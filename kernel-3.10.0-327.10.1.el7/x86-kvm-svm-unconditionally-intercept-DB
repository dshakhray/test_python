From bb9c30f104e6678ef99a7eeaa28ad93d524bc77c Mon Sep 17 00:00:00 2001
From: Paolo Bonzini <pbonzini@redhat.com>
Date: Tue, 10 Nov 2015 12:17:26 +0100
Subject: [x86] kvm: svm: unconditionally intercept #DB

Message-id: <1447157846-20086-1-git-send-email-pbonzini@redhat.com>
Patchwork-id: 126512
O-Subject: [RHEL7 PATCH] KVM: svm: unconditionally intercept #DB (CVE-2015-8104)
Bugzilla: 1279470
Z-Bugzilla: 1279469
CVE: CVE-2015-8104
RH-Acked-by: Laszlo Ersek <lersek@redhat.com>
RH-Acked-by: Bandan Das <bsd@redhat.com>

This is needed to avoid the possibility that the guest triggers
an infinite stream of #DB exceptions.

VMX is not affected: because it does not save DR6 in the VMCS,
it already intercepts #DB unconditionally.

Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from kvm/next commit cbdb967af3d54993f5814f1cee0ed311a055377d)

Signed-off-by: Alexander Gordeev <agordeev@redhat.com>

diff --git a/arch/x86/kvm/svm.c b/arch/x86/kvm/svm.c
index d31b0ff..3a31570 100644
--- a/arch/x86/kvm/svm.c
+++ b/arch/x86/kvm/svm.c
@@ -1107,6 +1107,7 @@ static void init_vmcb(struct vcpu_svm *svm)
  set_exception_intercept(svm, UD_VECTOR);
  set_exception_intercept(svm, MC_VECTOR);
  set_exception_intercept(svm, AC_VECTOR);
+ set_exception_intercept(svm, DB_VECTOR);
 
  set_intercept(svm, INTERCEPT_INTR);
  set_intercept(svm, INTERCEPT_NMI);
@@ -1641,20 +1642,13 @@ static void svm_set_segment(struct kvm_vcpu *vcpu,
  mark_dirty(svm->vmcb, VMCB_SEG);
 }
 
-static void update_db_bp_intercept(struct kvm_vcpu *vcpu)
+static void update_bp_intercept(struct kvm_vcpu *vcpu)
 {
  struct vcpu_svm *svm = to_svm(vcpu);
 
- clr_exception_intercept(svm, DB_VECTOR);
  clr_exception_intercept(svm, BP_VECTOR);
 
- if (svm->nmi_singlestep)
-  set_exception_intercept(svm, DB_VECTOR);
-
  if (vcpu->guest_debug & KVM_GUESTDBG_ENABLE) {
-  if (vcpu->guest_debug &
-      (KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP))
-   set_exception_intercept(svm, DB_VECTOR);
   if (vcpu->guest_debug & KVM_GUESTDBG_USE_SW_BP)
    set_exception_intercept(svm, BP_VECTOR);
  } else
@@ -1760,7 +1754,6 @@ static int db_interception(struct vcpu_svm *svm)
   if (!(svm->vcpu.guest_debug & KVM_GUESTDBG_SINGLESTEP))
    svm->vmcb->save.rflags &=
     ~(X86_EFLAGS_TF | X86_EFLAGS_RF);
-  update_db_bp_intercept(&svm->vcpu);
  }
 
  if (svm->vcpu.guest_debug &
@@ -3751,7 +3744,6 @@ static void enable_nmi_window(struct kvm_vcpu *vcpu)
   */
  svm->nmi_singlestep = true;
  svm->vmcb->save.rflags |= (X86_EFLAGS_TF | X86_EFLAGS_RF);
- update_db_bp_intercept(vcpu);
 }
 
 static int svm_set_tss_addr(struct kvm *kvm, unsigned int addr)
@@ -4368,7 +4360,7 @@ static struct kvm_x86_ops svm_x86_ops = {
  .vcpu_load = svm_vcpu_load,
  .vcpu_put = svm_vcpu_put,
 
- .update_db_bp_intercept = update_db_bp_intercept,
+ .update_db_bp_intercept = update_bp_intercept,
  .get_msr = svm_get_msr,
  .set_msr = svm_set_msr,
  .get_segment_base = svm_get_segment_base,
-- 
1.7.1