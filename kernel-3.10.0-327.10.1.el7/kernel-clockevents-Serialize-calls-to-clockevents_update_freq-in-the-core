From 7ec36db91b52f36ea04821c976b251488d295a4c Mon Sep 17 00:00:00 2001
From: Prarit Bhargava <prarit@redhat.com>
Date: Wed, 30 Sep 2015 17:52:34 +0200
Subject: [kernel] clockevents: Serialize calls to clockevents_update_freq() in the core

Message-id: <1443635555-6854-2-git-send-email-prarit@redhat.com>
Patchwork-id: 125173
O-Subject: [RHEL7.3 PATCH BZ 1265283 1/2] clockevents: Serialize calls to clockevents_update_freq() in the core
Bugzilla: 1265283
Z-Bugzilla: 1284043
RH-Acked-by: Steve Best <sbest@redhat.com>
RH-Acked-by: Jes Sorensen <Jes.Sorensen@redhat.com>
RH-Acked-by: Dean Nelson <dnelson@redhat.com>
RH-Acked-by: Tony Camuso <tcamuso@redhat.com>
RH-Acked-by: John Linville <linville@redhat.com>

Bugzilla: http://bugzilla.redhat.com/1265283

commit 627ee7947e2e83ba565c31c5c9373d6e364b1ecd
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Feb 3 14:34:31 2014 -0800

    clockevents: Serialize calls to clockevents_update_freq() in the core

    We can identify the broadcast device in the core and serialize all
    callers including interrupts on a different CPU against the update.
    Also, disabling interrupts is moved into the core allowing callers to
    leave interrutps enabled when calling clockevents_update_freq().

    Signed-off-by: Soren Brinkmann <soren.brinkmann@xilinx.com>
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: Soeren Brinkmann <soren.brinkmann@xilinx.com>
    Cc: Daniel Lezcano <daniel.lezcano@linaro.org>
    Cc: Michal Simek <michal.simek@xilinx.com>
    Link: http://lkml.kernel.org/r/1391466877-28908-2-git-send-email-soren.brinkmann@xilinx.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

Signed-off-by: Alexander Gordeev <agordeev@redhat.com>

diff --git a/kernel/time/clockevents.c b/kernel/time/clockevents.c
index 807e9d2..2176027 100644
--- a/kernel/time/clockevents.c
+++ b/kernel/time/clockevents.c
@@ -347,6 +347,16 @@ void clockevents_config_and_register(struct clock_event_device *dev,
 }
 EXPORT_SYMBOL_GPL(clockevents_config_and_register);
 
+int __clockevents_update_freq(struct clock_event_device *dev, u32 freq)
+{
+ clockevents_config(dev, freq);
+
+ if (dev->mode != CLOCK_EVT_MODE_ONESHOT)
+  return 0;
+
+ return clockevents_program_event(dev, dev->next_event, false);
+}
+
 /**
  * clockevents_update_freq - Update frequency and reprogram a clock event device.
  * @dev: device to modify
@@ -354,17 +364,22 @@ EXPORT_SYMBOL_GPL(clockevents_config_and_register);
  *
  * Reconfigure and reprogram a clock event device in oneshot
  * mode. Must be called on the cpu for which the device delivers per
- * cpu timer events with interrupts disabled!  Returns 0 on success,
- * -ETIME when the event is in the past.
+ * cpu timer events. If called for the broadcast device the core takes
+ * care of serialization.
+ *
+ * Returns 0 on success, -ETIME when the event is in the past.
  */
 int clockevents_update_freq(struct clock_event_device *dev, u32 freq)
 {
- clockevents_config(dev, freq);
-
- if (dev->mode != CLOCK_EVT_MODE_ONESHOT)
-  return 0;
+ unsigned long flags;
+ int ret;
 
- return clockevents_program_event(dev, dev->next_event, false);
+ local_irq_save(flags);
+ ret = tick_broadcast_update_freq(dev, freq);
+ if (ret == -ENODEV)
+  ret = __clockevents_update_freq(dev, freq);
+ local_irq_restore(flags);
+ return ret;
 }
 
 /*
diff --git a/kernel/time/tick-broadcast.c b/kernel/time/tick-broadcast.c
index 5eada99..a219e68 100644
--- a/kernel/time/tick-broadcast.c
+++ b/kernel/time/tick-broadcast.c
@@ -119,6 +119,19 @@ int tick_is_broadcast_device(struct clock_event_device *dev)
  return (dev && tick_broadcast_device.evtdev == dev);
 }
 
+int tick_broadcast_update_freq(struct clock_event_device *dev, u32 freq)
+{
+ int ret = -ENODEV;
+
+ if (tick_is_broadcast_device(dev)) {
+  raw_spin_lock(&tick_broadcast_lock);
+  ret = __clockevents_update_freq(dev, freq);
+  raw_spin_unlock(&tick_broadcast_lock);
+ }
+ return ret;
+}
+
+
 static void err_broadcast(const struct cpumask *mask)
 {
  pr_crit_once("Failed to broadcast timer tick. Some CPUs may be unresponsive.\n");
@@ -268,12 +281,8 @@ static void tick_do_broadcast(struct cpumask *mask)
  */
 static void tick_do_periodic_broadcast(void)
 {
- raw_spin_lock(&tick_broadcast_lock);
-
  cpumask_and(tmpmask, cpu_online_mask, tick_broadcast_mask);
  tick_do_broadcast(tmpmask);
-
- raw_spin_unlock(&tick_broadcast_lock);
 }
 
 /*
@@ -283,13 +292,15 @@ static void tick_handle_periodic_broadcast(struct clock_event_device *dev)
 {
  ktime_t next;
 
+ raw_spin_lock(&tick_broadcast_lock);
+
  tick_do_periodic_broadcast();
 
  /*
   * The device is in periodic mode. No reprogramming necessary:
   */
  if (dev->mode == CLOCK_EVT_MODE_PERIODIC)
-  return;
+  goto unlock;
 
  /*
   * Setup the next period for devices, which do not have
@@ -302,9 +313,11 @@ static void tick_handle_periodic_broadcast(struct clock_event_device *dev)
   next = ktime_add(next, tick_period);
 
   if (!clockevents_program_event(dev, next, false))
-   return;
+   goto unlock;
   tick_do_periodic_broadcast();
  }
+unlock:
+ raw_spin_unlock(&tick_broadcast_lock);
 }
 
 /*
diff --git a/kernel/time/tick-internal.h b/kernel/time/tick-internal.h
index b886039..4b57414 100644
--- a/kernel/time/tick-internal.h
+++ b/kernel/time/tick-internal.h
@@ -101,6 +101,7 @@ extern int tick_resume_broadcast(void);
 extern void tick_broadcast_init(void);
 extern void
 tick_set_periodic_handler(struct clock_event_device *dev, int broadcast);
+int tick_broadcast_update_freq(struct clock_event_device *dev, u32 freq);
 
 #else /* !BROADCAST */
 
@@ -123,6 +124,8 @@ static inline void tick_shutdown_broadcast(unsigned int *cpup) { }
 static inline void tick_suspend_broadcast(void) { }
 static inline int tick_resume_broadcast(void) { return 0; }
 static inline void tick_broadcast_init(void) { }
+static inline int tick_broadcast_update_freq(struct clock_event_device *dev,
+          u32 freq) { return -ENODEV; }
 
 /*
  * Set the periodic handler in non broadcast mode
@@ -144,6 +147,7 @@ static inline int tick_device_is_functional(struct clock_event_device *dev)
 
 #endif
 
+int __clockevents_update_freq(struct clock_event_device *dev, u32 freq);
 extern void do_timer(unsigned long ticks);
 extern void update_wall_time(void);
 
-- 
1.7.1