From 5c04c10dd47922bb63bb37d1c86cfeb7c519e5cb Mon Sep 17 00:00:00 2001
From: Prarit Bhargava <prarit@redhat.com>
Date: Thu, 12 Nov 2015 15:59:17 +0100
Subject: [cpufreq] intel_pstate: fix rounding error in max_freq_pct

Message-id: <1447343957-19886-1-git-send-email-prarit@redhat.com>
Patchwork-id: 126611
O-Subject: [RHEL7.3 PATCH BZ 1263866] cpufreq, intel_pstate.c, fix rounding error in max_freq_pct
Bugzilla: 1263866
Z-Bugzilla: 1281491
RH-Acked-by: Steve Best <sbest@redhat.com>
RH-Acked-by: Lenny Szubowicz <lszubowi@redhat.com>
RH-Acked-by: Jarod Wilson <jarod@redhat.com>

Build info:
Date: Thu Nov 12 10:46:13 EST 2015
Build OS: Red Hat Enterprise Linux Server release 7.2 (Maipo)
System name: intel-wildcatpass-05.khw.lab.eng.bos.redhat.com with -j88
Built on: kernel-3.10.0-328.el7
Arch built: ppc64 s390x x86_64

RHEL_only. (I will be pushing this upstream after further discussions with
Intel.  There may be some benefit in using the intel_pstate floating point
operations but I think that just obfuscates the problem.  There has been
some churn in this area in the past few weeks but it still seems broken
upstream.)

I have a Intel processor with a "normal" frequency (from /proc/cpuinfo)
of 2100MHz, and a max turbo frequency of 2600MHz.

cpupower frequency-set -g powersave --min 1200MHz --max 2100MHz

the max_freq_pct is set to 80.

However, 2100/2600 = .807, and because max_freq_pct is 80 the processors
will never reach 2100MHz.  When running a simple load test and monitoring the
processors will only reach a maximum of 1995MHz.

The problem is that division, by default, rounds down in the calculation
for max_freq_pct.  This patch extends the calculation to an additional
10th of a percent and rounds up to the nearest percent so that a better
value is returned.

Signed-off-by: Prarit Bhargava <prarit@redhat.com>

Cc: Lenny Szubowicz <lszubowi@redhat.com>
Cc: Steve Best <sbest@redhat.com>
Cc: Janet Morgan <jamorgan@redhat.com>
Signed-off-by: Alexander Gordeev <agordeev@redhat.com>

diff --git a/drivers/cpufreq/intel_pstate.c b/drivers/cpufreq/intel_pstate.c
index 59a248b..fd0b9a6 100644
--- a/drivers/cpufreq/intel_pstate.c
+++ b/drivers/cpufreq/intel_pstate.c
@@ -955,6 +955,8 @@ static unsigned int intel_pstate_get(unsigned int cpu_num)
 
 static int intel_pstate_set_policy(struct cpufreq_policy *policy)
 {
+ int max_policy_calc;
+
  if (!policy->cpuinfo.max_freq)
   return -ENODEV;
 
@@ -973,7 +975,9 @@ static int intel_pstate_set_policy(struct cpufreq_policy *policy)
  limits.min_perf_pct = clamp_t(int, limits.min_perf_pct, 0 , 100);
  limits.min_perf = div_fp(int_tofp(limits.min_perf_pct), int_tofp(100));
 
- limits.max_policy_pct = (policy->max * 100) / policy->cpuinfo.max_freq;
+ max_policy_calc = (policy->max * 1000) / policy->cpuinfo.max_freq;
+ limits.max_policy_pct = round_up(max_policy_calc, 10) / 10;
+
  limits.max_policy_pct = clamp_t(int, limits.max_policy_pct, 0 , 100);
  limits.max_perf_pct = min(limits.max_policy_pct, limits.max_sysfs_pct);
  limits.max_perf = div_fp(int_tofp(limits.max_perf_pct), int_tofp(100));
-- 
1.7.1