From b55eccd0319edbc8826e79181124fbafd5362e1e Mon Sep 17 00:00:00 2001
From: Hannes Frederic Sowa <hannes@redhat.com>
Date: Thu, 19 Nov 2015 10:44:14 +0100
Subject: [net] ipv6: update ip6_rt_last_gc every time GC is run

Message-id: <8874de6d50a62dfd527edac049082c4a0896426d.1447929850.git.hannes@redhat.com>
Patchwork-id: 127012
O-Subject: [RHEL7.3 net] ipv6: update ip6_rt_last_gc every time GC is run
Bugzilla: 1270092
Z-Bugzilla: 1285370
RH-Acked-by: Marcelo Leitner <mleitner@redhat.com>
RH-Acked-by: Jarod Wilson <jarod@redhat.com>
RH-Acked-by: Paolo Abeni <pabeni@redhat.com>
RH-Acked-by: David S. Miller <davem@redhat.com>
RH-Acked-by: Neil Horman <nhorman@redhat.com>

Bugzilla: https://bugzilla.redhat.com/show_bug.cgi?id=1270092
Upstream Status: 49a18d86f66d33a20144ecb5a34bba0d1856b260
Brew: http://brewweb.devel.redhat.com/brew/taskinfo?taskID=10123802

Upstream Commit:
commit 49a18d86f66d33a20144ecb5a34bba0d1856b260
Author: Michal Kubecek <mkubecek@suse.cz>
Date:   Thu Aug 1 10:04:24 2013 +0200

    ipv6: update ip6_rt_last_gc every time GC is run

    As pointed out by Eric Dumazet, net->ipv6.ip6_rt_last_gc should
    hold the last time garbage collector was run so that we should
    update it whenever fib6_run_gc() calls fib6_clean_all(), not only
    if we got there from ip6_dst_gc().

    Signed-off-by: Michal Kubecek <mkubecek@suse.cz>
    Signed-off-by: David S. Miller <davem@davemloft.net>

Signed-off-by: Hannes Frederic Sowa <hannes@redhat.com>
Signed-off-by: Jiri Benc <jbenc@redhat.com>
Signed-off-by: Alexander Gordeev <agordeev@redhat.com>

diff --git a/net/ipv6/ip6_fib.c b/net/ipv6/ip6_fib.c
index 97a2ef8..2c2fffa 100644
--- a/net/ipv6/ip6_fib.c
+++ b/net/ipv6/ip6_fib.c
@@ -1692,6 +1692,8 @@ static DEFINE_SPINLOCK(fib6_gc_lock);
 
 void fib6_run_gc(unsigned long expires, struct net *net, bool force)
 {
+ unsigned long now;
+
  if (force) {
   spin_lock_bh(&fib6_gc_lock);
  } else if (!spin_trylock_bh(&fib6_gc_lock)) {
@@ -1704,10 +1706,12 @@ void fib6_run_gc(unsigned long expires, struct net *net, bool force)
  gc_args.more = icmp6_dst_gc();
 
  fib6_clean_all(net, fib6_age, NULL);
+ now = jiffies;
+ net->ipv6.ip6_rt_last_gc = now;
 
  if (gc_args.more)
   mod_timer(&net->ipv6.ip6_fib_timer,
-     round_jiffies(jiffies
+     round_jiffies(now
      + net->ipv6.sysctl.ip6_rt_gc_interval));
  else
   del_timer(&net->ipv6.ip6_fib_timer);
diff --git a/net/ipv6/route.c b/net/ipv6/route.c
index 2d007c5..d39e100 100644
--- a/net/ipv6/route.c
+++ b/net/ipv6/route.c
@@ -1422,7 +1422,6 @@ static void icmp6_clean_all(int (*func)(struct rt6_info *rt, void *arg),
 
 static int ip6_dst_gc(struct dst_ops *ops)
 {
- unsigned long now = jiffies;
  struct net *net = container_of(ops, struct net, ipv6.ip6_dst_ops);
  int rt_min_interval = net->ipv6.sysctl.ip6_rt_gc_min_interval;
  int rt_max_size = net->ipv6.sysctl.ip6_rt_max_size;
@@ -1432,13 +1431,12 @@ static int ip6_dst_gc(struct dst_ops *ops)
  int entries;
 
  entries = dst_entries_get_fast(ops);
- if (time_after(rt_last_gc + rt_min_interval, now) &&
+ if (time_after(rt_last_gc + rt_min_interval, jiffies) &&
      entries <= rt_max_size)
   goto out;
 
  net->ipv6.ip6_rt_gc_expire++;
  fib6_run_gc(net->ipv6.ip6_rt_gc_expire, net, entries > rt_max_size);
- net->ipv6.ip6_rt_last_gc = now;
  entries = dst_entries_get_slow(ops);
  if (entries < ops->gc_thresh)
   net->ipv6.ip6_rt_gc_expire = rt_gc_timeout>>1;
-- 
1.7.1