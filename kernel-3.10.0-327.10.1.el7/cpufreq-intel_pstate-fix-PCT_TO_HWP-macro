From 63a8f363eb3a7bdeeede48a772daa73578caa24b Mon Sep 17 00:00:00 2001
From: Prarit Bhargava <prarit@redhat.com>
Date: Wed, 21 Oct 2015 13:34:53 +0200
Subject: [cpufreq] intel_pstate: fix PCT_TO_HWP macro

Message-id: <1445434493-19829-4-git-send-email-prarit@redhat.com>
Patchwork-id: 125838
O-Subject: [RHEL7.3 PATCH BZ 1264990 3/3] intel_pstate: fix PCT_TO_HWP macro
Bugzilla: 1264990
Z-Bugzilla: 1273926
RH-Acked-by: Steve Best <sbest@redhat.com>
RH-Acked-by: Jerry Snitselaar <jsnitsel@redhat.com>
RH-Acked-by: Stefan Assmann <sassmann@redhat.com>

Bugzilla: http://bugzilla.redhat.com/1264990

commit 74da56ce5c6715630aed3ccc0fcb86a9210c1a56
Author: Kristen Carlson Accardi <kristen@linux.intel.com>
Date:   Wed Sep 9 11:41:22 2015 -0700

    intel_pstate: fix PCT_TO_HWP macro

    PCT_TO_HWP does not take the actual range of pstates exported
    by HWP_CAPABILITIES in account, and is broken on most platforms.
    Remove the macro and set the min and max pstate for hwp by
    determining the range and adjusting by the min and max percent
    limits values.

    Signed-off-by: Kristen Carlson Accardi <kristen@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

Cc: Lenny Szubowicz <lszubowi@redhat.com>
Cc: Steve Best <sbest@redhat.com>
Signed-off-by: Alexander Gordeev <agordeev@redhat.com>

diff --git a/drivers/cpufreq/intel_pstate.c b/drivers/cpufreq/intel_pstate.c
index 1d385c0..59a248b 100644
--- a/drivers/cpufreq/intel_pstate.c
+++ b/drivers/cpufreq/intel_pstate.c
@@ -252,24 +252,31 @@ static inline void update_turbo_state(void)
    cpu->pstate.max_pstate == cpu->pstate.turbo_pstate);
 }
 
-#define PCT_TO_HWP(x) (x * 255 / 100)
 static void intel_pstate_hwp_set(void)
 {
- int min, max, cpu;
- u64 value, freq;
+ int min, hw_min, max, hw_max, cpu, range, adj_range;
+ u64 value, cap;
+
+ rdmsrl(MSR_HWP_CAPABILITIES, cap);
+ hw_min = HWP_LOWEST_PERF(cap);
+ hw_max = HWP_HIGHEST_PERF(cap);
+ range = hw_max - hw_min;
 
  get_online_cpus();
 
  for_each_online_cpu(cpu) {
   rdmsrl_on_cpu(cpu, MSR_HWP_REQUEST, &value);
-  min = PCT_TO_HWP(limits.min_perf_pct);
+  adj_range = limits.min_perf_pct * range / 100;
+  min = hw_min + adj_range;
   value &= ~HWP_MIN_PERF(~0L);
   value |= HWP_MIN_PERF(min);
 
-  max = PCT_TO_HWP(limits.max_perf_pct);
+  adj_range = limits.max_perf_pct * range / 100;
+  max = hw_min + adj_range;
   if (limits.no_turbo) {
-   rdmsrl( MSR_HWP_CAPABILITIES, freq);
-   max = HWP_GUARANTEED_PERF(freq);
+   hw_max = HWP_GUARANTEED_PERF(cap);
+   if (hw_max < max)
+    max = hw_max;
   }
 
   value &= ~HWP_MAX_PERF(~0L);
-- 
1.7.1