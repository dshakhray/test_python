From e45b0c596ebf2552c5ceecc136e3c80fe425ba0a Mon Sep 17 00:00:00 2001
From: Bandan Das <bsd@redhat.com>
Date: Mon, 19 Oct 2015 18:02:12 +0200
Subject: [x86] kvm: mmu: fix validation of mmio page fault

Message-id: <jpgh9lmhh3v.fsf@linux.bootlegged.copy>
Patchwork-id: 125783
O-Subject: [RHEL-7.3 PATCH] KVM: MMU: fix validation of mmio page fault
Bugzilla: 1267128
Z-Bugzilla: 1275150
RH-Acked-by: Radim Krcmar <rkrcmar@redhat.com>
RH-Acked-by: Paolo Bonzini <pbonzini@redhat.com>

Bugzilla: https://bugzilla.redhat.com/show_bug.cgi?id=1267128
Brew: http://brewweb.devel.redhat.com/brew/taskinfo?taskID=9975971

From: Xiao Guangrong <guangrong xiao linux intel com>

We got the bug that qemu complained with "KVM: unknown exit, hardware
reason 31" and KVM shown these info:
[84245.284948] EPT: Misconfiguration.
[84245.285056] EPT: GPA: 0xfeda848
[84245.285154] ept_misconfig_inspect_spte: spte 0x5eaef50107 level 4
[84245.285344] ept_misconfig_inspect_spte: spte 0x5f5fadc107 level 3
[84245.285532] ept_misconfig_inspect_spte: spte 0x5141d18107 level 2
[84245.285723] ept_misconfig_inspect_spte: spte 0x52e40dad77 level 1

This is because we got a mmio #PF and the handler see the mmio spte becomes
normal (points to the ram page)

However, this is valid after introducing fast mmio spte invalidation which
increases the generation-number instead of zapping mmio sptes, a example
is as follows:
1. QEMU drops mmio region by adding a new memslot
2. invalidate all mmio sptes
3.

        VCPU 0                        VCPU 1
    access the invalid mmio spte
                            access the region originally was MMIO before
                            set the spte to the normal ram map

    mmio #PF
    check the spte and see it becomes normal ram mapping !!!

This patch fixes the bug just by dropping the check in mmio handler, it's
good for backport. Full check will be introduced in later patches

Reported-by: Pavel Shirshov <ru.pchel@gmail.com>
Tested-by: Pavel Shirshov <ru.pchel@gmail.com>
Signed-off-by: Xiao Guangrong <guangrong.xiao@linux.intel.com>
Cc: stable@vger.kernel.org
Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 6f691251c0350ac52a007c54bf3ef62e9d8cdc5e)

RHEL7 Notes:
This is the first patch of the series that just removes the check.
It was pointed out in the review[1] that some of the changes led to
buggy behavior on AMD systems.
[1] http://post-office.corp.redhat.com/archives/rhkernel-list/2015-October/msg00877.html

Signed-off-by: Alexander Gordeev <agordeev@redhat.com>

diff --git a/arch/x86/kvm/mmu.c b/arch/x86/kvm/mmu.c
index bcc518a..2fd6e94 100644
--- a/arch/x86/kvm/mmu.c
+++ b/arch/x86/kvm/mmu.c
@@ -357,12 +357,6 @@ static u64 __get_spte_lockless(u64 *sptep)
 {
  return ACCESS_ONCE(*sptep);
 }
-
-static bool __check_direct_spte_mmio_pf(u64 spte)
-{
- /* It is valid if the spte is zapped. */
- return spte == 0ull;
-}
 #else
 union split_spte {
  struct {
@@ -478,23 +472,6 @@ retry:
 
  return spte.spte;
 }
-
-static bool __check_direct_spte_mmio_pf(u64 spte)
-{
- union split_spte sspte = (union split_spte)spte;
- u32 high_mmio_mask = shadow_mmio_mask >> 32;
-
- /* It is valid if the spte is zapped. */
- if (spte == 0ull)
-  return true;
-
- /* It is valid if the spte is being zapped. */
- if (sspte.spte_low == 0ull &&
-     (sspte.spte_high & high_mmio_mask) == high_mmio_mask)
-  return true;
-
- return false;
-}
 #endif
 
 static bool spte_is_locklessly_modifiable(u64 spte)
@@ -3385,21 +3362,6 @@ static bool quickly_check_mmio_pf(struct kvm_vcpu *vcpu, u64 addr, bool direct)
  return vcpu_match_mmio_gva(vcpu, addr);
 }
 
-
-/*
- * On direct hosts, the last spte is only allows two states
- * for mmio page fault:
- *   - It is the mmio spte
- *   - It is zapped or it is being zapped.
- *
- * This function completely checks the spte when the last spte
- * is not the mmio spte.
- */
-static bool check_direct_spte_mmio_pf(u64 spte)
-{
- return __check_direct_spte_mmio_pf(spte);
-}
-
 static u64 walk_shadow_page_get_mmio_spte(struct kvm_vcpu *vcpu, u64 addr)
 {
  struct kvm_shadow_walk_iterator iterator;
@@ -3442,13 +3404,6 @@ int handle_mmio_page_fault_common(struct kvm_vcpu *vcpu, u64 addr, bool direct)
  }
 
  /*
-  * It's ok if the gva is remapped by other cpus on shadow guest,
-  * it's a BUG if the gfn is not a mmio page.
-  */
- if (direct && !check_direct_spte_mmio_pf(spte))
-  return RET_MMIO_PF_BUG;
-
- /*
   * If the page table is zapped by other cpus, let CPU fault again on
   * the address.
   */
-- 
1.7.1