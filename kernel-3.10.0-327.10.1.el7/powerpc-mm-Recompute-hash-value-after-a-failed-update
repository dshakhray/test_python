From 6064d36bcf0f8f173455fd07f2a03d4c04bd4c90 Mon Sep 17 00:00:00 2001
From: Gustavo Duarte <gduarte@redhat.com>
Date: Wed, 4 Nov 2015 21:17:14 +0100
Subject: [powerpc] mm: Recompute hash value after a failed update

Message-id: <1446671834-24448-1-git-send-email-gduarte@redhat.com>
Patchwork-id: 126220
O-Subject: [RHEL7.2 PATCH BZ 1264920] powerpc/mm: Recompute hash value after a failed update
Bugzilla: 1264920
Z-Bugzilla: 1289452
RH-Acked-by: Steve Best <sbest@redhat.com>
RH-Acked-by: Stefan Assmann <sassmann@redhat.com>
RH-Acked-by: Don Zickus <dzickus@redhat.com>

commit 36b35d5d807b7e57aff7d08e63de8b17731ee211
Author: Aneesh Kumar K.V <aneesh.kumar@linux.vnet.ibm.com>
Date:   Tue Sep 15 12:30:08 2015 +0530

    powerpc/mm: Recompute hash value after a failed update

    If we had secondary hash flag set, we ended up modifying hash value in
    the updatepp code path. Hence with a failed updatepp we will be using
    a wrong hash value for the following hash insert. Fix this by
    recomputing hash before insert.

    Without this patch we can end up with using wrong slot number in linux
    pte. That can result in us missing an hash pte update or invalidate
    which can cause memory corruption or even machine check.

    Fixes: 6d492ecc6489 ("powerpc/THP: Add code to handle HPTE faults for hugepages")
    Cc: stable@vger.kernel.org # v3.11+
    Signed-off-by: Aneesh Kumar K.V <aneesh.kumar@linux.vnet.ibm.com>
    Reviewed-by: Paul Mackerras <paulus@samba.org>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

Signed-off-by: Alexander Gordeev <agordeev@redhat.com>

diff --git a/arch/powerpc/mm/hugepage-hash64.c b/arch/powerpc/mm/hugepage-hash64.c
index edecf93..211bc30 100644
--- a/arch/powerpc/mm/hugepage-hash64.c
+++ b/arch/powerpc/mm/hugepage-hash64.c
@@ -136,7 +136,6 @@ int __hash_page_thp(unsigned long ea, unsigned long access, unsigned long vsid,
  BUG_ON(index >= 4096);
 
  vpn = hpt_vpn(ea, vsid, ssize);
- hash = hpt_hash(vpn, shift, ssize);
  hpte_slot_array = get_hpte_slot_array(pmdp);
  if (psize == MMU_PAGE_4K) {
   /*
@@ -151,6 +150,7 @@ int __hash_page_thp(unsigned long ea, unsigned long access, unsigned long vsid,
  valid = hpte_valid(hpte_slot_array, index);
  if (valid) {
   /* update the hpte bits */
+  hash = hpt_hash(vpn, shift, ssize);
   hidx =  hpte_hash_index(hpte_slot_array, index);
   if (hidx & _PTEIDX_SECONDARY)
    hash = ~hash;
@@ -176,6 +176,7 @@ int __hash_page_thp(unsigned long ea, unsigned long access, unsigned long vsid,
  if (!valid) {
   unsigned long hpte_group;
 
+  hash = hpt_hash(vpn, shift, ssize);
   /* insert new entry */
   pa = pmd_pfn(__pmd(old_pmd)) << PAGE_SHIFT;
   new_pmd |= _PAGE_HASHPTE;
-- 
1.7.1