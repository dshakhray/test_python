From 70bff951913ecef184dd7457a234b3dbdc23e105 Mon Sep 17 00:00:00 2001
From: Herton R. Krzesinski <herton@redhat.com>
Date: Wed, 18 May 2016 06:41:05 +0200
Subject: [kernel] sched: Guarantee new group-entities always have weight

Message-id: <1463553686-8136-5-git-send-email-herton@redhat.com>
Patchwork-id: 145568
O-Subject: [RHEL7 PATCH 04/25] sched: Guarantee new group-entities always have weight
Bugzilla: 1336863
Z-Bugzilla: 1370157
RH-Acked-by: Jiri Olsa <jolsa@redhat.com>
RH-Acked-by: Rafael Aquini <aquini@redhat.com>

Bugzilla: https://bugzilla.redhat.com/show_bug.cgi?id=1336863
Upstream Status: commit 0ac9b1c, linux-stable commit 5ba4542
Build Info: https://brewweb.engineering.redhat.com/brew/taskinfo?taskID=11035443
Tested: kt1 (looking for consistent regressions) and with test case on the bug

commit 5ba4542368ccbbb717426505c0fb801233f9110a
Author: Paul Turner <pjt@google.com>
Date:   Wed Oct 16 11:16:27 2013 -0700

    sched: Guarantee new group-entities always have weight

    commit 0ac9b1c21874d2490331233b3242085f8151e166 upstream.

    Currently, group entity load-weights are initialized to zero. This
    admits some races with respect to the first time they are re-weighted in
    earlty use. ( Let g[x] denote the se for "g" on cpu "x". )

    Suppose that we have root->a and that a enters a throttled state,
    immediately followed by a[0]->t1 (the only task running on cpu[0])
    blocking:

      put_prev_task(group_cfs_rq(a[0]), t1)
      put_prev_entity(..., t1)
      check_cfs_rq_runtime(group_cfs_rq(a[0]))
      throttle_cfs_rq(group_cfs_rq(a[0]))

    Then, before unthrottling occurs, let a[0]->b[0]->t2 wake for the first
    time:

      enqueue_task_fair(rq[0], t2)
      enqueue_entity(group_cfs_rq(b[0]), t2)
      enqueue_entity_load_avg(group_cfs_rq(b[0]), t2)
      account_entity_enqueue(group_cfs_ra(b[0]), t2)
      update_cfs_shares(group_cfs_rq(b[0]))
      < skipped because b is part of a throttled hierarchy >
      enqueue_entity(group_cfs_rq(a[0]), b[0])
      ...

    We now have b[0] enqueued, yet group_cfs_rq(a[0])->load.weight == 0
    which violates invariants in several code-paths. Eliminate the
    possibility of this by initializing group entity weight.

    Signed-off-by: Paul Turner <pjt@google.com>
    Signed-off-by: Peter Zijlstra <peterz@infradead.org>
    Link: http://lkml.kernel.org/r/20131016181627.22647.47543.stgit@sword-of-the-dawn.mtv.corp.google.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Cc: Chris J Arges <chris.j.arges@canonical.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

Signed-off-by: Herton R. Krzesinski <herton@redhat.com>
Signed-off-by: Alexander Gordeev <agordeev@redhat.com>

diff --git a/kernel/sched/fair.c b/kernel/sched/fair.c
index 44316bb..3e3ff30 100644
--- a/kernel/sched/fair.c
+++ b/kernel/sched/fair.c
@@ -7411,7 +7411,8 @@ void init_tg_cfs_entry(struct task_group *tg, struct cfs_rq *cfs_rq,
   se->cfs_rq = parent->my_q;
 
  se->my_q = cfs_rq;
- update_load_set(&se->load, 0);
+ /* guarantee group entities always have weight */
+ update_load_set(&se->load, NICE_0_LOAD);
  se->parent = parent;
 }
 
-- 
1.7.1