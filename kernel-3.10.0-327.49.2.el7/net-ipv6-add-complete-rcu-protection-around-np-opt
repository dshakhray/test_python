From b4a3cba0e0115ad8d17b06847b94501356c5bd57 Mon Sep 17 00:00:00 2001
From: Aaron Conole <aconole@redhat.com>
Date: Tue, 26 Jan 2016 16:17:42 +0100
Subject: [net] ipv6: add complete rcu protection around np->opt

Message-id: <1453825062-4894-1-git-send-email-aconole@redhat.com>
Patchwork-id: 133254
O-Subject: [RHEL7.3 net PATCH v2 1/3] ipv6: add complete rcu protection around np->opt
Bugzilla: 1286695
Z-Bugzilla: 1374026
RH-Acked-by: Sabrina Dubroca <sdubroca@redhat.com>
RH-Acked-by: Marcelo Leitner <mleitner@redhat.com>
RH-Acked-by: Paolo Abeni <pabeni@redhat.com>

Bugzilla: https://bugzilla.redhat.com/show_bug.cgi?id=1286695
Brew: https://brewweb.devel.redhat.com/taskinfo?taskID=10380750
Tested: on netdev25

This did not apply cleanly for the following two commits:
commit: 53b24b8f94cb ("ipv6: coding style: comparison for inequality
with NULL")
commit: 86fe8f892013 ("ipv6: remove useless spin_lock/spin_unlock")

Upstream commit:
commit 45f6fad84cc305103b28d73482b344d7f5b76f39
Author: Eric Dumazet <edumazet@google.com>
Date:   Sun Nov 29 19:37:57 2015 -0800

    ipv6: add complete rcu protection around np->opt

    This patch addresses multiple problems :

    UDP/RAW sendmsg() need to get a stable struct ipv6_txoptions
    while socket is not locked : Other threads can change np->opt
    concurrently. Dmitry posted a syzkaller
    (http://github.com/google/syzkaller) program desmonstrating
    use-after-free.

    Starting with TCP/DCCP lockless listeners, tcp_v6_syn_recv_sock()
    and dccp_v6_request_recv_sock() also need to use RCU protection
    to dereference np->opt once (before calling ipv6_dup_options())

    This patch adds full RCU protection to np->opt

    Reported-by: Dmitry Vyukov <dvyukov@google.com>
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Acked-by: Hannes Frederic Sowa <hannes@stressinduktion.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

Signed-off-by: Aaron Conole <aconole@redhat.com>
Signed-off-by: Jiri Benc <jbenc@redhat.com>
Signed-off-by: Alexander Gordeev <agordeev@redhat.com>

diff --git a/include/linux/ipv6.h b/include/linux/ipv6.h
index d6569da..5e190a7 100644
--- a/include/linux/ipv6.h
+++ b/include/linux/ipv6.h
@@ -213,7 +213,7 @@ struct ipv6_pinfo {
  struct ipv6_ac_socklist *ipv6_ac_list;
  struct ipv6_fl_socklist __rcu *ipv6_fl_list;
 
- struct ipv6_txoptions *opt;
+ struct ipv6_txoptions __rcu *opt;
  struct sk_buff  *pktoptions;
  struct sk_buff  *rxpmtu;
  struct inet6_cork cork;
diff --git a/include/net/ipv6.h b/include/net/ipv6.h
index 7464189..6547012 100644
--- a/include/net/ipv6.h
+++ b/include/net/ipv6.h
@@ -203,6 +203,7 @@ extern rwlock_t ip6_ra_lock;
  */
 
 struct ipv6_txoptions {
+ atomic_t  refcnt;
  /* Length of this structure */
  int   tot_len;
 
@@ -215,7 +216,7 @@ struct ipv6_txoptions {
  struct ipv6_opt_hdr *dst0opt;
  struct ipv6_rt_hdr *srcrt; /* Routing Header */
  struct ipv6_opt_hdr *dst1opt;
-
+ struct rcu_head  rcu;
  /* Option buffer, as read by IPV6_PKTOPTIONS, starts here. */
 };
 
@@ -247,6 +248,24 @@ struct ipv6_fl_socklist {
  struct rcu_head   rcu;
 };
 
+static inline struct ipv6_txoptions *txopt_get(const struct ipv6_pinfo *np)
+{
+ struct ipv6_txoptions *opt;
+
+ rcu_read_lock();
+ opt = rcu_dereference(np->opt);
+ if (opt && !atomic_inc_not_zero(&opt->refcnt))
+  opt = NULL;
+ rcu_read_unlock();
+ return opt;
+}
+
+static inline void txopt_put(struct ipv6_txoptions *opt)
+{
+ if (opt && atomic_dec_and_test(&opt->refcnt))
+  kfree_rcu(opt, rcu);
+}
+
 struct ip6_flowlabel *fl6_sock_lookup(struct sock *sk, __be32 label);
 struct ipv6_txoptions *fl6_merge_options(struct ipv6_txoptions *opt_space,
       struct ip6_flowlabel *fl,
diff --git a/net/dccp/ipv6.c b/net/dccp/ipv6.c
index 7ee29ac..ba1638f 100644
--- a/net/dccp/ipv6.c
+++ b/net/dccp/ipv6.c
@@ -238,7 +238,9 @@ static int dccp_v6_send_response(struct sock *sk, struct request_sock *req)
  security_req_classify_flow(req, flowi6_to_flowi(&fl6));
 
 
- final_p = fl6_update_dst(&fl6, np->opt, &final);
+ rcu_read_lock();
+ final_p = fl6_update_dst(&fl6, rcu_dereference(np->opt), &final);
+ rcu_read_unlock();
 
  dst = ip6_dst_lookup_flow(sk, &fl6, final_p);
  if (IS_ERR(dst)) {
@@ -255,7 +257,10 @@ static int dccp_v6_send_response(struct sock *sk, struct request_sock *req)
         &ireq->ir_v6_loc_addr,
         &ireq->ir_v6_rmt_addr);
   fl6.daddr = ireq->ir_v6_rmt_addr;
-  err = ip6_xmit(sk, skb, &fl6, np->opt, np->tclass);
+  rcu_read_lock();
+  err = ip6_xmit(sk, skb, &fl6, rcu_dereference(np->opt),
+          np->tclass);
+  rcu_read_unlock();
   err = net_xmit_eval(err);
  }
 
@@ -450,6 +455,7 @@ static struct sock *dccp_v6_request_recv_sock(struct sock *sk,
 {
  struct inet_request_sock *ireq = inet_rsk(req);
  struct ipv6_pinfo *newnp, *np = inet6_sk(sk);
+ struct ipv6_txoptions *opt;
  struct inet_sock *newinet;
  struct dccp6_sock *newdp6;
  struct sock *newsk;
@@ -573,13 +579,15 @@ static struct sock *dccp_v6_request_recv_sock(struct sock *sk,
   * Yes, keeping reference count would be much more clever, but we make
   * one more one thing there: reattach optmem to newsk.
   */
- if (np->opt != NULL)
-  newnp->opt = ipv6_dup_options(newsk, np->opt);
-
+ opt = rcu_dereference(np->opt);
+ if (opt) {
+  opt = ipv6_dup_options(newsk, opt);
+  RCU_INIT_POINTER(newnp->opt, opt);
+ }
  inet_csk(newsk)->icsk_ext_hdr_len = 0;
- if (newnp->opt != NULL)
-  inet_csk(newsk)->icsk_ext_hdr_len = (newnp->opt->opt_nflen +
-           newnp->opt->opt_flen);
+ if (opt)
+  inet_csk(newsk)->icsk_ext_hdr_len = opt->opt_nflen +
+          opt->opt_flen;
 
  dccp_sync_mss(newsk, dst_mtu(dst));
 
@@ -831,6 +839,7 @@ static int dccp_v6_connect(struct sock *sk, struct sockaddr *uaddr,
  struct ipv6_pinfo *np = inet6_sk(sk);
  struct dccp_sock *dp = dccp_sk(sk);
  struct in6_addr *saddr = NULL, *final_p, final;
+ struct ipv6_txoptions *opt;
  struct flowi6 fl6;
  struct dst_entry *dst;
  int addr_type;
@@ -933,7 +942,8 @@ static int dccp_v6_connect(struct sock *sk, struct sockaddr *uaddr,
  fl6.fl6_sport = inet->inet_sport;
  security_sk_classify_flow(sk, flowi6_to_flowi(&fl6));
 
- final_p = fl6_update_dst(&fl6, np->opt, &final);
+ opt = rcu_dereference_protected(np->opt, sock_owned_by_user(sk));
+ final_p = fl6_update_dst(&fl6, opt, &final);
 
  dst = ip6_dst_lookup_flow(sk, &fl6, final_p);
  if (IS_ERR(dst)) {
@@ -953,9 +963,8 @@ static int dccp_v6_connect(struct sock *sk, struct sockaddr *uaddr,
  __ip6_dst_store(sk, dst, NULL, NULL);
 
  icsk->icsk_ext_hdr_len = 0;
- if (np->opt != NULL)
-  icsk->icsk_ext_hdr_len = (np->opt->opt_flen +
-       np->opt->opt_nflen);
+ if (opt)
+  icsk->icsk_ext_hdr_len = opt->opt_flen + opt->opt_nflen;
 
  inet->inet_dport = usin->sin6_port;
 
diff --git a/net/ipv6/af_inet6.c b/net/ipv6/af_inet6.c
index d6f2299..714e680 100644
--- a/net/ipv6/af_inet6.c
+++ b/net/ipv6/af_inet6.c
@@ -425,9 +425,11 @@ void inet6_destroy_sock(struct sock *sk)
 
  /* Free tx options */
 
- opt = xchg(&np->opt, NULL);
- if (opt != NULL)
-  sock_kfree_s(sk, opt, opt->tot_len);
+ opt = xchg((__force struct ipv6_txoptions **)&np->opt, NULL);
+ if (opt) {
+  atomic_sub(opt->tot_len, &sk->sk_omem_alloc);
+  txopt_put(opt);
+ }
 }
 EXPORT_SYMBOL_GPL(inet6_destroy_sock);
 
@@ -656,7 +658,10 @@ int inet6_sk_rebuild_header(struct sock *sk)
   fl6.fl6_sport = inet->inet_sport;
   security_sk_classify_flow(sk, flowi6_to_flowi(&fl6));
 
-  final_p = fl6_update_dst(&fl6, np->opt, &final);
+  rcu_read_lock();
+  final_p = fl6_update_dst(&fl6, rcu_dereference(np->opt),
+      &final);
+  rcu_read_unlock();
 
   dst = ip6_dst_lookup_flow(sk, &fl6, final_p);
   if (IS_ERR(dst)) {
diff --git a/net/ipv6/datagram.c b/net/ipv6/datagram.c
index 8cbab37..e5e5b21 100644
--- a/net/ipv6/datagram.c
+++ b/net/ipv6/datagram.c
@@ -168,8 +168,10 @@ ipv4_connected:
 
  security_sk_classify_flow(sk, flowi6_to_flowi(&fl6));
 
- opt = flowlabel ? flowlabel->opt : np->opt;
+ rcu_read_lock();
+ opt = flowlabel ? flowlabel->opt : rcu_dereference(np->opt);
  final_p = fl6_update_dst(&fl6, opt, &final);
+ rcu_read_unlock();
 
  dst = ip6_dst_lookup_flow(sk, &fl6, final_p);
  err = 0;
diff --git a/net/ipv6/exthdrs.c b/net/ipv6/exthdrs.c
index 8d67900..33dbd6c 100644
--- a/net/ipv6/exthdrs.c
+++ b/net/ipv6/exthdrs.c
@@ -727,6 +727,7 @@ ipv6_dup_options(struct sock *sk, struct ipv6_txoptions *opt)
    *((char **)&opt2->dst1opt) += dif;
   if (opt2->srcrt)
    *((char **)&opt2->srcrt) += dif;
+  atomic_set(&opt2->refcnt, 1);
  }
  return opt2;
 }
@@ -790,7 +791,7 @@ ipv6_renew_options(struct sock *sk, struct ipv6_txoptions *opt,
   return ERR_PTR(-ENOBUFS);
 
  memset(opt2, 0, tot_len);
-
+ atomic_set(&opt2->refcnt, 1);
  opt2->tot_len = tot_len;
  p = (char *)(opt2 + 1);
 
diff --git a/net/ipv6/inet6_connection_sock.c b/net/ipv6/inet6_connection_sock.c
index c913818..0e08e1b 100644
--- a/net/ipv6/inet6_connection_sock.c
+++ b/net/ipv6/inet6_connection_sock.c
@@ -78,7 +78,9 @@ struct dst_entry *inet6_csk_route_req(struct sock *sk,
  memset(fl6, 0, sizeof(*fl6));
  fl6->flowi6_proto = IPPROTO_TCP;
  fl6->daddr = ireq->ir_v6_rmt_addr;
- final_p = fl6_update_dst(fl6, np->opt, &final);
+ rcu_read_lock();
+ final_p = fl6_update_dst(fl6, rcu_dereference(np->opt), &final);
+ rcu_read_unlock();
  fl6->saddr = ireq->ir_v6_loc_addr;
  fl6->flowi6_oif = ireq->ir_iif;
  fl6->flowi6_mark = sk->sk_mark;
@@ -212,7 +214,9 @@ static struct dst_entry *inet6_csk_route_socket(struct sock *sk,
  fl6->fl6_dport = inet->inet_dport;
  security_sk_classify_flow(sk, flowi6_to_flowi(fl6));
 
- final_p = fl6_update_dst(fl6, np->opt, &final);
+ rcu_read_lock();
+ final_p = fl6_update_dst(fl6, rcu_dereference(np->opt), &final);
+ rcu_read_unlock();
 
  dst = __inet6_csk_dst_check(sk, np->dst_cookie);
  if (!dst) {
@@ -246,7 +250,8 @@ int inet6_csk_xmit(struct sk_buff *skb, struct flowi *fl_unused)
  /* Restore final destination back after routing done */
  fl6.daddr = sk->sk_v6_daddr;
 
- res = ip6_xmit(sk, skb, &fl6, np->opt, np->tclass);
+ res = ip6_xmit(sk, skb, &fl6, rcu_dereference(np->opt),
+         np->tclass);
  rcu_read_unlock();
  return res;
 }
diff --git a/net/ipv6/ipv6_sockglue.c b/net/ipv6/ipv6_sockglue.c
index 4b42ed6..374c8b7 100644
--- a/net/ipv6/ipv6_sockglue.c
+++ b/net/ipv6/ipv6_sockglue.c
@@ -110,10 +110,10 @@ struct ipv6_txoptions *ipv6_update_options(struct sock *sk,
    icsk->icsk_ext_hdr_len = opt->opt_flen + opt->opt_nflen;
    icsk->icsk_sync_mss(sk, icsk->icsk_pmtu_cookie);
   }
-  opt = xchg(&inet6_sk(sk)->opt, opt);
+  opt = xchg((__force struct ipv6_txoptions **)&inet6_sk(sk)->opt, opt);
  } else {
   spin_lock(&sk->sk_dst_lock);
-  opt = xchg(&inet6_sk(sk)->opt, opt);
+  opt = xchg((__force struct ipv6_txoptions **)&inet6_sk(sk)->opt, opt);
   spin_unlock(&sk->sk_dst_lock);
  }
  sk_dst_reset(sk);
@@ -235,9 +235,12 @@ static int do_ipv6_setsockopt(struct sock *sk, int level, int optname,
     sk->sk_socket->ops = &inet_dgram_ops;
     sk->sk_family = PF_INET;
    }
-   opt = xchg(&np->opt, NULL);
-   if (opt)
-    sock_kfree_s(sk, opt, opt->tot_len);
+   opt = xchg((__force struct ipv6_txoptions **)&np->opt,
+       NULL);
+   if (opt) {
+    atomic_sub(opt->tot_len, &sk->sk_omem_alloc);
+    txopt_put(opt);
+   }
    pktopt = xchg(&np->pktoptions, NULL);
    kfree_skb(pktopt);
 
@@ -407,7 +410,8 @@ static int do_ipv6_setsockopt(struct sock *sk, int level, int optname,
   if (optname != IPV6_RTHDR && !ns_capable(net->user_ns, CAP_NET_RAW))
    break;
 
-  opt = ipv6_renew_options(sk, np->opt, optname,
+  opt = rcu_dereference_protected(np->opt, sock_owned_by_user(sk));
+  opt = ipv6_renew_options(sk, opt, optname,
       (struct ipv6_opt_hdr __user *)optval,
       optlen);
   if (IS_ERR(opt)) {
@@ -436,8 +440,10 @@ static int do_ipv6_setsockopt(struct sock *sk, int level, int optname,
   retv = 0;
   opt = ipv6_update_options(sk, opt);
 sticky_done:
-  if (opt)
-   sock_kfree_s(sk, opt, opt->tot_len);
+  if (opt) {
+   atomic_sub(opt->tot_len, &sk->sk_omem_alloc);
+   txopt_put(opt);
+  }
   break;
  }
 
@@ -490,6 +496,7 @@ sticky_done:
    break;
 
   memset(opt, 0, sizeof(*opt));
+  atomic_set(&opt->refcnt, 1);
   opt->tot_len = sizeof(*opt) + optlen;
   retv = -EFAULT;
   if (copy_from_user(opt+1, optval, optlen))
@@ -506,8 +513,10 @@ update:
   retv = 0;
   opt = ipv6_update_options(sk, opt);
 done:
-  if (opt)
-   sock_kfree_s(sk, opt, opt->tot_len);
+  if (opt) {
+   atomic_sub(opt->tot_len, &sk->sk_omem_alloc);
+   txopt_put(opt);
+  }
   break;
  }
  case IPV6_UNICAST_HOPS:
@@ -1112,10 +1121,11 @@ static int do_ipv6_getsockopt(struct sock *sk, int level, int optname,
  case IPV6_RTHDR:
  case IPV6_DSTOPTS:
  {
+  struct ipv6_txoptions *opt;
 
   lock_sock(sk);
-  len = ipv6_getsockopt_sticky(sk, np->opt,
-          optname, optval, len);
+  opt = rcu_dereference_protected(np->opt, sock_owned_by_user(sk));
+  len = ipv6_getsockopt_sticky(sk, opt, optname, optval, len);
   release_sock(sk);
   /* check if ipv6_getsockopt_sticky() returns err code */
   if (len < 0)
diff --git a/net/ipv6/raw.c b/net/ipv6/raw.c
index f952913..3d20cff 100644
--- a/net/ipv6/raw.c
+++ b/net/ipv6/raw.c
@@ -726,6 +726,7 @@ static int rawv6_probe_proto_opt(struct flowi6 *fl6, struct msghdr *msg)
 static int rawv6_sendmsg(struct kiocb *iocb, struct sock *sk,
      struct msghdr *msg, size_t len)
 {
+ struct ipv6_txoptions *opt_to_free = NULL;
  struct ipv6_txoptions opt_space;
  struct sockaddr_in6 * sin6 = (struct sockaddr_in6 *) msg->msg_name;
  struct in6_addr *daddr, *final_p, final;
@@ -832,8 +833,10 @@ static int rawv6_sendmsg(struct kiocb *iocb, struct sock *sk,
   if (!(opt->opt_nflen|opt->opt_flen))
    opt = NULL;
  }
- if (opt == NULL)
-  opt = np->opt;
+ if (!opt) {
+  opt = txopt_get(np);
+  opt_to_free = opt;
+  }
  if (flowlabel)
   opt = fl6_merge_options(&opt_space, flowlabel, opt);
  opt = ipv6_fixup_options(&opt_space, opt);
@@ -900,6 +903,7 @@ done:
  dst_release(dst);
 out:
  fl6_sock_release(flowlabel);
+ txopt_put(opt_to_free);
  return err<0?err:len;
 do_confirm:
  dst_confirm(dst);
diff --git a/net/ipv6/syncookies.c b/net/ipv6/syncookies.c
index 47e5432..917ede0 100644
--- a/net/ipv6/syncookies.c
+++ b/net/ipv6/syncookies.c
@@ -237,7 +237,7 @@ struct sock *cookie_v6_check(struct sock *sk, struct sk_buff *skb)
   memset(&fl6, 0, sizeof(fl6));
   fl6.flowi6_proto = IPPROTO_TCP;
   fl6.daddr = ireq->ir_v6_rmt_addr;
-  final_p = fl6_update_dst(&fl6, np->opt, &final);
+  final_p = fl6_update_dst(&fl6, rcu_dereference(np->opt), &final);
   fl6.saddr = ireq->ir_v6_loc_addr;
   fl6.flowi6_oif = sk->sk_bound_dev_if;
   fl6.flowi6_mark = sk->sk_mark;
diff --git a/net/ipv6/tcp_ipv6.c b/net/ipv6/tcp_ipv6.c
index c5078c5..4041015 100644
--- a/net/ipv6/tcp_ipv6.c
+++ b/net/ipv6/tcp_ipv6.c
@@ -133,6 +133,7 @@ static int tcp_v6_connect(struct sock *sk, struct sockaddr *uaddr,
  struct ipv6_pinfo *np = inet6_sk(sk);
  struct tcp_sock *tp = tcp_sk(sk);
  struct in6_addr *saddr = NULL, *final_p, final;
+ struct ipv6_txoptions *opt;
  struct rt6_info *rt;
  struct flowi6 fl6;
  struct dst_entry *dst;
@@ -253,7 +254,8 @@ static int tcp_v6_connect(struct sock *sk, struct sockaddr *uaddr,
  fl6.fl6_dport = usin->sin6_port;
  fl6.fl6_sport = inet->inet_sport;
 
- final_p = fl6_update_dst(&fl6, np->opt, &final);
+ opt = rcu_dereference_protected(np->opt, sock_owned_by_user(sk));
+ final_p = fl6_update_dst(&fl6, opt, &final);
 
  security_sk_classify_flow(sk, flowi6_to_flowi(&fl6));
 
@@ -282,9 +284,9 @@ static int tcp_v6_connect(struct sock *sk, struct sockaddr *uaddr,
   tcp_fetch_timewait_stamp(sk, dst);
 
  icsk->icsk_ext_hdr_len = 0;
- if (np->opt)
-  icsk->icsk_ext_hdr_len = (np->opt->opt_flen +
-       np->opt->opt_nflen);
+ if (opt)
+  icsk->icsk_ext_hdr_len = opt->opt_flen +
+      opt->opt_nflen;
 
  tp->rx_opt.mss_clamp = IPV6_MIN_MTU - sizeof(struct tcphdr) - sizeof(struct ipv6hdr);
 
@@ -497,7 +499,8 @@ static int tcp_v6_send_synack(struct sock *sk, struct dst_entry *dst,
 
   fl6->daddr = ireq->ir_v6_rmt_addr;
   skb_set_queue_mapping(skb, queue_mapping);
-  err = ip6_xmit(sk, skb, fl6, np->opt, np->tclass);
+  err = ip6_xmit(sk, skb, fl6, rcu_dereference(np->opt),
+          np->tclass);
   err = net_xmit_eval(err);
  }
 
@@ -1043,6 +1046,7 @@ static struct sock *tcp_v6_syn_recv_sock(struct sock *sk, struct sk_buff *skb,
 {
  struct inet_request_sock *ireq;
  struct ipv6_pinfo *newnp, *np = inet6_sk(sk);
+ struct ipv6_txoptions *opt;
  struct tcp6_sock *newtcp6sk;
  struct inet_sock *newinet;
  struct tcp_sock *newtp;
@@ -1179,13 +1183,15 @@ static struct sock *tcp_v6_syn_recv_sock(struct sock *sk, struct sk_buff *skb,
     but we make one more one thing there: reattach optmem
     to newsk.
   */
- if (np->opt)
-  newnp->opt = ipv6_dup_options(newsk, np->opt);
-
+ opt = rcu_dereference(np->opt);
+ if (opt) {
+  opt = ipv6_dup_options(newsk, opt);
+  RCU_INIT_POINTER(newnp->opt, opt);
+ }
  inet_csk(newsk)->icsk_ext_hdr_len = 0;
- if (newnp->opt)
-  inet_csk(newsk)->icsk_ext_hdr_len = (newnp->opt->opt_nflen +
-           newnp->opt->opt_flen);
+ if (opt)
+  inet_csk(newsk)->icsk_ext_hdr_len = opt->opt_nflen +
+          opt->opt_flen;
 
  tcp_ca_openreq_child(newsk, dst);
 
diff --git a/net/ipv6/udp.c b/net/ipv6/udp.c
index 67ddb0e..a92f5ef 100644
--- a/net/ipv6/udp.c
+++ b/net/ipv6/udp.c
@@ -1097,6 +1097,7 @@ int udpv6_sendmsg(struct kiocb *iocb, struct sock *sk,
  struct sockaddr_in6 *sin6 = (struct sockaddr_in6 *) msg->msg_name;
  struct in6_addr *daddr, *final_p, final;
  struct ipv6_txoptions *opt = NULL;
+ struct ipv6_txoptions *opt_to_free = NULL;
  struct ip6_flowlabel *flowlabel = NULL;
  struct flowi6 fl6;
  struct dst_entry *dst;
@@ -1251,8 +1252,10 @@ do_udp_sendmsg:
    opt = NULL;
   connected = 0;
  }
- if (opt == NULL)
-  opt = np->opt;
+ if (!opt) {
+  opt = txopt_get(np);
+  opt_to_free = opt;
+ }
  if (flowlabel)
   opt = fl6_merge_options(&opt_space, flowlabel, opt);
  opt = ipv6_fixup_options(&opt_space, opt);
@@ -1367,6 +1370,7 @@ release_dst:
 out:
  dst_release(dst);
  fl6_sock_release(flowlabel);
+ txopt_put(opt_to_free);
  if (!err)
   return len;
  /*
diff --git a/net/l2tp/l2tp_ip6.c b/net/l2tp/l2tp_ip6.c
index d1a4edf..413ebef 100644
--- a/net/l2tp/l2tp_ip6.c
+++ b/net/l2tp/l2tp_ip6.c
@@ -485,6 +485,7 @@ static int l2tp_ip6_sendmsg(struct kiocb *iocb, struct sock *sk,
   (struct sockaddr_l2tpip6 *) msg->msg_name;
  struct in6_addr *daddr, *final_p, final;
  struct ipv6_pinfo *np = inet6_sk(sk);
+ struct ipv6_txoptions *opt_to_free = NULL;
  struct ipv6_txoptions *opt = NULL;
  struct ip6_flowlabel *flowlabel = NULL;
  struct dst_entry *dst = NULL;
@@ -575,8 +576,10 @@ static int l2tp_ip6_sendmsg(struct kiocb *iocb, struct sock *sk,
    opt = NULL;
  }
 
- if (opt == NULL)
-  opt = np->opt;
+ if (!opt) {
+  opt = txopt_get(np);
+  opt_to_free = opt;
+ }
  if (flowlabel)
   opt = fl6_merge_options(&opt_space, flowlabel, opt);
  opt = ipv6_fixup_options(&opt_space, opt);
@@ -637,6 +640,7 @@ done:
  dst_release(dst);
 out:
  fl6_sock_release(flowlabel);
+ txopt_put(opt_to_free);
 
  return err < 0 ? err : len;
 
-- 
1.7.1