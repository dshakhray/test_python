From e831f0dcbec98a664e88f7f4369733844c38305b Mon Sep 17 00:00:00 2001
From: Brian Foster <bfoster@redhat.com>
Date: Fri, 26 Aug 2016 13:14:51 +0200
Subject: [fs] xfs: prevent dropping ioend completions during buftarg wait

Message-id: <1472217291-32067-1-git-send-email-bfoster@redhat.com>
Patchwork-id: 157336
O-Subject: [RHEL7 PATCH] xfs: prevent dropping ioend completions during buftarg wait
Bugzilla: 1370177
Z-Bugzilla: 1385028
RH-Acked-by: Jeremy McNicoll <jmcnicol@redhat.com>
RH-Acked-by: Eric Sandeen <sandeen@redhat.com>
RH-Acked-by: Jarod Wilson <jarod@redhat.com>

commit 800b2694f890cc35a1bda63501fc71c94389d517
Author: Brian Foster <bfoster@redhat.com>
Date:   Fri Aug 26 16:01:59 2016 +1000

    xfs: prevent dropping ioend completions during buftarg wait

    xfs_wait_buftarg() waits for all pending I/O, drains the ioend
    completion workqueue and walks the LRU until all buffers in the cache
    have been released. This is traditionally an unmount operation` but the
    mechanism is also reused during filesystem freeze.

    xfs_wait_buftarg() invokes drain_workqueue() as part of the quiesce,
    which is intended more for a shutdown sequence in that it indicates to
    the queue that new operations are not expected once the drain has begun.
    New work jobs after this point result in a WARN_ON_ONCE() and are
    otherwise dropped.

    With filesystem freeze, however, read operations are allowed and can
    proceed during or after the workqueue drain. If such a read occurs
    during the drain sequence, the workqueue infrastructure complains about
    the queued ioend completion work item and drops it on the floor. As a
    result, the buffer remains on the LRU and the freeze never completes.

    Despite the fact that the overall buffer cache cleanup is not necessary
    during freeze, fix up this operation such that it is safe to invoke
    during non-unmount quiesce operations. Replace the drain_workqueue()
    call with flush_workqueue(), which runs a similar serialization on
    pending workqueue jobs without causing new jobs to be dropped. This is
    safe for unmount as unmount independently locks out new operations by
    the time xfs_wait_buftarg() is invoked.

    cc: <stable@vger.kernel.org>
    Signed-off-by: Brian Foster <bfoster@redhat.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dave Chinner <david@fromorbit.com>

Signed-off-by: Brian Foster <bfoster@redhat.com>
---

Bugzilla: https://bugzilla.redhat.com/show_bug.cgi?id=1370177
Upstream Status: Merged (xfs repo).
Build Info: https://brewweb.engineering.redhat.com/brew/taskinfo?taskID=11664126
Tested: via xfstests and fsstress/xfs_freeze hang reproducer.

Signed-off-by: Alexander Gordeev <agordeev@redhat.com>

diff --git a/fs/xfs/xfs_buf.c b/fs/xfs/xfs_buf.c
index f6cff3a..cf71762 100644
--- a/fs/xfs/xfs_buf.c
+++ b/fs/xfs/xfs_buf.c
@@ -1612,7 +1612,7 @@ xfs_wait_buftarg(
   */
  while (percpu_counter_sum(&btp->bt_io_count))
   delay(100);
- drain_workqueue(btp->bt_mount->m_buf_workqueue);
+ flush_workqueue(btp->bt_mount->m_buf_workqueue);
 
 restart:
  spin_lock(&btp->bt_lru_lock);
-- 
1.7.1