From 21a6abb5dc76177e733afb267b9aa10e5c1bf2ad Mon Sep 17 00:00:00 2001
From: Sabrina Dubroca <sdubroca@redhat.com>
Date: Mon, 26 Sep 2016 15:55:32 +0200
Subject: [net] add recursion limit to GRO

Message-id: <c0c0fb546b3d3d2657b30a4dd3cc8618370091b7.1474385187.git.sdubroca@redhat.com>
Patchwork-id: 5318
O-Subject: [kernel team] [EMBARGOED PATCH RHEL7.2z net] net: add recursion limit to GRO
Bugzilla: 1374191
Z-Bugzilla: 1378405
CVE: CVE-2016-7039
RH-Acked-by: Jarod Wilson <jarod@redhat.com>
RH-Acked-by: Jiri Benc <jbenc@redhat.com>
RH-Acked-by: Hannes Frederic Sowa <hannes@redhat.com>
RH-Acked-by: Ivan Vecera <ivecera@redhat.com>

Bugzilla: https://bugzilla.redhat.com/show_bug.cgi?id=1378405
CVE: CVE-2016-7039
Upstream Status: not upstream yet
Brew: https://brewweb.engineering.redhat.com/brew/taskinfo?taskID=11782586

Z-Stream notes:
 - no geneve
 - different context in dev_gro_receive
 - differences in how UDP offloads are implemented

Y-Stream notes:
 - different context in struct napi_gro_cb and dev_gro_receive
 - although we don't compile FOU, I kept the changes in fou_gro_receive

This patch has not been submitted upstream yet, because the CVE is embargoed.

(no upstream commit yet)
Author: Sabrina Dubroca <sd@queasysnail.net>
Date:   Thu Sep 15 10:49:30 2016 +0200

    net: add recursion limit to GRO

    Currently, GRO can do unlimited recursion through the gro_receive
    handlers.  This was fixed for tunneling protocols by limiting tunnel GRO
    to one level with encap_mark, but both VLAN and TEB still have this
    problem.  Thus, the kernel is vulnerable to a stack overflow, if we
    receive a packet composed entirely of VLAN headers.

    This patch adds a recursion counter to the GRO layer to prevent stack
    overflow.  When a gro_receive function hits the recursion limit, GRO is
    aborted for this skb and it is processed normally.

    Fixes: 9b174d88c257 ("net: Add Transparent Ethernet Bridging GRO support.")
    Fixes: 66e5133f19e9 ("vlan: Add GRO support for non hardware accelerated vlan")
    Signed-off-by: Sabrina Dubroca <sd@queasysnail.net>
    Reviewed-by: Jiri Benc <jbenc@redhat.com>
    Acked-by: Hannes Frederic Sowa <hannes@stressinduktion.org>

Signed-off-by: Sabrina Dubroca <sdubroca@redhat.com>
---
 drivers/net/vxlan.c       |  2 +-
 include/linux/netdevice.h | 24 +++++++++++++++++++++++-
 net/8021q/vlan.c          |  2 +-
 net/core/dev.c            |  1 +
 net/ethernet/eth.c        |  2 +-
 net/ipv4/af_inet.c        |  2 +-
 net/ipv4/fou.c            |  4 ++--
 net/ipv4/gre_offload.c    |  2 +-
 net/ipv4/udp_offload.c    | 10 ++++++++--
 net/ipv6/ip6_offload.c    |  2 +-
 10 files changed, 40 insertions(+), 11 deletions(-)

Signed-off-by: Alexander Gordeev <agordeev@redhat.com>

diff --git a/drivers/net/vxlan.c b/drivers/net/vxlan.c
index dbf1449..fd2516d 100644
--- a/drivers/net/vxlan.c
+++ b/drivers/net/vxlan.c
@@ -634,7 +634,7 @@ static struct sk_buff **vxlan_gro_receive(struct sk_buff **head,
   }
  }
 
- pp = eth_gro_receive(head, skb);
+ pp = call_gro_receive(eth_gro_receive, head, skb);
 
 out:
  skb_gro_remcsum_cleanup(skb, &grc);
diff --git a/include/linux/netdevice.h b/include/linux/netdevice.h
index 45d72df..adb7cdb 100644
--- a/include/linux/netdevice.h
+++ b/include/linux/netdevice.h
@@ -1844,7 +1844,10 @@ struct napi_gro_cb {
  /* This is non-zero if the packet may be of the same flow. */
  u8 same_flow:1;
 
- /* 7 bit hole */
+ /* Number of gro_receive callbacks this packet already went through */
+ u8 recursion_counter:4;
+
+ /* 3 bit hole */
 
  /* used to support CHECKSUM_COMPLETE for tunneling protocols */
  __wsum csum;
@@ -1855,6 +1858,25 @@ struct napi_gro_cb {
 
 #define NAPI_GRO_CB(skb) ((struct napi_gro_cb *)(skb)->cb)
 
+#define GRO_RECURSION_LIMIT 15
+static inline int gro_recursion_inc_test(struct sk_buff *skb)
+{
+ return ++NAPI_GRO_CB(skb)->recursion_counter == GRO_RECURSION_LIMIT;
+}
+
+typedef struct sk_buff **(*gro_receive_t)(struct sk_buff **, struct sk_buff *);
+static inline struct sk_buff **call_gro_receive(gro_receive_t cb,
+      struct sk_buff **head,
+      struct sk_buff *skb)
+{
+ if (gro_recursion_inc_test(skb)) {
+  NAPI_GRO_CB(skb)->flush |= 1;
+  return NULL;
+ }
+
+ return cb(head, skb);
+}
+
 struct packet_type {
  __be16   type; /* This is really htons(ether_type). */
  struct net_device *dev; /* NULL is wildcarded here      */
diff --git a/net/8021q/vlan.c b/net/8021q/vlan.c
index bb8af39..5ac3ff9 100644
--- a/net/8021q/vlan.c
+++ b/net/8021q/vlan.c
@@ -640,7 +640,7 @@ static struct sk_buff **vlan_gro_receive(struct sk_buff **head,
 
  skb_gro_pull(skb, sizeof(*vhdr));
  skb_gro_postpull_rcsum(skb, vhdr, sizeof(*vhdr));
- pp = ptype->callbacks.gro_receive(head, skb);
+ pp = call_gro_receive(ptype->callbacks.gro_receive, head, skb);
 
 out_unlock:
  rcu_read_unlock();
diff --git a/net/core/dev.c b/net/core/dev.c
index e42b717..74e25a3 100644
--- a/net/core/dev.c
+++ b/net/core/dev.c
@@ -3854,6 +3854,7 @@ static enum gro_result dev_gro_receive(struct napi_struct *napi, struct sk_buff
   NAPI_GRO_CB(skb)->free = 0;
   NAPI_GRO_CB(skb)->udp_mark = 0;
   NAPI_GRO_CB(skb)->gro_remcsum_start = 0;
+  NAPI_GRO_CB(skb)->recursion_counter = 0;
 
   /* Setup for GRO checksum validation */
   switch (skb->ip_summed) {
diff --git a/net/ethernet/eth.c b/net/ethernet/eth.c
index 6a6a707..700c7a1 100644
--- a/net/ethernet/eth.c
+++ b/net/ethernet/eth.c
@@ -496,7 +496,7 @@ struct sk_buff **eth_gro_receive(struct sk_buff **head,
 
  skb_gro_pull(skb, sizeof(*eh));
  skb_gro_postpull_rcsum(skb, eh, sizeof(*eh));
- pp = ptype->callbacks.gro_receive(head, skb);
+ pp = call_gro_receive(ptype->callbacks.gro_receive, head, skb);
 
 out_unlock:
  rcu_read_unlock();
diff --git a/net/ipv4/af_inet.c b/net/ipv4/af_inet.c
index 51783fc..3dc8113 100644
--- a/net/ipv4/af_inet.c
+++ b/net/ipv4/af_inet.c
@@ -1375,7 +1375,7 @@ static struct sk_buff **inet_gro_receive(struct sk_buff **head,
  skb_gro_pull(skb, sizeof(*iph));
  skb_set_transport_header(skb, skb_gro_offset(skb));
 
- pp = ops->callbacks.gro_receive(head, skb);
+ pp = call_gro_receive(ops->callbacks.gro_receive, head, skb);
 
 out_unlock:
  rcu_read_unlock();
diff --git a/net/ipv4/fou.c b/net/ipv4/fou.c
index ff069f6..25361fa 100644
--- a/net/ipv4/fou.c
+++ b/net/ipv4/fou.c
@@ -182,7 +182,7 @@ static struct sk_buff **fou_gro_receive(struct sk_buff **head,
  if (!ops || !ops->callbacks.gro_receive)
   goto out_unlock;
 
- pp = ops->callbacks.gro_receive(head, skb);
+ pp = call_gro_receive(ops->callbacks.gro_receive, head, skb);
 
 out_unlock:
  rcu_read_unlock();
@@ -349,7 +349,7 @@ static struct sk_buff **gue_gro_receive(struct sk_buff **head,
  if (WARN_ON(!ops || !ops->callbacks.gro_receive))
   goto out_unlock;
 
- pp = ops->callbacks.gro_receive(head, skb);
+ pp = call_gro_receive(ops->callbacks.gro_receive, head, skb);
 
 out_unlock:
  rcu_read_unlock();
diff --git a/net/ipv4/gre_offload.c b/net/ipv4/gre_offload.c
index bb5947b..c9351ad 100644
--- a/net/ipv4/gre_offload.c
+++ b/net/ipv4/gre_offload.c
@@ -213,7 +213,7 @@ static struct sk_buff **gre_gro_receive(struct sk_buff **head,
  /* Adjusted NAPI_GRO_CB(skb)->csum after skb_gro_pull()*/
  skb_gro_postpull_rcsum(skb, greh, grehlen);
 
- pp = ptype->callbacks.gro_receive(head, skb);
+ pp = call_gro_receive(ptype->callbacks.gro_receive, head, skb);
 
 out_unlock:
  rcu_read_unlock();
diff --git a/net/ipv4/udp_offload.c b/net/ipv4/udp_offload.c
index 269c5a8..cc0b9cd 100644
--- a/net/ipv4/udp_offload.c
+++ b/net/ipv4/udp_offload.c
@@ -340,8 +340,14 @@ unflush:
  skb_gro_pull(skb, sizeof(struct udphdr)); /* pull encapsulating udp header */
  skb_gro_postpull_rcsum(skb, uh, sizeof(struct udphdr));
  NAPI_GRO_CB(skb)->proto = uo_priv->offload->ipproto;
- pp = uo_priv->offload->callbacks.gro_receive(head, skb,
-           uo_priv->offload);
+
+ if (gro_recursion_inc_test(skb)) {
+  flush = 1;
+  pp = NULL;
+ } else {
+  pp = uo_priv->offload->callbacks.gro_receive(head, skb,
+            uo_priv->offload);
+ }
 
 out_unlock:
  rcu_read_unlock();
diff --git a/net/ipv6/ip6_offload.c b/net/ipv6/ip6_offload.c
index b2a1519..e1dd2bd 100644
--- a/net/ipv6/ip6_offload.c
+++ b/net/ipv6/ip6_offload.c
@@ -244,7 +244,7 @@ static struct sk_buff **ipv6_gro_receive(struct sk_buff **head,
 
  skb_gro_postpull_rcsum(skb, iph, nlen);
 
- pp = ops->callbacks.gro_receive(head, skb);
+ pp = call_gro_receive(ops->callbacks.gro_receive, head, skb);
 
 out_unlock:
  rcu_read_unlock();
-- 
1.7.1