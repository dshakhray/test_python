From 6b4e91e5600e3aa1b131f85fb9c498b03181b7c6 Mon Sep 17 00:00:00 2001
From: Steve Dickson <SteveD@redhat.com>
Date: Mon, 7 Nov 2016 18:48:56 +0100
Subject: [fs] Retry operation on EREMOTEIO on an interrupted slot

Message-id: <1478544536-9273-1-git-send-email-steved@redhat.com>
Patchwork-id: 160282
O-Subject: [RHEL7.4 fs PATCH 1/1] Retry operation on EREMOTEIO on an interrupted slot
Bugzilla: 1378981
Z-Bugzilla: 1394709
RH-Acked-by: J. Bruce Fields <bfields@redhat.com>
RH-Acked-by: Benjamin Coddington <bcodding@redhat.com>

From: Olga Kornievskaia <kolga@netapp.com>

If an operation got interrupted, then since we don't know if the
server processed it on not, we keep the seq#. Upon reuse of slot
and seq# if we get reply from the cache (ie EREMOTEIO) then we
need to retry the operation after bumping the seq#

Signed-off-by: Olga Kornievskaia <kolga@netapp.com>
Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>
Upstream Id: a865880e20ca4d2df362f61c9ef51f0fc0273131
Bugzilla: 1378981

Signed-off-by: Alexander Gordeev <agordeev@redhat.com>

diff --git a/fs/nfs/nfs4proc.c b/fs/nfs/nfs4proc.c
index d9ecf01..d52ef42 100644
--- a/fs/nfs/nfs4proc.c
+++ b/fs/nfs/nfs4proc.c
@@ -625,6 +625,13 @@ int nfs41_sequence_done(struct rpc_task *task, struct nfs4_sequence_res *res)
  /* Check the SEQUENCE operation status */
  switch (res->sr_status) {
  case 0:
+  /* If previous op on slot was interrupted and we reused
+   * the seq# and got a reply from the cache, then retry
+   */
+  if (task->tk_status == -EREMOTEIO && interrupted) {
+   ++slot->seq_nr;
+   goto retry_nowait;
+  }
   /* Update the slot's sequence and clientid lease timer */
   ++slot->seq_nr;
   clp = session->clp;
-- 
1.7.1