From 78bc0509b47b6f09287aa5581bf20f6c3b3bc0e0 Mon Sep 17 00:00:00 2001
From: Baoquan He <bhe@redhat.com>
Date: Wed, 21 Oct 2015 08:45:36 +0200
Subject: [kernel] kexec: align crash_notes allocation to make it be inside one physical page

Message-id: <1445417136-28029-3-git-send-email-bhe@redhat.com>
Patchwork-id: 125833
O-Subject: [RHEL7.3 Patch 2/2] kexec: align crash_notes allocation to make it be inside one physical page
Bugzilla: 1073651
Z-Bugzilla: 1365621
RH-Acked-by: Minfei Huang <mhuang@redhat.com>
RH-Acked-by: Dave Young <dyoung@redhat.com>

Resolves: bz1073651
https://bugzilla.redhat.com/show_bug.cgi?id=1073651

Brew build:
https://brewweb.devel.redhat.com/taskinfo?taskID=9985748

Test:
Basic test passed on beaker machine. And this patch has been tested when
post to upstream.

This is back ported from upstream. It need be handled manually since in
upstream commit 2965faa("kexec: split kexec_load syscall from kexec core
code") kernel/kexec.c is split into several files and it's not in rhel7 yet.

commit bbb78b8f3f4ea8eca14937b693bfe244838e1d4d
Author: Baoquan He <bhe@redhat.com>
Date:   Wed Sep 9 15:39:00 2015 -0700

    kexec: align crash_notes allocation to make it be inside one physical page

    People reported that crash_notes in /proc/vmcore were corrupted and this
    cause crash kdump failure.  With code debugging and log we got the root
    cause.  This is because percpu variable crash_notes are allocated in 2
    vmalloc pages.  Currently percpu is based on vmalloc by default.  Vmalloc
    can't guarantee 2 continuous vmalloc pages are also on 2 continuous
    physical pages.  So when 1st kernel exports the starting address and size
    of crash_notes through sysfs like below:

    /sys/devices/system/cpu/cpux/crash_notes
    /sys/devices/system/cpu/cpux/crash_notes_size

    kdump kernel use them to get the content of crash_notes.  However the 2nd
    part may not be in the next neighbouring physical page as we expected if
    crash_notes are allocated accross 2 vmalloc pages.  That's why
    nhdr_ptr->n_namesz or nhdr_ptr->n_descsz could be very huge in
    update_note_header_size_elf64() and cause note header merging failure or
    some warnings.

    In this patch change to call __alloc_percpu() to passed in the align value
    by rounding crash_notes_size up to the nearest power of two.  This makes
    sure the crash_notes is allocated inside one physical page since
    sizeof(note_buf_t) in all ARCHS is smaller than PAGE_SIZE.  Meanwhile add
    a BUILD_BUG_ON to break compile if size is bigger than PAGE_SIZE since
    crash_notes definitely will be in 2 pages.  That need be avoided, and need
    be reported if it's unavoidable.

    [akpm@linux-foundation.org: use correct comment layout]
    Signed-off-by: Baoquan He <bhe@redhat.com>
    Cc: Eric W. Biederman <ebiederm@xmission.com>
    Cc: Vivek Goyal <vgoyal@redhat.com>
    Cc: Dave Young <dyoung@redhat.com>
    Cc: Lisa Mitchell <lisa.mitchell@hp.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

Signed-off-by: Baoquan He <bhe@redhat.com>
Signed-off-by: Alexander Gordeev <agordeev@redhat.com>

diff --git a/kernel/kexec.c b/kernel/kexec.c
index ecb56cb..269aa7c 100644
--- a/kernel/kexec.c
+++ b/kernel/kexec.c
@@ -1614,7 +1614,28 @@ void crash_save_cpu(struct pt_regs *regs, int cpu)
 static int __init crash_notes_memory_init(void)
 {
  /* Allocate memory for saving cpu registers. */
- crash_notes = alloc_percpu(note_buf_t);
+ size_t size, align;
+
+ /*
+  * crash_notes could be allocated across 2 vmalloc pages when percpu
+  * is vmalloc based . vmalloc doesn't guarantee 2 continuous vmalloc
+  * pages are also on 2 continuous physical pages. In this case the
+  * 2nd part of crash_notes in 2nd page could be lost since only the
+  * starting address and size of crash_notes are exported through sysfs.
+  * Here round up the size of crash_notes to the nearest power of two
+  * and pass it to __alloc_percpu as align value. This can make sure
+  * crash_notes is allocated inside one physical page.
+  */
+ size = sizeof(note_buf_t);
+ align = min(roundup_pow_of_two(sizeof(note_buf_t)), PAGE_SIZE);
+
+ /*
+  * Break compile if size is bigger than PAGE_SIZE since crash_notes
+  * definitely will be in 2 pages with that.
+  */
+ BUILD_BUG_ON(size > PAGE_SIZE);
+
+ crash_notes = __alloc_percpu(size, align);
  if (!crash_notes) {
   pr_warn("Kexec: Memory allocation for saving cpu register states failed\n");
   return -ENOMEM;
-- 
1.7.1