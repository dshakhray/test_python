From 30024017225d5a53761414f7ef93c792e8cd050c Mon Sep 17 00:00:00 2001
From: Alexander Gordeev <agordeev@redhat.com>
Date: Mon, 7 Nov 2016 13:42:07 +0100
Subject: [fs] sunrpc: move NO_CRKEY_TIMEOUT to the auth->au_flags

Message-id: <20161107134207.GA663@localhost>
Patchwork-id: 160275
O-Subject: [RHEL7.2.z fs PATCH BZ 1388603] sunrpc: move NO_CRKEY_TIMEOUT to the auth->au_flags
Bugzilla: 1384666
Z-Bugzilla: 1388603
RH-Acked-by: Jeremy McNicoll <jmcnicol@redhat.com>
RH-Acked-by: Scott Mayhew <smayhew@redhat.com>
RH-Acked-by: Dave Wysochanski <dwysocha@redhat.com>

This is a fixup to make 7.4 patch apply to 7.2.z

Bugzilla: https://bugzilla.redhat.com/show_bug.cgi?id=1388603
Brew: https://brewweb.engineering.redhat.com/brew/taskinfo?taskID=12044886
Test:
    Dave Wysochanski <dwysocha@redhat.com> tested it using an own script:
    https://bugzilla.redhat.com/show_bug.cgi?id=1384666#c5

    Yongcheng Yang <yoyang@redhat.com> ran a Beaker test on it:
    https://bugzilla.redhat.com/show_bug.cgi?id=1388603#c10

This patch fixes a severe NFS performance regression on an NFS client
when multiple mounts are used with mixed security flavors, as described in
the below patch header.

The patch was tested on RHEL7 with the test case provided on the RHEL6 bug,
and was a simple backport from upstream with only minor fixups required.

commit ce52914eb76efd62aa48d738cf845b37852bf920
Author: Scott Mayhew <smayhew@redhat.com>
Date:   Tue Jun 7 15:14:48 2016 -0400

    sunrpc: move NO_CRKEY_TIMEOUT to the auth->au_flags

    A generic_cred can be used to look up a unx_cred or a gss_cred, so it's
    not really safe to use the the generic_cred->acred->ac_flags to store
    the NO_CRKEY_TIMEOUT flag.  A lookup for a unx_cred triggered while the
    KEY_EXPIRE_SOON flag is already set will cause both NO_CRKEY_TIMEOUT and
    KEY_EXPIRE_SOON to be set in the ac_flags, leaving the user associated
    with the auth_cred to be in a state where they're perpetually doing 4K
    NFS_FILE_SYNC writes.

    This can be reproduced as follows:

    1. Mount two NFS filesystems, one with sec=krb5 and one with sec=sys.
    They do not need to be the same export, nor do they even need to be from
    the same NFS server.  Also, v3 is fine.
    $ sudo mount -o v3,sec=krb5 server1:/export /mnt/krb5
    $ sudo mount -o v3,sec=sys server2:/export /mnt/sys

    2. As the normal user, before accessing the kerberized mount, kinit with
    a short lifetime (but not so short that renewing the ticket would leave
    you within the 4-minute window again by the time the original ticket
    expires), e.g.
    $ kinit -l 10m -r 60m

    3. Do some I/O to the kerberized mount and verify that the writes are
    wsize, UNSTABLE:
    $ dd if=/dev/zero of=/mnt/krb5/file bs=1M count=1

    4. Wait until you're within 4 minutes of key expiry, then do some more
    I/O to the kerberized mount to ensure that RPC_CRED_KEY_EXPIRE_SOON gets
    set.  Verify that the writes are 4K, FILE_SYNC:
    $ dd if=/dev/zero of=/mnt/krb5/file bs=1M count=1

    5. Now do some I/O to the sec=sys mount.  This will cause
    RPC_CRED_NO_CRKEY_TIMEOUT to be set:
    $ dd if=/dev/zero of=/mnt/sys/file bs=1M count=1

    6. Writes for that user will now be permanently 4K, FILE_SYNC for that
    user, regardless of which mount is being written to, until you reboot
    the client.  Renewing the kerberos ticket (assuming it hasn't already
    expired) will have no effect.  Grabbing a new kerberos ticket at this
    point will have no effect either.

    Move the flag to the auth->au_flags field (which is currently unused)
    and rename it slightly to reflect that it's no longer associated with
    the auth_cred->ac_flags.  Add the rpc_auth to the arg list of
    rpcauth_cred_key_to_expire and check the au_flags there too.  Finally,
    add the inode to the arg list of nfs_ctx_key_to_expire so we can
    determine the rpc_auth to pass to rpcauth_cred_key_to_expire.

    Signed-off-by: Scott Mayhew <smayhew@redhat.com>
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

Conflicts:
 net/sunrpc/auth_null.c
 net/sunrpc/auth_unix.c

Signed-off-by: Dave Wysochanski <dwysocha@redhat.com>
Signed-off-by: Alexander Gordeev <agordeev@redhat.com>
---
 fs/nfs/file.c                  |    4 ++--
 fs/nfs/internal.h              |    2 +-
 fs/nfs/write.c                 |    6 ++++--
 include/linux/sunrpc/auth.h    |    6 ++++--
 net/sunrpc/auth.c              |    4 +++-
 net/sunrpc/auth_generic.c      |    9 +--------
 net/sunrpc/auth_gss/auth_gss.c |    1 +
 net/sunrpc/auth_null.c         |    1 +
 net/sunrpc/auth_unix.c         |    1 +
 9 files changed, 18 insertions(+), 16 deletions(-)

Signed-off-by: Alexander Gordeev <agordeev@redhat.com>

diff --git a/fs/nfs/file.c b/fs/nfs/file.c
index 7104ab2..127ee87 100644
--- a/fs/nfs/file.c
+++ b/fs/nfs/file.c
@@ -434,7 +434,7 @@ static int nfs_write_end(struct file *file, struct address_space *mapping,
   return status;
  NFS_I(mapping->host)->write_io += copied;
 
- if (nfs_ctx_key_to_expire(ctx)) {
+ if (nfs_ctx_key_to_expire(ctx, mapping->host)) {
   status = nfs_wb_all(mapping->host);
   if (status < 0)
    return status;
@@ -646,7 +646,7 @@ static int nfs_need_sync_write(struct file *filp, struct inode *inode)
   return 1;
  ctx = nfs_file_open_context(filp);
  if (test_bit(NFS_CONTEXT_ERROR_WRITE, &ctx->flags) ||
-     nfs_ctx_key_to_expire(ctx))
+     nfs_ctx_key_to_expire(ctx, inode))
   return 1;
  return 0;
 }
diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 7564322..91aca7e 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -476,7 +476,7 @@ void nfs_init_cinfo(struct nfs_commit_info *cinfo,
       struct inode *inode,
       struct nfs_direct_req *dreq);
 int nfs_key_timeout_notify(struct file *filp, struct inode *inode);
-bool nfs_ctx_key_to_expire(struct nfs_open_context *ctx);
+bool nfs_ctx_key_to_expire(struct nfs_open_context *ctx, struct inode *inode);
 void nfs_pageio_stop_mirroring(struct nfs_pageio_descriptor *pgio);
 
 #ifdef CONFIG_MIGRATION
diff --git a/fs/nfs/write.c b/fs/nfs/write.c
index a6261e0..2e42be0 100644
--- a/fs/nfs/write.c
+++ b/fs/nfs/write.c
@@ -1147,9 +1147,11 @@ nfs_key_timeout_notify(struct file *filp, struct inode *inode)
 /*
  * Test if the open context credential key is marked to expire soon.
  */
-bool nfs_ctx_key_to_expire(struct nfs_open_context *ctx)
+bool nfs_ctx_key_to_expire(struct nfs_open_context *ctx, struct inode *inode)
 {
- return rpcauth_cred_key_to_expire(ctx->cred);
+ struct rpc_auth *auth = NFS_SERVER(inode)->client->cl_auth;
+
+ return rpcauth_cred_key_to_expire(auth, ctx->cred);
 }
 
 /*
diff --git a/include/linux/sunrpc/auth.h b/include/linux/sunrpc/auth.h
index 1ecf13e..c0ca557 100644
--- a/include/linux/sunrpc/auth.h
+++ b/include/linux/sunrpc/auth.h
@@ -30,7 +30,6 @@ struct rpcsec_gss_info;
 
 /* auth_cred ac_flags bits */
 enum {
- RPC_CRED_NO_CRKEY_TIMEOUT = 0, /* underlying cred has no key timeout */
  RPC_CRED_KEY_EXPIRE_SOON = 1, /* underlying cred key will expire soon */
  RPC_CRED_NOTIFY_TIMEOUT = 2,   /* nofity generic cred when underlying
      key will expire soon */
@@ -75,6 +74,9 @@ struct rpc_cred {
 
 #define RPCAUTH_CRED_MAGIC 0x0f4aa4f0
 
+/* rpc_auth au_flags */
+#define RPCAUTH_AUTH_NO_CRKEY_TIMEOUT 0x0001 /* underlying cred has no key timeout */
+
 /*
  * Client authentication handle
  */
@@ -188,7 +190,7 @@ void   rpcauth_destroy_credcache(struct rpc_auth *);
 void   rpcauth_clear_credcache(struct rpc_cred_cache *);
 int   rpcauth_key_timeout_notify(struct rpc_auth *,
       struct rpc_cred *);
-bool   rpcauth_cred_key_to_expire(struct rpc_cred *);
+bool   rpcauth_cred_key_to_expire(struct rpc_auth *, struct rpc_cred *);
 char *   rpcauth_stringify_acceptor(struct rpc_cred *);
 
 static inline
diff --git a/net/sunrpc/auth.c b/net/sunrpc/auth.c
index 36ad830..4e9c1ad 100644
--- a/net/sunrpc/auth.c
+++ b/net/sunrpc/auth.c
@@ -355,8 +355,10 @@ rpcauth_key_timeout_notify(struct rpc_auth *auth, struct rpc_cred *cred)
 EXPORT_SYMBOL_GPL(rpcauth_key_timeout_notify);
 
 bool
-rpcauth_cred_key_to_expire(struct rpc_cred *cred)
+rpcauth_cred_key_to_expire(struct rpc_auth *auth, struct rpc_cred *cred)
 {
+ if (auth->au_flags & RPCAUTH_AUTH_NO_CRKEY_TIMEOUT)
+  return false;
  if (!cred->cr_ops->crkey_to_expire)
   return false;
  return cred->cr_ops->crkey_to_expire(cred);
diff --git a/net/sunrpc/auth_generic.c b/net/sunrpc/auth_generic.c
index 41248b1..9b8f647 100644
--- a/net/sunrpc/auth_generic.c
+++ b/net/sunrpc/auth_generic.c
@@ -217,7 +217,7 @@ generic_key_timeout(struct rpc_auth *auth, struct rpc_cred *cred)
 
 
  /* Fast track for non crkey_timeout (no key) underlying credentials */
- if (test_bit(RPC_CRED_NO_CRKEY_TIMEOUT, &acred->ac_flags))
+ if (auth->au_flags & RPCAUTH_AUTH_NO_CRKEY_TIMEOUT)
   return 0;
 
  /* Fast track for the normal case */
@@ -229,12 +229,6 @@ generic_key_timeout(struct rpc_auth *auth, struct rpc_cred *cred)
  if (IS_ERR(tcred))
   return -EACCES;
 
- if (!tcred->cr_ops->crkey_timeout) {
-  set_bit(RPC_CRED_NO_CRKEY_TIMEOUT, &acred->ac_flags);
-  ret = 0;
-  goto out_put;
- }
-
  /* Test for the almost error case */
  ret = tcred->cr_ops->crkey_timeout(tcred);
  if (ret != 0) {
@@ -250,7 +244,6 @@ generic_key_timeout(struct rpc_auth *auth, struct rpc_cred *cred)
   set_bit(RPC_CRED_NOTIFY_TIMEOUT, &acred->ac_flags);
  }
 
-out_put:
  put_rpccred(tcred);
  return ret;
 }
diff --git a/net/sunrpc/auth_gss/auth_gss.c b/net/sunrpc/auth_gss/auth_gss.c
index 460baa5..10d0ddc 100644
--- a/net/sunrpc/auth_gss/auth_gss.c
+++ b/net/sunrpc/auth_gss/auth_gss.c
@@ -1012,6 +1012,7 @@ gss_create_new(struct rpc_auth_create_args *args, struct rpc_clnt *clnt)
  auth = &gss_auth->rpc_auth;
  auth->au_cslack = GSS_CRED_SLACK >> 2;
  auth->au_rslack = GSS_VERF_SLACK >> 2;
+ auth->au_flags = 0;
  auth->au_ops = &authgss_ops;
  auth->au_flavor = flavor;
  atomic_set(&auth->au_count, 1);
diff --git a/net/sunrpc/auth_null.c b/net/sunrpc/auth_null.c
index c2a2b58..e931cfb 100644
--- a/net/sunrpc/auth_null.c
+++ b/net/sunrpc/auth_null.c
@@ -115,6 +115,7 @@ static
 struct rpc_auth null_auth = {
  .au_cslack = 4,
  .au_rslack = 2,
+ .au_flags = RPCAUTH_AUTH_NO_CRKEY_TIMEOUT,
  .au_ops  = &authnull_ops,
  .au_flavor = RPC_AUTH_NULL,
  .au_count = ATOMIC_INIT(0),
diff --git a/net/sunrpc/auth_unix.c b/net/sunrpc/auth_unix.c
index 548240d..1465849 100644
--- a/net/sunrpc/auth_unix.c
+++ b/net/sunrpc/auth_unix.c
@@ -230,6 +230,7 @@ static
 struct rpc_auth  unix_auth = {
  .au_cslack = UNX_WRITESLACK,
  .au_rslack = 2,   /* assume AUTH_NULL verf */
+ .au_flags = RPCAUTH_AUTH_NO_CRKEY_TIMEOUT,
  .au_ops  = &authunix_ops,
  .au_flavor = RPC_AUTH_UNIX,
  .au_count = ATOMIC_INIT(0),
-- 
1.7.1