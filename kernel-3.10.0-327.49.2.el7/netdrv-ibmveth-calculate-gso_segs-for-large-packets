From f28d3f3647635980b51b22f82850e8fc2f55208d Mon Sep 17 00:00:00 2001
From: Gustavo Duarte <gduarte@redhat.com>
Date: Tue, 20 Dec 2016 18:55:59 +0100
Subject: [netdrv] ibmveth: calculate gso_segs for large packets

Message-id: <1482260159-10727-3-git-send-email-gduarte@redhat.com>
Patchwork-id: 161733
O-Subject: [RHEL7.4 PATCH BZ 1361958 2/2] ibmveth: calculate gso_segs for large packets
Bugzilla: 1361958
Z-Bugzilla: 1411381
RH-Acked-by: Ivan Vecera <ivecera@redhat.com>
RH-Acked-by: David S. Miller <davem@redhat.com>
RH-Acked-by: Jarod Wilson <jarod@redhat.com>
RH-Acked-by: Steve Best <sbest@redhat.com>

BZ 1361958
Upstream Status: 94acf164dc8f1184e8d0737be7125134c2701dbe

commit 94acf164dc8f1184e8d0737be7125134c2701dbe
Author: Thomas Falcon <tlfalcon@linux.vnet.ibm.com>
Date:   Tue Dec 13 18:15:09 2016 -0600

    ibmveth: calculate gso_segs for large packets

    Include calculations to compute the number of segments
    that comprise an aggregated large packet.

    Signed-off-by: Thomas Falcon <tlfalcon@linux.vnet.ibm.com>
    Reviewed-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
    Reviewed-by: Jonathan Maxwell <jmaxwell37@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

Signed-off-by: Alexander Gordeev <agordeev@redhat.com>

diff --git a/drivers/net/ethernet/ibm/ibmveth.c b/drivers/net/ethernet/ibm/ibmveth.c
index 8f3efe6..1590a04 100644
--- a/drivers/net/ethernet/ibm/ibmveth.c
+++ b/drivers/net/ethernet/ibm/ibmveth.c
@@ -1170,7 +1170,9 @@ map_failed:
 
 static void ibmveth_rx_mss_helper(struct sk_buff *skb, u16 mss, int lrg_pkt)
 {
+ struct tcphdr *tcph;
  int offset = 0;
+ int hdr_len;
 
  /* only TCP packets will be aggregated */
  if (skb->protocol == htons(ETH_P_IP)) {
@@ -1197,14 +1199,20 @@ static void ibmveth_rx_mss_helper(struct sk_buff *skb, u16 mss, int lrg_pkt)
  /* if mss is not set through Large Packet bit/mss in rx buffer,
   * expect that the mss will be written to the tcp header checksum.
   */
+ tcph = (struct tcphdr *)(skb->data + offset);
  if (lrg_pkt) {
   skb_shinfo(skb)->gso_size = mss;
  } else if (offset) {
-  struct tcphdr *tcph = (struct tcphdr *)(skb->data + offset);
-
   skb_shinfo(skb)->gso_size = ntohs(tcph->check);
   tcph->check = 0;
  }
+
+ if (skb_shinfo(skb)->gso_size) {
+  hdr_len = offset + tcph->doff * 4;
+  skb_shinfo(skb)->gso_segs =
+    DIV_ROUND_UP(skb->len - hdr_len,
+          skb_shinfo(skb)->gso_size);
+ }
 }
 
 static int ibmveth_poll(struct napi_struct *napi, int budget)
-- 
1.7.1