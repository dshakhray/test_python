From 20626d0ce6f0c67d0fe71abe52c9b0475b1caee0 Mon Sep 17 00:00:00 2001
From: Ken Cox <jkc@redhat.com>
Date: Thu, 26 May 2016 18:11:24 +0200
Subject: [netdrv] ixgbe: Save VF info and take references

Message-id: <47b7ab84f943982395b9b64d9b85f1ba97908ec8.1464282996.git.jkc@redhat.com>
Patchwork-id: 147934
O-Subject: [RHEL7.3 BZ 1274174 075/161] ixgbe: Save VF info and take references
Bugzilla: 1264529
Z-Bugzilla: 1361464
RH-Acked-by: Jarod Wilson <jarod@redhat.com>
RH-Acked-by: Tony Camuso <tcamuso@redhat.com>
RH-Acked-by: Neil Horman <nhorman@redhat.com>
RH-Acked-by: John Linville <linville@redhat.com>

Bugzilla: 1274174 1264529

Delta: My refreshed patch orders some of the diffs slightly different that upstream patch, but
       result is the same.

commit 988d13073fe122f0b6a2b80b5f2aa1b0717f9edb
Author: Mark Rustad <mark.d.rustad@intel.com>
Date:   Fri Oct 30 15:29:34 2015 -0700

    ixgbe: Save VF info and take references

    Save VF device pointers and take references to speed accesses used
    to monitor the device behavior to avoid slot resets. The saved
    information avoids lock contention during the search used to access
    each of the VFs.

    Signed-off-by: Mark Rustad <mark.d.rustad@intel.com>
    Tested-by: Darin Miller <darin.j.miller@intel.com>
    Tested-by: Phil Schmitt <phillip.j.schmitt@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

Signed-off-by: Ken Cox <jkc@redhat.com>

Cc: Ken Cox <jkc@redhat.com>
Cc: John Greene <jogreene@redhat.com>
Cc: Ivan Vecera <ivecera@redhat.com>
Signed-off-by: Alexander Gordeev <agordeev@redhat.com>

diff --git a/drivers/net/ethernet/intel/ixgbe/ixgbe.h b/drivers/net/ethernet/intel/ixgbe/ixgbe.h
index 86d789a..195fb6c 100644
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe.h
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe.h
@@ -139,6 +139,7 @@ enum ixgbe_tx_flags {
 #define IXGBE_X540_VF_DEVICE_ID         0x1515
 
 struct vf_data_storage {
+ struct pci_dev *vfdev;
  unsigned char vf_mac_addresses[ETH_ALEN];
  u16 vf_mc_hashes[IXGBE_MAX_VF_MC_ENTRIES];
  u16 num_vf_mc_hashes;
diff --git a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c b/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
index fb2c5e4..e976544 100644
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
@@ -6269,10 +6269,8 @@ static void ixgbe_check_for_bad_vf(struct ixgbe_adapter *adapter)
 {
  struct ixgbe_hw *hw = &adapter->hw;
  struct pci_dev *pdev = adapter->pdev;
- struct pci_dev *vfdev;
+ unsigned int vf;
  u32 gpc;
- int pos;
- unsigned short vf_id;
 
  if (!(netif_carrier_ok(adapter->netdev)))
   return;
@@ -6289,26 +6287,17 @@ static void ixgbe_check_for_bad_vf(struct ixgbe_adapter *adapter)
  if (!pdev)
   return;
 
- pos = pci_find_ext_capability(pdev, PCI_EXT_CAP_ID_SRIOV);
- if (!pos)
-  return;
-
- /* get the device ID for the VF */
- pci_read_config_word(pdev, pos + PCI_SRIOV_VF_DID, &vf_id);
-
  /* check status reg for all VFs owned by this PF */
- vfdev = pci_get_device(pdev->vendor, vf_id, NULL);
- while (vfdev) {
-  if (vfdev->is_virtfn && (vfdev->physfn == pdev)) {
-   u16 status_reg;
-
-   pci_read_config_word(vfdev, PCI_STATUS, &status_reg);
-   if (status_reg & PCI_STATUS_REC_MASTER_ABORT)
-    /* issue VFLR */
-    ixgbe_issue_vf_flr(adapter, vfdev);
-  }
+ for (vf = 0; vf < adapter->num_vfs; ++vf) {
+  struct pci_dev *vfdev = adapter->vfinfo[vf].vfdev;
+  u16 status_reg;
 
-  vfdev = pci_get_device(pdev->vendor, vf_id, vfdev);
+  if (!vfdev)
+   continue;
+  pci_read_config_word(vfdev, PCI_STATUS, &status_reg);
+  if (status_reg != IXGBE_FAILED_READ_CFG_WORD &&
+      status_reg & PCI_STATUS_REC_MASTER_ABORT)
+   ixgbe_issue_vf_flr(adapter, vfdev);
  }
 }
 
diff --git a/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c b/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c
index d8bd0fc..0ac0020 100644
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c
@@ -1,7 +1,7 @@
 /*******************************************************************************
 
   Intel 10 Gigabit PCI Express Linux driver
-  Copyright(c) 1999 - 2014 Intel Corporation.
+  Copyright(c) 1999 - 2015 Intel Corporation.
 
   This program is free software; you can redistribute it and/or modify it
   under the terms and conditions of the GNU General Public License,
@@ -124,6 +124,38 @@ static int __ixgbe_enable_sriov(struct ixgbe_adapter *adapter)
  return -ENOMEM;
 }
 
+/**
+ * ixgbe_get_vfs - Find and take references to all vf devices
+ * @adapter: Pointer to adapter struct
+ */
+static void ixgbe_get_vfs(struct ixgbe_adapter *adapter)
+{
+ struct pci_dev *pdev = adapter->pdev;
+ u16 vendor = pdev->vendor;
+ struct pci_dev *vfdev;
+ int vf = 0;
+ u16 vf_id;
+ int pos;
+
+ pos = pci_find_ext_capability(pdev, PCI_EXT_CAP_ID_SRIOV);
+ if (!pos)
+  return;
+ pci_read_config_word(pdev, pos + PCI_SRIOV_VF_DID, &vf_id);
+
+ vfdev = pci_get_device(vendor, vf_id, NULL);
+ for (; vfdev; vfdev = pci_get_device(vendor, vf_id, vfdev)) {
+  if (!vfdev->is_virtfn)
+   continue;
+  if (vfdev->physfn != pdev)
+   continue;
+  if (vf >= adapter->num_vfs)
+   continue;
+  pci_dev_get(vfdev);
+  adapter->vfinfo[vf].vfdev = vfdev;
+  ++vf;
+ }
+}
+
 /* Note this function is called when the user wants to enable SR-IOV
  * VFs using the now deprecated module parameter
  */
@@ -168,8 +200,10 @@ void ixgbe_enable_sriov(struct ixgbe_adapter *adapter)
   }
  }
 
- if (!__ixgbe_enable_sriov(adapter))
+ if (!__ixgbe_enable_sriov(adapter)) {
+  ixgbe_get_vfs(adapter);
   return;
+ }
 
  /* If we have gotten to this point then there is no memory available
   * to manage the VF devices - print message and bail.
@@ -182,6 +216,7 @@ void ixgbe_enable_sriov(struct ixgbe_adapter *adapter)
 #endif /* #ifdef CONFIG_PCI_IOV */
 int ixgbe_disable_sriov(struct ixgbe_adapter *adapter)
 {
+ unsigned int num_vfs = adapter->num_vfs, vf;
  struct ixgbe_hw *hw = &adapter->hw;
  u32 gpie;
  u32 vmdctl;
@@ -190,6 +225,16 @@ int ixgbe_disable_sriov(struct ixgbe_adapter *adapter)
  /* set num VFs to 0 to prevent access to vfinfo */
  adapter->num_vfs = 0;
 
+ /* put the reference to all of the vf devices */
+ for (vf = 0; vf < num_vfs; ++vf) {
+  struct pci_dev *vfdev = adapter->vfinfo[vf].vfdev;
+
+  if (!vfdev)
+   continue;
+  adapter->vfinfo[vf].vfdev = NULL;
+  pci_dev_put(vfdev);
+ }
+
  /* free VF control structures */
  kfree(adapter->vfinfo);
  adapter->vfinfo = NULL;
@@ -283,6 +328,7 @@ static int ixgbe_pci_sriov_enable(struct pci_dev *dev, int num_vfs)
   e_dev_warn("Failed to enable PCI sriov: %d\n", err);
   return err;
  }
+ ixgbe_get_vfs(adapter);
  ixgbe_sriov_reinit(adapter);
 
  return num_vfs;
-- 
1.7.1