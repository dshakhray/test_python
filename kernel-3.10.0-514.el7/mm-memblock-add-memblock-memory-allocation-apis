From 0aa26f58da98d5eca198a496f75eefd0f522f318 Mon Sep 17 00:00:00 2001
From: Koki Sanagi <ksanagi@redhat.com>
Date: Fri, 16 Sep 2016 12:33:19 -0400
Subject: [mm] memblock: add memblock memory allocation apis

Message-id: <57DBE68F.6050603@redhat.com>
Patchwork-id: 157898
O-Subject: [RHEL7.3 PATCH 1/2] mm/memblock: add memblock memory allocation apis
Bugzilla: 1375453
RH-Acked-by: Jeremy McNicoll <jmcnicol@redhat.com>
RH-Acked-by: Larry Woodman <lwoodman@redhat.com>
RH-Acked-by: Rafael Aquini <aquini@redhat.com>
RH-Acked-by: Joe Lawrence <joe.lawrence@redhat.com>

Bz:https://bugzilla.redhat.com/show_bug.cgi?id=1375453

Upstream commit:
commit 26f09e9b3a0696f6fe20b021901300fba26fb579
Author: Santosh Shilimkar <santosh.shilimkar@ti.com>
Date:   Wed Sep 14 10:40:27 2016 -0400

    mm/memblock: add memblock memory allocation apis

    Introduce memblock memory allocation APIs which allow to support PAE or
    LPAE extension on 32 bits archs where the physical memory start address
    can be beyond 4GB.  In such cases, existing bootmem APIs which operate
    on 32 bit addresses won't work and needs memblock layer which operates
    on 64 bit addresses.

    So we add equivalent APIs so that we can replace usage of bootmem with
    memblock interfaces.  Architectures already converted to NO_BOOTMEM use
    these new memblock interfaces.  The architectures which are still not
    converted to NO_BOOTMEM continue to function as is because we still
    maintain the fal lback option of bootmem back-end supporting these new
    interfaces.  So no functional change as such.

    In long run, once all the architectures moves to NO_BOOTMEM, we can get
    rid of bootmem layer completely.  This is one step to remove the core
    code dependency with bootmem and also gives path for architectures to
    move away from bootmem.

    The proposed interface will became active if both CONFIG_HAVE_MEMBLOCK
    and CONFIG_NO_BOOTMEM are specified by arch.  In case
    !CONFIG_NO_BOOTMEM, the memblock() wrappers will fallback to the
    existing bootmem apis so that arch's not converted to NO_BOOTMEM
    continue to work as is.

    The meaning of MEMBLOCK_ALLOC_ACCESSIBLE and MEMBLOCK_ALLOC_ANYWHERE
    is kept same.

    [akpm@linux-foundation.org: s/depricated/deprecated/]
    Signed-off-by: Grygorii Strashko <grygorii.strashko@ti.com>
    Signed-off-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: "Rafael J. Wysocki" <rjw@sisk.pl>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Christoph Lameter <cl@linux-foundation.org>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Johannes Weiner <hannes@cmpxchg.org>
    Cc: KAMEZAWA Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com>
    Cc: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Cc: Michal Hocko <mhocko@suse.cz>
    Cc: Paul Walmsley <paul@pwsan.com>
    Cc: Pavel Machek <pavel@ucw.cz>
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

Pulls in parts from upstream:

  a3f5bafcc04aa mm/memblock: allocate boot time data structures from mirrored memory
  f1af9d3af3081 mm/memblock: Do some refactoring, enhance API
  d70ddd7a5d9aa mm: page_alloc: pass PFN to __free_pages_bootmem

Signed-off-by: Rafael Aquini <aquini@redhat.com>

diff --git a/arch/arm/include/asm/dma.h b/arch/arm/include/asm/dma.h
index 58b8c6a..9908443 100644
--- a/arch/arm/include/asm/dma.h
+++ b/arch/arm/include/asm/dma.h
@@ -8,8 +8,8 @@
 #define MAX_DMA_ADDRESS 0xffffffffUL
 #else
 #define MAX_DMA_ADDRESS ({ \
- extern unsigned long arm_dma_zone_size; \
- arm_dma_zone_size ? \
+ extern phys_addr_t arm_dma_zone_size; \
+ arm_dma_zone_size && arm_dma_zone_size < (0x10000000 - PAGE_OFFSET) ? \
   (PAGE_OFFSET + arm_dma_zone_size) : 0xffffffffUL; })
 #endif
 
diff --git a/include/linux/bootmem.h b/include/linux/bootmem.h
index 9cf9e98..e9263ba 100644
--- a/include/linux/bootmem.h
+++ b/include/linux/bootmem.h
@@ -5,6 +5,7 @@
 #define _LINUX_BOOTMEM_H
 
 #include <linux/mmzone.h>
+#include <linux/mm_types.h>
 #include <asm/dma.h>
 
 /*
@@ -147,6 +148,157 @@ extern void *__alloc_bootmem_low_node(pg_data_t *pgdat,
 #define alloc_bootmem_low_pages_node(pgdat, x) \
  __alloc_bootmem_low_node(pgdat, x, PAGE_SIZE, 0)
 
+
+#if defined(CONFIG_HAVE_MEMBLOCK) && defined(CONFIG_NO_BOOTMEM)
+
+/* FIXME: use MEMBLOCK_ALLOC_* variants here */
+#define BOOTMEM_ALLOC_ACCESSIBLE 0
+#define BOOTMEM_ALLOC_ANYWHERE  (~(phys_addr_t)0)
+
+/* FIXME: Move to memblock.h at a point where we remove nobootmem.c */
+void *memblock_virt_alloc_try_nid_nopanic(phys_addr_t size,
+  phys_addr_t align, phys_addr_t min_addr,
+  phys_addr_t max_addr, int nid);
+void *memblock_virt_alloc_try_nid(phys_addr_t size, phys_addr_t align,
+  phys_addr_t min_addr, phys_addr_t max_addr, int nid);
+void __memblock_free_early(phys_addr_t base, phys_addr_t size);
+void __memblock_free_late(phys_addr_t base, phys_addr_t size);
+
+static inline void * __init memblock_virt_alloc(
+     phys_addr_t size,  phys_addr_t align)
+{
+ return memblock_virt_alloc_try_nid(size, align, BOOTMEM_LOW_LIMIT,
+         BOOTMEM_ALLOC_ACCESSIBLE,
+         NUMA_NO_NODE);
+}
+
+static inline void * __init memblock_virt_alloc_nopanic(
+     phys_addr_t size, phys_addr_t align)
+{
+ return memblock_virt_alloc_try_nid_nopanic(size, align,
+          BOOTMEM_LOW_LIMIT,
+          BOOTMEM_ALLOC_ACCESSIBLE,
+          NUMA_NO_NODE);
+}
+
+static inline void * __init memblock_virt_alloc_from_nopanic(
+  phys_addr_t size, phys_addr_t align, phys_addr_t min_addr)
+{
+ return memblock_virt_alloc_try_nid_nopanic(size, align, min_addr,
+          BOOTMEM_ALLOC_ACCESSIBLE,
+          NUMA_NO_NODE);
+}
+
+static inline void * __init memblock_virt_alloc_node(
+      phys_addr_t size, int nid)
+{
+ return memblock_virt_alloc_try_nid(size, 0, BOOTMEM_LOW_LIMIT,
+         BOOTMEM_ALLOC_ACCESSIBLE, nid);
+}
+
+static inline void * __init memblock_virt_alloc_node_nopanic(
+      phys_addr_t size, int nid)
+{
+ return memblock_virt_alloc_try_nid_nopanic(size, 0, BOOTMEM_LOW_LIMIT,
+          BOOTMEM_ALLOC_ACCESSIBLE,
+          nid);
+}
+
+static inline void __init memblock_free_early(
+     phys_addr_t base, phys_addr_t size)
+{
+ __memblock_free_early(base, size);
+}
+
+static inline void __init memblock_free_early_nid(
+    phys_addr_t base, phys_addr_t size, int nid)
+{
+ __memblock_free_early(base, size);
+}
+
+static inline void __init memblock_free_late(
+     phys_addr_t base, phys_addr_t size)
+{
+ __memblock_free_late(base, size);
+}
+
+#else
+
+#define BOOTMEM_ALLOC_ACCESSIBLE 0
+
+
+/* Fall back to all the existing bootmem APIs */
+static inline void * __init memblock_virt_alloc(
+     phys_addr_t size,  phys_addr_t align)
+{
+ if (!align)
+  align = SMP_CACHE_BYTES;
+ return __alloc_bootmem(size, align, BOOTMEM_LOW_LIMIT);
+}
+
+static inline void * __init memblock_virt_alloc_nopanic(
+     phys_addr_t size, phys_addr_t align)
+{
+ if (!align)
+  align = SMP_CACHE_BYTES;
+ return __alloc_bootmem_nopanic(size, align, BOOTMEM_LOW_LIMIT);
+}
+
+static inline void * __init memblock_virt_alloc_from_nopanic(
+  phys_addr_t size, phys_addr_t align, phys_addr_t min_addr)
+{
+ return __alloc_bootmem_nopanic(size, align, min_addr);
+}
+
+static inline void * __init memblock_virt_alloc_node(
+      phys_addr_t size, int nid)
+{
+ return __alloc_bootmem_node(NODE_DATA(nid), size, SMP_CACHE_BYTES,
+         BOOTMEM_LOW_LIMIT);
+}
+
+static inline void * __init memblock_virt_alloc_node_nopanic(
+      phys_addr_t size, int nid)
+{
+ return __alloc_bootmem_node_nopanic(NODE_DATA(nid), size,
+          SMP_CACHE_BYTES,
+          BOOTMEM_LOW_LIMIT);
+}
+
+static inline void * __init memblock_virt_alloc_try_nid(phys_addr_t size,
+ phys_addr_t align, phys_addr_t min_addr, phys_addr_t max_addr, int nid)
+{
+ return __alloc_bootmem_node_high(NODE_DATA(nid), size, align,
+       min_addr);
+}
+
+static inline void * __init memblock_virt_alloc_try_nid_nopanic(
+   phys_addr_t size, phys_addr_t align,
+   phys_addr_t min_addr, phys_addr_t max_addr, int nid)
+{
+ return ___alloc_bootmem_node_nopanic(NODE_DATA(nid), size, align,
+    min_addr, max_addr);
+}
+
+static inline void __init memblock_free_early(
+     phys_addr_t base, phys_addr_t size)
+{
+ free_bootmem(base, size);
+}
+
+static inline void __init memblock_free_early_nid(
+    phys_addr_t base, phys_addr_t size, int nid)
+{
+ free_bootmem_node(NODE_DATA(nid), base, size);
+}
+
+static inline void __init memblock_free_late(
+     phys_addr_t base, phys_addr_t size)
+{
+ free_bootmem_late(base, size);
+}
+#endif /* defined(CONFIG_HAVE_MEMBLOCK) && defined(CONFIG_NO_BOOTMEM) */
+
 #ifdef CONFIG_HAVE_ARCH_ALLOC_REMAP
 extern void *alloc_remap(int nid, unsigned long size);
 #else
diff --git a/mm/memblock.c b/mm/memblock.c
index e367890..f9605b9 100644
--- a/mm/memblock.c
+++ b/mm/memblock.c
@@ -19,8 +19,12 @@
 #include <linux/debugfs.h>
 #include <linux/seq_file.h>
 #include <linux/memblock.h>
+#include <linux/kmemleak.h>
 
 #include <asm-generic/sections.h>
+#include <linux/io.h>
+
+#include "internal.h"
 
 static struct memblock_region memblock_memory_init_regions[INIT_MEMBLOCK_REGIONS] __initdata_memblock;
 static struct memblock_region memblock_reserved_init_regions[INIT_MEMBLOCK_REGIONS] __initdata_memblock;
@@ -1157,6 +1161,213 @@ phys_addr_t __init memblock_alloc_try_nid(phys_addr_t size, phys_addr_t align, i
  return memblock_alloc_base(size, align, MEMBLOCK_ALLOC_ACCESSIBLE);
 }
 
+/**
+ * memblock_virt_alloc_internal - allocate boot memory block
+ * @size: size of memory block to be allocated in bytes
+ * @align: alignment of the region and block's size
+ * @min_addr: the lower bound of the memory region to allocate (phys address)
+ * @max_addr: the upper bound of the memory region to allocate (phys address)
+ * @nid: nid of the free area to find, %NUMA_NO_NODE for any node
+ *
+ * The @min_addr limit is dropped if it can not be satisfied and the allocation
+ * will fall back to memory below @min_addr. Also, allocation may fall back
+ * to any node in the system if the specified node can not
+ * hold the requested memory.
+ *
+ * The allocation is performed from memory region limited by
+ * memblock.current_limit if @max_addr == %BOOTMEM_ALLOC_ACCESSIBLE.
+ *
+ * The memory block is aligned on SMP_CACHE_BYTES if @align == 0.
+ *
+ * The phys address of allocated boot memory block is converted to virtual and
+ * allocated memory is reset to 0.
+ *
+ * In addition, function sets the min_count to 0 using kmemleak_alloc for
+ * allocated boot memory block, so that it is never reported as leaks.
+ *
+ * RETURNS:
+ * Virtual address of allocated memory block on success, NULL on failure.
+ */
+static void * __init memblock_virt_alloc_internal(
+    phys_addr_t size, phys_addr_t align,
+    phys_addr_t min_addr, phys_addr_t max_addr,
+    int nid)
+{
+ phys_addr_t alloc;
+ void *ptr;
+ ulong flags = choose_memblock_flags();
+
+ if (nid == MAX_NUMNODES)
+  pr_warn("%s: usage of MAX_NUMNODES is deprecated. Use NUMA_NO_NODE\n",
+   __func__);
+
+ /*
+  * Detect any accidental use of these APIs after slab is ready, as at
+  * this moment memblock may be deinitialized already and its
+  * internal data may be destroyed (after execution of free_all_bootmem)
+  */
+ if (WARN_ON_ONCE(slab_is_available()))
+  return kzalloc_node(size, GFP_NOWAIT, nid);
+
+ if (!align)
+  align = SMP_CACHE_BYTES;
+
+ /* align @size to avoid excessive fragmentation on reserved array */
+ size = round_up(size, align);
+
+again:
+ alloc = memblock_find_in_range_node(size, align, min_addr, max_addr,
+         nid, flags);
+ if (alloc)
+  goto done;
+
+ if (nid != NUMA_NO_NODE) {
+  alloc = memblock_find_in_range_node(size, align, min_addr,
+          max_addr,  NUMA_NO_NODE,
+          flags);
+  if (alloc)
+   goto done;
+ }
+
+ if (min_addr) {
+  min_addr = 0;
+  goto again;
+ }
+
+ if (flags & MEMBLOCK_MIRROR) {
+  flags &= ~MEMBLOCK_MIRROR;
+  pr_warn("Could not allocate %pap bytes of mirrored memory\n",
+   &size);
+  goto again;
+ }
+
+ return NULL;
+done:
+ memblock_reserve(alloc, size);
+ ptr = phys_to_virt(alloc);
+ memset(ptr, 0, size);
+
+ /*
+  * The min_count is set to 0 so that bootmem allocated blocks
+  * are never reported as leaks. This is because many of these blocks
+  * are only referred via the physical address which is not
+  * looked up by kmemleak.
+  */
+ kmemleak_alloc(ptr, size, 0, 0);
+
+ return ptr;
+}
+
+/**
+ * memblock_virt_alloc_try_nid_nopanic - allocate boot memory block
+ * @size: size of memory block to be allocated in bytes
+ * @align: alignment of the region and block's size
+ * @min_addr: the lower bound of the memory region from where the allocation
+ *   is preferred (phys address)
+ * @max_addr: the upper bound of the memory region from where the allocation
+ *       is preferred (phys address), or %BOOTMEM_ALLOC_ACCESSIBLE to
+ *       allocate only from memory limited by memblock.current_limit value
+ * @nid: nid of the free area to find, %NUMA_NO_NODE for any node
+ *
+ * Public version of _memblock_virt_alloc_try_nid_nopanic() which provides
+ * additional debug information (including caller info), if enabled.
+ *
+ * RETURNS:
+ * Virtual address of allocated memory block on success, NULL on failure.
+ */
+void * __init memblock_virt_alloc_try_nid_nopanic(
+    phys_addr_t size, phys_addr_t align,
+    phys_addr_t min_addr, phys_addr_t max_addr,
+    int nid)
+{
+ memblock_dbg("%s: %llu bytes align=0x%llx nid=%d from=0x%llx max_addr=0x%llx %pF\n",
+       __func__, (u64)size, (u64)align, nid, (u64)min_addr,
+       (u64)max_addr, (void *)_RET_IP_);
+ return memblock_virt_alloc_internal(size, align, min_addr,
+          max_addr, nid);
+}
+
+/**
+ * memblock_virt_alloc_try_nid - allocate boot memory block with panicking
+ * @size: size of memory block to be allocated in bytes
+ * @align: alignment of the region and block's size
+ * @min_addr: the lower bound of the memory region from where the allocation
+ *   is preferred (phys address)
+ * @max_addr: the upper bound of the memory region from where the allocation
+ *       is preferred (phys address), or %BOOTMEM_ALLOC_ACCESSIBLE to
+ *       allocate only from memory limited by memblock.current_limit value
+ * @nid: nid of the free area to find, %NUMA_NO_NODE for any node
+ *
+ * Public panicking version of _memblock_virt_alloc_try_nid_nopanic()
+ * which provides debug information (including caller info), if enabled,
+ * and panics if the request can not be satisfied.
+ *
+ * RETURNS:
+ * Virtual address of allocated memory block on success, NULL on failure.
+ */
+void * __init memblock_virt_alloc_try_nid(
+   phys_addr_t size, phys_addr_t align,
+   phys_addr_t min_addr, phys_addr_t max_addr,
+   int nid)
+{
+ void *ptr;
+
+ memblock_dbg("%s: %llu bytes align=0x%llx nid=%d from=0x%llx max_addr=0x%llx %pF\n",
+       __func__, (u64)size, (u64)align, nid, (u64)min_addr,
+       (u64)max_addr, (void *)_RET_IP_);
+ ptr = memblock_virt_alloc_internal(size, align,
+        min_addr, max_addr, nid);
+ if (ptr)
+  return ptr;
+
+ panic("%s: Failed to allocate %llu bytes align=0x%llx nid=%d from=0x%llx max_addr=0x%llx\n",
+       __func__, (u64)size, (u64)align, nid, (u64)min_addr,
+       (u64)max_addr);
+ return NULL;
+}
+
+/**
+ * __memblock_free_early - free boot memory block
+ * @base: phys starting address of the  boot memory block
+ * @size: size of the boot memory block in bytes
+ *
+ * Free boot memory block previously allocated by memblock_virt_alloc_xx() API.
+ * The freeing memory will not be released to the buddy allocator.
+ */
+void __init __memblock_free_early(phys_addr_t base, phys_addr_t size)
+{
+ memblock_dbg("%s: [%#016llx-%#016llx] %pF\n",
+       __func__, (u64)base, (u64)base + size - 1,
+       (void *)_RET_IP_);
+ kmemleak_free_part(__va(base), size);
+ memblock_remove_range(&memblock.reserved, base, size);
+}
+
+/*
+ * __memblock_free_late - free bootmem block pages directly to buddy allocator
+ * @addr: phys starting address of the  boot memory block
+ * @size: size of the boot memory block in bytes
+ *
+ * This is only useful when the bootmem allocator has already been torn
+ * down, but we are still initializing the system.  Pages are released directly
+ * to the buddy allocator, no bootmem metadata is updated because it is gone.
+ */
+void __init __memblock_free_late(phys_addr_t base, phys_addr_t size)
+{
+ u64 cursor, end;
+
+ memblock_dbg("%s: [%#016llx-%#016llx] %pF\n",
+       __func__, (u64)base, (u64)base + size - 1,
+       (void *)_RET_IP_);
+ kmemleak_free_part(__va(base), size);
+ cursor = PFN_UP(base);
+ end = PFN_DOWN(base + size);
+
+ for (; cursor < end; cursor++) {
+  __free_pages_bootmem(pfn_to_page(cursor), cursor, 0);
+  totalram_pages++;
+ }
+}
 
 /*
  * Remaining API functions
-- 
1.7.1