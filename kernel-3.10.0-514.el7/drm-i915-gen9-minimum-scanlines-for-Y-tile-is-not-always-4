From b1545a268862ba3dd36e2ede476beac0c75ceb23 Mon Sep 17 00:00:00 2001
From: Lyude Paul <cpaul@redhat.com>
Date: Thu, 15 Sep 2016 17:56:52 -0400
Subject: [drm] i915/gen9: minimum scanlines for Y tile is not always 4

Message-id: <1473962216-29060-12-git-send-email-cpaul@redhat.com>
Patchwork-id: 157893
O-Subject: [RHEL7.3][RESEND PATCH v2 11/15] drm/i915/gen9: minimum scanlines for Y tile is not always 4
Bugzilla: 1341633 1355776
RH-Acked-by: Adam Jackson <ajax@redhat.com>
RH-Acked-by: Rob Clark <rclark@redhat.com>

From: Lyude Paul <cpaul@redhat.com>

Upstream status: posted

 drm/i915/gen9: minimum scanlines for Y tile is not always 4
 Author: Paulo Zanoni <paulo.r.zanoni@intel.com>

 During watermarks calculations, this value is used in 3 different
 places. Only one of them was not using a hardcoded 4. Move the code up
 so everybody can benefit from the actual value.

 This should only help on situations with Y tiling + 90/270 rotation +
 1 or 2 bpp or NV12.

 Signed-off-by: Paulo Zanoni <paulo.r.zanoni@intel.com>

RHBZ: 1341633
RHBZ: 1355776
Signed-off-by: Lyude Paul <cpaul@redhat.com>
Signed-off-by: Lyude <cpaul@redhat.com>
Signed-off-by: Rafael Aquini <aquini@redhat.com>

diff --git a/drivers/gpu/drm/i915/intel_pm.c b/drivers/gpu/drm/i915/intel_pm.c
index a692974..6bf150e 100644
--- a/drivers/gpu/drm/i915/intel_pm.c
+++ b/drivers/gpu/drm/i915/intel_pm.c
@@ -3283,7 +3283,8 @@ static uint32_t skl_wm_method1(uint32_t pixel_rate, uint8_t cpp, uint32_t latenc
 
 static uint32_t skl_wm_method2(uint32_t pixel_rate, uint32_t pipe_htotal,
           uint32_t horiz_pixels, uint8_t cpp,
-          uint64_t tiling, uint32_t latency)
+          uint64_t tiling, uint32_t latency,
+          uint32_t y_min_scanlines)
 {
  uint32_t ret;
  uint32_t plane_bytes_per_line, plane_blocks_per_line;
@@ -3296,9 +3297,11 @@ static uint32_t skl_wm_method2(uint32_t pixel_rate, uint32_t pipe_htotal,
 
  if (tiling == I915_FORMAT_MOD_Y_TILED ||
      tiling == I915_FORMAT_MOD_Yf_TILED) {
-  plane_bytes_per_line *= 4;
+  plane_bytes_per_line *= y_min_scanlines;
   plane_blocks_per_line = DIV_ROUND_UP(plane_bytes_per_line, 512);
-  plane_blocks_per_line /= 4;
+  plane_blocks_per_line /= y_min_scanlines;
+ } else if (tiling == DRM_FORMAT_MOD_NONE) {
+  plane_blocks_per_line = DIV_ROUND_UP(plane_bytes_per_line, 512) + 1;
  } else {
   plane_blocks_per_line = DIV_ROUND_UP(plane_bytes_per_line, 512);
  }
@@ -3328,6 +3331,7 @@ static int skl_compute_plane_wm(const struct drm_i915_private *dev_priv,
  uint32_t selected_result;
  uint8_t cpp;
  uint32_t width = 0, height = 0;
+ uint32_t y_min_scanlines;
 
  if (latency == 0 || !cstate->base.active || !intel_pstate->visible) {
   *enabled = false;
@@ -3341,6 +3345,28 @@ static int skl_compute_plane_wm(const struct drm_i915_private *dev_priv,
   swap(width, height);
 
  cpp = drm_format_plane_cpp(fb->pixel_format, 0);
+ if (intel_rotation_90_or_270(pstate->rotation)) {
+  int cpp = (fb->pixel_format == DRM_FORMAT_NV12) ?
+   drm_format_plane_cpp(fb->pixel_format, 1) :
+   drm_format_plane_cpp(fb->pixel_format, 0);
+
+  switch (cpp) {
+  case 1:
+   y_min_scanlines = 16;
+   break;
+  case 2:
+   y_min_scanlines = 8;
+   break;
+  default:
+   WARN(1, "Unsupported pixel depth for rotation");
+  case 4:
+   y_min_scanlines = 4;
+   break;
+  }
+ } else {
+  y_min_scanlines = 4;
+ }
+
  method1 = skl_wm_method1(skl_pipe_pixel_rate(cstate),
      cpp, latency);
  method2 = skl_wm_method2(skl_pipe_pixel_rate(cstate),
@@ -3348,32 +3374,16 @@ static int skl_compute_plane_wm(const struct drm_i915_private *dev_priv,
      width,
      cpp,
      fb->modifier[0],
-     latency);
+     latency,
+     y_min_scanlines);
 
  plane_bytes_per_line = width * cpp;
  plane_blocks_per_line = DIV_ROUND_UP(plane_bytes_per_line, 512);
 
  if (fb->modifier[0] == I915_FORMAT_MOD_Y_TILED ||
      fb->modifier[0] == I915_FORMAT_MOD_Yf_TILED) {
-  uint32_t min_scanlines = 4;
-  uint32_t y_tile_minimum;
-  if (intel_rotation_90_or_270(pstate->rotation)) {
-   int cpp = (fb->pixel_format == DRM_FORMAT_NV12) ?
-    drm_format_plane_cpp(fb->pixel_format, 1) :
-    drm_format_plane_cpp(fb->pixel_format, 0);
-
-   switch (cpp) {
-   case 1:
-    min_scanlines = 16;
-    break;
-   case 2:
-    min_scanlines = 8;
-    break;
-   case 8:
-    WARN(1, "Unsupported pixel depth for rotation");
-   }
-  }
-  y_tile_minimum = plane_blocks_per_line * min_scanlines;
+  uint32_t y_tile_minimum = plane_blocks_per_line *
+       y_min_scanlines;
   selected_result = max(method2, y_tile_minimum);
  } else {
   if ((ddb_allocation / plane_blocks_per_line) >= 1)
@@ -3388,7 +3398,7 @@ static int skl_compute_plane_wm(const struct drm_i915_private *dev_priv,
  if (level >= 1 && level <= 7) {
   if (fb->modifier[0] == I915_FORMAT_MOD_Y_TILED ||
       fb->modifier[0] == I915_FORMAT_MOD_Yf_TILED)
-   res_lines += 4;
+   res_lines += y_min_scanlines;
   else
    res_blocks++;
  }
-- 
1.7.1