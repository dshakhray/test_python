From 2466c310c14829c138c17e98f1843a2206b784f3 Mon Sep 17 00:00:00 2001
From: Lyude Paul <cpaul@redhat.com>
Date: Thu, 15 Sep 2016 17:56:45 -0400
Subject: [drm] i915/gen9: Only copy WM results for changed pipes to skl_hw

Message-id: <1473962216-29060-5-git-send-email-cpaul@redhat.com>
Patchwork-id: 157881
O-Subject: [RHEL7.3][RESEND PATCH v2 04/15] drm/i915/gen9: Only copy WM results for changed pipes to skl_hw
Bugzilla: 1341633 1355776
RH-Acked-by: Adam Jackson <ajax@redhat.com>
RH-Acked-by: Rob Clark <rclark@redhat.com>

From: Lyude Paul <cpaul@redhat.com>

Upstream: since v4.8

commit 9909113cc48a7ce6e772573e3cc82a3f03ffa8ef

Author: Matt Roper <matthew.d.roper@intel.com>
Date:   Wed Aug 17 15:55:55 2016 -0400

    drm/i915/gen9: Only copy WM results for changed pipes to skl_hw

    When we write watermark values to the hardware, those values are stored
    in dev_priv->wm.skl_hw.  However with recent watermark changes, the
    results structure we're copying from only contains valid watermark and
    DDB values for the pipes that are actually changing; the values for
    other pipes remain 0.  Thus a blind copy of the entire skl_wm_values
    structure will clobber the values for unchanged pipes...we need to be
    more selective and only copy over the values for the changing pipes.

    This mistake was hidden until recently due to another bug that caused us
    to erroneously re-calculate watermarks for all active pipes rather than
    changing pipes.  Only when that bug was fixed was the impact of this bug
    discovered (e.g., modesets failing with "Requested display configuration
    exceeds system watermark limitations" messages and leaving watermarks
    non-functional, even ones initiated by intel_fbdev_restore_mode).

    Changes since v1:
     - Add a function for copying a pipe's wm values
       (skl_copy_wm_for_pipe()) so we can reuse this later

    Fixes: 734fa01f3a17 ("drm/i915/gen9: Calculate watermarks during atomic 'check' (v2)")
    Fixes: 9b6130227495 ("drm/i915/gen9: Re-allocate DDB only for changed pipes")
    Signed-off-by: Matt Roper <matthew.d.roper@intel.com>
    Signed-off-by: Lyude <cpaul@redhat.com>
    Reviewed-by: Matt Roper <matthew.d.roper@intel.com>
    Cc: stable@vger.kernel.org
    Cc: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Cc: Ville Syrjl <ville.syrjala@linux.intel.com>
    Cc: Daniel Vetter <daniel.vetter@intel.com>
    Cc: Radhakrishna Sripada <radhakrishna.sripada@intel.com>
    Cc: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1471463761-26796-4-git-send-email-cpaul@redhat.com
    (cherry picked from commit 2722efb90b3420dee54b4cb3cdc7917efacc2dce)
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>

RHBZ: 1341633
RHBZ: 1355776
Signed-off-by: Lyude Paul <cpaul@redhat.com>
Signed-off-by: Lyude <cpaul@redhat.com>
Signed-off-by: Rafael Aquini <aquini@redhat.com>

diff --git a/drivers/gpu/drm/i915/intel_pm.c b/drivers/gpu/drm/i915/intel_pm.c
index 9496e52..57337fa 100644
--- a/drivers/gpu/drm/i915/intel_pm.c
+++ b/drivers/gpu/drm/i915/intel_pm.c
@@ -3872,6 +3872,24 @@ skl_compute_ddb(struct drm_atomic_state *state)
  return 0;
 }
 
+static void
+skl_copy_wm_for_pipe(struct skl_wm_values *dst,
+       struct skl_wm_values *src,
+       enum pipe pipe)
+{
+ dst->wm_linetime[pipe] = src->wm_linetime[pipe];
+ memcpy(dst->plane[pipe], src->plane[pipe],
+        sizeof(dst->plane[pipe]));
+ memcpy(dst->plane_trans[pipe], src->plane_trans[pipe],
+        sizeof(dst->plane_trans[pipe]));
+
+ dst->ddb.pipe[pipe] = src->ddb.pipe[pipe];
+ memcpy(dst->ddb.y_plane[pipe], src->ddb.y_plane[pipe],
+        sizeof(dst->ddb.y_plane[pipe]));
+ memcpy(dst->ddb.plane[pipe], src->ddb.plane[pipe],
+        sizeof(dst->ddb.plane[pipe]));
+}
+
 static int
 skl_compute_wm(struct drm_atomic_state *state)
 {
@@ -3943,8 +3961,10 @@ static void skl_update_wm(struct drm_crtc *crtc)
  struct drm_device *dev = crtc->dev;
  struct drm_i915_private *dev_priv = dev->dev_private;
  struct skl_wm_values *results = &dev_priv->wm.skl_results;
+ struct skl_wm_values *hw_vals = &dev_priv->wm.skl_hw;
  struct intel_crtc_state *cstate = to_intel_crtc_state(crtc->state);
  struct skl_pipe_wm *pipe_wm = &cstate->wm.skl.optimal;
+ int pipe;
 
  if ((results->dirty_pipes & drm_crtc_mask(crtc)) == 0)
   return;
@@ -3954,8 +3974,12 @@ static void skl_update_wm(struct drm_crtc *crtc)
  skl_write_wm_values(dev_priv, results);
  skl_flush_wm_values(dev_priv, results);
 
- /* store the new configuration */
- dev_priv->wm.skl_hw = *results;
+ /*
+  * Store the new configuration (but only for the pipes that have
+  * changed; the other values weren't recomputed).
+  */
+ for_each_pipe_masked(dev_priv, pipe, results->dirty_pipes)
+  skl_copy_wm_for_pipe(hw_vals, results, pipe);
 }
 
 static void ilk_compute_wm_config(struct drm_device *dev,
-- 
1.7.1