From 07e485765a744cac7dbb887a73c4c0fdc0ba822e Mon Sep 17 00:00:00 2001
From: Richard Guy Briggs <rgb@redhat.com>
Date: Sat, 17 Sep 2016 23:42:17 -0400
Subject: [kernel] prctl: avoid using mmap_sem for exe_file serialization

Message-id: <afdaebc62dd901a1c94fc6ca66f2a8a60ddb1205.1473974354.git.rgb@redhat.com>
Patchwork-id: 157920
O-Subject: [RHEL7 PATCH V2 2/4] prctl: avoid using mmap_sem for exe_file serialization
Bugzilla: 1374478
RH-Acked-by: Herton R. Krzesinski <herton@redhat.com>
RH-Acked-by: Eric W. Biederman <ebiederm@redhat.com>
RH-Acked-by: Larry Woodman <lwoodman@redhat.com>
RH-Acked-by: Rafael Aquini <aquini@redhat.com>
RH-Acked-by: Paul Moore <pmoore@redhat.com>

From: Davidlohr Bueso <dave@stgolabs.net>

Oleg cleverly suggested using xchg() to set the new mm->exe_file instead
of calling set_mm_exe_file() which requires some form of serialization --
mmap_sem in this case.  For archs that do not have atomic rmw instructions
we still fallback to a spinlock alternative, so this should always be
safe.  As such, we only need the mmap_sem for looking up the backing
vm_file, which can be done sharing the lock.  Naturally, this means we
need to manually deal with both the new and old file reference counting,
and we need not worry about the MMF_EXE_FILE_CHANGED bits, which can
probably be deleted in the future anyway.

Signed-off-by: Davidlohr Bueso <dbueso@suse.de>
Suggested-by: Oleg Nesterov <oleg@redhat.com>
Acked-by: Oleg Nesterov <oleg@redhat.com>
Reviewed-by: Konstantin Khlebnikov <khlebnikov@yandex-team.ru>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry-pick from 6e399cd144d8500ffb5d40fa6848890e2580a80a)
(resolve conflict 96dad67ff244 use VM_BUG_ON_MM)
(resolve conflict 23aebe1691a3 kill bprm->tcomm)
 (wanted this, but would cause kABI breakage)
Signed-off-by: Richard Guy Briggs <rgb@redhat.com>

Signed-off-by: Rafael Aquini <aquini@redhat.com>

diff --git a/fs/exec.c b/fs/exec.c
index 40b9633..cc7185c 100644
--- a/fs/exec.c
+++ b/fs/exec.c
@@ -1084,6 +1084,11 @@ int flush_old_exec(struct linux_binprm * bprm)
  if (retval)
   goto out;
 
+ /*
+  * Must be called _before_ exec_mmap() as bprm->mm is
+  * not visibile until then. This also enables the update
+  * to be lockless.
+  */
  set_mm_exe_file(bprm->mm, bprm->file);
 
  filename_to_taskname(bprm->tcomm, bprm->filename, sizeof(bprm->tcomm));
diff --git a/kernel/fork.c b/kernel/fork.c
index 1068dd8..cb8343b 100644
--- a/kernel/fork.c
+++ b/kernel/fork.c
@@ -681,15 +681,22 @@ EXPORT_SYMBOL_GPL(mmput);
  *
  * This changes mm's executable file (shown as symlink /proc/[pid]/exe).
  *
- * Main users are mmput(), sys_execve() and sys_prctl(PR_SET_MM_MAP/EXE_FILE).
- * Callers prevent concurrent invocations: in mmput() nobody alive left,
- * in execve task is single-threaded, prctl holds mmap_sem exclusively.
+ * Main users are mmput() and sys_execve(). Callers prevent concurrent
+ * invocations: in mmput() nobody alive left, in execve task is single
+ * threaded. sys_prctl(PR_SET_MM_MAP/EXE_FILE) also needs to set the
+ * mm->exe_file, but does so without using set_mm_exe_file() in order
+ * to do avoid the need for any locks.
  */
 void set_mm_exe_file(struct mm_struct *mm, struct file *new_exe_file)
 {
- struct file *old_exe_file = rcu_dereference_protected(mm->exe_file,
-   !atomic_read(&mm->mm_users) || current->in_execve ||
-   lockdep_is_held(&mm->mmap_sem));
+ struct file *old_exe_file;
+
+ /*
+  * It is safe to dereference the exe_file without RCU as
+  * this function is only called if nobody else can access
+  * this mm -- see comment above for justification.
+  */
+ old_exe_file = rcu_dereference_raw(mm->exe_file);
 
  if (new_exe_file)
   get_file(new_exe_file);
diff --git a/kernel/sys.c b/kernel/sys.c
index a5f548e..02adba4 100644
--- a/kernel/sys.c
+++ b/kernel/sys.c
@@ -1898,14 +1898,13 @@ SYSCALL_DEFINE1(umask, int, mask)
  return mask;
 }
 
-static int prctl_set_mm_exe_file_locked(struct mm_struct *mm, unsigned int fd)
+static int prctl_set_mm_exe_file(struct mm_struct *mm, unsigned int fd)
 {
  struct fd exe;
+ struct file *old_exe, *exe_file;
  struct inode *inode;
  int err;
 
- VM_BUG_ON(!rwsem_is_locked(&mm->mmap_sem));
-
  exe = fdget(fd);
  if (!exe.file)
   return -EBADF;
@@ -1929,15 +1928,22 @@ static int prctl_set_mm_exe_file_locked(struct mm_struct *mm, unsigned int fd)
  /*
   * Forbid mm->exe_file change if old file still mapped.
   */
+ exe_file = get_mm_exe_file(mm);
  err = -EBUSY;
- if (mm->exe_file) {
+ if (exe_file) {
   struct vm_area_struct *vma;
 
-  for (vma = mm->mmap; vma; vma = vma->vm_next)
-   if (vma->vm_file &&
-       path_equal(&vma->vm_file->f_path,
-           &mm->exe_file->f_path))
-    goto exit;
+  down_read(&mm->mmap_sem);
+  for (vma = mm->mmap; vma; vma = vma->vm_next) {
+   if (!vma->vm_file)
+    continue;
+   if (path_equal(&vma->vm_file->f_path,
+           &exe_file->f_path))
+    goto exit_err;
+  }
+
+  up_read(&mm->mmap_sem);
+  fput(exe_file);
  }
 
  /*
@@ -1951,10 +1957,18 @@ static int prctl_set_mm_exe_file_locked(struct mm_struct *mm, unsigned int fd)
   goto exit;
 
  err = 0;
- set_mm_exe_file(mm, exe.file); /* this grabs a reference to exe.file */
+ /* set the new file, lockless */
+ get_file(exe.file);
+ old_exe = xchg(&mm->exe_file, exe.file);
+ if (old_exe)
+  fput(old_exe);
 exit:
  fdput(exe);
  return err;
+exit_err:
+ up_read(&mm->mmap_sem);
+ fput(exe_file);
+ goto exit;
 }
 
 /*
@@ -2089,10 +2103,9 @@ static int prctl_set_mm_map(int opt, const void __user *addr, unsigned long data
   user_auxv[AT_VECTOR_SIZE - 1] = AT_NULL;
  }
 
- down_write(&mm->mmap_sem);
  if (prctl_map.exe_fd != (u32)-1)
-  error = prctl_set_mm_exe_file_locked(mm, prctl_map.exe_fd);
- downgrade_write(&mm->mmap_sem);
+  error = prctl_set_mm_exe_file(mm, prctl_map.exe_fd);
+ down_read(&mm->mmap_sem);
  if (error)
   goto out;
 
@@ -2189,12 +2202,8 @@ static int prctl_set_mm(int opt, unsigned long addr,
  if (!capable(CAP_SYS_RESOURCE))
   return -EPERM;
 
- if (opt == PR_SET_MM_EXE_FILE) {
-  down_write(&mm->mmap_sem);
-  error = prctl_set_mm_exe_file_locked(mm, (unsigned int)addr);
-  up_write(&mm->mmap_sem);
-  return error;
- }
+ if (opt == PR_SET_MM_EXE_FILE)
+  return prctl_set_mm_exe_file(mm, (unsigned int)addr);
 
  if (opt == PR_SET_MM_AUXV)
   return prctl_set_auxv(mm, addr, arg4);
-- 
1.7.1