From ae2f5b1c378cfa9b82d835851b12c1595273f532 Mon Sep 17 00:00:00 2001
From: Prarit Bhargava <prarit@redhat.com>
Date: Thu, 8 Sep 2016 15:07:25 -0400
Subject: [x86] tsc: Enumerate BXT tsc_khz via CPUID

Message-id: <1473347246-1962-2-git-send-email-prarit@redhat.com>
Patchwork-id: 157724
O-Subject: [RHEL7.3 PATCH BZ 1372759 1/2] x86/tsc: Enumerate BXT tsc_khz via CPUID
Bugzilla: 1372759
RH-Acked-by: Radim Krcmar <rkrcmar@redhat.com>
RH-Acked-by: Paolo Bonzini <pbonzini@redhat.com>
RH-Acked-by: Jiri Olsa <jolsa@redhat.com>

Bugzilla: http://bugzilla.redhat.com/1372759

commit ff4c86635ee12461fd3bd911d7d5253394da8f9d
Author: Len Brown <len.brown@intel.com>
Date:   Fri Jun 17 01:22:52 2016 -0400

    x86/tsc: Enumerate BXT tsc_khz via CPUID

    Hard code the BXT crystal clock (aka ART - Always Running Timer)
    to 19.200 MHz, and use CPUID leaf 0x15 to determine the BXT TSC frequency.

    Use tsc_khz to sanity check BXT cpu_khz,
    which can be erroneous in some configurations.

    (I simplified the original patch from Bin Gao.)

    Original-From: Bin Gao <bin.gao@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Link: http://lkml.kernel.org/r/bf4e7c175acd6d09719c47c319b10ff1f0627ff8.1466138954.git.len.brown@intel.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

Cc: Jiri Olsa <jolsa@redhat.com>
Signed-off-by: Rafael Aquini <aquini@redhat.com>

diff --git a/arch/x86/kernel/tsc.c b/arch/x86/kernel/tsc.c
index 2d38483..18346c1 100644
--- a/arch/x86/kernel/tsc.c
+++ b/arch/x86/kernel/tsc.c
@@ -707,7 +707,11 @@ unsigned long native_calibrate_tsc(void)
   switch (boot_cpu_data.x86_model) {
   case 0x4E: /* SKL */
   case 0x5E: /* SKL */
-   crystal_khz = 24000; /* 24 MHz */
+   crystal_khz = 24000; /* 24.0 MHz */
+   break;
+  case 0x5C: /* BXT */
+   crystal_khz = 19200; /* 19.2 MHz */
+   break;
   }
  }
 
@@ -910,6 +914,8 @@ int recalibrate_cpu_khz(void)
   tsc_khz = x86_platform.calibrate_tsc();
   if (tsc_khz == 0)
    tsc_khz = cpu_khz;
+  else if (abs(cpu_khz - tsc_khz) * 10 > tsc_khz)
+   cpu_khz = tsc_khz;
   cpu_data(0).loops_per_jiffy =
    cpufreq_scale(cpu_data(0).loops_per_jiffy,
      cpu_khz_old, cpu_khz);
@@ -1322,8 +1328,16 @@ void __init tsc_init(void)
 
  cpu_khz = x86_platform.calibrate_cpu();
  tsc_khz = x86_platform.calibrate_tsc();
+
+ /*
+  * Trust non-zero tsc_khz as authorative,
+  * and use it to sanity check cpu_khz,
+  * which will be off if system timer is off.
+  */
  if (tsc_khz == 0)
   tsc_khz = cpu_khz;
+ else if (abs(cpu_khz - tsc_khz) * 10 > tsc_khz)
+  cpu_khz = tsc_khz;
 
  if (!tsc_khz) {
   mark_tsc_unstable("could not calculate TSC khz");
-- 
1.7.1