From cce013af5c766e30f9832fb8046ca716f68de789 Mon Sep 17 00:00:00 2001
From: Xin Long <lxin@redhat.com>
Date: Wed, 14 Sep 2016 08:45:22 -0400
Subject: [net] sctp: hold the transport before using it in sctp_hash_cmp

Message-id: <db39b6d1b2764ace215b5606c29cac61a9d6d9cd.1473842722.git.lxin@redhat.com>
Patchwork-id: 157813
O-Subject: [RHEL7.3 net PATCH] sctp: hold the transport before using it in sctp_hash_cmp
Bugzilla: 1368884
RH-Acked-by: Marcelo Leitner <mleitner@redhat.com>
RH-Acked-by: Paolo Abeni <pabeni@redhat.com>
RH-Acked-by: Eric Garver <egarver@redhat.com>

Bugzilla: https://bugzilla.redhat.com/show_bug.cgi?id=1368884
Upstream Status: net.git commit 715f555

commit 715f5552b1e90ba3eecf6d1a6d044d0d5226663f
Author: Xin Long <lucien.xin@gmail.com>
Date:   Sat Sep 10 23:11:23 2016 +0800

    sctp: hold the transport before using it in sctp_hash_cmp

    Since commit 4f0087812648 ("sctp: apply rhashtable api to send/recv
    path"), sctp uses transport rhashtable with .obj_cmpfn sctp_hash_cmp,
    in which it compares the members of the transport with the rhashtable
    args to check if it's the right transport.

    But sctp uses the transport without holding it in sctp_hash_cmp, it can
    cause a use-after-free panic. As after it gets transport from hashtable,
    another CPU may close the sk and free the asoc. In sctp_association_free,
    it frees all the transports, meanwhile, the assoc's refcnt may be reduced
    to 0, assoc can be destroyed by sctp_association_destroy.

    So after that, transport->assoc is actually an unavailable memory address
    in sctp_hash_cmp. Although sctp_hash_cmp is under rcu_read_lock, it still
    can not avoid this, as assoc is not freed by RCU.

    This patch is to hold the transport before checking it's members with
    sctp_transport_hold, in which it checks the refcnt first, holds it if
    it's not 0.

    Fixes: 4f0087812648 ("sctp: apply rhashtable api to send/recv path")
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Acked-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

Signed-off-by: Jiri Benc <jbenc@redhat.com>
Signed-off-by: Rafael Aquini <aquini@redhat.com>

diff --git a/net/sctp/input.c b/net/sctp/input.c
index 203a8d1..7720f36 100644
--- a/net/sctp/input.c
+++ b/net/sctp/input.c
@@ -800,27 +800,34 @@ struct sctp_hash_cmp_arg {
 static inline int sctp_hash_cmp(struct rhashtable_compare_arg *arg,
     const void *ptr)
 {
+ struct sctp_transport *t = (struct sctp_transport *)ptr;
  const struct sctp_hash_cmp_arg *x = arg->key;
- const struct sctp_transport *t = ptr;
- struct sctp_association *asoc = t->asoc;
- const struct net *net = x->net;
+ struct sctp_association *asoc;
+ int err = 1;
 
  if (!sctp_cmp_addr_exact(&t->ipaddr, x->paddr))
-  return 1;
- if (!net_eq(sock_net(asoc->base.sk), net))
-  return 1;
+  return err;
+ if (!sctp_transport_hold(t))
+  return err;
+
+ asoc = t->asoc;
+ if (!net_eq(sock_net(asoc->base.sk), x->net))
+  goto out;
  if (x->ep) {
   if (x->ep != asoc->ep)
-   return 1;
+   goto out;
  } else {
   if (x->laddr->v4.sin_port != htons(asoc->base.bind_addr.port))
-   return 1;
+   goto out;
   if (!sctp_bind_addr_match(&asoc->base.bind_addr,
        x->laddr, sctp_sk(asoc->base.sk)))
-   return 1;
+   goto out;
  }
 
- return 0;
+ err = 0;
+out:
+ sctp_transport_put(t);
+ return err;
 }
 
 static inline u32 sctp_hash_obj(const void *data, u32 len, u32 seed)
-- 
1.7.1