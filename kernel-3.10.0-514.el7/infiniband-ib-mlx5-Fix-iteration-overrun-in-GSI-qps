From 3cd124b43715936a25b24667e0ea8b8611720dec Mon Sep 17 00:00:00 2001
From: Don Dutile <ddutile@redhat.com>
Date: Mon, 26 Sep 2016 03:55:49 -0400
Subject: [infiniband] ib/mlx5: Fix iteration overrun in GSI qps

Message-id: <1474862149-20431-1-git-send-email-ddutile@redhat.com>
Patchwork-id: 158361
O-Subject: [PATCH RHEL-7.3] IB/mlx5: Fix iteration overrun in GSI qps
Bugzilla: 1376941
RH-Acked-by: Jeremy McNicoll <jmcnicol@redhat.com>
RH-Acked-by: Jerry Snitselaar <jsnitsel@redhat.com>
RH-Acked-by: Doug Ledford <dledford@redhat.com>
RH-Acked-by: Jarod Wilson <jarod@redhat.com>

From: Slava Shwartsman <slavash@mellanox.com>

Bugzilla: https://bugzilla.redhat.com/show_bug.cgi?id=1376941
Brew build: https://brewweb.engineering.redhat.com/brew/taskinfo?taskID=11810178

Number of outstanding_pi may overflow and as a result may indicate that
there are no elements in the queue. The effect of doing this is that the
MAD layer will get stuck waiting for completions. The MAD layer will
think that the QP is full - because it didn't receive these completions.

This fix changes it so the outstanding_pi number is increased
with 32-bit wraparound and is not limited to max_send_wr so
that the difference between outstanding_pi and outstanding_ci will
really indicate the number of outstanding completions.

Cc: Stable <stable@vger.kernel.org>
Fixes: ea6dc2036224 ('IB/mlx5: Reorder GSI completions')
Signed-off-by: Slava Shwartsman <slavash@mellanox.com>
Signed-off-by: Leon Romanovsky <leon@kernel.org>
Reviewed-by: Haggai Eran <haggaie@mellanox.com>
Reviewed-by: Sagi Grimberg <sagi@grimberg.me>
Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit b0ffeb537f3a726931d962ab6d03e34a2f070ea4)

Testing:
(In bugzilla, synopis here):
Bug original found at customer site testing 7.3-beta.
Verified that 7.2 did not have this bug, thus a regression.
Verified that v4.6-2 has the bug, which is closest in sources to 7.3 RDMA core.
Verified that v4.7-2 worked.
Found this upstream patch in v4.7-2, as
  commit 3e132bf7877a410507f40de76783d762c65ec6f7
(the upstream fix went into v4.8-rc2).
Note: Doug Ledford provided key information that perfquery's
      are handled via GSI QP to device, which this patch title
      caught the author's eye, and the description matched
      the bugzilla listed symptoms.

Signed-off-by: Donald Dutile <ddutile@redhat.com>
Signed-off-by: Rafael Aquini <aquini@redhat.com>

diff --git a/drivers/infiniband/hw/mlx5/gsi.c b/drivers/infiniband/hw/mlx5/gsi.c
index 53e03c8..79e6309 100644
--- a/drivers/infiniband/hw/mlx5/gsi.c
+++ b/drivers/infiniband/hw/mlx5/gsi.c
@@ -69,15 +69,6 @@ static bool mlx5_ib_deth_sqpn_cap(struct mlx5_ib_dev *dev)
  return MLX5_CAP_GEN(dev->mdev, set_deth_sqpn);
 }
 
-static u32 next_outstanding(struct mlx5_ib_gsi_qp *gsi, u32 index)
-{
- return ++index % gsi->cap.max_send_wr;
-}
-
-#define for_each_outstanding_wr(gsi, index) \
- for (index = gsi->outstanding_ci; index != gsi->outstanding_pi; \
-      index = next_outstanding(gsi, index))
-
 /* Call with gsi->lock locked */
 static void generate_completions(struct mlx5_ib_gsi_qp *gsi)
 {
@@ -85,8 +76,9 @@ static void generate_completions(struct mlx5_ib_gsi_qp *gsi)
  struct mlx5_ib_gsi_wr *wr;
  u32 index;
 
- for_each_outstanding_wr(gsi, index) {
-  wr = &gsi->outstanding_wrs[index];
+ for (index = gsi->outstanding_ci; index != gsi->outstanding_pi;
+      index++) {
+  wr = &gsi->outstanding_wrs[index % gsi->cap.max_send_wr];
 
   if (!wr->completed)
    break;
@@ -430,8 +422,9 @@ static int mlx5_ib_add_outstanding_wr(struct mlx5_ib_gsi_qp *gsi,
   return -ENOMEM;
  }
 
- gsi_wr = &gsi->outstanding_wrs[gsi->outstanding_pi];
- gsi->outstanding_pi = next_outstanding(gsi, gsi->outstanding_pi);
+ gsi_wr = &gsi->outstanding_wrs[gsi->outstanding_pi %
+           gsi->cap.max_send_wr];
+ gsi->outstanding_pi++;
 
  if (!wc) {
   memset(&gsi_wr->wc, 0, sizeof(gsi_wr->wc));
-- 
1.7.1