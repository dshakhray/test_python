From da8c432fc50632a1086fcc67efc554daf6a01b3e Mon Sep 17 00:00:00 2001
From: Maurizio Lombardi <mlombard@redhat.com>
Date: Thu, 15 Sep 2016 12:01:13 -0400
Subject: [scsi] be2iscsi: revert: _bh for io_sgl_lock and mgmt_sgl_lock

Message-id: <1473940873-9876-1-git-send-email-mlombard@redhat.com>
Patchwork-id: 157835
O-Subject: [RHEL7.3 e-stor PATCH] Revert "[scsi] be2iscsi: _bh for io_sgl_lock and mgmt_sgl_lock"
Bugzilla: 1374223
RH-Acked-by: Ewan Milne <emilne@redhat.com>
RH-Acked-by: Tomas Henzl <thenzl@redhat.com>

Description: This patch exposed a locking problem in libiscsi that is
      still under investigation by the upstream developers
      (see https://patchwork.kernel.org/patch/9241195).
      This is a regression, we have to revert it because
      it triggers a kernel warning when a user does I/O
             on a remote LUN attached through be2iscsi HBA.

Testing: Tested by Broadcom and by Martin Hoyer <mhoyer@redhat.com>

This reverts commit b03046687af7594f89fd643c4c97538b0d54ae1d.

Signed-off-by: Rafael Aquini <aquini@redhat.com>

diff --git a/drivers/scsi/be2iscsi/be_main.c b/drivers/scsi/be2iscsi/be_main.c
index 26a2fb6..783bdfc 100644
--- a/drivers/scsi/be2iscsi/be_main.c
+++ b/drivers/scsi/be2iscsi/be_main.c
@@ -1140,7 +1140,6 @@ static struct sgl_handle *alloc_io_sgl_handle(struct beiscsi_hba *phba)
 {
  struct sgl_handle *psgl_handle;
 
- spin_lock_bh(&phba->io_sgl_lock);
  if (phba->io_sgl_hndl_avbl) {
   beiscsi_log(phba, KERN_INFO, BEISCSI_LOG_IO,
        "BM_%d : In alloc_io_sgl_handle,"
@@ -1158,14 +1157,12 @@ static struct sgl_handle *alloc_io_sgl_handle(struct beiscsi_hba *phba)
    phba->io_sgl_alloc_index++;
  } else
   psgl_handle = NULL;
- spin_unlock_bh(&phba->io_sgl_lock);
  return psgl_handle;
 }
 
 static void
 free_io_sgl_handle(struct beiscsi_hba *phba, struct sgl_handle *psgl_handle)
 {
- spin_lock_bh(&phba->io_sgl_lock);
  beiscsi_log(phba, KERN_INFO, BEISCSI_LOG_IO,
       "BM_%d : In free_,io_sgl_free_index=%d\n",
       phba->io_sgl_free_index);
@@ -1180,7 +1177,6 @@ free_io_sgl_handle(struct beiscsi_hba *phba, struct sgl_handle *psgl_handle)
         "value there=%p\n", phba->io_sgl_free_index,
         phba->io_sgl_hndl_base
         [phba->io_sgl_free_index]);
-   spin_unlock_bh(&phba->io_sgl_lock);
   return;
  }
  phba->io_sgl_hndl_base[phba->io_sgl_free_index] = psgl_handle;
@@ -1189,7 +1185,6 @@ free_io_sgl_handle(struct beiscsi_hba *phba, struct sgl_handle *psgl_handle)
   phba->io_sgl_free_index = 0;
  else
   phba->io_sgl_free_index++;
- spin_unlock_bh(&phba->io_sgl_lock);
 }
 
 static inline struct wrb_handle *
@@ -1270,7 +1265,6 @@ static struct sgl_handle *alloc_mgmt_sgl_handle(struct beiscsi_hba *phba)
 {
  struct sgl_handle *psgl_handle;
 
- spin_lock_bh(&phba->mgmt_sgl_lock);
  if (phba->eh_sgl_hndl_avbl) {
   psgl_handle = phba->eh_sgl_hndl_base[phba->eh_sgl_alloc_index];
   phba->eh_sgl_hndl_base[phba->eh_sgl_alloc_index] = NULL;
@@ -1288,14 +1282,13 @@ static struct sgl_handle *alloc_mgmt_sgl_handle(struct beiscsi_hba *phba)
    phba->eh_sgl_alloc_index++;
  } else
   psgl_handle = NULL;
- spin_unlock_bh(&phba->mgmt_sgl_lock);
  return psgl_handle;
 }
 
 void
 free_mgmt_sgl_handle(struct beiscsi_hba *phba, struct sgl_handle *psgl_handle)
 {
- spin_lock_bh(&phba->mgmt_sgl_lock);
+
  beiscsi_log(phba, KERN_INFO, BEISCSI_LOG_CONFIG,
       "BM_%d : In  free_mgmt_sgl_handle,"
       "eh_sgl_free_index=%d\n",
@@ -1310,7 +1303,6 @@ free_mgmt_sgl_handle(struct beiscsi_hba *phba, struct sgl_handle *psgl_handle)
        "BM_%d : Double Free in eh SGL ,"
        "eh_sgl_free_index=%d\n",
        phba->eh_sgl_free_index);
-  spin_unlock_bh(&phba->mgmt_sgl_lock);
   return;
  }
  phba->eh_sgl_hndl_base[phba->eh_sgl_free_index] = psgl_handle;
@@ -1320,7 +1312,6 @@ free_mgmt_sgl_handle(struct beiscsi_hba *phba, struct sgl_handle *psgl_handle)
   phba->eh_sgl_free_index = 0;
  else
   phba->eh_sgl_free_index++;
- spin_unlock_bh(&phba->mgmt_sgl_lock);
 }
 
 static void
@@ -4638,9 +4629,11 @@ beiscsi_free_mgmt_task_handles(struct beiscsi_conn *beiscsi_conn,
  }
 
  if (io_task->psgl_handle) {
+  spin_lock_bh(&phba->mgmt_sgl_lock);
   free_mgmt_sgl_handle(phba,
          io_task->psgl_handle);
   io_task->psgl_handle = NULL;
+  spin_unlock_bh(&phba->mgmt_sgl_lock);
  }
 
  if (io_task->mtask_addr) {
@@ -4686,7 +4679,9 @@ static void beiscsi_cleanup_task(struct iscsi_task *task)
   }
 
   if (io_task->psgl_handle) {
+   spin_lock(&phba->io_sgl_lock);
    free_io_sgl_handle(phba, io_task->psgl_handle);
+   spin_unlock(&phba->io_sgl_lock);
    io_task->psgl_handle = NULL;
   }
 
@@ -4802,7 +4797,9 @@ static int beiscsi_alloc_pdu(struct iscsi_task *task, uint8_t opcode)
  io_task->pwrb_handle = NULL;
 
  if (task->sc) {
+  spin_lock(&phba->io_sgl_lock);
   io_task->psgl_handle = alloc_io_sgl_handle(phba);
+  spin_unlock(&phba->io_sgl_lock);
   if (!io_task->psgl_handle) {
    beiscsi_log(phba, KERN_ERR,
         BEISCSI_LOG_IO | BEISCSI_LOG_CONFIG,
@@ -4827,8 +4824,10 @@ static int beiscsi_alloc_pdu(struct iscsi_task *task, uint8_t opcode)
   if ((opcode & ISCSI_OPCODE_MASK) == ISCSI_OP_LOGIN) {
    beiscsi_conn->task = task;
    if (!beiscsi_conn->login_in_progress) {
+    spin_lock(&phba->mgmt_sgl_lock);
     io_task->psgl_handle = (struct sgl_handle *)
       alloc_mgmt_sgl_handle(phba);
+    spin_unlock(&phba->mgmt_sgl_lock);
     if (!io_task->psgl_handle) {
      beiscsi_log(phba, KERN_ERR,
           BEISCSI_LOG_IO |
@@ -4867,7 +4866,9 @@ static int beiscsi_alloc_pdu(struct iscsi_task *task, uint8_t opcode)
       beiscsi_conn->plogin_wrb_handle;
    }
   } else {
+   spin_lock(&phba->mgmt_sgl_lock);
    io_task->psgl_handle = alloc_mgmt_sgl_handle(phba);
+   spin_unlock(&phba->mgmt_sgl_lock);
    if (!io_task->psgl_handle) {
     beiscsi_log(phba, KERN_ERR,
          BEISCSI_LOG_IO |
@@ -4902,11 +4903,15 @@ static int beiscsi_alloc_pdu(struct iscsi_task *task, uint8_t opcode)
  return 0;
 
 free_io_hndls:
+ spin_lock(&phba->io_sgl_lock);
  free_io_sgl_handle(phba, io_task->psgl_handle);
+ spin_unlock(&phba->io_sgl_lock);
  goto free_hndls;
 free_mgmt_hndls:
+ spin_lock(&phba->mgmt_sgl_lock);
  free_mgmt_sgl_handle(phba, io_task->psgl_handle);
  io_task->psgl_handle = NULL;
+ spin_unlock(&phba->mgmt_sgl_lock);
 free_hndls:
  phwi_ctrlr = phba->phwi_ctrlr;
  cri_index = BE_GET_CRI_FROM_CID(
-- 
1.7.1