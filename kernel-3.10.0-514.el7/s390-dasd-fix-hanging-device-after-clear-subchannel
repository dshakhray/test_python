From f5bd969173d63fdb7b8948ee88e54d9df44d9acf Mon Sep 17 00:00:00 2001
From: Gustavo Duarte <gduarte@redhat.com>
Date: Thu, 8 Sep 2016 20:04:27 -0400
Subject: [s390] dasd: fix hanging device after clear subchannel

Message-id: <1473365067-487-1-git-send-email-gduarte@redhat.com>
Patchwork-id: 157731
O-Subject: [RHEL7.3 PATCH BZ 1368068] s390/dasd: fix hanging device after clear subchannel
Bugzilla: 1368068
RH-Acked-by: Don Zickus <dzickus@redhat.com>
RH-Acked-by: Hendrik Brueckner <brueckner@redhat.com>
RH-Acked-by: Jarod Wilson <jarod@redhat.com>

BZ 1368068
Upstream Status: 9ba333dc55cbb9523553df973adb3024d223e905
Build Info: https://brewweb.engineering.redhat.com/brew/taskinfo?taskID=11720443
Tested: I boot tested on s390x. I also sent a test kernel to IBM for testing.

commit 9ba333dc55cbb9523553df973adb3024d223e905
Author: Stefan Haberland <sth@linux.vnet.ibm.com>
Date:   Mon Aug 8 14:08:17 2016 +0200

    s390/dasd: fix hanging device after clear subchannel

    When a device is in a status where CIO has killed all I/O by itself the
    interrupt for a clear request may not contain an irb to determine the
    clear function. Instead it contains an error pointer -EIO.
    This was ignored by the DASD int_handler leading to a hanging device
    waiting for a clear interrupt.

    Handle -EIO error pointer correctly for requests that are clear pending and
    treat the clear as successful.

    Signed-off-by: Stefan Haberland <sth@linux.vnet.ibm.com>
    Reviewed-by: Sebastian Ott <sebott@linux.vnet.ibm.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

Signed-off-by: Rafael Aquini <aquini@redhat.com>

diff --git a/drivers/s390/block/dasd.c b/drivers/s390/block/dasd.c
index 95236ac..5f422bc 100644
--- a/drivers/s390/block/dasd.c
+++ b/drivers/s390/block/dasd.c
@@ -1619,9 +1619,18 @@ void dasd_int_handler(struct ccw_device *cdev, unsigned long intparm,
  unsigned long long now;
  int expires;
 
+ cqr = (struct dasd_ccw_req *) intparm;
  if (IS_ERR(irb)) {
   switch (PTR_ERR(irb)) {
   case -EIO:
+   if (cqr && cqr->status == DASD_CQR_CLEAR_PENDING) {
+    device = (struct dasd_device *) cqr->startdev;
+    cqr->status = DASD_CQR_CLEARED;
+    dasd_device_clear_timer(device);
+    wake_up(&dasd_flush_wq);
+    dasd_schedule_device_bh(device);
+    return;
+   }
    break;
   case -ETIMEDOUT:
    DBF_EVENT_DEVID(DBF_WARNING, cdev, "%s: "
@@ -1637,7 +1646,6 @@ void dasd_int_handler(struct ccw_device *cdev, unsigned long intparm,
  }
 
  now = get_tod_clock();
- cqr = (struct dasd_ccw_req *) intparm;
  /* check for conditions that should be handled immediately */
  if (!cqr ||
      !(scsw_dstat(&irb->scsw) == (DEV_STAT_CHN_END | DEV_STAT_DEV_END) &&
-- 
1.7.1