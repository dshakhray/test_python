From f5ba8e1339ba579139392be69a091e3223f66070 Mon Sep 17 00:00:00 2001
From: Eric Sandeen <sandeen@redhat.com>
Date: Thu, 22 Sep 2016 14:47:07 -0400
Subject: [fs] ext4: pre-zero allocated blocks for DAX IO

Message-id: <5e316a7b-7ae9-b909-6a58-46094f336318@redhat.com>
Patchwork-id: 158064
O-Subject: [RHEL7.3 PATCH V3] [fs] ext4: pre-zero allocated blocks for DAX IO
Bugzilla: 1367989
RH-Acked-by: Jeff Moyer <jmoyer@redhat.com>
RH-Acked-by: Lukas Czerner <lczerner@redhat.com>

Bugzilla: 1367989
Testing: Local (xfstests generic/344, generic/346)
Build: Local

Backport of this upstream commit, with some modifications because
upstream has significantly refactored direct IO codepaths.  I didn't
want to introduced all that churn.

This essentially just replaces the get_block function which gets
used for dax_io, to one which will pre-zero blocks vs. creating
unwritten extents.  The get_block function it uses is renamed
from ext4_dax_mmap_get_block to ext4_dax_get_block due to
the new usecase.  This is done for both extent-based and indirect-block
based files (thanks Jeff!)

    commit 12735f881952c32b31bc4e433768f18489f79ec9
    Author: Jan Kara <jack@suse.cz>
    Date:   Fri May 13 00:51:15 2016 -0400

    ext4: pre-zero allocated blocks for DAX IO

    Currently ext4 treats DAX IO the same way as direct IO. I.e., it
    allocates unwritten extents before IO is done and converts unwritten
    extents afterwards. However this way DAX IO can race with page fault to
    the same area:

    ext4_ext_direct_IO()                                dax_fault()
      dax_io()
        get_block() - allocates unwritten extent
        copy_from_iter_pmem()
                                                  get_block() - converts
                                                    unwritten block to
                                                    written and zeroes it
                                                    out
      ext4_convert_unwritten_extents()

    So data written with DAX IO gets lost. Similarly dax_new_buf() called
    from dax_io() can overwrite data that has been already written to the
    block via mmap.

    Fix the problem by using pre-zeroed blocks for DAX IO the same way as we
    use them for DAX mmap. The downside of this solution is that every
    allocating write writes each block twice (once zeros, once data). Fixing
    the race with locking is possible as well however we would need to
    lock-out faults for the whole range written to by DAX IO. And that is
    not easy to do without locking-out faults for the whole file which seems
    too aggressive.

    Signed-off-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Theodore Ts'o <tytso@mit.edu>

Signed-off-by: Eric Sandeen <sandeen@redhat.com>
Signed-off-by: Rafael Aquini <aquini@redhat.com>

diff --git a/fs/ext4/ext4.h b/fs/ext4/ext4.h
index ab96289..d00d779 100644
--- a/fs/ext4/ext4.h
+++ b/fs/ext4/ext4.h
@@ -2096,8 +2096,8 @@ struct buffer_head *ext4_bread(handle_t *, struct inode *,
       ext4_lblk_t, int, int *);
 int ext4_get_block_write(struct inode *inode, sector_t iblock,
     struct buffer_head *bh_result, int create);
-int ext4_dax_mmap_get_block(struct inode *inode, sector_t iblock,
-       struct buffer_head *bh_result, int create);
+int ext4_dax_get_block(struct inode *inode, sector_t iblock,
+         struct buffer_head *bh_result, int create);
 int ext4_get_block(struct inode *inode, sector_t iblock,
     struct buffer_head *bh_result, int create);
 int ext4_da_get_block_prep(struct inode *inode, sector_t iblock,
@@ -2847,6 +2847,13 @@ extern struct mutex ext4__aio_mutex[EXT4_WQ_HASH_SZ];
 extern int ext4_resize_begin(struct super_block *sb);
 extern void ext4_resize_end(struct super_block *sb);
 
+static inline bool ext4_aligned_io(struct inode *inode, loff_t off, loff_t len)
+{
+ int blksize = 1 << inode->i_blkbits;
+
+ return IS_ALIGNED(off, blksize) && IS_ALIGNED(len, blksize);
+}
+
 #endif /* __KERNEL__ */
 
 #endif /* _EXT4_H */
diff --git a/fs/ext4/file.c b/fs/ext4/file.c
index de8914c..3fe5332 100644
--- a/fs/ext4/file.c
+++ b/fs/ext4/file.c
@@ -222,7 +222,7 @@ static int ext4_dax_fault(struct vm_area_struct *vma, struct vm_fault *vmf)
  if (IS_ERR(handle))
   result = VM_FAULT_SIGBUS;
  else
-  result = __dax_fault(vma, vmf, ext4_dax_mmap_get_block, NULL);
+  result = __dax_fault(vma, vmf, ext4_dax_get_block, NULL);
 
  if (write) {
   if (!IS_ERR(handle))
@@ -258,7 +258,7 @@ static int ext4_dax_pmd_fault(struct vm_area_struct *vma, unsigned long addr,
   result = VM_FAULT_SIGBUS;
  else
   result = __dax_pmd_fault(vma, addr, pmd, flags,
-    ext4_dax_mmap_get_block, NULL);
+    ext4_dax_get_block, NULL);
 
  if (write) {
   if (!IS_ERR(handle))
diff --git a/fs/ext4/indirect.c b/fs/ext4/indirect.c
index a2104bc..3f4c59d 100644
--- a/fs/ext4/indirect.c
+++ b/fs/ext4/indirect.c
@@ -704,10 +704,26 @@ retry:
   inode_dio_end(inode);
  } else {
 locked:
-  if (IS_DAX(inode))
+  if (IS_DAX(inode)) {
+   get_block_t *get_block_func = NULL;
+
+   /*
+    * We can avoid zeroing for aligned DAX writes beyond
+    * EOF. Other writes need zeroing either because they
+    * can race with page faults or because they use partial
+    * blocks.
+    */
+   if (rw == READ)
+    get_block_func = ext4_get_block;
+   else if (round_down(offset, 1<<inode->i_blkbits) >=
+        inode->i_size &&
+       ext4_aligned_io(inode, offset, count))
+    get_block_func = ext4_get_block_write;
+   else
+    get_block_func = ext4_dax_get_block;
    ret = dax_do_io(rw, iocb, inode, iov, offset, nr_segs,
-     ext4_get_block, NULL, DIO_LOCKING);
-  else
+     get_block_func, NULL, DIO_LOCKING);
+  } else
    ret = blockdev_direct_IO(rw, iocb, inode, iov,
      offset, nr_segs, ext4_get_block);
 
diff --git a/fs/ext4/inode.c b/fs/ext4/inode.c
index b14916c..58d4bac 100644
--- a/fs/ext4/inode.c
+++ b/fs/ext4/inode.c
@@ -2975,8 +2975,13 @@ static int ext4_get_block_overwrite(struct inode *inode, sector_t iblock,
 }
 
 #ifdef CONFIG_FS_DAX
-int ext4_dax_mmap_get_block(struct inode *inode, sector_t iblock,
-       struct buffer_head *bh_result, int create)
+/*
+ * Get block function for DAX IO and mmap faults. It takes care of converting
+ * unwritten extents to written ones and initializes new / converted blocks
+ * to zeros.
+ */
+int ext4_dax_get_block(struct inode *inode, sector_t iblock,
+         struct buffer_head *bh_result, int create)
 {
  int ret, err;
  int credits;
@@ -2984,8 +2989,7 @@ int ext4_dax_mmap_get_block(struct inode *inode, sector_t iblock,
  handle_t *handle = NULL;
  int flags = 0;
 
- ext4_debug("ext4_dax_mmap_get_block: inode %lu, create flag %d\n",
-     inode->i_ino, create);
+ ext4_debug("inode %lu, create flag %d\n", inode->i_ino, create);
  map.m_lblk = iblock;
  map.m_len = bh_result->b_size >> inode->i_blkbits;
  credits = ext4_chunk_trans_blocks(inode, map.m_len);
@@ -3010,9 +3014,9 @@ int ext4_dax_mmap_get_block(struct inode *inode, sector_t iblock,
   int err2;
 
   /*
-   * We are protected by i_mmap_sem so we know block cannot go
-   * away from under us even though we dropped i_data_sem.
-   * Convert extent to written and write zeros there.
+   * We are protected by i_mmap_sem or i_mutex so we know block
+   * cannot go away from under us even though we dropped
+   * i_data_sem. Convert extent to written and write zeros there.
    *
    * Note: We may get here even when create == 0.
    */
@@ -3046,6 +3050,14 @@ out:
  }
  return ret;
 }
+#else
+/* Just define empty function, it will never get called. */
+int ext4_dax_get_block(struct inode *inode, sector_t iblock,
+         struct buffer_head *bh_result, int create)
+{
+ BUG();
+ return 0;
+}
 #endif
 
 static void ext4_end_io_dio(struct kiocb *iocb, loff_t offset,
@@ -3165,13 +3177,25 @@ static ssize_t ext4_ext_direct_IO(int rw, struct kiocb *iocb,
 
  if (overwrite) {
   get_block_func = ext4_get_block_overwrite;
+ } else if (IS_DAX(inode)) {
+  /*
+   * We can avoid zeroing for aligned DAX writes beyond EOF. Other
+   * writes need zeroing either because they can race with page
+   * faults or because they use partial blocks.
+   */
+  if (round_down(offset, 1<<inode->i_blkbits) >= inode->i_size &&
+      ext4_aligned_io(inode, offset, count))
+   get_block_func = ext4_get_block_write;
+  else
+   get_block_func = ext4_dax_get_block;
+  dio_flags = DIO_LOCKING;
  } else {
   get_block_func = ext4_get_block_write;
   dio_flags = DIO_LOCKING;
  }
  if (IS_DAX(inode))
   ret = dax_do_io(rw, iocb, inode, iov, offset, nr_segs,
-    ext4_get_block, ext4_end_io_dio, dio_flags);
+    get_block_func, ext4_end_io_dio, dio_flags);
  else
   ret = __blockdev_direct_IO(rw, iocb, inode,
         inode->i_sb->s_bdev, iov, offset,
-- 
1.7.1