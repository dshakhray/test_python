From 35c0abc0c70cfb3b37505ec137beae7fabca6b79 Mon Sep 17 00:00:00 2001
From: Brian Foster <bfoster@redhat.com>
Date: Thu, 25 Aug 2016 12:50:10 -0400
Subject: [fs] xfs: rework buffer dispose list tracking

Message-id: <1472129410-4267-1-git-send-email-bfoster@redhat.com>
Patchwork-id: 157287
O-Subject: [RHEL7 PATCH] xfs: rework buffer dispose list tracking
Bugzilla: 1349175
RH-Acked-by: Dave Chinner <dchinner@redhat.com>
RH-Acked-by: Eric Sandeen <sandeen@redhat.com>

- Retain the buffer lru helpers as rhel7 does not include built-in
  list_lru infrastructure.
- Some b_lock bits dropped as they were introduced by a previous
  selective backport.
- Backport use of dispose list from upstream list_lru-based
  xfs_wait_buftarg[_rele]() to downstream variant.

commit a408235726aa82c0358c9ec68124b6f4bc0a79df
Author: Dave Chinner <dchinner@redhat.com>
Date:   Wed Aug 28 10:18:06 2013 +1000

    xfs: rework buffer dispose list tracking

    In converting the buffer lru lists to use the generic code, the locking
    for marking the buffers as on the dispose list was lost.  This results in
    confusion in LRU buffer tracking and acocunting, resulting in reference
    counts being mucked up and filesystem beig unmountable.

    To fix this, introduce an internal buffer spinlock to protect the state
    field that holds the dispose list information.  Because there is now
    locking needed around xfs_buf_lru_add/del, and they are used in exactly
    one place each two lines apart, get rid of the wrappers and code the logic
    directly in place.

    Further, the LRU emptying code used on unmount is less than optimal.
    Convert it to use a dispose list as per a normal shrinker walk, and repeat
    the walk that fills the dispose list until the LRU is empty.  Thi avoids
    needing to drop and regain the LRU lock for every item being freed, and
    allows the same logic as the shrinker isolate call to be used.  Simpler,
    easier to understand.

    Signed-off-by: Dave Chinner <dchinner@redhat.com>
    Signed-off-by: Glauber Costa <glommer@openvz.org>
    Cc: "Theodore Ts'o" <tytso@mit.edu>
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Cc: Arve Hjonnevag <arve@android.com>
    Cc: Carlos Maiolino <cmaiolino@redhat.com>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: Chuck Lever <chuck.lever@oracle.com>
    Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
    Cc: David Rientjes <rientjes@google.com>
    Cc: Gleb Natapov <gleb@redhat.com>
    Cc: Greg Thelen <gthelen@google.com>
    Cc: J. Bruce Fields <bfields@redhat.com>
    Cc: Jan Kara <jack@suse.cz>
    Cc: Jerome Glisse <jglisse@redhat.com>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: KAMEZAWA Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com>
    Cc: Kent Overstreet <koverstreet@google.com>
    Cc: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
    Cc: Marcelo Tosatti <mtosatti@redhat.com>
    Cc: Mel Gorman <mgorman@suse.de>
    Cc: Steven Whitehouse <swhiteho@redhat.com>
    Cc: Thomas Hellstrom <thellstrom@vmware.com>
    Cc: Trond Myklebust <Trond.Myklebust@netapp.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

Signed-off-by: Brian Foster <bfoster@redhat.com>
---

Bugzilla: https://bugzilla.redhat.com/show_bug.cgi?id=1349175
Upstream Status: Merged
Build Info: https://brewweb.engineering.redhat.com/brew/taskinfo?taskID=11654898
Tested: via xfstests and custom fsstress/freeze reproducer.
Conflicts: noted in commit log description.

Signed-off-by: Rafael Aquini <aquini@redhat.com>

diff --git a/fs/xfs/xfs_buf.c b/fs/xfs/xfs_buf.c
index 593a5e2..52df2bc 100644
--- a/fs/xfs/xfs_buf.c
+++ b/fs/xfs/xfs_buf.c
@@ -96,7 +96,7 @@ xfs_buf_lru_add(
   atomic_inc(&bp->b_hold);
   list_add_tail(&bp->b_lru, &btp->bt_lru);
   btp->bt_lru_nr++;
-  bp->b_lru_flags &= ~_XBF_LRU_DISPOSE;
+  bp->b_state &= ~XFS_BSTATE_DISPOSE;
  }
  spin_unlock(&btp->bt_lru_lock);
 }
@@ -198,19 +198,21 @@ xfs_buf_stale(
   */
  xfs_buf_ioacct_dec(bp);
 
- atomic_set(&(bp)->b_lru_ref, 0);
+ spin_lock(&bp->b_lock);
+ atomic_set(&bp->b_lru_ref, 0);
  if (!list_empty(&bp->b_lru)) {
   struct xfs_buftarg *btp = bp->b_target;
 
   spin_lock(&btp->bt_lru_lock);
   if (!list_empty(&bp->b_lru) &&
-      !(bp->b_lru_flags & _XBF_LRU_DISPOSE)) {
+      !(bp->b_state & XFS_BSTATE_DISPOSE)) {
    list_del_init(&bp->b_lru);
    btp->bt_lru_nr--;
    atomic_dec(&bp->b_hold);
   }
   spin_unlock(&btp->bt_lru_lock);
  }
+ spin_unlock(&bp->b_lock);
  ASSERT(atomic_read(&bp->b_hold) >= 1);
 }
 
@@ -1012,10 +1014,26 @@ xfs_buf_rele(
  /* the last reference has been dropped ... */
  xfs_buf_ioacct_dec(bp);
  if (!(bp->b_flags & XBF_STALE) && atomic_read(&bp->b_lru_ref)) {
+  /*
+   * If the buffer is added to the LRU take a new
+   * reference to the buffer for the LRU and clear the
+   * (now stale) dispose list state flag
+   */
   xfs_buf_lru_add(bp);
   spin_unlock(&pag->pag_buf_lock);
  } else {
-  xfs_buf_lru_del(bp);
+  /*
+   * most of the time buffers will already be removed from
+   * the LRU, so optimise that case by checking for the
+   * XFS_BSTATE_DISPOSE flag indicating the last list the
+   * buffer was on was the disposal list
+   */
+  if (!(bp->b_state & XFS_BSTATE_DISPOSE)) {
+   xfs_buf_lru_del(bp);
+  } else {
+   ASSERT(list_empty(&bp->b_lru));
+  }
+
   ASSERT(!(bp->b_flags & _XBF_DELWRI_Q));
   rb_erase(&bp->b_rbnode, &pag->pag_buf_tree);
   spin_unlock(&pag->pag_buf_lock);
@@ -1602,6 +1620,7 @@ xfs_wait_buftarg(
  struct xfs_buftarg *btp)
 {
  struct xfs_buf  *bp;
+ LIST_HEAD(dispose);
 
  /*
   * First wait on the buftarg I/O count for all in-flight buffers to be
@@ -1624,18 +1643,22 @@ restart:
  while (!list_empty(&btp->bt_lru)) {
   bp = list_first_entry(&btp->bt_lru, struct xfs_buf, b_lru);
   if (atomic_read(&bp->b_hold) > 1) {
+   /* need to wait, so skip it this pass */
    trace_xfs_buf_wait_buftarg(bp, _RET_IP_);
+skip:
    list_move_tail(&bp->b_lru, &btp->bt_lru);
    spin_unlock(&btp->bt_lru_lock);
    delay(100);
    goto restart;
   }
+  if (!spin_trylock(&bp->b_lock))
+   goto skip;
+
   /*
    * clear the LRU reference count so the buffer doesn't get
    * ignored in xfs_buf_rele().
    */
   atomic_set(&bp->b_lru_ref, 0);
-  spin_unlock(&btp->bt_lru_lock);
   if (bp->b_flags & XBF_WRITE_FAIL) {
    xfs_alert(btp->bt_mount,
 "Corruption Alert: Buffer at block 0x%llx had permanent write failures!",
@@ -1643,10 +1666,17 @@ restart:
    xfs_alert(btp->bt_mount,
 "Please run xfs_repair to determine the extent of the problem.");
   }
-  xfs_buf_rele(bp);
-  spin_lock(&btp->bt_lru_lock);
+  bp->b_state |= XFS_BSTATE_DISPOSE;
+  list_move_tail(&bp->b_lru, &dispose);
+  spin_unlock(&bp->b_lock);
  }
  spin_unlock(&btp->bt_lru_lock);
+
+ while (!list_empty(&dispose)) {
+  bp = list_first_entry(&dispose, struct xfs_buf, b_lru);
+  list_del_init(&bp->b_lru);
+  xfs_buf_rele(bp);
+ }
 }
 
 int
@@ -1671,11 +1701,21 @@ xfs_buftarg_shrink(
   bp = list_first_entry(&btp->bt_lru, struct xfs_buf, b_lru);
 
   /*
+   * we are inverting the lru lock/bp->b_lock here, so use a trylock.
+   * If we fail to get the lock, just skip it.
+   */
+  if (!spin_trylock(&bp->b_lock)) {
+   list_move_tail(&bp->b_lru, &btp->bt_lru);
+   continue;
+  }
+
+  /*
    * Decrement the b_lru_ref count unless the value is already
    * zero. If the value is already zero, we need to reclaim the
    * buffer, otherwise it gets another trip through the LRU.
    */
   if (!atomic_add_unless(&bp->b_lru_ref, -1, 0)) {
+   spin_unlock(&bp->b_lock);
    list_move_tail(&bp->b_lru, &btp->bt_lru);
    continue;
   }
@@ -1686,7 +1726,8 @@ xfs_buftarg_shrink(
    */
   list_move(&bp->b_lru, &dispose);
   btp->bt_lru_nr--;
-  bp->b_lru_flags |= _XBF_LRU_DISPOSE;
+  bp->b_state |= XFS_BSTATE_DISPOSE;
+  spin_unlock(&bp->b_lock);
  }
  spin_unlock(&btp->bt_lru_lock);
 
diff --git a/fs/xfs/xfs_buf.h b/fs/xfs/xfs_buf.h
index 180bf33..648b20e 100644
--- a/fs/xfs/xfs_buf.h
+++ b/fs/xfs/xfs_buf.h
@@ -62,7 +62,6 @@ typedef enum {
 #define _XBF_KMEM  (1 << 21)/* backed by heap memory */
 #define _XBF_DELWRI_Q  (1 << 22)/* buffer on a delwri queue */
 #define _XBF_COMPOUND  (1 << 23)/* compound buffer */
-#define _XBF_LRU_DISPOSE (1 << 24)/* buffer being discarded */
 #define _XBF_IN_FLIGHT  (1 << 26) /* I/O in flight, for accounting purposes */
 
 typedef unsigned int xfs_buf_flags_t;
@@ -84,9 +83,12 @@ typedef unsigned int xfs_buf_flags_t;
  { _XBF_KMEM,  "KMEM" }, \
  { _XBF_DELWRI_Q, "DELWRI_Q" }, \
  { _XBF_COMPOUND, "COMPOUND" }, \
- { _XBF_LRU_DISPOSE, "LRU_DISPOSE" }, \
  { _XBF_IN_FLIGHT, "IN_FLIGHT" }
 
+/*
+ * Internal state flags.
+ */
+#define XFS_BSTATE_DISPOSE (1 << 0) /* buffer being discarded */
 
 /*
  * The xfs_buftarg contains 2 notions of "sector size" -
@@ -161,8 +163,8 @@ typedef struct xfs_buf {
   * bt_lru_lock and not by b_sema
   */
  struct list_head b_lru;  /* lru list */
- xfs_buf_flags_t  b_lru_flags; /* internal lru status flags */
  spinlock_t  b_lock;  /* internal state lock */
+ unsigned int  b_state; /* internal state flags */
  int   b_io_error; /* internal IO error state */
  wait_queue_head_t b_waiters; /* unpin waiters */
  struct list_head b_list;
-- 
1.7.1