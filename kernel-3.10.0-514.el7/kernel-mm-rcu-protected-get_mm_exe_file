From 1ab4ae04233ec53c0de3b21f878bdd0e08923fa8 Mon Sep 17 00:00:00 2001
From: Richard Guy Briggs <rgb@redhat.com>
Date: Sat, 17 Sep 2016 23:42:16 -0400
Subject: [kernel] mm: rcu-protected get_mm_exe_file()

Message-id: <a8a25defc55321a5b197f91af2e1f78bd2140fcd.1473974354.git.rgb@redhat.com>
Patchwork-id: 157921
O-Subject: [RHEL7 PATCH V2 1/4] mm: rcu-protected get_mm_exe_file()
Bugzilla: 1374478
RH-Acked-by: Herton R. Krzesinski <herton@redhat.com>
RH-Acked-by: Eric W. Biederman <ebiederm@redhat.com>
RH-Acked-by: Larry Woodman <lwoodman@redhat.com>
RH-Acked-by: Rafael Aquini <aquini@redhat.com>
RH-Acked-by: Paul Moore <pmoore@redhat.com>

From: Konstantin Khlebnikov <khlebnikov@yandex-team.ru>

This patch removes mm->mmap_sem from mm->exe_file read side.
Also it kills dup_mm_exe_file() and moves exe_file duplication into
dup_mmap() where both mmap_sems are locked.

[akpm@linux-foundation.org: fix comment typo]
Signed-off-by: Konstantin Khlebnikov <khlebnikov@yandex-team.ru>
Cc: Davidlohr Bueso <dbueso@suse.de>
Cc: Al Viro <viro@zeniv.linux.org.uk>
Cc: Oleg Nesterov <oleg@redhat.com>
Cc: "Paul E. McKenney" <paulmck@us.ibm.com>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry-picked from 90f31d0ea88880f780574f3d0bb1a227c4c66ca3)
(resolve conflict w/1deb46e25625 fget/fget_raw refactorization)
(resolve conflict w/98d1e64f95b1 free_area_cache removal)
(resolve conflict w/615d6e8756c8 vma caching)
(resolve conflict w/41f727fde1fe mm initialization cleanup)
(resolve conflict w/4f7d461433bb vm usage counters)

Signed-off-by: Richard Guy Briggs <rgb@redhat.com>
Signed-off-by: Rafael Aquini <aquini@redhat.com>

diff --git a/fs/file.c b/fs/file.c
index e53db23..c900218 100644
--- a/fs/file.c
+++ b/fs/file.c
@@ -651,8 +651,7 @@ struct file *fget(unsigned int fd)
  file = fcheck_files(files, fd);
  if (file) {
   /* File object ref couldn't be taken */
-  if (file->f_mode & FMODE_PATH ||
-      !atomic_long_inc_not_zero(&file->f_count))
+  if (file->f_mode & FMODE_PATH || !get_file_rcu(file))
    file = NULL;
  }
  rcu_read_unlock();
diff --git a/include/linux/fs.h b/include/linux/fs.h
index acb7875..39915f9 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -901,6 +901,7 @@ static inline struct file *get_file(struct file *f)
  atomic_long_inc(&f->f_count);
  return f;
 }
+#define get_file_rcu(x) atomic_long_inc_not_zero(&(x)->f_count)
 #define fput_atomic(x) atomic_long_add_unless(&(x)->f_count, -1, 1)
 #define file_count(x) atomic_long_read(&(x)->f_count)
 
diff --git a/include/linux/mm_types.h b/include/linux/mm_types.h
index f4abe25..068f002 100644
--- a/include/linux/mm_types.h
+++ b/include/linux/mm_types.h
@@ -477,7 +477,7 @@ struct mm_struct {
 #endif
 
  /* store ref to file /proc/<pid>/exe symlink points to */
- struct file *exe_file;
+ struct file __rcu *exe_file;
 #ifdef CONFIG_MMU_NOTIFIER
  struct mmu_notifier_mm *mmu_notifier_mm;
 #endif
diff --git a/kernel/fork.c b/kernel/fork.c
index 1594338..1068dd8 100644
--- a/kernel/fork.c
+++ b/kernel/fork.c
@@ -391,6 +391,9 @@ static int dup_mmap(struct mm_struct *mm, struct mm_struct *oldmm)
   */
  down_write_nested(&mm->mmap_sem, SINGLE_DEPTH_NESTING);
 
+ /* No ordering required: file already has been exposed. */
+ RCU_INIT_POINTER(mm->exe_file, get_mm_exe_file(oldmm));
+
  mm->locked_vm = 0;
  mm->mmap = NULL;
  mm->mmap_cache = NULL;
@@ -526,7 +529,13 @@ static inline void mm_free_pgd(struct mm_struct *mm)
  pgd_free(mm, mm->pgd);
 }
 #else
-#define dup_mmap(mm, oldmm) (0)
+static int dup_mmap(struct mm_struct *mm, struct mm_struct *oldmm)
+{
+ down_write(&oldmm->mmap_sem);
+ RCU_INIT_POINTER(mm->exe_file, get_mm_exe_file(oldmm));
+ up_write(&oldmm->mmap_sem);
+ return 0;
+}
 #define mm_alloc_pgd(mm) (0)
 #define mm_free_pgd(mm)
 #endif /* CONFIG_MMU */
@@ -667,35 +676,46 @@ void mmput(struct mm_struct *mm)
 }
 EXPORT_SYMBOL_GPL(mmput);
 
+/**
+ * set_mm_exe_file - change a reference to the mm's executable file
+ *
+ * This changes mm's executable file (shown as symlink /proc/[pid]/exe).
+ *
+ * Main users are mmput(), sys_execve() and sys_prctl(PR_SET_MM_MAP/EXE_FILE).
+ * Callers prevent concurrent invocations: in mmput() nobody alive left,
+ * in execve task is single-threaded, prctl holds mmap_sem exclusively.
+ */
 void set_mm_exe_file(struct mm_struct *mm, struct file *new_exe_file)
 {
+ struct file *old_exe_file = rcu_dereference_protected(mm->exe_file,
+   !atomic_read(&mm->mm_users) || current->in_execve ||
+   lockdep_is_held(&mm->mmap_sem));
+
  if (new_exe_file)
   get_file(new_exe_file);
- if (mm->exe_file)
-  fput(mm->exe_file);
- mm->exe_file = new_exe_file;
+ rcu_assign_pointer(mm->exe_file, new_exe_file);
+ if (old_exe_file)
+  fput(old_exe_file);
 }
 
+/**
+ * get_mm_exe_file - acquire a reference to the mm's executable file
+ *
+ * Returns %NULL if mm has no associated executable file.
+ * User must release file via fput().
+ */
 struct file *get_mm_exe_file(struct mm_struct *mm)
 {
  struct file *exe_file;
 
- /* We need mmap_sem to protect against races with removal of exe_file */
- down_read(&mm->mmap_sem);
- exe_file = mm->exe_file;
- if (exe_file)
-  get_file(exe_file);
- up_read(&mm->mmap_sem);
+ rcu_read_lock();
+ exe_file = rcu_dereference(mm->exe_file);
+ if (exe_file && !get_file_rcu(exe_file))
+  exe_file = NULL;
+ rcu_read_unlock();
  return exe_file;
 }
 
-static void dup_mm_exe_file(struct mm_struct *oldmm, struct mm_struct *newmm)
-{
- /* It's safe to write the exe_file pointer without exe_file_lock because
-  * this is called during fork when the task is not yet in /proc */
- newmm->exe_file = get_mm_exe_file(oldmm);
-}
-
 /**
  * get_task_mm - acquire a reference to the task's mm
  *
@@ -867,8 +887,6 @@ struct mm_struct *dup_mm(struct task_struct *tsk)
  if (init_new_context(tsk, mm))
   goto fail_nocontext;
 
- dup_mm_exe_file(oldmm, mm);
-
  err = dup_mmap(mm, oldmm);
  if (err)
   goto free_pt;
-- 
1.7.1