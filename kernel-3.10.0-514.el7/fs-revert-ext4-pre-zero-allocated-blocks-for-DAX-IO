From 57a29db11e2564d3eeb8a19137333a74564216fe Mon Sep 17 00:00:00 2001
From: Eric Sandeen <sandeen@redhat.com>
Date: Fri, 30 Sep 2016 15:16:22 -0400
Subject: [fs] revert "ext4: pre-zero allocated blocks for DAX IO"

Message-id: <4c613c3d-e185-3c6c-f775-d0370ff40c02@redhat.com>
Patchwork-id: 158470
O-Subject: [RHEL7.3 PATCH] [fs] revert ext4: pre-zero allocated blocks for DAX IO
Bugzilla: 1380571
RH-Acked-by: Rafael Aquini <aquini@redhat.com>
RH-Acked-by: Jeremy McNicoll <jmcnicol@redhat.com>
RH-Acked-by: Jeff Moyer <jmoyer@redhat.com>

Bugzilla: 1380571

This reverts the very recent rhel7 commit:

f5ba8e13 [fs] ext4: pre-zero allocated blocks for DAX IO

which contains a serious error affecting all block-aligned IOs with
DAX on ext4.

I inadvertently set the get_block function to ext4_get_block_write instead
of ext4_get_block as it should have been, resulting in data loss on
the DAX path for aligned IOs.  Thanks to Jeff Moyer for spotting it.

The fix is trivial; switch the new get_block_func to ext4_get_block,
but there is no time left for testing, and we know that without this
we have only a corner case problem related to page fault races, vs.
the current serious problem with generic IO.  So for now, revert.

Signed-off-by: Eric Sandeen <sandeen@redhat.com>
Signed-off-by: Rafael Aquini <aquini@redhat.com>

diff --git a/fs/ext4/ext4.h b/fs/ext4/ext4.h
index d00d779..ab96289 100644
--- a/fs/ext4/ext4.h
+++ b/fs/ext4/ext4.h
@@ -2096,8 +2096,8 @@ struct buffer_head *ext4_bread(handle_t *, struct inode *,
       ext4_lblk_t, int, int *);
 int ext4_get_block_write(struct inode *inode, sector_t iblock,
     struct buffer_head *bh_result, int create);
-int ext4_dax_get_block(struct inode *inode, sector_t iblock,
-         struct buffer_head *bh_result, int create);
+int ext4_dax_mmap_get_block(struct inode *inode, sector_t iblock,
+       struct buffer_head *bh_result, int create);
 int ext4_get_block(struct inode *inode, sector_t iblock,
     struct buffer_head *bh_result, int create);
 int ext4_da_get_block_prep(struct inode *inode, sector_t iblock,
@@ -2847,13 +2847,6 @@ extern struct mutex ext4__aio_mutex[EXT4_WQ_HASH_SZ];
 extern int ext4_resize_begin(struct super_block *sb);
 extern void ext4_resize_end(struct super_block *sb);
 
-static inline bool ext4_aligned_io(struct inode *inode, loff_t off, loff_t len)
-{
- int blksize = 1 << inode->i_blkbits;
-
- return IS_ALIGNED(off, blksize) && IS_ALIGNED(len, blksize);
-}
-
 #endif /* __KERNEL__ */
 
 #endif /* _EXT4_H */
diff --git a/fs/ext4/file.c b/fs/ext4/file.c
index 3fe5332..de8914c 100644
--- a/fs/ext4/file.c
+++ b/fs/ext4/file.c
@@ -222,7 +222,7 @@ static int ext4_dax_fault(struct vm_area_struct *vma, struct vm_fault *vmf)
  if (IS_ERR(handle))
   result = VM_FAULT_SIGBUS;
  else
-  result = __dax_fault(vma, vmf, ext4_dax_get_block, NULL);
+  result = __dax_fault(vma, vmf, ext4_dax_mmap_get_block, NULL);
 
  if (write) {
   if (!IS_ERR(handle))
@@ -258,7 +258,7 @@ static int ext4_dax_pmd_fault(struct vm_area_struct *vma, unsigned long addr,
   result = VM_FAULT_SIGBUS;
  else
   result = __dax_pmd_fault(vma, addr, pmd, flags,
-    ext4_dax_get_block, NULL);
+    ext4_dax_mmap_get_block, NULL);
 
  if (write) {
   if (!IS_ERR(handle))
diff --git a/fs/ext4/indirect.c b/fs/ext4/indirect.c
index 3f4c59d..a2104bc 100644
--- a/fs/ext4/indirect.c
+++ b/fs/ext4/indirect.c
@@ -704,26 +704,10 @@ retry:
   inode_dio_end(inode);
  } else {
 locked:
-  if (IS_DAX(inode)) {
-   get_block_t *get_block_func = NULL;
-
-   /*
-    * We can avoid zeroing for aligned DAX writes beyond
-    * EOF. Other writes need zeroing either because they
-    * can race with page faults or because they use partial
-    * blocks.
-    */
-   if (rw == READ)
-    get_block_func = ext4_get_block;
-   else if (round_down(offset, 1<<inode->i_blkbits) >=
-        inode->i_size &&
-       ext4_aligned_io(inode, offset, count))
-    get_block_func = ext4_get_block_write;
-   else
-    get_block_func = ext4_dax_get_block;
+  if (IS_DAX(inode))
    ret = dax_do_io(rw, iocb, inode, iov, offset, nr_segs,
-     get_block_func, NULL, DIO_LOCKING);
-  } else
+     ext4_get_block, NULL, DIO_LOCKING);
+  else
    ret = blockdev_direct_IO(rw, iocb, inode, iov,
      offset, nr_segs, ext4_get_block);
 
diff --git a/fs/ext4/inode.c b/fs/ext4/inode.c
index 58d4bac..b14916c 100644
--- a/fs/ext4/inode.c
+++ b/fs/ext4/inode.c
@@ -2975,13 +2975,8 @@ static int ext4_get_block_overwrite(struct inode *inode, sector_t iblock,
 }
 
 #ifdef CONFIG_FS_DAX
-/*
- * Get block function for DAX IO and mmap faults. It takes care of converting
- * unwritten extents to written ones and initializes new / converted blocks
- * to zeros.
- */
-int ext4_dax_get_block(struct inode *inode, sector_t iblock,
-         struct buffer_head *bh_result, int create)
+int ext4_dax_mmap_get_block(struct inode *inode, sector_t iblock,
+       struct buffer_head *bh_result, int create)
 {
  int ret, err;
  int credits;
@@ -2989,7 +2984,8 @@ int ext4_dax_get_block(struct inode *inode, sector_t iblock,
  handle_t *handle = NULL;
  int flags = 0;
 
- ext4_debug("inode %lu, create flag %d\n", inode->i_ino, create);
+ ext4_debug("ext4_dax_mmap_get_block: inode %lu, create flag %d\n",
+     inode->i_ino, create);
  map.m_lblk = iblock;
  map.m_len = bh_result->b_size >> inode->i_blkbits;
  credits = ext4_chunk_trans_blocks(inode, map.m_len);
@@ -3014,9 +3010,9 @@ int ext4_dax_get_block(struct inode *inode, sector_t iblock,
   int err2;
 
   /*
-   * We are protected by i_mmap_sem or i_mutex so we know block
-   * cannot go away from under us even though we dropped
-   * i_data_sem. Convert extent to written and write zeros there.
+   * We are protected by i_mmap_sem so we know block cannot go
+   * away from under us even though we dropped i_data_sem.
+   * Convert extent to written and write zeros there.
    *
    * Note: We may get here even when create == 0.
    */
@@ -3050,14 +3046,6 @@ out:
  }
  return ret;
 }
-#else
-/* Just define empty function, it will never get called. */
-int ext4_dax_get_block(struct inode *inode, sector_t iblock,
-         struct buffer_head *bh_result, int create)
-{
- BUG();
- return 0;
-}
 #endif
 
 static void ext4_end_io_dio(struct kiocb *iocb, loff_t offset,
@@ -3177,25 +3165,13 @@ static ssize_t ext4_ext_direct_IO(int rw, struct kiocb *iocb,
 
  if (overwrite) {
   get_block_func = ext4_get_block_overwrite;
- } else if (IS_DAX(inode)) {
-  /*
-   * We can avoid zeroing for aligned DAX writes beyond EOF. Other
-   * writes need zeroing either because they can race with page
-   * faults or because they use partial blocks.
-   */
-  if (round_down(offset, 1<<inode->i_blkbits) >= inode->i_size &&
-      ext4_aligned_io(inode, offset, count))
-   get_block_func = ext4_get_block_write;
-  else
-   get_block_func = ext4_dax_get_block;
-  dio_flags = DIO_LOCKING;
  } else {
   get_block_func = ext4_get_block_write;
   dio_flags = DIO_LOCKING;
  }
  if (IS_DAX(inode))
   ret = dax_do_io(rw, iocb, inode, iov, offset, nr_segs,
-    get_block_func, ext4_end_io_dio, dio_flags);
+    ext4_get_block, ext4_end_io_dio, dio_flags);
  else
   ret = __blockdev_direct_IO(rw, iocb, inode,
         inode->i_sb->s_bdev, iov, offset,
-- 
1.7.1