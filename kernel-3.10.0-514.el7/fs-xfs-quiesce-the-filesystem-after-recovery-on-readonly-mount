From 96c370d7a9785be6fe9b7081233a387416e9bbca Mon Sep 17 00:00:00 2001
From: Eric Sandeen <sandeen@redhat.com>
Date: Sat, 24 Sep 2016 15:28:16 -0400
Subject: [fs] xfs: quiesce the filesystem after recovery on readonly mount

Message-id: <108bf2be-70cc-ca9d-aefd-fa3804b4acc7@redhat.com>
Patchwork-id: 158359
O-Subject: [RHEL7.3 PATCH] xfs: quiesce the filesystem after recovery on readonly mount
Bugzilla: 1375457
RH-Acked-by: Jeremy McNicoll <jmcnicol@redhat.com>
RH-Acked-by: Brian Foster <bfoster@redhat.com>
RH-Acked-by: Dave Chinner <dchinner@redhat.com>
RH-Acked-by: Carlos Maiolino <cmaiolino@redhat.com>

Bugzilla: 1375457
Testing: Local
Build: Local
Upstream: Posted, reviewed, not yet merged

Upstream: ddeb14f4fb2fa1242829a76edc821f087e50bcdf (xfs tree)
From: Dave Chinner <dchinner@redhat.com>

Recently we've had a number of reports where log recovery on a v5
filesystem has reported corruptions that looked to be caused by
recovery being re-run over the top of an already-recovered
metadata. This has uncovered a bug in recovery (fixed elsewhere)
but the vector that caused this was largely unknown.

A kdump test started tripping over this problem - the system
would be crashed, the kdump kernel and environment would boot and
dump the kernel core image, and then the system would reboot. After
reboot, the root filesystem was triggering log recovery and
corruptions were being detected. The metadumps indicated the above
log recovery issue.

What is happening is that the kdump kernel and environment is
mounting the root device read-only to find the binaries needed to do
it's work. The result of this is that it is running log recovery.
However, because there were unlinked files and EFIs to be processed
by recovery, the completion of phase 1 of log recovery could not
mark the log clean. And because it's a read-only mount, the unmount
process does not write records to the log to mark it clean, either.
Hence on the next mount of the filesystem, log recovery was run
again across all the metadata that had already been recovered and
this is what triggered corruption warnings.

To avoid this problem, we need to ensure that a read-only mount
always updates the log when it completes the second phase of
recovery. We already handle this sort of issue with rw->ro remount
transitions, so the solution is as simple as quiescing the
filesystem at the appropriate time during the mount process. This
results in the log being marked clean so the mount behaviour
recorded in the logs on repeated RO mounts will change (i.e. log
recovery will no longer be run on every mount until a RW mount is
done). This is a user visible change in behaviour, but it is
harmless.

Signed-off-by: Dave Chinner <dchinner@redhat.com>

Signed-off-by: Eric Sandeen <sandeen@redhat.com>
Signed-off-by: Rafael Aquini <aquini@redhat.com>

diff --git a/fs/xfs/xfs_mount.c b/fs/xfs/xfs_mount.c
index 0578844..4b6937b 100644
--- a/fs/xfs/xfs_mount.c
+++ b/fs/xfs/xfs_mount.c
@@ -948,6 +948,20 @@ xfs_mountfs(
  }
 
  /*
+  * Now the log is fully replayed, we can transition to full read-only
+  * mode for read-only mounts. This will sync all the metadata and clean
+  * the log so that the recovery we just performed does not have to be
+  * replayed again on the next mount.
+  *
+  * We use the same quiesce mechanism as the rw->ro remount, as they are
+  * semantically identical operations.
+  */
+ if ((mp->m_flags & (XFS_MOUNT_RDONLY|XFS_MOUNT_NORECOVERY)) ==
+       XFS_MOUNT_RDONLY) {
+  xfs_quiesce_attr(mp);
+ }
+
+ /*
   * Complete the quota initialisation, post-log-replay component.
   */
  if (quotamount) {
diff --git a/fs/xfs/xfs_super.c b/fs/xfs/xfs_super.c
index 9d89a42..0ba7a4b 100644
--- a/fs/xfs/xfs_super.c
+++ b/fs/xfs/xfs_super.c
@@ -1157,7 +1157,7 @@ xfs_restore_resvblks(struct xfs_mount *mp)
  * Note: xfs_log_quiesce() stops background log work - the callers must ensure
  * it is started again when appropriate.
  */
-static void
+void
 xfs_quiesce_attr(
  struct xfs_mount *mp)
 {
diff --git a/fs/xfs/xfs_super.h b/fs/xfs/xfs_super.h
index 499058f..fd59ce1 100644
--- a/fs/xfs/xfs_super.h
+++ b/fs/xfs/xfs_super.h
@@ -63,6 +63,7 @@ struct block_device;
 
 extern __uint64_t xfs_max_file_offset(unsigned int);
 
+extern void xfs_quiesce_attr(struct xfs_mount *mp);
 extern void xfs_flush_inodes(struct xfs_mount *mp);
 extern void xfs_blkdev_issue_flush(struct xfs_buftarg *);
 extern xfs_agnumber_t xfs_set_inode32(struct xfs_mount *, xfs_agnumber_t agcount);
-- 
1.7.1