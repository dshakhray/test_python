From b10162345830c1ffa990260131b18409d3aee76a Mon Sep 17 00:00:00 2001
From: Xin Long <lxin@redhat.com>
Date: Sat, 10 Sep 2016 15:31:06 -0400
Subject: [net] sctp: identify chunks that need to be fragmented at IP level

Message-id: <43cf96b1e52c4250f04dd6cb5a6edc5a12ee9dc6.1473521466.git.lxin@redhat.com>
Patchwork-id: 157751
O-Subject: [RHEL7.3 net PATCH] sctp: identify chunks that need to be fragmented at IP level
Bugzilla: 1371377
RH-Acked-by: Marcelo Leitner <mleitner@redhat.com>
RH-Acked-by: Paolo Abeni <pabeni@redhat.com>
RH-Acked-by: Eric Garver <egarver@redhat.com>
RH-Acked-by: David S. Miller <davem@redhat.com>

Bugzilla: https://bugzilla.redhat.com/show_bug.cgi?id=1371377
Upstream Status: net.git commit 7303a14
Tested Status: QE ran bug reproducer and did some sctp auth tests

commit 7303a1475008bee5c3e82a06a282568415690d72
Author: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
Date:   Thu Sep 8 17:54:11 2016 +0800

    sctp: identify chunks that need to be fragmented at IP level

    Previously, without GSO, it was easy to identify it: if the chunk didn't
    fit and there was no data chunk in the packet yet, we could fragment at
    IP level. So if there was an auth chunk and we were bundling a big data
    chunk, it would fragment regardless of the size of the auth chunk. This
    also works for the context of PMTU reductions.

    But with GSO, we cannot distinguish such PMTU events anymore, as the
    packet is allowed to exceed PMTU.

    So we need another check: to ensure that the chunk that we are adding,
    actually fits the current PMTU. If it doesn't, trigger a flush and let
    it be fragmented at IP level in the next round.

    Signed-off-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

Signed-off-by: Jiri Benc <jbenc@redhat.com>
Signed-off-by: Rafael Aquini <aquini@redhat.com>

diff --git a/net/sctp/output.c b/net/sctp/output.c
index 3905805..4667657 100644
--- a/net/sctp/output.c
+++ b/net/sctp/output.c
@@ -884,7 +884,7 @@ static sctp_xmit_t sctp_packet_will_fit(struct sctp_packet *packet,
      struct sctp_chunk *chunk,
      u16 chunk_len)
 {
- size_t psize, pmtu;
+ size_t psize, pmtu, maxsize;
  sctp_xmit_t retval = SCTP_XMIT_OK;
 
  psize = packet->size;
@@ -912,6 +912,17 @@ static sctp_xmit_t sctp_packet_will_fit(struct sctp_packet *packet,
    goto out;
   }
 
+  /* Similarly, if this chunk was built before a PMTU
+   * reduction, we have to fragment it at IP level now. So
+   * if the packet already contains something, we need to
+   * flush.
+   */
+  maxsize = pmtu - packet->overhead;
+  if (packet->auth)
+   maxsize -= WORD_ROUND(packet->auth->skb->len);
+  if (chunk_len > maxsize)
+   retval = SCTP_XMIT_PMTU_FULL;
+
   /* It is also okay to fragment if the chunk we are
    * adding is a control chunk, but only if current packet
    * is not a GSO one otherwise it causes fragmentation of
-- 
1.7.1