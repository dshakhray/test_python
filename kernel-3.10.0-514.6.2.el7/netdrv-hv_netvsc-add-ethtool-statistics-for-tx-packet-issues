From 52f91bc8ea19fcabe1f83d73fac4825c76816124 Mon Sep 17 00:00:00 2001
From: Vitaly Kuznetsov <vkuznets@redhat.com>
Date: Wed, 9 Nov 2016 15:29:27 -0500
Subject: [netdrv] hv_netvsc: add ethtool statistics for tx packet issues

Message-id: <1478705370-7589-3-git-send-email-vkuznets@redhat.com>
Patchwork-id: 160304
O-Subject: [RHEL7.4 KERNEL PATCH 2/5] hv_netvsc: add ethtool statistics for tx packet issues
Bugzilla: 1392220
Z-Bugzilla: 1395578
RH-Acked-by: Jonathan Toppins <jtoppins@redhat.com>
RH-Acked-by: David S. Miller <davem@redhat.com>
RH-Acked-by: Neil Horman <nhorman@redhat.com>

Upstream commit 4323b47cf8edfe95bd58e20965667e71121c866e
Author: Stephen Hemminger <sthemmin@microsoft.com>
Date:   Tue Aug 23 12:17:57 2016 -0700

    hv_netvsc: add ethtool statistics for tx packet issues

    Printing console messages is not helpful when system is out of memory;
    and can be disastrous with netconsole. Instead keep statistics
    of these anomalous conditions.

    Signed-off-by: Stephen Hemminger <sthemmin@microsoft.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

Signed-off-by: Vitaly Kuznetsov <vkuznets@redhat.com>
Signed-off-by: Frantisek Hrbata <fhrbata@hrbata.com>

diff --git a/drivers/net/hyperv/hyperv_net.h b/drivers/net/hyperv/hyperv_net.h
index 9820645..ef982c8 100644
--- a/drivers/net/hyperv/hyperv_net.h
+++ b/drivers/net/hyperv/hyperv_net.h
@@ -639,6 +639,14 @@ struct netvsc_stats {
  struct u64_stats_sync syncp;
 };
 
+struct netvsc_ethtool_stats {
+ unsigned long tx_scattered;
+ unsigned long tx_no_memory;
+ unsigned long tx_no_space;
+ unsigned long tx_too_big;
+ unsigned long tx_busy;
+};
+
 struct netvsc_reconfig {
  struct list_head list;
  u32 event;
@@ -668,6 +676,7 @@ struct net_device_context {
  /* Ethtool settings */
  u8 duplex;
  u32 speed;
+ struct netvsc_ethtool_stats eth_stats;
 
  /* the device is going away */
  bool start_remove;
diff --git a/drivers/net/hyperv/netvsc_drv.c b/drivers/net/hyperv/netvsc_drv.c
index ca7b429..41d401d 100644
--- a/drivers/net/hyperv/netvsc_drv.c
+++ b/drivers/net/hyperv/netvsc_drv.c
@@ -370,7 +370,6 @@ static int netvsc_start_xmit(struct sk_buff *skb, struct net_device *net)
  u32 skb_length;
  struct hv_page_buffer page_buf[MAX_PAGE_BUFFER_COUNT];
  struct hv_page_buffer *pb = page_buf;
- struct netvsc_stats *tx_stats = this_cpu_ptr(net_device_ctx->tx_stats);
 
  /* We will atmost need two pages to describe the rndis
   * header. We can only transmit MAX_PAGE_BUFFER_COUNT number
@@ -382,17 +381,14 @@ static int netvsc_start_xmit(struct sk_buff *skb, struct net_device *net)
  num_data_pgs = netvsc_get_slots(skb) + 2;
 
  if (unlikely(num_data_pgs > MAX_PAGE_BUFFER_COUNT)) {
-  if (skb_linearize(skb)) {
-   net_alert_ratelimited("failed to linearize skb\n");
-   ret = -ENOMEM;
-   goto drop;
-  }
+  ++net_device_ctx->eth_stats.tx_scattered;
+
+  if (skb_linearize(skb))
+   goto no_memory;
 
   num_data_pgs = netvsc_get_slots(skb) + 2;
   if (num_data_pgs > MAX_PAGE_BUFFER_COUNT) {
-   net_alert_ratelimited("packet too big: %u pages (%u bytes)\n",
-           num_data_pgs, skb->len);
-   ret = -EFAULT;
+   ++net_device_ctx->eth_stats.tx_too_big;
    goto drop;
   }
  }
@@ -403,11 +399,9 @@ static int netvsc_start_xmit(struct sk_buff *skb, struct net_device *net)
   * structure.
   */
  ret = skb_cow_head(skb, RNDIS_AND_PPI_SIZE);
- if (ret) {
-  netdev_err(net, "unable to alloc hv_netvsc_packet\n");
-  ret = -ENOMEM;
-  goto drop;
- }
+ if (ret)
+  goto no_memory;
+
  /* Use the skb control buffer for building up the packet */
  BUILD_BUG_ON(sizeof(struct hv_netvsc_packet) >
    FIELD_SIZEOF(struct sk_buff, cb));
@@ -524,7 +518,7 @@ static int netvsc_start_xmit(struct sk_buff *skb, struct net_device *net)
 
   ret = skb_cow_head(skb, 0);
   if (ret)
-   goto drop;
+   goto no_memory;
 
   uh = udp_hdr(skb);
   udp_len = ntohs(uh->len);
@@ -551,20 +545,32 @@ do_send:
  ret = netvsc_send(net_device_ctx->device_ctx, packet,
      rndis_msg, &pb, skb);
  if (likely(ret == 0)) {
+  struct netvsc_stats *tx_stats = this_cpu_ptr(net_device_ctx->tx_stats);
+
   u64_stats_update_begin(&tx_stats->syncp);
   tx_stats->packets++;
   tx_stats->bytes += skb_length;
   u64_stats_update_end(&tx_stats->syncp);
   return NETDEV_TX_OK;
  }
- if (ret == -EAGAIN)
+
+ if (ret == -EAGAIN) {
+  ++net_device_ctx->eth_stats.tx_busy;
   return NETDEV_TX_BUSY;
+ }
+
+ if (ret == -ENOSPC)
+  ++net_device_ctx->eth_stats.tx_no_space;
 
 drop:
  dev_kfree_skb_any(skb);
  net->stats.tx_dropped++;
 
  return NETDEV_TX_OK;
+
+no_memory:
+ ++net_device_ctx->eth_stats.tx_no_memory;
+ goto drop;
 }
 
 /*
@@ -1011,6 +1017,51 @@ static int netvsc_set_mac_addr(struct net_device *ndev, void *p)
  return err;
 }
 
+static const struct {
+ char name[ETH_GSTRING_LEN];
+ u16 offset;
+} netvsc_stats[] = {
+ { "tx_scattered", offsetof(struct netvsc_ethtool_stats, tx_scattered) },
+ { "tx_no_memory",  offsetof(struct netvsc_ethtool_stats, tx_no_memory) },
+ { "tx_no_space",  offsetof(struct netvsc_ethtool_stats, tx_no_space) },
+ { "tx_too_big",   offsetof(struct netvsc_ethtool_stats, tx_too_big) },
+ { "tx_busy",   offsetof(struct netvsc_ethtool_stats, tx_busy) },
+};
+
+static int netvsc_get_sset_count(struct net_device *dev, int string_set)
+{
+ switch (string_set) {
+ case ETH_SS_STATS:
+  return ARRAY_SIZE(netvsc_stats);
+ default:
+  return -EINVAL;
+ }
+}
+
+static void netvsc_get_ethtool_stats(struct net_device *dev,
+         struct ethtool_stats *stats, u64 *data)
+{
+ struct net_device_context *ndc = netdev_priv(dev);
+ const void *nds = &ndc->eth_stats;
+ int i;
+
+ for (i = 0; i < ARRAY_SIZE(netvsc_stats); i++)
+  data[i] = *(unsigned long *)(nds + netvsc_stats[i].offset);
+}
+
+static void netvsc_get_strings(struct net_device *dev, u32 stringset, u8 *data)
+{
+ int i;
+
+ switch (stringset) {
+ case ETH_SS_STATS:
+  for (i = 0; i < ARRAY_SIZE(netvsc_stats); i++)
+   memcpy(data + i * ETH_GSTRING_LEN,
+          netvsc_stats[i].name, ETH_GSTRING_LEN);
+  break;
+ }
+}
+
 #ifdef CONFIG_NET_POLL_CONTROLLER
 static void netvsc_poll_controller(struct net_device *net)
 {
@@ -1023,6 +1074,9 @@ static void netvsc_poll_controller(struct net_device *net)
 static const struct ethtool_ops ethtool_ops = {
  .get_drvinfo = netvsc_get_drvinfo,
  .get_link = ethtool_op_get_link,
+ .get_ethtool_stats = netvsc_get_ethtool_stats,
+ .get_sset_count = netvsc_get_sset_count,
+ .get_strings = netvsc_get_strings,
  .get_channels   = netvsc_get_channels,
  .set_channels   = netvsc_set_channels,
  .get_ts_info = ethtool_op_get_ts_info,
-- 
1.7.1