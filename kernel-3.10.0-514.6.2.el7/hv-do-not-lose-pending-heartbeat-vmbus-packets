From 51d2b4ebff90c61112bf0f8a201a8c8ca4bc548a Mon Sep 17 00:00:00 2001
From: Vitaly Kuznetsov <vkuznets@redhat.com>
Date: Tue, 1 Nov 2016 12:52:45 -0400
Subject: [hv] do not lose pending heartbeat vmbus packets

Message-id: <1478004765-29396-1-git-send-email-vkuznets@redhat.com>
Patchwork-id: 160188
O-Subject: [RHEL7.4 KERNEL PATCH] hv: do not lose pending heartbeat vmbus packets
Bugzilla: 1378615
Z-Bugzilla: 1392035
RH-Acked-by: Cathy Avery <cavery@redhat.com>
RH-Acked-by: Jarod Wilson <jarod@redhat.com>
RH-Acked-by: Radim Krcmar <rkrcmar@redhat.com>

Bugzilla: https://bugzilla.redhat.com/show_bug.cgi?id=1378615
Brew: https://brewweb.engineering.redhat.com/brew/taskinfo?taskID=11987102
Tested: WS2016 Gen1 guest by me

Upstream commit 407a3aee6ee2d2cb46d9ba3fc380bc29f35d020c
Author: Long Li <longli@microsoft.com>
Date:   Wed Oct 5 16:57:46 2016 -0700

    hv: do not lose pending heartbeat vmbus packets

    The host keeps sending heartbeat packets independent of the
    guest responding to them.  Even though we respond to the heartbeat messages at
    interrupt level, we can have situations where there maybe multiple heartbeat
    messages pending that have not been responded to. For instance this occurs when the
    VM is paused and the host continues to send the heartbeat messages.
    Address this issue by draining and responding to all
    the heartbeat messages that maybe pending.

    Signed-off-by: Long Li <longli@microsoft.com>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    CC: Stable <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

Signed-off-by: Vitaly Kuznetsov <vkuznets@redhat.com>
Signed-off-by: Frantisek Hrbata <fhrbata@hrbata.com>

diff --git a/drivers/hv/hv_util.c b/drivers/hv/hv_util.c
index d5acaa2..9dc6372 100644
--- a/drivers/hv/hv_util.c
+++ b/drivers/hv/hv_util.c
@@ -283,10 +283,14 @@ static void heartbeat_onchannelcallback(void *context)
  u8 *hbeat_txf_buf = util_heartbeat.recv_buffer;
  struct icmsg_negotiate *negop = NULL;
 
- vmbus_recvpacket(channel, hbeat_txf_buf,
-    PAGE_SIZE, &recvlen, &requestid);
+ while (1) {
+
+  vmbus_recvpacket(channel, hbeat_txf_buf,
+     PAGE_SIZE, &recvlen, &requestid);
+
+  if (!recvlen)
+   break;
 
- if (recvlen > 0) {
   icmsghdrp = (struct icmsg_hdr *)&hbeat_txf_buf[
     sizeof(struct vmbuspipe_hdr)];
 
-- 
1.7.1