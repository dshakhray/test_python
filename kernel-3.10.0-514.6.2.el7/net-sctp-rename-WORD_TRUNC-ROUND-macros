From 74177ef1c2519edc8b64c19079915956e6aea623 Mon Sep 17 00:00:00 2001
From: Hangbin Liu <haliu@redhat.com>
Date: Fri, 2 Dec 2016 04:07:04 +0000
Subject: [net] sctp: rename WORD_TRUNC/ROUND macros

Message-id: <1480651625-25420-3-git-send-email-haliu@redhat.com>
Patchwork-id: 160960
O-Subject: [RHEL7.4 net PATCH 2/3] sctp: rename WORD_TRUNC/ROUND macros
Bugzilla: 1399459
Z-Bugzilla: 1399458
CVE: CVE-2016-9555
RH-Acked-by: Xin Long <lxin@redhat.com>
RH-Acked-by: Sabrina Dubroca <sdubroca@redhat.com>
RH-Acked-by: Marcelo Leitner <mleitner@redhat.com>
RH-Acked-by: Davide Caratti <dcaratti@redhat.com>

Bugzilla: https://bugzilla.redhat.com/show_bug.cgi?id=1399459
Brew: https://brewweb.devel.redhat.com/taskinfo?taskID=12187771
Upstream Status: net.git commit e2f036a97271

commit e2f036a97271cf5811ee754bf321a29a814577f9
Author: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
Date:   Wed Sep 21 08:45:55 2016 -0300

    sctp: rename WORD_TRUNC/ROUND macros

    To something more meaningful these days, specially because this is
    working on packet headers or lengths and which are not tied to any CPU
    arch but to the protocol itself.

    So, WORD_TRUNC becomes SCTP_TRUNC4 and WORD_ROUND becomes SCTP_PAD4.

    Reported-by: David Laight <David.Laight@ACULAB.COM>
    Reported-by: David Miller <davem@davemloft.net>
    Signed-off-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

Signed-off-by: Hangbin Liu <haliu@redhat.com>
[fhrbata@redhat.com: fixed fuzz in sctp_packet_transmit]
Signed-off-by: Frantisek Hrbata <fhrbata@redhat.com>

diff --git a/include/net/sctp/sctp.h b/include/net/sctp/sctp.h
index cd487fb..0994f5c 100644
--- a/include/net/sctp/sctp.h
+++ b/include/net/sctp/sctp.h
@@ -90,9 +90,9 @@
 #endif
 
 /* Round an int up to the next multiple of 4.  */
-#define WORD_ROUND(s) (((s)+3)&~3)
+#define SCTP_PAD4(s) (((s)+3)&~3)
 /* Truncate to the previous multiple of 4.  */
-#define WORD_TRUNC(s) ((s)&~3)
+#define SCTP_TRUNC4(s) ((s)&~3)
 
 /*
  * Function declarations.
@@ -439,7 +439,7 @@ static inline int sctp_frag_point(const struct sctp_association *asoc, int pmtu)
  if (asoc->user_frag)
   frag = min_t(int, frag, asoc->user_frag);
 
- frag = WORD_TRUNC(min_t(int, frag, SCTP_MAX_CHUNK_LEN));
+ frag = SCTP_TRUNC4(min_t(int, frag, SCTP_MAX_CHUNK_LEN));
 
  return frag;
 }
@@ -468,7 +468,7 @@ _sctp_walk_params((pos), (chunk), ntohs((chunk)->chunk_hdr.length), member)
 for (pos.v = chunk->member;\
      pos.v <= (void *)chunk + end - ntohs(pos.p->length) &&\
      ntohs(pos.p->length) >= sizeof(sctp_paramhdr_t);\
-     pos.v += WORD_ROUND(ntohs(pos.p->length)))
+     pos.v += SCTP_PAD4(ntohs(pos.p->length)))
 
 #define sctp_walk_errors(err, chunk_hdr)\
 _sctp_walk_errors((err), (chunk_hdr), ntohs((chunk_hdr)->length))
@@ -478,7 +478,7 @@ for (err = (sctp_errhdr_t *)((void *)chunk_hdr + \
      sizeof(sctp_chunkhdr_t));\
      (void *)err <= (void *)chunk_hdr + end - ntohs(err->length) &&\
      ntohs(err->length) >= sizeof(sctp_errhdr_t); \
-     err = (sctp_errhdr_t *)((void *)err + WORD_ROUND(ntohs(err->length))))
+     err = (sctp_errhdr_t *)((void *)err + SCTP_PAD4(ntohs(err->length))))
 
 #define sctp_walk_fwdtsn(pos, chunk)\
 _sctp_walk_fwdtsn((pos), (chunk), ntohs((chunk)->chunk_hdr->length) - sizeof(struct sctp_fwdtsn_chunk))
diff --git a/net/netfilter/xt_sctp.c b/net/netfilter/xt_sctp.c
index ef36a56..4dedb96 100644
--- a/net/netfilter/xt_sctp.c
+++ b/net/netfilter/xt_sctp.c
@@ -68,7 +68,7 @@ match_packet(const struct sk_buff *skb,
     ++i, offset, sch->type, htons(sch->length),
     sch->flags);
 #endif
-  offset += WORD_ROUND(ntohs(sch->length));
+  offset += SCTP_PAD4(ntohs(sch->length));
 
   pr_debug("skb->len: %d\toffset: %d\n", skb->len, offset);
 
diff --git a/net/sctp/associola.c b/net/sctp/associola.c
index 3ce2b5d..3a785ba 100644
--- a/net/sctp/associola.c
+++ b/net/sctp/associola.c
@@ -1421,7 +1421,7 @@ void sctp_assoc_sync_pmtu(struct sock *sk, struct sctp_association *asoc)
     transports) {
   if (t->pmtu_pending && t->dst) {
    sctp_transport_update_pmtu(sk, t,
-         WORD_TRUNC(dst_mtu(t->dst)));
+         SCTP_TRUNC4(dst_mtu(t->dst)));
    t->pmtu_pending = 0;
   }
   if (!pmtu || (t->pathmtu < pmtu))
diff --git a/net/sctp/chunk.c b/net/sctp/chunk.c
index 47e2c80..cb37068 100644
--- a/net/sctp/chunk.c
+++ b/net/sctp/chunk.c
@@ -214,8 +214,8 @@ struct sctp_datamsg *sctp_datamsg_from_user(struct sctp_association *asoc,
   struct sctp_hmac *hmac_desc = sctp_auth_asoc_get_hmac(asoc);
 
   if (hmac_desc)
-   max_data -= WORD_ROUND(sizeof(sctp_auth_chunk_t) +
-         hmac_desc->hmac_len);
+   max_data -= SCTP_PAD4(sizeof(sctp_auth_chunk_t) +
+           hmac_desc->hmac_len);
  }
 
  /* Now, check if we need to reduce our max */
@@ -235,7 +235,7 @@ struct sctp_datamsg *sctp_datamsg_from_user(struct sctp_association *asoc,
      asoc->outqueue.out_qlen == 0 &&
      list_empty(&asoc->outqueue.retransmit) &&
      msg_len > max)
-  max_data -= WORD_ROUND(sizeof(sctp_sack_chunk_t));
+  max_data -= SCTP_PAD4(sizeof(sctp_sack_chunk_t));
 
  /* Encourage Cookie-ECHO bundling. */
  if (asoc->state < SCTP_STATE_COOKIE_ECHOED)
diff --git a/net/sctp/input.c b/net/sctp/input.c
index 7720f36..92bb5ec 100644
--- a/net/sctp/input.c
+++ b/net/sctp/input.c
@@ -609,7 +609,7 @@ void sctp_v4_err(struct sk_buff *skb, __u32 info)
   /* PMTU discovery (RFC1191) */
   if (ICMP_FRAG_NEEDED == code) {
    sctp_icmp_frag_needed(sk, asoc, transport,
-           WORD_TRUNC(info));
+           SCTP_TRUNC4(info));
    goto out_unlock;
   } else {
    if (ICMP_PROT_UNREACH == code) {
@@ -677,7 +677,7 @@ static int sctp_rcv_ootb(struct sk_buff *skb)
   if (ntohs(ch->length) < sizeof(sctp_chunkhdr_t))
    break;
 
-  ch_end = offset + WORD_ROUND(ntohs(ch->length));
+  ch_end = offset + SCTP_PAD4(ntohs(ch->length));
   if (ch_end > skb->len)
    break;
 
@@ -1132,7 +1132,7 @@ static struct sctp_association *__sctp_rcv_walk_lookup(struct net *net,
   if (ntohs(ch->length) < sizeof(sctp_chunkhdr_t))
    break;
 
-  ch_end = ((__u8 *)ch) + WORD_ROUND(ntohs(ch->length));
+  ch_end = ((__u8 *)ch) + SCTP_PAD4(ntohs(ch->length));
   if (ch_end > skb_tail_pointer(skb))
    break;
 
@@ -1201,7 +1201,7 @@ static struct sctp_association *__sctp_rcv_lookup_harder(struct net *net,
   * that the chunk length doesn't cause overflow.  Otherwise, we'll
   * walk off the end.
   */
- if (WORD_ROUND(ntohs(ch->length)) > skb->len)
+ if (SCTP_PAD4(ntohs(ch->length)) > skb->len)
   return NULL;
 
  /* If this is INIT/INIT-ACK look inside the chunk too. */
diff --git a/net/sctp/inqueue.c b/net/sctp/inqueue.c
index 2d9d158..9e8840a 100644
--- a/net/sctp/inqueue.c
+++ b/net/sctp/inqueue.c
@@ -219,7 +219,7 @@ new_skb:
  }
 
  chunk->chunk_hdr = ch;
- chunk->chunk_end = ((__u8 *)ch) + WORD_ROUND(ntohs(ch->length));
+ chunk->chunk_end = ((__u8 *)ch) + SCTP_PAD4(ntohs(ch->length));
  skb_pull(chunk->skb, sizeof(sctp_chunkhdr_t));
  chunk->subh.v = NULL; /* Subheader is no longer valid.  */
 
diff --git a/net/sctp/output.c b/net/sctp/output.c
index a778e2d..5f10855 100644
--- a/net/sctp/output.c
+++ b/net/sctp/output.c
@@ -304,7 +304,7 @@ static sctp_xmit_t __sctp_packet_append_chunk(struct sctp_packet *packet,
            struct sctp_chunk *chunk)
 {
  sctp_xmit_t retval = SCTP_XMIT_OK;
- __u16 chunk_len = WORD_ROUND(ntohs(chunk->chunk_hdr->length));
+ __u16 chunk_len = SCTP_PAD4(ntohs(chunk->chunk_hdr->length));
 
  /* Check to see if this chunk will fit into the packet */
  retval = sctp_packet_will_fit(packet, chunk, chunk_len);
@@ -515,7 +515,7 @@ int sctp_packet_transmit(struct sctp_packet *packet, gfp_t gfp)
   if (gso) {
    pkt_size = packet->overhead;
    list_for_each_entry(chunk, &packet->chunk_list, list) {
-    int padded = WORD_ROUND(chunk->skb->len);
+    int padded = SCTP_PAD4(chunk->skb->len);
 
     if (pkt_size + padded > tp->pathmtu)
      break;
@@ -545,7 +545,7 @@ int sctp_packet_transmit(struct sctp_packet *packet, gfp_t gfp)
    * included in the chunk length field.  The sender should
    * never pad with more than 3 bytes.
    *
-   * [This whole comment explains WORD_ROUND() below.]
+   * [This whole comment explains SCTP_PAD4() below.]
    */
 
   pkt_size -= packet->overhead;
@@ -567,7 +567,7 @@ int sctp_packet_transmit(struct sctp_packet *packet, gfp_t gfp)
     has_data = 1;
    }
 
-   padding = WORD_ROUND(chunk->skb->len) - chunk->skb->len;
+   padding = SCTP_PAD4(chunk->skb->len) - chunk->skb->len;
    if (padding)
     memset(skb_put(chunk->skb, padding), 0, padding);
 
@@ -594,7 +594,7 @@ int sctp_packet_transmit(struct sctp_packet *packet, gfp_t gfp)
     * acknowledged or have failed.
     * Re-queue auth chunks if needed.
     */
-   pkt_size -= WORD_ROUND(chunk->skb->len);
+   pkt_size -= SCTP_PAD4(chunk->skb->len);
 
    if (!sctp_chunk_is_data(chunk) && chunk != packet->auth)
     sctp_chunk_free(chunk);
@@ -917,7 +917,7 @@ static sctp_xmit_t sctp_packet_will_fit(struct sctp_packet *packet,
    */
   maxsize = pmtu - packet->overhead;
   if (packet->auth)
-   maxsize -= WORD_ROUND(packet->auth->skb->len);
+   maxsize -= SCTP_PAD4(packet->auth->skb->len);
   if (chunk_len > maxsize)
    retval = SCTP_XMIT_PMTU_FULL;
 
diff --git a/net/sctp/sm_make_chunk.c b/net/sctp/sm_make_chunk.c
index c189f65..fb7bbc3 100644
--- a/net/sctp/sm_make_chunk.c
+++ b/net/sctp/sm_make_chunk.c
@@ -263,7 +263,7 @@ struct sctp_chunk *sctp_make_init(const struct sctp_association *asoc,
  num_types = sp->pf->supported_addrs(sp, types);
 
  chunksize = sizeof(init) + addrs_len;
- chunksize += WORD_ROUND(SCTP_SAT_LEN(num_types));
+ chunksize += SCTP_PAD4(SCTP_SAT_LEN(num_types));
  chunksize += sizeof(ecap_param);
 
  if (asoc->prsctp_enable)
@@ -293,14 +293,14 @@ struct sctp_chunk *sctp_make_init(const struct sctp_association *asoc,
   /* Add HMACS parameter length if any were defined */
   auth_hmacs = (sctp_paramhdr_t *)asoc->c.auth_hmacs;
   if (auth_hmacs->length)
-   chunksize += WORD_ROUND(ntohs(auth_hmacs->length));
+   chunksize += SCTP_PAD4(ntohs(auth_hmacs->length));
   else
    auth_hmacs = NULL;
 
   /* Add CHUNKS parameter length */
   auth_chunks = (sctp_paramhdr_t *)asoc->c.auth_chunks;
   if (auth_chunks->length)
-   chunksize += WORD_ROUND(ntohs(auth_chunks->length));
+   chunksize += SCTP_PAD4(ntohs(auth_chunks->length));
   else
    auth_chunks = NULL;
 
@@ -310,8 +310,8 @@ struct sctp_chunk *sctp_make_init(const struct sctp_association *asoc,
 
  /* If we have any extensions to report, account for that */
  if (num_ext)
-  chunksize += WORD_ROUND(sizeof(sctp_supported_ext_param_t) +
-     num_ext);
+  chunksize += SCTP_PAD4(sizeof(sctp_supported_ext_param_t) +
+           num_ext);
 
  /* RFC 2960 3.3.2 Initiation (INIT) (1)
   *
@@ -453,13 +453,13 @@ struct sctp_chunk *sctp_make_init_ack(const struct sctp_association *asoc,
 
   auth_hmacs = (sctp_paramhdr_t *)asoc->c.auth_hmacs;
   if (auth_hmacs->length)
-   chunksize += WORD_ROUND(ntohs(auth_hmacs->length));
+   chunksize += SCTP_PAD4(ntohs(auth_hmacs->length));
   else
    auth_hmacs = NULL;
 
   auth_chunks = (sctp_paramhdr_t *)asoc->c.auth_chunks;
   if (auth_chunks->length)
-   chunksize += WORD_ROUND(ntohs(auth_chunks->length));
+   chunksize += SCTP_PAD4(ntohs(auth_chunks->length));
   else
    auth_chunks = NULL;
 
@@ -468,8 +468,8 @@ struct sctp_chunk *sctp_make_init_ack(const struct sctp_association *asoc,
  }
 
  if (num_ext)
-  chunksize += WORD_ROUND(sizeof(sctp_supported_ext_param_t) +
-     num_ext);
+  chunksize += SCTP_PAD4(sizeof(sctp_supported_ext_param_t) +
+           num_ext);
 
  /* Now allocate and fill out the chunk.  */
  retval = sctp_make_control(asoc, SCTP_CID_INIT_ACK, 0, chunksize, gfp);
@@ -1413,7 +1413,7 @@ static struct sctp_chunk *_sctp_make_chunk(const struct sctp_association *asoc,
  struct sock *sk;
 
  /* No need to allocate LL here, as this is only a chunk. */
- skb = alloc_skb(WORD_ROUND(sizeof(sctp_chunkhdr_t) + paylen), gfp);
+ skb = alloc_skb(SCTP_PAD4(sizeof(sctp_chunkhdr_t) + paylen), gfp);
  if (!skb)
   goto nodata;
 
@@ -1505,7 +1505,7 @@ void *sctp_addto_chunk(struct sctp_chunk *chunk, int len, const void *data)
  void *target;
  void *padding;
  int chunklen = ntohs(chunk->chunk_hdr->length);
- int padlen = WORD_ROUND(chunklen) - chunklen;
+ int padlen = SCTP_PAD4(chunklen) - chunklen;
 
  padding = skb_put(chunk->skb, padlen);
  target = skb_put(chunk->skb, len);
@@ -1923,7 +1923,7 @@ static int sctp_process_missing_param(const struct sctp_association *asoc,
  struct __sctp_missing report;
  __u16 len;
 
- len = WORD_ROUND(sizeof(report));
+ len = SCTP_PAD4(sizeof(report));
 
  /* Make an ERROR chunk, preparing enough room for
   * returning multiple unknown parameters.
@@ -2121,9 +2121,9 @@ static sctp_ierror_t sctp_process_unk_param(const struct sctp_association *asoc,
 
   if (*errp) {
    if (!sctp_init_cause_fixed(*errp, SCTP_ERROR_UNKNOWN_PARAM,
-     WORD_ROUND(ntohs(param.p->length))))
+     SCTP_PAD4(ntohs(param.p->length))))
     sctp_addto_chunk_fixed(*errp,
-      WORD_ROUND(ntohs(param.p->length)),
+      SCTP_PAD4(ntohs(param.p->length)),
       param.v);
   } else {
    /* If there is no memory for generating the ERROR
diff --git a/net/sctp/sm_statefuns.c b/net/sctp/sm_statefuns.c
index 1d4eaa3..e4df313 100644
--- a/net/sctp/sm_statefuns.c
+++ b/net/sctp/sm_statefuns.c
@@ -3461,7 +3461,7 @@ sctp_disposition_t sctp_sf_ootb(struct net *net,
   }
 
   /* Report violation if chunk len overflows */
-  ch_end = ((__u8 *)ch) + WORD_ROUND(ntohs(ch->length));
+  ch_end = ((__u8 *)ch) + SCTP_PAD4(ntohs(ch->length));
   if (ch_end > skb_tail_pointer(skb))
    return sctp_sf_violation_chunklen(net, ep, asoc, type, arg,
         commands);
@@ -4193,7 +4193,7 @@ sctp_disposition_t sctp_sf_unk_chunk(struct net *net,
   hdr = unk_chunk->chunk_hdr;
   err_chunk = sctp_make_op_error(asoc, unk_chunk,
             SCTP_ERROR_UNKNOWN_CHUNK, hdr,
-            WORD_ROUND(ntohs(hdr->length)),
+            SCTP_PAD4(ntohs(hdr->length)),
             0);
   if (err_chunk) {
    sctp_add_cmd_sf(commands, SCTP_CMD_REPLY,
@@ -4213,7 +4213,7 @@ sctp_disposition_t sctp_sf_unk_chunk(struct net *net,
   hdr = unk_chunk->chunk_hdr;
   err_chunk = sctp_make_op_error(asoc, unk_chunk,
             SCTP_ERROR_UNKNOWN_CHUNK, hdr,
-            WORD_ROUND(ntohs(hdr->length)),
+            SCTP_PAD4(ntohs(hdr->length)),
             0);
   if (err_chunk) {
    sctp_add_cmd_sf(commands, SCTP_CMD_REPLY,
diff --git a/net/sctp/transport.c b/net/sctp/transport.c
index fa58856..545086e 100644
--- a/net/sctp/transport.c
+++ b/net/sctp/transport.c
@@ -240,7 +240,7 @@ void sctp_transport_pmtu(struct sctp_transport *transport, struct sock *sk)
  }
 
  if (transport->dst) {
-  transport->pathmtu = WORD_TRUNC(dst_mtu(transport->dst));
+  transport->pathmtu = SCTP_TRUNC4(dst_mtu(transport->dst));
  } else
   transport->pathmtu = SCTP_DEFAULT_MAXSEGMENT;
 }
@@ -294,7 +294,7 @@ void sctp_transport_route(struct sctp_transport *transport,
   return;
  }
  if (transport->dst) {
-  transport->pathmtu = WORD_TRUNC(dst_mtu(transport->dst));
+  transport->pathmtu = SCTP_TRUNC4(dst_mtu(transport->dst));
 
   /* Initialize sk->sk_rcv_saddr, if the transport is the
    * association's active path for getsockname().
diff --git a/net/sctp/ulpevent.c b/net/sctp/ulpevent.c
index 495ea8e..de62359 100644
--- a/net/sctp/ulpevent.c
+++ b/net/sctp/ulpevent.c
@@ -389,7 +389,7 @@ struct sctp_ulpevent *sctp_ulpevent_make_remote_error(
 
  ch = (sctp_errhdr_t *)(chunk->skb->data);
  cause = ch->cause;
- elen = WORD_ROUND(ntohs(ch->length)) - sizeof(sctp_errhdr_t);
+ elen = SCTP_PAD4(ntohs(ch->length)) - sizeof(sctp_errhdr_t);
 
  /* Pull off the ERROR header.  */
  skb_pull(chunk->skb, sizeof(sctp_errhdr_t));
@@ -736,7 +736,7 @@ struct sctp_ulpevent *sctp_ulpevent_make_rcvmsg(struct sctp_association *asoc,
   * MUST ignore the padding bytes.
   */
  len = ntohs(chunk->chunk_hdr->length);
- padding = WORD_ROUND(len) - len;
+ padding = SCTP_PAD4(len) - len;
 
  /* Fixup cloned skb with just this chunks data.  */
  skb_trim(skb, chunk->chunk_end - padding - skb->data);
-- 
1.7.1