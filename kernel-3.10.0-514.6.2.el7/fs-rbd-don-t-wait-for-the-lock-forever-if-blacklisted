From 60eb467822af4c853c65c1d30e8cf1a00c284eed Mon Sep 17 00:00:00 2001
From: Ilya Dryomov <idryomov@redhat.com>
Date: Mon, 17 Oct 2016 08:53:03 -0400
Subject: [fs] rbd: don't wait for the lock forever if blacklisted

Message-id: <1476694384-21682-3-git-send-email-idryomov@redhat.com>
Patchwork-id: 158990
O-Subject: [RHEL7.4 fs PATCH 2/3] rbd: don't wait for the lock forever if blacklisted
Bugzilla: 1378186
Z-Bugzilla: 1393485
RH-Acked-by: Jeremy McNicoll <jmcnicol@redhat.com>
RH-Acked-by: Mike Christie <mchristi@redhat.com>
RH-Acked-by: Sage Weil <sweil@redhat.com>

From: Ilya Dryomov <idryomov@gmail.com>

-EBLACKLISTED from __rbd_register_watch() means that our ceph_client
got blacklisted - we won't be able to restore the watch and reacquire
the lock.  Wake up and fail all outstanding requests waiting for the
lock and arrange for all new requests that require the lock to fail
immediately.

Signed-off-by: Ilya Dryomov <idryomov@gmail.com>
Tested-by: Mike Christie <mchristi@redhat.com>
(cherry picked from commit 87c0fded852ae20bddb7833da6ead082404de86a)
Signed-off-by: Frantisek Hrbata <fhrbata@hrbata.com>

diff --git a/drivers/block/rbd.c b/drivers/block/rbd.c
index a2f32de..4c51f19 100644
--- a/drivers/block/rbd.c
+++ b/drivers/block/rbd.c
@@ -415,15 +415,15 @@ struct rbd_device {
 };
 
 /*
- * Flag bits for rbd_dev->flags.  If atomicity is required,
- * rbd_dev->lock is used to protect access.
- *
- * Currently, only the "removing" flag (which is coupled with the
- * "open_count" field) requires atomic access.
+ * Flag bits for rbd_dev->flags:
+ * - REMOVING (which is coupled with rbd_dev->open_count) is protected
+ *   by rbd_dev->lock
+ * - BLACKLISTED is protected by rbd_dev->lock_rwsem
  */
 enum rbd_dev_flags {
  RBD_DEV_FLAG_EXISTS, /* mapped snapshot has not been deleted */
  RBD_DEV_FLAG_REMOVING, /* this mapping is being removed */
+ RBD_DEV_FLAG_BLACKLISTED, /* our ceph_client is blacklisted */
 };
 
 static DEFINE_MUTEX(client_mutex); /* Serialize client creation */
@@ -3989,6 +3989,7 @@ static void rbd_reregister_watch(struct work_struct *work)
  struct rbd_device *rbd_dev = container_of(to_delayed_work(work),
          struct rbd_device, watch_dwork);
  bool was_lock_owner = false;
+ bool need_to_wake = false;
  int ret;
 
  dout("%s rbd_dev %p\n", __func__, rbd_dev);
@@ -3998,19 +3999,27 @@ static void rbd_reregister_watch(struct work_struct *work)
   was_lock_owner = rbd_release_lock(rbd_dev);
 
  mutex_lock(&rbd_dev->watch_mutex);
- if (rbd_dev->watch_state != RBD_WATCH_STATE_ERROR)
-  goto fail_unlock;
+ if (rbd_dev->watch_state != RBD_WATCH_STATE_ERROR) {
+  mutex_unlock(&rbd_dev->watch_mutex);
+  goto out;
+ }
 
  ret = __rbd_register_watch(rbd_dev);
  if (ret) {
   rbd_warn(rbd_dev, "failed to reregister watch: %d", ret);
-  if (ret != -EBLACKLISTED)
+  if (ret == -EBLACKLISTED) {
+   set_bit(RBD_DEV_FLAG_BLACKLISTED, &rbd_dev->flags);
+   need_to_wake = true;
+  } else {
    queue_delayed_work(rbd_dev->task_wq,
         &rbd_dev->watch_dwork,
         RBD_RETRY_DELAY);
-  goto fail_unlock;
+  }
+  mutex_unlock(&rbd_dev->watch_mutex);
+  goto out;
  }
 
+ need_to_wake = true;
  rbd_dev->watch_state = RBD_WATCH_STATE_REGISTERED;
  rbd_dev->watch_cookie = rbd_dev->watch_handle->linger_id;
  mutex_unlock(&rbd_dev->watch_mutex);
@@ -4026,13 +4035,10 @@ static void rbd_reregister_watch(struct work_struct *work)
      ret);
  }
 
+out:
  up_write(&rbd_dev->lock_rwsem);
- wake_requests(rbd_dev, true);
- return;
-
-fail_unlock:
- mutex_unlock(&rbd_dev->watch_mutex);
- up_write(&rbd_dev->lock_rwsem);
+ if (need_to_wake)
+  wake_requests(rbd_dev, true);
 }
 
 /*
@@ -4141,7 +4147,9 @@ static void rbd_wait_state_locked(struct rbd_device *rbd_dev)
   up_read(&rbd_dev->lock_rwsem);
   schedule();
   down_read(&rbd_dev->lock_rwsem);
- } while (rbd_dev->lock_state != RBD_LOCK_STATE_LOCKED);
+ } while (rbd_dev->lock_state != RBD_LOCK_STATE_LOCKED &&
+   !test_bit(RBD_DEV_FLAG_BLACKLISTED, &rbd_dev->flags));
+
  finish_wait(&rbd_dev->lock_waitq, &wait);
 }
 
@@ -4233,8 +4241,16 @@ static void rbd_queue_workfn(struct work_struct *work)
 
  if (must_be_locked) {
   down_read(&rbd_dev->lock_rwsem);
-  if (rbd_dev->lock_state != RBD_LOCK_STATE_LOCKED)
+  if (rbd_dev->lock_state != RBD_LOCK_STATE_LOCKED &&
+      !test_bit(RBD_DEV_FLAG_BLACKLISTED, &rbd_dev->flags))
    rbd_wait_state_locked(rbd_dev);
+
+  WARN_ON((rbd_dev->lock_state == RBD_LOCK_STATE_LOCKED) ^
+   !test_bit(RBD_DEV_FLAG_BLACKLISTED, &rbd_dev->flags));
+  if (test_bit(RBD_DEV_FLAG_BLACKLISTED, &rbd_dev->flags)) {
+   result = -EBLACKLISTED;
+   goto err_unlock;
+  }
  }
 
  img_request = rbd_img_request_create(rbd_dev, offset, length, op_type,
-- 
1.7.1