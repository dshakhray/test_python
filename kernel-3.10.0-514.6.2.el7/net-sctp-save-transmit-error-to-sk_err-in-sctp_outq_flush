From 3e9ea92bfbec38a7e9301a09f5f7118297cda7f8 Mon Sep 17 00:00:00 2001
From: Xin Long <lxin@redhat.com>
Date: Wed, 28 Sep 2016 12:00:43 -0400
Subject: [net] sctp: save transmit error to sk_err in sctp_outq_flush

Message-id: <68173cc75137521915172768794fbdd11c856839.1475063952.git.lxin@redhat.com>
Patchwork-id: 158414
O-Subject: [RHEL7.4 net PATCH 4/6] sctp: save transmit error to sk_err in sctp_outq_flush
Bugzilla: 1371362
Z-Bugzilla: 1392025
RH-Acked-by: David S. Miller <davem@redhat.com>
RH-Acked-by: Marcelo Leitner <mleitner@redhat.com>
RH-Acked-by: Jarod Wilson <jarod@redhat.com>
RH-Acked-by: Paolo Abeni <pabeni@redhat.com>
RH-Acked-by: Eric Garver <egarver@redhat.com>

Bugzilla: https://bugzilla.redhat.com/show_bug.cgi?id=1371362
Upstream Status: net-next.git commit 6451944

commit 645194409b0634a43890ec27c491c368b3bffc07
Author: Xin Long <lucien.xin@gmail.com>
Date:   Wed Sep 14 02:04:21 2016 +0800

    sctp: save transmit error to sk_err in sctp_outq_flush

    Every time when sctp calls sctp_outq_flush, it sends out the chunks of
    control queue, retransmit queue and data queue. Even if some trunks are
    failed to transmit, it still has to flush all the transports, as it's
    the only chance to clean that transmit_list.

    So the latest transmit error here should be returned back. This transmit
    error is an internal error of sctp stack.

    I checked all the places where it uses the transmit error (the return
    value of sctp_outq_flush), most of them are actually just save it to
    sk_err.

    Except for sctp_assoc/endpoint_bh_rcv, they will drop the chunk if
    it's failed to send a REPLY, which is actually incorrect, as we can't
    be sure the error that sctp_outq_flush returns is from sending that
    REPLY.

    So it's meaningless for sctp_outq_flush to return error back.

    This patch is to save transmit error to sk_err in sctp_outq_flush, the
    new error can update the old value. Eventually, sctp_wait_for_* would
    check for it.

    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

Signed-off-by: Jiri Benc <jbenc@redhat.com>
Signed-off-by: Frantisek Hrbata <fhrbata@hrbata.com>

diff --git a/net/sctp/output.c b/net/sctp/output.c
index 4667657..140d378 100644
--- a/net/sctp/output.c
+++ b/net/sctp/output.c
@@ -187,7 +187,6 @@ sctp_xmit_t sctp_packet_transmit_chunk(struct sctp_packet *packet,
            int one_packet, gfp_t gfp)
 {
  sctp_xmit_t retval;
- int error = 0;
 
  pr_debug("%s: packet:%p size:%Zu chunk:%p size:%d\n", __func__,
    packet, packet->size, chunk, chunk->skb ? chunk->skb->len : -1);
@@ -195,6 +194,8 @@ sctp_xmit_t sctp_packet_transmit_chunk(struct sctp_packet *packet,
  switch ((retval = (sctp_packet_append_chunk(packet, chunk)))) {
  case SCTP_XMIT_PMTU_FULL:
   if (!packet->has_cookie_echo) {
+   int error = 0;
+
    error = sctp_packet_transmit(packet, gfp);
    if (error < 0)
     chunk->skb->sk->sk_err = -error;
diff --git a/net/sctp/outqueue.c b/net/sctp/outqueue.c
index 7aed2a6..87a522b 100644
--- a/net/sctp/outqueue.c
+++ b/net/sctp/outqueue.c
@@ -540,7 +540,6 @@ void sctp_retransmit(struct sctp_outq *q, struct sctp_transport *transport,
        sctp_retransmit_reason_t reason)
 {
  struct net *net = sock_net(q->asoc->base.sk);
- int error = 0;
 
  switch (reason) {
  case SCTP_RTXR_T3_RTX:
@@ -584,10 +583,7 @@ void sctp_retransmit(struct sctp_outq *q, struct sctp_transport *transport,
   * will be flushed at the end.
   */
  if (reason != SCTP_RTXR_FAST_RTX)
-  error = sctp_outq_flush(q, /* rtx_timeout */ 1, GFP_ATOMIC);
-
- if (error)
-  q->asoc->base.sk->sk_err = -error;
+  sctp_outq_flush(q, /* rtx_timeout */ 1, GFP_ATOMIC);
 }
 
 /*
@@ -900,8 +896,10 @@ static int sctp_outq_flush(struct sctp_outq *q, int rtx_timeout, gfp_t gfp)
    sctp_packet_config(&singleton, vtag, 0);
    sctp_packet_append_chunk(&singleton, chunk);
    error = sctp_packet_transmit(&singleton, gfp);
-   if (error < 0)
-    return error;
+   if (error < 0) {
+    asoc->base.sk->sk_err = -error;
+    return 0;
+   }
    break;
 
   case SCTP_CID_ABORT:
@@ -999,6 +997,8 @@ static int sctp_outq_flush(struct sctp_outq *q, int rtx_timeout, gfp_t gfp)
   retran:
    error = sctp_outq_flush_rtx(q, packet,
           rtx_timeout, &start_timer);
+   if (error < 0)
+    asoc->base.sk->sk_err = -error;
 
    if (start_timer) {
     sctp_transport_reset_t3_rtx(transport);
@@ -1174,14 +1174,17 @@ sctp_flush_out:
             struct sctp_transport,
             send_ready);
   packet = &t->packet;
-  if (!sctp_packet_empty(packet))
+  if (!sctp_packet_empty(packet)) {
    error = sctp_packet_transmit(packet, gfp);
+   if (error < 0)
+    asoc->base.sk->sk_err = -error;
+  }
 
   /* Clear the burst limited state, if any */
   sctp_transport_burst_reset(t);
  }
 
- return error;
+ return 0;
 }
 
 /* Update unack_data based on the incoming SACK chunk */
-- 
1.7.1