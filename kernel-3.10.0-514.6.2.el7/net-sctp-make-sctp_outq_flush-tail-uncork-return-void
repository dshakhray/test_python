From 27f82995fe3839fcf8c1302419399436e49eb0a1 Mon Sep 17 00:00:00 2001
From: Xin Long <lxin@redhat.com>
Date: Wed, 28 Sep 2016 12:00:44 -0400
Subject: [net] sctp: make sctp_outq_flush/tail/uncork return void

Message-id: <c15b3859699daaf4e49bb03f9ff0764fe7d602a3.1475063952.git.lxin@redhat.com>
Patchwork-id: 158415
O-Subject: [RHEL7.4 net PATCH 5/6] sctp: make sctp_outq_flush/tail/uncork return void
Bugzilla: 1371362
Z-Bugzilla: 1392025
RH-Acked-by: David S. Miller <davem@redhat.com>
RH-Acked-by: Marcelo Leitner <mleitner@redhat.com>
RH-Acked-by: Jarod Wilson <jarod@redhat.com>
RH-Acked-by: Eric Garver <egarver@redhat.com>
RH-Acked-by: Paolo Abeni <pabeni@redhat.com>

Bugzilla: https://bugzilla.redhat.com/show_bug.cgi?id=1371362
Upstream Status: net-next.git commit 83dbc3d

commit 83dbc3d4a38411ef38f680d7045c8478cc9c5a56
Author: Xin Long <lucien.xin@gmail.com>
Date:   Wed Sep 14 02:04:22 2016 +0800

    sctp: make sctp_outq_flush/tail/uncork return void

    sctp_outq_flush return value is meaningless now, this patch is
    to make sctp_outq_flush return void, as well as sctp_outq_fail
    and sctp_outq_uncork.

    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

Signed-off-by: Jiri Benc <jbenc@redhat.com>
Signed-off-by: Frantisek Hrbata <fhrbata@hrbata.com>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 0d5e89c..7c84269 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -1083,7 +1083,7 @@ struct sctp_outq {
 void sctp_outq_init(struct sctp_association *, struct sctp_outq *);
 void sctp_outq_teardown(struct sctp_outq *);
 void sctp_outq_free(struct sctp_outq*);
-int sctp_outq_tail(struct sctp_outq *, struct sctp_chunk *chunk, gfp_t);
+void sctp_outq_tail(struct sctp_outq *, struct sctp_chunk *chunk, gfp_t);
 int sctp_outq_sack(struct sctp_outq *, struct sctp_chunk *);
 int sctp_outq_is_empty(const struct sctp_outq *);
 void sctp_outq_restart(struct sctp_outq *);
@@ -1091,7 +1091,7 @@ void sctp_outq_restart(struct sctp_outq *);
 void sctp_retransmit(struct sctp_outq *, struct sctp_transport *,
        sctp_retransmit_reason_t);
 void sctp_retransmit_mark(struct sctp_outq *, struct sctp_transport *, __u8);
-int sctp_outq_uncork(struct sctp_outq *, gfp_t gfp);
+void sctp_outq_uncork(struct sctp_outq *, gfp_t gfp);
 void sctp_prsctp_prune(struct sctp_association *asoc,
          struct sctp_sndrcvinfo *sinfo, int msg_len);
 /* Uncork and flush an outqueue.  */
diff --git a/net/sctp/outqueue.c b/net/sctp/outqueue.c
index 87a522b..e29b9f1 100644
--- a/net/sctp/outqueue.c
+++ b/net/sctp/outqueue.c
@@ -75,7 +75,7 @@ static void sctp_mark_missing(struct sctp_outq *q,
 
 static void sctp_generate_fwdtsn(struct sctp_outq *q, __u32 sack_ctsn);
 
-static int sctp_outq_flush(struct sctp_outq *q, int rtx_timeout, gfp_t gfp);
+static void sctp_outq_flush(struct sctp_outq *q, int rtx_timeout, gfp_t gfp);
 
 /* Add data to the front of the queue. */
 static inline void sctp_outq_head_data(struct sctp_outq *q,
@@ -292,10 +292,9 @@ void sctp_outq_free(struct sctp_outq *q)
 }
 
 /* Put a new chunk in an sctp_outq.  */
-int sctp_outq_tail(struct sctp_outq *q, struct sctp_chunk *chunk, gfp_t gfp)
+void sctp_outq_tail(struct sctp_outq *q, struct sctp_chunk *chunk, gfp_t gfp)
 {
  struct net *net = sock_net(q->asoc->base.sk);
- int error = 0;
 
  pr_debug("%s: outq:%p, chunk:%p[%s]\n", __func__, q, chunk,
    chunk && chunk->chunk_hdr ?
@@ -325,9 +324,7 @@ int sctp_outq_tail(struct sctp_outq *q, struct sctp_chunk *chunk, gfp_t gfp)
  }
 
  if (!q->cork)
-  error = sctp_outq_flush(q, 0, gfp);
-
- return error;
+  sctp_outq_flush(q, 0, gfp);
 }
 
 /* Insert a chunk into the sorted list based on the TSNs.  The retransmit list
@@ -755,12 +752,12 @@ redo:
 }
 
 /* Cork the outqueue so queued chunks are really queued. */
-int sctp_outq_uncork(struct sctp_outq *q, gfp_t gfp)
+void sctp_outq_uncork(struct sctp_outq *q, gfp_t gfp)
 {
  if (q->cork)
   q->cork = 0;
 
- return sctp_outq_flush(q, 0, gfp);
+ sctp_outq_flush(q, 0, gfp);
 }
 
 
@@ -773,7 +770,7 @@ int sctp_outq_uncork(struct sctp_outq *q, gfp_t gfp)
  * locking concerns must be made.  Today we use the sock lock to protect
  * this function.
  */
-static int sctp_outq_flush(struct sctp_outq *q, int rtx_timeout, gfp_t gfp)
+static void sctp_outq_flush(struct sctp_outq *q, int rtx_timeout, gfp_t gfp)
 {
  struct sctp_packet *packet;
  struct sctp_packet singleton;
@@ -898,7 +895,7 @@ static int sctp_outq_flush(struct sctp_outq *q, int rtx_timeout, gfp_t gfp)
    error = sctp_packet_transmit(&singleton, gfp);
    if (error < 0) {
     asoc->base.sk->sk_err = -error;
-    return 0;
+    return;
    }
    break;
 
@@ -1183,8 +1180,6 @@ sctp_flush_out:
   /* Clear the burst limited state, if any */
   sctp_transport_burst_reset(t);
  }
-
- return 0;
 }
 
 /* Update unack_data based on the incoming SACK chunk */
diff --git a/net/sctp/sm_sideeffect.c b/net/sctp/sm_sideeffect.c
index ff0040b..aac129d 100644
--- a/net/sctp/sm_sideeffect.c
+++ b/net/sctp/sm_sideeffect.c
@@ -1428,8 +1428,7 @@ static int sctp_cmd_interpreter(sctp_event_t event_type,
     local_cork = 1;
    }
    /* Send a chunk to our peer.  */
-   error = sctp_outq_tail(&asoc->outqueue, cmd->obj.chunk,
-            gfp);
+   sctp_outq_tail(&asoc->outqueue, cmd->obj.chunk, gfp);
    break;
 
   case SCTP_CMD_SEND_PKT:
@@ -1683,7 +1682,7 @@ static int sctp_cmd_interpreter(sctp_event_t event_type,
   case SCTP_CMD_FORCE_PRIM_RETRAN:
    t = asoc->peer.retran_path;
    asoc->peer.retran_path = asoc->peer.primary_path;
-   error = sctp_outq_uncork(&asoc->outqueue, gfp);
+   sctp_outq_uncork(&asoc->outqueue, gfp);
    local_cork = 0;
    asoc->peer.retran_path = t;
    break;
@@ -1740,9 +1739,9 @@ out:
   */
  if (asoc && SCTP_EVENT_T_CHUNK == event_type && chunk) {
   if (chunk->end_of_packet || chunk->singleton)
-   error = sctp_outq_uncork(&asoc->outqueue, gfp);
+   sctp_outq_uncork(&asoc->outqueue, gfp);
  } else if (local_cork)
-  error = sctp_outq_uncork(&asoc->outqueue, gfp);
+  sctp_outq_uncork(&asoc->outqueue, gfp);
 
  if (sp->data_ready_signalled)
   sp->data_ready_signalled = 0;
-- 
1.7.1