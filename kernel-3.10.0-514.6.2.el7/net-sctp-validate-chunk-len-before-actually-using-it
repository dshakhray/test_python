From fbd324964c5ea71b0f77bfef4b5572914eb45359 Mon Sep 17 00:00:00 2001
From: Hangbin Liu <haliu@redhat.com>
Date: Fri, 2 Dec 2016 04:07:05 -0500
Subject: [net] sctp: validate chunk len before actually using it

Message-id: <1480651625-25420-4-git-send-email-haliu@redhat.com>
Patchwork-id: 160961
O-Subject: [RHEL7.4 net PATCH 3/3] sctp: validate chunk len before actually using it
Bugzilla: 1399459
Z-Bugzilla: 1399458
CVE: CVE-2016-9555
RH-Acked-by: Xin Long <lxin@redhat.com>
RH-Acked-by: Sabrina Dubroca <sdubroca@redhat.com>
RH-Acked-by: Marcelo Leitner <mleitner@redhat.com>
RH-Acked-by: Davide Caratti <dcaratti@redhat.com>

Bugzilla: https://bugzilla.redhat.com/show_bug.cgi?id=1399459
Brew: https://brewweb.devel.redhat.com/taskinfo?taskID=12187771
Upstream Status: net.git commit bf911e985d6b

commit bf911e985d6bbaa328c20c3e05f4eb03de11fdd6
Author: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
Date:   Tue Oct 25 14:27:39 2016 -0200

    sctp: validate chunk len before actually using it

    Andrey Konovalov reported that KASAN detected that SCTP was using a slab
    beyond the boundaries. It was caused because when handling out of the
    blue packets in function sctp_sf_ootb() it was checking the chunk len
    only after already processing the first chunk, validating only for the
    2nd and subsequent ones.

    The fix is to just move the check upwards so it's also validated for the
    1st chunk.

    Reported-by: Andrey Konovalov <andreyknvl@google.com>
    Tested-by: Andrey Konovalov <andreyknvl@google.com>
    Signed-off-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
    Reviewed-by: Xin Long <lucien.xin@gmail.com>
    Acked-by: Neil Horman <nhorman@tuxdriver.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

Signed-off-by: Hangbin Liu <haliu@redhat.com>
Signed-off-by: Frantisek Hrbata <fhrbata@hrbata.com>

diff --git a/net/sctp/sm_statefuns.c b/net/sctp/sm_statefuns.c
index e4df313..5d90fed 100644
--- a/net/sctp/sm_statefuns.c
+++ b/net/sctp/sm_statefuns.c
@@ -3429,6 +3429,12 @@ sctp_disposition_t sctp_sf_ootb(struct net *net,
    return sctp_sf_violation_chunklen(net, ep, asoc, type, arg,
         commands);
 
+  /* Report violation if chunk len overflows */
+  ch_end = ((__u8 *)ch) + SCTP_PAD4(ntohs(ch->length));
+  if (ch_end > skb_tail_pointer(skb))
+   return sctp_sf_violation_chunklen(net, ep, asoc, type, arg,
+        commands);
+
   /* Now that we know we at least have a chunk header,
    * do things that are type appropriate.
    */
@@ -3460,12 +3466,6 @@ sctp_disposition_t sctp_sf_ootb(struct net *net,
    }
   }
 
-  /* Report violation if chunk len overflows */
-  ch_end = ((__u8 *)ch) + SCTP_PAD4(ntohs(ch->length));
-  if (ch_end > skb_tail_pointer(skb))
-   return sctp_sf_violation_chunklen(net, ep, asoc, type, arg,
-        commands);
-
   ch = (sctp_chunkhdr_t *) ch_end;
  } while (ch_end < skb_tail_pointer(skb));
 
-- 
1.7.1