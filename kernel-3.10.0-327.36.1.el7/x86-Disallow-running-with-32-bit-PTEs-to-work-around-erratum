From c12421cd10ea2115c33d9976eada1b2d27f71efd Mon Sep 17 00:00:00 2001
From: Larry Woodman <lwoodman@redhat.com>
Date: Mon, 25 Jul 2016 15:16:14 +0200
Subject: [x86] Disallow running with 32-bit PTEs to work around erratum

Message-id: <1469459775-5464-4-git-send-email-lwoodman@redhat.com>
Patchwork-id: 155922
O-Subject: [RHEL7.3 PATCH 3/4] Disallow running with 32-bit PTEs to work around erratum
Bugzilla: 1347159
Z-Bugzilla: 1363860
RH-Acked-by: Jeremy McNicoll <jmcnicol@redhat.com>
RH-Acked-by: Rafael Aquini <aquini@redhat.com>

commit e4a84be6f05eab4778732d799f63b3cd15427885
 Author: Dave Hansen <dave.hansen@linux.intel.com>
 Date:   Thu Jul 7 17:19:14 2016 -0700

    x86/mm: Disallow running with 32-bit PTEs to work around erratum

    The Intel(R) Xeon Phi(TM) Processor x200 Family (codename: Knights
    Landing) has an erratum where a processor thread setting the Accessed
    or Dirty bits may not do so atomically against its checks for the
    Present bit.  This may cause a thread (which is about to page fault)
    to set A and/or D, even though the Present bit had already been
    atomically cleared.

    These bits are truly "stray".  In the case of the Dirty bit, the
    thread associated with the stray set was *not* allowed to write to
    the page.  This means that we do not have to launder the bit(s); we
    can simply ignore them.

    If the PTE is used for storing a swap index or a NUMA migration index,
    the A bit could be misinterpreted as part of the swap type.  The stray
    bits being set cause a software-cleared PTE to be interpreted as a
    swap entry.  In some cases (like when the swap index ends up being
    for a non-existent swapfile), the kernel detects the stray value
    and WARN()s about it, but there is no guarantee that the kernel can
    always detect it.

    When we have 64-bit PTEs (64-bit mode or 32-bit PAE), we were able
    to move the swap PTE format around to avoid these troublesome bits.
    But, 32-bit non-PAE is tight on bits.  So, disallow it from running
    on this hardware.  I can't imagine anyone wanting to run 32-bit
    non-highmem kernels on this hardware, but disallowing them from
    running entirely is surely the safe thing to do.

    Signed-off-by: Dave Hansen <dave.hansen@linux.intel.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: Dave Hansen <dave@sr71.net>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Josh Poimboeuf <jpoimboe@redhat.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Luis R. Rodriguez <mcgrof@suse.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Toshi Kani <toshi.kani@hp.com>
    Cc: dave.hansen@intel.com
    Cc: linux-mm@kvack.org
    Cc: mhocko@suse.com
    Link: http://lkml.kernel.org/r/20160708001914.D0B50110@viggo.jf.intel.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

Signed-off-by: Alexander Gordeev <agordeev@redhat.com>

diff --git a/arch/x86/boot/boot.h b/arch/x86/boot/boot.h
index ca13621..c25ff94 100644
--- a/arch/x86/boot/boot.h
+++ b/arch/x86/boot/boot.h
@@ -298,11 +298,13 @@ static inline int cmdline_find_option_bool(const char *option)
 /* cpu.c, cpucheck.c */
 struct cpu_features {
  int level;  /* Family, or 64 for x86-64 */
+ int family;  /* Family, always */
  int model;
  u32 flags[NCAPINTS];
 };
 extern struct cpu_features cpu;
 int check_cpu(int *cpu_level_ptr, int *req_level_ptr, u32 **err_flags_ptr);
+int check_knl_erratum(void);
 int validate_cpu(void);
 
 /* early_serial_console.c */
diff --git a/arch/x86/boot/cpu.c b/arch/x86/boot/cpu.c
index 6ec6bb6..ae98089 100644
--- a/arch/x86/boot/cpu.c
+++ b/arch/x86/boot/cpu.c
@@ -79,6 +79,8 @@ int validate_cpu(void)
   }
   putchar('\n');
   return -1;
+ } else if (check_knl_erratum()) {
+  return -1;
  } else {
   return 0;
  }
diff --git a/arch/x86/boot/cpucheck.c b/arch/x86/boot/cpucheck.c
index f1c2d75..00999f0 100644
--- a/arch/x86/boot/cpucheck.c
+++ b/arch/x86/boot/cpucheck.c
@@ -24,6 +24,7 @@
 # include "boot.h"
 #endif
 #include <linux/types.h>
+#include <asm/intel-family.h>
 #include <asm/processor-flags.h>
 #include <asm/required-features.h>
 #include <asm/msr-index.h>
@@ -70,6 +71,14 @@ static int is_transmeta(void)
         cpu_vendor[2] == A32('M', 'x', '8', '6');
 }
 
+static int is_intel(void)
+{
+ return cpu_vendor[0] == A32('G', 'e', 'n', 'u') &&
+  cpu_vendor[1] == A32('i', 'n', 'e', 'I') &&
+  cpu_vendor[2] == A32('n', 't', 'e', 'l');
+}
+
+
 static int has_fpu(void)
 {
  u16 fcw = -1, fsw = -1;
@@ -132,6 +141,7 @@ static void get_flags(void)
        : "a" (0x00000001)
        : "ebx");
    cpu.level = (tfms >> 8) & 15;
+   cpu.family = cpu.level;
    cpu.model = (tfms >> 4) & 15;
    if (cpu.level >= 6)
     cpu.model += ((tfms >> 16) & 0xf) << 4;
@@ -166,6 +176,8 @@ static int check_flags(void)
   if (err_flags[i])
    err |= 1 << i;
  }
+ if (!err)
+  err = check_knl_erratum();
 
  return err;
 }
@@ -251,3 +263,33 @@ int check_cpu(int *cpu_level_ptr, int *req_level_ptr, u32 **err_flags_ptr)
 
  return (cpu.level < req_level || err) ? -1 : 0;
 }
+
+int check_knl_erratum(void)
+{
+ /*
+  * First check for the affected model/family:
+  */
+ if (!is_intel() ||
+     cpu.family != 6 ||
+     cpu.model != INTEL_FAM6_XEON_PHI_KNL)
+  return 0;
+
+ /*
+  * This erratum affects the Accessed/Dirty bits, and can
+  * cause stray bits to be set in !Present PTEs.  We have
+  * enough bits in our 64-bit PTEs (which we have on real
+  * 64-bit mode or PAE) to avoid using these troublesome
+  * bits.  But, we do not have enough space in our 32-bit
+  * PTEs.  So, refuse to run on 32-bit non-PAE kernels.
+  */
+ if (IS_ENABLED(CONFIG_X86_64) || IS_ENABLED(CONFIG_X86_PAE))
+  return 0;
+
+ puts("This 32-bit kernel can not run on this Xeon Phi x200\n"
+      "processor due to a processor erratum.  Use a 64-bit\n"
+      "kernel, or enable PAE in this 32-bit kernel.\n\n");
+
+ return -1;
+}
+
+
-- 
1.7.1