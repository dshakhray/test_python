From 1a808de4310a2b08b92c5a0cdf47e8a4f12b2c0c Mon Sep 17 00:00:00 2001
From: Alexander Gordeev <agordeev@redhat.com>
Date: Mon, 15 Aug 2016 10:01:43 +0200
Subject: [x86] Move swap offset/type up in PTE to work around erratum

Message-id: <d500bf7298678e12f09d93ed66b085c3c74c5630.1471249063.git.agordeev@redhat.com>
Patchwork-id: 156833
O-Subject: [RHEL7.2.z PATCH BZ 1363860 1/4] x86: Move swap offset/type up in PTE to work around erratum
Bugzilla: 1347159
Z-Bugzilla: 1363860
RH-Acked-by: Prarit Bhargava <prarit@redhat.com>
RH-Acked-by: Larry Woodman <lwoodman@redhat.com>

This is a backport of 7.3 commit cede501b to 7.2.z
(http://patchwork.lab.bos.redhat.com/patch/155921)

The original Y-stream patch caused a failure of testcase
remap_file_pages01 and filed as BZ 1365475.

Dave Hansen from Intel provided a fix on top of -327.34.1
(https://bugzilla.redhat.com/show_bug.cgi?id=1363860#c14)

This patch is a merge of Dave Hansen's fix and 7.3 commit
cede501b (http://patchwork.lab.bos.redhat.com/patch/155921)

Bugzilla: 1363860 1365475

Testing: Artem Savkov <asavkov@redhat.com> confirmed
remap_file_pages01 testcase goes away with this patch

Description:
Mainline does not have real support for remap_file_pages()
(nonlinear memory) any more.  We now just fake it with linear
VMAs on top of the old API.  But, RHEL7 has the original code,
which our "KNL4 erratum" fix failed to patch.

RHEL7 marks non-present nonlinear PTEs with a special bit to
differentiate them from regular PTEs.  Unforunately, that bit
happens to be _PAGE_DIRTY, which can get set as a result of the
"KNL4 erratum".

A nonlinear PTE for the first page in a file has this value:
0x0000000000000040, which happens to be one of the values that
can be erroneously set on cleared PTEs with the erratum.

We need to find another bit.

On 32-bit non-PAE, we have no free bits, and the code is in sorry
shape anyway.  We do not have the erratum there, so just do not
move the bit around there.  (Not sure if this even matters for
RHEL7).

Fortunatley, we have lots of bits on 64-bit.  Just move it one
up from bit 6 to bit 7 (_PAGE_BIT_PSE).

I think the "#if _PAGE_BIT_FILE < _PAGE_BIT_PROTNONE" check was
dead code.  But, preserve it and add an error just in case.  Also,
open-code the SWP_TYPE_BITS just like we do in mainline.  The
Derivation from _PAGE_BIT_FILE and _PAGE_BIT_PRESENT was probably
another bug, and was confusing anyway.

So the PTE bits now look like this:

     bitnrs: |     ...            | 11| 10|  9|8|7|6|5| 4| 3|2|1|0|
     names:  |     ...            |SW3|SW2|SW1|G|L|D|A|CD|WT|U|W|P|
     swppte: | OFFSET (14-63)  |  TYPE (9-13) |0|X|X|X| X| X|X|X|0|
     ptenon: | PHYS ADDR (12-63)  |  X|  X|  X|1|X|?|X| X| X|X|X|0|
     nonlin: |    OFFSET (12-63)  |  0|  0|  0|0|0|1|0| 0| 0|0|0|0| <- before
     nonlin: |    OFFSET (12-63)  |  0|  0|  0|0|1|0|0| 0| 0|0|0|0| <- after

I am not 100% if we ever have PROT_NONE nonlinear ptes.  But, if we
do, this arrangement will support it.
---
 arch/x86/include/asm/pgtable_64.h    |   34 ++++++++++++++++++++++++----------
 arch/x86/include/asm/pgtable_types.h |    5 +++++
 2 files changed, 29 insertions(+), 10 deletions(-)

Signed-off-by: Alexander Gordeev <agordeev@redhat.com>

diff --git a/arch/x86/include/asm/pgtable_64.h b/arch/x86/include/asm/pgtable_64.h
index cdf76bf..c0060b6 100644
--- a/arch/x86/include/asm/pgtable_64.h
+++ b/arch/x86/include/asm/pgtable_64.h
@@ -152,22 +152,36 @@ static inline int pgd_large(pgd_t pgd) { return 0; }
 #define pte_unmap(pte) ((void)(pte))/* NOP */
 
 /* Encode and de-code a swap entry */
-#if _PAGE_BIT_FILE < _PAGE_BIT_PROTNONE
-#define SWP_TYPE_BITS (_PAGE_BIT_FILE - _PAGE_BIT_PRESENT - 1)
-#define SWP_OFFSET_SHIFT (_PAGE_BIT_PROTNONE + 1)
-#else
-#define SWP_TYPE_BITS (_PAGE_BIT_PROTNONE - _PAGE_BIT_PRESENT - 1)
-#define SWP_OFFSET_SHIFT (_PAGE_BIT_FILE + 1)
+#if _PAGE_BIT_FILE > _PAGE_BIT_PROTNONE
+#error unsupported PTE bit arrangement
 #endif
 
+/*
+ * Encode and de-code a swap entry
+ *
+ * |     ...            | 11| 10|  9|8|7|6|5| 4| 3|2|1|0| <- bit number
+ * |     ...            |SW3|SW2|SW1|G|L|D|A|CD|WT|U|W|P| <- bit names
+ * | OFFSET (14->63) | TYPE (9-13)  |0|X|X|X| X| X|X|X|0| <- swp entry
+ *
+ * G (8) is aliased and used as a PROT_NONE indicator for
+ * !present ptes.  We need to start storing swap entries above
+ * there.  We also need to avoid using A and D because of an
+ * erratum where they can be incorrectly set by hardware on
+ * non-present PTEs.
+ */
+#define SWP_TYPE_FIRST_BIT (_PAGE_BIT_PROTNONE + 1)
+#define SWP_TYPE_BITS 5
+/* Place the offset above the type: */
+#define SWP_OFFSET_FIRST_BIT (SWP_TYPE_FIRST_BIT + SWP_TYPE_BITS + 1)
+
 #define MAX_SWAPFILES_CHECK() BUILD_BUG_ON(MAX_SWAPFILES_SHIFT > SWP_TYPE_BITS)
 
-#define __swp_type(x)   (((x).val >> (_PAGE_BIT_PRESENT + 1)) \
+#define __swp_type(x)   (((x).val >> (SWP_TYPE_FIRST_BIT)) \
       & ((1U << SWP_TYPE_BITS) - 1))
-#define __swp_offset(x)   ((x).val >> SWP_OFFSET_SHIFT)
+#define __swp_offset(x)   ((x).val >> SWP_OFFSET_FIRST_BIT)
 #define __swp_entry(type, offset) ((swp_entry_t) { \
-      ((type) << (_PAGE_BIT_PRESENT + 1)) \
-      | ((offset) << SWP_OFFSET_SHIFT) })
+      ((type) << (SWP_TYPE_FIRST_BIT)) \
+      | ((offset) << SWP_OFFSET_FIRST_BIT) })
 #define __pte_to_swp_entry(pte)  ((swp_entry_t) { pte_val((pte)) })
 #define __swp_entry_to_pte(x)  ((pte_t) { .pte = (x).val })
 
diff --git a/arch/x86/include/asm/pgtable_types.h b/arch/x86/include/asm/pgtable_types.h
index 35216ae..06c8dad 100644
--- a/arch/x86/include/asm/pgtable_types.h
+++ b/arch/x86/include/asm/pgtable_types.h
@@ -30,7 +30,12 @@
 /* - if the user mapped it with PROT_NONE; pte_present gives true */
 #define _PAGE_BIT_PROTNONE _PAGE_BIT_GLOBAL
 /* - set: nonlinear file mapping, saved PTE; unset:swap */
+#if defined(CONFIG_X86_64) || defined(CONFIG_X86_PAE)
+/* Pick a bit unaffected by the "KNL4 erratum": */
+#define _PAGE_BIT_FILE  _PAGE_BIT_PSE
+#else
 #define _PAGE_BIT_FILE  _PAGE_BIT_DIRTY
+#endif
 
 #define _PAGE_PRESENT (_AT(pteval_t, 1) << _PAGE_BIT_PRESENT)
 #define _PAGE_RW (_AT(pteval_t, 1) << _PAGE_BIT_RW)
-- 
1.7.1