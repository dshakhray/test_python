From 9a5a052da913bb5cf1328219740e677bc6b29e4e Mon Sep 17 00:00:00 2001
From: Larry Woodman <lwoodman@redhat.com>
Date: Mon, 25 Jul 2016 15:16:15 +0200
Subject: [x86] Use pte_none() to test for empty PTE

Message-id: <1469459775-5464-5-git-send-email-lwoodman@redhat.com>
Patchwork-id: 155924
O-Subject: [RHEL7.3 PATCH 4/4] Use pte_none() to test for empty PTE
Bugzilla: 1347159
Z-Bugzilla: 1363860
RH-Acked-by: Jeremy McNicoll <jmcnicol@redhat.com>
RH-Acked-by: Rafael Aquini <aquini@redhat.com>

commit dcb32d9913b7ed527b135a7e221f8d14b67bb952
 Author: Dave Hansen <dave.hansen@linux.intel.com>
 Date:   Thu Jul 7 17:19:15 2016 -0700

    x86/mm: Use pte_none() to test for empty PTE

    The page table manipulation code seems to have grown a couple of
    sites that are looking for empty PTEs.  Just in case one of these
    entries got a stray bit set, use pte_none() instead of checking
    for a zero pte_val().

    The use pte_same() makes me a bit nervous.  If we were doing a
    pte_same() check against two cleared entries and one of them had
    a stray bit set, it might fail the pte_same() check.  But, I
    don't think we ever _do_ pte_same() for cleared entries.  It is
    almost entirely used for checking for races in fault-in paths.

    Signed-off-by: Dave Hansen <dave.hansen@linux.intel.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: Dave Hansen <dave@sr71.net>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Josh Poimboeuf <jpoimboe@redhat.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Luis R. Rodriguez <mcgrof@suse.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Toshi Kani <toshi.kani@hp.com>
    Cc: dave.hansen@intel.com
    Cc: linux-mm@kvack.org
    Cc: mhocko@suse.com
    Link: http://lkml.kernel.org/r/20160708001915.813703D9@viggo.jf.intel.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

Signed-off-by: Alexander Gordeev <agordeev@redhat.com>

diff --git a/arch/x86/mm/init_64.c b/arch/x86/mm/init_64.c
index cb28741..0a4984d 100644
--- a/arch/x86/mm/init_64.c
+++ b/arch/x86/mm/init_64.c
@@ -436,7 +436,7 @@ phys_pte_init(pte_t *pte_page, unsigned long addr, unsigned long end,
    * pagetable pages as RO. So assume someone who pre-setup
    * these mappings are more intelligent.
    */
-  if (pte_val(*pte)) {
+  if (!pte_none(*pte)) {
    if (!after_bootmem)
     pages++;
    continue;
@@ -478,7 +478,7 @@ phys_pmd_init(pmd_t *pmd_page, unsigned long address, unsigned long end,
    continue;
   }
 
-  if (pmd_val(*pmd)) {
+  if (!pmd_none(*pmd)) {
    if (!pmd_large(*pmd)) {
     spin_lock(&init_mm.page_table_lock);
     pte = (pte_t *)pmd_page_vaddr(*pmd);
@@ -552,7 +552,7 @@ phys_pud_init(pud_t *pud_page, unsigned long addr, unsigned long end,
    continue;
   }
 
-  if (pud_val(*pud)) {
+  if (!pud_none(*pud)) {
    if (!pud_large(*pud)) {
     pmd = pmd_offset(pud, 0);
     last_map_addr = phys_pmd_init(pmd, addr, end,
@@ -749,7 +749,7 @@ static void __meminit free_pte_table(pte_t *pte_start, pmd_t *pmd)
 
  for (i = 0; i < PTRS_PER_PTE; i++) {
   pte = pte_start + i;
-  if (pte_val(*pte))
+  if (!pte_none(*pte))
    return;
  }
 
@@ -767,7 +767,7 @@ static void __meminit free_pmd_table(pmd_t *pmd_start, pud_t *pud)
 
  for (i = 0; i < PTRS_PER_PMD; i++) {
   pmd = pmd_start + i;
-  if (pmd_val(*pmd))
+  if (!pmd_none(*pmd))
    return;
  }
 
@@ -786,7 +786,7 @@ static bool __meminit free_pud_table(pud_t *pud_start, pgd_t *pgd)
 
  for (i = 0; i < PTRS_PER_PUD; i++) {
   pud = pud_start + i;
-  if (pud_val(*pud))
+  if (!pud_none(*pud))
    return false;
  }
 
diff --git a/arch/x86/mm/pageattr.c b/arch/x86/mm/pageattr.c
index 6d235d9..dea8544 100644
--- a/arch/x86/mm/pageattr.c
+++ b/arch/x86/mm/pageattr.c
@@ -1107,7 +1107,7 @@ repeat:
   return __cpa_process_fault(cpa, address, primary);
 
  old_pte = *kpte;
- if (!pte_val(old_pte))
+ if (pte_none(old_pte))
   return __cpa_process_fault(cpa, address, primary);
 
  if (level == PG_LEVEL_4K) {
diff --git a/arch/x86/mm/pgtable_32.c b/arch/x86/mm/pgtable_32.c
index a69bcb8..56779b5 100644
--- a/arch/x86/mm/pgtable_32.c
+++ b/arch/x86/mm/pgtable_32.c
@@ -47,7 +47,7 @@ void set_pte_vaddr(unsigned long vaddr, pte_t pteval)
   return;
  }
  pte = pte_offset_kernel(pmd, vaddr);
- if (pte_val(pteval))
+ if (!pte_none(pteval))
   set_pte_at(&init_mm, vaddr, pte, pteval);
  else
   pte_clear(&init_mm, vaddr, pte);
-- 
1.7.1