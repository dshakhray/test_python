From c93b047bb729e846f05125e8abfee29d3dd2c1ec Mon Sep 17 00:00:00 2001
From: Jaroslav Kysela <jkysela@redhat.com>
Date: Wed, 3 Sep 2014 07:25:10 -0400
Subject: [alsa] usb-audio: Use standard printk helpers

Message-id: <140972823573-194-patchset-jkysela@redhat.com>
Patchwork-id: 90894
O-Subject: [RHEL 7.1 PATCH 193/442] ALSA: usb-audio: Use standard printk helpers
Bugzilla: 1112200
RH-Acked-by: John Linville <linville@redhat.com>
RH-Acked-by: Prarit Bhargava <prarit@redhat.com>
RH-Acked-by: Ivan Vecera <ivecera@redhat.com>

Convert with dev_err() and co from snd_printk(), etc.
As there are too deep indirections (e.g. ep->chip->dev->dev),
a few new local macros, usb_audio_err() & co, are introduced.

Also, the device numbers in some messages are dropped, as they are
shown in the prefix automatically.

Signed-off-by: Takashi Iwai <tiwai@suse.de>

(picked from kernel: 0ba41d917eeb87f608cf147f870ff2f4c1056bab)
rhbz#1112200
Signed-off-by: Jaroslav Kysela <jkysela@redhat.com>
---

Signed-off-by: Jarod Wilson <jarod@redhat.com>

diff --git a/sound/usb/card.c b/sound/usb/card.c
index 0cfdc2d..893d5a1 100644
--- a/sound/usb/card.c
+++ b/sound/usb/card.c
@@ -139,8 +139,8 @@ static int snd_usb_create_stream(struct snd_usb_audio *chip, int ctrlif, int int
  struct usb_interface *iface = usb_ifnum_to_if(dev, interface);
 
  if (!iface) {
-  snd_printk(KERN_ERR "%d:%u:%d : does not exist\n",
-      dev->devnum, ctrlif, interface);
+  dev_err(&dev->dev, "%u:%d : does not exist\n",
+   ctrlif, interface);
   return -EINVAL;
  }
 
@@ -165,8 +165,8 @@ static int snd_usb_create_stream(struct snd_usb_audio *chip, int ctrlif, int int
  }
 
  if (usb_interface_claimed(iface)) {
-  snd_printdd(KERN_INFO "%d:%d:%d: skipping, already claimed\n",
-      dev->devnum, ctrlif, interface);
+  dev_dbg(&dev->dev, "%d:%d: skipping, already claimed\n",
+   ctrlif, interface);
   return -EINVAL;
  }
 
@@ -176,8 +176,9 @@ static int snd_usb_create_stream(struct snd_usb_audio *chip, int ctrlif, int int
   int err = snd_usbmidi_create(chip->card, iface,
           &chip->midi_list, NULL);
   if (err < 0) {
-   snd_printk(KERN_ERR "%d:%u:%d: cannot create sequencer device\n",
-      dev->devnum, ctrlif, interface);
+   dev_err(&dev->dev,
+    "%u:%d: cannot create sequencer device\n",
+    ctrlif, interface);
    return -EINVAL;
   }
   usb_driver_claim_interface(&usb_audio_driver, iface, (void *)-1L);
@@ -188,14 +189,15 @@ static int snd_usb_create_stream(struct snd_usb_audio *chip, int ctrlif, int int
  if ((altsd->bInterfaceClass != USB_CLASS_AUDIO &&
       altsd->bInterfaceClass != USB_CLASS_VENDOR_SPEC) ||
      altsd->bInterfaceSubClass != USB_SUBCLASS_AUDIOSTREAMING) {
-  snd_printdd(KERN_ERR "%d:%u:%d: skipping non-supported interface %d\n",
-     dev->devnum, ctrlif, interface, altsd->bInterfaceClass);
+  dev_dbg(&dev->dev,
+   "%u:%d: skipping non-supported interface %d\n",
+   ctrlif, interface, altsd->bInterfaceClass);
   /* skip non-supported classes */
   return -EINVAL;
  }
 
  if (snd_usb_get_speed(dev) == USB_SPEED_LOW) {
-  snd_printk(KERN_ERR "low speed audio streaming not supported\n");
+  dev_err(&dev->dev, "low speed audio streaming not supported\n");
   return -EINVAL;
  }
 
@@ -228,26 +230,27 @@ static int snd_usb_create_streams(struct snd_usb_audio *chip, int ctrlif)
  protocol = altsd->bInterfaceProtocol;
 
  if (!control_header) {
-  snd_printk(KERN_ERR "cannot find UAC_HEADER\n");
+  dev_err(&dev->dev, "cannot find UAC_HEADER\n");
   return -EINVAL;
  }
 
  switch (protocol) {
  default:
-  snd_printdd(KERN_WARNING "unknown interface protocol %#02x, assuming v1\n",
-       protocol);
+  dev_warn(&dev->dev,
+    "unknown interface protocol %#02x, assuming v1\n",
+    protocol);
   /* fall through */
 
  case UAC_VERSION_1: {
   struct uac1_ac_header_descriptor *h1 = control_header;
 
   if (!h1->bInCollection) {
-   snd_printk(KERN_INFO "skipping empty audio interface (v1)\n");
+   dev_info(&dev->dev, "skipping empty audio interface (v1)\n");
    return -EINVAL;
   }
 
   if (h1->bLength < sizeof(*h1) + h1->bInCollection) {
-   snd_printk(KERN_ERR "invalid UAC_HEADER (v1)\n");
+   dev_err(&dev->dev, "invalid UAC_HEADER (v1)\n");
    return -EINVAL;
   }
 
@@ -277,7 +280,7 @@ static int snd_usb_create_streams(struct snd_usb_audio *chip, int ctrlif)
   }
 
   if (!assoc) {
-   snd_printk(KERN_ERR "Audio class v2 interfaces need an interface association\n");
+   dev_err(&dev->dev, "Audio class v2 interfaces need an interface association\n");
    return -EINVAL;
   }
 
@@ -351,14 +354,14 @@ static int snd_usb_audio_create(struct usb_interface *intf,
  case USB_SPEED_SUPER:
   break;
  default:
-  snd_printk(KERN_ERR "unknown device speed %d\n", snd_usb_get_speed(dev));
+  dev_err(&dev->dev, "unknown device speed %d\n", snd_usb_get_speed(dev));
   return -ENXIO;
  }
 
  err = snd_card_new(&intf->dev, index[idx], id[idx], THIS_MODULE,
       0, &card);
  if (err < 0) {
-  snd_printk(KERN_ERR "cannot create card instance %d\n", idx);
+  dev_err(&dev->dev, "cannot create card instance %d\n", idx);
   return err;
  }
 
@@ -499,7 +502,7 @@ snd_usb_audio_probe(struct usb_device *dev,
  for (i = 0; i < SNDRV_CARDS; i++) {
   if (usb_chip[i] && usb_chip[i]->dev == dev) {
    if (usb_chip[i]->shutdown) {
-    snd_printk(KERN_ERR "USB device is in the shutdown state, cannot create a card instance\n");
+    dev_err(&dev->dev, "USB device is in the shutdown state, cannot create a card instance\n");
     goto __error;
    }
    chip = usb_chip[i];
@@ -523,7 +526,7 @@ snd_usb_audio_probe(struct usb_device *dev,
     break;
    }
   if (!chip) {
-   printk(KERN_ERR "no available usb audio device\n");
+   dev_err(&dev->dev, "no available usb audio device\n");
    goto __error;
   }
  }
diff --git a/sound/usb/clock.c b/sound/usb/clock.c
index 86f80c6..03fed66 100644
--- a/sound/usb/clock.c
+++ b/sound/usb/clock.c
@@ -115,9 +115,9 @@ static int uac_clock_selector_set_val(struct snd_usb_audio *chip, int selector_i
   return ret;
 
  if (ret != sizeof(pin)) {
-  snd_printk(KERN_ERR
-   "usb-audio:%d: setting selector (id %d) unexpected length %d\n",
-   chip->dev->devnum, selector_id, ret);
+  usb_audio_err(chip,
+   "setting selector (id %d) unexpected length %d\n",
+   selector_id, ret);
   return -EINVAL;
  }
 
@@ -126,9 +126,9 @@ static int uac_clock_selector_set_val(struct snd_usb_audio *chip, int selector_i
   return ret;
 
  if (ret != pin) {
-  snd_printk(KERN_ERR
-   "usb-audio:%d: setting selector (id %d) to %x failed (current: %d)\n",
-   chip->dev->devnum, selector_id, pin, ret);
+  usb_audio_err(chip,
+   "setting selector (id %d) to %x failed (current: %d)\n",
+   selector_id, pin, ret);
   return -EINVAL;
  }
 
@@ -158,7 +158,8 @@ static bool uac_clock_source_is_valid(struct snd_usb_audio *chip, int source_id)
          &data, sizeof(data));
 
  if (err < 0) {
-  snd_printk(KERN_WARNING "%s(): cannot get clock validity for id %d\n",
+  dev_warn(&dev->dev,
+    "%s(): cannot get clock validity for id %d\n",
       __func__, source_id);
   return 0;
  }
@@ -177,9 +178,9 @@ static int __uac_clock_find_source(struct snd_usb_audio *chip,
  entity_id &= 0xff;
 
  if (test_and_set_bit(entity_id, visited)) {
-  snd_printk(KERN_WARNING
-   "%s(): recursive clock topology detected, id %d.\n",
-   __func__, entity_id);
+  usb_audio_warn(chip,
+    "%s(): recursive clock topology detected, id %d.\n",
+    __func__, entity_id);
   return -EINVAL;
  }
 
@@ -188,8 +189,9 @@ static int __uac_clock_find_source(struct snd_usb_audio *chip,
  if (source) {
   entity_id = source->bClockID;
   if (validate && !uac_clock_source_is_valid(chip, entity_id)) {
-   snd_printk(KERN_ERR "usb-audio:%d: clock source %d is not valid, cannot use\n",
-       chip->dev->devnum, entity_id);
+   usb_audio_err(chip,
+    "clock source %d is not valid, cannot use\n",
+    entity_id);
    return -ENXIO;
   }
   return entity_id;
@@ -208,7 +210,7 @@ static int __uac_clock_find_source(struct snd_usb_audio *chip,
   /* Selector values are one-based */
 
   if (ret > selector->bNrInPins || ret < 1) {
-   snd_printk(KERN_ERR
+   usb_audio_err(chip,
     "%s(): selector reported illegal value, id %d, ret %d\n",
     __func__, selector->bClockID, ret);
 
@@ -237,9 +239,9 @@ static int __uac_clock_find_source(struct snd_usb_audio *chip,
    if (err < 0)
     continue;
 
-   snd_printk(KERN_INFO
-    "usb-audio:%d: found and selected valid clock source %d\n",
-    chip->dev->devnum, ret);
+   usb_audio_info(chip,
+     "found and selected valid clock source %d\n",
+     ret);
    return ret;
   }
 
@@ -296,8 +298,8 @@ static int set_sample_rate_v1(struct snd_usb_audio *chip, int iface,
        USB_TYPE_CLASS | USB_RECIP_ENDPOINT | USB_DIR_OUT,
        UAC_EP_CS_ATTR_SAMPLE_RATE << 8, ep,
        data, sizeof(data))) < 0) {
-  snd_printk(KERN_ERR "%d:%d:%d: cannot set freq %d to ep %#x\n",
-      dev->devnum, iface, fmt->altsetting, rate, ep);
+  dev_err(&dev->dev, "%d:%d: cannot set freq %d to ep %#x\n",
+   iface, fmt->altsetting, rate, ep);
   return err;
  }
 
@@ -305,14 +307,14 @@ static int set_sample_rate_v1(struct snd_usb_audio *chip, int iface,
        USB_TYPE_CLASS | USB_RECIP_ENDPOINT | USB_DIR_IN,
        UAC_EP_CS_ATTR_SAMPLE_RATE << 8, ep,
        data, sizeof(data))) < 0) {
-  snd_printk(KERN_WARNING "%d:%d:%d: cannot get freq at ep %#x\n",
-      dev->devnum, iface, fmt->altsetting, ep);
+  dev_err(&dev->dev, "%d:%d: cannot get freq at ep %#x\n",
+   iface, fmt->altsetting, ep);
   return 0; /* some devices don't support reading */
  }
 
  crate = data[0] | (data[1] << 8) | (data[2] << 16);
  if (crate != rate) {
-  snd_printd(KERN_WARNING "current rate %d is different from the runtime rate %d\n", crate, rate);
+  dev_warn(&dev->dev, "current rate %d is different from the runtime rate %d\n", crate, rate);
   // runtime->rate = crate;
  }
 
@@ -332,8 +334,8 @@ static int get_sample_rate_v2(struct snd_usb_audio *chip, int iface,
          snd_usb_ctrl_intf(chip) | (clock << 8),
          &data, sizeof(data));
  if (err < 0) {
-  snd_printk(KERN_WARNING "%d:%d:%d: cannot get freq (v2): err %d\n",
-      dev->devnum, iface, altsetting, err);
+  dev_warn(&dev->dev, "%d:%d: cannot get freq (v2): err %d\n",
+    iface, altsetting, err);
   return 0;
  }
 
@@ -369,8 +371,9 @@ static int set_sample_rate_v2(struct snd_usb_audio *chip, int iface,
           snd_usb_ctrl_intf(chip) | (clock << 8),
           &data, sizeof(data));
   if (err < 0) {
-   snd_printk(KERN_ERR "%d:%d:%d: cannot set freq %d (v2): err %d\n",
-       dev->devnum, iface, fmt->altsetting, rate, err);
+   usb_audio_err(chip,
+    "%d:%d: cannot set freq %d (v2): err %d\n",
+    iface, fmt->altsetting, rate, err);
    return err;
   }
 
@@ -381,14 +384,14 @@ static int set_sample_rate_v2(struct snd_usb_audio *chip, int iface,
 
  if (cur_rate != rate) {
   if (!writeable) {
-   snd_printk(KERN_WARNING
-       "%d:%d:%d: freq mismatch (RO clock): req %d, clock runs @%d\n",
-       dev->devnum, iface, fmt->altsetting, rate, cur_rate);
+   usb_audio_warn(chip,
+     "%d:%d: freq mismatch (RO clock): req %d, clock runs @%d\n",
+     iface, fmt->altsetting, rate, cur_rate);
    return -ENXIO;
   }
-  snd_printd(KERN_WARNING
-      "current rate %d is different from the runtime rate %d\n",
-      cur_rate, rate);
+  usb_audio_dbg(chip,
+   "current rate %d is different from the runtime rate %d\n",
+   cur_rate, rate);
  }
 
  /* Some devices doesn't respond to sample rate changes while the
diff --git a/sound/usb/endpoint.c b/sound/usb/endpoint.c
index 83aabea..e70a87e 100644
--- a/sound/usb/endpoint.c
+++ b/sound/usb/endpoint.c
@@ -333,8 +333,9 @@ static void queue_pending_output_urbs(struct snd_usb_endpoint *ep)
 
   err = usb_submit_urb(ctx->urb, GFP_ATOMIC);
   if (err < 0)
-   snd_printk(KERN_ERR "Unable to submit urb #%d: %d (urb %p)\n",
-       ctx->index, err, ctx->urb);
+   usb_audio_err(ep->chip,
+    "Unable to submit urb #%d: %d (urb %p)\n",
+    ctx->index, err, ctx->urb);
   else
    set_bit(ctx->index, &ep->active_mask);
  }
@@ -387,7 +388,7 @@ static void snd_complete_urb(struct urb *urb)
  if (err == 0)
   return;
 
- snd_printk(KERN_ERR "cannot submit urb (err = %d)\n", err);
+ usb_audio_err(ep->chip, "cannot submit urb (err = %d)\n", err);
  //snd_pcm_stop(substream, SNDRV_PCM_STATE_XRUN);
 
 exit_clear:
@@ -426,13 +427,14 @@ struct snd_usb_endpoint *snd_usb_add_endpoint(struct snd_usb_audio *chip,
   if (ep->ep_num == ep_num &&
       ep->iface == alts->desc.bInterfaceNumber &&
       ep->altsetting == alts->desc.bAlternateSetting) {
-   snd_printdd(KERN_DEBUG "Re-using EP %x in iface %d,%d @%p\n",
+   usb_audio_dbg(ep->chip,
+          "Re-using EP %x in iface %d,%d @%p\n",
      ep_num, ep->iface, ep->altsetting, ep);
    goto __exit_unlock;
   }
  }
 
- snd_printdd(KERN_DEBUG "Creating new %s %s endpoint #%x\n",
+ usb_audio_dbg(chip, "Creating new %s %s endpoint #%x\n",
       is_playback ? "playback" : "capture",
       type == SND_USB_ENDPOINT_TYPE_DATA ? "data" : "sync",
       ep_num);
@@ -496,8 +498,9 @@ static int wait_clear_urbs(struct snd_usb_endpoint *ep)
  } while (time_before(jiffies, end_time));
 
  if (alive)
-  snd_printk(KERN_ERR "timeout: still %d active urbs on EP #%x\n",
-     alive, ep->ep_num);
+  usb_audio_err(ep->chip,
+   "timeout: still %d active urbs on EP #%x\n",
+   alive, ep->ep_num);
  clear_bit(EP_FLAG_STOPPING, &ep->flags);
 
  return 0;
@@ -794,8 +797,9 @@ int snd_usb_endpoint_set_params(struct snd_usb_endpoint *ep,
  int err;
 
  if (ep->use_count != 0) {
-  snd_printk(KERN_WARNING "Unable to change format on ep #%x: already in use\n",
-      ep->ep_num);
+  usb_audio_warn(ep->chip,
+    "Unable to change format on ep #%x: already in use\n",
+    ep->ep_num);
   return -EBUSY;
  }
 
@@ -830,8 +834,9 @@ int snd_usb_endpoint_set_params(struct snd_usb_endpoint *ep,
   err = -EINVAL;
  }
 
- snd_printdd(KERN_DEBUG "Setting params for ep #%x (type %d, %d urbs), ret=%d\n",
-     ep->ep_num, ep->type, ep->nurbs, err);
+ usb_audio_dbg(ep->chip,
+  "Setting params for ep #%x (type %d, %d urbs), ret=%d\n",
+  ep->ep_num, ep->type, ep->nurbs, err);
 
  return err;
 }
@@ -906,8 +911,9 @@ int snd_usb_endpoint_start(struct snd_usb_endpoint *ep, bool can_sleep)
 
   err = usb_submit_urb(urb, GFP_ATOMIC);
   if (err < 0) {
-   snd_printk(KERN_ERR "cannot submit urb %d, error %d: %s\n",
-       i, err, usb_error_string(err));
+   usb_audio_err(ep->chip,
+    "cannot submit urb %d, error %d: %s\n",
+    i, err, usb_error_string(err));
    goto __error;
   }
   set_bit(i, &ep->active_mask);
diff --git a/sound/usb/format.c b/sound/usb/format.c
index d244fd3..8bcc87c 100644
--- a/sound/usb/format.c
+++ b/sound/usb/format.c
@@ -74,8 +74,8 @@ static u64 parse_audio_format_i_type(struct snd_usb_audio *chip,
  if ((pcm_formats == 0) &&
      (format == 0 || format == (1 << UAC_FORMAT_TYPE_I_UNDEFINED))) {
   /* some devices don't define this correctly... */
-  snd_printdd(KERN_INFO "%d:%u:%d : format type 0 is detected, processed as PCM\n",
-       chip->dev->devnum, fp->iface, fp->altsetting);
+  usb_audio_info(chip, "%u:%d : format type 0 is detected, processed as PCM\n",
+   fp->iface, fp->altsetting);
   format = 1 << UAC_FORMAT_TYPE_I_PCM;
  }
  if (format & (1 << UAC_FORMAT_TYPE_I_PCM)) {
@@ -83,9 +83,9 @@ static u64 parse_audio_format_i_type(struct snd_usb_audio *chip,
       sample_width == 24 && sample_bytes == 2)
    sample_bytes = 3;
   else if (sample_width > sample_bytes * 8) {
-   snd_printk(KERN_INFO "%d:%u:%d : sample bitwidth %d in over sample bytes %d\n",
-       chip->dev->devnum, fp->iface, fp->altsetting,
-       sample_width, sample_bytes);
+   usb_audio_info(chip, "%u:%d : sample bitwidth %d in over sample bytes %d\n",
+     fp->iface, fp->altsetting,
+     sample_width, sample_bytes);
   }
   /* check the format byte size */
   switch (sample_bytes) {
@@ -108,9 +108,10 @@ static u64 parse_audio_format_i_type(struct snd_usb_audio *chip,
    pcm_formats |= SNDRV_PCM_FMTBIT_S32_LE;
    break;
   default:
-   snd_printk(KERN_INFO "%d:%u:%d : unsupported sample bitwidth %d in %d bytes\n",
-       chip->dev->devnum, fp->iface, fp->altsetting,
-       sample_width, sample_bytes);
+   usb_audio_info(chip,
+     "%u:%d : unsupported sample bitwidth %d in %d bytes\n",
+     fp->iface, fp->altsetting,
+     sample_width, sample_bytes);
    break;
   }
  }
@@ -132,8 +133,9 @@ static u64 parse_audio_format_i_type(struct snd_usb_audio *chip,
   pcm_formats |= SNDRV_PCM_FMTBIT_MU_LAW;
  }
  if (format & ~0x3f) {
-  snd_printk(KERN_INFO "%d:%u:%d : unsupported format bits %#x\n",
-      chip->dev->devnum, fp->iface, fp->altsetting, format);
+  usb_audio_info(chip,
+    "%u:%d : unsupported format bits %#x\n",
+    fp->iface, fp->altsetting, format);
  }
 
  pcm_formats |= snd_usb_interface_dsd_format_quirks(chip, fp, sample_bytes);
@@ -158,8 +160,9 @@ static int parse_audio_format_rates_v1(struct snd_usb_audio *chip, struct audiof
  int nr_rates = fmt[offset];
 
  if (fmt[0] < offset + 1 + 3 * (nr_rates ? nr_rates : 2)) {
-  snd_printk(KERN_ERR "%d:%u:%d : invalid UAC_FORMAT_TYPE desc\n",
-       chip->dev->devnum, fp->iface, fp->altsetting);
+  usb_audio_err(chip,
+   "%u:%d : invalid UAC_FORMAT_TYPE desc\n",
+   fp->iface, fp->altsetting);
   return -EINVAL;
  }
 
@@ -171,7 +174,7 @@ static int parse_audio_format_rates_v1(struct snd_usb_audio *chip, struct audiof
 
   fp->rate_table = kmalloc(sizeof(int) * nr_rates, GFP_KERNEL);
   if (fp->rate_table == NULL) {
-   snd_printk(KERN_ERR "cannot malloc\n");
+   usb_audio_err(chip, "cannot malloc\n");
    return -ENOMEM;
   }
 
@@ -222,7 +225,8 @@ static int parse_audio_format_rates_v1(struct snd_usb_audio *chip, struct audiof
  * get to know how many sample rates we have to expect.
  * Then fp->rate_table can be allocated and filled.
  */
-static int parse_uac2_sample_rate_range(struct audioformat *fp, int nr_triplets,
+static int parse_uac2_sample_rate_range(struct snd_usb_audio *chip,
+     struct audioformat *fp, int nr_triplets,
      const unsigned char *data)
 {
  int i, nr_rates = 0;
@@ -261,7 +265,7 @@ static int parse_uac2_sample_rate_range(struct audioformat *fp, int nr_triplets,
 
    nr_rates++;
    if (nr_rates >= MAX_NR_RATES) {
-    snd_printk(KERN_ERR "invalid uac2 rates\n");
+    usb_audio_err(chip, "invalid uac2 rates\n");
     break;
    }
 
@@ -287,7 +291,8 @@ static int parse_audio_format_rates_v2(struct snd_usb_audio *chip,
  int clock = snd_usb_clock_find_source(chip, fp->clock, false);
 
  if (clock < 0) {
-  snd_printk(KERN_ERR "%s(): unable to find clock source (clock %d)\n",
+  dev_err(&dev->dev,
+   "%s(): unable to find clock source (clock %d)\n",
     __func__, clock);
   goto err;
  }
@@ -300,7 +305,8 @@ static int parse_audio_format_rates_v2(struct snd_usb_audio *chip,
          tmp, sizeof(tmp));
 
  if (ret < 0) {
-  snd_printk(KERN_ERR "%s(): unable to retrieve number of sample rates (clock %d)\n",
+  dev_err(&dev->dev,
+   "%s(): unable to retrieve number of sample rates (clock %d)\n",
     __func__, clock);
   goto err;
  }
@@ -321,7 +327,8 @@ static int parse_audio_format_rates_v2(struct snd_usb_audio *chip,
          data, data_size);
 
  if (ret < 0) {
-  snd_printk(KERN_ERR "%s(): unable to retrieve sample rate range (clock %d)\n",
+  dev_err(&dev->dev,
+   "%s(): unable to retrieve sample rate range (clock %d)\n",
     __func__, clock);
   ret = -EINVAL;
   goto err_free;
@@ -332,7 +339,7 @@ static int parse_audio_format_rates_v2(struct snd_usb_audio *chip,
   * will have to deal with. */
  kfree(fp->rate_table);
  fp->rate_table = NULL;
- fp->nr_rates = parse_uac2_sample_rate_range(fp, nr_triplets, data);
+ fp->nr_rates = parse_uac2_sample_rate_range(chip, fp, nr_triplets, data);
 
  if (fp->nr_rates == 0) {
   /* SNDRV_PCM_RATE_CONTINUOUS */
@@ -348,7 +355,7 @@ static int parse_audio_format_rates_v2(struct snd_usb_audio *chip,
 
  /* Call the triplet parser again, but this time, fp->rate_table is
   * allocated, so the rates will be stored */
- parse_uac2_sample_rate_range(fp, nr_triplets, data);
+ parse_uac2_sample_rate_range(chip, fp, nr_triplets, data);
 
 err_free:
  kfree(data);
@@ -408,8 +415,9 @@ static int parse_audio_format_i(struct snd_usb_audio *chip,
  }
 
  if (fp->channels < 1) {
-  snd_printk(KERN_ERR "%d:%u:%d : invalid channels %d\n",
-      chip->dev->devnum, fp->iface, fp->altsetting, fp->channels);
+  usb_audio_err(chip,
+   "%u:%d : invalid channels %d\n",
+   fp->iface, fp->altsetting, fp->channels);
   return -EINVAL;
  }
 
@@ -435,8 +443,9 @@ static int parse_audio_format_ii(struct snd_usb_audio *chip,
   fp->formats = SNDRV_PCM_FMTBIT_MPEG;
   break;
  default:
-  snd_printd(KERN_INFO "%d:%u:%d : unknown format tag %#x is detected.  processed as MPEG.\n",
-      chip->dev->devnum, fp->iface, fp->altsetting, format);
+  usb_audio_info(chip,
+    "%u:%d : unknown format tag %#x is detected.  processed as MPEG.\n",
+    fp->iface, fp->altsetting, format);
   fp->formats = SNDRV_PCM_FMTBIT_MPEG;
   break;
  }
@@ -449,7 +458,7 @@ static int parse_audio_format_ii(struct snd_usb_audio *chip,
   struct uac_format_type_ii_discrete_descriptor *fmt = _fmt;
   brate = le16_to_cpu(fmt->wMaxBitRate);
   framesize = le16_to_cpu(fmt->wSamplesPerFrame);
-  snd_printd(KERN_INFO "found format II with max.bitrate = %d, frame size=%d\n", brate, framesize);
+  usb_audio_info(chip, "found format II with max.bitrate = %d, frame size=%d\n", brate, framesize);
   fp->frame_size = framesize;
   ret = parse_audio_format_rates_v1(chip, fp, _fmt, 8); /* fmt[8..] sample rates */
   break;
@@ -458,7 +467,7 @@ static int parse_audio_format_ii(struct snd_usb_audio *chip,
   struct uac_format_type_ii_ext_descriptor *fmt = _fmt;
   brate = le16_to_cpu(fmt->wMaxBitRate);
   framesize = le16_to_cpu(fmt->wSamplesPerFrame);
-  snd_printd(KERN_INFO "found format II with max.bitrate = %d, frame size=%d\n", brate, framesize);
+  usb_audio_info(chip, "found format II with max.bitrate = %d, frame size=%d\n", brate, framesize);
   fp->frame_size = framesize;
   ret = parse_audio_format_rates_v2(chip, fp);
   break;
@@ -484,9 +493,10 @@ int snd_usb_parse_audio_format(struct snd_usb_audio *chip,
   err = parse_audio_format_ii(chip, fp, format, fmt);
   break;
  default:
-  snd_printd(KERN_INFO "%d:%u:%d : format type %d is not supported yet\n",
-      chip->dev->devnum, fp->iface, fp->altsetting,
-      fmt->bFormatType);
+  usb_audio_info(chip,
+    "%u:%d : format type %d is not supported yet\n",
+    fp->iface, fp->altsetting,
+    fmt->bFormatType);
   return -ENOTSUPP;
  }
  fp->fmt_type = fmt->bFormatType;
diff --git a/sound/usb/midi.c b/sound/usb/midi.c
index b901f46..9da74d2 100644
--- a/sound/usb/midi.c
+++ b/sound/usb/midi.c
@@ -191,16 +191,16 @@ static int snd_usbmidi_submit_urb(struct urb* urb, gfp_t flags)
 {
  int err = usb_submit_urb(urb, flags);
  if (err < 0 && err != -ENODEV)
-  snd_printk(KERN_ERR "usb_submit_urb: %d\n", err);
+  dev_err(&urb->dev->dev, "usb_submit_urb: %d\n", err);
  return err;
 }
 
 /*
  * Error handling for URB completion functions.
  */
-static int snd_usbmidi_urb_error(int status)
+static int snd_usbmidi_urb_error(const struct urb *urb)
 {
- switch (status) {
+ switch (urb->status) {
  /* manually unlinked, or device gone */
  case -ENOENT:
  case -ECONNRESET:
@@ -213,7 +213,7 @@ static int snd_usbmidi_urb_error(int status)
  case -EILSEQ:
   return -EIO;
  default:
-  snd_printk(KERN_ERR "urb status %d\n", status);
+  dev_err(&urb->dev->dev, "urb status %d\n", urb->status);
   return 0; /* continue */
  }
 }
@@ -227,7 +227,7 @@ static void snd_usbmidi_input_data(struct snd_usb_midi_in_endpoint* ep, int port
  struct usbmidi_in_port* port = &ep->ports[portidx];
 
  if (!port->substream) {
-  snd_printd("unexpected port %d!\n", portidx);
+  dev_dbg(&ep->umidi->dev->dev, "unexpected port %d!\n", portidx);
   return;
  }
  if (!test_bit(port->substream->number, &ep->umidi->input_triggered))
@@ -259,7 +259,7 @@ static void snd_usbmidi_in_urb_complete(struct urb* urb)
   ep->umidi->usb_protocol_ops->input(ep, urb->transfer_buffer,
          urb->actual_length);
  } else {
-  int err = snd_usbmidi_urb_error(urb->status);
+  int err = snd_usbmidi_urb_error(urb);
   if (err < 0) {
    if (err != -ENODEV) {
     ep->error_resubmit = 1;
@@ -289,7 +289,7 @@ static void snd_usbmidi_out_urb_complete(struct urb* urb)
  }
  spin_unlock(&ep->buffer_lock);
  if (urb->status < 0) {
-  int err = snd_usbmidi_urb_error(urb->status);
+  int err = snd_usbmidi_urb_error(urb);
   if (err < 0) {
    if (err != -ENODEV)
     mod_timer(&ep->umidi->error_timer,
@@ -1668,7 +1668,7 @@ static void snd_usbmidi_init_substream(struct snd_usb_midi* umidi,
 
  struct snd_rawmidi_substream *substream = snd_usbmidi_find_substream(umidi, stream, number);
  if (!substream) {
-  snd_printd(KERN_ERR "substream %d:%d not found\n", stream, number);
+  dev_err(&umidi->dev->dev, "substream %d:%d not found\n", stream, number);
   return;
  }
 
@@ -1717,7 +1717,7 @@ static int snd_usbmidi_create_endpoints(struct snd_usb_midi* umidi,
    }
   }
  }
- snd_printdd(KERN_INFO "created %d output and %d input ports\n",
+ dev_dbg(&umidi->dev->dev, "created %d output and %d input ports\n",
       out_ports, in_ports);
  return 0;
 }
@@ -1747,10 +1747,11 @@ static int snd_usbmidi_get_ms_info(struct snd_usb_midi* umidi,
      ms_header->bLength >= 7 &&
      ms_header->bDescriptorType == USB_DT_CS_INTERFACE &&
      ms_header->bDescriptorSubtype == UAC_HEADER)
-  snd_printdd(KERN_INFO "MIDIStreaming version %02x.%02x\n",
+  dev_dbg(&umidi->dev->dev, "MIDIStreaming version %02x.%02x\n",
        ms_header->bcdMSC[1], ms_header->bcdMSC[0]);
  else
-  snd_printk(KERN_WARNING "MIDIStreaming interface descriptor not found\n");
+  dev_warn(&umidi->dev->dev,
+    "MIDIStreaming interface descriptor not found\n");
 
  epidx = 0;
  for (i = 0; i < intfd->bNumEndpoints; ++i) {
@@ -1767,7 +1768,8 @@ static int snd_usbmidi_get_ms_info(struct snd_usb_midi* umidi,
   if (usb_endpoint_dir_out(ep)) {
    if (endpoints[epidx].out_ep) {
     if (++epidx >= MIDI_MAX_ENDPOINTS) {
-     snd_printk(KERN_WARNING "too many endpoints\n");
+     dev_warn(&umidi->dev->dev,
+       "too many endpoints\n");
      break;
     }
    }
@@ -1782,12 +1784,13 @@ static int snd_usbmidi_get_ms_info(struct snd_usb_midi* umidi,
      */
     endpoints[epidx].out_interval = 1;
    endpoints[epidx].out_cables = (1 << ms_ep->bNumEmbMIDIJack) - 1;
-   snd_printdd(KERN_INFO "EP %02X: %d jack(s)\n",
+   dev_dbg(&umidi->dev->dev, "EP %02X: %d jack(s)\n",
         ep->bEndpointAddress, ms_ep->bNumEmbMIDIJack);
   } else {
    if (endpoints[epidx].in_ep) {
     if (++epidx >= MIDI_MAX_ENDPOINTS) {
-     snd_printk(KERN_WARNING "too many endpoints\n");
+     dev_warn(&umidi->dev->dev,
+       "too many endpoints\n");
      break;
     }
    }
@@ -1797,7 +1800,7 @@ static int snd_usbmidi_get_ms_info(struct snd_usb_midi* umidi,
    else if (snd_usb_get_speed(umidi->dev) == USB_SPEED_LOW)
     endpoints[epidx].in_interval = 1;
    endpoints[epidx].in_cables = (1 << ms_ep->bNumEmbMIDIJack) - 1;
-   snd_printdd(KERN_INFO "EP %02X: %d jack(s)\n",
+   dev_dbg(&umidi->dev->dev, "EP %02X: %d jack(s)\n",
         ep->bEndpointAddress, ms_ep->bNumEmbMIDIJack);
   }
  }
@@ -1865,7 +1868,7 @@ static void snd_usbmidi_switch_roland_altsetting(struct snd_usb_midi* umidi)
      (get_endpoint(hostif, 1)->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) != USB_ENDPOINT_XFER_INT)
   return;
 
- snd_printdd(KERN_INFO "switching to altsetting %d with int ep\n",
+ dev_dbg(&umidi->dev->dev, "switching to altsetting %d with int ep\n",
       intfd->bAlternateSetting);
  usb_set_interface(umidi->dev, intfd->bInterfaceNumber,
      intfd->bAlternateSetting);
@@ -2047,25 +2050,25 @@ static int snd_usbmidi_create_endpoints_midiman(struct snd_usb_midi* umidi,
   * input bulk endpoints (at indices 1 and 3) which aren't used.
   */
  if (intfd->bNumEndpoints < (endpoint->out_cables > 0x0001 ? 5 : 3)) {
-  snd_printdd(KERN_ERR "not enough endpoints\n");
+  dev_dbg(&umidi->dev->dev, "not enough endpoints\n");
   return -ENOENT;
  }
 
  epd = get_endpoint(hostif, 0);
  if (!usb_endpoint_dir_in(epd) || !usb_endpoint_xfer_int(epd)) {
-  snd_printdd(KERN_ERR "endpoint[0] isn't interrupt\n");
+  dev_dbg(&umidi->dev->dev, "endpoint[0] isn't interrupt\n");
   return -ENXIO;
  }
  epd = get_endpoint(hostif, 2);
  if (!usb_endpoint_dir_out(epd) || !usb_endpoint_xfer_bulk(epd)) {
-  snd_printdd(KERN_ERR "endpoint[2] isn't bulk output\n");
+  dev_dbg(&umidi->dev->dev, "endpoint[2] isn't bulk output\n");
   return -ENXIO;
  }
  if (endpoint->out_cables > 0x0001) {
   epd = get_endpoint(hostif, 4);
   if (!usb_endpoint_dir_out(epd) ||
       !usb_endpoint_xfer_bulk(epd)) {
-   snd_printdd(KERN_ERR "endpoint[4] isn't bulk output\n");
+   dev_dbg(&umidi->dev->dev, "endpoint[4] isn't bulk output\n");
    return -ENXIO;
   }
  }
@@ -2289,7 +2292,7 @@ int snd_usbmidi_create(struct snd_card *card,
   err = snd_usbmidi_detect_per_port_endpoints(umidi, endpoints);
   break;
  default:
-  snd_printd(KERN_ERR "invalid quirk type %d\n", quirk->type);
+  dev_err(&umidi->dev->dev, "invalid quirk type %d\n", quirk->type);
   err = -ENXIO;
   break;
  }
diff --git a/sound/usb/mixer.c b/sound/usb/mixer.c
index 8c152b0..fcd3ab9 100644
--- a/sound/usb/mixer.c
+++ b/sound/usb/mixer.c
@@ -305,8 +305,9 @@ static int get_ctl_value_v1(struct usb_mixer_elem_info *cval, int request, int v
    goto out;
   }
  }
- snd_printdd(KERN_ERR "cannot get ctl value: req = %#x, wValue = %#x, wIndex = %#x, type = %d\n",
-      request, validx, idx, cval->val_type);
+ usb_audio_dbg(chip,
+  "cannot get ctl value: req = %#x, wValue = %#x, wIndex = %#x, type = %d\n",
+  request, validx, idx, cval->val_type);
  err = -EINVAL;
 
  out:
@@ -351,8 +352,9 @@ static int get_ctl_value_v2(struct usb_mixer_elem_info *cval, int request, int v
 
  if (ret < 0) {
 error:
-  snd_printk(KERN_ERR "cannot get ctl value: req = %#x, wValue = %#x, wIndex = %#x, type = %d\n",
-      request, validx, idx, cval->val_type);
+  usb_audio_err(chip,
+   "cannot get ctl value: req = %#x, wValue = %#x, wIndex = %#x, type = %d\n",
+   request, validx, idx, cval->val_type);
   return ret;
  }
 
@@ -413,7 +415,8 @@ static int get_cur_mix_value(struct usb_mixer_elem_info *cval,
  err = get_cur_mix_raw(cval, channel, value);
  if (err < 0) {
   if (!cval->mixer->ignore_ctl_error)
-   snd_printd(KERN_ERR "cannot get current value for control %d ch %d: err = %d\n",
+   usb_audio_dbg(cval->mixer->chip,
+    "cannot get current value for control %d ch %d: err = %d\n",
        cval->control, channel, err);
   return err;
  }
@@ -444,7 +447,7 @@ int snd_usb_mixer_set_ctl_value(struct usb_mixer_elem_info *cval,
 
   /* FIXME */
   if (request != UAC_SET_CUR) {
-   snd_printdd(KERN_WARNING "RANGE setting not yet supported\n");
+   usb_audio_dbg(chip, "RANGE setting not yet supported\n");
    return -EINVAL;
   }
 
@@ -470,7 +473,7 @@ int snd_usb_mixer_set_ctl_value(struct usb_mixer_elem_info *cval,
    goto out;
   }
  }
- snd_printdd(KERN_ERR "cannot set ctl value: req = %#x, wValue = %#x, wIndex = %#x, type = %d, data = %#x/%#x\n",
+ usb_audio_dbg(chip, "cannot set ctl value: req = %#x, wValue = %#x, wIndex = %#x, type = %d, data = %#x/%#x\n",
       request, validx, idx, cval->val_type, buf[0], buf[1]);
  err = -EINVAL;
 
@@ -494,7 +497,8 @@ static int set_cur_mix_value(struct usb_mixer_elem_info *cval, int channel,
   cval->ch_readonly & (1 << (channel - 1));
 
  if (read_only) {
-  snd_printdd(KERN_INFO "%s(): channel %d of control %d is read_only\n",
+  usb_audio_dbg(cval->mixer->chip,
+         "%s(): channel %d of control %d is read_only\n",
        __func__, channel, cval->control);
   return 0;
  }
@@ -560,7 +564,7 @@ int snd_usb_mixer_add_control(struct usb_mixer_interface *mixer,
  while (snd_ctl_find_id(mixer->chip->card, &kctl->id))
   kctl->id.index++;
  if ((err = snd_ctl_add(mixer->chip->card, kctl)) < 0) {
-  snd_printd(KERN_ERR "cannot add control (err = %d)\n", err);
+  usb_audio_dbg(mixer->chip, "cannot add control (err = %d)\n", err);
   return err;
  }
  cval->elem_id = &kctl->id;
@@ -807,7 +811,8 @@ static void usb_mixer_elem_free(struct snd_kcontrol *kctl)
 static void volume_control_quirks(struct usb_mixer_elem_info *cval,
       struct snd_kcontrol *kctl)
 {
- switch (cval->mixer->chip->usb_id) {
+ struct snd_usb_audio *chip = cval->mixer->chip;
+ switch (chip->usb_id) {
  case USB_ID(0x0763, 0x2030): /* M-Audio Fast Track C400 */
  case USB_ID(0x0763, 0x2031): /* M-Audio Fast Track C600 */
   if (strcmp(kctl->id.name, "Effect Duration") == 0) {
@@ -839,8 +844,8 @@ static void volume_control_quirks(struct usb_mixer_elem_info *cval,
  case USB_ID(0x0763, 0x2081): /* M-Audio Fast Track Ultra 8R */
  case USB_ID(0x0763, 0x2080): /* M-Audio Fast Track Ultra */
   if (strcmp(kctl->id.name, "Effect Duration") == 0) {
-   snd_printk(KERN_INFO
-    "usb-audio: set quirk for FTU Effect Duration\n");
+   usb_audio_info(chip,
+           "set quirk for FTU Effect Duration\n");
    cval->min = 0x0000;
    cval->max = 0x7f00;
    cval->res = 0x0100;
@@ -848,8 +853,8 @@ static void volume_control_quirks(struct usb_mixer_elem_info *cval,
   }
   if (strcmp(kctl->id.name, "Effect Volume") == 0 ||
       strcmp(kctl->id.name, "Effect Feedback Volume") == 0) {
-   snd_printk(KERN_INFO
-    "usb-audio: set quirks for FTU Effect Feedback/Volume\n");
+   usb_audio_info(chip,
+           "set quirks for FTU Effect Feedback/Volume\n");
    cval->min = 0x00;
    cval->max = 0x7f;
    break;
@@ -867,7 +872,7 @@ static void volume_control_quirks(struct usb_mixer_elem_info *cval,
   */
   if (!strcmp(kctl->id.name, "PCM Playback Volume") &&
       cval->min == -15616) {
-   snd_printk(KERN_INFO
+   usb_audio_info(chip,
      "set volume quirk for UDA1321/N101 chip\n");
    cval->max = -256;
   }
@@ -875,7 +880,7 @@ static void volume_control_quirks(struct usb_mixer_elem_info *cval,
 
  case USB_ID(0x046d, 0x09a4):
   if (!strcmp(kctl->id.name, "Mic Capture Volume")) {
-   snd_printk(KERN_INFO
+   usb_audio_info(chip,
     "set volume quirk for QuickCam E3500\n");
    cval->min = 6080;
    cval->max = 8768;
@@ -895,7 +900,7 @@ static void volume_control_quirks(struct usb_mixer_elem_info *cval,
   * Proboly there is some logitech magic behind this number --fishor
   */
   if (!strcmp(kctl->id.name, "Mic Capture Volume")) {
-   snd_printk(KERN_INFO
+   usb_audio_info(chip,
     "set resolution quirk: cval->res = 384\n");
    cval->res = 384;
   }
@@ -931,7 +936,8 @@ static int get_min_max_with_quirks(struct usb_mixer_elem_info *cval,
   }
   if (get_ctl_value(cval, UAC_GET_MAX, (cval->control << 8) | minchn, &cval->max) < 0 ||
       get_ctl_value(cval, UAC_GET_MIN, (cval->control << 8) | minchn, &cval->min) < 0) {
-   snd_printd(KERN_ERR "%d:%d: cannot get min/max values for control %d (id %d)\n",
+   usb_audio_err(cval->mixer->chip,
+          "%d:%d: cannot get min/max values for control %d (id %d)\n",
        cval->id, snd_usb_ctrl_intf(cval->mixer->chip), cval->control, cval->id);
    return -EINVAL;
   }
@@ -1195,7 +1201,7 @@ static void build_feature_ctl(struct mixer_build *state, void *raw_desc,
 
  cval = kzalloc(sizeof(*cval), GFP_KERNEL);
  if (! cval) {
-  snd_printk(KERN_ERR "cannot malloc kcontrol\n");
+  usb_audio_err(state->chip, "cannot malloc kcontrol\n");
   return;
  }
  cval->mixer = state->mixer;
@@ -1224,7 +1230,7 @@ static void build_feature_ctl(struct mixer_build *state, void *raw_desc,
   kctl = snd_ctl_new1(&usb_feature_unit_ctl, cval);
 
  if (! kctl) {
-  snd_printk(KERN_ERR "cannot malloc kcontrol\n");
+  usb_audio_err(state->chip, "cannot malloc kcontrol\n");
   kfree(cval);
   return;
  }
@@ -1298,16 +1304,16 @@ static void build_feature_ctl(struct mixer_build *state, void *raw_desc,
   * devices. It will definitively catch all buggy Logitech devices.
   */
  if (range > 384) {
-  snd_printk(KERN_WARNING "usb_audio: Warning! Unlikely big "
+  usb_audio_warn(state->chip, "Warning! Unlikely big "
       "volume range (=%u), cval->res is probably wrong.",
       range);
-  snd_printk(KERN_WARNING "usb_audio: [%d] FU [%s] ch = %d, "
+  usb_audio_warn(state->chip, "[%d] FU [%s] ch = %d, "
       "val = %d/%d/%d", cval->id,
       kctl->id.name, cval->channels,
       cval->min, cval->max, cval->res);
  }
 
- snd_printdd(KERN_INFO "[%d] FU [%s] ch = %d, val = %d/%d/%d\n",
+ usb_audio_dbg(state->chip, "[%d] FU [%s] ch = %d, val = %d/%d/%d\n",
       cval->id, kctl->id.name, cval->channels, cval->min, cval->max, cval->res);
  snd_usb_mixer_add_control(state->mixer, kctl);
 }
@@ -1331,16 +1337,17 @@ static int parse_audio_feature_unit(struct mixer_build *state, int unitid, void
  if (state->mixer->protocol == UAC_VERSION_1) {
   csize = hdr->bControlSize;
   if (!csize) {
-   snd_printdd(KERN_ERR "usbaudio: unit %u: "
-        "invalid bControlSize == 0\n", unitid);
+   usb_audio_dbg(state->chip,
+          "unit %u: invalid bControlSize == 0\n",
+          unitid);
    return -EINVAL;
   }
   channels = (hdr->bLength - 7) / csize - 1;
   bmaControls = hdr->bmaControls;
   if (hdr->bLength < 7 + csize) {
-   snd_printk(KERN_ERR "usbaudio: unit %u: "
-       "invalid UAC_FEATURE_UNIT descriptor\n",
-       unitid);
+   usb_audio_err(state->chip,
+          "unit %u: invalid UAC_FEATURE_UNIT descriptor\n",
+          unitid);
    return -EINVAL;
   }
  } else {
@@ -1349,9 +1356,9 @@ static int parse_audio_feature_unit(struct mixer_build *state, int unitid, void
   channels = (hdr->bLength - 6) / 4 - 1;
   bmaControls = ftr->bmaControls;
   if (hdr->bLength < 6 + csize) {
-   snd_printk(KERN_ERR "usbaudio: unit %u: "
-       "invalid UAC_FEATURE_UNIT descriptor\n",
-       unitid);
+   usb_audio_err(state->chip,
+          "unit %u: invalid UAC_FEATURE_UNIT descriptor\n",
+          unitid);
    return -EINVAL;
   }
  }
@@ -1369,14 +1376,14 @@ static int parse_audio_feature_unit(struct mixer_build *state, int unitid, void
  /* master configuration quirks */
  switch (state->chip->usb_id) {
  case USB_ID(0x08bb, 0x2702):
-  snd_printk(KERN_INFO
-      "usbmixer: master volume quirk for PCM2702 chip\n");
+  usb_audio_info(state->chip,
+          "usbmixer: master volume quirk for PCM2702 chip\n");
   /* disable non-functional volume control */
   master_bits &= ~UAC_CONTROL_BIT(UAC_FU_VOLUME);
   break;
  case USB_ID(0x1130, 0xf211):
-  snd_printk(KERN_INFO
-      "usbmixer: volume control quirk for Tenx TP6911 Audio Headset\n");
+  usb_audio_info(state->chip,
+          "usbmixer: volume control quirk for Tenx TP6911 Audio Headset\n");
   /* disable non-functional volume control */
   channels = 0;
   break;
@@ -1478,7 +1485,7 @@ static void build_mixer_unit_ctl(struct mixer_build *state,
 
  kctl = snd_ctl_new1(&usb_feature_unit_ctl, cval);
  if (! kctl) {
-  snd_printk(KERN_ERR "cannot malloc kcontrol\n");
+  usb_audio_err(state->chip, "cannot malloc kcontrol\n");
   kfree(cval);
   return;
  }
@@ -1491,7 +1498,7 @@ static void build_mixer_unit_ctl(struct mixer_build *state,
   len = sprintf(kctl->id.name, "Mixer Source %d", in_ch + 1);
  append_ctl_name(kctl, " Volume");
 
- snd_printdd(KERN_INFO "[%d] MU [%s] ch = %d, val = %d/%d\n",
+ usb_audio_dbg(state->chip, "[%d] MU [%s] ch = %d, val = %d/%d\n",
       cval->id, kctl->id.name, cval->channels, cval->min, cval->max);
  snd_usb_mixer_add_control(state->mixer, kctl);
 }
@@ -1508,12 +1515,12 @@ static int parse_audio_mixer_unit(struct mixer_build *state, int unitid, void *r
  int pin, ich, err;
 
  if (desc->bLength < 11 || ! (input_pins = desc->bNrInPins) || ! (num_outs = uac_mixer_unit_bNrChannels(desc))) {
-  snd_printk(KERN_ERR "invalid MIXER UNIT descriptor %d\n", unitid);
+  usb_audio_err(state->chip, "invalid MIXER UNIT descriptor %d\n", unitid);
   return -EINVAL;
  }
  /* no bmControls field (e.g. Maya44) -> ignore */
  if (desc->bLength <= 10 + input_pins) {
-  snd_printdd(KERN_INFO "MU %d has no bmControls field\n", unitid);
+  usb_audio_dbg(state->chip, "MU %d has no bmControls field\n", unitid);
   return 0;
  }
 
@@ -1712,7 +1719,7 @@ static int build_audio_procunit(struct mixer_build *state, int unitid, void *raw
 
  if (desc->bLength < 13 || desc->bLength < 13 + num_ins ||
      desc->bLength < num_ins + uac_processing_unit_bControlSize(desc, state->mixer->protocol)) {
-  snd_printk(KERN_ERR "invalid %s descriptor (id %d)\n", name, unitid);
+  usb_audio_err(state->chip, "invalid %s descriptor (id %d)\n", name, unitid);
   return -EINVAL;
  }
 
@@ -1738,7 +1745,7 @@ static int build_audio_procunit(struct mixer_build *state, int unitid, void *raw
    continue;
   cval = kzalloc(sizeof(*cval), GFP_KERNEL);
   if (! cval) {
-   snd_printk(KERN_ERR "cannot malloc kcontrol\n");
+   usb_audio_err(state->chip, "cannot malloc kcontrol\n");
    return -ENOMEM;
   }
   cval->mixer = state->mixer;
@@ -1770,7 +1777,7 @@ static int build_audio_procunit(struct mixer_build *state, int unitid, void *raw
 
   kctl = snd_ctl_new1(&mixer_procunit_ctl, cval);
   if (! kctl) {
-   snd_printk(KERN_ERR "cannot malloc kcontrol\n");
+   usb_audio_err(state->chip, "cannot malloc kcontrol\n");
    kfree(cval);
    return -ENOMEM;
   }
@@ -1792,7 +1799,8 @@ static int build_audio_procunit(struct mixer_build *state, int unitid, void *raw
   append_ctl_name(kctl, " ");
   append_ctl_name(kctl, valinfo->suffix);
 
-  snd_printdd(KERN_INFO "[%d] PU [%s] ch = %d, val = %d/%d\n",
+  usb_audio_dbg(state->chip,
+   "[%d] PU [%s] ch = %d, val = %d/%d\n",
        cval->id, kctl->id.name, cval->channels, cval->min, cval->max);
   if ((err = snd_usb_mixer_add_control(state->mixer, kctl)) < 0)
    return err;
@@ -1917,7 +1925,8 @@ static int parse_audio_selector_unit(struct mixer_build *state, int unitid, void
  char **namelist;
 
  if (!desc->bNrInPins || desc->bLength < 5 + desc->bNrInPins) {
-  snd_printk(KERN_ERR "invalid SELECTOR UNIT descriptor %d\n", unitid);
+  usb_audio_err(state->chip,
+   "invalid SELECTOR UNIT descriptor %d\n", unitid);
   return -EINVAL;
  }
 
@@ -1935,7 +1944,7 @@ static int parse_audio_selector_unit(struct mixer_build *state, int unitid, void
 
  cval = kzalloc(sizeof(*cval), GFP_KERNEL);
  if (! cval) {
-  snd_printk(KERN_ERR "cannot malloc kcontrol\n");
+  usb_audio_err(state->chip, "cannot malloc kcontrol\n");
   return -ENOMEM;
  }
  cval->mixer = state->mixer;
@@ -1954,7 +1963,7 @@ static int parse_audio_selector_unit(struct mixer_build *state, int unitid, void
 
  namelist = kmalloc(sizeof(char *) * desc->bNrInPins, GFP_KERNEL);
  if (! namelist) {
-  snd_printk(KERN_ERR "cannot malloc\n");
+  usb_audio_err(state->chip, "cannot malloc\n");
   kfree(cval);
   return -ENOMEM;
  }
@@ -1964,7 +1973,7 @@ static int parse_audio_selector_unit(struct mixer_build *state, int unitid, void
   len = 0;
   namelist[i] = kmalloc(MAX_ITEM_NAME_LEN, GFP_KERNEL);
   if (! namelist[i]) {
-   snd_printk(KERN_ERR "cannot malloc\n");
+   usb_audio_err(state->chip, "cannot malloc\n");
    while (i--)
     kfree(namelist[i]);
    kfree(namelist);
@@ -1981,7 +1990,7 @@ static int parse_audio_selector_unit(struct mixer_build *state, int unitid, void
 
  kctl = snd_ctl_new1(&mixer_selectunit_ctl, cval);
  if (! kctl) {
-  snd_printk(KERN_ERR "cannot malloc kcontrol\n");
+  usb_audio_err(state->chip, "cannot malloc kcontrol\n");
   kfree(namelist);
   kfree(cval);
   return -ENOMEM;
@@ -2009,7 +2018,7 @@ static int parse_audio_selector_unit(struct mixer_build *state, int unitid, void
    append_ctl_name(kctl, " Playback Source");
  }
 
- snd_printdd(KERN_INFO "[%d] SU [%s] items = %d\n",
+ usb_audio_dbg(state->chip, "[%d] SU [%s] items = %d\n",
       cval->id, kctl->id.name, desc->bNrInPins);
  if ((err = snd_usb_mixer_add_control(state->mixer, kctl)) < 0)
   return err;
@@ -2031,7 +2040,7 @@ static int parse_audio_unit(struct mixer_build *state, int unitid)
 
  p1 = find_audio_control_unit(state, unitid);
  if (!p1) {
-  snd_printk(KERN_ERR "usbaudio: unit %d not found!\n", unitid);
+  usb_audio_err(state->chip, "unit %d not found!\n", unitid);
   return -EINVAL;
  }
 
@@ -2061,7 +2070,8 @@ static int parse_audio_unit(struct mixer_build *state, int unitid)
  case UAC2_EXTENSION_UNIT_V2:
   return parse_audio_extension_unit(state, unitid, p1);
  default:
-  snd_printk(KERN_ERR "usbaudio: unit %u: unexpected type 0x%02x\n", unitid, p1[2]);
+  usb_audio_err(state->chip,
+   "unit %u: unexpected type 0x%02x\n", unitid, p1[2]);
   return -EINVAL;
  }
 }
@@ -2209,8 +2219,9 @@ static void snd_usb_mixer_interrupt_v2(struct usb_mixer_interface *mixer,
  __u8 channel = value & 0xff;
 
  if (channel >= MAX_CHANNELS) {
-  snd_printk(KERN_DEBUG "%s(): bogus channel number %d\n",
-    __func__, channel);
+  usb_audio_dbg(mixer->chip,
+   "%s(): bogus channel number %d\n",
+   __func__, channel);
   return;
  }
 
@@ -2239,8 +2250,9 @@ static void snd_usb_mixer_interrupt_v2(struct usb_mixer_interface *mixer,
    break;
 
   default:
-   snd_printk(KERN_DEBUG "unknown attribute %d in interrupt\n",
-      attribute);
+   usb_audio_dbg(mixer->chip,
+    "unknown attribute %d in interrupt\n",
+    attribute);
    break;
   } /* switch */
  }
@@ -2261,7 +2273,7 @@ static void snd_usb_mixer_interrupt(struct urb *urb)
   for (status = urb->transfer_buffer;
        len >= sizeof(*status);
        len -= sizeof(*status), status++) {
-   snd_printd(KERN_DEBUG "status interrupt: %02x %02x\n",
+   dev_dbg(&urb->dev->dev, "status interrupt: %02x %02x\n",
       status->bStatusType,
       status->bOriginator);
 
diff --git a/sound/usb/mixer_quirks.c b/sound/usb/mixer_quirks.c
index f4b12c2..f119a41 100644
--- a/sound/usb/mixer_quirks.c
+++ b/sound/usb/mixer_quirks.c
@@ -600,8 +600,8 @@ static int snd_nativeinstruments_control_get(struct snd_kcontrol *kcontrol,
  up_read(&mixer->chip->shutdown_rwsem);
 
  if (ret < 0) {
-  snd_printk(KERN_ERR
-      "unable to issue vendor read request (ret = %d)", ret);
+  dev_err(&dev->dev,
+   "unable to issue vendor read request (ret = %d)", ret);
   return ret;
  }
 
@@ -631,8 +631,8 @@ static int snd_nativeinstruments_control_put(struct snd_kcontrol *kcontrol,
  up_read(&mixer->chip->shutdown_rwsem);
 
  if (ret < 0) {
-  snd_printk(KERN_ERR
-      "unable to issue vendor write request (ret = %d)", ret);
+  dev_err(&dev->dev,
+   "unable to issue vendor write request (ret = %d)", ret);
   return ret;
  }
 
@@ -1699,7 +1699,7 @@ void snd_usb_mixer_rc_memory_change(struct usb_mixer_interface *mixer,
    snd_usb_mixer_notify_id(mixer, mixer->rc_cfg->mute_mixer_id);
   break;
  default:
-  snd_printd(KERN_DEBUG "memory change in unknown unit %d\n", unitid);
+  usb_audio_dbg(mixer->chip, "memory change in unknown unit %d\n", unitid);
   break;
  }
 }
diff --git a/sound/usb/pcm.c b/sound/usb/pcm.c
index ca3256d..49de5c1 100644
--- a/sound/usb/pcm.c
+++ b/sound/usb/pcm.c
@@ -166,8 +166,8 @@ static int init_pitch_v1(struct snd_usb_audio *chip, int iface,
        USB_TYPE_CLASS|USB_RECIP_ENDPOINT|USB_DIR_OUT,
        UAC_EP_CS_ATTR_PITCH_CONTROL << 8, ep,
        data, sizeof(data))) < 0) {
-  snd_printk(KERN_ERR "%d:%d:%d: cannot set enable PITCH\n",
-      dev->devnum, iface, ep);
+  usb_audio_err(chip, "%d:%d: cannot set enable PITCH\n",
+         iface, ep);
   return err;
  }
 
@@ -187,8 +187,8 @@ static int init_pitch_v2(struct snd_usb_audio *chip, int iface,
        USB_TYPE_CLASS | USB_RECIP_ENDPOINT | USB_DIR_OUT,
        UAC2_EP_CS_PITCH << 8, 0,
        data, sizeof(data))) < 0) {
-  snd_printk(KERN_ERR "%d:%d:%d: cannot set enable PITCH (v2)\n",
-      dev->devnum, iface, fmt->altsetting);
+  usb_audio_err(chip, "%d:%d: cannot set enable PITCH (v2)\n",
+         iface, fmt->altsetting);
   return err;
  }
 
@@ -226,7 +226,7 @@ static int start_endpoints(struct snd_usb_substream *subs, bool can_sleep)
  if (!test_and_set_bit(SUBSTREAM_FLAG_DATA_EP_STARTED, &subs->flags)) {
   struct snd_usb_endpoint *ep = subs->data_endpoint;
 
-  snd_printdd(KERN_DEBUG "Starting data EP @%p\n", ep);
+  dev_dbg(&subs->dev->dev, "Starting data EP @%p\n", ep);
 
   ep->data_subs = subs;
   err = snd_usb_endpoint_start(ep, can_sleep);
@@ -247,16 +247,15 @@ static int start_endpoints(struct snd_usb_substream *subs, bool can_sleep)
       subs->sync_endpoint->altsetting);
    if (err < 0) {
     clear_bit(SUBSTREAM_FLAG_SYNC_EP_STARTED, &subs->flags);
-    snd_printk(KERN_ERR
-        "%d:%d:%d: cannot set interface (%d)\n",
-        subs->dev->devnum,
+    dev_err(&subs->dev->dev,
+        "%d:%d: cannot set interface (%d)\n",
         subs->sync_endpoint->iface,
         subs->sync_endpoint->altsetting, err);
     return -EIO;
    }
   }
 
-  snd_printdd(KERN_DEBUG "Starting sync EP @%p\n", ep);
+  dev_dbg(&subs->dev->dev, "Starting sync EP @%p\n", ep);
 
   ep->sync_slave = subs->data_endpoint;
   err = snd_usb_endpoint_start(ep, can_sleep);
@@ -410,8 +409,9 @@ static int set_sync_endpoint(struct snd_usb_substream *subs,
  if ((get_endpoint(alts, 1)->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) != USB_ENDPOINT_XFER_ISOC ||
      (get_endpoint(alts, 1)->bLength >= USB_DT_ENDPOINT_AUDIO_SIZE &&
       get_endpoint(alts, 1)->bSynchAddress != 0)) {
-  snd_printk(KERN_ERR "%d:%d:%d : invalid sync pipe. bmAttributes %02x, bLength %d, bSynchAddress %02x\n",
-      dev->devnum, fmt->iface, fmt->altsetting,
+  dev_err(&dev->dev,
+   "%d:%d : invalid sync pipe. bmAttributes %02x, bLength %d, bSynchAddress %02x\n",
+      fmt->iface, fmt->altsetting,
       get_endpoint(alts, 1)->bmAttributes,
       get_endpoint(alts, 1)->bLength,
       get_endpoint(alts, 1)->bSynchAddress);
@@ -421,8 +421,9 @@ static int set_sync_endpoint(struct snd_usb_substream *subs,
  if (get_endpoint(alts, 0)->bLength >= USB_DT_ENDPOINT_AUDIO_SIZE &&
      ((is_playback && ep != (unsigned int)(get_endpoint(alts, 0)->bSynchAddress | USB_DIR_IN)) ||
       (!is_playback && ep != (unsigned int)(get_endpoint(alts, 0)->bSynchAddress & ~USB_DIR_IN)))) {
-  snd_printk(KERN_ERR "%d:%d:%d : invalid sync pipe. is_playback %d, ep %02x, bSynchAddress %02x\n",
-      dev->devnum, fmt->iface, fmt->altsetting,
+  dev_err(&dev->dev,
+   "%d:%d : invalid sync pipe. is_playback %d, ep %02x, bSynchAddress %02x\n",
+      fmt->iface, fmt->altsetting,
       is_playback, ep, get_endpoint(alts, 0)->bSynchAddress);
   return -EINVAL;
  }
@@ -469,8 +470,9 @@ static int set_format(struct snd_usb_substream *subs, struct audioformat *fmt)
  if (subs->interface >= 0 && subs->interface != fmt->iface) {
   err = usb_set_interface(subs->dev, subs->interface, 0);
   if (err < 0) {
-   snd_printk(KERN_ERR "%d:%d:%d: return to setting 0 failed (%d)\n",
-    dev->devnum, fmt->iface, fmt->altsetting, err);
+   dev_err(&dev->dev,
+    "%d:%d: return to setting 0 failed (%d)\n",
+    fmt->iface, fmt->altsetting, err);
    return -EIO;
   }
   subs->interface = -1;
@@ -482,12 +484,13 @@ static int set_format(struct snd_usb_substream *subs, struct audioformat *fmt)
      subs->altset_idx != fmt->altset_idx) {
   err = usb_set_interface(dev, fmt->iface, fmt->altsetting);
   if (err < 0) {
-   snd_printk(KERN_ERR "%d:%d:%d: usb_set_interface failed (%d)\n",
-       dev->devnum, fmt->iface, fmt->altsetting, err);
+   dev_err(&dev->dev,
+    "%d:%d: usb_set_interface failed (%d)\n",
+    fmt->iface, fmt->altsetting, err);
    return -EIO;
   }
-  snd_printdd(KERN_INFO "setting usb interface %d:%d\n",
-    fmt->iface, fmt->altsetting);
+  dev_dbg(&dev->dev, "setting usb interface %d:%d\n",
+   fmt->iface, fmt->altsetting);
   subs->interface = fmt->iface;
   subs->altset_idx = fmt->altset_idx;
 
@@ -523,20 +526,23 @@ static int set_format(struct snd_usb_substream *subs, struct audioformat *fmt)
  * - Requested PCM format is not supported.
  * - Requested sample rate is not supported.
  */
-static int match_endpoint_audioformats(struct audioformat *fp,
- struct audioformat *match, int rate,
- snd_pcm_format_t pcm_format)
+static int match_endpoint_audioformats(struct snd_usb_substream *subs,
+           struct audioformat *fp,
+           struct audioformat *match, int rate,
+           snd_pcm_format_t pcm_format)
 {
  int i;
  int score = 0;
 
  if (fp->channels < 1) {
-  snd_printdd("%s: (fmt @%p) no channels\n", __func__, fp);
+  dev_dbg(&subs->dev->dev,
+   "%s: (fmt @%p) no channels\n", __func__, fp);
   return 0;
  }
 
  if (!(fp->formats & pcm_format_to_bits(pcm_format))) {
-  snd_printdd("%s: (fmt @%p) no match for format %d\n", __func__,
+  dev_dbg(&subs->dev->dev,
+   "%s: (fmt @%p) no match for format %d\n", __func__,
    fp, pcm_format);
   return 0;
  }
@@ -548,7 +554,8 @@ static int match_endpoint_audioformats(struct audioformat *fp,
   }
  }
  if (!score) {
-  snd_printdd("%s: (fmt @%p) no match for rate %d\n", __func__,
+  dev_dbg(&subs->dev->dev,
+   "%s: (fmt @%p) no match for rate %d\n", __func__,
    fp, rate);
   return 0;
  }
@@ -556,7 +563,8 @@ static int match_endpoint_audioformats(struct audioformat *fp,
  if (fp->channels == match->channels)
   score++;
 
- snd_printdd("%s: (fmt @%p) score %d\n", __func__, fp, score);
+ dev_dbg(&subs->dev->dev,
+  "%s: (fmt @%p) score %d\n", __func__, fp, score);
 
  return score;
 }
@@ -587,7 +595,8 @@ static int configure_sync_endpoint(struct snd_usb_substream *subs)
 
  /* Try to find the best matching audioformat. */
  list_for_each_entry(fp, &sync_subs->fmt_list, list) {
-  int score = match_endpoint_audioformats(fp, subs->cur_audiofmt,
+  int score = match_endpoint_audioformats(subs,
+       fp, subs->cur_audiofmt,
    subs->cur_rate, subs->pcm_format);
 
   if (score > cur_score) {
@@ -597,7 +606,8 @@ static int configure_sync_endpoint(struct snd_usb_substream *subs)
  }
 
  if (unlikely(sync_fp == NULL)) {
-  snd_printk(KERN_ERR "%s: no valid audioformat for sync ep %x found\n",
+  dev_err(&subs->dev->dev,
+   "%s: no valid audioformat for sync ep %x found\n",
    __func__, sync_subs->ep_num);
   return -EINVAL;
  }
@@ -609,7 +619,8 @@ static int configure_sync_endpoint(struct snd_usb_substream *subs)
  if (sync_fp->channels != subs->channels) {
   sync_period_bytes = (subs->period_bytes / subs->channels) *
    sync_fp->channels;
-  snd_printdd("%s: adjusted sync ep period bytes (%d -> %d)\n",
+  dev_dbg(&subs->dev->dev,
+   "%s: adjusted sync ep period bytes (%d -> %d)\n",
    __func__, subs->period_bytes, sync_period_bytes);
  }
 
@@ -685,7 +696,8 @@ static int snd_usb_hw_params(struct snd_pcm_substream *substream,
 
  fmt = find_format(subs);
  if (!fmt) {
-  snd_printd(KERN_DEBUG "cannot set format: format = %#x, rate = %d, channels = %d\n",
+  dev_dbg(&subs->dev->dev,
+   "cannot set format: format = %#x, rate = %d, channels = %d\n",
       subs->pcm_format, subs->cur_rate, subs->channels);
   return -EINVAL;
  }
@@ -742,7 +754,7 @@ static int snd_usb_pcm_prepare(struct snd_pcm_substream *substream)
  int ret;
 
  if (! subs->cur_audiofmt) {
-  snd_printk(KERN_ERR "usbaudio: no format is specified!\n");
+  dev_err(&subs->dev->dev, "no format is specified!\n");
   return -ENXIO;
  }
 
@@ -1235,7 +1247,8 @@ static void retire_capture_urb(struct snd_usb_substream *subs,
  for (i = 0; i < urb->number_of_packets; i++) {
   cp = (unsigned char *)urb->transfer_buffer + urb->iso_frame_desc[i].offset + subs->pkt_offset_adj;
   if (urb->iso_frame_desc[i].status && printk_ratelimit()) {
-   snd_printdd(KERN_ERR "frame %d active: %d\n", i, urb->iso_frame_desc[i].status);
+   dev_dbg(&subs->dev->dev, "frame %d active: %d\n",
+    i, urb->iso_frame_desc[i].status);
    // continue;
   }
   bytes = urb->iso_frame_desc[i].actual_length;
@@ -1245,7 +1258,8 @@ static void retire_capture_urb(struct snd_usb_substream *subs,
   if (bytes % (runtime->sample_bits >> 3) != 0) {
    int oldbytes = bytes;
    bytes = frames * stride;
-   snd_printdd(KERN_ERR "Corrected urb data len. %d->%d\n",
+   dev_warn(&subs->dev->dev,
+     "Corrected urb data len. %d->%d\n",
        oldbytes, bytes);
   }
   /* update the current pointer */
@@ -1488,7 +1502,8 @@ static void retire_playback_urb(struct snd_usb_substream *subs,
   * on two reads of a counter updated every ms.
   */
  if (abs(est_delay - subs->last_delay) * 1000 > runtime->rate * 2)
-  snd_printk(KERN_DEBUG "delay: estimated %d, actual %d\n",
+  dev_dbg(&subs->dev->dev,
+   "delay: estimated %d, actual %d\n",
    est_delay, subs->last_delay);
 
  if (!subs->running) {
diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index 8973070..7c57f22 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -110,7 +110,7 @@ static int create_standard_audio_quirk(struct snd_usb_audio *chip,
  altsd = get_iface_desc(alts);
  err = snd_usb_parse_audio_interface(chip, altsd->bInterfaceNumber);
  if (err < 0) {
-  snd_printk(KERN_ERR "cannot setup if %d: error %d\n",
+  usb_audio_err(chip, "cannot setup if %d: error %d\n",
       altsd->bInterfaceNumber, err);
   return err;
  }
@@ -135,7 +135,7 @@ static int create_fixed_stream_quirk(struct snd_usb_audio *chip,
 
  fp = kmemdup(quirk->data, sizeof(*fp), GFP_KERNEL);
  if (!fp) {
-  snd_printk(KERN_ERR "cannot memdup\n");
+  usb_audio_err(chip, "cannot memdup\n");
   return -ENOMEM;
  }
  if (fp->nr_rates > MAX_NR_RATES) {
@@ -464,7 +464,7 @@ static int create_uaxx_quirk(struct snd_usb_audio *chip,
   fp->rate_max = fp->rate_min = 96000;
   break;
  default:
-  snd_printk(KERN_ERR "unknown sample rate\n");
+  usb_audio_err(chip, "unknown sample rate\n");
   kfree(fp);
   return -ENXIO;
  }
@@ -536,7 +536,7 @@ int snd_usb_create_quirk(struct snd_usb_audio *chip,
  if (quirk->type < QUIRK_TYPE_COUNT) {
   return quirk_funcs[quirk->type](chip, iface, driver, quirk);
  } else {
-  snd_printd(KERN_ERR "invalid quirk type %d\n", quirk->type);
+  usb_audio_err(chip, "invalid quirk type %d\n", quirk->type);
   return -ENXIO;
  }
 }
@@ -555,18 +555,21 @@ static int snd_usb_extigy_boot_quirk(struct usb_device *dev, struct usb_interfac
 
  if (le16_to_cpu(get_cfg_desc(config)->wTotalLength) == EXTIGY_FIRMWARE_SIZE_OLD ||
      le16_to_cpu(get_cfg_desc(config)->wTotalLength) == EXTIGY_FIRMWARE_SIZE_NEW) {
-  snd_printdd("sending Extigy boot sequence...\n");
+  dev_dbg(&dev->dev, "sending Extigy boot sequence...\n");
   /* Send message to force it to reconnect with full interface. */
   err = snd_usb_ctl_msg(dev, usb_sndctrlpipe(dev,0),
           0x10, 0x43, 0x0001, 0x000a, NULL, 0);
-  if (err < 0) snd_printdd("error sending boot message: %d\n", err);
+  if (err < 0)
+   dev_dbg(&dev->dev, "error sending boot message: %d\n", err);
   err = usb_get_descriptor(dev, USB_DT_DEVICE, 0,
     &dev->descriptor, sizeof(dev->descriptor));
   config = dev->actconfig;
-  if (err < 0) snd_printdd("error usb_get_descriptor: %d\n", err);
+  if (err < 0)
+   dev_dbg(&dev->dev, "error usb_get_descriptor: %d\n", err);
   err = usb_reset_configuration(dev);
-  if (err < 0) snd_printdd("error usb_reset_configuration: %d\n", err);
-  snd_printdd("extigy_boot: new boot length = %d\n",
+  if (err < 0)
+   dev_dbg(&dev->dev, "error usb_reset_configuration: %d\n", err);
+  dev_dbg(&dev->dev, "extigy_boot: new boot length = %d\n",
        le16_to_cpu(get_cfg_desc(config)->wTotalLength));
   return -ENODEV; /* quit this anyway */
  }
@@ -594,7 +597,7 @@ static int snd_usb_fasttrackpro_boot_quirk(struct usb_device *dev)
  int err;
 
  if (dev->actconfig->desc.bConfigurationValue == 1) {
-  snd_printk(KERN_INFO "usb-audio: "
+  dev_info(&dev->dev,
       "Fast Track Pro switching to config #2\n");
   /* This function has to be available by the usb core module.
    * if it is not avialable the boot quirk has to be left out
@@ -603,14 +606,15 @@ static int snd_usb_fasttrackpro_boot_quirk(struct usb_device *dev)
    */
   err = usb_driver_set_configuration(dev, 2);
   if (err < 0)
-   snd_printdd("error usb_driver_set_configuration: %d\n",
-        err);
+   dev_dbg(&dev->dev,
+    "error usb_driver_set_configuration: %d\n",
+    err);
   /* Always return an error, so that we stop creating a device
      that will just be destroyed and recreated with a new
      configuration */
   return -ENODEV;
  } else
-  snd_printk(KERN_INFO "usb-audio: Fast Track Pro config OK\n");
+  dev_info(&dev->dev, "Fast Track Pro config OK\n");
 
  return 0;
 }
@@ -779,11 +783,11 @@ static int snd_usb_mbox2_boot_quirk(struct usb_device *dev)
  fwsize = le16_to_cpu(get_cfg_desc(config)->wTotalLength);
 
  if (fwsize != MBOX2_FIRMWARE_SIZE) {
-  snd_printk(KERN_ERR "usb-audio: Invalid firmware size=%d.\n", fwsize);
+  dev_err(&dev->dev, "Invalid firmware size=%d.\n", fwsize);
   return -ENODEV;
  }
 
- snd_printd("usb-audio: Sending Digidesign Mbox 2 boot sequence...\n");
+ dev_dbg(&dev->dev, "Sending Digidesign Mbox 2 boot sequence...\n");
 
  count = 0;
  bootresponse[0] = MBOX2_BOOT_LOADING;
@@ -794,32 +798,32 @@ static int snd_usb_mbox2_boot_quirk(struct usb_device *dev)
    0x85, 0xc0, 0x0001, 0x0000, &bootresponse, 0x0012);
   if (bootresponse[0] == MBOX2_BOOT_READY)
    break;
-  snd_printd("usb-audio: device not ready, resending boot sequence...\n");
+  dev_dbg(&dev->dev, "device not ready, resending boot sequence...\n");
   count++;
  }
 
  if (bootresponse[0] != MBOX2_BOOT_READY) {
-  snd_printk(KERN_ERR "usb-audio: Unknown bootresponse=%d, or timed out, ignoring device.\n", bootresponse[0]);
+  dev_err(&dev->dev, "Unknown bootresponse=%d, or timed out, ignoring device.\n", bootresponse[0]);
   return -ENODEV;
  }
 
- snd_printdd("usb-audio: device initialised!\n");
+ dev_dbg(&dev->dev, "device initialised!\n");
 
  err = usb_get_descriptor(dev, USB_DT_DEVICE, 0,
   &dev->descriptor, sizeof(dev->descriptor));
  config = dev->actconfig;
  if (err < 0)
-  snd_printd("error usb_get_descriptor: %d\n", err);
+  dev_dbg(&dev->dev, "error usb_get_descriptor: %d\n", err);
 
  err = usb_reset_configuration(dev);
  if (err < 0)
-  snd_printd("error usb_reset_configuration: %d\n", err);
- snd_printdd("mbox2_boot: new boot length = %d\n",
+  dev_dbg(&dev->dev, "error usb_reset_configuration: %d\n", err);
+ dev_dbg(&dev->dev, "mbox2_boot: new boot length = %d\n",
   le16_to_cpu(get_cfg_desc(config)->wTotalLength));
 
  mbox2_setup_48_24_magic(dev);
 
- snd_printk(KERN_INFO "usb-audio: Digidesign Mbox 2: 24bit 48kHz");
+ dev_info(&dev->dev, "Digidesign Mbox 2: 24bit 48kHz");
 
  return 0; /* Successful boot */
 }
@@ -865,7 +869,7 @@ static int quattro_skip_setting_quirk(struct snd_usb_audio *chip,
     return 1; /* skip this altsetting */
   }
  }
- snd_printdd(KERN_INFO
+ usb_audio_dbg(chip,
       "using altsetting %d for interface %d config %d\n",
       altno, iface, chip->setup);
  return 0; /* keep this altsetting */
@@ -932,7 +936,7 @@ static int fasttrackpro_skip_setting_quirk(struct snd_usb_audio *chip,
    return 1;
  }
 
- snd_printdd(KERN_INFO
+ usb_audio_dbg(chip,
       "using altsetting %d for interface %d config %d\n",
       altno, iface, chip->setup);
  return 0; /* keep this altsetting */
diff --git a/sound/usb/stream.c b/sound/usb/stream.c
index 2fb71be..310a382 100644
--- a/sound/usb/stream.c
+++ b/sound/usb/stream.c
@@ -411,10 +411,9 @@ static int parse_uac_endpoint_attributes(struct snd_usb_audio *chip,
 
  if (!csep || csep->bLength < 7 ||
      csep->bDescriptorSubtype != UAC_EP_GENERAL) {
-  snd_printk(KERN_WARNING "%d:%u:%d : no or invalid"
-      " class specific endpoint descriptor\n",
-      chip->dev->devnum, iface_no,
-      altsd->bAlternateSetting);
+  usb_audio_warn(chip,
+          "%u:%d : no or invalid class specific endpoint descriptor\n",
+          iface_no, altsd->bAlternateSetting);
   return 0;
  }
 
@@ -533,8 +532,8 @@ int snd_usb_parse_audio_interface(struct snd_usb_audio *chip, int iface_no)
   /* get audio formats */
   switch (protocol) {
   default:
-   snd_printdd(KERN_WARNING "%d:%u:%d: unknown interface protocol %#02x, assuming v1\n",
-        dev->devnum, iface_no, altno, protocol);
+   dev_dbg(&dev->dev, "%u:%d: unknown interface protocol %#02x, assuming v1\n",
+    iface_no, altno, protocol);
    protocol = UAC_VERSION_1;
    /* fall through */
 
@@ -544,14 +543,16 @@ int snd_usb_parse_audio_interface(struct snd_usb_audio *chip, int iface_no)
    struct uac_input_terminal_descriptor *iterm;
 
    if (!as) {
-    snd_printk(KERN_ERR "%d:%u:%d : UAC_AS_GENERAL descriptor not found\n",
-        dev->devnum, iface_no, altno);
+    dev_err(&dev->dev,
+     "%u:%d : UAC_AS_GENERAL descriptor not found\n",
+     iface_no, altno);
     continue;
    }
 
    if (as->bLength < sizeof(*as)) {
-    snd_printk(KERN_ERR "%d:%u:%d : invalid UAC_AS_GENERAL desc\n",
-        dev->devnum, iface_no, altno);
+    dev_err(&dev->dev,
+     "%u:%d : invalid UAC_AS_GENERAL desc\n",
+     iface_no, altno);
     continue;
    }
 
@@ -574,14 +575,16 @@ int snd_usb_parse_audio_interface(struct snd_usb_audio *chip, int iface_no)
     snd_usb_find_csint_desc(alts->extra, alts->extralen, NULL, UAC_AS_GENERAL);
 
    if (!as) {
-    snd_printk(KERN_ERR "%d:%u:%d : UAC_AS_GENERAL descriptor not found\n",
-        dev->devnum, iface_no, altno);
+    dev_err(&dev->dev,
+     "%u:%d : UAC_AS_GENERAL descriptor not found\n",
+     iface_no, altno);
     continue;
    }
 
    if (as->bLength < sizeof(*as)) {
-    snd_printk(KERN_ERR "%d:%u:%d : invalid UAC_AS_GENERAL desc\n",
-        dev->devnum, iface_no, altno);
+    dev_err(&dev->dev,
+     "%u:%d : invalid UAC_AS_GENERAL desc\n",
+     iface_no, altno);
     continue;
    }
 
@@ -607,8 +610,9 @@ int snd_usb_parse_audio_interface(struct snd_usb_audio *chip, int iface_no)
     break;
    }
 
-   snd_printk(KERN_ERR "%d:%u:%d : bogus bTerminalLink %d\n",
-       dev->devnum, iface_no, altno, as->bTerminalLink);
+   dev_err(&dev->dev,
+    "%u:%d : bogus bTerminalLink %d\n",
+    iface_no, altno, as->bTerminalLink);
    continue;
   }
   }
@@ -616,14 +620,16 @@ int snd_usb_parse_audio_interface(struct snd_usb_audio *chip, int iface_no)
   /* get format type */
   fmt = snd_usb_find_csint_desc(alts->extra, alts->extralen, NULL, UAC_FORMAT_TYPE);
   if (!fmt) {
-   snd_printk(KERN_ERR "%d:%u:%d : no UAC_FORMAT_TYPE desc\n",
-       dev->devnum, iface_no, altno);
+   dev_err(&dev->dev,
+    "%u:%d : no UAC_FORMAT_TYPE desc\n",
+    iface_no, altno);
    continue;
   }
   if (((protocol == UAC_VERSION_1) && (fmt->bLength < 8)) ||
       ((protocol == UAC_VERSION_2) && (fmt->bLength < 6))) {
-   snd_printk(KERN_ERR "%d:%u:%d : invalid UAC_FORMAT_TYPE desc\n",
-       dev->devnum, iface_no, altno);
+   dev_err(&dev->dev,
+    "%u:%d : invalid UAC_FORMAT_TYPE desc\n",
+    iface_no, altno);
    continue;
   }
 
@@ -644,7 +650,7 @@ int snd_usb_parse_audio_interface(struct snd_usb_audio *chip, int iface_no)
 
   fp = kzalloc(sizeof(*fp), GFP_KERNEL);
   if (! fp) {
-   snd_printk(KERN_ERR "cannot malloc\n");
+   dev_err(&dev->dev, "cannot malloc\n");
    return -ENOMEM;
   }
 
@@ -707,7 +713,7 @@ int snd_usb_parse_audio_interface(struct snd_usb_audio *chip, int iface_no)
    chconfig = 0;
   fp->chmap = convert_chmap(fp->channels, chconfig, protocol);
 
-  snd_printdd(KERN_INFO "%d:%u:%d: add audio endpoint %#x\n", dev->devnum, iface_no, altno, fp->endpoint);
+  dev_dbg(&dev->dev, "%u:%d: add audio endpoint %#x\n", iface_no, altno, fp->endpoint);
   err = snd_usb_add_audio_stream(chip, stream, fp);
   if (err < 0) {
    kfree(fp->rate_table);
diff --git a/sound/usb/usbaudio.h b/sound/usb/usbaudio.h
index 5d2fe05..25c4c7e 100644
--- a/sound/usb/usbaudio.h
+++ b/sound/usb/usbaudio.h
@@ -60,6 +60,15 @@ struct snd_usb_audio {
  struct usb_host_interface *ctrl_intf; /* the audio control interface */
 };
 
+#define usb_audio_err(chip, fmt, args...) \
+ dev_err(&(chip)->dev->dev, fmt, ##args)
+#define usb_audio_warn(chip, fmt, args...) \
+ dev_warn(&(chip)->dev->dev, fmt, ##args)
+#define usb_audio_info(chip, fmt, args...) \
+ dev_info(&(chip)->dev->dev, fmt, ##args)
+#define usb_audio_dbg(chip, fmt, args...) \
+ dev_dbg(&(chip)->dev->dev, fmt, ##args)
+
 /*
  * Information about devices with broken descriptors
  */
-- 
1.7.1