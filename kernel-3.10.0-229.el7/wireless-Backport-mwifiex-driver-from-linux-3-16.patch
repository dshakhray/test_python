From 7c5b6c0d5e88ccb00cf1a5e354d1dc685b47532d Mon Sep 17 00:00:00 2001
From: Stanislaw Gruszka <sgruszka@redhat.com>
Date: Fri, 5 Sep 2014 11:23:51 -0400
Subject: [wireless] Backport mwifiex driver from linux 3.16

Message-id: <1409916232-5882-15-git-send-email-sgruszka@redhat.com>
Patchwork-id: 91445
O-Subject: [RHEL7 PATCH 14/15] Backport mwifiex driver from linux 3.16
Bugzilla: 1136324
RH-Acked-by: Prarit Bhargava <prarit@redhat.com>
RH-Acked-by: John Greene <jogreene@redhat.com>

BZ#1136324

Decription:
Sync mwifiex driver to code from linux 3.16 (up to commit
19583ca584d6f574384e17fe7613dfaeadcdc4a6).

Brew:
https://brewweb.devel.redhat.com/taskinfo?taskID=7918052

Testing:
Not tested.

Signed-off-by: Jarod Wilson <jarod@redhat.com>

diff --git a/drivers/net/wireless/mwifiex/11ac.c b/drivers/net/wireless/mwifiex/11ac.c
index 5e0eec4..706831d 100644
--- a/drivers/net/wireless/mwifiex/11ac.c
+++ b/drivers/net/wireless/mwifiex/11ac.c
@@ -23,6 +23,31 @@
 #include "main.h"
 #include "11ac.h"
 
+/* Tables of the MCS map to the highest data rate (in Mbps) supported
+ * for long GI.
+ */
+static const u16 max_rate_lgi_80MHZ[8][3] = {
+ {0x124, 0x15F, 0x186}, /* NSS = 1 */
+ {0x249, 0x2BE, 0x30C},  /* NSS = 2 */
+ {0x36D, 0x41D, 0x492},  /* NSS = 3 */
+ {0x492, 0x57C, 0x618},  /* NSS = 4 */
+ {0x5B6, 0x6DB, 0x79E},  /* NSS = 5 */
+ {0x6DB, 0x83A, 0x0},    /* NSS = 6 */
+ {0x7FF, 0x999, 0xAAA},  /* NSS = 7 */
+ {0x924, 0xAF8, 0xC30}   /* NSS = 8 */
+};
+
+static const u16 max_rate_lgi_160MHZ[8][3] = {
+ {0x249, 0x2BE, 0x30C},   /* NSS = 1 */
+ {0x492, 0x57C, 0x618},   /* NSS = 2 */
+ {0x6DB, 0x83A, 0x0},     /* NSS = 3 */
+ {0x924, 0xAF8, 0xC30},   /* NSS = 4 */
+ {0xB6D, 0xDB6, 0xF3C},   /* NSS = 5 */
+ {0xDB6, 0x1074, 0x1248}, /* NSS = 6 */
+ {0xFFF, 0x1332, 0x1554}, /* NSS = 7 */
+ {0x1248, 0x15F0, 0x1860} /* NSS = 8 */
+};
+
 /* This function converts the 2-bit MCS map to the highest long GI
  * VHT data rate.
  */
@@ -30,33 +55,10 @@ static u16
 mwifiex_convert_mcsmap_to_maxrate(struct mwifiex_private *priv,
       u8 bands, u16 mcs_map)
 {
- u8 i, nss, max_mcs;
+ u8 i, nss, mcs;
  u16 max_rate = 0;
  u32 usr_vht_cap_info = 0;
  struct mwifiex_adapter *adapter = priv->adapter;
- /* tables of the MCS map to the highest data rate (in Mbps)
-  * supported for long GI
-  */
- u16 max_rate_lgi_80MHZ[8][3] = {
-  {0x124, 0x15F, 0x186}, /* NSS = 1 */
-  {0x249, 0x2BE, 0x30C},  /* NSS = 2 */
-  {0x36D, 0x41D, 0x492},  /* NSS = 3 */
-  {0x492, 0x57C, 0x618},  /* NSS = 4 */
-  {0x5B6, 0x6DB, 0x79E},  /* NSS = 5 */
-  {0x6DB, 0x83A, 0x0},    /* NSS = 6 */
-  {0x7FF, 0x999, 0xAAA},  /* NSS = 7 */
-  {0x924, 0xAF8, 0xC30}   /* NSS = 8 */
- };
- u16 max_rate_lgi_160MHZ[8][3] = {
-  {0x249, 0x2BE, 0x30C},   /* NSS = 1 */
-  {0x492, 0x57C, 0x618},   /* NSS = 2 */
-  {0x6DB, 0x83A, 0x0},     /* NSS = 3 */
-  {0x924, 0xAF8, 0xC30},   /* NSS = 4 */
-  {0xB6D, 0xDB6, 0xF3C},   /* NSS = 5 */
-  {0xDB6, 0x1074, 0x1248}, /* NSS = 6 */
-  {0xFFF, 0x1332, 0x1554}, /* NSS = 7 */
-  {0x1248, 0x15F0, 0x1860} /* NSS = 8 */
- };
 
  if (bands & BAND_AAC)
   usr_vht_cap_info = adapter->usr_dot_11ac_dev_cap_a;
@@ -64,29 +66,29 @@ mwifiex_convert_mcsmap_to_maxrate(struct mwifiex_private *priv,
   usr_vht_cap_info = adapter->usr_dot_11ac_dev_cap_bg;
 
  /* find the max NSS supported */
- nss = 0;
- for (i = 0; i < 8; i++) {
-  max_mcs = (mcs_map >> (2 * i)) & 0x3;
-  if (max_mcs < 3)
+ nss = 1;
+ for (i = 1; i <= 8; i++) {
+  mcs = GET_VHTNSSMCS(mcs_map, i);
+  if (mcs < IEEE80211_VHT_MCS_NOT_SUPPORTED)
    nss = i;
  }
- max_mcs = (mcs_map >> (2 * nss)) & 0x3;
+ mcs = GET_VHTNSSMCS(mcs_map, nss);
 
- /* if max_mcs is 3, nss must be 0 (SS = 1). Thus, max mcs is MCS 9 */
- if (max_mcs >= 3)
-  max_mcs = 2;
+ /* if mcs is 3, nss must be 1 (NSS = 1). Default mcs to MCS 0~9 */
+ if (mcs == IEEE80211_VHT_MCS_NOT_SUPPORTED)
+  mcs = IEEE80211_VHT_MCS_SUPPORT_0_9;
 
  if (GET_VHTCAP_CHWDSET(usr_vht_cap_info)) {
   /* support 160 MHz */
-  max_rate = max_rate_lgi_160MHZ[nss][max_mcs];
+  max_rate = max_rate_lgi_160MHZ[nss - 1][mcs];
   if (!max_rate)
    /* MCS9 is not supported in NSS6 */
-   max_rate = max_rate_lgi_160MHZ[nss][max_mcs - 1];
+   max_rate = max_rate_lgi_160MHZ[nss - 1][mcs - 1];
  } else {
-  max_rate = max_rate_lgi_80MHZ[nss][max_mcs];
+  max_rate = max_rate_lgi_80MHZ[nss - 1][mcs];
   if (!max_rate)
    /* MCS9 is not supported in NSS3 */
-   max_rate = max_rate_lgi_80MHZ[nss][max_mcs - 1];
+   max_rate = max_rate_lgi_80MHZ[nss - 1][mcs - 1];
  }
 
  return max_rate;
@@ -94,21 +96,20 @@ mwifiex_convert_mcsmap_to_maxrate(struct mwifiex_private *priv,
 
 static void
 mwifiex_fill_vht_cap_info(struct mwifiex_private *priv,
-     struct mwifiex_ie_types_vhtcap *vht_cap, u8 bands)
+     struct ieee80211_vht_cap *vht_cap, u8 bands)
 {
  struct mwifiex_adapter *adapter = priv->adapter;
 
  if (bands & BAND_A)
-  vht_cap->vht_cap.vht_cap_info =
+  vht_cap->vht_cap_info =
     cpu_to_le32(adapter->usr_dot_11ac_dev_cap_a);
  else
-  vht_cap->vht_cap.vht_cap_info =
+  vht_cap->vht_cap_info =
     cpu_to_le32(adapter->usr_dot_11ac_dev_cap_bg);
 }
 
-static void
-mwifiex_fill_vht_cap_tlv(struct mwifiex_private *priv,
-    struct mwifiex_ie_types_vhtcap *vht_cap, u8 bands)
+void mwifiex_fill_vht_cap_tlv(struct mwifiex_private *priv,
+         struct ieee80211_vht_cap *vht_cap, u8 bands)
 {
  struct mwifiex_adapter *adapter = priv->adapter;
  u16 mcs_map_user, mcs_map_resp, mcs_map_result;
@@ -119,46 +120,48 @@ mwifiex_fill_vht_cap_tlv(struct mwifiex_private *priv,
 
  /* rx MCS Set: find the minimum of the user rx mcs and ap rx mcs */
  mcs_map_user = GET_DEVRXMCSMAP(adapter->usr_dot_11ac_mcs_support);
- mcs_map_resp = le16_to_cpu(vht_cap->vht_cap.supp_mcs.rx_mcs_map);
+ mcs_map_resp = le16_to_cpu(vht_cap->supp_mcs.rx_mcs_map);
  mcs_map_result = 0;
 
  for (nss = 1; nss <= 8; nss++) {
   mcs_user = GET_VHTNSSMCS(mcs_map_user, nss);
   mcs_resp = GET_VHTNSSMCS(mcs_map_resp, nss);
 
-  if ((mcs_user == NO_NSS_SUPPORT) ||
-      (mcs_resp == NO_NSS_SUPPORT))
-   SET_VHTNSSMCS(mcs_map_result, nss, NO_NSS_SUPPORT);
+  if ((mcs_user == IEEE80211_VHT_MCS_NOT_SUPPORTED) ||
+      (mcs_resp == IEEE80211_VHT_MCS_NOT_SUPPORTED))
+   SET_VHTNSSMCS(mcs_map_result, nss,
+          IEEE80211_VHT_MCS_NOT_SUPPORTED);
   else
    SET_VHTNSSMCS(mcs_map_result, nss,
           min(mcs_user, mcs_resp));
  }
 
- vht_cap->vht_cap.supp_mcs.rx_mcs_map = cpu_to_le16(mcs_map_result);
+ vht_cap->supp_mcs.rx_mcs_map = cpu_to_le16(mcs_map_result);
 
  tmp = mwifiex_convert_mcsmap_to_maxrate(priv, bands, mcs_map_result);
- vht_cap->vht_cap.supp_mcs.rx_highest = cpu_to_le16(tmp);
+ vht_cap->supp_mcs.rx_highest = cpu_to_le16(tmp);
 
  /* tx MCS Set: find the minimum of the user tx mcs and ap tx mcs */
  mcs_map_user = GET_DEVTXMCSMAP(adapter->usr_dot_11ac_mcs_support);
- mcs_map_resp = le16_to_cpu(vht_cap->vht_cap.supp_mcs.tx_mcs_map);
+ mcs_map_resp = le16_to_cpu(vht_cap->supp_mcs.tx_mcs_map);
  mcs_map_result = 0;
 
  for (nss = 1; nss <= 8; nss++) {
   mcs_user = GET_VHTNSSMCS(mcs_map_user, nss);
   mcs_resp = GET_VHTNSSMCS(mcs_map_resp, nss);
-  if ((mcs_user == NO_NSS_SUPPORT) ||
-      (mcs_resp == NO_NSS_SUPPORT))
-   SET_VHTNSSMCS(mcs_map_result, nss, NO_NSS_SUPPORT);
+  if ((mcs_user == IEEE80211_VHT_MCS_NOT_SUPPORTED) ||
+      (mcs_resp == IEEE80211_VHT_MCS_NOT_SUPPORTED))
+   SET_VHTNSSMCS(mcs_map_result, nss,
+          IEEE80211_VHT_MCS_NOT_SUPPORTED);
   else
    SET_VHTNSSMCS(mcs_map_result, nss,
           min(mcs_user, mcs_resp));
  }
 
- vht_cap->vht_cap.supp_mcs.tx_mcs_map = cpu_to_le16(mcs_map_result);
+ vht_cap->supp_mcs.tx_mcs_map = cpu_to_le16(mcs_map_result);
 
  tmp = mwifiex_convert_mcsmap_to_maxrate(priv, bands, mcs_map_result);
- vht_cap->vht_cap.supp_mcs.tx_highest = cpu_to_le16(tmp);
+ vht_cap->supp_mcs.tx_highest = cpu_to_le16(tmp);
 
  return;
 }
@@ -189,11 +192,11 @@ int mwifiex_cmd_append_11ac_tlv(struct mwifiex_private *priv,
   vht_cap->header.len  =
     cpu_to_le16(sizeof(struct ieee80211_vht_cap));
   memcpy((u8 *)vht_cap + sizeof(struct mwifiex_ie_types_header),
-         (u8 *)bss_desc->bcn_vht_cap +
-         sizeof(struct ieee_types_header),
+         (u8 *)bss_desc->bcn_vht_cap,
          le16_to_cpu(vht_cap->header.len));
 
-  mwifiex_fill_vht_cap_tlv(priv, vht_cap, bss_desc->bss_band);
+  mwifiex_fill_vht_cap_tlv(priv, &vht_cap->vht_cap,
+      bss_desc->bss_band);
   *buffer += sizeof(*vht_cap);
   ret_len += sizeof(*vht_cap);
  }
@@ -209,8 +212,7 @@ int mwifiex_cmd_append_11ac_tlv(struct mwifiex_private *priv,
           sizeof(struct mwifiex_ie_types_header));
    memcpy((u8 *)vht_op +
     sizeof(struct mwifiex_ie_types_header),
-          (u8 *)bss_desc->bcn_vht_oper +
-          sizeof(struct ieee_types_header),
+          (u8 *)bss_desc->bcn_vht_oper,
           le16_to_cpu(vht_op->header.len));
 
    /* negotiate the channel width and central freq
@@ -300,3 +302,81 @@ void mwifiex_set_11ac_ba_params(struct mwifiex_private *priv)
 
  return;
 }
+
+bool mwifiex_is_bss_in_11ac_mode(struct mwifiex_private *priv)
+{
+ struct mwifiex_bssdescriptor *bss_desc;
+ struct ieee80211_vht_operation *vht_oper;
+
+ bss_desc = &priv->curr_bss_params.bss_descriptor;
+ vht_oper = bss_desc->bcn_vht_oper;
+
+ if (!bss_desc->bcn_vht_cap || !vht_oper)
+  return false;
+
+ if (vht_oper->chan_width == IEEE80211_VHT_CHANWIDTH_USE_HT)
+  return false;
+
+ return true;
+}
+
+u8 mwifiex_get_center_freq_index(struct mwifiex_private *priv, u8 band,
+     u32 pri_chan, u8 chan_bw)
+{
+ u8 center_freq_idx = 0;
+
+ if (band & BAND_AAC) {
+  switch (pri_chan) {
+  case 36:
+  case 40:
+  case 44:
+  case 48:
+   if (chan_bw == IEEE80211_VHT_CHANWIDTH_80MHZ)
+    center_freq_idx = 42;
+   break;
+  case 52:
+  case 56:
+  case 60:
+  case 64:
+   if (chan_bw == IEEE80211_VHT_CHANWIDTH_80MHZ)
+    center_freq_idx = 58;
+   else if (chan_bw == IEEE80211_VHT_CHANWIDTH_160MHZ)
+    center_freq_idx = 50;
+   break;
+  case 100:
+  case 104:
+  case 108:
+  case 112:
+   if (chan_bw == IEEE80211_VHT_CHANWIDTH_80MHZ)
+    center_freq_idx = 106;
+   break;
+  case 116:
+  case 120:
+  case 124:
+  case 128:
+   if (chan_bw == IEEE80211_VHT_CHANWIDTH_80MHZ)
+    center_freq_idx = 122;
+   else if (chan_bw == IEEE80211_VHT_CHANWIDTH_160MHZ)
+    center_freq_idx = 114;
+   break;
+  case 132:
+  case 136:
+  case 140:
+  case 144:
+   if (chan_bw == IEEE80211_VHT_CHANWIDTH_80MHZ)
+    center_freq_idx = 138;
+   break;
+  case 149:
+  case 153:
+  case 157:
+  case 161:
+   if (chan_bw == IEEE80211_VHT_CHANWIDTH_80MHZ)
+    center_freq_idx = 155;
+   break;
+  default:
+   center_freq_idx = 42;
+  }
+ }
+
+ return center_freq_idx;
+}
diff --git a/drivers/net/wireless/mwifiex/11ac.h b/drivers/net/wireless/mwifiex/11ac.h
index 7c2c69b..0b02cb6 100644
--- a/drivers/net/wireless/mwifiex/11ac.h
+++ b/drivers/net/wireless/mwifiex/11ac.h
@@ -40,4 +40,6 @@ int mwifiex_cmd_append_11ac_tlv(struct mwifiex_private *priv,
 int mwifiex_cmd_11ac_cfg(struct mwifiex_private *priv,
     struct host_cmd_ds_command *cmd, u16 cmd_action,
     struct mwifiex_11ac_vht_cfg *cfg);
+void mwifiex_fill_vht_cap_tlv(struct mwifiex_private *priv,
+         struct ieee80211_vht_cap *vht_cap, u8 bands);
 #endif /* _MWIFIEX_11AC_H_ */
diff --git a/drivers/net/wireless/mwifiex/11h.c b/drivers/net/wireless/mwifiex/11h.c
new file mode 100644
index 0000000..e76b0db
--- /dev/null
+++ b/drivers/net/wireless/mwifiex/11h.c
@@ -0,0 +1,101 @@
+/*
+ * Marvell Wireless LAN device driver: 802.11h
+ *
+ * Copyright (C) 2013, Marvell International Ltd.
+ *
+ * This software file (the "File") is distributed by Marvell International
+ * Ltd. under the terms of the GNU General Public License Version 2, June 1991
+ * (the "License").  You may use, redistribute and/or modify this File in
+ * accordance with the terms and conditions of the License, a copy of which
+ * is available by writing to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA or on the
+ * worldwide web at http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.
+ *
+ * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE
+ * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about
+ * this warranty disclaimer.
+ */
+
+#include "main.h"
+#include "fw.h"
+
+
+/* This function appends 11h info to a buffer while joining an
+ * infrastructure BSS
+ */
+static void
+mwifiex_11h_process_infra_join(struct mwifiex_private *priv, u8 **buffer,
+          struct mwifiex_bssdescriptor *bss_desc)
+{
+ struct mwifiex_ie_types_header *ie_header;
+ struct mwifiex_ie_types_pwr_capability *cap;
+ struct mwifiex_ie_types_local_pwr_constraint *constraint;
+ struct ieee80211_supported_band *sband;
+ u8 radio_type;
+ int i;
+
+ if (!buffer || !(*buffer))
+  return;
+
+ radio_type = mwifiex_band_to_radio_type((u8) bss_desc->bss_band);
+ sband = priv->wdev->wiphy->bands[radio_type];
+
+ cap = (struct mwifiex_ie_types_pwr_capability *)*buffer;
+ cap->header.type = cpu_to_le16(WLAN_EID_PWR_CAPABILITY);
+ cap->header.len = cpu_to_le16(2);
+ cap->min_pwr = 0;
+ cap->max_pwr = 0;
+ *buffer += sizeof(*cap);
+
+ constraint = (struct mwifiex_ie_types_local_pwr_constraint *)*buffer;
+ constraint->header.type = cpu_to_le16(WLAN_EID_PWR_CONSTRAINT);
+ constraint->header.len = cpu_to_le16(2);
+ constraint->chan = bss_desc->channel;
+ constraint->constraint = bss_desc->local_constraint;
+ *buffer += sizeof(*constraint);
+
+ ie_header = (struct mwifiex_ie_types_header *)*buffer;
+ ie_header->type = cpu_to_le16(TLV_TYPE_PASSTHROUGH);
+ ie_header->len  = cpu_to_le16(2 * sband->n_channels + 2);
+ *buffer += sizeof(*ie_header);
+ *(*buffer)++ = WLAN_EID_SUPPORTED_CHANNELS;
+ *(*buffer)++ = 2 * sband->n_channels;
+ for (i = 0; i < sband->n_channels; i++) {
+  *(*buffer)++ = ieee80211_frequency_to_channel(
+     sband->channels[i].center_freq);
+  *(*buffer)++ = 1; /* one channel in the subband */
+ }
+}
+
+/* Enable or disable the 11h extensions in the firmware */
+static int mwifiex_11h_activate(struct mwifiex_private *priv, bool flag)
+{
+ u32 enable = flag;
+
+ return mwifiex_send_cmd(priv, HostCmd_CMD_802_11_SNMP_MIB,
+    HostCmd_ACT_GEN_SET, DOT11H_I, &enable, true);
+}
+
+/* This functions processes TLV buffer for a pending BSS Join command.
+ *
+ * Activate 11h functionality in the firmware if the spectrum management
+ * capability bit is found in the network we are joining. Also, necessary
+ * TLVs are set based on requested network's 11h capability.
+ */
+void mwifiex_11h_process_join(struct mwifiex_private *priv, u8 **buffer,
+         struct mwifiex_bssdescriptor *bss_desc)
+{
+ if (bss_desc->sensed_11h) {
+  /* Activate 11h functions in firmware, turns on capability
+   * bit
+   */
+  mwifiex_11h_activate(priv, true);
+  bss_desc->cap_info_bitmap |= WLAN_CAPABILITY_SPECTRUM_MGMT;
+  mwifiex_11h_process_infra_join(priv, buffer, bss_desc);
+ } else {
+  /* Deactivate 11h functions in the firmware */
+  mwifiex_11h_activate(priv, false);
+  bss_desc->cap_info_bitmap &= ~WLAN_CAPABILITY_SPECTRUM_MGMT;
+ }
+}
diff --git a/drivers/net/wireless/mwifiex/11n.c b/drivers/net/wireless/mwifiex/11n.c
index 41e9d25..e1c2f67 100644
--- a/drivers/net/wireless/mwifiex/11n.c
+++ b/drivers/net/wireless/mwifiex/11n.c
@@ -34,22 +34,26 @@
  *
  * RD responder bit to set to clear in the extended capability header.
  */
-void
-mwifiex_fill_cap_info(struct mwifiex_private *priv, u8 radio_type,
-        struct mwifiex_ie_types_htcap *ht_cap)
+int mwifiex_fill_cap_info(struct mwifiex_private *priv, u8 radio_type,
+     struct ieee80211_ht_cap *ht_cap)
 {
- uint16_t ht_ext_cap = le16_to_cpu(ht_cap->ht_cap.extended_ht_cap_info);
+ uint16_t ht_ext_cap = le16_to_cpu(ht_cap->extended_ht_cap_info);
  struct ieee80211_supported_band *sband =
      priv->wdev->wiphy->bands[radio_type];
 
- ht_cap->ht_cap.ampdu_params_info =
+ if (WARN_ON_ONCE(!sband)) {
+  dev_err(priv->adapter->dev, "Invalid radio type!\n");
+  return -EINVAL;
+ }
+
+ ht_cap->ampdu_params_info =
   (sband->ht_cap.ampdu_factor &
    IEEE80211_HT_AMPDU_PARM_FACTOR) |
   ((sband->ht_cap.ampdu_density <<
    IEEE80211_HT_AMPDU_PARM_DENSITY_SHIFT) &
    IEEE80211_HT_AMPDU_PARM_DENSITY);
 
- memcpy((u8 *) &ht_cap->ht_cap.mcs, &sband->ht_cap.mcs,
+ memcpy((u8 *)&ht_cap->mcs, &sband->ht_cap.mcs,
         sizeof(sband->ht_cap.mcs));
 
  if (priv->bss_mode == NL80211_IFTYPE_STATION ||
@@ -57,13 +61,18 @@ mwifiex_fill_cap_info(struct mwifiex_private *priv, u8 radio_type,
       (priv->adapter->sec_chan_offset !=
      IEEE80211_HT_PARAM_CHA_SEC_NONE)))
   /* Set MCS32 for infra mode or ad-hoc mode with 40MHz support */
-  SETHT_MCS32(ht_cap->ht_cap.mcs.rx_mask);
+  SETHT_MCS32(ht_cap->mcs.rx_mask);
 
  /* Clear RD responder bit */
  ht_ext_cap &= ~IEEE80211_HT_EXT_CAP_RD_RESPONDER;
 
- ht_cap->ht_cap.cap_info = cpu_to_le16(sband->ht_cap.cap);
- ht_cap->ht_cap.extended_ht_cap_info = cpu_to_le16(ht_ext_cap);
+ ht_cap->cap_info = cpu_to_le16(sband->ht_cap.cap);
+ ht_cap->extended_ht_cap_info = cpu_to_le16(ht_ext_cap);
+
+ if (ISSUPP_BEAMFORMING(priv->adapter->hw_dot_11n_dev_cap))
+  ht_cap->tx_BF_cap_info = cpu_to_le32(MWIFIEX_DEF_11N_TX_BF_CAP);
+
+ return 0;
 }
 
 /*
@@ -150,28 +159,34 @@ int mwifiex_ret_11n_addba_req(struct mwifiex_private *priv,
  int tid;
  struct host_cmd_ds_11n_addba_rsp *add_ba_rsp = &resp->params.add_ba_rsp;
  struct mwifiex_tx_ba_stream_tbl *tx_ba_tbl;
+ u16 block_ack_param_set = le16_to_cpu(add_ba_rsp->block_ack_param_set);
 
  add_ba_rsp->ssn = cpu_to_le16((le16_to_cpu(add_ba_rsp->ssn))
    & SSN_MASK);
 
- tid = (le16_to_cpu(add_ba_rsp->block_ack_param_set)
-  & IEEE80211_ADDBA_PARAM_TID_MASK)
-  >> BLOCKACKPARAM_TID_POS;
- if (le16_to_cpu(add_ba_rsp->status_code) == BA_RESULT_SUCCESS) {
-  tx_ba_tbl = mwifiex_get_ba_tbl(priv, tid,
-      add_ba_rsp->peer_mac_addr);
-  if (tx_ba_tbl) {
-   dev_dbg(priv->adapter->dev, "info: BA stream complete\n");
-   tx_ba_tbl->ba_status = BA_SETUP_COMPLETE;
-  } else {
-   dev_err(priv->adapter->dev, "BA stream not created\n");
-  }
- } else {
+ tid = (block_ack_param_set & IEEE80211_ADDBA_PARAM_TID_MASK)
+        >> BLOCKACKPARAM_TID_POS;
+ if (le16_to_cpu(add_ba_rsp->status_code) != BA_RESULT_SUCCESS) {
   mwifiex_del_ba_tbl(priv, tid, add_ba_rsp->peer_mac_addr,
        TYPE_DELBA_SENT, true);
   if (add_ba_rsp->add_rsp_result != BA_RESULT_TIMEOUT)
    priv->aggr_prio_tbl[tid].ampdu_ap =
     BA_STREAM_NOT_ALLOWED;
+  return 0;
+ }
+
+ tx_ba_tbl = mwifiex_get_ba_tbl(priv, tid, add_ba_rsp->peer_mac_addr);
+ if (tx_ba_tbl) {
+  dev_dbg(priv->adapter->dev, "info: BA stream complete\n");
+  tx_ba_tbl->ba_status = BA_SETUP_COMPLETE;
+  if ((block_ack_param_set & BLOCKACKPARAM_AMSDU_SUPP_MASK) &&
+      priv->add_ba_param.tx_amsdu &&
+      (priv->aggr_prio_tbl[tid].amsdu != BA_STREAM_NOT_ALLOWED))
+   tx_ba_tbl->amsdu = true;
+  else
+   tx_ba_tbl->amsdu = false;
+ } else {
+  dev_err(priv->adapter->dev, "BA stream not created\n");
  }
 
  return 0;
@@ -292,6 +307,7 @@ mwifiex_cmd_append_11n_tlv(struct mwifiex_private *priv,
  struct mwifiex_ie_types_extcap *ext_cap;
  int ret_len = 0;
  struct ieee80211_supported_band *sband;
+ struct ieee_types_header *hdr;
  u8 radio_type;
 
  if (!buffer || !*buffer)
@@ -307,11 +323,10 @@ mwifiex_cmd_append_11n_tlv(struct mwifiex_private *priv,
   ht_cap->header.len =
     cpu_to_le16(sizeof(struct ieee80211_ht_cap));
   memcpy((u8 *) ht_cap + sizeof(struct mwifiex_ie_types_header),
-         (u8 *) bss_desc->bcn_ht_cap +
-         sizeof(struct ieee_types_header),
+         (u8 *)bss_desc->bcn_ht_cap,
          le16_to_cpu(ht_cap->header.len));
 
-  mwifiex_fill_cap_info(priv, radio_type, ht_cap);
+  mwifiex_fill_cap_info(priv, radio_type, &ht_cap->ht_cap);
 
   *buffer += sizeof(struct mwifiex_ie_types_htcap);
   ret_len += sizeof(struct mwifiex_ie_types_htcap);
@@ -330,8 +345,7 @@ mwifiex_cmd_append_11n_tlv(struct mwifiex_private *priv,
 
    memcpy((u8 *) ht_info +
           sizeof(struct mwifiex_ie_types_header),
-          (u8 *) bss_desc->bcn_ht_oper +
-          sizeof(struct ieee_types_header),
+          (u8 *)bss_desc->bcn_ht_oper,
           le16_to_cpu(ht_info->header.len));
 
    if (!(sband->ht_cap.cap &
@@ -388,17 +402,24 @@ mwifiex_cmd_append_11n_tlv(struct mwifiex_private *priv,
  }
 
  if (bss_desc->bcn_ext_cap) {
+  hdr = (void *)bss_desc->bcn_ext_cap;
   ext_cap = (struct mwifiex_ie_types_extcap *) *buffer;
   memset(ext_cap, 0, sizeof(struct mwifiex_ie_types_extcap));
   ext_cap->header.type = cpu_to_le16(WLAN_EID_EXT_CAPABILITY);
-  ext_cap->header.len = cpu_to_le16(sizeof(ext_cap->ext_cap));
+  ext_cap->header.len = cpu_to_le16(hdr->len);
 
-  memcpy((u8 *)ext_cap + sizeof(struct mwifiex_ie_types_header),
+  memcpy((u8 *)ext_cap->ext_capab,
          bss_desc->bcn_ext_cap + sizeof(struct ieee_types_header),
          le16_to_cpu(ext_cap->header.len));
 
-  *buffer += sizeof(struct mwifiex_ie_types_extcap);
-  ret_len += sizeof(struct mwifiex_ie_types_extcap);
+  if (hdr->len > 3 &&
+      ext_cap->ext_capab[3] & WLAN_EXT_CAPA4_INTERWORKING_ENABLED)
+   priv->hs2_enabled = true;
+  else
+   priv->hs2_enabled = false;
+
+  *buffer += sizeof(struct mwifiex_ie_types_extcap) + hdr->len;
+  ret_len += sizeof(struct mwifiex_ie_types_extcap) + hdr->len;
  }
 
  return ret_len;
@@ -475,7 +496,7 @@ mwifiex_get_ba_tbl(struct mwifiex_private *priv, int tid, u8 *ra)
 
  spin_lock_irqsave(&priv->tx_ba_stream_tbl_lock, flags);
  list_for_each_entry(tx_ba_tsr_tbl, &priv->tx_ba_stream_tbl_ptr, list) {
-  if (!memcmp(tx_ba_tsr_tbl->ra, ra, ETH_ALEN) &&
+  if (ether_addr_equal_unaligned(tx_ba_tsr_tbl->ra, ra) &&
       tx_ba_tsr_tbl->tid == tid) {
    spin_unlock_irqrestore(&priv->tx_ba_stream_tbl_lock,
             flags);
@@ -520,16 +541,39 @@ void mwifiex_create_ba_tbl(struct mwifiex_private *priv, u8 *ra, int tid,
 int mwifiex_send_addba(struct mwifiex_private *priv, int tid, u8 *peer_mac)
 {
  struct host_cmd_ds_11n_addba_req add_ba_req;
+ struct mwifiex_sta_node *sta_ptr;
+ u32 tx_win_size = priv->add_ba_param.tx_win_size;
  static u8 dialog_tok;
  int ret;
+ u16 block_ack_param_set;
 
  dev_dbg(priv->adapter->dev, "cmd: %s: tid %d\n", __func__, tid);
 
- add_ba_req.block_ack_param_set = cpu_to_le16(
-  (u16) ((tid << BLOCKACKPARAM_TID_POS) |
-    (priv->add_ba_param.
-     tx_win_size << BLOCKACKPARAM_WINSIZE_POS) |
-    IMMEDIATE_BLOCK_ACK));
+ if ((GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_STA) &&
+     ISSUPP_TDLS_ENABLED(priv->adapter->fw_cap_info) &&
+     priv->adapter->is_hw_11ac_capable &&
+     memcmp(priv->cfg_bssid, peer_mac, ETH_ALEN)) {
+  sta_ptr = mwifiex_get_sta_entry(priv, peer_mac);
+  if (!sta_ptr) {
+   dev_warn(priv->adapter->dev,
+     "BA setup with unknown TDLS peer %pM!\n",
+    peer_mac);
+   return -1;
+  }
+  if (sta_ptr->is_11ac_enabled)
+   tx_win_size = MWIFIEX_11AC_STA_AMPDU_DEF_TXWINSIZE;
+ }
+
+ block_ack_param_set = (u16)((tid << BLOCKACKPARAM_TID_POS) |
+        tx_win_size << BLOCKACKPARAM_WINSIZE_POS |
+        IMMEDIATE_BLOCK_ACK);
+
+ /* enable AMSDU inside AMPDU */
+ if (priv->add_ba_param.tx_amsdu &&
+     (priv->aggr_prio_tbl[tid].amsdu != BA_STREAM_NOT_ALLOWED))
+  block_ack_param_set |= BLOCKACKPARAM_AMSDU_SUPP_MASK;
+
+ add_ba_req.block_ack_param_set = cpu_to_le16(block_ack_param_set);
  add_ba_req.block_ack_tmo = cpu_to_le16((u16)priv->add_ba_param.timeout);
 
  ++dialog_tok;
@@ -541,8 +585,8 @@ int mwifiex_send_addba(struct mwifiex_private *priv, int tid, u8 *peer_mac)
  memcpy(&add_ba_req.peer_mac_addr, peer_mac, ETH_ALEN);
 
  /* We don't wait for the response of this command */
- ret = mwifiex_send_cmd_async(priv, HostCmd_CMD_11N_ADDBA_REQ,
-         0, 0, &add_ba_req);
+ ret = mwifiex_send_cmd(priv, HostCmd_CMD_11N_ADDBA_REQ,
+          0, 0, &add_ba_req, false);
 
  return ret;
 }
@@ -569,8 +613,8 @@ int mwifiex_send_delba(struct mwifiex_private *priv, int tid, u8 *peer_mac,
  memcpy(&delba.peer_mac_addr, peer_mac, ETH_ALEN);
 
  /* We don't wait for the response of this command */
- ret = mwifiex_send_cmd_async(priv, HostCmd_CMD_11N_DELBA,
-         HostCmd_ACT_GEN_SET, 0, &delba);
+ ret = mwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA,
+          HostCmd_ACT_GEN_SET, 0, &delba, false);
 
  return ret;
 }
@@ -644,6 +688,7 @@ int mwifiex_get_tx_ba_stream_tbl(struct mwifiex_private *priv,
   dev_dbg(priv->adapter->dev, "data: %s tid=%d\n",
    __func__, rx_reo_tbl->tid);
   memcpy(rx_reo_tbl->ra, tx_ba_tsr_tbl->ra, ETH_ALEN);
+  rx_reo_tbl->amsdu = tx_ba_tsr_tbl->amsdu;
   rx_reo_tbl++;
   count++;
   if (count >= MWIFIEX_MAX_TX_BASTREAM_SUPPORTED)
@@ -699,5 +744,50 @@ void mwifiex_set_ba_params(struct mwifiex_private *priv)
       MWIFIEX_STA_AMPDU_DEF_RXWINSIZE;
  }
 
+ priv->add_ba_param.tx_amsdu = true;
+ priv->add_ba_param.rx_amsdu = true;
+
  return;
 }
+
+u8 mwifiex_get_sec_chan_offset(int chan)
+{
+ u8 sec_offset;
+
+ switch (chan) {
+ case 36:
+ case 44:
+ case 52:
+ case 60:
+ case 100:
+ case 108:
+ case 116:
+ case 124:
+ case 132:
+ case 140:
+ case 149:
+ case 157:
+  sec_offset = IEEE80211_HT_PARAM_CHA_SEC_ABOVE;
+  break;
+ case 40:
+ case 48:
+ case 56:
+ case 64:
+ case 104:
+ case 112:
+ case 120:
+ case 128:
+ case 136:
+ case 144:
+ case 153:
+ case 161:
+  sec_offset = IEEE80211_HT_PARAM_CHA_SEC_BELOW;
+  break;
+ case 165:
+ default:
+  sec_offset = IEEE80211_HT_PARAM_CHA_SEC_NONE;
+  break;
+ }
+
+ return sec_offset;
+}
diff --git a/drivers/net/wireless/mwifiex/11n.h b/drivers/net/wireless/mwifiex/11n.h
index 375db01..0b73fa0 100644
--- a/drivers/net/wireless/mwifiex/11n.h
+++ b/drivers/net/wireless/mwifiex/11n.h
@@ -34,8 +34,8 @@ int mwifiex_cmd_11n_cfg(struct mwifiex_private *priv,
 int mwifiex_cmd_append_11n_tlv(struct mwifiex_private *priv,
           struct mwifiex_bssdescriptor *bss_desc,
           u8 **buffer);
-void mwifiex_fill_cap_info(struct mwifiex_private *, u8 radio_type,
-      struct mwifiex_ie_types_htcap *);
+int mwifiex_fill_cap_info(struct mwifiex_private *, u8 radio_type,
+     struct ieee80211_ht_cap *);
 int mwifiex_set_get_11n_htcap_cfg(struct mwifiex_private *priv,
       u16 action, int *htcap_cfg);
 void mwifiex_11n_delete_tx_ba_stream_tbl_entry(struct mwifiex_private *priv,
@@ -63,15 +63,48 @@ int mwifiex_cmd_amsdu_aggr_ctrl(struct host_cmd_ds_command *cmd,
     int cmd_action,
     struct mwifiex_ds_11n_amsdu_aggr_ctrl *aa_ctrl);
 void mwifiex_del_tx_ba_stream_tbl_by_ra(struct mwifiex_private *priv, u8 *ra);
+u8 mwifiex_get_sec_chan_offset(int chan);
 
-/*
- * This function checks whether AMPDU is allowed or not for a particular TID.
- */
 static inline u8
-mwifiex_is_ampdu_allowed(struct mwifiex_private *priv, int tid)
+mwifiex_is_station_ampdu_allowed(struct mwifiex_private *priv,
+     struct mwifiex_ra_list_tbl *ptr, int tid)
 {
- return ((priv->aggr_prio_tbl[tid].ampdu_ap != BA_STREAM_NOT_ALLOWED)
-  ? true : false);
+ struct mwifiex_sta_node *node = mwifiex_get_sta_entry(priv, ptr->ra);
+
+ if (unlikely(!node))
+  return false;
+
+ return (node->ampdu_sta[tid] != BA_STREAM_NOT_ALLOWED) ? true : false;
+}
+
+/* This function checks whether AMSDU is allowed for BA stream. */
+static inline u8
+mwifiex_is_amsdu_in_ampdu_allowed(struct mwifiex_private *priv,
+      struct mwifiex_ra_list_tbl *ptr, int tid)
+{
+ struct mwifiex_tx_ba_stream_tbl *tx_tbl;
+
+ tx_tbl = mwifiex_get_ba_tbl(priv, tid, ptr->ra);
+ if (tx_tbl)
+  return tx_tbl->amsdu;
+
+ return false;
+}
+
+/* This function checks whether AMPDU is allowed or not for a particular TID. */
+static inline u8
+mwifiex_is_ampdu_allowed(struct mwifiex_private *priv,
+    struct mwifiex_ra_list_tbl *ptr, int tid)
+{
+ if (GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_UAP) {
+  return mwifiex_is_station_ampdu_allowed(priv, ptr, tid);
+ } else {
+  if (ptr->tdls_link)
+   return mwifiex_is_station_ampdu_allowed(priv, ptr, tid);
+
+  return (priv->aggr_prio_tbl[tid].ampdu_ap !=
+   BA_STREAM_NOT_ALLOWED) ? true : false;
+ }
 }
 
 /*
@@ -165,4 +198,14 @@ static inline int mwifiex_is_sta_11n_enabled(struct mwifiex_private *priv,
 
  return node->is_11n_enabled;
 }
+
+static inline u8
+mwifiex_tdls_peer_11n_enabled(struct mwifiex_private *priv, const u8 *ra)
+{
+ struct mwifiex_sta_node *node = mwifiex_get_sta_entry(priv, ra);
+ if (node)
+  return node->is_11n_enabled;
+
+ return false;
+}
 #endif /* !_MWIFIEX_11N_H_ */
diff --git a/drivers/net/wireless/mwifiex/11n_aggr.c b/drivers/net/wireless/mwifiex/11n_aggr.c
index d69d024..fe0f66f 100644
--- a/drivers/net/wireless/mwifiex/11n_aggr.c
+++ b/drivers/net/wireless/mwifiex/11n_aggr.c
@@ -69,8 +69,9 @@ mwifiex_11n_form_amsdu_pkt(struct sk_buff *skb_aggr,
  memcpy(&tx_header->eth803_hdr, skb_src->data, dt_offset);
 
  /* Copy SNAP header */
- snap.snap_type = *(u16 *) ((u8 *)skb_src->data + dt_offset);
- dt_offset += sizeof(u16);
+ snap.snap_type = ((struct ethhdr *)skb_src->data)->h_proto;
+
+ dt_offset += sizeof(__be16);
 
  memcpy(&tx_header->rfc1042_hdr, &snap, sizeof(struct rfc_1042_hdr));
 
@@ -99,6 +100,7 @@ mwifiex_11n_form_amsdu_txpd(struct mwifiex_private *priv,
        struct sk_buff *skb)
 {
  struct txpd *local_tx_pd;
+ struct mwifiex_txinfo *tx_info = MWIFIEX_SKB_TXCB(skb);
 
  skb_push(skb, sizeof(*local_tx_pd));
 
@@ -117,6 +119,9 @@ mwifiex_11n_form_amsdu_txpd(struct mwifiex_private *priv,
  local_tx_pd->tx_pkt_length = cpu_to_le16(skb->len -
        sizeof(*local_tx_pd));
 
+ if (tx_info->flags & MWIFIEX_BUF_FLAG_TDLS_PKT)
+  local_tx_pd->flags |= MWIFIEX_TXPD_FLAGS_TDLS_PACKET;
+
  if (local_tx_pd->tx_control == 0)
   /* TxCtrl set by user or default */
   local_tx_pd->tx_control = cpu_to_le32(priv->pkt_tx_ctrl);
@@ -159,6 +164,7 @@ mwifiex_11n_aggregate_pkt(struct mwifiex_private *priv,
  int pad = 0, ret;
  struct mwifiex_tx_param tx_param;
  struct txpd *ptx_pd = NULL;
+ struct timeval tv;
  int headroom = adapter->iface_type == MWIFIEX_USB ? 0 : INTF_HEADER_LEN;
 
  skb_src = skb_peek(&pra_list->skb_head);
@@ -179,10 +185,17 @@ mwifiex_11n_aggregate_pkt(struct mwifiex_private *priv,
  skb_reserve(skb_aggr, headroom + sizeof(struct txpd));
  tx_info_aggr =  MWIFIEX_SKB_TXCB(skb_aggr);
 
+ memset(tx_info_aggr, 0, sizeof(*tx_info_aggr));
  tx_info_aggr->bss_type = tx_info_src->bss_type;
  tx_info_aggr->bss_num = tx_info_src->bss_num;
+
+ if (tx_info_src->flags & MWIFIEX_BUF_FLAG_TDLS_PKT)
+  tx_info_aggr->flags |= MWIFIEX_BUF_FLAG_TDLS_PKT;
  skb_aggr->priority = skb_src->priority;
 
+ do_gettimeofday(&tv);
+ skb_aggr->tstamp = timeval_to_ktime(tv);
+
  do {
   /* Check if AMSDU can accommodate this MSDU */
   if (skb_tailroom(skb_aggr) < (skb_src->len + LLC_SNAP_LEN))
@@ -190,7 +203,7 @@ mwifiex_11n_aggregate_pkt(struct mwifiex_private *priv,
 
   skb_src = skb_dequeue(&pra_list->skb_head);
 
-  pra_list->total_pkts_size -= skb_src->len;
+  pra_list->total_pkt_count--;
 
   atomic_dec(&priv->wmm.tx_pkts_queued);
 
@@ -235,18 +248,11 @@ mwifiex_11n_aggregate_pkt(struct mwifiex_private *priv,
   ret = adapter->if_ops.host_to_card(adapter, MWIFIEX_USB_EP_DATA,
          skb_aggr, NULL);
  } else {
-  /*
-   * Padding per MSDU will affect the length of next
-   * packet and hence the exact length of next packet
-   * is uncertain here.
-   *
-   * Also, aggregation of transmission buffer, while
-   * downloading the data to the card, wont gain much
-   * on the AMSDU packets as the AMSDU packets utilizes
-   * the transmission buffer space to the maximum
-   * (adapter->tx_buf_size).
-   */
-  tx_param.next_pkt_len = 0;
+  if (skb_src)
+   tx_param.next_pkt_len =
+     skb_src->len + sizeof(struct txpd);
+  else
+   tx_param.next_pkt_len = 0;
 
   ret = adapter->if_ops.host_to_card(adapter, MWIFIEX_TYPE_DATA,
          skb_aggr, &tx_param);
@@ -269,7 +275,7 @@ mwifiex_11n_aggregate_pkt(struct mwifiex_private *priv,
 
   skb_queue_tail(&pra_list->skb_head, skb_aggr);
 
-  pra_list->total_pkts_size += skb_aggr->len;
+  pra_list->total_pkt_count++;
 
   atomic_inc(&priv->wmm.tx_pkts_queued);
 
diff --git a/drivers/net/wireless/mwifiex/11n_rxreorder.c b/drivers/net/wireless/mwifiex/11n_rxreorder.c
index ada809f..0c3571f 100644
--- a/drivers/net/wireless/mwifiex/11n_rxreorder.c
+++ b/drivers/net/wireless/mwifiex/11n_rxreorder.c
@@ -26,6 +26,56 @@
 #include "11n.h"
 #include "11n_rxreorder.h"
 
+/* This function will dispatch amsdu packet and forward it to kernel/upper
+ * layer.
+ */
+static int mwifiex_11n_dispatch_amsdu_pkt(struct mwifiex_private *priv,
+       struct sk_buff *skb)
+{
+ struct rxpd *local_rx_pd = (struct rxpd *)(skb->data);
+ int ret;
+
+ if (le16_to_cpu(local_rx_pd->rx_pkt_type) == PKT_TYPE_AMSDU) {
+  struct sk_buff_head list;
+  struct sk_buff *rx_skb;
+
+  __skb_queue_head_init(&list);
+
+  skb_pull(skb, le16_to_cpu(local_rx_pd->rx_pkt_offset));
+  skb_trim(skb, le16_to_cpu(local_rx_pd->rx_pkt_length));
+
+  ieee80211_amsdu_to_8023s(skb, &list, priv->curr_addr,
+      priv->wdev->iftype, 0, false);
+
+  while (!skb_queue_empty(&list)) {
+   rx_skb = __skb_dequeue(&list);
+   ret = mwifiex_recv_packet(priv, rx_skb);
+   if (ret == -1)
+    dev_err(priv->adapter->dev,
+     "Rx of A-MSDU failed");
+  }
+  return 0;
+ }
+
+ return -1;
+}
+
+/* This function will process the rx packet and forward it to kernel/upper
+ * layer.
+ */
+static int mwifiex_11n_dispatch_pkt(struct mwifiex_private *priv, void *payload)
+{
+ int ret = mwifiex_11n_dispatch_amsdu_pkt(priv, payload);
+
+ if (!ret)
+  return 0;
+
+ if (priv->bss_role == MWIFIEX_BSS_ROLE_UAP)
+  return mwifiex_handle_uap_rx_forward(priv, payload);
+
+ return mwifiex_process_rx_packet(priv, payload);
+}
+
 /*
  * This function dispatches all packets in the Rx reorder table until the
  * start window.
@@ -35,8 +85,9 @@
  * circular buffer.
  */
 static void
-mwifiex_11n_dispatch_pkt(struct mwifiex_private *priv,
-    struct mwifiex_rx_reorder_tbl *tbl, int start_win)
+mwifiex_11n_dispatch_pkt_until_start_win(struct mwifiex_private *priv,
+      struct mwifiex_rx_reorder_tbl *tbl,
+      int start_win)
 {
  int pkt_to_send, i;
  void *rx_tmp_ptr;
@@ -54,12 +105,8 @@ mwifiex_11n_dispatch_pkt(struct mwifiex_private *priv,
    tbl->rx_reorder_ptr[i] = NULL;
   }
   spin_unlock_irqrestore(&priv->rx_pkt_lock, flags);
-  if (rx_tmp_ptr) {
-   if (priv->bss_role == MWIFIEX_BSS_ROLE_UAP)
-    mwifiex_handle_uap_rx_forward(priv, rx_tmp_ptr);
-   else
-    mwifiex_process_rx_packet(priv, rx_tmp_ptr);
-  }
+  if (rx_tmp_ptr)
+   mwifiex_11n_dispatch_pkt(priv, rx_tmp_ptr);
  }
 
  spin_lock_irqsave(&priv->rx_pkt_lock, flags);
@@ -101,11 +148,7 @@ mwifiex_11n_scan_and_dispatch(struct mwifiex_private *priv,
   rx_tmp_ptr = tbl->rx_reorder_ptr[i];
   tbl->rx_reorder_ptr[i] = NULL;
   spin_unlock_irqrestore(&priv->rx_pkt_lock, flags);
-
-  if (priv->bss_role == MWIFIEX_BSS_ROLE_UAP)
-   mwifiex_handle_uap_rx_forward(priv, rx_tmp_ptr);
-  else
-   mwifiex_process_rx_packet(priv, rx_tmp_ptr);
+  mwifiex_11n_dispatch_pkt(priv, rx_tmp_ptr);
  }
 
  spin_lock_irqsave(&priv->rx_pkt_lock, flags);
@@ -135,14 +178,15 @@ mwifiex_del_rx_reorder_entry(struct mwifiex_private *priv,
         struct mwifiex_rx_reorder_tbl *tbl)
 {
  unsigned long flags;
+ int start_win;
 
  if (!tbl)
   return;
 
- mwifiex_11n_dispatch_pkt(priv, tbl, (tbl->start_win + tbl->win_size) &
-         (MAX_TID_VALUE - 1));
+ start_win = (tbl->start_win + tbl->win_size) & (MAX_TID_VALUE - 1);
+ mwifiex_11n_dispatch_pkt_until_start_win(priv, tbl, start_win);
 
- del_timer(&tbl->timer_context.timer);
+ del_timer_sync(&tbl->timer_context.timer);
 
  spin_lock_irqsave(&priv->rx_reorder_tbl_lock, flags);
  list_del(&tbl->list);
@@ -228,17 +272,17 @@ mwifiex_flush_data(unsigned long context)
 {
  struct reorder_tmr_cnxt *ctx =
   (struct reorder_tmr_cnxt *) context;
- int start_win;
+ int start_win, seq_num;
 
- start_win = mwifiex_11n_find_last_seq_num(ctx->ptr);
+ seq_num = mwifiex_11n_find_last_seq_num(ctx->ptr);
 
- if (start_win < 0)
+ if (seq_num < 0)
   return;
 
- dev_dbg(ctx->priv->adapter->dev, "info: flush data %d\n", start_win);
- mwifiex_11n_dispatch_pkt(ctx->priv, ctx->ptr,
-     (ctx->ptr->start_win + start_win + 1) &
-     (MAX_TID_VALUE - 1));
+ dev_dbg(ctx->priv->adapter->dev, "info: flush data %d\n", seq_num);
+ start_win = (ctx->ptr->start_win + seq_num + 1) & (MAX_TID_VALUE - 1);
+ mwifiex_11n_dispatch_pkt_until_start_win(ctx->priv, ctx->ptr,
+       start_win);
 }
 
 /*
@@ -267,7 +311,7 @@ mwifiex_11n_create_rx_reorder_tbl(struct mwifiex_private *priv, u8 *ta,
   */
  tbl = mwifiex_11n_get_rx_reorder_tbl(priv, tid, ta);
  if (tbl) {
-  mwifiex_11n_dispatch_pkt(priv, tbl, seq_num);
+  mwifiex_11n_dispatch_pkt_until_start_win(priv, tbl, seq_num);
   return;
  }
  /* if !tbl then create one */
@@ -279,6 +323,8 @@ mwifiex_11n_create_rx_reorder_tbl(struct mwifiex_private *priv, u8 *ta,
  new_node->tid = tid;
  memcpy(new_node->ta, ta, ETH_ALEN);
  new_node->start_win = seq_num;
+ new_node->init_win = seq_num;
+ new_node->flags = 0;
 
  if (mwifiex_queuing_ra_based(priv)) {
   dev_dbg(priv->adapter->dev,
@@ -290,15 +336,20 @@ mwifiex_11n_create_rx_reorder_tbl(struct mwifiex_private *priv, u8 *ta,
     last_seq = node->rx_seq[tid];
   }
  } else {
-  last_seq = priv->rx_seq[tid];
+  node = mwifiex_get_sta_entry(priv, ta);
+  if (node)
+   last_seq = node->rx_seq[tid];
+  else
+   last_seq = priv->rx_seq[tid];
  }
 
  if (last_seq != MWIFIEX_DEF_11N_RX_SEQ_NUM &&
-     last_seq >= new_node->start_win)
+     last_seq >= new_node->start_win) {
   new_node->start_win = last_seq + 1;
+  new_node->flags |= RXREOR_INIT_WINDOW_SHIFT;
+ }
 
  new_node->win_size = win_size;
- new_node->flags = 0;
 
  new_node->rx_reorder_ptr = kzalloc(sizeof(void *) * win_size,
      GFP_KERNEL);
@@ -358,10 +409,28 @@ int mwifiex_cmd_11n_addba_rsp_gen(struct mwifiex_private *priv,
       *cmd_addba_req)
 {
  struct host_cmd_ds_11n_addba_rsp *add_ba_rsp = &cmd->params.add_ba_rsp;
+ struct mwifiex_sta_node *sta_ptr;
+ u32 rx_win_size = priv->add_ba_param.rx_win_size;
  u8 tid;
  int win_size;
  uint16_t block_ack_param_set;
 
+ if ((GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_STA) &&
+     ISSUPP_TDLS_ENABLED(priv->adapter->fw_cap_info) &&
+     priv->adapter->is_hw_11ac_capable &&
+     memcmp(priv->cfg_bssid, cmd_addba_req->peer_mac_addr, ETH_ALEN)) {
+  sta_ptr = mwifiex_get_sta_entry(priv,
+      cmd_addba_req->peer_mac_addr);
+  if (!sta_ptr) {
+   dev_warn(priv->adapter->dev,
+     "BA setup with unknown TDLS peer %pM!\n",
+     cmd_addba_req->peer_mac_addr);
+   return -1;
+  }
+  if (sta_ptr->is_11ac_enabled)
+   rx_win_size = MWIFIEX_11AC_STA_AMPDU_DEF_RXWINSIZE;
+ }
+
  cmd->command = cpu_to_le16(HostCmd_CMD_11N_ADDBA_RSP);
  cmd->size = cpu_to_le16(sizeof(*add_ba_rsp) + S_DS_GEN);
 
@@ -376,10 +445,12 @@ int mwifiex_cmd_11n_addba_rsp_gen(struct mwifiex_private *priv,
   >> BLOCKACKPARAM_TID_POS;
  add_ba_rsp->status_code = cpu_to_le16(ADDBA_RSP_STATUS_ACCEPT);
  block_ack_param_set &= ~IEEE80211_ADDBA_PARAM_BUF_SIZE_MASK;
- /* We donot support AMSDU inside AMPDU, hence reset the bit */
- block_ack_param_set &= ~BLOCKACKPARAM_AMSDU_SUPP_MASK;
- block_ack_param_set |= (priv->add_ba_param.rx_win_size <<
-          BLOCKACKPARAM_WINSIZE_POS);
+
+ /* If we don't support AMSDU inside AMPDU, reset the bit */
+ if (!priv->add_ba_param.rx_amsdu ||
+     (priv->aggr_prio_tbl[tid].amsdu == BA_STREAM_NOT_ALLOWED))
+  block_ack_param_set &= ~BLOCKACKPARAM_AMSDU_SUPP_MASK;
+ block_ack_param_set |= rx_win_size << BLOCKACKPARAM_WINSIZE_POS;
  add_ba_rsp->block_ack_param_set = cpu_to_le16(block_ack_param_set);
  win_size = (le16_to_cpu(add_ba_rsp->block_ack_param_set)
      & IEEE80211_ADDBA_PARAM_BUF_SIZE_MASK)
@@ -431,33 +502,46 @@ int mwifiex_11n_rx_reorder_pkt(struct mwifiex_private *priv,
  struct mwifiex_rx_reorder_tbl *tbl;
  int start_win, end_win, win_size;
  u16 pkt_index;
+ bool init_window_shift = false;
 
  tbl = mwifiex_11n_get_rx_reorder_tbl(priv, tid, ta);
  if (!tbl) {
-  if (pkt_type != PKT_TYPE_BAR) {
-   if (priv->bss_role == MWIFIEX_BSS_ROLE_UAP)
-    mwifiex_handle_uap_rx_forward(priv, payload);
-   else
-    mwifiex_process_rx_packet(priv, payload);
-  }
+  if (pkt_type != PKT_TYPE_BAR)
+   mwifiex_11n_dispatch_pkt(priv, payload);
   return 0;
  }
+
+ if ((pkt_type == PKT_TYPE_AMSDU) && !tbl->amsdu) {
+  mwifiex_11n_dispatch_pkt(priv, payload);
+  return 0;
+ }
+
  start_win = tbl->start_win;
  win_size = tbl->win_size;
  end_win = ((start_win + win_size) - 1) & (MAX_TID_VALUE - 1);
- del_timer(&tbl->timer_context.timer);
+ if (tbl->flags & RXREOR_INIT_WINDOW_SHIFT) {
+  init_window_shift = true;
+  tbl->flags &= ~RXREOR_INIT_WINDOW_SHIFT;
+ }
  mod_timer(&tbl->timer_context.timer,
     jiffies + msecs_to_jiffies(MIN_FLUSH_TIMER_MS * win_size));
 
- /*
-  * If seq_num is less then starting win then ignore and drop the
-  * packet
-  */
  if (tbl->flags & RXREOR_FORCE_NO_DROP) {
   dev_dbg(priv->adapter->dev,
    "RXREOR_FORCE_NO_DROP when HS is activated\n");
   tbl->flags &= ~RXREOR_FORCE_NO_DROP;
+ } else if (init_window_shift && seq_num < start_win &&
+     seq_num >= tbl->init_win) {
+  dev_dbg(priv->adapter->dev,
+   "Sender TID sequence number reset %d->%d for SSN %d\n",
+   start_win, seq_num, tbl->init_win);
+  tbl->start_win = start_win = seq_num;
+  end_win = ((start_win + win_size) - 1) & (MAX_TID_VALUE - 1);
  } else {
+  /*
+   * If seq_num is less then starting win then ignore and drop
+   * the packet
+   */
   if ((start_win + TWOPOW11) > (MAX_TID_VALUE - 1)) {
    if (seq_num >= ((start_win + TWOPOW11) &
      (MAX_TID_VALUE - 1)) &&
@@ -485,7 +569,7 @@ int mwifiex_11n_rx_reorder_pkt(struct mwifiex_private *priv,
    start_win = (end_win - win_size) + 1;
   else
    start_win = (MAX_TID_VALUE - (win_size - seq_num)) + 1;
-  mwifiex_11n_dispatch_pkt(priv, tbl, start_win);
+  mwifiex_11n_dispatch_pkt_until_start_win(priv, tbl, start_win);
  }
 
  if (pkt_type != PKT_TYPE_BAR) {
@@ -576,16 +660,7 @@ int mwifiex_ret_11n_addba_resp(struct mwifiex_private *priv,
   * Check if we had rejected the ADDBA, if yes then do not create
   * the stream
   */
- if (le16_to_cpu(add_ba_rsp->status_code) == BA_RESULT_SUCCESS) {
-  win_size = (block_ack_param_set &
-   IEEE80211_ADDBA_PARAM_BUF_SIZE_MASK)
-   >> BLOCKACKPARAM_WINSIZE_POS;
-
-  dev_dbg(priv->adapter->dev,
-   "cmd: ADDBA RSP: %pM tid=%d ssn=%d win_size=%d\n",
-   add_ba_rsp->peer_mac_addr, tid,
-   add_ba_rsp->ssn, win_size);
- } else {
+ if (le16_to_cpu(add_ba_rsp->status_code) != BA_RESULT_SUCCESS) {
   dev_err(priv->adapter->dev, "ADDBA RSP: failed %pM tid=%d)\n",
    add_ba_rsp->peer_mac_addr, tid);
 
@@ -593,8 +668,28 @@ int mwifiex_ret_11n_addba_resp(struct mwifiex_private *priv,
            add_ba_rsp->peer_mac_addr);
   if (tbl)
    mwifiex_del_rx_reorder_entry(priv, tbl);
+
+  return 0;
  }
 
+ win_size = (block_ack_param_set & IEEE80211_ADDBA_PARAM_BUF_SIZE_MASK)
+      >> BLOCKACKPARAM_WINSIZE_POS;
+
+ tbl = mwifiex_11n_get_rx_reorder_tbl(priv, tid,
+          add_ba_rsp->peer_mac_addr);
+ if (tbl) {
+  if ((block_ack_param_set & BLOCKACKPARAM_AMSDU_SUPP_MASK) &&
+      priv->add_ba_param.rx_amsdu &&
+      (priv->aggr_prio_tbl[tid].amsdu != BA_STREAM_NOT_ALLOWED))
+   tbl->amsdu = true;
+  else
+   tbl->amsdu = false;
+ }
+
+ dev_dbg(priv->adapter->dev,
+  "cmd: ADDBA RSP: %pM tid=%d ssn=%d win_size=%d\n",
+  add_ba_rsp->peer_mac_addr, tid, add_ba_rsp->ssn, win_size);
+
  return 0;
 }
 
@@ -615,7 +710,7 @@ void mwifiex_11n_ba_stream_timeout(struct mwifiex_private *priv,
  delba.del_ba_param_set |= cpu_to_le16(
   (u16) event->origninator << DELBA_INITIATOR_POS);
  delba.reason_code = cpu_to_le16(WLAN_REASON_QSTA_TIMEOUT);
- mwifiex_send_cmd_async(priv, HostCmd_CMD_11N_DELBA, 0, 0, &delba);
+ mwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA, 0, 0, &delba, false);
 }
 
 /*
diff --git a/drivers/net/wireless/mwifiex/11n_rxreorder.h b/drivers/net/wireless/mwifiex/11n_rxreorder.h
index 4064041..0fc76e4 100644
--- a/drivers/net/wireless/mwifiex/11n_rxreorder.h
+++ b/drivers/net/wireless/mwifiex/11n_rxreorder.h
@@ -42,7 +42,8 @@
 #define BA_SETUP_PACKET_OFFSET  16
 
 enum mwifiex_rxreor_flags {
- RXREOR_FORCE_NO_DROP = 1<<0,
+ RXREOR_FORCE_NO_DROP  = 1<<0,
+ RXREOR_INIT_WINDOW_SHIFT = 1<<1,
 };
 
 static inline void mwifiex_reset_11n_rx_seq_num(struct mwifiex_private *priv)
diff --git a/drivers/net/wireless/mwifiex/Kconfig b/drivers/net/wireless/mwifiex/Kconfig
index 4f614aa..ecdf345 100644
--- a/drivers/net/wireless/mwifiex/Kconfig
+++ b/drivers/net/wireless/mwifiex/Kconfig
@@ -3,13 +3,13 @@ config MWIFIEX
  depends on CFG80211
  ---help---
    This adds support for wireless adapters based on Marvell
-   802.11n chipsets.
+   802.11n/ac chipsets.
 
    If you choose to build it as a module, it will be called
    mwifiex.
 
 config MWIFIEX_SDIO
- tristate "Marvell WiFi-Ex Driver for SD8786/SD8787/SD8797"
+ tristate "Marvell WiFi-Ex Driver for SD8786/SD8787/SD8797/SD8897"
  depends on MWIFIEX && MMC
  select FW_LOADER
  ---help---
@@ -31,12 +31,12 @@ config MWIFIEX_PCIE
    mwifiex_pcie.
 
 config MWIFIEX_USB
- tristate "Marvell WiFi-Ex Driver for USB8797"
+ tristate "Marvell WiFi-Ex Driver for USB8797/8897"
  depends on MWIFIEX && USB
  select FW_LOADER
  ---help---
    This adds support for wireless adapters based on Marvell
-   Avastar 88W8797 chipset with USB interface.
+   8797/8897 chipset with USB interface.
 
    If you choose to build it as a module, it will be called
    mwifiex_usb.
diff --git a/drivers/net/wireless/mwifiex/Makefile b/drivers/net/wireless/mwifiex/Makefile
index ecf2846..2aa208f 100644
--- a/drivers/net/wireless/mwifiex/Makefile
+++ b/drivers/net/wireless/mwifiex/Makefile
@@ -40,6 +40,8 @@ mwifiex-y += sta_rx.o
 mwifiex-y += uap_txrx.o
 mwifiex-y += cfg80211.o
 mwifiex-y += ethtool.o
+mwifiex-y += 11h.o
+mwifiex-y += tdls.o
 mwifiex-$(CONFIG_DEBUG_FS) += debugfs.o
 obj-$(CONFIG_MWIFIEX) += mwifiex.o
 
diff --git a/drivers/net/wireless/mwifiex/README b/drivers/net/wireless/mwifiex/README
index 3d64613..3b55ce5 100644
--- a/drivers/net/wireless/mwifiex/README
+++ b/drivers/net/wireless/mwifiex/README
@@ -131,7 +131,7 @@ info
  hs_configured = <0/1, host sleep not configured/configured>
  hs_activated = <0/1, extended host sleep not activated/activated>
  num_tx_timeout = <number of Tx timeout>
- num_cmd_timeout = <number of timeout commands>
+ is_cmd_timedout = <0/1 command timeout not occurred/occurred>
  timeout_cmd_id = <command id of the last timeout command>
  timeout_cmd_act = <command action of the last timeout command>
  last_cmd_id = <command id of the last several commands sent to device>
@@ -200,4 +200,11 @@ getlog
 
  cat getlog
 
+fw_dump
+ This command is used to dump firmware memory into files.
+ Separate file will be created for each memory segment.
+ Usage:
+
+ cat fw_dump
+
 ===============================================================================
diff --git a/drivers/net/wireless/mwifiex/cfg80211.c b/drivers/net/wireless/mwifiex/cfg80211.c
index e7f7cdf..b511613 100644
--- a/drivers/net/wireless/mwifiex/cfg80211.c
+++ b/drivers/net/wireless/mwifiex/cfg80211.c
@@ -20,9 +20,14 @@
 #include "cfg80211.h"
 #include "main.h"
 
+static char *reg_alpha2;
+module_param(reg_alpha2, charp, 0);
+
 static const struct ieee80211_iface_limit mwifiex_ap_sta_limits[] = {
  {
-  .max = 2, .types = BIT(NL80211_IFTYPE_STATION),
+  .max = 2, .types = BIT(NL80211_IFTYPE_STATION) |
+       BIT(NL80211_IFTYPE_P2P_GO) |
+       BIT(NL80211_IFTYPE_P2P_CLIENT),
  },
  {
   .max = 1, .types = BIT(NL80211_IFTYPE_AP),
@@ -45,24 +50,24 @@ static const struct ieee80211_regdomain mwifiex_world_regdom_custom = {
   REG_RULE(2412-10, 2462+10, 40, 3, 20, 0),
   /* Channel 12 - 13 */
   REG_RULE(2467-10, 2472+10, 20, 3, 20,
-    NL80211_RRF_PASSIVE_SCAN | NL80211_RRF_NO_IBSS),
+    NL80211_RRF_NO_IR),
   /* Channel 14 */
   REG_RULE(2484-10, 2484+10, 20, 3, 20,
-    NL80211_RRF_PASSIVE_SCAN | NL80211_RRF_NO_IBSS |
+    NL80211_RRF_NO_IR |
     NL80211_RRF_NO_OFDM),
   /* Channel 36 - 48 */
   REG_RULE(5180-10, 5240+10, 40, 3, 20,
-    NL80211_RRF_PASSIVE_SCAN | NL80211_RRF_NO_IBSS),
+    NL80211_RRF_NO_IR),
   /* Channel 149 - 165 */
   REG_RULE(5745-10, 5825+10, 40, 3, 20,
-    NL80211_RRF_PASSIVE_SCAN | NL80211_RRF_NO_IBSS),
+    NL80211_RRF_NO_IR),
   /* Channel 52 - 64 */
   REG_RULE(5260-10, 5320+10, 40, 3, 30,
-    NL80211_RRF_PASSIVE_SCAN | NL80211_RRF_NO_IBSS |
+    NL80211_RRF_NO_IR |
     NL80211_RRF_DFS),
   /* Channel 100 - 140 */
   REG_RULE(5500-10, 5700+10, 40, 3, 30,
-    NL80211_RRF_PASSIVE_SCAN | NL80211_RRF_NO_IBSS |
+    NL80211_RRF_NO_IR |
     NL80211_RRF_DFS),
  }
 };
@@ -179,13 +184,14 @@ mwifiex_form_mgmt_frame(struct sk_buff *skb, const u8 *buf, size_t len)
  */
 static int
 mwifiex_cfg80211_mgmt_tx(struct wiphy *wiphy, struct wireless_dev *wdev,
-    struct ieee80211_channel *chan, bool offchan,
-    unsigned int wait, const u8 *buf, size_t len,
-    bool no_cck, bool dont_wait_for_ack, u64 *cookie)
+    struct cfg80211_mgmt_tx_params *params, u64 *cookie)
 {
+ const u8 *buf = params->buf;
+ size_t len = params->len;
  struct sk_buff *skb;
  u16 pkt_len;
  const struct ieee80211_mgmt *mgmt;
+ struct mwifiex_txinfo *tx_info;
  struct mwifiex_private *priv = mwifiex_netdev_get_priv(wdev->netdev);
 
  if (!buf || !len) {
@@ -213,6 +219,12 @@ mwifiex_cfg80211_mgmt_tx(struct wiphy *wiphy, struct wireless_dev *wdev,
   return -ENOMEM;
  }
 
+ tx_info = MWIFIEX_SKB_TXCB(skb);
+ memset(tx_info, 0, sizeof(*tx_info));
+ tx_info->bss_num = priv->bss_num;
+ tx_info->bss_type = priv->bss_type;
+ tx_info->pkt_len = pkt_len;
+
  mwifiex_form_mgmt_frame(skb, buf, len);
  mwifiex_queue_tx_pkt(priv, skb);
 
@@ -232,16 +244,20 @@ mwifiex_cfg80211_mgmt_frame_register(struct wiphy *wiphy,
          u16 frame_type, bool reg)
 {
  struct mwifiex_private *priv = mwifiex_netdev_get_priv(wdev->netdev);
+ u32 mask;
 
  if (reg)
-  priv->mgmt_frame_mask |= BIT(frame_type >> 4);
+  mask = priv->mgmt_frame_mask | BIT(frame_type >> 4);
  else
-  priv->mgmt_frame_mask &= ~BIT(frame_type >> 4);
-
- mwifiex_send_cmd_async(priv, HostCmd_CMD_MGMT_FRAME_REG,
-          HostCmd_ACT_GEN_SET, 0, &priv->mgmt_frame_mask);
+  mask = priv->mgmt_frame_mask & ~BIT(frame_type >> 4);
 
- wiphy_dbg(wiphy, "info: mgmt frame registered\n");
+ if (mask != priv->mgmt_frame_mask) {
+  priv->mgmt_frame_mask = mask;
+  mwifiex_send_cmd(priv, HostCmd_CMD_MGMT_FRAME_REG,
+     HostCmd_ACT_GEN_SET, 0,
+     &priv->mgmt_frame_mask, false);
+  wiphy_dbg(wiphy, "info: mgmt frame registered\n");
+ }
 }
 
 /*
@@ -500,8 +516,8 @@ static int mwifiex_send_domain_info_cmd_fw(struct wiphy *wiphy)
 
  priv = mwifiex_get_priv(adapter, MWIFIEX_BSS_ROLE_ANY);
 
- if (mwifiex_send_cmd_async(priv, HostCmd_CMD_802_11D_DOMAIN_INFO,
-       HostCmd_ACT_GEN_SET, 0, NULL)) {
+ if (mwifiex_send_cmd(priv, HostCmd_CMD_802_11D_DOMAIN_INFO,
+        HostCmd_ACT_GEN_SET, 0, NULL, false)) {
   wiphy_err(wiphy, "11D: setting domain info in FW\n");
   return -1;
  }
@@ -523,23 +539,33 @@ static void mwifiex_reg_notifier(struct wiphy *wiphy,
      struct regulatory_request *request)
 {
  struct mwifiex_adapter *adapter = mwifiex_cfg80211_get_adapter(wiphy);
+ struct mwifiex_private *priv = mwifiex_get_priv(adapter,
+       MWIFIEX_BSS_ROLE_ANY);
 
  wiphy_dbg(wiphy, "info: cfg80211 regulatory domain callback for %c%c\n",
     request->alpha2[0], request->alpha2[1]);
 
- memcpy(adapter->country_code, request->alpha2, sizeof(request->alpha2));
-
  switch (request->initiator) {
  case NL80211_REGDOM_SET_BY_DRIVER:
  case NL80211_REGDOM_SET_BY_CORE:
  case NL80211_REGDOM_SET_BY_USER:
-  break;
-  /* Todo: apply driver specific changes in channel flags based
-     on the request initiator if necessary. */
  case NL80211_REGDOM_SET_BY_COUNTRY_IE:
   break;
+ default:
+  wiphy_err(wiphy, "unknown regdom initiator: %d\n",
+     request->initiator);
+  return;
+ }
+
+ /* Don't send world or same regdom info to firmware */
+ if (strncmp(request->alpha2, "00", 2) &&
+     strncmp(request->alpha2, adapter->country_code,
+      sizeof(request->alpha2))) {
+  memcpy(adapter->country_code, request->alpha2,
+         sizeof(request->alpha2));
+  mwifiex_send_domain_info_cmd_fw(wiphy);
+  mwifiex_dnld_txpwr_table(priv);
  }
- mwifiex_send_domain_info_cmd_fw(wiphy);
 }
 
 /*
@@ -555,9 +581,9 @@ mwifiex_set_frag(struct mwifiex_private *priv, u32 frag_thr)
      frag_thr > MWIFIEX_FRAG_MAX_VALUE)
   frag_thr = MWIFIEX_FRAG_MAX_VALUE;
 
- return mwifiex_send_cmd_sync(priv, HostCmd_CMD_802_11_SNMP_MIB,
-         HostCmd_ACT_GEN_SET, FRAG_THRESH_I,
-         &frag_thr);
+ return mwifiex_send_cmd(priv, HostCmd_CMD_802_11_SNMP_MIB,
+    HostCmd_ACT_GEN_SET, FRAG_THRESH_I,
+    &frag_thr, true);
 }
 
 /*
@@ -572,9 +598,9 @@ mwifiex_set_rts(struct mwifiex_private *priv, u32 rts_thr)
  if (rts_thr < MWIFIEX_RTS_MIN_VALUE || rts_thr > MWIFIEX_RTS_MAX_VALUE)
   rts_thr = MWIFIEX_RTS_MAX_VALUE;
 
- return mwifiex_send_cmd_sync(priv, HostCmd_CMD_802_11_SNMP_MIB,
-        HostCmd_ACT_GEN_SET, RTS_THRESH_I,
-        &rts_thr);
+ return mwifiex_send_cmd(priv, HostCmd_CMD_802_11_SNMP_MIB,
+    HostCmd_ACT_GEN_SET, RTS_THRESH_I,
+    &rts_thr, true);
 }
 
 /*
@@ -612,20 +638,19 @@ mwifiex_cfg80211_set_wiphy_params(struct wiphy *wiphy, u32 changed)
 
    bss_started = priv->bss_started;
 
-   ret = mwifiex_send_cmd_sync(priv,
-          HostCmd_CMD_UAP_BSS_STOP,
-          HostCmd_ACT_GEN_SET, 0,
-          NULL);
+   ret = mwifiex_send_cmd(priv, HostCmd_CMD_UAP_BSS_STOP,
+            HostCmd_ACT_GEN_SET, 0,
+            NULL, true);
    if (ret) {
     wiphy_err(wiphy, "Failed to stop the BSS\n");
     kfree(bss_cfg);
     return ret;
    }
 
-   ret = mwifiex_send_cmd_async(priv,
-           HostCmd_CMD_UAP_SYS_CONFIG,
-           HostCmd_ACT_GEN_SET,
-           UAP_BSS_PARAMS_I, bss_cfg);
+   ret = mwifiex_send_cmd(priv, HostCmd_CMD_UAP_SYS_CONFIG,
+            HostCmd_ACT_GEN_SET,
+            UAP_BSS_PARAMS_I, bss_cfg,
+            false);
 
    kfree(bss_cfg);
 
@@ -637,10 +662,9 @@ mwifiex_cfg80211_set_wiphy_params(struct wiphy *wiphy, u32 changed)
    if (!bss_started)
     break;
 
-   ret = mwifiex_send_cmd_async(priv,
-           HostCmd_CMD_UAP_BSS_START,
-           HostCmd_ACT_GEN_SET, 0,
-           NULL);
+   ret = mwifiex_send_cmd(priv, HostCmd_CMD_UAP_BSS_START,
+            HostCmd_ACT_GEN_SET, 0,
+            NULL, false);
    if (ret) {
     wiphy_err(wiphy, "Failed to start BSS\n");
     return ret;
@@ -675,8 +699,8 @@ mwifiex_cfg80211_deinit_p2p(struct mwifiex_private *priv)
  if (GET_BSS_ROLE(priv) != MWIFIEX_BSS_ROLE_STA)
   mwifiex_set_bss_role(priv, MWIFIEX_BSS_ROLE_STA);
 
- if (mwifiex_send_cmd_sync(priv, HostCmd_CMD_P2P_MODE_CFG,
-      HostCmd_ACT_GEN_SET, 0, &mode))
+ if (mwifiex_send_cmd(priv, HostCmd_CMD_P2P_MODE_CFG,
+        HostCmd_ACT_GEN_SET, 0, &mode, true))
   return -1;
 
  return 0;
@@ -696,13 +720,13 @@ mwifiex_cfg80211_init_p2p_client(struct mwifiex_private *priv)
   return -1;
 
  mode = P2P_MODE_DEVICE;
- if (mwifiex_send_cmd_sync(priv, HostCmd_CMD_P2P_MODE_CFG,
-      HostCmd_ACT_GEN_SET, 0, &mode))
+ if (mwifiex_send_cmd(priv, HostCmd_CMD_P2P_MODE_CFG,
+        HostCmd_ACT_GEN_SET, 0, &mode, true))
   return -1;
 
  mode = P2P_MODE_CLIENT;
- if (mwifiex_send_cmd_sync(priv, HostCmd_CMD_P2P_MODE_CFG,
-      HostCmd_ACT_GEN_SET, 0, &mode))
+ if (mwifiex_send_cmd(priv, HostCmd_CMD_P2P_MODE_CFG,
+        HostCmd_ACT_GEN_SET, 0, &mode, true))
   return -1;
 
  return 0;
@@ -722,13 +746,13 @@ mwifiex_cfg80211_init_p2p_go(struct mwifiex_private *priv)
   return -1;
 
  mode = P2P_MODE_DEVICE;
- if (mwifiex_send_cmd_sync(priv, HostCmd_CMD_P2P_MODE_CFG,
-      HostCmd_ACT_GEN_SET, 0, &mode))
+ if (mwifiex_send_cmd(priv, HostCmd_CMD_P2P_MODE_CFG,
+        HostCmd_ACT_GEN_SET, 0, &mode, true))
   return -1;
 
  mode = P2P_MODE_GO;
- if (mwifiex_send_cmd_sync(priv, HostCmd_CMD_P2P_MODE_CFG,
-      HostCmd_ACT_GEN_SET, 0, &mode))
+ if (mwifiex_send_cmd(priv, HostCmd_CMD_P2P_MODE_CFG,
+        HostCmd_ACT_GEN_SET, 0, &mode, true))
   return -1;
 
  if (GET_BSS_ROLE(priv) != MWIFIEX_BSS_ROLE_UAP)
@@ -828,8 +852,8 @@ mwifiex_cfg80211_change_virtual_intf(struct wiphy *wiphy,
 
  priv->sec_info.authentication_mode = NL80211_AUTHTYPE_OPEN_SYSTEM;
 
- ret = mwifiex_send_cmd_sync(priv, HostCmd_CMD_SET_BSS_MODE,
-        HostCmd_ACT_GEN_SET, 0, NULL);
+ ret = mwifiex_send_cmd(priv, HostCmd_CMD_SET_BSS_MODE,
+          HostCmd_ACT_GEN_SET, 0, NULL, true);
 
  return ret;
 }
@@ -917,8 +941,8 @@ mwifiex_dump_station_info(struct mwifiex_private *priv,
    STATION_INFO_SIGNAL | STATION_INFO_SIGNAL_AVG;
 
  /* Get signal information from the firmware */
- if (mwifiex_send_cmd_sync(priv, HostCmd_CMD_RSSI_INFO,
-      HostCmd_ACT_GEN_GET, 0, NULL)) {
+ if (mwifiex_send_cmd(priv, HostCmd_CMD_RSSI_INFO,
+        HostCmd_ACT_GEN_GET, 0, NULL, true)) {
   dev_err(priv->adapter->dev, "failed to get signal information\n");
   return -EFAULT;
  }
@@ -929,9 +953,9 @@ mwifiex_dump_station_info(struct mwifiex_private *priv,
  }
 
  /* Get DTIM period information from firmware */
- mwifiex_send_cmd_sync(priv, HostCmd_CMD_802_11_SNMP_MIB,
-         HostCmd_ACT_GEN_GET, DTIM_PERIOD_I,
-         &priv->dtim_period);
+ mwifiex_send_cmd(priv, HostCmd_CMD_802_11_SNMP_MIB,
+    HostCmd_ACT_GEN_GET, DTIM_PERIOD_I,
+    &priv->dtim_period, true);
 
  mwifiex_parse_htinfo(priv, priv->tx_htinfo, &sinfo->txrate);
 
@@ -971,7 +995,7 @@ mwifiex_dump_station_info(struct mwifiex_private *priv,
  */
 static int
 mwifiex_cfg80211_get_station(struct wiphy *wiphy, struct net_device *dev,
-        u8 *mac, struct station_info *sinfo)
+        const u8 *mac, struct station_info *sinfo)
 {
  struct mwifiex_private *priv = mwifiex_netdev_get_priv(dev);
 
@@ -1135,9 +1159,10 @@ static int mwifiex_cfg80211_set_bitrate_mask(struct wiphy *wiphy,
  struct mwifiex_private *priv = mwifiex_netdev_get_priv(dev);
  u16 bitmap_rates[MAX_BITMAP_RATES_SIZE];
  enum ieee80211_band band;
+ struct mwifiex_adapter *adapter = priv->adapter;
 
  if (!priv->media_connected) {
-  dev_err(priv->adapter->dev,
+  dev_err(adapter->dev,
    "Can not set Tx data rate in disconnected state\n");
   return -EINVAL;
  }
@@ -1156,13 +1181,20 @@ static int mwifiex_cfg80211_set_bitrate_mask(struct wiphy *wiphy,
  else
   bitmap_rates[1] = mask->control[band].legacy;
 
- /* Fill MCS rates */
- bitmap_rates[2] = mask->control[band].mcs[0];
- if (priv->adapter->hw_dev_mcs_support == HT_STREAM_2X2)
-  bitmap_rates[2] |= mask->control[band].mcs[1] << 8;
+ /* Fill HT MCS rates */
+ bitmap_rates[2] = mask->control[band].ht_mcs[0];
+ if (adapter->hw_dev_mcs_support == HT_STREAM_2X2)
+  bitmap_rates[2] |= mask->control[band].ht_mcs[1] << 8;
 
- return mwifiex_send_cmd_sync(priv, HostCmd_CMD_TX_RATE_CFG,
-         HostCmd_ACT_GEN_SET, 0, bitmap_rates);
+       /* Fill VHT MCS rates */
+ if (adapter->fw_api_ver == MWIFIEX_FW_V15) {
+  bitmap_rates[10] = mask->control[band].vht_mcs[0];
+  if (adapter->hw_dev_mcs_support == HT_STREAM_2X2)
+   bitmap_rates[11] = mask->control[band].vht_mcs[1];
+ }
+
+ return mwifiex_send_cmd(priv, HostCmd_CMD_TX_RATE_CFG,
+    HostCmd_ACT_GEN_SET, 0, bitmap_rates, true);
 }
 
 /*
@@ -1191,14 +1223,14 @@ static int mwifiex_cfg80211_set_cqm_rssi_config(struct wiphy *wiphy,
   subsc_evt.bcn_h_rssi_cfg.abs_value = abs(rssi_thold);
   subsc_evt.bcn_l_rssi_cfg.evt_freq = 1;
   subsc_evt.bcn_h_rssi_cfg.evt_freq = 1;
-  return mwifiex_send_cmd_sync(priv,
-          HostCmd_CMD_802_11_SUBSCRIBE_EVENT,
-          0, 0, &subsc_evt);
+  return mwifiex_send_cmd(priv,
+     HostCmd_CMD_802_11_SUBSCRIBE_EVENT,
+     0, 0, &subsc_evt, true);
  } else {
   subsc_evt.action = HostCmd_ACT_BITWISE_CLR;
-  return mwifiex_send_cmd_sync(priv,
-          HostCmd_CMD_802_11_SUBSCRIBE_EVENT,
-          0, 0, &subsc_evt);
+  return mwifiex_send_cmd(priv,
+     HostCmd_CMD_802_11_SUBSCRIBE_EVENT,
+     0, 0, &subsc_evt, true);
  }
 
  return 0;
@@ -1231,6 +1263,49 @@ static int mwifiex_cfg80211_change_beacon(struct wiphy *wiphy,
  return 0;
 }
 
+/* cfg80211 operation handler for del_station.
+ * Function deauthenticates station which value is provided in mac parameter.
+ * If mac is NULL/broadcast, all stations in associated station list are
+ * deauthenticated. If bss is not started or there are no stations in
+ * associated stations list, no action is taken.
+ */
+static int
+mwifiex_cfg80211_del_station(struct wiphy *wiphy, struct net_device *dev,
+        const u8 *mac)
+{
+ struct mwifiex_private *priv = mwifiex_netdev_get_priv(dev);
+ struct mwifiex_sta_node *sta_node;
+ unsigned long flags;
+
+ if (list_empty(&priv->sta_list) || !priv->bss_started)
+  return 0;
+
+ if (!mac || is_broadcast_ether_addr(mac)) {
+  wiphy_dbg(wiphy, "%s: NULL/broadcast mac address\n", __func__);
+  list_for_each_entry(sta_node, &priv->sta_list, list) {
+   if (mwifiex_send_cmd(priv, HostCmd_CMD_UAP_STA_DEAUTH,
+          HostCmd_ACT_GEN_SET, 0,
+          sta_node->mac_addr, true))
+    return -1;
+   mwifiex_uap_del_sta_data(priv, sta_node);
+  }
+ } else {
+  wiphy_dbg(wiphy, "%s: mac address %pM\n", __func__, mac);
+  spin_lock_irqsave(&priv->sta_list_spinlock, flags);
+  sta_node = mwifiex_get_sta_entry(priv, mac);
+  spin_unlock_irqrestore(&priv->sta_list_spinlock, flags);
+  if (sta_node) {
+   if (mwifiex_send_cmd(priv, HostCmd_CMD_UAP_STA_DEAUTH,
+          HostCmd_ACT_GEN_SET, 0,
+          sta_node->mac_addr, true))
+    return -1;
+   mwifiex_uap_del_sta_data(priv, sta_node);
+  }
+ }
+
+ return 0;
+}
+
 static int
 mwifiex_cfg80211_set_antenna(struct wiphy *wiphy, u32 tx_ant, u32 rx_ant)
 {
@@ -1258,13 +1333,40 @@ mwifiex_cfg80211_set_antenna(struct wiphy *wiphy, u32 tx_ant, u32 rx_ant)
    tx_ant = RF_ANTENNA_AUTO;
    rx_ant = RF_ANTENNA_AUTO;
   }
+ } else {
+  struct ieee80211_sta_ht_cap *ht_info;
+  int rx_mcs_supp;
+  enum ieee80211_band band;
+
+  if ((tx_ant == 0x1 && rx_ant == 0x1)) {
+   adapter->user_dev_mcs_support = HT_STREAM_1X1;
+   if (adapter->is_hw_11ac_capable)
+    adapter->usr_dot_11ac_mcs_support =
+      MWIFIEX_11AC_MCS_MAP_1X1;
+  } else {
+   adapter->user_dev_mcs_support = HT_STREAM_2X2;
+   if (adapter->is_hw_11ac_capable)
+    adapter->usr_dot_11ac_mcs_support =
+      MWIFIEX_11AC_MCS_MAP_2X2;
+  }
+
+  for (band = 0; band < IEEE80211_NUM_BANDS; band++) {
+   if (!adapter->wiphy->bands[band])
+    continue;
+
+   ht_info = &adapter->wiphy->bands[band]->ht_cap;
+   rx_mcs_supp =
+    GET_RXMCSSUPP(adapter->user_dev_mcs_support);
+   memset(&ht_info->mcs, 0, adapter->number_of_antenna);
+   memset(&ht_info->mcs, 0xff, rx_mcs_supp);
+  }
  }
 
  ant_cfg.tx_ant = tx_ant;
  ant_cfg.rx_ant = rx_ant;
 
- return mwifiex_send_cmd_sync(priv, HostCmd_CMD_RF_ANTENNA,
-         HostCmd_ACT_GEN_SET, 0, &ant_cfg);
+ return mwifiex_send_cmd(priv, HostCmd_CMD_RF_ANTENNA,
+    HostCmd_ACT_GEN_SET, 0, &ant_cfg, true);
 }
 
 /* cfg80211 operation handler for stop ap.
@@ -1279,8 +1381,8 @@ static int mwifiex_cfg80211_stop_ap(struct wiphy *wiphy, struct net_device *dev)
 
  priv->ap_11n_enabled = 0;
 
- if (mwifiex_send_cmd_sync(priv, HostCmd_CMD_UAP_BSS_STOP,
-      HostCmd_ACT_GEN_SET, 0, NULL)) {
+ if (mwifiex_send_cmd(priv, HostCmd_CMD_UAP_BSS_STOP,
+        HostCmd_ACT_GEN_SET, 0, NULL, true)) {
   wiphy_err(wiphy, "Failed to stop the BSS\n");
   return -1;
  }
@@ -1346,9 +1448,6 @@ static int mwifiex_cfg80211_start_ap(struct wiphy *wiphy,
 
   if (params->chandef.width > NL80211_CHAN_WIDTH_20_NOHT)
    config_bands |= BAND_GN;
-
-  if (params->chandef.width > NL80211_CHAN_WIDTH_40)
-   config_bands |= BAND_GAC;
  } else {
   bss_cfg->band_cfg = BAND_CONFIG_A;
   config_bands = BAND_A;
@@ -1394,16 +1493,16 @@ static int mwifiex_cfg80211_start_ap(struct wiphy *wiphy,
   bss_cfg->ps_sta_ao_timer = 10 * params->inactivity_timeout;
  }
 
- if (mwifiex_send_cmd_sync(priv, HostCmd_CMD_UAP_BSS_STOP,
-      HostCmd_ACT_GEN_SET, 0, NULL)) {
+ if (mwifiex_send_cmd(priv, HostCmd_CMD_UAP_BSS_STOP,
+        HostCmd_ACT_GEN_SET, 0, NULL, true)) {
   wiphy_err(wiphy, "Failed to stop the BSS\n");
   kfree(bss_cfg);
   return -1;
  }
 
- if (mwifiex_send_cmd_async(priv, HostCmd_CMD_UAP_SYS_CONFIG,
-       HostCmd_ACT_GEN_SET,
-       UAP_BSS_PARAMS_I, bss_cfg)) {
+ if (mwifiex_send_cmd(priv, HostCmd_CMD_UAP_SYS_CONFIG,
+        HostCmd_ACT_GEN_SET,
+        UAP_BSS_PARAMS_I, bss_cfg, false)) {
   wiphy_err(wiphy, "Failed to set the SSID\n");
   kfree(bss_cfg);
   return -1;
@@ -1411,8 +1510,8 @@ static int mwifiex_cfg80211_start_ap(struct wiphy *wiphy,
 
  kfree(bss_cfg);
 
- if (mwifiex_send_cmd_async(priv, HostCmd_CMD_UAP_BSS_START,
-       HostCmd_ACT_GEN_SET, 0, NULL)) {
+ if (mwifiex_send_cmd(priv, HostCmd_CMD_UAP_BSS_START,
+        HostCmd_ACT_GEN_SET, 0, NULL, false)) {
   wiphy_err(wiphy, "Failed to start the BSS\n");
   return -1;
  }
@@ -1422,9 +1521,9 @@ static int mwifiex_cfg80211_start_ap(struct wiphy *wiphy,
  else
   priv->curr_pkt_filter &= ~HostCmd_ACT_MAC_WEP_ENABLE;
 
- if (mwifiex_send_cmd_sync(priv, HostCmd_CMD_MAC_CONTROL,
-      HostCmd_ACT_GEN_SET, 0,
-      &priv->curr_pkt_filter))
+ if (mwifiex_send_cmd(priv, HostCmd_CMD_MAC_CONTROL,
+        HostCmd_ACT_GEN_SET, 0,
+        &priv->curr_pkt_filter, true))
   return -1;
 
  return 0;
@@ -1449,6 +1548,7 @@ mwifiex_cfg80211_disconnect(struct wiphy *wiphy, struct net_device *dev,
   " reason code %d\n", priv->cfg_bssid, reason_code);
 
  memset(priv->cfg_bssid, 0, ETH_ALEN);
+ priv->hs2_enabled = false;
 
  return 0;
 }
@@ -1512,8 +1612,9 @@ static int mwifiex_cfg80211_inform_ibss_bss(struct mwifiex_private *priv)
  * the function notifies the CFG802.11 subsystem of the new BSS connection.
  */
 static int
-mwifiex_cfg80211_assoc(struct mwifiex_private *priv, size_t ssid_len, u8 *ssid,
-         u8 *bssid, int mode, struct ieee80211_channel *channel,
+mwifiex_cfg80211_assoc(struct mwifiex_private *priv, size_t ssid_len,
+         const u8 *ssid, const u8 *bssid, int mode,
+         struct ieee80211_channel *channel,
          struct cfg80211_connect_params *sme, bool privacy)
 {
  struct cfg80211_ssid req_ssid;
@@ -1810,7 +1911,8 @@ mwifiex_cfg80211_join_ibss(struct wiphy *wiphy, struct net_device *dev,
          params->privacy);
 done:
  if (!ret) {
-  cfg80211_ibss_joined(priv->netdev, priv->cfg_bssid, GFP_KERNEL);
+  cfg80211_ibss_joined(priv->netdev, priv->cfg_bssid,
+         params->chandef.chan, GFP_KERNEL);
   dev_dbg(priv->adapter->dev,
    "info: joined/created adhoc network with bssid"
    " %pM successfully\n", priv->cfg_bssid);
@@ -1859,6 +1961,7 @@ mwifiex_cfg80211_scan(struct wiphy *wiphy,
  int i, offset, ret;
  struct ieee80211_channel *chan;
  struct ieee_types_header *ie;
+ struct mwifiex_user_scan_cfg *user_scan_cfg;
 
  wiphy_dbg(wiphy, "info: received scan request on %s\n", dev->name);
 
@@ -1869,20 +1972,22 @@ mwifiex_cfg80211_scan(struct wiphy *wiphy,
   return -EBUSY;
  }
 
- if (priv->user_scan_cfg) {
+ /* Block scan request if scan operation or scan cleanup when interface
+  * is disabled is in process
+  */
+ if (priv->scan_request || priv->scan_aborting) {
   dev_err(priv->adapter->dev, "cmd: Scan already in process..\n");
   return -EBUSY;
  }
 
- priv->user_scan_cfg = kzalloc(sizeof(struct mwifiex_user_scan_cfg),
-          GFP_KERNEL);
- if (!priv->user_scan_cfg)
+ user_scan_cfg = kzalloc(sizeof(*user_scan_cfg), GFP_KERNEL);
+ if (!user_scan_cfg)
   return -ENOMEM;
 
  priv->scan_request = request;
 
- priv->user_scan_cfg->num_ssids = request->n_ssids;
- priv->user_scan_cfg->ssid_list = request->ssids;
+ user_scan_cfg->num_ssids = request->n_ssids;
+ user_scan_cfg->ssid_list = request->ssids;
 
  if (request->ie && request->ie_len) {
   offset = 0;
@@ -1902,25 +2007,25 @@ mwifiex_cfg80211_scan(struct wiphy *wiphy,
  for (i = 0; i < min_t(u32, request->n_channels,
          MWIFIEX_USER_SCAN_CHAN_MAX); i++) {
   chan = request->channels[i];
-  priv->user_scan_cfg->chan_list[i].chan_number = chan->hw_value;
-  priv->user_scan_cfg->chan_list[i].radio_type = chan->band;
+  user_scan_cfg->chan_list[i].chan_number = chan->hw_value;
+  user_scan_cfg->chan_list[i].radio_type = chan->band;
 
-  if (chan->flags & IEEE80211_CHAN_PASSIVE_SCAN)
-   priv->user_scan_cfg->chan_list[i].scan_type =
+  if (chan->flags & IEEE80211_CHAN_NO_IR)
+   user_scan_cfg->chan_list[i].scan_type =
       MWIFIEX_SCAN_TYPE_PASSIVE;
   else
-   priv->user_scan_cfg->chan_list[i].scan_type =
+   user_scan_cfg->chan_list[i].scan_type =
       MWIFIEX_SCAN_TYPE_ACTIVE;
 
-  priv->user_scan_cfg->chan_list[i].scan_time = 0;
+  user_scan_cfg->chan_list[i].scan_time = 0;
  }
 
- ret = mwifiex_scan_networks(priv, priv->user_scan_cfg);
+ ret = mwifiex_scan_networks(priv, user_scan_cfg);
+ kfree(user_scan_cfg);
  if (ret) {
   dev_err(priv->adapter->dev, "scan failed: %d\n", ret);
+  priv->scan_aborting = false;
   priv->scan_request = NULL;
-  kfree(priv->user_scan_cfg);
-  priv->user_scan_cfg = NULL;
   return ret;
  }
 
@@ -1996,10 +2101,10 @@ mwifiex_setup_ht_caps(struct ieee80211_sta_ht_cap *ht_info,
  else
   ht_info->cap &= ~IEEE80211_HT_CAP_SGI_40;
 
- if (ISSUPP_RXSTBC(adapter->hw_dot_11n_dev_cap))
-  ht_info->cap |= 1 << IEEE80211_HT_CAP_RX_STBC_SHIFT;
+ if (adapter->user_dev_mcs_support == HT_STREAM_2X2)
+  ht_info->cap |= 3 << IEEE80211_HT_CAP_RX_STBC_SHIFT;
  else
-  ht_info->cap &= ~(3 << IEEE80211_HT_CAP_RX_STBC_SHIFT);
+  ht_info->cap |= 1 << IEEE80211_HT_CAP_RX_STBC_SHIFT;
 
  if (ISSUPP_TXSTBC(adapter->hw_dot_11n_dev_cap))
   ht_info->cap |= IEEE80211_HT_CAP_TX_STBC;
@@ -2024,8 +2129,8 @@ mwifiex_setup_ht_caps(struct ieee80211_sta_ht_cap *ht_info,
  ht_info->cap &= ~IEEE80211_HT_CAP_MAX_AMSDU;
  ht_info->cap |= IEEE80211_HT_CAP_SM_PS;
 
- rx_mcs_supp = GET_RXMCSSUPP(adapter->hw_dev_mcs_support);
- /* Set MCS for 1x1 */
+ rx_mcs_supp = GET_RXMCSSUPP(adapter->user_dev_mcs_support);
+ /* Set MCS for 1x1/2x2 */
  memset(mcs, 0xff, rx_mcs_supp);
  /* Clear all the other values */
  memset(&mcs[rx_mcs_supp], 0,
@@ -2147,8 +2252,10 @@ struct wireless_dev *mwifiex_add_virtual_intf(struct wiphy *wiphy,
   priv->bss_started = 0;
   priv->bss_num = 0;
 
-  if (mwifiex_cfg80211_init_p2p_client(priv))
-   return ERR_PTR(-EFAULT);
+  if (mwifiex_cfg80211_init_p2p_client(priv)) {
+   wdev = ERR_PTR(-EFAULT);
+   goto done;
+  }
 
   break;
  default:
@@ -2161,7 +2268,8 @@ struct wireless_dev *mwifiex_add_virtual_intf(struct wiphy *wiphy,
  if (!dev) {
   wiphy_err(wiphy, "no memory available for netdevice\n");
   priv->bss_mode = NL80211_IFTYPE_UNSPECIFIED;
-  return ERR_PTR(-ENOMEM);
+  wdev = ERR_PTR(-ENOMEM);
+  goto done;
  }
 
  mwifiex_init_priv_params(priv, dev);
@@ -2201,7 +2309,9 @@ struct wireless_dev *mwifiex_add_virtual_intf(struct wiphy *wiphy,
   wiphy_err(wiphy, "cannot register virtual network device\n");
   free_netdev(dev);
   priv->bss_mode = NL80211_IFTYPE_UNSPECIFIED;
-  return ERR_PTR(-EFAULT);
+  priv->netdev = NULL;
+  wdev = ERR_PTR(-EFAULT);
+  goto done;
  }
 
  sema_init(&priv->async_sem, 1);
@@ -2211,6 +2321,13 @@ struct wireless_dev *mwifiex_add_virtual_intf(struct wiphy *wiphy,
 #ifdef CONFIG_DEBUG_FS
  mwifiex_dev_debugfs_init(priv);
 #endif
+
+done:
+ if (IS_ERR(wdev)) {
+  kfree(priv->wdev);
+  priv->wdev = NULL;
+ }
+
  return wdev;
 }
 EXPORT_SYMBOL_GPL(mwifiex_add_virtual_intf);
@@ -2235,7 +2352,10 @@ int mwifiex_del_virtual_intf(struct wiphy *wiphy, struct wireless_dev *wdev)
   unregister_netdevice(wdev->netdev);
 
  /* Clear the priv in adapter */
+ priv->netdev->ieee80211_ptr = NULL;
  priv->netdev = NULL;
+ kfree(wdev);
+ priv->wdev = NULL;
 
  priv->media_connected = false;
 
@@ -2245,10 +2365,9 @@ int mwifiex_del_virtual_intf(struct wiphy *wiphy, struct wireless_dev *wdev)
 }
 EXPORT_SYMBOL_GPL(mwifiex_del_virtual_intf);
 
-#ifdef CONFIG_PM
 static bool
-mwifiex_is_pattern_supported(struct cfg80211_wowlan_trig_pkt_pattern *pat,
-        s8 *byte_seq)
+mwifiex_is_pattern_supported(struct cfg80211_pkt_pattern *pat, s8 *byte_seq,
+        u8 max_byte_seq)
 {
  int j, k, valid_byte_cnt = 0;
  bool dont_care_byte = false;
@@ -2266,16 +2385,17 @@ mwifiex_is_pattern_supported(struct cfg80211_wowlan_trig_pkt_pattern *pat,
      dont_care_byte = true;
    }
 
-   if (valid_byte_cnt > MAX_BYTESEQ)
+   if (valid_byte_cnt > max_byte_seq)
     return false;
   }
  }
 
- byte_seq[MAX_BYTESEQ] = valid_byte_cnt;
+ byte_seq[max_byte_seq] = valid_byte_cnt;
 
  return true;
 }
 
+#ifdef CONFIG_PM
 static int mwifiex_cfg80211_suspend(struct wiphy *wiphy,
         struct cfg80211_wowlan *wowlan)
 {
@@ -2284,7 +2404,7 @@ static int mwifiex_cfg80211_suspend(struct wiphy *wiphy,
  struct mwifiex_mef_entry *mef_entry;
  int i, filt_num = 0, ret;
  bool first_pat = true;
- u8 byte_seq[MAX_BYTESEQ + 1];
+ u8 byte_seq[MWIFIEX_MEF_MAX_BYTESEQ + 1];
  const u8 ipv4_mc_mac[] = {0x33, 0x33};
  const u8 ipv6_mc_mac[] = {0x01, 0x00, 0x5e};
  struct mwifiex_private *priv =
@@ -2314,7 +2434,8 @@ static int mwifiex_cfg80211_suspend(struct wiphy *wiphy,
  for (i = 0; i < wowlan->n_patterns; i++) {
   memset(byte_seq, 0, sizeof(byte_seq));
   if (!mwifiex_is_pattern_supported(&wowlan->patterns[i],
-        byte_seq)) {
+        byte_seq,
+        MWIFIEX_MEF_MAX_BYTESEQ)) {
    wiphy_err(wiphy, "Pattern not supported\n");
    kfree(mef_entry);
    return -EOPNOTSUPP;
@@ -2322,16 +2443,16 @@ static int mwifiex_cfg80211_suspend(struct wiphy *wiphy,
 
   if (!wowlan->patterns[i].pkt_offset) {
    if (!(byte_seq[0] & 0x01) &&
-       (byte_seq[MAX_BYTESEQ] == 1)) {
+       (byte_seq[MWIFIEX_MEF_MAX_BYTESEQ] == 1)) {
     mef_cfg.criteria |= MWIFIEX_CRITERIA_UNICAST;
     continue;
    } else if (is_broadcast_ether_addr(byte_seq)) {
     mef_cfg.criteria |= MWIFIEX_CRITERIA_BROADCAST;
     continue;
    } else if ((!memcmp(byte_seq, ipv4_mc_mac, 2) &&
-        (byte_seq[MAX_BYTESEQ] == 2)) ||
+        (byte_seq[MWIFIEX_MEF_MAX_BYTESEQ] == 2)) ||
        (!memcmp(byte_seq, ipv6_mc_mac, 3) &&
-        (byte_seq[MAX_BYTESEQ] == 3))) {
+        (byte_seq[MWIFIEX_MEF_MAX_BYTESEQ] == 3))) {
     mef_cfg.criteria |= MWIFIEX_CRITERIA_MULTICAST;
     continue;
    }
@@ -2357,8 +2478,9 @@ static int mwifiex_cfg80211_suspend(struct wiphy *wiphy,
   mef_entry->filter[filt_num].repeat = 16;
   memcpy(mef_entry->filter[filt_num].byte_seq, priv->curr_addr,
          ETH_ALEN);
-  mef_entry->filter[filt_num].byte_seq[MAX_BYTESEQ] = ETH_ALEN;
-  mef_entry->filter[filt_num].offset = 14;
+  mef_entry->filter[filt_num].byte_seq[MWIFIEX_MEF_MAX_BYTESEQ] =
+        ETH_ALEN;
+  mef_entry->filter[filt_num].offset = 28;
   mef_entry->filter[filt_num].filt_type = TYPE_EQ;
   if (filt_num)
    mef_entry->filter[filt_num].filt_action = TYPE_OR;
@@ -2369,9 +2491,8 @@ static int mwifiex_cfg80211_suspend(struct wiphy *wiphy,
        MWIFIEX_CRITERIA_UNICAST |
        MWIFIEX_CRITERIA_MULTICAST;
 
- ret =  mwifiex_send_cmd_sync(priv, HostCmd_CMD_MEF_CFG,
-         HostCmd_ACT_GEN_SET, 0,
-         &mef_cfg);
+ ret = mwifiex_send_cmd(priv, HostCmd_CMD_MEF_CFG,
+          HostCmd_ACT_GEN_SET, 0, &mef_cfg, true);
 
  kfree(mef_entry);
  return ret;
@@ -2391,6 +2512,282 @@ static void mwifiex_cfg80211_set_wakeup(struct wiphy *wiphy,
 }
 #endif
 
+static int mwifiex_get_coalesce_pkt_type(u8 *byte_seq)
+{
+ const u8 ipv4_mc_mac[] = {0x33, 0x33};
+ const u8 ipv6_mc_mac[] = {0x01, 0x00, 0x5e};
+ const u8 bc_mac[] = {0xff, 0xff, 0xff, 0xff};
+
+ if ((byte_seq[0] & 0x01) &&
+     (byte_seq[MWIFIEX_COALESCE_MAX_BYTESEQ] == 1))
+  return PACKET_TYPE_UNICAST;
+ else if (!memcmp(byte_seq, bc_mac, 4))
+  return PACKET_TYPE_BROADCAST;
+ else if ((!memcmp(byte_seq, ipv4_mc_mac, 2) &&
+    byte_seq[MWIFIEX_COALESCE_MAX_BYTESEQ] == 2) ||
+   (!memcmp(byte_seq, ipv6_mc_mac, 3) &&
+    byte_seq[MWIFIEX_COALESCE_MAX_BYTESEQ] == 3))
+  return PACKET_TYPE_MULTICAST;
+
+ return 0;
+}
+
+static int
+mwifiex_fill_coalesce_rule_info(struct mwifiex_private *priv,
+    struct cfg80211_coalesce_rules *crule,
+    struct mwifiex_coalesce_rule *mrule)
+{
+ u8 byte_seq[MWIFIEX_COALESCE_MAX_BYTESEQ + 1];
+ struct filt_field_param *param;
+ int i;
+
+ mrule->max_coalescing_delay = crule->delay;
+
+ param = mrule->params;
+
+ for (i = 0; i < crule->n_patterns; i++) {
+  memset(byte_seq, 0, sizeof(byte_seq));
+  if (!mwifiex_is_pattern_supported(&crule->patterns[i],
+        byte_seq,
+      MWIFIEX_COALESCE_MAX_BYTESEQ)) {
+   dev_err(priv->adapter->dev, "Pattern not supported\n");
+   return -EOPNOTSUPP;
+  }
+
+  if (!crule->patterns[i].pkt_offset) {
+   u8 pkt_type;
+
+   pkt_type = mwifiex_get_coalesce_pkt_type(byte_seq);
+   if (pkt_type && mrule->pkt_type) {
+    dev_err(priv->adapter->dev,
+     "Multiple packet types not allowed\n");
+    return -EOPNOTSUPP;
+   } else if (pkt_type) {
+    mrule->pkt_type = pkt_type;
+    continue;
+   }
+  }
+
+  if (crule->condition == NL80211_COALESCE_CONDITION_MATCH)
+   param->operation = RECV_FILTER_MATCH_TYPE_EQ;
+  else
+   param->operation = RECV_FILTER_MATCH_TYPE_NE;
+
+  param->operand_len = byte_seq[MWIFIEX_COALESCE_MAX_BYTESEQ];
+  memcpy(param->operand_byte_stream, byte_seq,
+         param->operand_len);
+  param->offset = crule->patterns[i].pkt_offset;
+  param++;
+
+  mrule->num_of_fields++;
+ }
+
+ if (!mrule->pkt_type) {
+  dev_err(priv->adapter->dev,
+   "Packet type can not be determined\n");
+  return -EOPNOTSUPP;
+ }
+
+ return 0;
+}
+
+static int mwifiex_cfg80211_set_coalesce(struct wiphy *wiphy,
+      struct cfg80211_coalesce *coalesce)
+{
+ struct mwifiex_adapter *adapter = mwifiex_cfg80211_get_adapter(wiphy);
+ int i, ret;
+ struct mwifiex_ds_coalesce_cfg coalesce_cfg;
+ struct mwifiex_private *priv =
+   mwifiex_get_priv(adapter, MWIFIEX_BSS_ROLE_STA);
+
+ memset(&coalesce_cfg, 0, sizeof(coalesce_cfg));
+ if (!coalesce) {
+  dev_dbg(adapter->dev,
+   "Disable coalesce and reset all previous rules\n");
+  return mwifiex_send_cmd(priv, HostCmd_CMD_COALESCE_CFG,
+     HostCmd_ACT_GEN_SET, 0,
+     &coalesce_cfg, true);
+ }
+
+ coalesce_cfg.num_of_rules = coalesce->n_rules;
+ for (i = 0; i < coalesce->n_rules; i++) {
+  ret = mwifiex_fill_coalesce_rule_info(priv, &coalesce->rules[i],
+            &coalesce_cfg.rule[i]);
+  if (ret) {
+   dev_err(priv->adapter->dev,
+    "Recheck the patterns provided for rule %d\n",
+    i + 1);
+   return ret;
+  }
+ }
+
+ return mwifiex_send_cmd(priv, HostCmd_CMD_COALESCE_CFG,
+    HostCmd_ACT_GEN_SET, 0, &coalesce_cfg, true);
+}
+
+/* cfg80211 ops handler for tdls_mgmt.
+ * Function prepares TDLS action frame packets and forwards them to FW
+ */
+static int
+mwifiex_cfg80211_tdls_mgmt(struct wiphy *wiphy, struct net_device *dev,
+      const u8 *peer, u8 action_code, u8 dialog_token,
+      u16 status_code, u32 peer_capability,
+      const u8 *extra_ies, size_t extra_ies_len)
+{
+ struct mwifiex_private *priv = mwifiex_netdev_get_priv(dev);
+ int ret;
+
+ if (!(wiphy->flags & WIPHY_FLAG_SUPPORTS_TDLS))
+  return -ENOTSUPP;
+
+ /* make sure we are in station mode and connected */
+ if (!(priv->bss_type == MWIFIEX_BSS_TYPE_STA && priv->media_connected))
+  return -ENOTSUPP;
+
+ switch (action_code) {
+ case WLAN_TDLS_SETUP_REQUEST:
+  dev_dbg(priv->adapter->dev,
+   "Send TDLS Setup Request to %pM status_code=%d\n", peer,
+    status_code);
+  ret = mwifiex_send_tdls_data_frame(priv, peer, action_code,
+         dialog_token, status_code,
+         extra_ies, extra_ies_len);
+  break;
+ case WLAN_TDLS_SETUP_RESPONSE:
+  dev_dbg(priv->adapter->dev,
+   "Send TDLS Setup Response to %pM status_code=%d\n",
+   peer, status_code);
+  ret = mwifiex_send_tdls_data_frame(priv, peer, action_code,
+         dialog_token, status_code,
+         extra_ies, extra_ies_len);
+  break;
+ case WLAN_TDLS_SETUP_CONFIRM:
+  dev_dbg(priv->adapter->dev,
+   "Send TDLS Confirm to %pM status_code=%d\n", peer,
+   status_code);
+  ret = mwifiex_send_tdls_data_frame(priv, peer, action_code,
+         dialog_token, status_code,
+         extra_ies, extra_ies_len);
+  break;
+ case WLAN_TDLS_TEARDOWN:
+  dev_dbg(priv->adapter->dev, "Send TDLS Tear down to %pM\n",
+   peer);
+  ret = mwifiex_send_tdls_data_frame(priv, peer, action_code,
+         dialog_token, status_code,
+         extra_ies, extra_ies_len);
+  break;
+ case WLAN_TDLS_DISCOVERY_REQUEST:
+  dev_dbg(priv->adapter->dev,
+   "Send TDLS Discovery Request to %pM\n", peer);
+  ret = mwifiex_send_tdls_data_frame(priv, peer, action_code,
+         dialog_token, status_code,
+         extra_ies, extra_ies_len);
+  break;
+ case WLAN_PUB_ACTION_TDLS_DISCOVER_RES:
+  dev_dbg(priv->adapter->dev,
+   "Send TDLS Discovery Response to %pM\n", peer);
+  ret = mwifiex_send_tdls_action_frame(priv, peer, action_code,
+         dialog_token, status_code,
+         extra_ies, extra_ies_len);
+  break;
+ default:
+  dev_warn(priv->adapter->dev,
+    "Unknown TDLS mgmt/action frame %pM\n", peer);
+  ret = -EINVAL;
+  break;
+ }
+
+ return ret;
+}
+
+static int
+mwifiex_cfg80211_tdls_oper(struct wiphy *wiphy, struct net_device *dev,
+      const u8 *peer, enum nl80211_tdls_operation action)
+{
+ struct mwifiex_private *priv = mwifiex_netdev_get_priv(dev);
+
+ if (!(wiphy->flags & WIPHY_FLAG_SUPPORTS_TDLS) ||
+     !(wiphy->flags & WIPHY_FLAG_TDLS_EXTERNAL_SETUP))
+  return -ENOTSUPP;
+
+ /* make sure we are in station mode and connected */
+ if (!(priv->bss_type == MWIFIEX_BSS_TYPE_STA && priv->media_connected))
+  return -ENOTSUPP;
+
+ dev_dbg(priv->adapter->dev,
+  "TDLS peer=%pM, oper=%d\n", peer, action);
+
+ switch (action) {
+ case NL80211_TDLS_ENABLE_LINK:
+  action = MWIFIEX_TDLS_ENABLE_LINK;
+  break;
+ case NL80211_TDLS_DISABLE_LINK:
+  action = MWIFIEX_TDLS_DISABLE_LINK;
+  break;
+ case NL80211_TDLS_TEARDOWN:
+  /* shouldn't happen!*/
+  dev_warn(priv->adapter->dev,
+    "tdls_oper: teardown from driver not supported\n");
+  return -EINVAL;
+ case NL80211_TDLS_SETUP:
+  /* shouldn't happen!*/
+  dev_warn(priv->adapter->dev,
+    "tdls_oper: setup from driver not supported\n");
+  return -EINVAL;
+ case NL80211_TDLS_DISCOVERY_REQ:
+  /* shouldn't happen!*/
+  dev_warn(priv->adapter->dev,
+    "tdls_oper: discovery from driver not supported\n");
+  return -EINVAL;
+ default:
+  dev_err(priv->adapter->dev,
+   "tdls_oper: operation not supported\n");
+  return -ENOTSUPP;
+ }
+
+ return mwifiex_tdls_oper(priv, peer, action);
+}
+
+static int
+mwifiex_cfg80211_add_station(struct wiphy *wiphy, struct net_device *dev,
+        const u8 *mac, struct station_parameters *params)
+{
+ struct mwifiex_private *priv = mwifiex_netdev_get_priv(dev);
+
+ if (!(params->sta_flags_set & BIT(NL80211_STA_FLAG_TDLS_PEER)))
+  return -ENOTSUPP;
+
+ /* make sure we are in station mode and connected */
+ if ((priv->bss_type != MWIFIEX_BSS_TYPE_STA) || !priv->media_connected)
+  return -ENOTSUPP;
+
+ return mwifiex_tdls_oper(priv, mac, MWIFIEX_TDLS_CREATE_LINK);
+}
+
+static int
+mwifiex_cfg80211_change_station(struct wiphy *wiphy, struct net_device *dev,
+    const u8 *mac,
+    struct station_parameters *params)
+{
+ int ret;
+ struct mwifiex_private *priv = mwifiex_netdev_get_priv(dev);
+
+ /* we support change_station handler only for TDLS peers*/
+ if (!(params->sta_flags_set & BIT(NL80211_STA_FLAG_TDLS_PEER)))
+  return -ENOTSUPP;
+
+ /* make sure we are in station mode and connected */
+ if ((priv->bss_type != MWIFIEX_BSS_TYPE_STA) || !priv->media_connected)
+  return -ENOTSUPP;
+
+ priv->sta_params = params;
+
+ ret = mwifiex_tdls_oper(priv, mac, MWIFIEX_TDLS_CONFIG_LINK);
+ priv->sta_params = NULL;
+
+ return ret;
+}
+
 /* station cfg80211 operations */
 static struct cfg80211_ops mwifiex_cfg80211_ops = {
  .add_virtual_intf = mwifiex_add_virtual_intf,
@@ -2419,11 +2816,47 @@ static struct cfg80211_ops mwifiex_cfg80211_ops = {
  .change_beacon = mwifiex_cfg80211_change_beacon,
  .set_cqm_rssi_config = mwifiex_cfg80211_set_cqm_rssi_config,
  .set_antenna = mwifiex_cfg80211_set_antenna,
+ .del_station = mwifiex_cfg80211_del_station,
 #ifdef CONFIG_PM
  .suspend = mwifiex_cfg80211_suspend,
  .resume = mwifiex_cfg80211_resume,
  .set_wakeup = mwifiex_cfg80211_set_wakeup,
 #endif
+ .set_coalesce = mwifiex_cfg80211_set_coalesce,
+ .tdls_mgmt = mwifiex_cfg80211_tdls_mgmt,
+ .tdls_oper = mwifiex_cfg80211_tdls_oper,
+ .add_station = mwifiex_cfg80211_add_station,
+ .change_station = mwifiex_cfg80211_change_station,
+};
+
+#ifdef CONFIG_PM
+static const struct wiphy_wowlan_support mwifiex_wowlan_support = {
+ .flags = WIPHY_WOWLAN_MAGIC_PKT,
+ .n_patterns = MWIFIEX_MEF_MAX_FILTERS,
+ .pattern_min_len = 1,
+ .pattern_max_len = MWIFIEX_MAX_PATTERN_LEN,
+ .max_pkt_offset = MWIFIEX_MAX_OFFSET_LEN,
+};
+#endif
+
+static bool mwifiex_is_valid_alpha2(const char *alpha2)
+{
+ if (!alpha2 || strlen(alpha2) != 2)
+  return false;
+
+ if (isalpha(alpha2[0]) && isalpha(alpha2[1]))
+  return true;
+
+ return false;
+}
+
+static const struct wiphy_coalesce_support mwifiex_coalesce_support = {
+ .n_rules = MWIFIEX_COALESCE_MAX_RULES,
+ .max_delay = MWIFIEX_MAX_COALESCING_DELAY,
+ .n_patterns = MWIFIEX_COALESCE_MAX_FILTERS,
+ .pattern_min_len = 1,
+ .pattern_max_len = MWIFIEX_MAX_PATTERN_LEN,
+ .max_pkt_offset = MWIFIEX_MAX_OFFSET_LEN,
 };
 
 /*
@@ -2441,6 +2874,7 @@ int mwifiex_register_cfg80211(struct mwifiex_adapter *adapter)
  struct wiphy *wiphy;
  struct mwifiex_private *priv = adapter->priv[MWIFIEX_BSS_TYPE_STA];
  u8 *country_code;
+ u32 thr, retry;
 
  /* create a new wiphy for use with cfg80211 */
  wiphy = wiphy_new(&mwifiex_cfg80211_ops,
@@ -2477,19 +2911,24 @@ int mwifiex_register_cfg80211(struct mwifiex_adapter *adapter)
  wiphy->flags |= WIPHY_FLAG_HAVE_AP_SME |
    WIPHY_FLAG_AP_PROBE_RESP_OFFLOAD |
    WIPHY_FLAG_AP_UAPSD |
-   WIPHY_FLAG_CUSTOM_REGULATORY |
    WIPHY_FLAG_HAS_REMAIN_ON_CHANNEL;
 
+ if (ISSUPP_TDLS_ENABLED(adapter->fw_cap_info))
+  wiphy->flags |= WIPHY_FLAG_SUPPORTS_TDLS |
+    WIPHY_FLAG_TDLS_EXTERNAL_SETUP;
+
+ wiphy->regulatory_flags |=
+   REGULATORY_CUSTOM_REG |
+   REGULATORY_STRICT_REG;
+
  wiphy_apply_custom_regulatory(wiphy, &mwifiex_world_regdom_custom);
 
 #ifdef CONFIG_PM
- wiphy->wowlan.flags = WIPHY_WOWLAN_MAGIC_PKT;
- wiphy->wowlan.n_patterns = MWIFIEX_MAX_FILTERS;
- wiphy->wowlan.pattern_min_len = 1;
- wiphy->wowlan.pattern_max_len = MWIFIEX_MAX_PATTERN_LEN;
- wiphy->wowlan.max_pkt_offset = MWIFIEX_MAX_OFFSET_LEN;
+ wiphy->wowlan = &mwifiex_wowlan_support;
 #endif
 
+ wiphy->coalesce = &mwifiex_coalesce_support;
+
  wiphy->probe_resp_offload = NL80211_PROBE_RESP_OFFLOAD_SUPPORT_WPS |
         NL80211_PROBE_RESP_OFFLOAD_SUPPORT_WPS2 |
         NL80211_PROBE_RESP_OFFLOAD_SUPPORT_P2P;
@@ -2499,7 +2938,8 @@ int mwifiex_register_cfg80211(struct mwifiex_adapter *adapter)
 
  wiphy->features |= NL80211_FEATURE_HT_IBSS |
       NL80211_FEATURE_INACTIVITY_TIMER |
-      NL80211_FEATURE_LOW_PRIORITY_SCAN;
+      NL80211_FEATURE_LOW_PRIORITY_SCAN |
+      NL80211_FEATURE_NEED_OBSS_SCAN;
 
  /* Reserve space for mwifiex specific private data for BSS */
  wiphy->bss_priv_size = sizeof(struct mwifiex_bss_priv);
@@ -2519,10 +2959,29 @@ int mwifiex_register_cfg80211(struct mwifiex_adapter *adapter)
   wiphy_free(wiphy);
   return ret;
  }
- country_code = mwifiex_11d_code_2_region(priv->adapter->region_code);
- if (country_code)
-  dev_info(adapter->dev,
-    "ignoring F/W country code %2.2s\n", country_code);
+
+ if (reg_alpha2 && mwifiex_is_valid_alpha2(reg_alpha2)) {
+  wiphy_info(wiphy, "driver hint alpha2: %2.2s\n", reg_alpha2);
+  regulatory_hint(wiphy, reg_alpha2);
+ } else {
+  country_code = mwifiex_11d_code_2_region(adapter->region_code);
+  if (country_code)
+   wiphy_info(wiphy, "ignoring F/W country code %2.2s\n",
+       country_code);
+ }
+
+ mwifiex_send_cmd(priv, HostCmd_CMD_802_11_SNMP_MIB,
+    HostCmd_ACT_GEN_GET, FRAG_THRESH_I, &thr, true);
+ wiphy->frag_threshold = thr;
+ mwifiex_send_cmd(priv, HostCmd_CMD_802_11_SNMP_MIB,
+    HostCmd_ACT_GEN_GET, RTS_THRESH_I, &thr, true);
+ wiphy->rts_threshold = thr;
+ mwifiex_send_cmd(priv, HostCmd_CMD_802_11_SNMP_MIB,
+    HostCmd_ACT_GEN_GET, SHORT_RETRY_LIM_I, &retry, true);
+ wiphy->retry_short = (u8) retry;
+ mwifiex_send_cmd(priv, HostCmd_CMD_802_11_SNMP_MIB,
+    HostCmd_ACT_GEN_GET, LONG_RETRY_LIM_I, &retry, true);
+ wiphy->retry_long = (u8) retry;
 
  adapter->wiphy = wiphy;
  return ret;
diff --git a/drivers/net/wireless/mwifiex/cfp.c b/drivers/net/wireless/mwifiex/cfp.c
index 5178c46..0ddec3d 100644
--- a/drivers/net/wireless/mwifiex/cfp.c
+++ b/drivers/net/wireless/mwifiex/cfp.c
@@ -71,6 +71,95 @@ u16 region_code_index[MWIFIEX_MAX_REGION_CODE] = { 0x10, 0x20, 0x30,
 
 static u8 supported_rates_n[N_SUPPORTED_RATES] = { 0x02, 0x04, 0 };
 
+/* For every mcs_rate line, the first 8 bytes are for stream 1x1,
+ * and all 16 bytes are for stream 2x2.
+ */
+static const u16 mcs_rate[4][16] = {
+ /* LGI 40M */
+ { 0x1b, 0x36, 0x51, 0x6c, 0xa2, 0xd8, 0xf3, 0x10e,
+   0x36, 0x6c, 0xa2, 0xd8, 0x144, 0x1b0, 0x1e6, 0x21c },
+
+ /* SGI 40M */
+ { 0x1e, 0x3c, 0x5a, 0x78, 0xb4, 0xf0, 0x10e, 0x12c,
+   0x3c, 0x78, 0xb4, 0xf0, 0x168, 0x1e0, 0x21c, 0x258 },
+
+ /* LGI 20M */
+ { 0x0d, 0x1a, 0x27, 0x34, 0x4e, 0x68, 0x75, 0x82,
+   0x1a, 0x34, 0x4e, 0x68, 0x9c, 0xd0, 0xea, 0x104 },
+
+ /* SGI 20M */
+ { 0x0e, 0x1c, 0x2b, 0x39, 0x56, 0x73, 0x82, 0x90,
+   0x1c, 0x39, 0x56, 0x73, 0xad, 0xe7, 0x104, 0x120 }
+};
+
+/* AC rates */
+static const u16 ac_mcs_rate_nss1[8][10] = {
+ /* LG 160M */
+ { 0x75, 0xEA, 0x15F, 0x1D4, 0x2BE, 0x3A8, 0x41D,
+   0x492, 0x57C, 0x618 },
+
+ /* SG 160M */
+ { 0x82, 0x104, 0x186, 0x208, 0x30C, 0x410, 0x492,
+   0x514, 0x618, 0x6C6 },
+
+ /* LG 80M */
+ { 0x3B, 0x75, 0xB0, 0xEA, 0x15F, 0x1D4, 0x20F,
+   0x249, 0x2BE, 0x30C },
+
+ /* SG 80M */
+ { 0x41, 0x82, 0xC3, 0x104, 0x186, 0x208, 0x249,
+   0x28A, 0x30C, 0x363 },
+
+ /* LG 40M */
+ { 0x1B, 0x36, 0x51, 0x6C, 0xA2, 0xD8, 0xF3,
+   0x10E, 0x144, 0x168 },
+
+ /* SG 40M */
+ { 0x1E, 0x3C, 0x5A, 0x78, 0xB4, 0xF0, 0x10E,
+   0x12C, 0x168, 0x190 },
+
+ /* LG 20M */
+ { 0xD, 0x1A, 0x27, 0x34, 0x4E, 0x68, 0x75, 0x82, 0x9C, 0x00 },
+
+ /* SG 20M */
+ { 0xF, 0x1D, 0x2C, 0x3A, 0x57, 0x74, 0x82, 0x91, 0xAE, 0x00 },
+};
+
+/* NSS2 note: the value in the table is 2 multiplier of the actual rate */
+static const u16 ac_mcs_rate_nss2[8][10] = {
+ /* LG 160M */
+ { 0xEA, 0x1D4, 0x2BE, 0x3A8, 0x57C, 0x750, 0x83A,
+   0x924, 0xAF8, 0xC30 },
+
+ /* SG 160M */
+ { 0x104, 0x208, 0x30C, 0x410, 0x618, 0x820, 0x924,
+   0xA28, 0xC30, 0xD8B },
+
+ /* LG 80M */
+ { 0x75, 0xEA, 0x15F, 0x1D4, 0x2BE, 0x3A8, 0x41D,
+   0x492, 0x57C, 0x618 },
+
+ /* SG 80M */
+ { 0x82, 0x104, 0x186, 0x208, 0x30C, 0x410, 0x492,
+   0x514, 0x618, 0x6C6 },
+
+ /* LG 40M */
+ { 0x36, 0x6C, 0xA2, 0xD8, 0x144, 0x1B0, 0x1E6,
+   0x21C, 0x288, 0x2D0 },
+
+ /* SG 40M */
+ { 0x3C, 0x78, 0xB4, 0xF0, 0x168, 0x1E0, 0x21C,
+   0x258, 0x2D0, 0x320 },
+
+ /* LG 20M */
+ { 0x1A, 0x34, 0x4A, 0x68, 0x9C, 0xD0, 0xEA, 0x104,
+   0x138, 0x00 },
+
+ /* SG 20M */
+ { 0x1D, 0x3A, 0x57, 0x74, 0xAE, 0xE6, 0x104, 0x121,
+   0x15B, 0x00 },
+};
+
 struct region_code_mapping {
  u8 code;
  u8 region[IEEE80211_COUNTRY_STRING_LEN];
@@ -109,95 +198,6 @@ u8 *mwifiex_11d_code_2_region(u8 code)
 u32 mwifiex_index_to_acs_data_rate(struct mwifiex_private *priv,
        u8 index, u8 ht_info)
 {
- /*
-  * For every mcs_rate line, the first 8 bytes are for stream 1x1,
-  * and all 16 bytes are for stream 2x2.
-  */
- u16  mcs_rate[4][16] = {
-  /* LGI 40M */
-  { 0x1b, 0x36, 0x51, 0x6c, 0xa2, 0xd8, 0xf3, 0x10e,
-    0x36, 0x6c, 0xa2, 0xd8, 0x144, 0x1b0, 0x1e6, 0x21c },
-
-  /* SGI 40M */
-  { 0x1e, 0x3c, 0x5a, 0x78, 0xb4, 0xf0, 0x10e, 0x12c,
-    0x3c, 0x78, 0xb4, 0xf0, 0x168, 0x1e0, 0x21c, 0x258 },
-
-  /* LGI 20M */
-  { 0x0d, 0x1a, 0x27, 0x34, 0x4e, 0x68, 0x75, 0x82,
-    0x1a, 0x34, 0x4e, 0x68, 0x9c, 0xd0, 0xea, 0x104 },
-
-  /* SGI 20M */
-  { 0x0e, 0x1c, 0x2b, 0x39, 0x56, 0x73, 0x82, 0x90,
-    0x1c, 0x39, 0x56, 0x73, 0xad, 0xe7, 0x104, 0x120 }
- };
- /* AC rates */
- u16 ac_mcs_rate_nss1[8][10] = {
-  /* LG 160M */
-  { 0x75, 0xEA, 0x15F, 0x1D4, 0x2BE, 0x3A8, 0x41D,
-    0x492, 0x57C, 0x618 },
-
-  /* SG 160M */
-  { 0x82, 0x104, 0x186, 0x208, 0x30C, 0x410, 0x492,
-    0x514, 0x618, 0x6C6 },
-
-  /* LG 80M */
-  { 0x3B, 0x75, 0xB0, 0xEA, 0x15F, 0x1D4, 0x20F,
-    0x249, 0x2BE, 0x30C },
-
-  /* SG 80M */
-  { 0x41, 0x82, 0xC3, 0x104, 0x186, 0x208, 0x249,
-    0x28A, 0x30C, 0x363 },
-
-  /* LG 40M */
-  { 0x1B, 0x36, 0x51, 0x6C, 0xA2, 0xD8, 0xF3,
-    0x10E, 0x144, 0x168 },
-
-  /* SG 40M */
-  { 0x1E, 0x3C, 0x5A, 0x78, 0xB4, 0xF0, 0x10E,
-    0x12C, 0x168, 0x190 },
-
-  /* LG 20M */
-  { 0xD, 0x1A, 0x27, 0x34, 0x4E, 0x68, 0x75, 0x82, 0x9C, 0x00 },
-
-  /* SG 20M */
-  { 0xF, 0x1D, 0x2C, 0x3A, 0x57, 0x74, 0x82, 0x91, 0xAE, 0x00 },
- };
- /* NSS2 note: the value in the table is 2 multiplier of the actual
-  * rate
-  */
- u16 ac_mcs_rate_nss2[8][10] = {
-  /* LG 160M */
-  { 0xEA, 0x1D4, 0x2BE, 0x3A8, 0x57C, 0x750, 0x83A,
-    0x924, 0xAF8, 0xC30 },
-
-  /* SG 160M */
-  { 0x104, 0x208, 0x30C, 0x410, 0x618, 0x820, 0x924,
-    0xA28, 0xC30, 0xD8B },
-
-  /* LG 80M */
-  { 0x75, 0xEA, 0x15F, 0x1D4, 0x2BE, 0x3A8, 0x41D,
-    0x492, 0x57C, 0x618 },
-
-  /* SG 80M */
-  { 0x82, 0x104, 0x186, 0x208, 0x30C, 0x410, 0x492,
-    0x514, 0x618, 0x6C6 },
-
-  /* LG 40M */
-  { 0x36, 0x6C, 0xA2, 0xD8, 0x144, 0x1B0, 0x1E6,
-    0x21C, 0x288, 0x2D0 },
-
-  /* SG 40M */
-  { 0x3C, 0x78, 0xB4, 0xF0, 0x168, 0x1E0, 0x21C,
-    0x258, 0x2D0, 0x320 },
-
-  /* LG 20M */
-  { 0x1A, 0x34, 0x4A, 0x68, 0x9C, 0xD0, 0xEA, 0x104,
-    0x138, 0x00 },
-
-  /* SG 20M */
-  { 0x1D, 0x3A, 0x57, 0x74, 0xAE, 0xE6, 0x104, 0x121,
-    0x15B, 0x00 },
- };
  u32 rate = 0;
  u8 mcs_index = 0;
  u8 bw = 0;
@@ -252,28 +252,8 @@ u32 mwifiex_index_to_acs_data_rate(struct mwifiex_private *priv,
 u32 mwifiex_index_to_data_rate(struct mwifiex_private *priv,
           u8 index, u8 ht_info)
 {
- /* For every mcs_rate line, the first 8 bytes are for stream 1x1,
-  * and all 16 bytes are for stream 2x2.
-  */
- u16  mcs_rate[4][16] = {
-  /* LGI 40M */
-  { 0x1b, 0x36, 0x51, 0x6c, 0xa2, 0xd8, 0xf3, 0x10e,
-    0x36, 0x6c, 0xa2, 0xd8, 0x144, 0x1b0, 0x1e6, 0x21c },
-
-  /* SGI 40M */
-  { 0x1e, 0x3c, 0x5a, 0x78, 0xb4, 0xf0, 0x10e, 0x12c,
-    0x3c, 0x78, 0xb4, 0xf0, 0x168, 0x1e0, 0x21c, 0x258 },
-
-  /* LGI 20M */
-  { 0x0d, 0x1a, 0x27, 0x34, 0x4e, 0x68, 0x75, 0x82,
-    0x1a, 0x34, 0x4e, 0x68, 0x9c, 0xd0, 0xea, 0x104 },
-
-  /* SGI 20M */
-  { 0x0e, 0x1c, 0x2b, 0x39, 0x56, 0x73, 0x82, 0x90,
-    0x1c, 0x39, 0x56, 0x73, 0xad, 0xe7, 0x104, 0x120 }
- };
  u32 mcs_num_supp =
-  (priv->adapter->hw_dev_mcs_support == HT_STREAM_2X2) ? 16 : 8;
+  (priv->adapter->user_dev_mcs_support == HT_STREAM_2X2) ? 16 : 8;
  u32 rate;
 
  if (priv->adapter->is_hw_11ac_capable)
@@ -404,11 +384,43 @@ mwifiex_is_rate_auto(struct mwifiex_private *priv)
   return false;
 }
 
-/*
- * This function gets the supported data rates.
- *
- * The function works in both Ad-Hoc and infra mode by printing the
- * band and returning the data rates.
+/* This function gets the supported data rates from bitmask inside
+ * cfg80211_scan_request.
+ */
+u32 mwifiex_get_rates_from_cfg80211(struct mwifiex_private *priv,
+        u8 *rates, u8 radio_type)
+{
+ struct wiphy *wiphy = priv->adapter->wiphy;
+ struct cfg80211_scan_request *request = priv->scan_request;
+ u32 num_rates, rate_mask;
+ struct ieee80211_supported_band *sband;
+ int i;
+
+ if (radio_type) {
+  sband = wiphy->bands[IEEE80211_BAND_5GHZ];
+  if (WARN_ON_ONCE(!sband))
+   return 0;
+  rate_mask = request->rates[IEEE80211_BAND_5GHZ];
+ } else {
+  sband = wiphy->bands[IEEE80211_BAND_2GHZ];
+  if (WARN_ON_ONCE(!sband))
+   return 0;
+  rate_mask = request->rates[IEEE80211_BAND_2GHZ];
+ }
+
+ num_rates = 0;
+ for (i = 0; i < sband->n_bitrates; i++) {
+  if ((BIT(i) & rate_mask) == 0)
+   continue; /* skip rate */
+  rates[num_rates++] = (u8)(sband->bitrates[i].bitrate / 5);
+ }
+
+ return num_rates;
+}
+
+/* This function gets the supported data rates. The function works in
+ * both Ad-Hoc and infra mode by printing the band and returning the
+ * data rates.
  */
 u32 mwifiex_get_supported_rates(struct mwifiex_private *priv, u8 *rates)
 {
@@ -426,7 +438,6 @@ u32 mwifiex_get_supported_rates(struct mwifiex_private *priv, u8 *rates)
    break;
   case BAND_G:
   case BAND_G | BAND_GN:
-  case BAND_G | BAND_GN | BAND_GAC:
    dev_dbg(adapter->dev, "info: infra band=%d "
     "supported_rates_g\n", adapter->config_bands);
    k = mwifiex_copy_rates(rates, k, supported_rates_g,
@@ -437,10 +448,7 @@ u32 mwifiex_get_supported_rates(struct mwifiex_private *priv, u8 *rates)
   case BAND_A | BAND_B:
   case BAND_A | BAND_B | BAND_G | BAND_GN | BAND_AN:
   case BAND_A | BAND_B | BAND_G | BAND_GN | BAND_AN | BAND_AAC:
-  case BAND_A | BAND_B | BAND_G | BAND_GN | BAND_AN |
-       BAND_AAC | BAND_GAC:
   case BAND_B | BAND_G | BAND_GN:
-  case BAND_B | BAND_G | BAND_GN | BAND_GAC:
    dev_dbg(adapter->dev, "info: infra band=%d "
     "supported_rates_bg\n", adapter->config_bands);
    k = mwifiex_copy_rates(rates, k, supported_rates_bg,
@@ -464,7 +472,6 @@ u32 mwifiex_get_supported_rates(struct mwifiex_private *priv, u8 *rates)
             sizeof(supported_rates_a));
    break;
   case BAND_GN:
-  case BAND_GN | BAND_GAC:
    dev_dbg(adapter->dev, "info: infra band=%d "
     "supported_rates_n\n", adapter->config_bands);
    k = mwifiex_copy_rates(rates, k, supported_rates_n,
diff --git a/drivers/net/wireless/mwifiex/cmdevt.c b/drivers/net/wireless/mwifiex/cmdevt.c
index 7a97f6c..c161141 100644
--- a/drivers/net/wireless/mwifiex/cmdevt.c
+++ b/drivers/net/wireless/mwifiex/cmdevt.c
@@ -37,13 +37,12 @@
 static void
 mwifiex_init_cmd_node(struct mwifiex_private *priv,
         struct cmd_ctrl_node *cmd_node,
-        u32 cmd_oid, void *data_buf)
+        u32 cmd_oid, void *data_buf, bool sync)
 {
  cmd_node->priv = priv;
  cmd_node->cmd_oid = cmd_oid;
- if (priv->adapter->cmd_wait_q_required) {
-  cmd_node->wait_q_enabled = priv->adapter->cmd_wait_q_required;
-  priv->adapter->cmd_wait_q_required = false;
+ if (sync) {
+  cmd_node->wait_q_enabled = true;
   cmd_node->cmd_wait_q_woken = false;
   cmd_node->condition = &cmd_node->cmd_wait_q_woken;
  }
@@ -166,8 +165,10 @@ static int mwifiex_dnld_cmd_to_fw(struct mwifiex_private *priv,
   dev_err(adapter->dev,
    "DNLD_CMD: FW in reset state, ignore cmd %#x\n",
    cmd_code);
-  mwifiex_complete_cmd(adapter, cmd_node);
+  if (cmd_node->wait_q_enabled)
+   mwifiex_complete_cmd(adapter, cmd_node);
   mwifiex_recycle_cmd_node(adapter, cmd_node);
+  queue_work(adapter->workqueue, &adapter->main_work);
   return -1;
  }
 
@@ -276,11 +277,11 @@ static int mwifiex_dnld_sleep_confirm_cmd(struct mwifiex_adapter *adapter)
 
  priv = mwifiex_get_priv(adapter, MWIFIEX_BSS_ROLE_ANY);
 
+ adapter->seq_num++;
  sleep_cfm_buf->seq_num =
   cpu_to_le16((HostCmd_SET_SEQ_NO_BSS_INFO
      (adapter->seq_num, priv->bss_num,
       priv->bss_type)));
- adapter->seq_num++;
 
  if (adapter->iface_type == MWIFIEX_USB) {
   sleep_cfm_tmp =
@@ -312,14 +313,14 @@ static int mwifiex_dnld_sleep_confirm_cmd(struct mwifiex_adapter *adapter)
  }
  if (GET_BSS_ROLE(mwifiex_get_priv(adapter, MWIFIEX_BSS_ROLE_ANY))
      == MWIFIEX_BSS_ROLE_STA) {
-  if (!sleep_cfm_buf->resp_ctrl)
+  if (!le16_to_cpu(sleep_cfm_buf->resp_ctrl))
    /* Response is not needed for sleep
       confirm command */
    adapter->ps_state = PS_STATE_SLEEP;
   else
    adapter->ps_state = PS_STATE_SLEEP_CFM;
 
-  if (!sleep_cfm_buf->resp_ctrl &&
+  if (!le16_to_cpu(sleep_cfm_buf->resp_ctrl) &&
       (adapter->is_hs_configured &&
        !adapter->sleep_period.period)) {
    adapter->pm_wakeup_card_req = true;
@@ -452,6 +453,7 @@ int mwifiex_process_event(struct mwifiex_adapter *adapter)
 
  if (skb) {
   rx_info = MWIFIEX_SKB_RXCB(skb);
+  memset(rx_info, 0, sizeof(*rx_info));
   rx_info->bss_num = priv->bss_num;
   rx_info->bss_type = priv->bss_type;
  }
@@ -480,28 +482,7 @@ int mwifiex_process_event(struct mwifiex_adapter *adapter)
 }
 
 /*
- * This function is used to send synchronous command to the firmware.
- *
- * it allocates a wait queue for the command and wait for the command
- * response.
- */
-int mwifiex_send_cmd_sync(struct mwifiex_private *priv, uint16_t cmd_no,
-     u16 cmd_action, u32 cmd_oid, void *data_buf)
-{
- int ret = 0;
- struct mwifiex_adapter *adapter = priv->adapter;
-
- adapter->cmd_wait_q_required = true;
-
- ret = mwifiex_send_cmd_async(priv, cmd_no, cmd_action, cmd_oid,
-         data_buf);
-
- return ret;
-}
-
-
-/*
- * This function prepares a command and asynchronously send it to the firmware.
+ * This function prepares a command and send it to the firmware.
  *
  * Preparation includes -
  *      - Sanity tests to make sure the card is still present or the FW
@@ -511,8 +492,8 @@ int mwifiex_send_cmd_sync(struct mwifiex_private *priv, uint16_t cmd_no,
  *      - Fill up the non-default parameters and buffer pointers
  *      - Add the command to pending queue
  */
-int mwifiex_send_cmd_async(struct mwifiex_private *priv, uint16_t cmd_no,
-      u16 cmd_action, u32 cmd_oid, void *data_buf)
+int mwifiex_send_cmd(struct mwifiex_private *priv, u16 cmd_no,
+       u16 cmd_action, u32 cmd_oid, void *data_buf, bool sync)
 {
  int ret;
  struct mwifiex_adapter *adapter = priv->adapter;
@@ -529,11 +510,21 @@ int mwifiex_send_cmd_async(struct mwifiex_private *priv, uint16_t cmd_no,
   return -1;
  }
 
+ if (adapter->hs_enabling && cmd_no != HostCmd_CMD_802_11_HS_CFG_ENH) {
+  dev_err(adapter->dev, "PREP_CMD: host entering sleep state\n");
+  return -1;
+ }
+
  if (adapter->surprise_removed) {
   dev_err(adapter->dev, "PREP_CMD: card is removed\n");
   return -1;
  }
 
+ if (adapter->is_cmd_timedout) {
+  dev_err(adapter->dev, "PREP_CMD: FW is in bad state\n");
+  return -1;
+ }
+
  if (adapter->hw_status == MWIFIEX_HW_STATUS_RESET) {
   if (cmd_no != HostCmd_CMD_FUNC_INIT) {
    dev_err(adapter->dev, "PREP_CMD: FW in reset state\n");
@@ -550,7 +541,7 @@ int mwifiex_send_cmd_async(struct mwifiex_private *priv, uint16_t cmd_no,
  }
 
  /* Initialize the command node */
- mwifiex_init_cmd_node(priv, cmd_node, cmd_oid, data_buf);
+ mwifiex_init_cmd_node(priv, cmd_node, cmd_oid, data_buf, sync);
 
  if (!cmd_node->cmd_skb) {
   dev_err(adapter->dev, "PREP_CMD: no free cmd buf\n");
@@ -570,6 +561,7 @@ int mwifiex_send_cmd_async(struct mwifiex_private *priv, uint16_t cmd_no,
   case HostCmd_CMD_UAP_SYS_CONFIG:
   case HostCmd_CMD_UAP_BSS_START:
   case HostCmd_CMD_UAP_BSS_STOP:
+  case HostCmd_CMD_UAP_STA_DEAUTH:
    ret = mwifiex_uap_prepare_cmd(priv, cmd_no, cmd_action,
             cmd_oid, data_buf,
             cmd_ptr);
@@ -594,7 +586,8 @@ int mwifiex_send_cmd_async(struct mwifiex_private *priv, uint16_t cmd_no,
  }
 
  /* Send command */
- if (cmd_no == HostCmd_CMD_802_11_SCAN) {
+ if (cmd_no == HostCmd_CMD_802_11_SCAN ||
+     cmd_no == HostCmd_CMD_802_11_SCAN_EXT) {
   mwifiex_queue_scan_cmd(priv, cmd_node);
  } else {
   mwifiex_insert_cmd_to_pending_q(adapter, cmd_node, true);
@@ -784,7 +777,7 @@ int mwifiex_process_cmdresp(struct mwifiex_adapter *adapter)
  unsigned long flags;
 
  /* Now we got response from FW, cancel the command timer */
- del_timer(&adapter->cmd_timer);
+ del_timer_sync(&adapter->cmd_timer);
 
  if (!adapter->curr_cmd || !adapter->curr_cmd->resp_skb) {
   resp = (struct host_cmd_ds_command *) adapter->upld_buf;
@@ -793,7 +786,7 @@ int mwifiex_process_cmdresp(struct mwifiex_adapter *adapter)
   return -1;
  }
 
- adapter->num_cmd_timeout = 0;
+ adapter->is_cmd_timedout = 0;
 
  resp = (struct host_cmd_ds_command *) adapter->curr_cmd->resp_skb->data;
  if (adapter->curr_cmd->cmd_flag & CMD_F_CANCELED) {
@@ -904,8 +897,7 @@ mwifiex_cmd_timeout_func(unsigned long function_context)
  struct cmd_ctrl_node *cmd_node;
  struct timeval tstamp;
 
- adapter->num_cmd_timeout++;
- adapter->dbg.num_cmd_timeout++;
+ adapter->is_cmd_timedout = 1;
  if (!adapter->curr_cmd) {
   dev_dbg(adapter->dev, "cmd: empty curr_cmd\n");
   return;
@@ -928,8 +920,8 @@ mwifiex_cmd_timeout_func(unsigned long function_context)
   dev_err(adapter->dev, "num_cmd_h2c_failure = %d\n",
    adapter->dbg.num_cmd_host_to_card_failure);
 
-  dev_err(adapter->dev, "num_cmd_timeout = %d\n",
-   adapter->dbg.num_cmd_timeout);
+  dev_err(adapter->dev, "is_cmd_timedout = %d\n",
+   adapter->is_cmd_timedout);
   dev_err(adapter->dev, "num_tx_timeout = %d\n",
    adapter->dbg.num_tx_timeout);
 
@@ -964,8 +956,6 @@ mwifiex_cmd_timeout_func(unsigned long function_context)
    adapter->cmd_wait_q.status = -ETIMEDOUT;
    wake_up_interruptible(&adapter->cmd_wait_q.wait);
    mwifiex_cancel_pending_ioctl(adapter);
-   /* reset cmd_sent flag to unblock new commands */
-   adapter->cmd_sent = false;
   }
  }
  if (adapter->hw_status == MWIFIEX_HW_STATUS_INITIALIZING)
@@ -986,13 +976,14 @@ void
 mwifiex_cancel_all_pending_cmd(struct mwifiex_adapter *adapter)
 {
  struct cmd_ctrl_node *cmd_node = NULL, *tmp_node;
- unsigned long flags;
+ unsigned long flags, cmd_flags;
+ struct mwifiex_private *priv;
+ int i;
 
+ spin_lock_irqsave(&adapter->mwifiex_cmd_lock, cmd_flags);
  /* Cancel current cmd */
  if ((adapter->curr_cmd) && (adapter->curr_cmd->wait_q_enabled)) {
-  spin_lock_irqsave(&adapter->mwifiex_cmd_lock, flags);
   adapter->curr_cmd->wait_q_enabled = false;
-  spin_unlock_irqrestore(&adapter->mwifiex_cmd_lock, flags);
   adapter->cmd_wait_q.status = -1;
   mwifiex_complete_cmd(adapter, adapter->curr_cmd);
  }
@@ -1012,6 +1003,7 @@ mwifiex_cancel_all_pending_cmd(struct mwifiex_adapter *adapter)
   spin_lock_irqsave(&adapter->cmd_pending_q_lock, flags);
  }
  spin_unlock_irqrestore(&adapter->cmd_pending_q_lock, flags);
+ spin_unlock_irqrestore(&adapter->mwifiex_cmd_lock, cmd_flags);
 
  /* Cancel all pending scan command */
  spin_lock_irqsave(&adapter->scan_pending_q_lock, flags);
@@ -1026,9 +1018,21 @@ mwifiex_cancel_all_pending_cmd(struct mwifiex_adapter *adapter)
  }
  spin_unlock_irqrestore(&adapter->scan_pending_q_lock, flags);
 
- spin_lock_irqsave(&adapter->mwifiex_cmd_lock, flags);
- adapter->scan_processing = false;
- spin_unlock_irqrestore(&adapter->mwifiex_cmd_lock, flags);
+ if (adapter->scan_processing) {
+  spin_lock_irqsave(&adapter->mwifiex_cmd_lock, cmd_flags);
+  adapter->scan_processing = false;
+  spin_unlock_irqrestore(&adapter->mwifiex_cmd_lock, cmd_flags);
+  for (i = 0; i < adapter->priv_num; i++) {
+   priv = adapter->priv[i];
+   if (!priv)
+    continue;
+   if (priv->scan_request) {
+    dev_dbg(adapter->dev, "info: aborting scan\n");
+    cfg80211_scan_done(priv->scan_request, 1);
+    priv->scan_request = NULL;
+   }
+  }
+ }
 }
 
 /*
@@ -1047,7 +1051,8 @@ mwifiex_cancel_pending_ioctl(struct mwifiex_adapter *adapter)
  struct cmd_ctrl_node *cmd_node = NULL, *tmp_node = NULL;
  unsigned long cmd_flags;
  unsigned long scan_pending_q_flags;
- uint16_t cancel_scan_cmd = false;
+ struct mwifiex_private *priv;
+ int i;
 
  if ((adapter->curr_cmd) &&
      (adapter->curr_cmd->wait_q_enabled)) {
@@ -1073,15 +1078,24 @@ mwifiex_cancel_pending_ioctl(struct mwifiex_adapter *adapter)
   mwifiex_insert_cmd_to_free_q(adapter, cmd_node);
   spin_lock_irqsave(&adapter->scan_pending_q_lock,
       scan_pending_q_flags);
-  cancel_scan_cmd = true;
  }
  spin_unlock_irqrestore(&adapter->scan_pending_q_lock,
           scan_pending_q_flags);
 
- if (cancel_scan_cmd) {
+ if (adapter->scan_processing) {
   spin_lock_irqsave(&adapter->mwifiex_cmd_lock, cmd_flags);
   adapter->scan_processing = false;
   spin_unlock_irqrestore(&adapter->mwifiex_cmd_lock, cmd_flags);
+  for (i = 0; i < adapter->priv_num; i++) {
+   priv = adapter->priv[i];
+   if (!priv)
+    continue;
+   if (priv->scan_request) {
+    dev_dbg(adapter->dev, "info: aborting scan\n");
+    cfg80211_scan_done(priv->scan_request, 1);
+    priv->scan_request = NULL;
+   }
+  }
  }
  adapter->cmd_wait_q.status = -1;
 }
@@ -1453,7 +1467,10 @@ int mwifiex_ret_get_hw_spec(struct mwifiex_private *priv,
 {
  struct host_cmd_ds_get_hw_spec *hw_spec = &resp->params.hw_spec;
  struct mwifiex_adapter *adapter = priv->adapter;
- int i;
+ struct mwifiex_ie_types_header *tlv;
+ struct hw_spec_fw_api_rev *api_rev;
+ u16 resp_size, api_id;
+ int i, left_len, parsed_len = 0;
 
  adapter->fw_cap_info = le32_to_cpu(hw_spec->fw_cap_info);
 
@@ -1489,6 +1506,7 @@ int mwifiex_ret_get_hw_spec(struct mwifiex_private *priv,
  }
 
  adapter->fw_release_number = le32_to_cpu(hw_spec->fw_release_number);
+ adapter->fw_api_ver = (adapter->fw_release_number >> 16) & 0xff;
  adapter->number_of_antenna = le16_to_cpu(hw_spec->number_of_antenna);
 
  if (le32_to_cpu(hw_spec->dot_11ac_dev_cap)) {
@@ -1497,8 +1515,10 @@ int mwifiex_ret_get_hw_spec(struct mwifiex_private *priv,
   /* Copy 11AC cap */
   adapter->hw_dot_11ac_dev_cap =
      le32_to_cpu(hw_spec->dot_11ac_dev_cap);
-  adapter->usr_dot_11ac_dev_cap_bg = adapter->hw_dot_11ac_dev_cap;
-  adapter->usr_dot_11ac_dev_cap_a = adapter->hw_dot_11ac_dev_cap;
+  adapter->usr_dot_11ac_dev_cap_bg = adapter->hw_dot_11ac_dev_cap
+     & ~MWIFIEX_DEF_11AC_CAP_BF_RESET_MASK;
+  adapter->usr_dot_11ac_dev_cap_a = adapter->hw_dot_11ac_dev_cap
+     & ~MWIFIEX_DEF_11AC_CAP_BF_RESET_MASK;
 
   /* Copy 11AC mcs */
   adapter->hw_dot_11ac_mcs_support =
@@ -1509,6 +1529,46 @@ int mwifiex_ret_get_hw_spec(struct mwifiex_private *priv,
   adapter->is_hw_11ac_capable = false;
  }
 
+ resp_size = le16_to_cpu(resp->size) - S_DS_GEN;
+ if (resp_size > sizeof(struct host_cmd_ds_get_hw_spec)) {
+  /* we have variable HW SPEC information */
+  left_len = resp_size - sizeof(struct host_cmd_ds_get_hw_spec);
+  while (left_len > sizeof(struct mwifiex_ie_types_header)) {
+   tlv = (void *)&hw_spec->tlvs + parsed_len;
+   switch (le16_to_cpu(tlv->type)) {
+   case TLV_TYPE_FW_API_REV:
+    api_rev = (struct hw_spec_fw_api_rev *)tlv;
+    api_id = le16_to_cpu(api_rev->api_id);
+    switch (api_id) {
+    case KEY_API_VER_ID:
+     adapter->fw_key_api_major_ver =
+       api_rev->major_ver;
+     adapter->fw_key_api_minor_ver =
+       api_rev->minor_ver;
+     dev_dbg(adapter->dev,
+      "fw_key_api v%d.%d\n",
+      adapter->fw_key_api_major_ver,
+      adapter->fw_key_api_minor_ver);
+     break;
+    default:
+     dev_warn(adapter->dev,
+       "Unknown FW api_id: %d\n",
+       api_id);
+     break;
+    }
+    break;
+   default:
+    dev_warn(adapter->dev,
+      "Unknown GET_HW_SPEC TLV type: %#x\n",
+      le16_to_cpu(tlv->type));
+    break;
+   }
+   parsed_len += le16_to_cpu(tlv->len) +
+          sizeof(struct mwifiex_ie_types_header);
+   left_len -= parsed_len;
+  }
+ }
+
  dev_dbg(adapter->dev, "info: GET_HW_SPEC: fw_release_number- %#x\n",
   adapter->fw_release_number);
  dev_dbg(adapter->dev, "info: GET_HW_SPEC: permanent addr: %pM\n",
@@ -1537,6 +1597,7 @@ int mwifiex_ret_get_hw_spec(struct mwifiex_private *priv,
 
  adapter->hw_dot_11n_dev_cap = le32_to_cpu(hw_spec->dot_11n_dev_cap);
  adapter->hw_dev_mcs_support = hw_spec->dev_mcs_support;
+ adapter->user_dev_mcs_support = adapter->hw_dev_mcs_support;
 
  if (adapter->if_ops.update_mp_end_port)
   adapter->if_ops.update_mp_end_port(adapter,
diff --git a/drivers/net/wireless/mwifiex/debugfs.c b/drivers/net/wireless/mwifiex/debugfs.c
index a5f9875..7b419bb 100644
--- a/drivers/net/wireless/mwifiex/debugfs.c
+++ b/drivers/net/wireless/mwifiex/debugfs.c
@@ -85,8 +85,8 @@ static struct mwifiex_debug_data items[] = {
   item_addr(hs_activated), 1},
  {"num_tx_timeout", item_size(num_tx_timeout),
   item_addr(num_tx_timeout), 1},
- {"num_cmd_timeout", item_size(num_cmd_timeout),
-  item_addr(num_cmd_timeout), 1},
+ {"is_cmd_timedout", item_size(is_cmd_timedout),
+  item_addr(is_cmd_timedout), 1},
  {"timeout_cmd_id", item_size(timeout_cmd_id),
   item_addr(timeout_cmd_id), 1},
  {"timeout_cmd_act", item_size(timeout_cmd_act),
@@ -257,6 +257,29 @@ free_and_exit:
 }
 
 /*
+ * Proc firmware dump read handler.
+ *
+ * This function is called when the 'fw_dump' file is opened for
+ * reading.
+ * This function dumps firmware memory in different files
+ * (ex. DTCM, ITCM, SQRAM etc.) based on the the segments for
+ * debugging.
+ */
+static ssize_t
+mwifiex_fw_dump_read(struct file *file, char __user *ubuf,
+       size_t count, loff_t *ppos)
+{
+ struct mwifiex_private *priv = file->private_data;
+
+ if (!priv->adapter->if_ops.fw_dump)
+  return -EIO;
+
+ priv->adapter->if_ops.fw_dump(priv->adapter);
+
+ return 0;
+}
+
+/*
  * Proc getlog file read handler.
  *
  * This function is called when the 'getlog' file is opened for reading
@@ -493,7 +516,7 @@ mwifiex_regrdwr_write(struct file *file,
 {
  unsigned long addr = get_zeroed_page(GFP_KERNEL);
  char *buf = (char *) addr;
- size_t buf_size = min(count, (size_t) (PAGE_SIZE - 1));
+ size_t buf_size = min_t(size_t, count, PAGE_SIZE - 1);
  int ret;
  u32 reg_type = 0, reg_offset = 0, reg_value = UINT_MAX;
 
@@ -594,7 +617,7 @@ mwifiex_rdeeprom_write(struct file *file,
 {
  unsigned long addr = get_zeroed_page(GFP_KERNEL);
  char *buf = (char *) addr;
- size_t buf_size = min(count, (size_t) (PAGE_SIZE - 1));
+ size_t buf_size = min_t(size_t, count, PAGE_SIZE - 1);
  int ret = 0;
  int offset = -1, bytes = -1;
 
@@ -699,6 +722,7 @@ static const struct file_operations mwifiex_dfs_##name##_fops = {       \
 MWIFIEX_DFS_FILE_READ_OPS(info);
 MWIFIEX_DFS_FILE_READ_OPS(debug);
 MWIFIEX_DFS_FILE_READ_OPS(getlog);
+MWIFIEX_DFS_FILE_READ_OPS(fw_dump);
 MWIFIEX_DFS_FILE_OPS(regrdwr);
 MWIFIEX_DFS_FILE_OPS(rdeeprom);
 
@@ -722,6 +746,7 @@ mwifiex_dev_debugfs_init(struct mwifiex_private *priv)
  MWIFIEX_DFS_ADD_FILE(getlog);
  MWIFIEX_DFS_ADD_FILE(regrdwr);
  MWIFIEX_DFS_ADD_FILE(rdeeprom);
+ MWIFIEX_DFS_ADD_FILE(fw_dump);
 }
 
 /*
diff --git a/drivers/net/wireless/mwifiex/decl.h b/drivers/net/wireless/mwifiex/decl.h
index 94cc09d..38da6ff 100644
--- a/drivers/net/wireless/mwifiex/decl.h
+++ b/drivers/net/wireless/mwifiex/decl.h
@@ -26,6 +26,7 @@
 #include <linux/wait.h>
 #include <linux/timer.h>
 #include <linux/ieee80211.h>
+#include <uapi/linux/if_arp.h>
 #include <net/mac80211.h>
 
 
@@ -41,12 +42,12 @@
 #define MWIFIEX_MAX_TX_BASTREAM_SUPPORTED 2
 #define MWIFIEX_MAX_RX_BASTREAM_SUPPORTED 16
 
-#define MWIFIEX_STA_AMPDU_DEF_TXWINSIZE        16
-#define MWIFIEX_STA_AMPDU_DEF_RXWINSIZE        32
+#define MWIFIEX_STA_AMPDU_DEF_TXWINSIZE        64
+#define MWIFIEX_STA_AMPDU_DEF_RXWINSIZE        64
 #define MWIFIEX_UAP_AMPDU_DEF_TXWINSIZE        32
 #define MWIFIEX_UAP_AMPDU_DEF_RXWINSIZE        16
-#define MWIFIEX_11AC_STA_AMPDU_DEF_TXWINSIZE   32
-#define MWIFIEX_11AC_STA_AMPDU_DEF_RXWINSIZE   48
+#define MWIFIEX_11AC_STA_AMPDU_DEF_TXWINSIZE   64
+#define MWIFIEX_11AC_STA_AMPDU_DEF_RXWINSIZE   64
 #define MWIFIEX_11AC_UAP_AMPDU_DEF_TXWINSIZE   48
 #define MWIFIEX_11AC_UAP_AMPDU_DEF_RXWINSIZE   32
 
@@ -74,8 +75,15 @@
 
 #define MWIFIEX_BUF_FLAG_REQUEUED_PKT      BIT(0)
 #define MWIFIEX_BUF_FLAG_BRIDGED_PKT    BIT(1)
+#define MWIFIEX_BUF_FLAG_TDLS_PKT    BIT(2)
 
-#define MWIFIEX_BRIDGED_PKTS_THRESHOLD     1024
+#define MWIFIEX_BRIDGED_PKTS_THR_HIGH      1024
+#define MWIFIEX_BRIDGED_PKTS_THR_LOW        128
+
+#define MWIFIEX_TDLS_DISABLE_LINK             0x00
+#define MWIFIEX_TDLS_ENABLE_LINK              0x01
+#define MWIFIEX_TDLS_CREATE_LINK              0x02
+#define MWIFIEX_TDLS_CONFIG_LINK              0x03
 
 enum mwifiex_bss_type {
  MWIFIEX_BSS_TYPE_STA = 0,
@@ -90,6 +98,23 @@ enum mwifiex_bss_role {
  MWIFIEX_BSS_ROLE_ANY = 0xff,
 };
 
+enum mwifiex_tdls_status {
+ TDLS_NOT_SETUP = 0,
+ TDLS_SETUP_INPROGRESS,
+ TDLS_SETUP_COMPLETE,
+ TDLS_SETUP_FAILURE,
+ TDLS_LINK_TEARDOWN,
+};
+
+enum mwifiex_tdls_error_code {
+ TDLS_ERR_NO_ERROR = 0,
+ TDLS_ERR_INTERNAL_ERROR,
+ TDLS_ERR_MAX_LINKS_EST,
+ TDLS_ERR_LINK_EXISTS,
+ TDLS_ERR_LINK_NONEXISTENT,
+ TDLS_ERR_PEER_STA_UNREACHABLE = 25,
+};
+
 #define BSS_ROLE_BIT_MASK    BIT(0)
 
 #define GET_BSS_ROLE(priv)   ((priv)->bss_role & BSS_ROLE_BIT_MASK)
@@ -128,6 +153,7 @@ struct mwifiex_txinfo {
  u8 flags;
  u8 bss_num;
  u8 bss_type;
+ u32 pkt_len;
 };
 
 enum mwifiex_wmm_ac_e {
@@ -151,4 +177,12 @@ struct mwifiex_types_wmm_info {
  u8 reserved;
  struct ieee_types_wmm_ac_parameters ac_params[IEEE80211_NUM_ACS];
 } __packed;
+
+struct mwifiex_arp_eth_header {
+ struct arphdr hdr;
+ u8 ar_sha[ETH_ALEN];
+ u8 ar_sip[4];
+ u8 ar_tha[ETH_ALEN];
+ u8 ar_tip[4];
+} __packed;
 #endif /* !_MWIFIEX_DECL_H_ */
diff --git a/drivers/net/wireless/mwifiex/fw.h b/drivers/net/wireless/mwifiex/fw.h
index 1f7578d..3175dd0 100644
--- a/drivers/net/wireless/mwifiex/fw.h
+++ b/drivers/net/wireless/mwifiex/fw.h
@@ -30,7 +30,7 @@ struct rfc_1042_hdr {
  u8 llc_ssap;
  u8 llc_ctrl;
  u8 snap_oui[3];
- u16 snap_type;
+ __be16 snap_type;
 };
 
 struct rx_packet_hdr {
@@ -50,21 +50,23 @@ struct tx_packet_hdr {
 #define HOSTCMD_SUPPORTED_RATES         14
 #define N_SUPPORTED_RATES               3
 #define ALL_802_11_BANDS           (BAND_A | BAND_B | BAND_G | BAND_GN | \
-        BAND_AN | BAND_GAC | BAND_AAC)
+        BAND_AN | BAND_AAC)
 
 #define FW_MULTI_BANDS_SUPPORT  (BIT(8) | BIT(9) | BIT(10) | BIT(11) | \
-     BIT(12) | BIT(13))
+     BIT(13))
 #define IS_SUPPORT_MULTI_BANDS(adapter)        \
  (adapter->fw_cap_info & FW_MULTI_BANDS_SUPPORT)
 
-/* shift bit 12 and bit 13 in fw_cap_info from the firmware to bit 13 and 14
- * for 11ac so that bit 11 is for GN, bit 12 for AN, bit 13 for GAC, and bit
- * bit 14 for AAC, in order to be compatible with the band capability
- * defined in the driver after right shift of 8 bits.
+/* bit 13: 11ac BAND_AAC
+ * bit 12: reserved for lab testing, will be reused for BAND_AN
+ * bit 11: 11n  BAND_GN
+ * bit 10: 11a  BAND_A
+ * bit 9: 11g   BAND_G
+ * bit 8: 11b   BAND_B
+ * Map these bits to band capability by right shifting 8 bits.
  */
 #define GET_FW_DEFAULT_BANDS(adapter)  \
-     (((((adapter->fw_cap_info & 0x3000) << 1) | \
-        (adapter->fw_cap_info & ~0xF000)) >> 8) & \
+     (((adapter->fw_cap_info & 0x2f00) >> 8) & \
       ALL_802_11_BANDS)
 
 #define HostCmd_WEP_KEY_INDEX_MASK              0x3fff
@@ -77,17 +79,23 @@ enum KEY_TYPE_ID {
  KEY_TYPE_ID_WAPI,
  KEY_TYPE_ID_AES_CMAC,
 };
+
+#define WPA_PN_SIZE  8
+#define KEY_PARAMS_FIXED_LEN 10
+#define KEY_INDEX_MASK  0xf
+#define FW_KEY_API_VER_MAJOR_V2 2
+
 #define KEY_MCAST BIT(0)
 #define KEY_UNICAST BIT(1)
 #define KEY_ENABLED BIT(2)
+#define KEY_DEFAULT BIT(3)
+#define KEY_TX_KEY BIT(4)
+#define KEY_RX_KEY BIT(5)
 #define KEY_IGTK BIT(10)
 
-#define WAPI_KEY_LEN   50
+#define WAPI_KEY_LEN   (WLAN_KEY_LEN_SMS4 + PN_LEN + 2)
 
 #define MAX_POLL_TRIES   100
-
-#define MAX_MULTI_INTERFACE_POLL_TRIES  1000
-
 #define MAX_FIRMWARE_POLL_TRIES   100
 
 #define FIRMWARE_READY_SDIO    0xfedc
@@ -133,6 +141,7 @@ enum MWIFIEX_802_11_PRIVACY_FILTER {
 #define TLV_TYPE_RSSI_HIGH          (PROPRIETARY_TLV_BASE_ID + 22)
 #define TLV_TYPE_AUTH_TYPE          (PROPRIETARY_TLV_BASE_ID + 31)
 #define TLV_TYPE_STA_MAC_ADDR       (PROPRIETARY_TLV_BASE_ID + 32)
+#define TLV_TYPE_BSSID              (PROPRIETARY_TLV_BASE_ID + 35)
 #define TLV_TYPE_CHANNELBANDLIST    (PROPRIETARY_TLV_BASE_ID + 42)
 #define TLV_TYPE_UAP_BEACON_PERIOD  (PROPRIETARY_TLV_BASE_ID + 44)
 #define TLV_TYPE_UAP_DTIM_PERIOD    (PROPRIETARY_TLV_BASE_ID + 45)
@@ -147,6 +156,8 @@ enum MWIFIEX_802_11_PRIVACY_FILTER {
 #define TLV_TYPE_RATE_DROP_CONTROL  (PROPRIETARY_TLV_BASE_ID + 82)
 #define TLV_TYPE_RATE_SCOPE         (PROPRIETARY_TLV_BASE_ID + 83)
 #define TLV_TYPE_POWER_GROUP        (PROPRIETARY_TLV_BASE_ID + 84)
+#define TLV_TYPE_BSS_SCAN_RSP       (PROPRIETARY_TLV_BASE_ID + 86)
+#define TLV_TYPE_BSS_SCAN_INFO      (PROPRIETARY_TLV_BASE_ID + 87)
 #define TLV_TYPE_UAP_RETRY_LIMIT    (PROPRIETARY_TLV_BASE_ID + 93)
 #define TLV_TYPE_WAPI_IE            (PROPRIETARY_TLV_BASE_ID + 94)
 #define TLV_TYPE_UAP_MGMT_FRAME     (PROPRIETARY_TLV_BASE_ID + 104)
@@ -156,6 +167,10 @@ enum MWIFIEX_802_11_PRIVACY_FILTER {
 #define TLV_TYPE_UAP_PS_AO_TIMER    (PROPRIETARY_TLV_BASE_ID + 123)
 #define TLV_TYPE_PWK_CIPHER         (PROPRIETARY_TLV_BASE_ID + 145)
 #define TLV_TYPE_GWK_CIPHER         (PROPRIETARY_TLV_BASE_ID + 146)
+#define TLV_TYPE_COALESCE_RULE      (PROPRIETARY_TLV_BASE_ID + 154)
+#define TLV_TYPE_KEY_PARAM_V2       (PROPRIETARY_TLV_BASE_ID + 156)
+#define TLV_TYPE_TDLS_IDLE_TIMEOUT  (PROPRIETARY_TLV_BASE_ID + 194)
+#define TLV_TYPE_FW_API_REV         (PROPRIETARY_TLV_BASE_ID + 199)
 
 #define MWIFIEX_TX_DATA_BUF_SIZE_2K        2048
 
@@ -178,13 +193,21 @@ enum MWIFIEX_802_11_PRIVACY_FILTER {
 #define MWIFIEX_TX_DATA_BUF_SIZE_8K        8192
 
 #define ISSUPP_11NENABLED(FwCapInfo) (FwCapInfo & BIT(11))
+#define ISSUPP_TDLS_ENABLED(FwCapInfo) (FwCapInfo & BIT(14))
 
 #define MWIFIEX_DEF_HT_CAP (IEEE80211_HT_CAP_DSSSCCK40 | \
      (1 << IEEE80211_HT_CAP_RX_STBC_SHIFT) | \
      IEEE80211_HT_CAP_SM_PS)
 
+#define MWIFIEX_DEF_11N_TX_BF_CAP 0x09E1E008
+
 #define MWIFIEX_DEF_AMPDU IEEE80211_HT_AMPDU_PARM_FACTOR
 
+#define GET_RXSTBC(x) (x & IEEE80211_HT_CAP_RX_STBC)
+#define MWIFIEX_RX_STBC1 0x0100
+#define MWIFIEX_RX_STBC12 0x0200
+#define MWIFIEX_RX_STBC123 0x0300
+
 /* dev_cap bitmap
  * BIT
  * 0-16  reserved
@@ -206,6 +229,8 @@ enum MWIFIEX_802_11_PRIVACY_FILTER {
 #define ISSUPP_GREENFIELD(Dot11nDevCap) (Dot11nDevCap & BIT(29))
 #define ISENABLED_40MHZ_INTOLERANT(Dot11nDevCap) (Dot11nDevCap & BIT(8))
 #define ISSUPP_RXLDPC(Dot11nDevCap) (Dot11nDevCap & BIT(22))
+#define ISSUPP_BEAMFORMING(Dot11nDevCap) (Dot11nDevCap & BIT(30))
+#define ISALLOWED_CHANWIDTH40(ht_param) (ht_param & BIT(2))
 
 /* httxcfg bitmap
  * 0  reserved
@@ -218,8 +243,21 @@ enum MWIFIEX_802_11_PRIVACY_FILTER {
  */
 #define MWIFIEX_FW_DEF_HTTXCFG (BIT(1) | BIT(4) | BIT(5) | BIT(6))
 
+/* 11AC Tx and Rx MCS map for 1x1 mode:
+ * IEEE80211_VHT_MCS_SUPPORT_0_9 for stream 1
+ * IEEE80211_VHT_MCS_NOT_SUPPORTED for remaining 7 streams
+ */
+#define MWIFIEX_11AC_MCS_MAP_1X1 0xfffefffe
+
+/* 11AC Tx and Rx MCS map for 2x2 mode:
+ * IEEE80211_VHT_MCS_SUPPORT_0_9 for stream 1 and 2
+ * IEEE80211_VHT_MCS_NOT_SUPPORTED for remaining 6 streams
+ */
+#define MWIFIEX_11AC_MCS_MAP_2X2 0xfffafffa
+
 #define GET_RXMCSSUPP(DevMCSSupported) (DevMCSSupported & 0x0f)
 #define SETHT_MCS32(x) (x[4] |= 1)
+#define HT_STREAM_1X1 0x11
 #define HT_STREAM_2X2 0x22
 
 #define SET_SECONDARYCHAN(RadioType, SECCHAN) (RadioType |= (SECCHAN << 4))
@@ -228,23 +266,32 @@ enum MWIFIEX_802_11_PRIVACY_FILTER {
 
 /* HW_SPEC fw_cap_info */
 
-#define ISSUPP_11ACENABLED(fw_cap_info) (fw_cap_info & (BIT(13)|BIT(14)))
+#define ISSUPP_11ACENABLED(fw_cap_info) (fw_cap_info & BIT(13))
 
 #define GET_VHTCAP_CHWDSET(vht_cap_info)    ((vht_cap_info >> 2) & 0x3)
 #define GET_VHTNSSMCS(mcs_mapset, nss) ((mcs_mapset >> (2 * (nss - 1))) & 0x3)
 #define SET_VHTNSSMCS(mcs_mapset, nss, value) (mcs_mapset |= (value & 0x3) << \
            (2 * (nss - 1)))
-#define NO_NSS_SUPPORT  0x3
-
 #define GET_DEVTXMCSMAP(dev_mcs_map)      (dev_mcs_map >> 16)
 #define GET_DEVRXMCSMAP(dev_mcs_map)      (dev_mcs_map & 0xFFFF)
 
+/* Clear SU Beanformer, MU beanformer, MU beanformee and
+ * sounding dimensions bits
+ */
+#define MWIFIEX_DEF_11AC_CAP_BF_RESET_MASK \
+   (IEEE80211_VHT_CAP_SU_BEAMFORMER_CAPABLE | \
+    IEEE80211_VHT_CAP_MU_BEAMFORMER_CAPABLE | \
+    IEEE80211_VHT_CAP_MU_BEAMFORMEE_CAPABLE | \
+    IEEE80211_VHT_CAP_SOUNDING_DIMENSIONS_MASK)
+
 #define MOD_CLASS_HR_DSSS       0x03
 #define MOD_CLASS_OFDM          0x07
 #define MOD_CLASS_HT            0x08
 #define HT_BW_20    0
 #define HT_BW_40    1
 
+#define DFS_CHAN_MOVE_TIME      10000
+
 #define HostCmd_CMD_GET_HW_SPEC                       0x0003
 #define HostCmd_CMD_802_11_SCAN                       0x0006
 #define HostCmd_CMD_802_11_GET_LOG                    0x000b
@@ -271,6 +318,7 @@ enum MWIFIEX_802_11_PRIVACY_FILTER {
 #define HostCmd_CMD_802_11_SUBSCRIBE_EVENT            0x0075
 #define HostCmd_CMD_802_11_TX_RATE_QUERY              0x007f
 #define HostCmd_CMD_802_11_IBSS_COALESCING_STATUS     0x0083
+#define HostCmd_CMD_CFG_DATA                          0x008f
 #define HostCmd_CMD_VERSION_EXT                       0x0097
 #define HostCmd_CMD_MEF_CFG                           0x009a
 #define HostCmd_CMD_RSSI_INFO                         0x00a4
@@ -279,6 +327,7 @@ enum MWIFIEX_802_11_PRIVACY_FILTER {
 #define HostCmd_CMD_UAP_SYS_CONFIG                    0x00b0
 #define HostCmd_CMD_UAP_BSS_START                     0x00b1
 #define HostCmd_CMD_UAP_BSS_STOP                      0x00b2
+#define HostCmd_CMD_UAP_STA_DEAUTH                    0x00b5
 #define HostCmd_CMD_11N_CFG                           0x00cd
 #define HostCmd_CMD_11N_ADDBA_REQ                     0x00ce
 #define HostCmd_CMD_11N_ADDBA_RSP                     0x00cf
@@ -293,9 +342,12 @@ enum MWIFIEX_802_11_PRIVACY_FILTER {
 #define HostCmd_CMD_CAU_REG_ACCESS                    0x00ed
 #define HostCmd_CMD_SET_BSS_MODE                      0x00f7
 #define HostCmd_CMD_PCIE_DESC_DETAILS                 0x00fa
+#define HostCmd_CMD_802_11_SCAN_EXT                   0x0107
+#define HostCmd_CMD_COALESCE_CFG                      0x010a
 #define HostCmd_CMD_MGMT_FRAME_REG                    0x010c
 #define HostCmd_CMD_REMAIN_ON_CHAN                    0x010d
 #define HostCmd_CMD_11AC_CFG         0x0112
+#define HostCmd_CMD_TDLS_OPER                         0x0122
 
 #define PROTOCOL_NO_SECURITY        0x01
 #define PROTOCOL_STATIC_WEP         0x02
@@ -353,7 +405,7 @@ enum P2P_MODES {
 #define HS_CFG_CANCEL   0xffffffff
 #define HS_CFG_COND_DEF   0x00000000
 #define HS_CFG_GPIO_DEF   0xff
-#define HS_CFG_GAP_DEF   0
+#define HS_CFG_GAP_DEF   0xff
 #define HS_CFG_COND_BROADCAST_DATA 0x00000001
 #define HS_CFG_COND_UNICAST_DATA 0x00000002
 #define HS_CFG_COND_MAC_EVENT  0x00000004
@@ -436,6 +488,9 @@ enum P2P_MODES {
 #define EVENT_BW_CHANGE                 0x00000048
 #define EVENT_UAP_MIC_COUNTERMEASURES   0x0000004c
 #define EVENT_HOSTWAKE_STAIE  0x0000004d
+#define EVENT_CHANNEL_SWITCH_ANN        0x00000050
+#define EVENT_TDLS_GENERIC_EVENT        0x00000052
+#define EVENT_EXT_SCAN_REPORT           0x00000058
 #define EVENT_REMAIN_ON_CHAN_EXPIRED    0x0000005f
 
 #define EVENT_ID_MASK                   0xffff
@@ -448,7 +503,7 @@ enum P2P_MODES {
  (((event_cause) >> 24) & 0x00ff)
 
 #define MWIFIEX_MAX_PATTERN_LEN  20
-#define MWIFIEX_MAX_OFFSET_LEN  50
+#define MWIFIEX_MAX_OFFSET_LEN  100
 #define STACK_NBYTES   100
 #define TYPE_DNUM   1
 #define TYPE_BYTESEQ   2
@@ -464,6 +519,13 @@ enum P2P_MODES {
 #define MWIFIEX_CRITERIA_UNICAST BIT(1)
 #define MWIFIEX_CRITERIA_MULTICAST BIT(3)
 
+#define ACT_TDLS_DELETE            0x00
+#define ACT_TDLS_CREATE            0x01
+#define ACT_TDLS_CONFIG            0x02
+#define TDLS_EVENT_LINK_TEAR_DOWN  3
+
+#define MWIFIEX_FW_V15     15
+
 struct mwifiex_ie_types_header {
  __le16 type;
  __le16 len;
@@ -476,6 +538,8 @@ struct mwifiex_ie_types_data {
 
 #define MWIFIEX_TxPD_POWER_MGMT_NULL_PACKET 0x01
 #define MWIFIEX_TxPD_POWER_MGMT_LAST_PACKET 0x08
+#define MWIFIEX_TXPD_FLAGS_TDLS_PACKET      0x10
+#define MWIFIEX_RXPD_FLAGS_TDLS_PACKET      0x01
 
 struct txpd {
  u8 bss_type;
@@ -518,7 +582,7 @@ struct rxpd {
   * [Bit 7] Reserved
   */
  u8 ht_info;
- u8 reserved;
+ u8 flags;
 } __packed;
 
 struct uap_txpd {
@@ -604,12 +668,12 @@ struct mwifiex_ie_types_tsf_timestamp {
 struct mwifiex_cf_param_set {
  u8 cfp_cnt;
  u8 cfp_period;
- u16 cfp_max_duration;
- u16 cfp_duration_remaining;
+ __le16 cfp_max_duration;
+ __le16 cfp_duration_remaining;
 } __packed;
 
 struct mwifiex_ibss_param_set {
- u16 atim_window;
+ __le16 atim_window;
 } __packed;
 
 struct mwifiex_ie_types_ss_param_set {
@@ -621,7 +685,7 @@ struct mwifiex_ie_types_ss_param_set {
 } __packed;
 
 struct mwifiex_fh_param_set {
- u16 dwell_time;
+ __le16 dwell_time;
  u8 hop_set;
  u8 hop_pattern;
  u8 hop_index;
@@ -649,6 +713,13 @@ struct mwifiex_ie_types_vendor_param_set {
  u8 ie[MWIFIEX_MAX_VSIE_LEN];
 };
 
+#define MWIFIEX_TDLS_IDLE_TIMEOUT 60
+
+struct mwifiex_ie_types_tdls_idle_timeout {
+ struct mwifiex_ie_types_header header;
+ __le16 value;
+} __packed;
+
 struct mwifiex_ie_types_rsn_param_set {
  struct mwifiex_ie_types_header header;
  u8 rsn_ie[1];
@@ -672,16 +743,66 @@ struct mwifiex_cmac_param {
  u8 key[WLAN_KEY_LEN_AES_CMAC];
 } __packed;
 
+struct mwifiex_wep_param {
+ __le16 key_len;
+ u8 key[WLAN_KEY_LEN_WEP104];
+} __packed;
+
+struct mwifiex_tkip_param {
+ u8 pn[WPA_PN_SIZE];
+ __le16 key_len;
+ u8 key[WLAN_KEY_LEN_TKIP];
+} __packed;
+
+struct mwifiex_aes_param {
+ u8 pn[WPA_PN_SIZE];
+ __le16 key_len;
+ u8 key[WLAN_KEY_LEN_CCMP];
+} __packed;
+
+struct mwifiex_wapi_param {
+ u8 pn[PN_LEN];
+ __le16 key_len;
+ u8 key[WLAN_KEY_LEN_SMS4];
+} __packed;
+
+struct mwifiex_cmac_aes_param {
+ u8 ipn[IGTK_PN_LEN];
+ __le16 key_len;
+ u8 key[WLAN_KEY_LEN_AES_CMAC];
+} __packed;
+
+struct mwifiex_ie_type_key_param_set_v2 {
+ __le16 type;
+ __le16 len;
+ u8 mac_addr[ETH_ALEN];
+ u8 key_idx;
+ u8 key_type;
+ __le16 key_info;
+ union {
+  struct mwifiex_wep_param wep;
+  struct mwifiex_tkip_param tkip;
+  struct mwifiex_aes_param aes;
+  struct mwifiex_wapi_param wapi;
+  struct mwifiex_cmac_aes_param cmac_aes;
+ } key_params;
+} __packed;
+
+struct host_cmd_ds_802_11_key_material_v2 {
+ __le16 action;
+ struct mwifiex_ie_type_key_param_set_v2 key_param_set;
+} __packed;
+
 struct host_cmd_ds_802_11_key_material {
  __le16 action;
  struct mwifiex_ie_type_key_param_set key_param_set;
 } __packed;
 
 struct host_cmd_ds_gen {
- u16 command;
- u16 size;
- u16 seq_num;
- u16 result;
+ __le16 command;
+ __le16 size;
+ __le16 seq_num;
+ __le16 result;
 };
 
 #define S_DS_GEN        sizeof(struct host_cmd_ds_gen)
@@ -723,6 +844,17 @@ struct host_cmd_ds_802_11_ps_mode_enh {
  } params;
 } __packed;
 
+enum FW_API_VER_ID {
+ KEY_API_VER_ID = 1,
+};
+
+struct hw_spec_fw_api_rev {
+ struct mwifiex_ie_types_header header;
+ __le16 api_id;
+ u8 major_ver;
+ u8 minor_ver;
+} __packed;
+
 struct host_cmd_ds_get_hw_spec {
  __le16 hw_if_version;
  __le16 version;
@@ -744,6 +876,7 @@ struct host_cmd_ds_get_hw_spec {
  __le32 reserved_6;
  __le32 dot_11ac_dev_cap;
  __le32 dot_11ac_mcs_support;
+ u8 tlvs[0];
 } __packed;
 
 struct host_cmd_ds_802_11_rssi_info {
@@ -814,8 +947,8 @@ struct ieee_types_cf_param_set {
  u8 len;
  u8 cfp_cnt;
  u8 cfp_period;
- u16 cfp_max_duration;
- u16 cfp_duration_remaining;
+ __le16 cfp_max_duration;
+ __le16 cfp_duration_remaining;
 } __packed;
 
 struct ieee_types_ibss_param_set {
@@ -951,7 +1084,7 @@ struct mwifiex_hs_config_param {
 } __packed;
 
 struct hs_activate_param {
- u16 resp_ctrl;
+ __le16 resp_ctrl;
 } __packed;
 
 struct host_cmd_ds_802_11_hs_cfg_enh {
@@ -971,6 +1104,7 @@ enum SNMP_MIB_INDEX {
  LONG_RETRY_LIM_I = 7,
  FRAG_THRESH_I = 8,
  DOT11D_I = 9,
+ DOT11H_I = 10,
 };
 
 #define MAX_SNMP_BUF_SIZE   128
@@ -988,6 +1122,7 @@ struct mwifiex_rate_scope {
  __le16 hr_dsss_rate_bitmap;
  __le16 ofdm_rate_bitmap;
  __le16 ht_mcs_rate_bitmap[8];
+ __le16 vht_mcs_rate_bitmap[8];
 } __packed;
 
 struct mwifiex_rate_drop_pattern {
@@ -1013,8 +1148,8 @@ struct mwifiex_power_group {
 } __packed;
 
 struct mwifiex_types_power_group {
- u16 type;
- u16 length;
+ __le16 type;
+ __le16 length;
 } __packed;
 
 struct host_cmd_ds_txpwr_cfg {
@@ -1042,14 +1177,28 @@ struct host_cmd_ds_rf_ant_siso {
  __le16 ant_mode;
 };
 
-struct mwifiex_bcn_param {
- u8 bssid[ETH_ALEN];
- u8 rssi;
+struct host_cmd_ds_tdls_oper {
+ __le16 tdls_action;
+ __le16 reason;
+ u8 peer_mac[ETH_ALEN];
+} __packed;
+
+struct mwifiex_fixed_bcn_param {
  __le64 timestamp;
  __le16 beacon_period;
  __le16 cap_info_bitmap;
 } __packed;
 
+struct mwifiex_event_scan_result {
+ __le16 event_id;
+ u8 bss_index;
+ u8 bss_type;
+ u8 more_event;
+ u8 reserved[3];
+ __le16 buf_size;
+ u8 num_of_set;
+} __packed;
+
 #define MWIFIEX_USER_SCAN_CHAN_MAX             50
 
 #define MWIFIEX_MAX_SSID_LIST_LENGTH         10
@@ -1119,12 +1268,34 @@ struct host_cmd_ds_802_11_scan_rsp {
  u8 bss_desc_and_tlv_buffer[1];
 } __packed;
 
+struct host_cmd_ds_802_11_scan_ext {
+ u32   reserved;
+ u8    tlv_buffer[1];
+} __packed;
+
+struct mwifiex_ie_types_bss_scan_rsp {
+ struct mwifiex_ie_types_header header;
+ u8 bssid[ETH_ALEN];
+ u8 frame_body[1];
+} __packed;
+
+struct mwifiex_ie_types_bss_scan_info {
+ struct mwifiex_ie_types_header header;
+ __le16 rssi;
+ __le16 anpi;
+ u8 cca_busy_fraction;
+ u8 radio_type;
+ u8 channel;
+ u8 reserved;
+ __le64 tsf;
+} __packed;
+
 struct host_cmd_ds_802_11_bg_scan_query {
  u8 flush;
 } __packed;
 
 struct host_cmd_ds_802_11_bg_scan_query_rsp {
- u32 report_condition;
+ __le32 report_condition;
  struct host_cmd_ds_802_11_scan_rsp scan_resp;
 } __packed;
 
@@ -1197,6 +1368,23 @@ struct host_cmd_ds_amsdu_aggr_ctrl {
  __le16 curr_buf_size;
 } __packed;
 
+struct host_cmd_ds_sta_deauth {
+ u8 mac[ETH_ALEN];
+ __le16 reason;
+} __packed;
+
+struct mwifiex_ie_types_pwr_capability {
+ struct mwifiex_ie_types_header header;
+ s8 min_pwr;
+ s8 max_pwr;
+};
+
+struct mwifiex_ie_types_local_pwr_constraint {
+ struct mwifiex_ie_types_header header;
+ u8 chan;
+ u8 constraint;
+};
+
 struct mwifiex_ie_types_wmm_param_set {
  struct mwifiex_ie_types_header header;
  u8 wmm_ie[1];
@@ -1206,7 +1394,7 @@ struct mwifiex_ie_types_wmm_queue_status {
  struct mwifiex_ie_types_header header;
  u8 queue_index;
  u8 disabled;
- u16 medium_time;
+ __le16 medium_time;
  u8 flow_required;
  u8 flow_created;
  u32 reserved;
@@ -1274,6 +1462,11 @@ struct mwifiex_ie_types_vhtcap {
  struct ieee80211_vht_cap vht_cap;
 } __packed;
 
+struct mwifiex_ie_types_aid {
+ struct mwifiex_ie_types_header header;
+ __le16 aid;
+} __packed;
+
 struct mwifiex_ie_types_oper_mode_ntf {
  struct mwifiex_ie_types_header header;
  u8 oper_mode;
@@ -1286,7 +1479,7 @@ struct mwifiex_ie_types_vht_oper {
  u8 chan_center_freq_1;
  u8 chan_center_freq_2;
  /* Basic MCS set map, each 2 bits stands for a NSS */
- u16 basic_mcs_map;
+ __le16 basic_mcs_map;
 } __packed;
 
 struct mwifiex_ie_types_wmmcap {
@@ -1306,7 +1499,12 @@ struct mwifiex_ie_types_2040bssco {
 
 struct mwifiex_ie_types_extcap {
  struct mwifiex_ie_types_header header;
- u8 ext_cap;
+ u8 ext_capab[0];
+} __packed;
+
+struct mwifiex_ie_types_qos_info {
+ struct mwifiex_ie_types_header header;
+ u8 qos_info;
 } __packed;
 
 struct host_cmd_ds_mac_reg_access {
@@ -1344,11 +1542,6 @@ struct host_cmd_ds_802_11_eeprom_access {
  u8 value;
 } __packed;
 
-struct host_cmd_tlv {
- __le16 type;
- __le16 len;
-} __packed;
-
 struct mwifiex_assoc_event {
  u8 sta_addr[ETH_ALEN];
  __le16 type;
@@ -1374,99 +1567,104 @@ struct host_cmd_11ac_vht_cfg {
 } __packed;
 
 struct host_cmd_tlv_akmp {
- struct host_cmd_tlv tlv;
+ struct mwifiex_ie_types_header header;
  __le16 key_mgmt;
  __le16 key_mgmt_operation;
 } __packed;
 
 struct host_cmd_tlv_pwk_cipher {
- struct host_cmd_tlv tlv;
+ struct mwifiex_ie_types_header header;
  __le16 proto;
  u8 cipher;
  u8 reserved;
 } __packed;
 
 struct host_cmd_tlv_gwk_cipher {
- struct host_cmd_tlv tlv;
+ struct mwifiex_ie_types_header header;
  u8 cipher;
  u8 reserved;
 } __packed;
 
 struct host_cmd_tlv_passphrase {
- struct host_cmd_tlv tlv;
+ struct mwifiex_ie_types_header header;
  u8 passphrase[0];
 } __packed;
 
 struct host_cmd_tlv_wep_key {
- struct host_cmd_tlv tlv;
+ struct mwifiex_ie_types_header header;
  u8 key_index;
  u8 is_default;
  u8 key[1];
 };
 
 struct host_cmd_tlv_auth_type {
- struct host_cmd_tlv tlv;
+ struct mwifiex_ie_types_header header;
  u8 auth_type;
 } __packed;
 
 struct host_cmd_tlv_encrypt_protocol {
- struct host_cmd_tlv tlv;
+ struct mwifiex_ie_types_header header;
  __le16 proto;
 } __packed;
 
 struct host_cmd_tlv_ssid {
- struct host_cmd_tlv tlv;
+ struct mwifiex_ie_types_header header;
  u8 ssid[0];
 } __packed;
 
 struct host_cmd_tlv_rates {
- struct host_cmd_tlv tlv;
+ struct mwifiex_ie_types_header header;
  u8 rates[0];
 } __packed;
 
+struct mwifiex_ie_types_bssid_list {
+ struct mwifiex_ie_types_header header;
+ u8 bssid[ETH_ALEN];
+} __packed;
+
 struct host_cmd_tlv_bcast_ssid {
- struct host_cmd_tlv tlv;
+ struct mwifiex_ie_types_header header;
  u8 bcast_ctl;
 } __packed;
 
 struct host_cmd_tlv_beacon_period {
- struct host_cmd_tlv tlv;
+ struct mwifiex_ie_types_header header;
  __le16 period;
 } __packed;
 
 struct host_cmd_tlv_dtim_period {
- struct host_cmd_tlv tlv;
+ struct mwifiex_ie_types_header header;
  u8 period;
 } __packed;
 
 struct host_cmd_tlv_frag_threshold {
- struct host_cmd_tlv tlv;
+ struct mwifiex_ie_types_header header;
  __le16 frag_thr;
 } __packed;
 
 struct host_cmd_tlv_rts_threshold {
- struct host_cmd_tlv tlv;
+ struct mwifiex_ie_types_header header;
  __le16 rts_thr;
 } __packed;
 
 struct host_cmd_tlv_retry_limit {
- struct host_cmd_tlv tlv;
+ struct mwifiex_ie_types_header header;
  u8 limit;
 } __packed;
 
 struct host_cmd_tlv_mac_addr {
- struct host_cmd_tlv tlv;
+ struct mwifiex_ie_types_header header;
  u8 mac_addr[ETH_ALEN];
 } __packed;
 
 struct host_cmd_tlv_channel_band {
- struct host_cmd_tlv tlv;
+ struct mwifiex_ie_types_header header;
  u8 band_config;
  u8 channel;
 } __packed;
 
 struct host_cmd_tlv_ageout_timer {
- struct host_cmd_tlv tlv;
+ struct mwifiex_ie_types_header header;
  __le32 sta_ao_timer;
 } __packed;
 
@@ -1559,6 +1757,15 @@ struct host_cmd_ds_802_11_subsc_evt {
  __le16 events;
 } __packed;
 
+struct mwifiex_tdls_generic_event {
+ __le16 type;
+ u8 peer_mac[ETH_ALEN];
+ union {
+  __le16 reason_code;
+  __le16 reserved;
+ } u;
+} __packed;
+
 struct mwifiex_ie {
  __le16 ie_index;
  __le16 mgmt_subtype_mask;
@@ -1573,6 +1780,27 @@ struct mwifiex_ie_list {
  struct mwifiex_ie ie_list[MAX_MGMT_IE_INDEX];
 } __packed;
 
+struct coalesce_filt_field_param {
+ u8 operation;
+ u8 operand_len;
+ __le16 offset;
+ u8 operand_byte_stream[4];
+};
+
+struct coalesce_receive_filt_rule {
+ struct mwifiex_ie_types_header header;
+ u8 num_of_fields;
+ u8 pkt_type;
+ __le16 max_coalescing_delay;
+ struct coalesce_filt_field_param params[0];
+} __packed;
+
+struct host_cmd_ds_coalesce_cfg {
+ __le16 action;
+ __le16 num_of_rules;
+ struct coalesce_receive_filt_rule rule[0];
+} __packed;
+
 struct host_cmd_ds_command {
  __le16 command;
  __le16 size;
@@ -1596,6 +1824,7 @@ struct host_cmd_ds_command {
   struct host_cmd_ds_802_11_ps_mode_enh psmode_enh;
   struct host_cmd_ds_802_11_hs_cfg_enh opt_hs_cfg;
   struct host_cmd_ds_802_11_scan scan;
+  struct host_cmd_ds_802_11_scan_ext ext_scan;
   struct host_cmd_ds_802_11_scan_rsp scan_resp;
   struct host_cmd_ds_802_11_bg_scan_query bg_scan_query;
   struct host_cmd_ds_802_11_bg_scan_query_rsp bg_scan_query_resp;
@@ -1615,6 +1844,7 @@ struct host_cmd_ds_command {
   struct host_cmd_ds_11n_cfg htcfg;
   struct host_cmd_ds_wmm_get_status get_wmm_status;
   struct host_cmd_ds_802_11_key_material key_material;
+  struct host_cmd_ds_802_11_key_material_v2 key_material_v2;
   struct host_cmd_ds_version_ext verext;
   struct host_cmd_ds_mgmt_frame_reg reg_mask;
   struct host_cmd_ds_remain_on_chan roc_cfg;
@@ -1630,7 +1860,10 @@ struct host_cmd_ds_command {
   struct host_cmd_ds_802_11_eeprom_access eeprom;
   struct host_cmd_ds_802_11_subsc_evt subsc_evt;
   struct host_cmd_ds_sys_config uap_sys_config;
+  struct host_cmd_ds_sta_deauth sta_deauth;
   struct host_cmd_11ac_vht_cfg vht_cfg;
+  struct host_cmd_ds_coalesce_cfg coalesce_cfg;
+  struct host_cmd_ds_tdls_oper tdls_oper;
  } params;
 } __packed;
 
diff --git a/drivers/net/wireless/mwifiex/ie.c b/drivers/net/wireless/mwifiex/ie.c
index e38342f..3bf3d58 100644
--- a/drivers/net/wireless/mwifiex/ie.c
+++ b/drivers/net/wireless/mwifiex/ie.c
@@ -82,20 +82,22 @@ mwifiex_update_autoindex_ies(struct mwifiex_private *priv,
         struct mwifiex_ie_list *ie_list)
 {
  u16 travel_len, index, mask;
- s16 input_len;
+ s16 input_len, tlv_len;
  struct mwifiex_ie *ie;
  u8 *tmp;
 
  input_len = le16_to_cpu(ie_list->len);
- travel_len = sizeof(struct host_cmd_tlv);
+ travel_len = sizeof(struct mwifiex_ie_types_header);
 
  ie_list->len = 0;
 
- while (input_len > 0) {
+ while (input_len >= sizeof(struct mwifiex_ie_types_header)) {
   ie = (struct mwifiex_ie *)(((u8 *)ie_list) + travel_len);
-  input_len -= le16_to_cpu(ie->ie_length) + MWIFIEX_IE_HDR_SIZE;
-  travel_len += le16_to_cpu(ie->ie_length) + MWIFIEX_IE_HDR_SIZE;
+  tlv_len = le16_to_cpu(ie->ie_length);
+  travel_len += tlv_len + MWIFIEX_IE_HDR_SIZE;
 
+  if (input_len < tlv_len + MWIFIEX_IE_HDR_SIZE)
+   return -1;
   index = le16_to_cpu(ie->ie_index);
   mask = le16_to_cpu(ie->mgmt_subtype_mask);
 
@@ -132,12 +134,13 @@ mwifiex_update_autoindex_ies(struct mwifiex_private *priv,
   le16_add_cpu(&ie_list->len,
         le16_to_cpu(priv->mgmt_ie[index].ie_length) +
         MWIFIEX_IE_HDR_SIZE);
+  input_len -= tlv_len + MWIFIEX_IE_HDR_SIZE;
  }
 
  if (GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_UAP)
-  return mwifiex_send_cmd_async(priv, HostCmd_CMD_UAP_SYS_CONFIG,
-           HostCmd_ACT_GEN_SET,
-           UAP_CUSTOM_IE_I, ie_list);
+  return mwifiex_send_cmd(priv, HostCmd_CMD_UAP_SYS_CONFIG,
+     HostCmd_ACT_GEN_SET,
+     UAP_CUSTOM_IE_I, ie_list, false);
 
  return 0;
 }
diff --git a/drivers/net/wireless/mwifiex/init.c b/drivers/net/wireless/mwifiex/init.c
index 9f44fda..4ecd0b2 100644
--- a/drivers/net/wireless/mwifiex/init.c
+++ b/drivers/net/wireless/mwifiex/init.c
@@ -52,87 +52,6 @@ static int mwifiex_add_bss_prio_tbl(struct mwifiex_private *priv)
  return 0;
 }
 
-static void scan_delay_timer_fn(unsigned long data)
-{
- struct mwifiex_private *priv = (struct mwifiex_private *)data;
- struct mwifiex_adapter *adapter = priv->adapter;
- struct cmd_ctrl_node *cmd_node, *tmp_node;
- unsigned long flags;
-
- if (adapter->scan_delay_cnt == MWIFIEX_MAX_SCAN_DELAY_CNT) {
-  /*
-   * Abort scan operation by cancelling all pending scan
-   * commands
-   */
-  spin_lock_irqsave(&adapter->scan_pending_q_lock, flags);
-  list_for_each_entry_safe(cmd_node, tmp_node,
-      &adapter->scan_pending_q, list) {
-   list_del(&cmd_node->list);
-   mwifiex_insert_cmd_to_free_q(adapter, cmd_node);
-  }
-  spin_unlock_irqrestore(&adapter->scan_pending_q_lock, flags);
-
-  spin_lock_irqsave(&adapter->mwifiex_cmd_lock, flags);
-  adapter->scan_processing = false;
-  adapter->scan_delay_cnt = 0;
-  adapter->empty_tx_q_cnt = 0;
-  spin_unlock_irqrestore(&adapter->mwifiex_cmd_lock, flags);
-
-  if (priv->user_scan_cfg) {
-   if (priv->scan_request) {
-    dev_dbg(priv->adapter->dev,
-     "info: aborting scan\n");
-    cfg80211_scan_done(priv->scan_request, 1);
-    priv->scan_request = NULL;
-   } else {
-    dev_dbg(priv->adapter->dev,
-     "info: scan already aborted\n");
-   }
-
-   kfree(priv->user_scan_cfg);
-   priv->user_scan_cfg = NULL;
-  }
-  goto done;
- }
-
- if (!atomic_read(&priv->adapter->is_tx_received)) {
-  adapter->empty_tx_q_cnt++;
-  if (adapter->empty_tx_q_cnt == MWIFIEX_MAX_EMPTY_TX_Q_CNT) {
-   /*
-    * No Tx traffic for 200msec. Get scan command from
-    * scan pending queue and put to cmd pending queue to
-    * resume scan operation
-    */
-   adapter->scan_delay_cnt = 0;
-   adapter->empty_tx_q_cnt = 0;
-   spin_lock_irqsave(&adapter->scan_pending_q_lock, flags);
-   cmd_node = list_first_entry(&adapter->scan_pending_q,
-          struct cmd_ctrl_node, list);
-   list_del(&cmd_node->list);
-   spin_unlock_irqrestore(&adapter->scan_pending_q_lock,
-            flags);
-
-   mwifiex_insert_cmd_to_pending_q(adapter, cmd_node,
-       true);
-   queue_work(adapter->workqueue, &adapter->main_work);
-   goto done;
-  }
- } else {
-  adapter->empty_tx_q_cnt = 0;
- }
-
- /* Delay scan operation further by 20msec */
- mod_timer(&priv->scan_delay_timer, jiffies +
-    msecs_to_jiffies(MWIFIEX_SCAN_DELAY_MSEC));
- adapter->scan_delay_cnt++;
-
-done:
- if (atomic_read(&priv->adapter->is_tx_received))
-  atomic_set(&priv->adapter->is_tx_received, false);
-
- return;
-}
-
 /*
  * This function initializes the private structure and sets default
  * values to the members.
@@ -214,8 +133,11 @@ int mwifiex_init_priv(struct mwifiex_private *priv)
 
  priv->scan_block = false;
 
- setup_timer(&priv->scan_delay_timer, scan_delay_timer_fn,
-      (unsigned long)priv);
+ priv->csa_chan = 0;
+ priv->csa_expire_time = 0;
+ priv->del_list_idx = 0;
+ priv->hs2_enabled = false;
+ memcpy(priv->tos_to_tid_inv, tos_to_tid_inv, MAX_NUM_TID);
 
  return mwifiex_add_bss_prio_tbl(priv);
 }
@@ -312,7 +234,6 @@ static void mwifiex_init_adapter(struct mwifiex_adapter *adapter)
 
  adapter->pm_wakeup_fw_try = false;
 
- adapter->tx_buf_size = MWIFIEX_TX_DATA_BUF_SIZE_2K;
  adapter->curr_tx_buf_size = MWIFIEX_TX_DATA_BUF_SIZE_2K;
 
  adapter->is_hs_configured = false;
@@ -360,6 +281,9 @@ static void mwifiex_init_adapter(struct mwifiex_adapter *adapter)
  adapter->arp_filter_size = 0;
  adapter->max_mgmt_ie_index = MAX_MGMT_IE_INDEX;
  adapter->empty_tx_q_cnt = 0;
+ adapter->ext_scan = true;
+ adapter->fw_key_api_major_ver = 0;
+ adapter->fw_key_api_minor_ver = 0;
 }
 
 /*
@@ -447,17 +371,16 @@ static void mwifiex_free_lock_list(struct mwifiex_adapter *adapter)
 }
 
 /*
- * This function frees the adapter structure.
+ * This function performs cleanup for adapter structure.
  *
- * The freeing operation is done recursively, by canceling all
- * pending commands, freeing the member buffers previously
- * allocated (command buffers, scan table buffer, sleep confirm
- * command buffer), stopping the timers and calling the cleanup
- * routines for every interface, before the actual adapter
- * structure is freed.
+ * The cleanup is done recursively, by canceling all pending
+ * commands, freeing the member buffers previously allocated
+ * (command buffers, scan table buffer, sleep confirm command
+ * buffer), stopping the timers and calling the cleanup routines
+ * for every interface.
  */
 static void
-mwifiex_free_adapter(struct mwifiex_adapter *adapter)
+mwifiex_adapter_cleanup(struct mwifiex_adapter *adapter)
 {
  if (!adapter) {
   pr_err("%s: adapter is NULL\n", __func__);
@@ -473,13 +396,8 @@ mwifiex_free_adapter(struct mwifiex_adapter *adapter)
  dev_dbg(adapter->dev, "info: free cmd buffer\n");
  mwifiex_free_cmd_buffer(adapter);
 
- del_timer(&adapter->cmd_timer);
-
  dev_dbg(adapter->dev, "info: free scan table\n");
 
- if (adapter->if_ops.cleanup_if)
-  adapter->if_ops.cleanup_if(adapter);
-
  if (adapter->sleep_cfm)
   dev_kfree_skb_any(adapter->sleep_cfm);
 }
@@ -535,6 +453,7 @@ int mwifiex_init_lock_list(struct mwifiex_adapter *adapter)
   INIT_LIST_HEAD(&priv->tx_ba_stream_tbl_ptr);
   INIT_LIST_HEAD(&priv->rx_reorder_tbl_ptr);
   INIT_LIST_HEAD(&priv->sta_list);
+  skb_queue_head_init(&priv->tdls_txq);
 
   spin_lock_init(&priv->tx_ba_stream_tbl_lock);
   spin_lock_init(&priv->rx_reorder_tbl_lock);
@@ -684,7 +603,6 @@ mwifiex_shutdown_drv(struct mwifiex_adapter *adapter)
  int ret = -EINPROGRESS;
  struct mwifiex_private *priv;
  s32 i;
- unsigned long flags;
  struct sk_buff *skb;
 
  /* mwifiex already shutdown */
@@ -701,7 +619,7 @@ mwifiex_shutdown_drv(struct mwifiex_adapter *adapter)
  /* cancel current command */
  if (adapter->curr_cmd) {
   dev_warn(adapter->dev, "curr_cmd is still in processing\n");
-  del_timer(&adapter->cmd_timer);
+  del_timer_sync(&adapter->cmd_timer);
   mwifiex_recycle_cmd_node(adapter, adapter->curr_cmd);
   adapter->curr_cmd = NULL;
  }
@@ -719,7 +637,7 @@ mwifiex_shutdown_drv(struct mwifiex_adapter *adapter)
   }
  }
 
- spin_lock_irqsave(&adapter->mwifiex_lock, flags);
+ spin_lock(&adapter->mwifiex_lock);
 
  if (adapter->if_ops.data_complete) {
   while ((skb = skb_dequeue(&adapter->usb_rx_data_q))) {
@@ -729,14 +647,14 @@ mwifiex_shutdown_drv(struct mwifiex_adapter *adapter)
    if (priv)
     priv->stats.rx_dropped++;
 
-   adapter->if_ops.data_complete(adapter, skb);
+   dev_kfree_skb_any(skb);
+   adapter->if_ops.data_complete(adapter);
   }
  }
 
- /* Free adapter structure */
- mwifiex_free_adapter(adapter);
+ mwifiex_adapter_cleanup(adapter);
 
- spin_unlock_irqrestore(&adapter->mwifiex_lock, flags);
+ spin_unlock(&adapter->mwifiex_lock);
 
  /* Notify completion */
  ret = mwifiex_shutdown_fw_complete(adapter);
@@ -770,7 +688,7 @@ int mwifiex_dnld_fw(struct mwifiex_adapter *adapter,
   if (!ret) {
    dev_notice(adapter->dev,
        "WLAN FW already running! Skip FW dnld\n");
-   goto done;
+   return 0;
   }
 
   poll_num = MAX_FIRMWARE_POLL_TRIES;
@@ -779,7 +697,6 @@ int mwifiex_dnld_fw(struct mwifiex_adapter *adapter,
   if (!adapter->winner) {
    dev_notice(adapter->dev,
        "FW already running! Skip FW dnld\n");
-   poll_num = MAX_MULTI_INTERFACE_POLL_TRIES;
    goto poll_fw;
   }
  }
@@ -796,14 +713,8 @@ int mwifiex_dnld_fw(struct mwifiex_adapter *adapter,
 poll_fw:
  /* Check if the firmware is downloaded successfully or not */
  ret = adapter->if_ops.check_fw_status(adapter, poll_num);
- if (ret) {
+ if (ret)
   dev_err(adapter->dev, "FW failed to be active in time\n");
-  return -1;
- }
-done:
- /* re-enable host interrupt for mwifiex after fw dnld is successful */
- if (adapter->if_ops.enable_int)
-  adapter->if_ops.enable_int(adapter);
 
  return ret;
 }
diff --git a/drivers/net/wireless/mwifiex/ioctl.h b/drivers/net/wireless/mwifiex/ioctl.h
index 7f27e45..1b57672 100644
--- a/drivers/net/wireless/mwifiex/ioctl.h
+++ b/drivers/net/wireless/mwifiex/ioctl.h
@@ -60,8 +60,7 @@ enum {
  BAND_A = 4,
  BAND_GN = 8,
  BAND_AN = 16,
- BAND_GAC = 32,
- BAND_AAC = 64,
+ BAND_AAC = 32,
 };
 
 #define MWIFIEX_WPA_PASSHPHRASE_LEN 64
@@ -86,6 +85,10 @@ struct wep_key {
 #define BAND_CONFIG_A           0x01
 #define MWIFIEX_SUPPORTED_RATES                 14
 #define MWIFIEX_SUPPORTED_RATES_EXT             32
+#define MWIFIEX_TDLS_SUPPORTED_RATES  8
+#define MWIFIEX_TDLS_DEF_QOS_CAPAB  0xf
+#define MWIFIEX_PRIO_BK    2
+#define MWIFIEX_PRIO_VI    5
 
 struct mwifiex_uap_bss_param {
  u8 channel;
@@ -174,6 +177,7 @@ struct mwifiex_ds_rx_reorder_tbl {
 struct mwifiex_ds_tx_ba_stream_tbl {
  u16 tid;
  u8 ra[ETH_ALEN];
+ u8 amsdu;
 };
 
 #define DBG_CMD_NUM 5
@@ -206,7 +210,7 @@ struct mwifiex_debug_info {
  u32 num_cmd_assoc_success;
  u32 num_cmd_assoc_failure;
  u32 num_tx_timeout;
- u32 num_cmd_timeout;
+ u8 is_cmd_timedout;
  u16 timeout_cmd_id;
  u16 timeout_cmd_act;
  u16 last_cmd_id[DBG_CMD_NUM];
@@ -233,7 +237,10 @@ struct mwifiex_ds_encrypt_key {
  u8 mac_addr[ETH_ALEN];
  u32 is_wapi_key;
  u8 pn[PN_LEN];  /* packet number */
+ u8 pn_len;
  u8 is_igtk_key;
+ u8 is_current_wep_key;
+ u8 is_rx_seq_valid;
 };
 
 struct mwifiex_power_cfg {
@@ -296,7 +303,7 @@ struct mwifiex_ds_ant_cfg {
  u32 rx_ant;
 };
 
-#define MWIFIEX_NUM_OF_CMD_BUFFER 20
+#define MWIFIEX_NUM_OF_CMD_BUFFER 50
 #define MWIFIEX_SIZE_OF_CMD_BUFFER 2048
 
 enum {
@@ -362,13 +369,13 @@ struct mwifiex_ds_misc_subsc_evt {
  struct subsc_evt_cfg bcn_h_rssi_cfg;
 };
 
-#define MAX_BYTESEQ  6 /* non-adjustable */
-#define MWIFIEX_MAX_FILTERS 10
+#define MWIFIEX_MEF_MAX_BYTESEQ  6 /* non-adjustable */
+#define MWIFIEX_MEF_MAX_FILTERS  10
 
 struct mwifiex_mef_filter {
  u16 repeat;
  u16 offset;
- s8 byte_seq[MAX_BYTESEQ + 1];
+ s8 byte_seq[MWIFIEX_MEF_MAX_BYTESEQ + 1];
  u8 filt_type;
  u8 filt_action;
 };
@@ -376,7 +383,7 @@ struct mwifiex_mef_filter {
 struct mwifiex_mef_entry {
  u8 mode;
  u8 action;
- struct mwifiex_mef_filter filter[MWIFIEX_MAX_FILTERS];
+ struct mwifiex_mef_filter filter[MWIFIEX_MEF_MAX_FILTERS];
 };
 
 struct mwifiex_ds_mef_cfg {
@@ -397,4 +404,51 @@ enum {
  MWIFIEX_FUNC_SHUTDOWN,
 };
 
+enum COALESCE_OPERATION {
+ RECV_FILTER_MATCH_TYPE_EQ = 0x80,
+ RECV_FILTER_MATCH_TYPE_NE,
+};
+
+enum COALESCE_PACKET_TYPE {
+ PACKET_TYPE_UNICAST = 1,
+ PACKET_TYPE_MULTICAST = 2,
+ PACKET_TYPE_BROADCAST = 3
+};
+
+#define MWIFIEX_COALESCE_MAX_RULES 8
+#define MWIFIEX_COALESCE_MAX_BYTESEQ 4 /* non-adjustable */
+#define MWIFIEX_COALESCE_MAX_FILTERS 4
+#define MWIFIEX_MAX_COALESCING_DELAY 100     /* in msecs */
+
+struct filt_field_param {
+ u8 operation;
+ u8 operand_len;
+ u16 offset;
+ u8 operand_byte_stream[MWIFIEX_COALESCE_MAX_BYTESEQ];
+};
+
+struct mwifiex_coalesce_rule {
+ u16 max_coalescing_delay;
+ u8 num_of_fields;
+ u8 pkt_type;
+ struct filt_field_param params[MWIFIEX_COALESCE_MAX_FILTERS];
+};
+
+struct mwifiex_ds_coalesce_cfg {
+ u16 num_of_rules;
+ struct mwifiex_coalesce_rule rule[MWIFIEX_COALESCE_MAX_RULES];
+};
+
+struct mwifiex_ds_tdls_oper {
+ u16 tdls_action;
+ u8 peer_mac[ETH_ALEN];
+ u16 capability;
+ u8 qos_info;
+ u8 *ext_capab;
+ u8 ext_capab_len;
+ u8 *supp_rates;
+ u8 supp_rates_len;
+ u8 *ht_capab;
+};
+
 #endif /* !_MWIFIEX_IOCTL_H_ */
diff --git a/drivers/net/wireless/mwifiex/join.c b/drivers/net/wireless/mwifiex/join.c
index 96bda6c..89dc62a 100644
--- a/drivers/net/wireless/mwifiex/join.c
+++ b/drivers/net/wireless/mwifiex/join.c
@@ -515,8 +515,7 @@ int mwifiex_cmd_802_11_associate(struct mwifiex_private *priv,
 
  if (ISSUPP_11ACENABLED(priv->adapter->fw_cap_info) &&
      !bss_desc->disable_11n && !bss_desc->disable_11ac &&
-     (priv->adapter->config_bands & BAND_GAC ||
-      priv->adapter->config_bands & BAND_AAC))
+     priv->adapter->config_bands & BAND_AAC)
   mwifiex_cmd_append_11ac_tlv(priv, bss_desc, &pos);
 
  /* Append vendor specific IE TLV */
@@ -534,6 +533,8 @@ int mwifiex_cmd_802_11_associate(struct mwifiex_private *priv,
 
  mwifiex_cmd_append_tsf_tlv(priv, &pos, bss_desc);
 
+ mwifiex_11h_process_join(priv, &pos, bss_desc);
+
  cmd->size = cpu_to_le16((u16) (pos - (u8 *) assoc) + S_DS_GEN);
 
  /* Set the Capability info at last */
@@ -619,7 +620,7 @@ int mwifiex_ret_802_11_associate(struct mwifiex_private *priv,
  int ret = 0;
  struct ieee_types_assoc_rsp *assoc_rsp;
  struct mwifiex_bssdescriptor *bss_desc;
- u8 enable_data = true;
+ bool enable_data = true;
  u16 cap_info, status_code;
 
  assoc_rsp = (struct ieee_types_assoc_rsp *) &resp->params;
@@ -900,9 +901,9 @@ mwifiex_cmd_802_11_ad_hoc_start(struct mwifiex_private *priv,
  mwifiex_get_active_data_rates(priv, adhoc_start->data_rate);
  if ((adapter->adhoc_start_band & BAND_G) &&
      (priv->curr_pkt_filter & HostCmd_ACT_MAC_ADHOC_G_PROTECTION_ON)) {
-  if (mwifiex_send_cmd_async(priv, HostCmd_CMD_MAC_CONTROL,
-        HostCmd_ACT_GEN_SET, 0,
-        &priv->curr_pkt_filter)) {
+  if (mwifiex_send_cmd(priv, HostCmd_CMD_MAC_CONTROL,
+         HostCmd_ACT_GEN_SET, 0,
+         &priv->curr_pkt_filter, false)) {
    dev_err(adapter->dev,
     "ADHOC_S_CMD: G Protection config failed\n");
    return -1;
@@ -919,9 +920,8 @@ mwifiex_cmd_802_11_ad_hoc_start(struct mwifiex_private *priv,
  memcpy(&priv->curr_bss_params.data_rates,
         &adhoc_start->data_rate, priv->curr_bss_params.num_of_rates);
 
- dev_dbg(adapter->dev, "info: ADHOC_S_CMD: rates=%02x %02x %02x %02x\n",
-  adhoc_start->data_rate[0], adhoc_start->data_rate[1],
-  adhoc_start->data_rate[2], adhoc_start->data_rate[3]);
+ dev_dbg(adapter->dev, "info: ADHOC_S_CMD: rates=%4ph\n",
+  adhoc_start->data_rate);
 
  dev_dbg(adapter->dev, "info: ADHOC_S_CMD: AD-HOC Start command is ready\n");
 
@@ -982,7 +982,7 @@ mwifiex_cmd_802_11_ad_hoc_start(struct mwifiex_private *priv,
          cpu_to_le16(sizeof(struct ieee80211_ht_cap));
   radio_type = mwifiex_band_to_radio_type(
      priv->adapter->config_bands);
-  mwifiex_fill_cap_info(priv, radio_type, ht_cap);
+  mwifiex_fill_cap_info(priv, radio_type, &ht_cap->ht_cap);
 
   if (adapter->sec_chan_offset ==
      IEEE80211_HT_PARAM_CHA_SEC_NONE) {
@@ -1073,9 +1073,9 @@ mwifiex_cmd_802_11_ad_hoc_join(struct mwifiex_private *priv,
    priv->
    curr_pkt_filter | HostCmd_ACT_MAC_ADHOC_G_PROTECTION_ON;
 
-  if (mwifiex_send_cmd_async(priv, HostCmd_CMD_MAC_CONTROL,
-        HostCmd_ACT_GEN_SET, 0,
-        &curr_pkt_filter)) {
+  if (mwifiex_send_cmd(priv, HostCmd_CMD_MAC_CONTROL,
+         HostCmd_ACT_GEN_SET, 0,
+         &curr_pkt_filter, false)) {
    dev_err(priv->adapter->dev,
     "ADHOC_J_CMD: G Protection config failed\n");
    return -1;
@@ -1299,8 +1299,7 @@ int mwifiex_associate(struct mwifiex_private *priv,
 
  if (ISSUPP_11ACENABLED(priv->adapter->fw_cap_info) &&
      !bss_desc->disable_11n && !bss_desc->disable_11ac &&
-     (priv->adapter->config_bands & BAND_GAC ||
-      priv->adapter->config_bands & BAND_AAC))
+     priv->adapter->config_bands & BAND_AAC)
   mwifiex_set_11ac_ba_params(priv);
  else
   mwifiex_set_ba_params(priv);
@@ -1313,8 +1312,8 @@ int mwifiex_associate(struct mwifiex_private *priv,
     retrieval */
  priv->assoc_rsp_size = 0;
 
- return mwifiex_send_cmd_sync(priv, HostCmd_CMD_802_11_ASSOCIATE,
-        HostCmd_ACT_GEN_SET, 0, bss_desc);
+ return mwifiex_send_cmd(priv, HostCmd_CMD_802_11_ASSOCIATE,
+    HostCmd_ACT_GEN_SET, 0, bss_desc, true);
 }
 
 /*
@@ -1334,14 +1333,13 @@ mwifiex_adhoc_start(struct mwifiex_private *priv,
   priv->curr_bss_params.band);
 
  if (ISSUPP_11ACENABLED(priv->adapter->fw_cap_info) &&
-     (priv->adapter->config_bands & BAND_GAC ||
-      priv->adapter->config_bands & BAND_AAC))
+     priv->adapter->config_bands & BAND_AAC)
   mwifiex_set_11ac_ba_params(priv);
  else
   mwifiex_set_ba_params(priv);
 
- return mwifiex_send_cmd_sync(priv, HostCmd_CMD_802_11_AD_HOC_START,
-        HostCmd_ACT_GEN_SET, 0, adhoc_ssid);
+ return mwifiex_send_cmd(priv, HostCmd_CMD_802_11_AD_HOC_START,
+    HostCmd_ACT_GEN_SET, 0, adhoc_ssid, true);
 }
 
 /*
@@ -1375,8 +1373,7 @@ int mwifiex_adhoc_join(struct mwifiex_private *priv,
 
  if (ISSUPP_11ACENABLED(priv->adapter->fw_cap_info) &&
      !bss_desc->disable_11n && !bss_desc->disable_11ac &&
-     (priv->adapter->config_bands & BAND_GAC ||
-      priv->adapter->config_bands & BAND_AAC))
+     priv->adapter->config_bands & BAND_AAC)
   mwifiex_set_11ac_ba_params(priv);
  else
   mwifiex_set_ba_params(priv);
@@ -1386,8 +1383,8 @@ int mwifiex_adhoc_join(struct mwifiex_private *priv,
  dev_dbg(priv->adapter->dev, "info: curr_bss_params.band = %c\n",
   priv->curr_bss_params.band);
 
- return mwifiex_send_cmd_sync(priv, HostCmd_CMD_802_11_AD_HOC_JOIN,
-        HostCmd_ACT_GEN_SET, 0, bss_desc);
+ return mwifiex_send_cmd(priv, HostCmd_CMD_802_11_AD_HOC_JOIN,
+    HostCmd_ACT_GEN_SET, 0, bss_desc, true);
 }
 
 /*
@@ -1406,8 +1403,8 @@ static int mwifiex_deauthenticate_infra(struct mwifiex_private *priv, u8 *mac)
  else
   memcpy(mac_address, mac, ETH_ALEN);
 
- ret = mwifiex_send_cmd_sync(priv, HostCmd_CMD_802_11_DEAUTHENTICATE,
-        HostCmd_ACT_GEN_SET, 0, mac_address);
+ ret = mwifiex_send_cmd(priv, HostCmd_CMD_802_11_DEAUTHENTICATE,
+          HostCmd_ACT_GEN_SET, 0, mac_address, true);
 
  return ret;
 }
@@ -1421,26 +1418,45 @@ static int mwifiex_deauthenticate_infra(struct mwifiex_private *priv, u8 *mac)
  */
 int mwifiex_deauthenticate(struct mwifiex_private *priv, u8 *mac)
 {
+ int ret = 0;
+
  if (!priv->media_connected)
   return 0;
 
  switch (priv->bss_mode) {
  case NL80211_IFTYPE_STATION:
-  return mwifiex_deauthenticate_infra(priv, mac);
+ case NL80211_IFTYPE_P2P_CLIENT:
+  ret = mwifiex_deauthenticate_infra(priv, mac);
+  if (ret)
+   cfg80211_disconnected(priv->netdev, 0, NULL, 0,
+           GFP_KERNEL);
+  break;
  case NL80211_IFTYPE_ADHOC:
-  return mwifiex_send_cmd_sync(priv,
-          HostCmd_CMD_802_11_AD_HOC_STOP,
-          HostCmd_ACT_GEN_SET, 0, NULL);
+  return mwifiex_send_cmd(priv, HostCmd_CMD_802_11_AD_HOC_STOP,
+     HostCmd_ACT_GEN_SET, 0, NULL, true);
  case NL80211_IFTYPE_AP:
-  return mwifiex_send_cmd_sync(priv, HostCmd_CMD_UAP_BSS_STOP,
-          HostCmd_ACT_GEN_SET, 0, NULL);
+  return mwifiex_send_cmd(priv, HostCmd_CMD_UAP_BSS_STOP,
+     HostCmd_ACT_GEN_SET, 0, NULL, true);
  default:
   break;
  }
 
- return 0;
+ return ret;
+}
+
+/* This function deauthenticates/disconnects from all BSS. */
+void mwifiex_deauthenticate_all(struct mwifiex_adapter *adapter)
+{
+ struct mwifiex_private *priv;
+ int i;
+
+ for (i = 0; i < adapter->priv_num; i++) {
+  priv = adapter->priv[i];
+  if (priv)
+   mwifiex_deauthenticate(priv, NULL);
+ }
 }
-EXPORT_SYMBOL_GPL(mwifiex_deauthenticate);
+EXPORT_SYMBOL_GPL(mwifiex_deauthenticate_all);
 
 /*
  * This function converts band to radio type used in channel TLV.
diff --git a/drivers/net/wireless/mwifiex/main.c b/drivers/net/wireless/mwifiex/main.c
index fc3fe8d..7a74ab5 100644
--- a/drivers/net/wireless/mwifiex/main.c
+++ b/drivers/net/wireless/mwifiex/main.c
@@ -25,6 +25,87 @@
 #define VERSION "1.0"
 
 const char driver_version[] = "mwifiex " VERSION " (%s) ";
+static char *cal_data_cfg;
+module_param(cal_data_cfg, charp, 0);
+
+static void scan_delay_timer_fn(unsigned long data)
+{
+ struct mwifiex_private *priv = (struct mwifiex_private *)data;
+ struct mwifiex_adapter *adapter = priv->adapter;
+ struct cmd_ctrl_node *cmd_node, *tmp_node;
+ unsigned long flags;
+
+ if (adapter->surprise_removed)
+  return;
+
+ if (adapter->scan_delay_cnt == MWIFIEX_MAX_SCAN_DELAY_CNT ||
+     !adapter->scan_processing) {
+  /*
+   * Abort scan operation by cancelling all pending scan
+   * commands
+   */
+  spin_lock_irqsave(&adapter->scan_pending_q_lock, flags);
+  list_for_each_entry_safe(cmd_node, tmp_node,
+      &adapter->scan_pending_q, list) {
+   list_del(&cmd_node->list);
+   mwifiex_insert_cmd_to_free_q(adapter, cmd_node);
+  }
+  spin_unlock_irqrestore(&adapter->scan_pending_q_lock, flags);
+
+  spin_lock_irqsave(&adapter->mwifiex_cmd_lock, flags);
+  adapter->scan_processing = false;
+  adapter->scan_delay_cnt = 0;
+  adapter->empty_tx_q_cnt = 0;
+  spin_unlock_irqrestore(&adapter->mwifiex_cmd_lock, flags);
+
+  if (priv->scan_request) {
+   dev_dbg(adapter->dev, "info: aborting scan\n");
+   cfg80211_scan_done(priv->scan_request, 1);
+   priv->scan_request = NULL;
+  } else {
+   priv->scan_aborting = false;
+   dev_dbg(adapter->dev, "info: scan already aborted\n");
+  }
+  goto done;
+ }
+
+ if (!atomic_read(&priv->adapter->is_tx_received)) {
+  adapter->empty_tx_q_cnt++;
+  if (adapter->empty_tx_q_cnt == MWIFIEX_MAX_EMPTY_TX_Q_CNT) {
+   /*
+    * No Tx traffic for 200msec. Get scan command from
+    * scan pending queue and put to cmd pending queue to
+    * resume scan operation
+    */
+   adapter->scan_delay_cnt = 0;
+   adapter->empty_tx_q_cnt = 0;
+   spin_lock_irqsave(&adapter->scan_pending_q_lock, flags);
+   cmd_node = list_first_entry(&adapter->scan_pending_q,
+          struct cmd_ctrl_node, list);
+   list_del(&cmd_node->list);
+   spin_unlock_irqrestore(&adapter->scan_pending_q_lock,
+            flags);
+
+   mwifiex_insert_cmd_to_pending_q(adapter, cmd_node,
+       true);
+   queue_work(adapter->workqueue, &adapter->main_work);
+   goto done;
+  }
+ } else {
+  adapter->empty_tx_q_cnt = 0;
+ }
+
+ /* Delay scan operation further by 20msec */
+ mod_timer(&priv->scan_delay_timer, jiffies +
+    msecs_to_jiffies(MWIFIEX_SCAN_DELAY_MSEC));
+ adapter->scan_delay_cnt++;
+
+done:
+ if (atomic_read(&priv->adapter->is_tx_received))
+  atomic_set(&priv->adapter->is_tx_received, false);
+
+ return;
+}
 
 /*
  * This function registers the device and performs all the necessary
@@ -73,6 +154,10 @@ static int mwifiex_register(void *card, struct mwifiex_if_ops *if_ops,
 
   adapter->priv[i]->adapter = adapter;
   adapter->priv_num++;
+
+  setup_timer(&adapter->priv[i]->scan_delay_timer,
+       scan_delay_timer_fn,
+       (unsigned long)adapter->priv[i]);
  }
  mwifiex_init_lock_list(adapter);
 
@@ -107,12 +192,16 @@ static int mwifiex_unregister(struct mwifiex_adapter *adapter)
 {
  s32 i;
 
- del_timer(&adapter->cmd_timer);
+ if (adapter->if_ops.cleanup_if)
+  adapter->if_ops.cleanup_if(adapter);
+
+ del_timer_sync(&adapter->cmd_timer);
 
  /* Free private structures */
  for (i = 0; i < adapter->priv_num; i++) {
   if (adapter->priv[i]) {
    mwifiex_free_curr_bcn(adapter->priv[i]);
+   del_timer_sync(&adapter->priv[i]->scan_delay_timer);
    kfree(adapter->priv[i]);
   }
  }
@@ -203,6 +292,12 @@ process_start:
    while ((skb = skb_dequeue(&adapter->usb_rx_data_q)))
     mwifiex_handle_rx_packet(adapter, skb);
 
+  /* Check for event */
+  if (adapter->event_received) {
+   adapter->event_received = false;
+   mwifiex_process_event(adapter);
+  }
+
   /* Check for Cmd Resp */
   if (adapter->cmd_resp_received) {
    adapter->cmd_resp_received = false;
@@ -215,12 +310,6 @@ process_start:
    }
   }
 
-  /* Check for event */
-  if (adapter->event_received) {
-   adapter->event_received = false;
-   mwifiex_process_event(adapter);
-  }
-
   /* Check if we need to confirm Sleep Request
      received previously */
   if (adapter->ps_state == PS_STATE_PRE_SLEEP) {
@@ -304,6 +393,17 @@ static void mwifiex_free_adapter(struct mwifiex_adapter *adapter)
 }
 
 /*
+ * This function cancels all works in the queue and destroys
+ * the main workqueue.
+ */
+static void mwifiex_terminate_workqueue(struct mwifiex_adapter *adapter)
+{
+ flush_workqueue(adapter->workqueue);
+ destroy_workqueue(adapter->workqueue);
+ adapter->workqueue = NULL;
+}
+
+/*
  * This function gets firmware and initializes it.
  *
  * The main initialization steps followed are -
@@ -317,11 +417,14 @@ static void mwifiex_fw_dpc(const struct firmware *firmware, void *context)
  struct mwifiex_private *priv;
  struct mwifiex_adapter *adapter = context;
  struct mwifiex_fw_image fw;
+ struct semaphore *sem = adapter->card_sem;
+ bool init_failed = false;
+ struct wireless_dev *wdev;
 
  if (!firmware) {
   dev_err(adapter->dev,
    "Failed to get firmware %s\n", adapter->fw_name);
-  goto done;
+  goto err_dnld_fw;
  }
 
  memset(&fw, 0, sizeof(struct mwifiex_fw_image));
@@ -334,14 +437,27 @@ static void mwifiex_fw_dpc(const struct firmware *firmware, void *context)
  else
   ret = mwifiex_dnld_fw(adapter, &fw);
  if (ret == -1)
-  goto done;
+  goto err_dnld_fw;
 
  dev_notice(adapter->dev, "WLAN FW is active\n");
 
+ if (cal_data_cfg) {
+  if ((request_firmware(&adapter->cal_data, cal_data_cfg,
+          adapter->dev)) < 0)
+   dev_err(adapter->dev,
+    "Cal data request_firmware() failed\n");
+ }
+
+ /* enable host interrupt after fw dnld is successful */
+ if (adapter->if_ops.enable_int) {
+  if (adapter->if_ops.enable_int(adapter))
+   goto err_dnld_fw;
+ }
+
  adapter->init_wait_q_woken = false;
  ret = mwifiex_init_fw(adapter);
  if (ret == -1) {
-  goto done;
+  goto err_init_fw;
  } else if (!ret) {
   adapter->hw_status = MWIFIEX_HW_STATUS_READY;
   goto done;
@@ -350,7 +466,7 @@ static void mwifiex_fw_dpc(const struct firmware *firmware, void *context)
  wait_event_interruptible(adapter->init_wait_q,
      adapter->init_wait_q_woken);
  if (adapter->hw_status != MWIFIEX_HW_STATUS_READY)
-  goto done;
+  goto err_init_fw;
 
  priv = adapter->priv[MWIFIEX_BSS_ROLE_STA];
  if (mwifiex_register_cfg80211(adapter)) {
@@ -360,9 +476,11 @@ static void mwifiex_fw_dpc(const struct firmware *firmware, void *context)
 
  rtnl_lock();
  /* Create station interface by default */
- if (!mwifiex_add_virtual_intf(adapter->wiphy, "mlan%d",
-          NL80211_IFTYPE_STATION, NULL, NULL)) {
+ wdev = mwifiex_add_virtual_intf(adapter->wiphy, "mlan%d",
+     NL80211_IFTYPE_STATION, NULL, NULL);
+ if (IS_ERR(wdev)) {
   dev_err(adapter->dev, "cannot create default STA interface\n");
+  rtnl_unlock();
   goto err_add_intf;
  }
  rtnl_unlock();
@@ -372,14 +490,40 @@ static void mwifiex_fw_dpc(const struct firmware *firmware, void *context)
  goto done;
 
 err_add_intf:
- mwifiex_del_virtual_intf(adapter->wiphy, priv->wdev);
- rtnl_unlock();
+ wiphy_unregister(adapter->wiphy);
+ wiphy_free(adapter->wiphy);
 err_init_fw:
+ if (adapter->if_ops.disable_int)
+  adapter->if_ops.disable_int(adapter);
+err_dnld_fw:
  pr_debug("info: %s: unregister device\n", __func__);
- adapter->if_ops.unregister_dev(adapter);
+ if (adapter->if_ops.unregister_dev)
+  adapter->if_ops.unregister_dev(adapter);
+
+ if ((adapter->hw_status == MWIFIEX_HW_STATUS_FW_READY) ||
+     (adapter->hw_status == MWIFIEX_HW_STATUS_READY)) {
+  pr_debug("info: %s: shutdown mwifiex\n", __func__);
+  adapter->init_wait_q_woken = false;
+
+  if (mwifiex_shutdown_drv(adapter) == -EINPROGRESS)
+   wait_event_interruptible(adapter->init_wait_q,
+       adapter->init_wait_q_woken);
+ }
+ adapter->surprise_removed = true;
+ mwifiex_terminate_workqueue(adapter);
+ init_failed = true;
 done:
- release_firmware(adapter->firmware);
- complete(&adapter->fw_load);
+ if (adapter->cal_data) {
+  release_firmware(adapter->cal_data);
+  adapter->cal_data = NULL;
+ }
+ if (adapter->firmware) {
+  release_firmware(adapter->firmware);
+  adapter->firmware = NULL;
+ }
+ if (init_failed)
+  mwifiex_free_adapter(adapter);
+ up(sem);
  return;
 }
 
@@ -390,7 +534,6 @@ static int mwifiex_init_hw_fw(struct mwifiex_adapter *adapter)
 {
  int ret;
 
- init_completion(&adapter->fw_load);
  ret = request_firmware_nowait(THIS_MODULE, 1, adapter->fw_name,
           adapter->dev, GFP_KERNEL, adapter,
           mwifiex_fw_dpc);
@@ -424,6 +567,7 @@ mwifiex_close(struct net_device *dev)
   dev_dbg(priv->adapter->dev, "aborting scan on ndo_stop\n");
   cfg80211_scan_done(priv->scan_request, 1);
   priv->scan_request = NULL;
+  priv->scan_aborting = true;
  }
 
  return 0;
@@ -501,8 +645,10 @@ mwifiex_hard_start_xmit(struct sk_buff *skb, struct net_device *dev)
  }
 
  tx_info = MWIFIEX_SKB_TXCB(skb);
+ memset(tx_info, 0, sizeof(*tx_info));
  tx_info->bss_num = priv->bss_num;
  tx_info->bss_type = priv->bss_type;
+ tx_info->pkt_len = skb->len;
 
  /* Record the current time the packet was queued; used to
   * determine the amount of time the packet was queued in
@@ -532,8 +678,8 @@ mwifiex_set_mac_address(struct net_device *dev, void *addr)
  memcpy(priv->curr_addr, hw_addr->sa_data, ETH_ALEN);
 
  /* Send request to firmware */
- ret = mwifiex_send_cmd_sync(priv, HostCmd_CMD_802_11_MAC_ADDRESS,
-        HostCmd_ACT_GEN_SET, 0, NULL);
+ ret = mwifiex_send_cmd(priv, HostCmd_CMD_802_11_MAC_ADDRESS,
+          HostCmd_ACT_GEN_SET, 0, NULL, true);
 
  if (!ret)
   memcpy(priv->netdev->dev_addr, priv->curr_addr, ETH_ALEN);
@@ -600,10 +746,16 @@ static struct net_device_stats *mwifiex_get_stats(struct net_device *dev)
  return &priv->stats;
 }
 
+#if 0 /* Not in RHEL */
+static u16
+mwifiex_netdev_select_wmm_queue(struct net_device *dev, struct sk_buff *skb,
+    void *accel_priv, select_queue_fallback_t fallback)
+#else
 static u16
 mwifiex_netdev_select_wmm_queue(struct net_device *dev, struct sk_buff *skb)
+#endif
 {
- skb->priority = cfg80211_classify8021d(skb);
+ skb->priority = cfg80211_classify8021d(skb, NULL);
  return mwifiex_1d_to_wmm_queue[skb->priority];
 }
 
@@ -689,18 +841,6 @@ static void mwifiex_main_work_queue(struct work_struct *work)
 }
 
 /*
- * This function cancels all works in the queue and destroys
- * the main workqueue.
- */
-static void
-mwifiex_terminate_workqueue(struct mwifiex_adapter *adapter)
-{
- flush_workqueue(adapter->workqueue);
- destroy_workqueue(adapter->workqueue);
- adapter->workqueue = NULL;
-}
-
-/*
  * This function adds the card.
  *
  * This function follows the following major steps to set up the device -
@@ -728,6 +868,7 @@ mwifiex_add_card(void *card, struct semaphore *sem,
  }
 
  adapter->iface_type = iface_type;
+ adapter->card_sem = sem;
 
  adapter->hw_status = MWIFIEX_HW_STATUS_INITIALIZING;
  adapter->surprise_removed = false;
@@ -735,19 +876,20 @@ mwifiex_add_card(void *card, struct semaphore *sem,
  adapter->is_suspended = false;
  adapter->hs_activated = false;
  init_waitqueue_head(&adapter->hs_activate_wait_q);
- adapter->cmd_wait_q_required = false;
  init_waitqueue_head(&adapter->cmd_wait_q.wait);
  adapter->cmd_wait_q.status = 0;
  adapter->scan_wait_q_woken = false;
 
- adapter->workqueue = create_workqueue("MWIFIEX_WORK_QUEUE");
+ adapter->workqueue =
+  alloc_workqueue("MWIFIEX_WORK_QUEUE",
+    WQ_HIGHPRI | WQ_MEM_RECLAIM | WQ_UNBOUND, 1);
  if (!adapter->workqueue)
   goto err_kmalloc;
 
  INIT_WORK(&adapter->main_work, mwifiex_main_work_queue);
 
  /* Register the device. Fill up the private data structure with relevant
-    information from the card and request for the required IRQ. */
+    information from the card. */
  if (adapter->if_ops.register_dev(adapter)) {
   pr_err("%s: failed to register mwifiex device\n", __func__);
   goto err_registerdev;
@@ -758,17 +900,12 @@ mwifiex_add_card(void *card, struct semaphore *sem,
   goto err_init_fw;
  }
 
- up(sem);
  return 0;
 
 err_init_fw:
  pr_debug("info: %s: unregister device\n", __func__);
  if (adapter->if_ops.unregister_dev)
   adapter->if_ops.unregister_dev(adapter);
-err_registerdev:
- adapter->surprise_removed = true;
- mwifiex_terminate_workqueue(adapter);
-err_kmalloc:
  if ((adapter->hw_status == MWIFIEX_HW_STATUS_FW_READY) ||
      (adapter->hw_status == MWIFIEX_HW_STATUS_READY)) {
   pr_debug("info: %s: shutdown mwifiex\n", __func__);
@@ -778,7 +915,10 @@ err_kmalloc:
    wait_event_interruptible(adapter->init_wait_q,
        adapter->init_wait_q_woken);
  }
-
+err_registerdev:
+ adapter->surprise_removed = true;
+ mwifiex_terminate_workqueue(adapter);
+err_kmalloc:
  mwifiex_free_adapter(adapter);
 
 err_init_sw:
@@ -811,6 +951,11 @@ int mwifiex_remove_card(struct mwifiex_adapter *adapter, struct semaphore *sem)
  if (!adapter)
   goto exit_remove;
 
+ /* We can no longer handle interrupts once we start doing the teardown
+  * below. */
+ if (adapter->if_ops.disable_int)
+  adapter->if_ops.disable_int(adapter);
+
  adapter->surprise_removed = true;
 
  /* Stop data */
@@ -852,18 +997,8 @@ int mwifiex_remove_card(struct mwifiex_adapter *adapter, struct semaphore *sem)
   rtnl_unlock();
  }
 
- priv = adapter->priv[0];
- if (!priv || !priv->wdev)
-  goto exit_remove;
-
- wiphy_unregister(priv->wdev->wiphy);
- wiphy_free(priv->wdev->wiphy);
-
- for (i = 0; i < adapter->priv_num; i++) {
-  priv = adapter->priv[i];
-  if (priv)
-   kfree(priv->wdev);
- }
+ wiphy_unregister(adapter->wiphy);
+ wiphy_free(adapter->wiphy);
 
  mwifiex_terminate_workqueue(adapter);
 
diff --git a/drivers/net/wireless/mwifiex/main.h b/drivers/net/wireless/mwifiex/main.h
index 4ef67fc..1398afa 100644
--- a/drivers/net/wireless/mwifiex/main.h
+++ b/drivers/net/wireless/mwifiex/main.h
@@ -32,6 +32,7 @@
 #include <net/lib80211.h>
 #include <linux/firmware.h>
 #include <linux/ctype.h>
+#include <linux/of.h>
 
 #include "decl.h"
 #include "ioctl.h"
@@ -58,7 +59,7 @@ enum {
 
 #define MWIFIEX_UPLD_SIZE               (2312)
 
-#define MAX_EVENT_SIZE                  1024
+#define MAX_EVENT_SIZE                  2048
 
 #define ARP_FILTER_MAX_BUF_SIZE         68
 
@@ -115,7 +116,7 @@ enum {
 #define MWIFIEX_TYPE_DATA    0
 #define MWIFIEX_TYPE_EVENT    3
 
-#define MAX_BITMAP_RATES_SIZE   10
+#define MAX_BITMAP_RATES_SIZE   18
 
 #define MAX_CHANNEL_BAND_BG     14
 #define MAX_CHANNEL_BAND_A      165
@@ -144,7 +145,6 @@ struct mwifiex_dbg {
  u32 num_cmd_assoc_success;
  u32 num_cmd_assoc_failure;
  u32 num_tx_timeout;
- u32 num_cmd_timeout;
  u16 timeout_cmd_id;
  u16 timeout_cmd_act;
  u16 last_cmd_id[DBG_CMD_NUM];
@@ -192,6 +192,8 @@ struct mwifiex_add_ba_param {
  u32 tx_win_size;
  u32 rx_win_size;
  u32 timeout;
+ u8 tx_amsdu;
+ u8 rx_amsdu;
 };
 
 struct mwifiex_tx_aggr {
@@ -204,11 +206,12 @@ struct mwifiex_ra_list_tbl {
  struct list_head list;
  struct sk_buff_head skb_head;
  u8 ra[ETH_ALEN];
- u32 total_pkts_size;
  u32 is_11n_enabled;
  u16 max_amsdu;
- u16 pkt_count;
+ u16 ba_pkt_count;
  u8 ba_packet_thr;
+ u16 total_pkt_count;
+ bool tdls_link;
 };
 
 struct mwifiex_tid_tbl {
@@ -261,6 +264,31 @@ struct ieee_types_generic {
  u8 data[IEEE_MAX_IE_SIZE - sizeof(struct ieee_types_header)];
 } __packed;
 
+struct ieee_types_bss_co_2040 {
+ struct ieee_types_header ieee_hdr;
+ u8 bss_2040co;
+} __packed;
+
+struct ieee_types_extcap {
+ struct ieee_types_header ieee_hdr;
+ u8 ext_capab[8];
+} __packed;
+
+struct ieee_types_vht_cap {
+ struct ieee_types_header ieee_hdr;
+ struct ieee80211_vht_cap vhtcap;
+} __packed;
+
+struct ieee_types_vht_oper {
+ struct ieee_types_header ieee_hdr;
+ struct ieee80211_vht_operation vhtoper;
+} __packed;
+
+struct ieee_types_aid {
+ struct ieee_types_header ieee_hdr;
+ u16 aid;
+} __packed;
+
 struct mwifiex_bssdescriptor {
  u8 mac_address[ETH_ALEN];
  struct cfg80211_ssid ssid;
@@ -309,6 +337,9 @@ struct mwifiex_bssdescriptor {
  u16 wapi_offset;
  u8 *beacon_buf;
  u32 beacon_buf_size;
+ u8 sensed_11h;
+ u8 local_constraint;
+ u8 chan_sw_ie_present;
 };
 
 struct mwifiex_current_bss_params {
@@ -439,6 +470,7 @@ struct mwifiex_private {
  u8 wpa_ie_len;
  u8 wpa_is_gtk_set;
  struct host_cmd_ds_802_11_key_material aes_key;
+ struct host_cmd_ds_802_11_key_material_v2 aes_key_v2;
  u8 wapi_ie[256];
  u8 wapi_ie_len;
  u8 *wps_ie;
@@ -457,6 +489,7 @@ struct mwifiex_private {
  struct mwifiex_tx_aggr aggr_prio_tbl[MAX_NUM_TID];
  struct mwifiex_add_ba_param add_ba_param;
  u16 rx_seq[MAX_NUM_TID];
+ u8 tos_to_tid_inv[MAX_NUM_TID];
  struct list_head rx_reorder_tbl_ptr;
  /* spin lock for rx_reorder_tbl_ptr queue */
  spinlock_t rx_reorder_tbl_lock;
@@ -492,7 +525,6 @@ struct mwifiex_private {
  struct semaphore async_sem;
  u8 report_scan_result;
  struct cfg80211_scan_request *scan_request;
- struct mwifiex_user_scan_cfg *user_scan_cfg;
  u8 cfg_bssid[6];
  struct wps wps;
  u8 scan_block;
@@ -510,6 +542,13 @@ struct mwifiex_private {
  u8 ap_11ac_enabled;
  u32 mgmt_frame_mask;
  struct mwifiex_roc_cfg roc_cfg;
+ bool scan_aborting;
+ u8 csa_chan;
+ unsigned long csa_expire_time;
+ u8 del_list_idx;
+ bool hs2_enabled;
+ struct station_parameters *sta_params;
+ struct sk_buff_head tdls_txq;
 };
 
 enum mwifiex_ba_status {
@@ -523,6 +562,7 @@ struct mwifiex_tx_ba_stream_tbl {
  int tid;
  u8 ra[ETH_ALEN];
  enum mwifiex_ba_status ba_status;
+ u8 amsdu;
 };
 
 struct mwifiex_rx_reorder_tbl;
@@ -537,10 +577,12 @@ struct mwifiex_rx_reorder_tbl {
  struct list_head list;
  int tid;
  u8 ta[ETH_ALEN];
+ int init_win;
  int start_win;
  int win_size;
  void **rx_reorder_ptr;
  struct reorder_tmr_cnxt timer_context;
+ u8 amsdu;
  u8 flags;
 };
 
@@ -575,17 +617,35 @@ struct mwifiex_bss_priv {
  u64 fw_tsf;
 };
 
-/* This is AP specific structure which stores information
- * about associated STA
+struct mwifiex_tdls_capab {
+ __le16 capab;
+ u8 rates[32];
+ u8 rates_len;
+ u8 qos_info;
+ u8 coex_2040;
+ u16 aid;
+ struct ieee80211_ht_cap ht_capb;
+ struct ieee80211_ht_operation ht_oper;
+ struct ieee_types_extcap extcap;
+ struct ieee_types_generic rsn_ie;
+ struct ieee80211_vht_cap vhtcap;
+ struct ieee80211_vht_operation vhtoper;
+};
+
+/* This is AP/TDLS specific structure which stores information
+ * about associated/peer STA
  */
 struct mwifiex_sta_node {
  struct list_head list;
  u8 mac_addr[ETH_ALEN];
  u8 is_wmm_enabled;
  u8 is_11n_enabled;
+ u8 is_11ac_enabled;
  u8 ampdu_sta[MAX_NUM_TID];
  u16 rx_seq[MAX_NUM_TID];
  u16 max_amsdu;
+ u8 tdls_status;
+ struct mwifiex_tdls_capab tdls_cap;
 };
 
 struct mwifiex_if_ops {
@@ -596,6 +656,7 @@ struct mwifiex_if_ops {
  int (*register_dev) (struct mwifiex_adapter *);
  void (*unregister_dev) (struct mwifiex_adapter *);
  int (*enable_int) (struct mwifiex_adapter *);
+ void (*disable_int) (struct mwifiex_adapter *);
  int (*process_int_status) (struct mwifiex_adapter *);
  int (*host_to_card) (struct mwifiex_adapter *, u8, struct sk_buff *,
         struct mwifiex_tx_param *);
@@ -607,10 +668,11 @@ struct mwifiex_if_ops {
  void (*cleanup_mpa_buf) (struct mwifiex_adapter *);
  int (*cmdrsp_complete) (struct mwifiex_adapter *, struct sk_buff *);
  int (*event_complete) (struct mwifiex_adapter *, struct sk_buff *);
- int (*data_complete) (struct mwifiex_adapter *, struct sk_buff *);
+ int (*data_complete) (struct mwifiex_adapter *);
  int (*init_fw_port) (struct mwifiex_adapter *);
  int (*dnld_fw) (struct mwifiex_adapter *, struct mwifiex_fw_image *);
  void (*card_reset) (struct mwifiex_adapter *);
+ void (*fw_dump)(struct mwifiex_adapter *);
  int (*clean_pcie_ring) (struct mwifiex_adapter *adapter);
 };
 
@@ -662,7 +724,7 @@ struct mwifiex_adapter {
  struct cmd_ctrl_node *curr_cmd;
  /* spin lock for command */
  spinlock_t mwifiex_cmd_lock;
- u32 num_cmd_timeout;
+ u8 is_cmd_timedout;
  u16 last_init_cmd;
  struct timer_list cmd_timer;
  struct list_head cmd_free_q;
@@ -713,23 +775,25 @@ struct mwifiex_adapter {
  u16 hs_activate_wait_q_woken;
  wait_queue_head_t hs_activate_wait_q;
  bool is_suspended;
+ bool hs_enabling;
  u8 event_body[MAX_EVENT_SIZE];
  u32 hw_dot_11n_dev_cap;
  u8 hw_dev_mcs_support;
+ u8 user_dev_mcs_support;
  u8 adhoc_11n_enabled;
  u8 sec_chan_offset;
  struct mwifiex_dbg dbg;
  u8 arp_filter[ARP_FILTER_MAX_BUF_SIZE];
  u32 arp_filter_size;
- u16 cmd_wait_q_required;
  struct mwifiex_wait_queue cmd_wait_q;
  u8 scan_wait_q_woken;
  spinlock_t queue_lock;  /* lock for tx queues */
- struct completion fw_load;
  u8 country_code[IEEE80211_COUNTRY_STRING_LEN];
  u16 max_mgmt_ie_index;
  u8 scan_delay_cnt;
  u8 empty_tx_q_cnt;
+ const struct firmware *cal_data;
+ struct device_node *dt_node;
 
  /* 11AC */
  u32 is_hw_11ac_capable;
@@ -741,6 +805,10 @@ struct mwifiex_adapter {
 
  atomic_t is_tx_received;
  atomic_t pending_bridged_pkts;
+ struct semaphore *card_sem;
+ bool ext_scan;
+ u8 fw_api_ver;
+ u8 fw_key_api_major_ver, fw_key_api_minor_ver;
 };
 
 int mwifiex_init_lock_list(struct mwifiex_adapter *adapter);
@@ -776,11 +844,8 @@ int mwifiex_process_event(struct mwifiex_adapter *adapter);
 int mwifiex_complete_cmd(struct mwifiex_adapter *adapter,
     struct cmd_ctrl_node *cmd_node);
 
-int mwifiex_send_cmd_async(struct mwifiex_private *priv, uint16_t cmd_no,
-      u16 cmd_action, u32 cmd_oid, void *data_buf);
-
-int mwifiex_send_cmd_sync(struct mwifiex_private *priv, uint16_t cmd_no,
-     u16 cmd_action, u32 cmd_oid, void *data_buf);
+int mwifiex_send_cmd(struct mwifiex_private *priv, u16 cmd_no,
+       u16 cmd_action, u32 cmd_oid, void *data_buf, bool sync);
 
 void mwifiex_cmd_timeout_func(unsigned long function_context);
 
@@ -845,8 +910,6 @@ int mwifiex_handle_uap_rx_forward(struct mwifiex_private *priv,
       struct sk_buff *skb);
 int mwifiex_process_sta_event(struct mwifiex_private *);
 int mwifiex_process_uap_event(struct mwifiex_private *);
-struct mwifiex_sta_node *
-mwifiex_get_sta_entry(struct mwifiex_private *priv, u8 *mac);
 void mwifiex_delete_all_station_list(struct mwifiex_private *priv);
 void *mwifiex_process_sta_txpd(struct mwifiex_private *, struct sk_buff *skb);
 void *mwifiex_process_uap_txpd(struct mwifiex_private *, struct sk_buff *skb);
@@ -868,6 +931,7 @@ int mwifiex_ret_802_11_associate(struct mwifiex_private *priv,
 void mwifiex_reset_connect_state(struct mwifiex_private *priv, u16 reason);
 u8 mwifiex_band_to_radio_type(u8 band);
 int mwifiex_deauthenticate(struct mwifiex_private *priv, u8 *mac);
+void mwifiex_deauthenticate_all(struct mwifiex_adapter *adapter);
 int mwifiex_adhoc_start(struct mwifiex_private *priv,
    struct cfg80211_ssid *adhoc_ssid);
 int mwifiex_adhoc_join(struct mwifiex_private *priv,
@@ -893,6 +957,8 @@ int mwifiex_cmd_append_vsie_tlv(struct mwifiex_private *priv, u16 vsie_mask,
 u32 mwifiex_get_active_data_rates(struct mwifiex_private *priv,
         u8 *rates);
 u32 mwifiex_get_supported_rates(struct mwifiex_private *priv, u8 *rates);
+u32 mwifiex_get_rates_from_cfg80211(struct mwifiex_private *priv,
+        u8 *rates, u8 radio_type);
 u8 mwifiex_is_rate_auto(struct mwifiex_private *priv);
 extern u16 region_code_index[MWIFIEX_MAX_REGION_CODE];
 void mwifiex_save_curr_bcn(struct mwifiex_private *priv);
@@ -924,6 +990,12 @@ mwifiex_set_wmm_params(struct mwifiex_private *priv,
          struct cfg80211_ap_settings *params);
 void mwifiex_set_ba_params(struct mwifiex_private *priv);
 void mwifiex_set_11ac_ba_params(struct mwifiex_private *priv);
+int mwifiex_cmd_802_11_scan_ext(struct mwifiex_private *priv,
+    struct host_cmd_ds_command *cmd,
+    void *data_buf);
+int mwifiex_ret_802_11_scan_ext(struct mwifiex_private *priv);
+int mwifiex_handle_event_ext_scan_report(struct mwifiex_private *priv,
+      void *buf);
 
 /*
  * This function checks if the queuing is RA based or not.
@@ -1014,7 +1086,25 @@ mwifiex_netdev_get_priv(struct net_device *dev)
  */
 static inline bool mwifiex_is_skb_mgmt_frame(struct sk_buff *skb)
 {
- return (*(u32 *)skb->data == PKT_TYPE_MGMT);
+ return (le32_to_cpu(*(__le32 *)skb->data) == PKT_TYPE_MGMT);
+}
+
+/* This function retrieves channel closed for operation by Channel
+ * Switch Announcement.
+ */
+static inline u8
+mwifiex_11h_get_csa_closed_channel(struct mwifiex_private *priv)
+{
+ if (!priv->csa_chan)
+  return 0;
+
+ /* Clear csa channel, if DFS channel move time has passed */
+ if (time_after(jiffies, priv->csa_expire_time)) {
+  priv->csa_chan = 0;
+  priv->csa_expire_time = 0;
+ }
+
+ return priv->csa_chan;
 }
 
 int mwifiex_init_shutdown_fw(struct mwifiex_private *priv,
@@ -1046,7 +1136,7 @@ int mwifiex_set_encode(struct mwifiex_private *priv, struct key_params *kp,
          const u8 *key, int key_len, u8 key_index,
          const u8 *mac_addr, int disable);
 
-int mwifiex_set_gen_ie(struct mwifiex_private *priv, u8 *ie, int ie_len);
+int mwifiex_set_gen_ie(struct mwifiex_private *priv, const u8 *ie, int ie_len);
 
 int mwifiex_get_ver_ext(struct mwifiex_private *priv);
 
@@ -1115,9 +1205,44 @@ int mwifiex_set_mgmt_ies(struct mwifiex_private *priv,
     struct cfg80211_beacon_data *data);
 int mwifiex_del_mgmt_ies(struct mwifiex_private *priv);
 u8 *mwifiex_11d_code_2_region(u8 code);
+void mwifiex_uap_del_sta_data(struct mwifiex_private *priv,
+         struct mwifiex_sta_node *node);
+
+void mwifiex_11h_process_join(struct mwifiex_private *priv, u8 **buffer,
+         struct mwifiex_bssdescriptor *bss_desc);
+int mwifiex_11h_handle_event_chanswann(struct mwifiex_private *priv);
+int mwifiex_dnld_dt_cfgdata(struct mwifiex_private *priv,
+       struct device_node *node, const char *prefix);
+void mwifiex_dnld_txpwr_table(struct mwifiex_private *priv);
 
 extern const struct ethtool_ops mwifiex_ethtool_ops;
 
+void mwifiex_del_all_sta_list(struct mwifiex_private *priv);
+void mwifiex_del_sta_entry(struct mwifiex_private *priv, const u8 *mac);
+void
+mwifiex_set_sta_ht_cap(struct mwifiex_private *priv, const u8 *ies,
+         int ies_len, struct mwifiex_sta_node *node);
+struct mwifiex_sta_node *
+mwifiex_add_sta_entry(struct mwifiex_private *priv, const u8 *mac);
+struct mwifiex_sta_node *
+mwifiex_get_sta_entry(struct mwifiex_private *priv, const u8 *mac);
+int mwifiex_send_tdls_data_frame(struct mwifiex_private *priv, const u8 *peer,
+     u8 action_code, u8 dialog_token,
+     u16 status_code, const u8 *extra_ies,
+     size_t extra_ies_len);
+int mwifiex_send_tdls_action_frame(struct mwifiex_private *priv, const u8 *peer,
+       u8 action_code, u8 dialog_token,
+       u16 status_code, const u8 *extra_ies,
+       size_t extra_ies_len);
+void mwifiex_process_tdls_action_frame(struct mwifiex_private *priv,
+           u8 *buf, int len);
+int mwifiex_tdls_oper(struct mwifiex_private *priv, const u8 *peer, u8 action);
+int mwifiex_get_tdls_link_status(struct mwifiex_private *priv, const u8 *mac);
+void mwifiex_disable_all_tdls_links(struct mwifiex_private *priv);
+bool mwifiex_is_bss_in_11ac_mode(struct mwifiex_private *priv);
+u8 mwifiex_get_center_freq_index(struct mwifiex_private *priv, u8 band,
+     u32 pri_chan, u8 chan_bw);
+
 #ifdef CONFIG_DEBUG_FS
 void mwifiex_debugfs_init(void);
 void mwifiex_debugfs_remove(void);
diff --git a/drivers/net/wireless/mwifiex/pcie.c b/drivers/net/wireless/mwifiex/pcie.c
index 20c9c4c..2cc9b6f 100644
--- a/drivers/net/wireless/mwifiex/pcie.c
+++ b/drivers/net/wireless/mwifiex/pcie.c
@@ -39,20 +39,31 @@ static struct semaphore add_remove_card_sem;
 
 static int
 mwifiex_map_pci_memory(struct mwifiex_adapter *adapter, struct sk_buff *skb,
-         int size, int flags)
+         size_t size, int flags)
 {
  struct pcie_service_card *card = adapter->card;
- dma_addr_t buf_pa;
+ struct mwifiex_dma_mapping mapping;
 
- buf_pa = pci_map_single(card->dev, skb->data, size, flags);
- if (pci_dma_mapping_error(card->dev, buf_pa)) {
+ mapping.addr = pci_map_single(card->dev, skb->data, size, flags);
+ if (pci_dma_mapping_error(card->dev, mapping.addr)) {
   dev_err(adapter->dev, "failed to map pci memory!\n");
   return -1;
  }
- memcpy(skb->cb, &buf_pa, sizeof(dma_addr_t));
+ mapping.len = size;
+ mwifiex_store_mapping(skb, &mapping);
  return 0;
 }
 
+static void mwifiex_unmap_pci_memory(struct mwifiex_adapter *adapter,
+         struct sk_buff *skb, int flags)
+{
+ struct pcie_service_card *card = adapter->card;
+ struct mwifiex_dma_mapping mapping;
+
+ mwifiex_get_mapping(skb, &mapping);
+ pci_unmap_single(card->dev, mapping.addr, mapping.len, flags);
+}
+
 /*
  * This function reads sleep cookie and checks if FW is ready
  */
@@ -76,7 +87,7 @@ static bool mwifiex_pcie_ok_to_access_hw(struct mwifiex_adapter *adapter)
  return false;
 }
 
-#ifdef CONFIG_PM
+#ifdef CONFIG_PM_SLEEP
 /*
  * Kernel needs to suspend all functions separately. Therefore all
  * registered functions must have drivers with suspend and resume
@@ -85,14 +96,15 @@ static bool mwifiex_pcie_ok_to_access_hw(struct mwifiex_adapter *adapter)
  * If already not suspended, this function allocates and sends a host
  * sleep activate request to the firmware and turns off the traffic.
  */
-static int mwifiex_pcie_suspend(struct pci_dev *pdev, pm_message_t state)
+static int mwifiex_pcie_suspend(struct device *dev)
 {
  struct mwifiex_adapter *adapter;
  struct pcie_service_card *card;
  int hs_actived;
+ struct pci_dev *pdev = to_pci_dev(dev);
 
  if (pdev) {
-  card = (struct pcie_service_card *) pci_get_drvdata(pdev);
+  card = pci_get_drvdata(pdev);
   if (!card || !card->adapter) {
    pr_err("Card or adapter structure is not valid\n");
    return 0;
@@ -108,6 +120,7 @@ static int mwifiex_pcie_suspend(struct pci_dev *pdev, pm_message_t state)
 
  /* Indicate device suspended */
  adapter->is_suspended = true;
+ adapter->hs_enabling = false;
 
  return 0;
 }
@@ -120,13 +133,14 @@ static int mwifiex_pcie_suspend(struct pci_dev *pdev, pm_message_t state)
  * If already not resumed, this function turns on the traffic and
  * sends a host sleep cancel request to the firmware.
  */
-static int mwifiex_pcie_resume(struct pci_dev *pdev)
+static int mwifiex_pcie_resume(struct device *dev)
 {
  struct mwifiex_adapter *adapter;
  struct pcie_service_card *card;
+ struct pci_dev *pdev = to_pci_dev(dev);
 
  if (pdev) {
-  card = (struct pcie_service_card *) pci_get_drvdata(pdev);
+  card = pci_get_drvdata(pdev);
   if (!card || !card->adapter) {
    pr_err("Card or adapter structure is not valid\n");
    return 0;
@@ -177,6 +191,7 @@ static int mwifiex_pcie_probe(struct pci_dev *pdev,
   card->pcie.firmware = data->firmware;
   card->pcie.reg = data->reg;
   card->pcie.blksz_fw_dl = data->blksz_fw_dl;
+  card->pcie.tx_buf_size = data->tx_buf_size;
  }
 
  if (mwifiex_add_card(card, &add_remove_card_sem, &pcie_ops,
@@ -197,7 +212,6 @@ static void mwifiex_pcie_remove(struct pci_dev *pdev)
  struct pcie_service_card *card;
  struct mwifiex_adapter *adapter;
  struct mwifiex_private *priv;
- int i;
 
  card = pci_get_drvdata(pdev);
  if (!card)
@@ -207,20 +221,13 @@ static void mwifiex_pcie_remove(struct pci_dev *pdev)
  if (!adapter || !adapter->priv_num)
   return;
 
- /* In case driver is removed when asynchronous FW load is in progress */
- wait_for_completion(&adapter->fw_load);
-
  if (user_rmmod) {
-#ifdef CONFIG_PM
+#ifdef CONFIG_PM_SLEEP
   if (adapter->is_suspended)
-   mwifiex_pcie_resume(pdev);
+   mwifiex_pcie_resume(&pdev->dev);
 #endif
 
-  for (i = 0; i < adapter->priv_num; i++)
-   if ((GET_BSS_ROLE(adapter->priv[i]) ==
-        MWIFIEX_BSS_ROLE_STA) &&
-       adapter->priv[i]->media_connected)
-    mwifiex_deauthenticate(adapter->priv[i], NULL);
+  mwifiex_deauthenticate_all(adapter);
 
   priv = mwifiex_get_priv(adapter, MWIFIEX_BSS_ROLE_ANY);
 
@@ -230,7 +237,14 @@ static void mwifiex_pcie_remove(struct pci_dev *pdev)
  }
 
  mwifiex_remove_card(card->adapter, &add_remove_card_sem);
- kfree(card);
+}
+
+static void mwifiex_pcie_shutdown(struct pci_dev *pdev)
+{
+ user_rmmod = 1;
+ mwifiex_pcie_remove(pdev);
+
+ return;
 }
 
 static DEFINE_PCI_DEVICE_TABLE(mwifiex_ids) = {
@@ -249,17 +263,24 @@ static DEFINE_PCI_DEVICE_TABLE(mwifiex_ids) = {
 
 MODULE_DEVICE_TABLE(pci, mwifiex_ids);
 
+#ifdef CONFIG_PM_SLEEP
+/* Power Management Hooks */
+static SIMPLE_DEV_PM_OPS(mwifiex_pcie_pm_ops, mwifiex_pcie_suspend,
+    mwifiex_pcie_resume);
+#endif
+
 /* PCI Device Driver */
 static struct pci_driver __refdata mwifiex_pcie = {
  .name     = "mwifiex_pcie",
  .id_table = mwifiex_ids,
  .probe    = mwifiex_pcie_probe,
  .remove   = mwifiex_pcie_remove,
-#ifdef CONFIG_PM
- /* Power Management Hooks */
- .suspend  = mwifiex_pcie_suspend,
- .resume   = mwifiex_pcie_resume,
+#ifdef CONFIG_PM_SLEEP
+ .driver   = {
+  .pm = &mwifiex_pcie_pm_ops,
+ },
 #endif
+ .shutdown = mwifiex_pcie_shutdown,
 };
 
 /*
@@ -304,6 +325,30 @@ static void mwifiex_pcie_dev_wakeup_delay(struct mwifiex_adapter *adapter)
  return;
 }
 
+static void mwifiex_delay_for_sleep_cookie(struct mwifiex_adapter *adapter,
+        u32 max_delay_loop_cnt)
+{
+ struct pcie_service_card *card = adapter->card;
+ u8 *buffer;
+ u32 sleep_cookie, count;
+
+ for (count = 0; count < max_delay_loop_cnt; count++) {
+  buffer = card->cmdrsp_buf->data - INTF_HEADER_LEN;
+  sleep_cookie = *(u32 *)buffer;
+
+  if (sleep_cookie == MWIFIEX_DEF_SLEEP_COOKIE) {
+   dev_dbg(adapter->dev,
+    "sleep cookie found at count %d\n", count);
+   break;
+  }
+  usleep_range(20, 30);
+ }
+
+ if (count >= max_delay_loop_cnt)
+  dev_dbg(adapter->dev,
+   "max count reached while accessing sleep cookie\n");
+}
+
 /* This function wakes up the card by reading fw_status register. */
 static int mwifiex_pm_wakeup_card(struct mwifiex_adapter *adapter)
 {
@@ -440,7 +485,7 @@ static int mwifiex_init_rxq_ring(struct mwifiex_adapter *adapter)
         PCI_DMA_FROMDEVICE))
    return -1;
 
-  MWIFIEX_SKB_PACB(skb, &buf_pa);
+  buf_pa = MWIFIEX_SKB_DMA_ADDR(skb);
 
   dev_dbg(adapter->dev,
    "info: RX ring: skb=%p len=%d data=%p buf_pa=%#x:%x\n",
@@ -497,7 +542,7 @@ static int mwifiex_pcie_init_evt_ring(struct mwifiex_adapter *adapter)
         PCI_DMA_FROMDEVICE))
    return -1;
 
-  MWIFIEX_SKB_PACB(skb, &buf_pa);
+  buf_pa = MWIFIEX_SKB_DMA_ADDR(skb);
 
   dev_dbg(adapter->dev,
    "info: EVT ring: skb=%p len=%d data=%p buf_pa=%#x:%x\n",
@@ -533,8 +578,8 @@ static void mwifiex_cleanup_txq_ring(struct mwifiex_adapter *adapter)
    desc2 = card->txbd_ring[i];
    if (card->tx_buf_list[i]) {
     skb = card->tx_buf_list[i];
-    pci_unmap_single(card->dev, desc2->paddr,
-       skb->len, PCI_DMA_TODEVICE);
+    mwifiex_unmap_pci_memory(adapter, skb,
+        PCI_DMA_TODEVICE);
     dev_kfree_skb_any(skb);
    }
    memset(desc2, 0, sizeof(*desc2));
@@ -542,8 +587,8 @@ static void mwifiex_cleanup_txq_ring(struct mwifiex_adapter *adapter)
    desc = card->txbd_ring[i];
    if (card->tx_buf_list[i]) {
     skb = card->tx_buf_list[i];
-    pci_unmap_single(card->dev, desc->paddr,
-       skb->len, PCI_DMA_TODEVICE);
+    mwifiex_unmap_pci_memory(adapter, skb,
+        PCI_DMA_TODEVICE);
     dev_kfree_skb_any(skb);
    }
    memset(desc, 0, sizeof(*desc));
@@ -571,8 +616,8 @@ static void mwifiex_cleanup_rxq_ring(struct mwifiex_adapter *adapter)
    desc2 = card->rxbd_ring[i];
    if (card->rx_buf_list[i]) {
     skb = card->rx_buf_list[i];
-    pci_unmap_single(card->dev, desc2->paddr,
-       skb->len, PCI_DMA_FROMDEVICE);
+    mwifiex_unmap_pci_memory(adapter, skb,
+        PCI_DMA_FROMDEVICE);
     dev_kfree_skb_any(skb);
    }
    memset(desc2, 0, sizeof(*desc2));
@@ -580,8 +625,8 @@ static void mwifiex_cleanup_rxq_ring(struct mwifiex_adapter *adapter)
    desc = card->rxbd_ring[i];
    if (card->rx_buf_list[i]) {
     skb = card->rx_buf_list[i];
-    pci_unmap_single(card->dev, desc->paddr,
-       skb->len, PCI_DMA_FROMDEVICE);
+    mwifiex_unmap_pci_memory(adapter, skb,
+        PCI_DMA_FROMDEVICE);
     dev_kfree_skb_any(skb);
    }
    memset(desc, 0, sizeof(*desc));
@@ -606,8 +651,8 @@ static void mwifiex_cleanup_evt_ring(struct mwifiex_adapter *adapter)
   desc = card->evtbd_ring[i];
   if (card->evt_buf_list[i]) {
    skb = card->evt_buf_list[i];
-   pci_unmap_single(card->dev, desc->paddr, MAX_EVENT_SIZE,
-      PCI_DMA_FROMDEVICE);
+   mwifiex_unmap_pci_memory(adapter, skb,
+       PCI_DMA_FROMDEVICE);
    dev_kfree_skb_any(skb);
   }
   card->evt_buf_list[i] = NULL;
@@ -845,7 +890,6 @@ static int mwifiex_pcie_alloc_cmdrsp_buf(struct mwifiex_adapter *adapter)
 static int mwifiex_pcie_delete_cmdrsp_buf(struct mwifiex_adapter *adapter)
 {
  struct pcie_service_card *card;
- dma_addr_t buf_pa;
 
  if (!adapter)
   return 0;
@@ -853,16 +897,14 @@ static int mwifiex_pcie_delete_cmdrsp_buf(struct mwifiex_adapter *adapter)
  card = adapter->card;
 
  if (card && card->cmdrsp_buf) {
-  MWIFIEX_SKB_PACB(card->cmdrsp_buf, &buf_pa);
-  pci_unmap_single(card->dev, buf_pa, MWIFIEX_UPLD_SIZE,
-     PCI_DMA_FROMDEVICE);
+  mwifiex_unmap_pci_memory(adapter, card->cmdrsp_buf,
+      PCI_DMA_FROMDEVICE);
   dev_kfree_skb_any(card->cmdrsp_buf);
  }
 
  if (card && card->cmd_buf) {
-  MWIFIEX_SKB_PACB(card->cmd_buf, &buf_pa);
-  pci_unmap_single(card->dev, buf_pa, card->cmd_buf->len,
-     PCI_DMA_TODEVICE);
+  mwifiex_unmap_pci_memory(adapter, card->cmd_buf,
+      PCI_DMA_TODEVICE);
  }
  return 0;
 }
@@ -940,7 +982,6 @@ static int mwifiex_clean_pcie_ring_buf(struct mwifiex_adapter *adapter)
 static int mwifiex_pcie_send_data_complete(struct mwifiex_adapter *adapter)
 {
  struct sk_buff *skb;
- dma_addr_t buf_pa;
  u32 wrdoneidx, rdptr, num_tx_buffs, unmap_count = 0;
  struct mwifiex_pcie_buf_desc *desc;
  struct mwifiex_pfu_buf_desc *desc2;
@@ -970,13 +1011,13 @@ static int mwifiex_pcie_send_data_complete(struct mwifiex_adapter *adapter)
        reg->tx_start_ptr;
 
   skb = card->tx_buf_list[wrdoneidx];
+
   if (skb) {
    dev_dbg(adapter->dev,
     "SEND COMP: Detach skb %p at txbd_rdidx=%d\n",
     skb, wrdoneidx);
-   MWIFIEX_SKB_PACB(skb, &buf_pa);
-   pci_unmap_single(card->dev, buf_pa, skb->len,
-      PCI_DMA_TODEVICE);
+   mwifiex_unmap_pci_memory(adapter, skb,
+       PCI_DMA_TODEVICE);
 
    unmap_count++;
 
@@ -990,7 +1031,7 @@ static int mwifiex_pcie_send_data_complete(struct mwifiex_adapter *adapter)
   card->tx_buf_list[wrdoneidx] = NULL;
 
   if (reg->pfu_enabled) {
-   desc2 = (void *)card->txbd_ring[wrdoneidx];
+   desc2 = card->txbd_ring[wrdoneidx];
    memset(desc2, 0, sizeof(*desc2));
   } else {
    desc = card->txbd_ring[wrdoneidx];
@@ -1030,6 +1071,7 @@ static int mwifiex_pcie_send_data_complete(struct mwifiex_adapter *adapter)
  * is mapped to PCI device memory. Tx ring pointers are advanced accordingly.
  * Download ready interrupt to FW is deffered if Tx ring is not full and
  * additional payload can be accomodated.
+ * Caller must ensure tx_param parameter to this function is not NULL.
  */
 static int
 mwifiex_pcie_send_data(struct mwifiex_adapter *adapter, struct sk_buff *skb,
@@ -1066,16 +1108,16 @@ mwifiex_pcie_send_data(struct mwifiex_adapter *adapter, struct sk_buff *skb,
   tmp = (__le16 *)&payload[2];
   *tmp = cpu_to_le16(MWIFIEX_TYPE_DATA);
 
-  if (mwifiex_map_pci_memory(adapter, skb, skb->len ,
+  if (mwifiex_map_pci_memory(adapter, skb, skb->len,
         PCI_DMA_TODEVICE))
    return -1;
 
   wrindx = (card->txbd_wrptr & reg->tx_mask) >> reg->tx_start_ptr;
-  MWIFIEX_SKB_PACB(skb, &buf_pa);
+  buf_pa = MWIFIEX_SKB_DMA_ADDR(skb);
   card->tx_buf_list[wrindx] = skb;
 
   if (reg->pfu_enabled) {
-   desc2 = (void *)card->txbd_ring[wrindx];
+   desc2 = card->txbd_ring[wrindx];
    desc2->paddr = buf_pa;
    desc2->len = (u16)skb->len;
    desc2->frag_len = (u16)skb->len;
@@ -1146,8 +1188,7 @@ mwifiex_pcie_send_data(struct mwifiex_adapter *adapter, struct sk_buff *skb,
 
  return -EINPROGRESS;
 done_unmap:
- MWIFIEX_SKB_PACB(skb, &buf_pa);
- pci_unmap_single(card->dev, buf_pa, skb->len, PCI_DMA_TODEVICE);
+ mwifiex_unmap_pci_memory(adapter, skb, PCI_DMA_TODEVICE);
  card->tx_buf_list[wrindx] = NULL;
  if (reg->pfu_enabled)
   memset(desc2, 0, sizeof(*desc2));
@@ -1195,9 +1236,13 @@ static int mwifiex_pcie_process_recv_data(struct mwifiex_adapter *adapter)
   rd_index = card->rxbd_rdptr & reg->rx_mask;
   skb_data = card->rx_buf_list[rd_index];
 
-  MWIFIEX_SKB_PACB(skb_data, &buf_pa);
-  pci_unmap_single(card->dev, buf_pa, MWIFIEX_RX_DATA_BUF_SIZE,
-     PCI_DMA_FROMDEVICE);
+  /* If skb allocation was failed earlier for Rx packet,
+   * rx_buf_list[rd_index] would have been left with a NULL.
+   */
+  if (!skb_data)
+   return -ENOMEM;
+
+  mwifiex_unmap_pci_memory(adapter, skb_data, PCI_DMA_FROMDEVICE);
   card->rx_buf_list[rd_index] = NULL;
 
   /* Get data length from interface header -
@@ -1224,7 +1269,7 @@ static int mwifiex_pcie_process_recv_data(struct mwifiex_adapter *adapter)
         PCI_DMA_FROMDEVICE))
    return -1;
 
-  MWIFIEX_SKB_PACB(skb_tmp, &buf_pa);
+  buf_pa = MWIFIEX_SKB_DMA_ADDR(skb_tmp);
 
   dev_dbg(adapter->dev,
    "RECV DATA: Attach new sk_buff %p at rxbd_rdidx=%d\n",
@@ -1232,7 +1277,7 @@ static int mwifiex_pcie_process_recv_data(struct mwifiex_adapter *adapter)
   card->rx_buf_list[rd_index] = skb_tmp;
 
   if (reg->pfu_enabled) {
-   desc2 = (void *)card->rxbd_ring[rd_index];
+   desc2 = card->rxbd_ring[rd_index];
    desc2->paddr = buf_pa;
    desc2->len = skb_tmp->len;
    desc2->frag_len = skb_tmp->len;
@@ -1300,7 +1345,7 @@ mwifiex_pcie_send_boot_cmd(struct mwifiex_adapter *adapter, struct sk_buff *skb)
  if (mwifiex_map_pci_memory(adapter, skb, skb->len , PCI_DMA_TODEVICE))
   return -1;
 
- MWIFIEX_SKB_PACB(skb, &buf_pa);
+ buf_pa = MWIFIEX_SKB_DMA_ADDR(skb);
 
  /* Write the lower 32bits of the physical address to low command
   * address scratch register
@@ -1309,8 +1354,7 @@ mwifiex_pcie_send_boot_cmd(struct mwifiex_adapter *adapter, struct sk_buff *skb)
   dev_err(adapter->dev,
    "%s: failed to write download command to boot code.\n",
    __func__);
-  pci_unmap_single(card->dev, buf_pa, MWIFIEX_UPLD_SIZE,
-     PCI_DMA_TODEVICE);
+  mwifiex_unmap_pci_memory(adapter, skb, PCI_DMA_TODEVICE);
   return -1;
  }
 
@@ -1322,8 +1366,7 @@ mwifiex_pcie_send_boot_cmd(struct mwifiex_adapter *adapter, struct sk_buff *skb)
   dev_err(adapter->dev,
    "%s: failed to write download command to boot code.\n",
    __func__);
-  pci_unmap_single(card->dev, buf_pa, MWIFIEX_UPLD_SIZE,
-     PCI_DMA_TODEVICE);
+  mwifiex_unmap_pci_memory(adapter, skb, PCI_DMA_TODEVICE);
   return -1;
  }
 
@@ -1332,8 +1375,7 @@ mwifiex_pcie_send_boot_cmd(struct mwifiex_adapter *adapter, struct sk_buff *skb)
   dev_err(adapter->dev,
    "%s: failed to write command len to cmd_size scratch reg\n",
    __func__);
-  pci_unmap_single(card->dev, buf_pa, MWIFIEX_UPLD_SIZE,
-     PCI_DMA_TODEVICE);
+  mwifiex_unmap_pci_memory(adapter, skb, PCI_DMA_TODEVICE);
   return -1;
  }
 
@@ -1342,8 +1384,7 @@ mwifiex_pcie_send_boot_cmd(struct mwifiex_adapter *adapter, struct sk_buff *skb)
          CPU_INTR_DOOR_BELL)) {
   dev_err(adapter->dev,
    "%s: failed to assert door-bell intr\n", __func__);
-  pci_unmap_single(card->dev, buf_pa,
-     MWIFIEX_UPLD_SIZE, PCI_DMA_TODEVICE);
+  mwifiex_unmap_pci_memory(adapter, skb, PCI_DMA_TODEVICE);
   return -1;
  }
 
@@ -1417,7 +1458,7 @@ mwifiex_pcie_send_cmd(struct mwifiex_adapter *adapter, struct sk_buff *skb)
  */
 
  if (card->cmdrsp_buf) {
-  MWIFIEX_SKB_PACB(card->cmdrsp_buf, &cmdrsp_buf_pa);
+  cmdrsp_buf_pa = MWIFIEX_SKB_DMA_ADDR(card->cmdrsp_buf);
   /* Write the lower 32bits of the cmdrsp buffer physical
      address */
   if (mwifiex_write_reg(adapter, reg->cmdrsp_addr_lo,
@@ -1438,7 +1479,7 @@ mwifiex_pcie_send_cmd(struct mwifiex_adapter *adapter, struct sk_buff *skb)
   }
  }
 
- MWIFIEX_SKB_PACB(card->cmd_buf, &cmd_buf_pa);
+ cmd_buf_pa = MWIFIEX_SKB_DMA_ADDR(card->cmd_buf);
  /* Write the lower 32bits of the physical address to reg->cmd_addr_lo */
  if (mwifiex_write_reg(adapter, reg->cmd_addr_lo,
          (u32)cmd_buf_pa)) {
@@ -1492,13 +1533,17 @@ static int mwifiex_pcie_process_cmd_complete(struct mwifiex_adapter *adapter)
  int count = 0;
  u16 rx_len;
  __le16 pkt_len;
- dma_addr_t buf_pa;
 
  dev_dbg(adapter->dev, "info: Rx CMD Response\n");
 
- MWIFIEX_SKB_PACB(skb, &buf_pa);
- pci_unmap_single(card->dev, buf_pa, MWIFIEX_UPLD_SIZE,
-    PCI_DMA_FROMDEVICE);
+ mwifiex_unmap_pci_memory(adapter, skb, PCI_DMA_FROMDEVICE);
+
+ /* Unmap the command as a response has been received. */
+ if (card->cmd_buf) {
+  mwifiex_unmap_pci_memory(adapter, card->cmd_buf,
+      PCI_DMA_TODEVICE);
+  card->cmd_buf = NULL;
+ }
 
  pkt_len = *((__le16 *)skb->data);
  rx_len = le16_to_cpu(pkt_len);
@@ -1509,6 +1554,16 @@ static int mwifiex_pcie_process_cmd_complete(struct mwifiex_adapter *adapter)
   if (adapter->ps_state == PS_STATE_SLEEP_CFM) {
    mwifiex_process_sleep_confirm_resp(adapter, skb->data,
           skb->len);
+   mwifiex_pcie_enable_host_int(adapter);
+   if (mwifiex_write_reg(adapter,
+           PCIE_CPU_INT_EVENT,
+           CPU_INTR_SLEEP_CFM_DONE)) {
+    dev_warn(adapter->dev,
+      "Write register failed\n");
+    return -1;
+   }
+   mwifiex_delay_for_sleep_cookie(adapter,
+             MWIFIEX_MAX_DELAY_COUNT);
    while (reg->sleep_cookie && (count++ < 10) &&
           mwifiex_pcie_ok_to_access_hw(adapter))
     usleep_range(50, 60);
@@ -1522,8 +1577,6 @@ static int mwifiex_pcie_process_cmd_complete(struct mwifiex_adapter *adapter)
   if (mwifiex_map_pci_memory(adapter, skb, MWIFIEX_UPLD_SIZE,
         PCI_DMA_FROMDEVICE))
    return -1;
-
-  MWIFIEX_SKB_PACB(skb, &buf_pa);
  } else if (mwifiex_pcie_ok_to_access_hw(adapter)) {
   adapter->curr_cmd->resp_skb = skb;
   adapter->cmd_resp_received = true;
@@ -1558,8 +1611,6 @@ static int mwifiex_pcie_cmdrsp_complete(struct mwifiex_adapter *adapter,
      struct sk_buff *skb)
 {
  struct pcie_service_card *card = adapter->card;
- dma_addr_t buf_pa;
- struct sk_buff *skb_tmp;
 
  if (skb) {
   card->cmdrsp_buf = skb;
@@ -1569,14 +1620,6 @@ static int mwifiex_pcie_cmdrsp_complete(struct mwifiex_adapter *adapter,
    return -1;
  }
 
- skb_tmp = card->cmd_buf;
- if (skb_tmp) {
-  MWIFIEX_SKB_PACB(skb_tmp, &buf_pa);
-  pci_unmap_single(card->dev, buf_pa, skb_tmp->len,
-     PCI_DMA_FROMDEVICE);
-  card->cmd_buf = NULL;
- }
-
  return 0;
 }
 
@@ -1589,7 +1632,6 @@ static int mwifiex_pcie_process_event_ready(struct mwifiex_adapter *adapter)
  const struct mwifiex_pcie_card_reg *reg = card->pcie.reg;
  u32 rdptr = card->evtbd_rdptr & MWIFIEX_EVTBD_MASK;
  u32 wrptr, event;
- dma_addr_t buf_pa;
  struct mwifiex_evt_buf_desc *desc;
 
  if (!mwifiex_pcie_ok_to_access_hw(adapter))
@@ -1625,9 +1667,7 @@ static int mwifiex_pcie_process_event_ready(struct mwifiex_adapter *adapter)
 
   dev_dbg(adapter->dev, "info: Read Index: %d\n", rdptr);
   skb_cmd = card->evt_buf_list[rdptr];
-  MWIFIEX_SKB_PACB(skb_cmd, &buf_pa);
-  pci_unmap_single(card->dev, buf_pa, MAX_EVENT_SIZE,
-     PCI_DMA_FROMDEVICE);
+  mwifiex_unmap_pci_memory(adapter, skb_cmd, PCI_DMA_FROMDEVICE);
 
   /* Take the pointer and set it to event pointer in adapter
      and will return back after event handling callback */
@@ -1673,7 +1713,6 @@ static int mwifiex_pcie_event_complete(struct mwifiex_adapter *adapter,
  int ret = 0;
  u32 rdptr = card->evtbd_rdptr & MWIFIEX_EVTBD_MASK;
  u32 wrptr;
- dma_addr_t buf_pa;
  struct mwifiex_evt_buf_desc *desc;
 
  if (!skb)
@@ -1698,11 +1737,9 @@ static int mwifiex_pcie_event_complete(struct mwifiex_adapter *adapter,
         MAX_EVENT_SIZE,
         PCI_DMA_FROMDEVICE))
    return -1;
-  MWIFIEX_SKB_PACB(skb, &buf_pa);
   card->evt_buf_list[rdptr] = skb;
-  MWIFIEX_SKB_PACB(skb, &buf_pa);
   desc = card->evtbd_ring[rdptr];
-  desc->paddr = buf_pa;
+  desc->paddr = MWIFIEX_SKB_DMA_ADDR(skb);
   desc->len = (u16)skb->len;
   desc->flags = 0;
   skb = NULL;
@@ -1752,7 +1789,6 @@ static int mwifiex_prog_fw_w_helper(struct mwifiex_adapter *adapter,
  struct sk_buff *skb;
  u32 txlen, tx_blocks = 0, tries, len;
  u32 block_retry_cnt = 0;
- dma_addr_t buf_pa;
  struct pcie_service_card *card = adapter->card;
  const struct mwifiex_pcie_card_reg *reg = card->pcie.reg;
 
@@ -1850,8 +1886,6 @@ static int mwifiex_prog_fw_w_helper(struct mwifiex_adapter *adapter,
    goto done;
   }
 
-  MWIFIEX_SKB_PACB(skb, &buf_pa);
-
   /* Wait for the command done interrupt */
   do {
    if (mwifiex_read_reg(adapter, PCIE_CPU_INT_STATUS,
@@ -1859,16 +1893,15 @@ static int mwifiex_prog_fw_w_helper(struct mwifiex_adapter *adapter,
     dev_err(adapter->dev, "%s: Failed to read "
      "interrupt status during fw dnld.\n",
      __func__);
-    pci_unmap_single(card->dev, buf_pa, skb->len,
-       PCI_DMA_TODEVICE);
+    mwifiex_unmap_pci_memory(adapter, skb,
+        PCI_DMA_TODEVICE);
     ret = -1;
     goto done;
    }
   } while ((ireg_intr & CPU_INTR_DOOR_BELL) ==
     CPU_INTR_DOOR_BELL);
 
-  pci_unmap_single(card->dev, buf_pa, skb->len,
-     PCI_DMA_TODEVICE);
+  mwifiex_unmap_pci_memory(adapter, skb, PCI_DMA_TODEVICE);
 
   offset += txlen;
  } while (true);
@@ -1925,7 +1958,7 @@ mwifiex_check_fw_status(struct mwifiex_adapter *adapter, u32 poll_num)
    ret = 0;
    break;
   } else {
-   mdelay(100);
+   msleep(100);
    ret = -1;
   }
  }
@@ -1937,12 +1970,10 @@ mwifiex_check_fw_status(struct mwifiex_adapter *adapter, u32 poll_num)
   else if (!winner_status) {
    dev_err(adapter->dev, "PCI-E is the winner\n");
    adapter->winner = 1;
-   ret = -1;
   } else {
    dev_err(adapter->dev,
     "PCI-E is not the winner <%#x,%d>, exit dnld\n",
     ret, adapter->winner);
-   ret = 0;
   }
  }
 
@@ -1979,23 +2010,9 @@ static void mwifiex_interrupt_status(struct mwifiex_adapter *adapter)
   adapter->int_status |= pcie_ireg;
   spin_unlock_irqrestore(&adapter->int_lock, flags);
 
-  if (pcie_ireg & HOST_INTR_CMD_DONE) {
-   if ((adapter->ps_state == PS_STATE_SLEEP_CFM) ||
-       (adapter->ps_state == PS_STATE_SLEEP)) {
-    mwifiex_pcie_enable_host_int(adapter);
-    if (mwifiex_write_reg(adapter,
-            PCIE_CPU_INT_EVENT,
-            CPU_INTR_SLEEP_CFM_DONE)
-            ) {
-     dev_warn(adapter->dev,
-       "Write register failed\n");
-     return;
-
-    }
-   }
-  } else if (!adapter->pps_uapsd_mode &&
-      adapter->ps_state == PS_STATE_SLEEP &&
-      mwifiex_pcie_ok_to_access_hw(adapter)) {
+  if (!adapter->pps_uapsd_mode &&
+      adapter->ps_state == PS_STATE_SLEEP &&
+      mwifiex_pcie_ok_to_access_hw(adapter)) {
     /* Potentially for PCIe we could get other
      * interrupts like shared. Don't change power
      * state until cookie is set */
@@ -2022,7 +2039,7 @@ static irqreturn_t mwifiex_pcie_interrupt(int irq, void *context)
   goto exit;
  }
 
- card = (struct pcie_service_card *) pci_get_drvdata(pdev);
+ card = pci_get_drvdata(pdev);
  if (!card || !card->adapter) {
   pr_debug("info: %s: card=%p adapter=%p\n", __func__, card,
     card ? card->adapter : NULL);
@@ -2298,6 +2315,7 @@ static void mwifiex_pcie_cleanup(struct mwifiex_adapter *adapter)
   pci_release_region(pdev, 0);
   pci_set_drvdata(pdev, NULL);
  }
+ kfree(card);
 }
 
 /*
@@ -2323,6 +2341,7 @@ static int mwifiex_register_dev(struct mwifiex_adapter *adapter)
  }
 
  adapter->dev = &pdev->dev;
+ adapter->tx_buf_size = card->pcie.tx_buf_size;
  strcpy(adapter->fw_name, card->pcie.firmware);
 
  return 0;
diff --git a/drivers/net/wireless/mwifiex/pcie.h b/drivers/net/wireless/mwifiex/pcie.h
index d322ab8..e8ec561 100644
--- a/drivers/net/wireless/mwifiex/pcie.h
+++ b/drivers/net/wireless/mwifiex/pcie.h
@@ -97,6 +97,8 @@
 #define MWIFIEX_PCIE_BLOCK_SIZE_FW_DNLD  256
 /* FW awake cookie after FW ready */
 #define FW_AWAKE_COOKIE      (0xAA55AA55)
+#define MWIFIEX_DEF_SLEEP_COOKIE   0xBEEFBEEF
+#define MWIFIEX_MAX_DELAY_COUNT    5
 
 struct mwifiex_pcie_card_reg {
  u16 cmd_addr_lo;
@@ -195,18 +197,21 @@ struct mwifiex_pcie_device {
  const char *firmware;
  const struct mwifiex_pcie_card_reg *reg;
  u16 blksz_fw_dl;
+ u16 tx_buf_size;
 };
 
 static const struct mwifiex_pcie_device mwifiex_pcie8766 = {
  .firmware       = PCIE8766_DEFAULT_FW_NAME,
  .reg            = &mwifiex_reg_8766,
  .blksz_fw_dl = MWIFIEX_PCIE_BLOCK_SIZE_FW_DNLD,
+ .tx_buf_size = MWIFIEX_TX_DATA_BUF_SIZE_2K,
 };
 
 static const struct mwifiex_pcie_device mwifiex_pcie8897 = {
  .firmware       = PCIE8897_DEFAULT_FW_NAME,
  .reg            = &mwifiex_reg_8897,
  .blksz_fw_dl = MWIFIEX_PCIE_BLOCK_SIZE_FW_DNLD,
+ .tx_buf_size = MWIFIEX_TX_DATA_BUF_SIZE_4K,
 };
 
 struct mwifiex_evt_buf_desc {
diff --git a/drivers/net/wireless/mwifiex/scan.c b/drivers/net/wireless/mwifiex/scan.c
index 9cf5d8f..45c5b34 100644
--- a/drivers/net/wireless/mwifiex/scan.c
+++ b/drivers/net/wireless/mwifiex/scan.c
@@ -29,9 +29,6 @@
 #define MWIFIEX_MAX_CHANNELS_PER_SPECIFIC_SCAN   14
 
 #define MWIFIEX_DEF_CHANNELS_PER_SCAN_CMD 4
-#define MWIFIEX_LIMIT_1_CHANNEL_PER_SCAN_CMD 15
-#define MWIFIEX_LIMIT_2_CHANNELS_PER_SCAN_CMD 27
-#define MWIFIEX_LIMIT_3_CHANNELS_PER_SCAN_CMD 35
 
 /* Memory needed to store a max sized Channel List TLV for a firmware scan */
 #define CHAN_TLV_MAX_SIZE  (sizeof(struct mwifiex_ie_types_header)         \
@@ -391,6 +388,12 @@ mwifiex_is_network_compatible(struct mwifiex_private *priv,
   return 0;
  }
 
+ if (bss_desc->chan_sw_ie_present) {
+  dev_err(adapter->dev,
+   "Don't connect to AP with WLAN_EID_CHANNEL_SWITCH\n");
+  return -1;
+ }
+
  if (mwifiex_is_bss_wapi(priv, bss_desc)) {
   dev_dbg(adapter->dev, "info: return success for WAPI AP\n");
   return 0;
@@ -509,14 +512,14 @@ mwifiex_scan_create_channel_list(struct mwifiex_private *priv,
     scan_chan_list[chan_idx].max_scan_time =
      cpu_to_le16((u16) user_scan_in->
      chan_list[0].scan_time);
-   else if (ch->flags & IEEE80211_CHAN_PASSIVE_SCAN)
+   else if (ch->flags & IEEE80211_CHAN_NO_IR)
     scan_chan_list[chan_idx].max_scan_time =
      cpu_to_le16(adapter->passive_scan_time);
    else
     scan_chan_list[chan_idx].max_scan_time =
      cpu_to_le16(adapter->active_scan_time);
 
-   if (ch->flags & IEEE80211_CHAN_PASSIVE_SCAN)
+   if (ch->flags & IEEE80211_CHAN_NO_IR)
     scan_chan_list[chan_idx].chan_scan_mode_bitmap
      |= MWIFIEX_PASSIVE_SCAN;
    else
@@ -537,6 +540,37 @@ mwifiex_scan_create_channel_list(struct mwifiex_private *priv,
  return chan_idx;
 }
 
+/* This function appends rate TLV to scan config command. */
+static int
+mwifiex_append_rate_tlv(struct mwifiex_private *priv,
+   struct mwifiex_scan_cmd_config *scan_cfg_out,
+   u8 radio)
+{
+ struct mwifiex_ie_types_rates_param_set *rates_tlv;
+ u8 rates[MWIFIEX_SUPPORTED_RATES], *tlv_pos;
+ u32 rates_size;
+
+ memset(rates, 0, sizeof(rates));
+
+ tlv_pos = (u8 *)scan_cfg_out->tlv_buf + scan_cfg_out->tlv_buf_len;
+
+ if (priv->scan_request)
+  rates_size = mwifiex_get_rates_from_cfg80211(priv, rates,
+            radio);
+ else
+  rates_size = mwifiex_get_supported_rates(priv, rates);
+
+ dev_dbg(priv->adapter->dev, "info: SCAN_CMD: Rates size = %d\n",
+  rates_size);
+ rates_tlv = (struct mwifiex_ie_types_rates_param_set *)tlv_pos;
+ rates_tlv->header.type = cpu_to_le16(WLAN_EID_SUPP_RATES);
+ rates_tlv->header.len = cpu_to_le16((u16) rates_size);
+ memcpy(rates_tlv->rates, rates, rates_size);
+ scan_cfg_out->tlv_buf_len += sizeof(rates_tlv->header) + rates_size;
+
+ return rates_size;
+}
+
 /*
  * This function constructs and sends multiple scan config commands to
  * the firmware.
@@ -554,13 +588,16 @@ mwifiex_scan_channel_list(struct mwifiex_private *priv,
      *chan_tlv_out,
      struct mwifiex_chan_scan_param_set *scan_chan_list)
 {
+ struct mwifiex_adapter *adapter = priv->adapter;
  int ret = 0;
  struct mwifiex_chan_scan_param_set *tmp_chan_list;
  struct mwifiex_chan_scan_param_set *start_chan;
-
- u32 tlv_idx;
+ struct cmd_ctrl_node *cmd_node, *tmp_node;
+ unsigned long flags;
+ u32 tlv_idx, rates_size, cmd_no;
  u32 total_scan_time;
  u32 done_early;
+ u8 radio_type;
 
  if (!scan_cfg_out || !chan_tlv_out || !scan_chan_list) {
   dev_dbg(priv->adapter->dev,
@@ -569,6 +606,9 @@ mwifiex_scan_channel_list(struct mwifiex_private *priv,
   return -1;
  }
 
+ /* Check csa channel expiry before preparing scan list */
+ mwifiex_11h_get_csa_closed_channel(priv);
+
  chan_tlv_out->header.type = cpu_to_le16(TLV_TYPE_CHANLIST);
 
  /* Set the temp channel struct pointer to the start of the desired
@@ -582,6 +622,7 @@ mwifiex_scan_channel_list(struct mwifiex_private *priv,
 
   tlv_idx = 0;
   total_scan_time = 0;
+  radio_type = 0;
   chan_tlv_out->header.len = 0;
   start_chan = tmp_chan_list;
   done_early = false;
@@ -598,6 +639,12 @@ mwifiex_scan_channel_list(struct mwifiex_private *priv,
   while (tlv_idx < max_chan_per_scan &&
          tmp_chan_list->chan_number && !done_early) {
 
+   if (tmp_chan_list->chan_number == priv->csa_chan) {
+    tmp_chan_list++;
+    continue;
+   }
+
+   radio_type = tmp_chan_list->radio_type;
    dev_dbg(priv->adapter->dev,
     "info: Scan: Chan(%3d), Radio(%d),"
     " Mode(%d, %d), Dur(%d)\n",
@@ -678,15 +725,41 @@ mwifiex_scan_channel_list(struct mwifiex_private *priv,
    break;
   }
 
+  rates_size = mwifiex_append_rate_tlv(priv, scan_cfg_out,
+           radio_type);
+
   priv->adapter->scan_channels = start_chan;
 
   /* Send the scan command to the firmware with the specified
      cfg */
-  ret = mwifiex_send_cmd_async(priv, HostCmd_CMD_802_11_SCAN,
-          HostCmd_ACT_GEN_SET, 0,
-          scan_cfg_out);
-  if (ret)
+  if (priv->adapter->ext_scan)
+   cmd_no = HostCmd_CMD_802_11_SCAN_EXT;
+  else
+   cmd_no = HostCmd_CMD_802_11_SCAN;
+
+  ret = mwifiex_send_cmd(priv, cmd_no, HostCmd_ACT_GEN_SET,
+           0, scan_cfg_out, false);
+
+  /* rate IE is updated per scan command but same starting
+   * pointer is used each time so that rate IE from earlier
+   * scan_cfg_out->buf is overwritten with new one.
+   */
+  scan_cfg_out->tlv_buf_len -=
+       sizeof(struct mwifiex_ie_types_header) + rates_size;
+
+  if (ret) {
+   spin_lock_irqsave(&adapter->scan_pending_q_lock, flags);
+   list_for_each_entry_safe(cmd_node, tmp_node,
+       &adapter->scan_pending_q,
+       list) {
+    list_del(&cmd_node->list);
+    cmd_node->wait_q_enabled = false;
+    mwifiex_insert_cmd_to_free_q(adapter, cmd_node);
+   }
+   spin_unlock_irqrestore(&adapter->scan_pending_q_lock,
+            flags);
    break;
+  }
  }
 
  if (ret)
@@ -727,7 +800,7 @@ mwifiex_config_scan(struct mwifiex_private *priv,
  struct mwifiex_adapter *adapter = priv->adapter;
  struct mwifiex_ie_types_num_probes *num_probes_tlv;
  struct mwifiex_ie_types_wildcard_ssid_params *wildcard_ssid_tlv;
- struct mwifiex_ie_types_rates_param_set *rates_tlv;
+ struct mwifiex_ie_types_bssid_list *bssid_tlv;
  u8 *tlv_pos;
  u32 num_probes;
  u32 ssid_len;
@@ -739,8 +812,6 @@ mwifiex_config_scan(struct mwifiex_private *priv,
  u8 radio_type;
  int i;
  u8 ssid_filter;
- u8 rates[MWIFIEX_SUPPORTED_RATES];
- u32 rates_size;
  struct mwifiex_ie_types_htcap *ht_cap;
 
  /* The tlv_buf_len is calculated for each scan command.  The TLVs added
@@ -792,6 +863,17 @@ mwifiex_config_scan(struct mwifiex_private *priv,
          user_scan_in->specific_bssid,
          sizeof(scan_cfg_out->specific_bssid));
 
+  if (adapter->ext_scan &&
+      !is_zero_ether_addr(scan_cfg_out->specific_bssid)) {
+   bssid_tlv =
+    (struct mwifiex_ie_types_bssid_list *)tlv_pos;
+   bssid_tlv->header.type = cpu_to_le16(TLV_TYPE_BSSID);
+   bssid_tlv->header.len = cpu_to_le16(ETH_ALEN);
+   memcpy(bssid_tlv->bssid, user_scan_in->specific_bssid,
+          ETH_ALEN);
+   tlv_pos += sizeof(struct mwifiex_ie_types_bssid_list);
+  }
+
   for (i = 0; i < user_scan_in->num_ssids; i++) {
    ssid_len = user_scan_in->ssid_list[i].ssid_len;
 
@@ -875,19 +957,6 @@ mwifiex_config_scan(struct mwifiex_private *priv,
 
  }
 
- /* Append rates tlv */
- memset(rates, 0, sizeof(rates));
-
- rates_size = mwifiex_get_supported_rates(priv, rates);
-
- rates_tlv = (struct mwifiex_ie_types_rates_param_set *) tlv_pos;
- rates_tlv->header.type = cpu_to_le16(WLAN_EID_SUPP_RATES);
- rates_tlv->header.len = cpu_to_le16((u16) rates_size);
- memcpy(rates_tlv->rates, rates, rates_size);
- tlv_pos += sizeof(rates_tlv->header) + rates_size;
-
- dev_dbg(adapter->dev, "info: SCAN_CMD: Rates size = %d\n", rates_size);
-
  if (ISSUPP_11NENABLED(priv->adapter->fw_cap_info) &&
      (priv->adapter->config_bands & BAND_GN ||
       priv->adapter->config_bands & BAND_AN)) {
@@ -898,7 +967,7 @@ mwifiex_config_scan(struct mwifiex_private *priv,
     cpu_to_le16(sizeof(struct ieee80211_ht_cap));
   radio_type =
    mwifiex_band_to_radio_type(priv->adapter->config_bands);
-  mwifiex_fill_cap_info(priv, radio_type, ht_cap);
+  mwifiex_fill_cap_info(priv, radio_type, &ht_cap->ht_cap);
   tlv_pos += sizeof(struct mwifiex_ie_types_htcap);
  }
 
@@ -983,20 +1052,10 @@ mwifiex_config_scan(struct mwifiex_private *priv,
 
  /*
   * In associated state we will reduce the number of channels scanned per
-  * scan command to avoid any traffic delay/loss. This number is decided
-  * based on total number of channels to be scanned due to constraints
-  * of command buffers.
+  * scan command to 1 to avoid any traffic delay/loss.
   */
- if (priv->media_connected) {
-  if (chan_num < MWIFIEX_LIMIT_1_CHANNEL_PER_SCAN_CMD)
+ if (priv->media_connected)
    *max_chan_per_scan = 1;
-  else if (chan_num < MWIFIEX_LIMIT_2_CHANNELS_PER_SCAN_CMD)
-   *max_chan_per_scan = 2;
-  else if (chan_num < MWIFIEX_LIMIT_3_CHANNELS_PER_SCAN_CMD)
-   *max_chan_per_scan = 3;
-  else
-   *max_chan_per_scan = 4;
- }
 }
 
 /*
@@ -1169,6 +1228,19 @@ int mwifiex_update_bss_desc_with_ie(struct mwifiex_adapter *adapter,
    bss_entry->erp_flags = *(current_ptr + 2);
    break;
 
+  case WLAN_EID_PWR_CONSTRAINT:
+   bss_entry->local_constraint = *(current_ptr + 2);
+   bss_entry->sensed_11h = true;
+   break;
+
+  case WLAN_EID_CHANNEL_SWITCH:
+   bss_entry->chan_sw_ie_present = true;
+  case WLAN_EID_PWR_CAPABILITY:
+  case WLAN_EID_TPC_REPORT:
+  case WLAN_EID_QUIET:
+   bss_entry->sensed_11h = true;
+      break;
+
   case WLAN_EID_EXT_SUPP_RATES:
    /*
     * Only process extended supported rate
@@ -1268,23 +1340,17 @@ int mwifiex_update_bss_desc_with_ie(struct mwifiex_adapter *adapter,
            bss_entry->beacon_buf);
    break;
   case WLAN_EID_BSS_COEX_2040:
-   bss_entry->bcn_bss_co_2040 = current_ptr +
-    sizeof(struct ieee_types_header);
-   bss_entry->bss_co_2040_offset = (u16) (current_ptr +
-     sizeof(struct ieee_types_header) -
-      bss_entry->beacon_buf);
+   bss_entry->bcn_bss_co_2040 = current_ptr;
+   bss_entry->bss_co_2040_offset =
+    (u16) (current_ptr - bss_entry->beacon_buf);
    break;
   case WLAN_EID_EXT_CAPABILITY:
-   bss_entry->bcn_ext_cap = current_ptr +
-    sizeof(struct ieee_types_header);
-   bss_entry->ext_cap_offset = (u16) (current_ptr +
-     sizeof(struct ieee_types_header) -
-     bss_entry->beacon_buf);
+   bss_entry->bcn_ext_cap = current_ptr;
+   bss_entry->ext_cap_offset =
+    (u16) (current_ptr - bss_entry->beacon_buf);
    break;
   case WLAN_EID_OPMODE_NOTIF:
-   bss_entry->oper_mode =
-    (void *)(current_ptr +
-      sizeof(struct ieee_types_header));
+   bss_entry->oper_mode = (void *)current_ptr;
    bss_entry->oper_mode_offset =
      (u16)((u8 *)bss_entry->oper_mode -
            bss_entry->beacon_buf);
@@ -1520,6 +1586,234 @@ done:
  return 0;
 }
 
+static int
+mwifiex_parse_single_response_buf(struct mwifiex_private *priv, u8 **bss_info,
+      u32 *bytes_left, u64 fw_tsf, u8 *radio_type,
+      bool ext_scan, s32 rssi_val)
+{
+ struct mwifiex_adapter *adapter = priv->adapter;
+ struct mwifiex_chan_freq_power *cfp;
+ struct cfg80211_bss *bss;
+ u8 bssid[ETH_ALEN];
+ s32 rssi;
+ const u8 *ie_buf;
+ size_t ie_len;
+ u16 channel = 0;
+ u16 beacon_size = 0;
+ u32 curr_bcn_bytes;
+ u32 freq;
+ u16 beacon_period;
+ u16 cap_info_bitmap;
+ u8 *current_ptr;
+ u64 timestamp;
+ struct mwifiex_fixed_bcn_param *bcn_param;
+ struct mwifiex_bss_priv *bss_priv;
+
+ if (*bytes_left >= sizeof(beacon_size)) {
+  /* Extract & convert beacon size from command buffer */
+  memcpy(&beacon_size, *bss_info, sizeof(beacon_size));
+  *bytes_left -= sizeof(beacon_size);
+  *bss_info += sizeof(beacon_size);
+ }
+
+ if (!beacon_size || beacon_size > *bytes_left) {
+  *bss_info += *bytes_left;
+  *bytes_left = 0;
+  return -EFAULT;
+ }
+
+ /* Initialize the current working beacon pointer for this BSS
+  * iteration
+  */
+ current_ptr = *bss_info;
+
+ /* Advance the return beacon pointer past the current beacon */
+ *bss_info += beacon_size;
+ *bytes_left -= beacon_size;
+
+ curr_bcn_bytes = beacon_size;
+
+ /* First 5 fields are bssid, RSSI(for legacy scan only),
+  * time stamp, beacon interval, and capability information
+  */
+ if (curr_bcn_bytes < ETH_ALEN + sizeof(u8) +
+     sizeof(struct mwifiex_fixed_bcn_param)) {
+  dev_err(adapter->dev, "InterpretIE: not enough bytes left\n");
+  return -EFAULT;
+ }
+
+ memcpy(bssid, current_ptr, ETH_ALEN);
+ current_ptr += ETH_ALEN;
+ curr_bcn_bytes -= ETH_ALEN;
+
+ if (!ext_scan) {
+  rssi = (s32) *current_ptr;
+  rssi = (-rssi) * 100;  /* Convert dBm to mBm */
+  current_ptr += sizeof(u8);
+  curr_bcn_bytes -= sizeof(u8);
+  dev_dbg(adapter->dev, "info: InterpretIE: RSSI=%d\n", rssi);
+ } else {
+  rssi = rssi_val;
+ }
+
+ bcn_param = (struct mwifiex_fixed_bcn_param *)current_ptr;
+ current_ptr += sizeof(*bcn_param);
+ curr_bcn_bytes -= sizeof(*bcn_param);
+
+ timestamp = le64_to_cpu(bcn_param->timestamp);
+ beacon_period = le16_to_cpu(bcn_param->beacon_period);
+
+ cap_info_bitmap = le16_to_cpu(bcn_param->cap_info_bitmap);
+ dev_dbg(adapter->dev, "info: InterpretIE: capabilities=0x%X\n",
+  cap_info_bitmap);
+
+ /* Rest of the current buffer are IE's */
+ ie_buf = current_ptr;
+ ie_len = curr_bcn_bytes;
+ dev_dbg(adapter->dev, "info: InterpretIE: IELength for this AP = %d\n",
+  curr_bcn_bytes);
+
+ while (curr_bcn_bytes >= sizeof(struct ieee_types_header)) {
+  u8 element_id, element_len;
+
+  element_id = *current_ptr;
+  element_len = *(current_ptr + 1);
+  if (curr_bcn_bytes < element_len +
+    sizeof(struct ieee_types_header)) {
+   dev_err(adapter->dev,
+    "%s: bytes left < IE length\n", __func__);
+   return -EFAULT;
+  }
+  if (element_id == WLAN_EID_DS_PARAMS) {
+   channel = *(current_ptr +
+        sizeof(struct ieee_types_header));
+   break;
+  }
+
+  current_ptr += element_len + sizeof(struct ieee_types_header);
+  curr_bcn_bytes -= element_len +
+     sizeof(struct ieee_types_header);
+ }
+
+ if (channel) {
+  struct ieee80211_channel *chan;
+  u8 band;
+
+  /* Skip entry if on csa closed channel */
+  if (channel == priv->csa_chan) {
+   dev_dbg(adapter->dev,
+    "Dropping entry on csa closed channel\n");
+   return 0;
+  }
+
+  band = BAND_G;
+  if (radio_type)
+   band = mwifiex_radio_type_to_band(*radio_type &
+         (BIT(0) | BIT(1)));
+
+  cfp = mwifiex_get_cfp(priv, band, channel, 0);
+
+  freq = cfp ? cfp->freq : 0;
+
+  chan = ieee80211_get_channel(priv->wdev->wiphy, freq);
+
+  if (chan && !(chan->flags & IEEE80211_CHAN_DISABLED)) {
+   bss = cfg80211_inform_bss(priv->wdev->wiphy,
+         chan, bssid, timestamp,
+         cap_info_bitmap, beacon_period,
+         ie_buf, ie_len, rssi, GFP_KERNEL);
+   bss_priv = (struct mwifiex_bss_priv *)bss->priv;
+   bss_priv->band = band;
+   bss_priv->fw_tsf = fw_tsf;
+   if (priv->media_connected &&
+       !memcmp(bssid, priv->curr_bss_params.bss_descriptor
+        .mac_address, ETH_ALEN))
+    mwifiex_update_curr_bss_params(priv, bss);
+   cfg80211_put_bss(priv->wdev->wiphy, bss);
+  }
+ } else {
+  dev_dbg(adapter->dev, "missing BSS channel IE\n");
+ }
+
+ return 0;
+}
+
+static void mwifiex_complete_scan(struct mwifiex_private *priv)
+{
+ struct mwifiex_adapter *adapter = priv->adapter;
+
+ if (adapter->curr_cmd->wait_q_enabled) {
+  adapter->cmd_wait_q.status = 0;
+  if (!priv->scan_request) {
+   dev_dbg(adapter->dev, "complete internal scan\n");
+   mwifiex_complete_cmd(adapter, adapter->curr_cmd);
+  }
+ }
+}
+
+static void mwifiex_check_next_scan_command(struct mwifiex_private *priv)
+{
+ struct mwifiex_adapter *adapter = priv->adapter;
+ struct cmd_ctrl_node *cmd_node;
+ unsigned long flags;
+
+ spin_lock_irqsave(&adapter->scan_pending_q_lock, flags);
+ if (list_empty(&adapter->scan_pending_q)) {
+  spin_unlock_irqrestore(&adapter->scan_pending_q_lock, flags);
+  spin_lock_irqsave(&adapter->mwifiex_cmd_lock, flags);
+  adapter->scan_processing = false;
+  spin_unlock_irqrestore(&adapter->mwifiex_cmd_lock, flags);
+
+  if (!adapter->ext_scan)
+   mwifiex_complete_scan(priv);
+
+  if (priv->report_scan_result)
+   priv->report_scan_result = false;
+
+  if (priv->scan_request) {
+   dev_dbg(adapter->dev, "info: notifying scan done\n");
+   cfg80211_scan_done(priv->scan_request, 0);
+   priv->scan_request = NULL;
+  } else {
+   priv->scan_aborting = false;
+   dev_dbg(adapter->dev, "info: scan already aborted\n");
+  }
+ } else {
+  if ((priv->scan_aborting && !priv->scan_request) ||
+      priv->scan_block) {
+   spin_unlock_irqrestore(&adapter->scan_pending_q_lock,
+            flags);
+   adapter->scan_delay_cnt = MWIFIEX_MAX_SCAN_DELAY_CNT;
+   mod_timer(&priv->scan_delay_timer, jiffies);
+   dev_dbg(priv->adapter->dev,
+    "info: %s: triggerring scan abort\n", __func__);
+  } else if (!mwifiex_wmm_lists_empty(adapter) &&
+      (priv->scan_request && (priv->scan_request->flags &
+         NL80211_SCAN_FLAG_LOW_PRIORITY))) {
+   spin_unlock_irqrestore(&adapter->scan_pending_q_lock,
+            flags);
+   adapter->scan_delay_cnt = 1;
+   mod_timer(&priv->scan_delay_timer, jiffies +
+      msecs_to_jiffies(MWIFIEX_SCAN_DELAY_MSEC));
+   dev_dbg(priv->adapter->dev,
+    "info: %s: deferring scan\n", __func__);
+  } else {
+   /* Get scan command from scan_pending_q and put to
+    * cmd_pending_q
+    */
+   cmd_node = list_first_entry(&adapter->scan_pending_q,
+          struct cmd_ctrl_node, list);
+   list_del(&cmd_node->list);
+   spin_unlock_irqrestore(&adapter->scan_pending_q_lock,
+            flags);
+   mwifiex_insert_cmd_to_pending_q(adapter, cmd_node,
+       true);
+  }
+ }
+
+ return;
+}
+
 /*
  * This function handles the command response of scan.
  *
@@ -1544,7 +1838,6 @@ int mwifiex_ret_802_11_scan(struct mwifiex_private *priv,
 {
  int ret = 0;
  struct mwifiex_adapter *adapter = priv->adapter;
- struct cmd_ctrl_node *cmd_node;
  struct host_cmd_ds_802_11_scan_rsp *scan_rsp;
  struct mwifiex_ie_types_data *tlv_data;
  struct mwifiex_ie_types_tsf_timestamp *tsf_tlv;
@@ -1553,12 +1846,11 @@ int mwifiex_ret_802_11_scan(struct mwifiex_private *priv,
  u32 bytes_left;
  u32 idx;
  u32 tlv_buf_size;
- struct mwifiex_chan_freq_power *cfp;
  struct mwifiex_ie_types_chan_band_list_param_set *chan_band_tlv;
  struct chan_band_param_set *chan_band;
  u8 is_bgscan_resp;
- unsigned long flags;
- struct cfg80211_bss *bss;
+ __le64 fw_tsf = 0;
+ u8 *radio_type;
 
  is_bgscan_resp = (le16_to_cpu(resp->command)
      == HostCmd_CMD_802_11_BG_SCAN_QUERY);
@@ -1575,6 +1867,9 @@ int mwifiex_ret_802_11_scan(struct mwifiex_private *priv,
   goto check_next_scan;
  }
 
+ /* Check csa channel expiry before parsing scan response */
+ mwifiex_11h_get_csa_closed_channel(priv);
+
  bytes_left = le16_to_cpu(scan_rsp->bss_descript_size);
  dev_dbg(adapter->dev, "info: SCAN_RESP: bss_descript_size %d\n",
   bytes_left);
@@ -1617,218 +1912,197 @@ int mwifiex_ret_802_11_scan(struct mwifiex_private *priv,
           &chan_band_tlv);
 
  for (idx = 0; idx < scan_rsp->number_of_sets && bytes_left; idx++) {
-  u8 bssid[ETH_ALEN];
-  s32 rssi;
-  const u8 *ie_buf;
-  size_t ie_len;
-  u16 channel = 0;
-  u64 fw_tsf = 0;
-  u16 beacon_size = 0;
-  u32 curr_bcn_bytes;
-  u32 freq;
-  u16 beacon_period;
-  u16 cap_info_bitmap;
-  u8 *current_ptr;
-  u64 timestamp;
-  struct mwifiex_bcn_param *bcn_param;
-  struct mwifiex_bss_priv *bss_priv;
-
-  if (bytes_left >= sizeof(beacon_size)) {
-   /* Extract & convert beacon size from command buffer */
-   memcpy(&beacon_size, bss_info, sizeof(beacon_size));
-   bytes_left -= sizeof(beacon_size);
-   bss_info += sizeof(beacon_size);
+  /*
+   * If the TSF TLV was appended to the scan results, save this
+   * entry's TSF value in the fw_tsf field. It is the firmware's
+   * TSF value at the time the beacon or probe response was
+   * received.
+   */
+  if (tsf_tlv)
+   memcpy(&fw_tsf, &tsf_tlv->tsf_data[idx * TSF_DATA_SIZE],
+          sizeof(fw_tsf));
+
+  if (chan_band_tlv) {
+   chan_band = &chan_band_tlv->chan_band_param[idx];
+   radio_type = &chan_band->radio_type;
+  } else {
+   radio_type = NULL;
   }
 
-  if (!beacon_size || beacon_size > bytes_left) {
-   bss_info += bytes_left;
-   bytes_left = 0;
-   ret = -1;
+  ret = mwifiex_parse_single_response_buf(priv, &bss_info,
+       &bytes_left,
+       le64_to_cpu(fw_tsf),
+       radio_type, false, 0);
+  if (ret)
    goto check_next_scan;
-  }
+ }
 
-  /* Initialize the current working beacon pointer for this BSS
-   * iteration */
-  current_ptr = bss_info;
+check_next_scan:
+ mwifiex_check_next_scan_command(priv);
+ return ret;
+}
 
-  /* Advance the return beacon pointer past the current beacon */
-  bss_info += beacon_size;
-  bytes_left -= beacon_size;
+/*
+ * This function prepares an extended scan command to be sent to the firmware
+ *
+ * This uses the scan command configuration sent to the command processing
+ * module in command preparation stage to configure a extended scan command
+ * structure to send to firmware.
+ */
+int mwifiex_cmd_802_11_scan_ext(struct mwifiex_private *priv,
+    struct host_cmd_ds_command *cmd,
+    void *data_buf)
+{
+ struct host_cmd_ds_802_11_scan_ext *ext_scan = &cmd->params.ext_scan;
+ struct mwifiex_scan_cmd_config *scan_cfg = data_buf;
 
-  curr_bcn_bytes = beacon_size;
+ memcpy(ext_scan->tlv_buffer, scan_cfg->tlv_buf, scan_cfg->tlv_buf_len);
 
-  /*
-   * First 5 fields are bssid, RSSI, time stamp, beacon interval,
-   *   and capability information
-   */
-  if (curr_bcn_bytes < sizeof(struct mwifiex_bcn_param)) {
-   dev_err(adapter->dev,
-    "InterpretIE: not enough bytes left\n");
-   continue;
-  }
-  bcn_param = (struct mwifiex_bcn_param *)current_ptr;
-  current_ptr += sizeof(*bcn_param);
-  curr_bcn_bytes -= sizeof(*bcn_param);
+ cmd->command = cpu_to_le16(HostCmd_CMD_802_11_SCAN_EXT);
 
-  memcpy(bssid, bcn_param->bssid, ETH_ALEN);
+ /* Size is equal to the sizeof(fixed portions) + the TLV len + header */
+ cmd->size = cpu_to_le16((u16)(sizeof(ext_scan->reserved)
+          + scan_cfg->tlv_buf_len + S_DS_GEN));
 
-  rssi = (s32) bcn_param->rssi;
-  rssi = (-rssi) * 100;  /* Convert dBm to mBm */
-  dev_dbg(adapter->dev, "info: InterpretIE: RSSI=%d\n", rssi);
+ return 0;
+}
 
-  timestamp = le64_to_cpu(bcn_param->timestamp);
-  beacon_period = le16_to_cpu(bcn_param->beacon_period);
+/* This function handles the command response of extended scan */
+int mwifiex_ret_802_11_scan_ext(struct mwifiex_private *priv)
+{
+ dev_dbg(priv->adapter->dev, "info: EXT scan returns successfully\n");
 
-  cap_info_bitmap = le16_to_cpu(bcn_param->cap_info_bitmap);
-  dev_dbg(adapter->dev, "info: InterpretIE: capabilities=0x%X\n",
-   cap_info_bitmap);
+ mwifiex_complete_scan(priv);
 
-  /* Rest of the current buffer are IE's */
-  ie_buf = current_ptr;
-  ie_len = curr_bcn_bytes;
-  dev_dbg(adapter->dev,
-   "info: InterpretIE: IELength for this AP = %d\n",
-   curr_bcn_bytes);
+ return 0;
+}
 
-  while (curr_bcn_bytes >= sizeof(struct ieee_types_header)) {
-   u8 element_id, element_len;
+/* This function This function handles the event extended scan report. It
+ * parses extended scan results and informs to cfg80211 stack.
+ */
+int mwifiex_handle_event_ext_scan_report(struct mwifiex_private *priv,
+      void *buf)
+{
+ int ret = 0;
+ struct mwifiex_adapter *adapter = priv->adapter;
+ u8 *bss_info;
+ u32 bytes_left, bytes_left_for_tlv, idx;
+ u16 type, len;
+ struct mwifiex_ie_types_data *tlv;
+ struct mwifiex_ie_types_bss_scan_rsp *scan_rsp_tlv;
+ struct mwifiex_ie_types_bss_scan_info *scan_info_tlv;
+ u8 *radio_type;
+ u64 fw_tsf = 0;
+ s32 rssi = 0;
+ struct mwifiex_event_scan_result *event_scan = buf;
+ u8 num_of_set = event_scan->num_of_set;
+ u8 *scan_resp = buf + sizeof(struct mwifiex_event_scan_result);
+ u16 scan_resp_size = le16_to_cpu(event_scan->buf_size);
+
+ if (num_of_set > MWIFIEX_MAX_AP) {
+  dev_err(adapter->dev,
+   "EXT_SCAN: Invalid number of AP returned (%d)!!\n",
+   num_of_set);
+  ret = -1;
+  goto check_next_scan;
+ }
 
-   element_id = *current_ptr;
-   element_len = *(current_ptr + 1);
-   if (curr_bcn_bytes < element_len +
-     sizeof(struct ieee_types_header)) {
-    dev_err(priv->adapter->dev,
-     "%s: bytes left < IE length\n",
-     __func__);
-    goto check_next_scan;
-   }
-   if (element_id == WLAN_EID_DS_PARAMS) {
-    channel = *(current_ptr + sizeof(struct ieee_types_header));
-    break;
-   }
+ bytes_left = scan_resp_size;
+ dev_dbg(adapter->dev,
+  "EXT_SCAN: size %d, returned %d APs...",
+  scan_resp_size, num_of_set);
 
-   current_ptr += element_len +
-     sizeof(struct ieee_types_header);
-   curr_bcn_bytes -= element_len +
-     sizeof(struct ieee_types_header);
+ tlv = (struct mwifiex_ie_types_data *)scan_resp;
+
+ for (idx = 0; idx < num_of_set && bytes_left; idx++) {
+  type = le16_to_cpu(tlv->header.type);
+  len = le16_to_cpu(tlv->header.len);
+  if (bytes_left < sizeof(struct mwifiex_ie_types_header) + len) {
+   dev_err(adapter->dev, "EXT_SCAN: Error bytes left < TLV length\n");
+   break;
   }
+  scan_rsp_tlv = NULL;
+  scan_info_tlv = NULL;
+  bytes_left_for_tlv = bytes_left;
 
-  /*
-   * If the TSF TLV was appended to the scan results, save this
-   * entry's TSF value in the fw_tsf field. It is the firmware's
-   * TSF value at the time the beacon or probe response was
-   * received.
+  /* BSS response TLV with beacon or probe response buffer
+   * at the initial position of each descriptor
    */
-  if (tsf_tlv)
-   memcpy(&fw_tsf, &tsf_tlv->tsf_data[idx * TSF_DATA_SIZE],
-          sizeof(fw_tsf));
+  if (type != TLV_TYPE_BSS_SCAN_RSP)
+   break;
 
-  if (channel) {
-   struct ieee80211_channel *chan;
-   u8 band;
-
-   band = BAND_G;
-   if (chan_band_tlv) {
-    chan_band =
-     &chan_band_tlv->chan_band_param[idx];
-    band = mwifiex_radio_type_to_band(
-      chan_band->radio_type
-      & (BIT(0) | BIT(1)));
+  bss_info = (u8 *)tlv;
+  scan_rsp_tlv = (struct mwifiex_ie_types_bss_scan_rsp *)tlv;
+  tlv = (struct mwifiex_ie_types_data *)(tlv->data + len);
+  bytes_left_for_tlv -=
+    (len + sizeof(struct mwifiex_ie_types_header));
+
+  while (bytes_left_for_tlv >=
+         sizeof(struct mwifiex_ie_types_header) &&
+         le16_to_cpu(tlv->header.type) != TLV_TYPE_BSS_SCAN_RSP) {
+   type = le16_to_cpu(tlv->header.type);
+   len = le16_to_cpu(tlv->header.len);
+   if (bytes_left_for_tlv <
+       sizeof(struct mwifiex_ie_types_header) + len) {
+    dev_err(adapter->dev,
+     "EXT_SCAN: Error in processing TLV, bytes left < TLV length\n");
+    scan_rsp_tlv = NULL;
+    bytes_left_for_tlv = 0;
+    continue;
    }
-
-   cfp = mwifiex_get_cfp(priv, band, channel, 0);
-
-   freq = cfp ? cfp->freq : 0;
-
-   chan = ieee80211_get_channel(priv->wdev->wiphy, freq);
-
-   if (chan && !(chan->flags & IEEE80211_CHAN_DISABLED)) {
-    bss = cfg80211_inform_bss(priv->wdev->wiphy,
-           chan, bssid, timestamp,
-           cap_info_bitmap, beacon_period,
-           ie_buf, ie_len, rssi, GFP_KERNEL);
-    bss_priv = (struct mwifiex_bss_priv *)bss->priv;
-    bss_priv->band = band;
-    bss_priv->fw_tsf = fw_tsf;
-    if (priv->media_connected &&
-        !memcmp(bssid,
-         priv->curr_bss_params.bss_descriptor
-         .mac_address, ETH_ALEN))
-     mwifiex_update_curr_bss_params(priv,
-               bss);
-    cfg80211_put_bss(priv->wdev->wiphy, bss);
+   switch (type) {
+   case TLV_TYPE_BSS_SCAN_INFO:
+    scan_info_tlv =
+      (struct mwifiex_ie_types_bss_scan_info *)tlv;
+    if (len !=
+     sizeof(struct mwifiex_ie_types_bss_scan_info) -
+     sizeof(struct mwifiex_ie_types_header)) {
+     bytes_left_for_tlv = 0;
+     continue;
+    }
+    break;
+   default:
+    break;
    }
-  } else {
-   dev_dbg(adapter->dev, "missing BSS channel IE\n");
+   tlv = (struct mwifiex_ie_types_data *)(tlv->data + len);
+   bytes_left -=
+    (len + sizeof(struct mwifiex_ie_types_header));
+   bytes_left_for_tlv -=
+    (len + sizeof(struct mwifiex_ie_types_header));
   }
- }
-
-check_next_scan:
- spin_lock_irqsave(&adapter->scan_pending_q_lock, flags);
- if (list_empty(&adapter->scan_pending_q)) {
-  spin_unlock_irqrestore(&adapter->scan_pending_q_lock, flags);
-  spin_lock_irqsave(&adapter->mwifiex_cmd_lock, flags);
-  adapter->scan_processing = false;
-  spin_unlock_irqrestore(&adapter->mwifiex_cmd_lock, flags);
 
-  /* Need to indicate IOCTL complete */
-  if (adapter->curr_cmd->wait_q_enabled) {
-   adapter->cmd_wait_q.status = 0;
-   if (!priv->scan_request) {
-    dev_dbg(adapter->dev,
-     "complete internal scan\n");
-    mwifiex_complete_cmd(adapter,
-           adapter->curr_cmd);
-   }
-  }
-  if (priv->report_scan_result)
-   priv->report_scan_result = false;
+  if (!scan_rsp_tlv)
+   break;
 
-  if (priv->user_scan_cfg) {
-   if (priv->scan_request) {
-    dev_dbg(priv->adapter->dev,
-     "info: notifying scan done\n");
-    cfg80211_scan_done(priv->scan_request, 0);
-    priv->scan_request = NULL;
-   } else {
-    dev_dbg(priv->adapter->dev,
-     "info: scan already aborted\n");
-   }
+  /* Advance pointer to the beacon buffer length and
+   * update the bytes count so that the function
+   * wlan_interpret_bss_desc_with_ie() can handle the
+   * scan buffer withut any change
+   */
+  bss_info += sizeof(u16);
+  bytes_left -= sizeof(u16);
 
-   kfree(priv->user_scan_cfg);
-   priv->user_scan_cfg = NULL;
-  }
- } else {
-  if (priv->user_scan_cfg && !priv->scan_request) {
-   spin_unlock_irqrestore(&adapter->scan_pending_q_lock,
-            flags);
-   adapter->scan_delay_cnt = MWIFIEX_MAX_SCAN_DELAY_CNT;
-   mod_timer(&priv->scan_delay_timer, jiffies);
-   dev_dbg(priv->adapter->dev,
-    "info: %s: triggerring scan abort\n", __func__);
-  } else if (!mwifiex_wmm_lists_empty(adapter) &&
-      (priv->scan_request && (priv->scan_request->flags &
-         NL80211_SCAN_FLAG_LOW_PRIORITY))) {
-   spin_unlock_irqrestore(&adapter->scan_pending_q_lock,
-            flags);
-   adapter->scan_delay_cnt = 1;
-   mod_timer(&priv->scan_delay_timer, jiffies +
-      msecs_to_jiffies(MWIFIEX_SCAN_DELAY_MSEC));
-   dev_dbg(priv->adapter->dev,
-    "info: %s: deferring scan\n", __func__);
+  if (scan_info_tlv) {
+   rssi = (s32)(s16)(le16_to_cpu(scan_info_tlv->rssi));
+   rssi *= 100;           /* Convert dBm to mBm */
+   dev_dbg(adapter->dev,
+    "info: InterpretIE: RSSI=%d\n", rssi);
+   fw_tsf = le64_to_cpu(scan_info_tlv->tsf);
+   radio_type = &scan_info_tlv->radio_type;
   } else {
-   /* Get scan command from scan_pending_q and put to
-      cmd_pending_q */
-   cmd_node = list_first_entry(&adapter->scan_pending_q,
-          struct cmd_ctrl_node, list);
-   list_del(&cmd_node->list);
-   spin_unlock_irqrestore(&adapter->scan_pending_q_lock,
-            flags);
-   mwifiex_insert_cmd_to_pending_q(adapter, cmd_node,
-       true);
+   radio_type = NULL;
   }
+  ret = mwifiex_parse_single_response_buf(priv, &bss_info,
+       &bytes_left, fw_tsf,
+       radio_type, true, rssi);
+  if (ret)
+   goto check_next_scan;
  }
 
+check_next_scan:
+ if (!event_scan->more_event)
+  mwifiex_check_next_scan_command(priv);
+
  return ret;
 }
 
@@ -2040,12 +2314,12 @@ mwifiex_save_curr_bcn(struct mwifiex_private *priv)
     curr_bss->ht_info_offset);
 
  if (curr_bss->bcn_vht_cap)
-  curr_bss->bcn_ht_cap = (void *)(curr_bss->beacon_buf +
-      curr_bss->vht_cap_offset);
+  curr_bss->bcn_vht_cap = (void *)(curr_bss->beacon_buf +
+       curr_bss->vht_cap_offset);
 
  if (curr_bss->bcn_vht_oper)
-  curr_bss->bcn_ht_oper = (void *)(curr_bss->beacon_buf +
-       curr_bss->vht_info_offset);
+  curr_bss->bcn_vht_oper = (void *)(curr_bss->beacon_buf +
+        curr_bss->vht_info_offset);
 
  if (curr_bss->bcn_bss_co_2040)
   curr_bss->bcn_bss_co_2040 =
diff --git a/drivers/net/wireless/mwifiex/sdio.c b/drivers/net/wireless/mwifiex/sdio.c
index 047a6f3..4ce3d7b 100644
--- a/drivers/net/wireless/mwifiex/sdio.c
+++ b/drivers/net/wireless/mwifiex/sdio.c
@@ -50,8 +50,6 @@ static struct mwifiex_if_ops sdio_ops;
 
 static struct semaphore add_remove_card_sem;
 
-static int mwifiex_sdio_resume(struct device *dev);
-
 /*
  * SDIO probe.
  *
@@ -77,6 +75,20 @@ mwifiex_sdio_probe(struct sdio_func *func, const struct sdio_device_id *id)
 
  func->card->quirks |= MMC_QUIRK_BLKSZ_FOR_BYTE_MODE;
 
+ if (id->driver_data) {
+  struct mwifiex_sdio_device *data = (void *)id->driver_data;
+
+  card->firmware = data->firmware;
+  card->reg = data->reg;
+  card->max_ports = data->max_ports;
+  card->mp_agg_pkt_limit = data->mp_agg_pkt_limit;
+  card->supports_sdio_new_mode = data->supports_sdio_new_mode;
+  card->has_control_mask = data->has_control_mask;
+  card->tx_buf_size = data->tx_buf_size;
+  card->mp_tx_agg_buf_size = data->mp_tx_agg_buf_size;
+  card->mp_rx_agg_buf_size = data->mp_rx_agg_buf_size;
+ }
+
  sdio_claim_host(func);
  ret = sdio_enable_func(func);
  sdio_release_host(func);
@@ -101,6 +113,51 @@ mwifiex_sdio_probe(struct sdio_func *func, const struct sdio_device_id *id)
 }
 
 /*
+ * SDIO resume.
+ *
+ * Kernel needs to suspend all functions separately. Therefore all
+ * registered functions must have drivers with suspend and resume
+ * methods. Failing that the kernel simply removes the whole card.
+ *
+ * If already not resumed, this function turns on the traffic and
+ * sends a host sleep cancel request to the firmware.
+ */
+static int mwifiex_sdio_resume(struct device *dev)
+{
+ struct sdio_func *func = dev_to_sdio_func(dev);
+ struct sdio_mmc_card *card;
+ struct mwifiex_adapter *adapter;
+ mmc_pm_flag_t pm_flag = 0;
+
+ if (func) {
+  pm_flag = sdio_get_host_pm_caps(func);
+  card = sdio_get_drvdata(func);
+  if (!card || !card->adapter) {
+   pr_err("resume: invalid card or adapter\n");
+   return 0;
+  }
+ } else {
+  pr_err("resume: sdio_func is not specified\n");
+  return 0;
+ }
+
+ adapter = card->adapter;
+
+ if (!adapter->is_suspended) {
+  dev_warn(adapter->dev, "device already resumed\n");
+  return 0;
+ }
+
+ adapter->is_suspended = false;
+
+ /* Disable Host Sleep */
+ mwifiex_cancel_hs(mwifiex_get_priv(adapter, MWIFIEX_BSS_ROLE_STA),
+     MWIFIEX_ASYNC_CMD);
+
+ return 0;
+}
+
+/*
  * SDIO remove.
  *
  * This function removes the interface and frees up the card structure.
@@ -111,7 +168,6 @@ mwifiex_sdio_remove(struct sdio_func *func)
  struct sdio_mmc_card *card;
  struct mwifiex_adapter *adapter;
  struct mwifiex_private *priv;
- int i;
 
  pr_debug("info: SDIO func num=%d\n", func->num);
 
@@ -123,18 +179,11 @@ mwifiex_sdio_remove(struct sdio_func *func)
  if (!adapter || !adapter->priv_num)
   return;
 
- /* In case driver is removed when asynchronous FW load is in progress */
- wait_for_completion(&adapter->fw_load);
-
  if (user_rmmod) {
   if (adapter->is_suspended)
    mwifiex_sdio_resume(adapter->dev);
 
-  for (i = 0; i < adapter->priv_num; i++)
-   if ((GET_BSS_ROLE(adapter->priv[i]) ==
-      MWIFIEX_BSS_ROLE_STA) &&
-       adapter->priv[i]->media_connected)
-    mwifiex_deauthenticate(adapter->priv[i], NULL);
+  mwifiex_deauthenticate_all(adapter);
 
   priv = mwifiex_get_priv(adapter, MWIFIEX_BSS_ROLE_ANY);
   mwifiex_disable_auto_ds(priv);
@@ -142,7 +191,6 @@ mwifiex_sdio_remove(struct sdio_func *func)
  }
 
  mwifiex_remove_card(card->adapter, &add_remove_card_sem);
- kfree(card);
 }
 
 /*
@@ -188,6 +236,7 @@ static int mwifiex_sdio_suspend(struct device *dev)
  /* Enable the Host Sleep */
  if (!mwifiex_enable_hs(adapter)) {
   dev_err(adapter->dev, "cmd: failed to suspend\n");
+  adapter->hs_enabling = false;
   return -EFAULT;
  }
 
@@ -196,67 +245,30 @@ static int mwifiex_sdio_suspend(struct device *dev)
 
  /* Indicate device suspended */
  adapter->is_suspended = true;
+ adapter->hs_enabling = false;
 
  return ret;
 }
 
-/*
- * SDIO resume.
- *
- * Kernel needs to suspend all functions separately. Therefore all
- * registered functions must have drivers with suspend and resume
- * methods. Failing that the kernel simply removes the whole card.
- *
- * If already not resumed, this function turns on the traffic and
- * sends a host sleep cancel request to the firmware.
- */
-static int mwifiex_sdio_resume(struct device *dev)
-{
- struct sdio_func *func = dev_to_sdio_func(dev);
- struct sdio_mmc_card *card;
- struct mwifiex_adapter *adapter;
- mmc_pm_flag_t pm_flag = 0;
-
- if (func) {
-  pm_flag = sdio_get_host_pm_caps(func);
-  card = sdio_get_drvdata(func);
-  if (!card || !card->adapter) {
-   pr_err("resume: invalid card or adapter\n");
-   return 0;
-  }
- } else {
-  pr_err("resume: sdio_func is not specified\n");
-  return 0;
- }
-
- adapter = card->adapter;
-
- if (!adapter->is_suspended) {
-  dev_warn(adapter->dev, "device already resumed\n");
-  return 0;
- }
-
- adapter->is_suspended = false;
-
- /* Disable Host Sleep */
- mwifiex_cancel_hs(mwifiex_get_priv(adapter, MWIFIEX_BSS_ROLE_STA),
-     MWIFIEX_ASYNC_CMD);
-
- return 0;
-}
-
 /* Device ID for SD8786 */
 #define SDIO_DEVICE_ID_MARVELL_8786   (0x9116)
 /* Device ID for SD8787 */
 #define SDIO_DEVICE_ID_MARVELL_8787   (0x9119)
 /* Device ID for SD8797 */
 #define SDIO_DEVICE_ID_MARVELL_8797   (0x9129)
+/* Device ID for SD8897 */
+#define SDIO_DEVICE_ID_MARVELL_8897   (0x912d)
 
 /* WLAN IDs */
 static const struct sdio_device_id mwifiex_ids[] = {
- {SDIO_DEVICE(SDIO_VENDOR_ID_MARVELL, SDIO_DEVICE_ID_MARVELL_8786)},
- {SDIO_DEVICE(SDIO_VENDOR_ID_MARVELL, SDIO_DEVICE_ID_MARVELL_8787)},
- {SDIO_DEVICE(SDIO_VENDOR_ID_MARVELL, SDIO_DEVICE_ID_MARVELL_8797)},
+ {SDIO_DEVICE(SDIO_VENDOR_ID_MARVELL, SDIO_DEVICE_ID_MARVELL_8786),
+  .driver_data = (unsigned long) &mwifiex_sdio_sd8786},
+ {SDIO_DEVICE(SDIO_VENDOR_ID_MARVELL, SDIO_DEVICE_ID_MARVELL_8787),
+  .driver_data = (unsigned long) &mwifiex_sdio_sd8787},
+ {SDIO_DEVICE(SDIO_VENDOR_ID_MARVELL, SDIO_DEVICE_ID_MARVELL_8797),
+  .driver_data = (unsigned long) &mwifiex_sdio_sd8797},
+ {SDIO_DEVICE(SDIO_VENDOR_ID_MARVELL, SDIO_DEVICE_ID_MARVELL_8897),
+  .driver_data = (unsigned long) &mwifiex_sdio_sd8897},
  {},
 };
 
@@ -278,17 +290,26 @@ static struct sdio_driver mwifiex_sdio = {
  }
 };
 
+/* Write data into SDIO card register. Caller claims SDIO device. */
+static int
+mwifiex_write_reg_locked(struct sdio_func *func, u32 reg, u8 data)
+{
+ int ret = -1;
+ sdio_writeb(func, data, reg, &ret);
+ return ret;
+}
+
 /*
  * This function writes data into SDIO card register.
  */
 static int
-mwifiex_write_reg(struct mwifiex_adapter *adapter, u32 reg, u32 data)
+mwifiex_write_reg(struct mwifiex_adapter *adapter, u32 reg, u8 data)
 {
  struct sdio_mmc_card *card = adapter->card;
- int ret = -1;
+ int ret;
 
  sdio_claim_host(card->func);
- sdio_writeb(card->func, (u8) data, reg, &ret);
+ ret = mwifiex_write_reg_locked(card->func, reg, data);
  sdio_release_host(card->func);
 
  return ret;
@@ -298,7 +319,7 @@ mwifiex_write_reg(struct mwifiex_adapter *adapter, u32 reg, u32 data)
  * This function reads data from SDIO card register.
  */
 static int
-mwifiex_read_reg(struct mwifiex_adapter *adapter, u32 reg, u32 *data)
+mwifiex_read_reg(struct mwifiex_adapter *adapter, u32 reg, u8 *data)
 {
  struct sdio_mmc_card *card = adapter->card;
  int ret = -1;
@@ -400,7 +421,40 @@ static int mwifiex_pm_wakeup_card_complete(struct mwifiex_adapter *adapter)
 }
 
 /*
- * This function initializes the IO ports.
+ * This function is used to initialize IO ports for the
+ * chipsets supporting SDIO new mode eg SD8897.
+ */
+static int mwifiex_init_sdio_new_mode(struct mwifiex_adapter *adapter)
+{
+ u8 reg;
+
+ adapter->ioport = MEM_PORT;
+
+ /* enable sdio new mode */
+ if (mwifiex_read_reg(adapter, CARD_CONFIG_2_1_REG, &reg))
+  return -1;
+ if (mwifiex_write_reg(adapter, CARD_CONFIG_2_1_REG,
+         reg | CMD53_NEW_MODE))
+  return -1;
+
+ /* Configure cmd port and enable reading rx length from the register */
+ if (mwifiex_read_reg(adapter, CMD_CONFIG_0, &reg))
+  return -1;
+ if (mwifiex_write_reg(adapter, CMD_CONFIG_0, reg | CMD_PORT_RD_LEN_EN))
+  return -1;
+
+ /* Enable Dnld/Upld ready auto reset for cmd port after cmd53 is
+  * completed
+  */
+ if (mwifiex_read_reg(adapter, CMD_CONFIG_1, &reg))
+  return -1;
+ if (mwifiex_write_reg(adapter, CMD_CONFIG_1, reg | CMD_PORT_AUTO_EN))
+  return -1;
+
+ return 0;
+}
+
+/* This function initializes the IO ports.
  *
  * The following operations are performed -
  *      - Read the IO ports (0, 1 and 2)
@@ -409,10 +463,17 @@ static int mwifiex_pm_wakeup_card_complete(struct mwifiex_adapter *adapter)
  */
 static int mwifiex_init_sdio_ioport(struct mwifiex_adapter *adapter)
 {
- u32 reg;
+ u8 reg;
+ struct sdio_mmc_card *card = adapter->card;
 
  adapter->ioport = 0;
 
+ if (card->supports_sdio_new_mode) {
+  if (mwifiex_init_sdio_new_mode(adapter))
+   return -1;
+  goto cont;
+ }
+
  /* Read the IO port */
  if (!mwifiex_read_reg(adapter, IO_PORT_0_REG, &reg))
   adapter->ioport |= (reg & 0xff);
@@ -428,19 +489,19 @@ static int mwifiex_init_sdio_ioport(struct mwifiex_adapter *adapter)
   adapter->ioport |= ((reg & 0xff) << 16);
  else
   return -1;
-
+cont:
  pr_debug("info: SDIO FUNC1 IO port: %#x\n", adapter->ioport);
 
  /* Set Host interrupt reset to read to clear */
  if (!mwifiex_read_reg(adapter, HOST_INT_RSR_REG, &reg))
   mwifiex_write_reg(adapter, HOST_INT_RSR_REG,
-      reg | SDIO_INT_MASK);
+      reg | card->reg->sdio_int_mask);
  else
   return -1;
 
  /* Dnld/Upld ready set to auto reset */
- if (!mwifiex_read_reg(adapter, CARD_MISC_CFG_REG, &reg))
-  mwifiex_write_reg(adapter, CARD_MISC_CFG_REG,
+ if (!mwifiex_read_reg(adapter, card->reg->card_misc_cfg_reg, &reg))
+  mwifiex_write_reg(adapter, card->reg->card_misc_cfg_reg,
       reg | AUTO_RE_ENABLE_INT);
  else
   return -1;
@@ -486,34 +547,42 @@ static int mwifiex_write_data_to_card(struct mwifiex_adapter *adapter,
 static int mwifiex_get_rd_port(struct mwifiex_adapter *adapter, u8 *port)
 {
  struct sdio_mmc_card *card = adapter->card;
- u16 rd_bitmap = card->mp_rd_bitmap;
+ const struct mwifiex_sdio_card_reg *reg = card->reg;
+ u32 rd_bitmap = card->mp_rd_bitmap;
 
- dev_dbg(adapter->dev, "data: mp_rd_bitmap=0x%04x\n", rd_bitmap);
+ dev_dbg(adapter->dev, "data: mp_rd_bitmap=0x%08x\n", rd_bitmap);
 
- if (!(rd_bitmap & (CTRL_PORT_MASK | DATA_PORT_MASK)))
-  return -1;
+ if (card->supports_sdio_new_mode) {
+  if (!(rd_bitmap & reg->data_port_mask))
+   return -1;
+ } else {
+  if (!(rd_bitmap & (CTRL_PORT_MASK | reg->data_port_mask)))
+   return -1;
+ }
 
- if (card->mp_rd_bitmap & CTRL_PORT_MASK) {
-  card->mp_rd_bitmap &= (u16) (~CTRL_PORT_MASK);
+ if ((card->has_control_mask) &&
+     (card->mp_rd_bitmap & CTRL_PORT_MASK)) {
+  card->mp_rd_bitmap &= (u32) (~CTRL_PORT_MASK);
   *port = CTRL_PORT;
-  dev_dbg(adapter->dev, "data: port=%d mp_rd_bitmap=0x%04x\n",
+  dev_dbg(adapter->dev, "data: port=%d mp_rd_bitmap=0x%08x\n",
    *port, card->mp_rd_bitmap);
- } else {
-  if (card->mp_rd_bitmap & (1 << card->curr_rd_port)) {
-   card->mp_rd_bitmap &= (u16)
-      (~(1 << card->curr_rd_port));
-   *port = card->curr_rd_port;
+  return 0;
+ }
 
-   if (++card->curr_rd_port == MAX_PORT)
-    card->curr_rd_port = 1;
-  } else {
-   return -1;
-  }
+ if (!(card->mp_rd_bitmap & (1 << card->curr_rd_port)))
+  return -1;
+
+ /* We are now handling the SDIO data ports */
+ card->mp_rd_bitmap &= (u32)(~(1 << card->curr_rd_port));
+ *port = card->curr_rd_port;
+
+ if (++card->curr_rd_port == card->max_ports)
+  card->curr_rd_port = reg->start_rd_port;
+
+ dev_dbg(adapter->dev,
+  "data: port=%d mp_rd_bitmap=0x%08x -> 0x%08x\n",
+  *port, rd_bitmap, card->mp_rd_bitmap);
 
-  dev_dbg(adapter->dev,
-   "data: port=%d mp_rd_bitmap=0x%04x -> 0x%04x\n",
-   *port, rd_bitmap, card->mp_rd_bitmap);
- }
  return 0;
 }
 
@@ -524,35 +593,45 @@ static int mwifiex_get_rd_port(struct mwifiex_adapter *adapter, u8 *port)
  * increased (provided it does not reach the maximum limit, in which
  * case it is reset to 1)
  */
-static int mwifiex_get_wr_port_data(struct mwifiex_adapter *adapter, u8 *port)
+static int mwifiex_get_wr_port_data(struct mwifiex_adapter *adapter, u32 *port)
 {
  struct sdio_mmc_card *card = adapter->card;
- u16 wr_bitmap = card->mp_wr_bitmap;
+ const struct mwifiex_sdio_card_reg *reg = card->reg;
+ u32 wr_bitmap = card->mp_wr_bitmap;
 
- dev_dbg(adapter->dev, "data: mp_wr_bitmap=0x%04x\n", wr_bitmap);
+ dev_dbg(adapter->dev, "data: mp_wr_bitmap=0x%08x\n", wr_bitmap);
 
- if (!(wr_bitmap & card->mp_data_port_mask))
+ if (card->supports_sdio_new_mode &&
+     !(wr_bitmap & reg->data_port_mask)) {
+  adapter->data_sent = true;
+  return -EBUSY;
+ } else if (!card->supports_sdio_new_mode &&
+     !(wr_bitmap & card->mp_data_port_mask)) {
   return -1;
+ }
 
  if (card->mp_wr_bitmap & (1 << card->curr_wr_port)) {
-  card->mp_wr_bitmap &= (u16) (~(1 << card->curr_wr_port));
+  card->mp_wr_bitmap &= (u32) (~(1 << card->curr_wr_port));
   *port = card->curr_wr_port;
-  if (++card->curr_wr_port == card->mp_end_port)
-   card->curr_wr_port = 1;
+  if (((card->supports_sdio_new_mode) &&
+       (++card->curr_wr_port == card->max_ports)) ||
+      ((!card->supports_sdio_new_mode) &&
+       (++card->curr_wr_port == card->mp_end_port)))
+   card->curr_wr_port = reg->start_wr_port;
  } else {
   adapter->data_sent = true;
   return -EBUSY;
  }
 
- if (*port == CTRL_PORT) {
-  dev_err(adapter->dev, "invalid data port=%d cur port=%d"
-   " mp_wr_bitmap=0x%04x -> 0x%04x\n",
+ if ((card->has_control_mask) && (*port == CTRL_PORT)) {
+  dev_err(adapter->dev,
+   "invalid data port=%d cur port=%d mp_wr_bitmap=0x%08x -> 0x%08x\n",
    *port, card->curr_wr_port, wr_bitmap,
    card->mp_wr_bitmap);
   return -1;
  }
 
- dev_dbg(adapter->dev, "data: port=%d mp_wr_bitmap=0x%04x -> 0x%04x\n",
+ dev_dbg(adapter->dev, "data: port=%d mp_wr_bitmap=0x%08x -> 0x%08x\n",
   *port, wr_bitmap, card->mp_wr_bitmap);
 
  return 0;
@@ -564,11 +643,12 @@ static int mwifiex_get_wr_port_data(struct mwifiex_adapter *adapter, u8 *port)
 static int
 mwifiex_sdio_poll_card_status(struct mwifiex_adapter *adapter, u8 bits)
 {
+ struct sdio_mmc_card *card = adapter->card;
  u32 tries;
- u32 cs;
+ u8 cs;
 
  for (tries = 0; tries < MAX_POLL_TRIES; tries++) {
-  if (mwifiex_read_reg(adapter, CARD_STATUS_REG, &cs))
+  if (mwifiex_read_reg(adapter, card->reg->poll_reg, &cs))
    break;
   else if ((cs & bits) == bits)
    return 0;
@@ -587,12 +667,14 @@ mwifiex_sdio_poll_card_status(struct mwifiex_adapter *adapter, u8 bits)
 static int
 mwifiex_sdio_read_fw_status(struct mwifiex_adapter *adapter, u16 *dat)
 {
- u32 fws0, fws1;
+ struct sdio_mmc_card *card = adapter->card;
+ const struct mwifiex_sdio_card_reg *reg = card->reg;
+ u8 fws0, fws1;
 
- if (mwifiex_read_reg(adapter, CARD_FW_STATUS0_REG, &fws0))
+ if (mwifiex_read_reg(adapter, reg->status_reg_0, &fws0))
   return -1;
 
- if (mwifiex_read_reg(adapter, CARD_FW_STATUS1_REG, &fws1))
+ if (mwifiex_read_reg(adapter, reg->status_reg_1, &fws1))
   return -1;
 
  *dat = (u16) ((fws1 << 8) | fws0);
@@ -606,23 +688,74 @@ mwifiex_sdio_read_fw_status(struct mwifiex_adapter *adapter, u16 *dat)
  * The host interrupt mask is read, the disable bit is reset and
  * written back to the card host interrupt mask register.
  */
-static int mwifiex_sdio_disable_host_int(struct mwifiex_adapter *adapter)
+static void mwifiex_sdio_disable_host_int(struct mwifiex_adapter *adapter)
 {
- u32 host_int_mask;
+ struct sdio_mmc_card *card = adapter->card;
+ struct sdio_func *func = card->func;
 
- /* Read back the host_int_mask register */
- if (mwifiex_read_reg(adapter, HOST_INT_MASK_REG, &host_int_mask))
-  return -1;
+ sdio_claim_host(func);
+ mwifiex_write_reg_locked(func, HOST_INT_MASK_REG, 0);
+ sdio_release_irq(func);
+ sdio_release_host(func);
+}
 
- /* Update with the mask and write back to the register */
- host_int_mask &= ~HOST_INT_DISABLE;
+/*
+ * This function reads the interrupt status from card.
+ */
+static void mwifiex_interrupt_status(struct mwifiex_adapter *adapter)
+{
+ struct sdio_mmc_card *card = adapter->card;
+ u8 sdio_ireg;
+ unsigned long flags;
 
- if (mwifiex_write_reg(adapter, HOST_INT_MASK_REG, host_int_mask)) {
-  dev_err(adapter->dev, "disable host interrupt failed\n");
-  return -1;
+ if (mwifiex_read_data_sync(adapter, card->mp_regs,
+       card->reg->max_mp_regs,
+       REG_PORT | MWIFIEX_SDIO_BYTE_MODE_MASK, 0)) {
+  dev_err(adapter->dev, "read mp_regs failed\n");
+  return;
  }
 
- return 0;
+ sdio_ireg = card->mp_regs[HOST_INTSTATUS_REG];
+ if (sdio_ireg) {
+  /*
+   * DN_LD_HOST_INT_STATUS and/or UP_LD_HOST_INT_STATUS
+   * For SDIO new mode CMD port interrupts
+   * DN_LD_CMD_PORT_HOST_INT_STATUS and/or
+   * UP_LD_CMD_PORT_HOST_INT_STATUS
+   * Clear the interrupt status register
+   */
+  dev_dbg(adapter->dev, "int: sdio_ireg = %#x\n", sdio_ireg);
+  spin_lock_irqsave(&adapter->int_lock, flags);
+  adapter->int_status |= sdio_ireg;
+  spin_unlock_irqrestore(&adapter->int_lock, flags);
+ }
+}
+
+/*
+ * SDIO interrupt handler.
+ *
+ * This function reads the interrupt status from firmware and handles
+ * the interrupt in current thread (ksdioirqd) right away.
+ */
+static void
+mwifiex_sdio_interrupt(struct sdio_func *func)
+{
+ struct mwifiex_adapter *adapter;
+ struct sdio_mmc_card *card;
+
+ card = sdio_get_drvdata(func);
+ if (!card || !card->adapter) {
+  pr_debug("int: func=%p card=%p adapter=%p\n",
+    func, card, card ? card->adapter : NULL);
+  return;
+ }
+ adapter = card->adapter;
+
+ if (!adapter->pps_uapsd_mode && adapter->ps_state == PS_STATE_SLEEP)
+  adapter->ps_state = PS_STATE_AWAKE;
+
+ mwifiex_interrupt_status(adapter);
+ mwifiex_main_process(adapter);
 }
 
 /*
@@ -633,12 +766,30 @@ static int mwifiex_sdio_disable_host_int(struct mwifiex_adapter *adapter)
  */
 static int mwifiex_sdio_enable_host_int(struct mwifiex_adapter *adapter)
 {
+ struct sdio_mmc_card *card = adapter->card;
+ struct sdio_func *func = card->func;
+ int ret;
+
+ sdio_claim_host(func);
+
+ /* Request the SDIO IRQ */
+ ret = sdio_claim_irq(func, mwifiex_sdio_interrupt);
+ if (ret) {
+  dev_err(adapter->dev, "claim irq failed: ret=%d\n", ret);
+  goto out;
+ }
+
  /* Simply write the mask to the register */
- if (mwifiex_write_reg(adapter, HOST_INT_MASK_REG, HOST_INT_ENABLE)) {
+ ret = mwifiex_write_reg_locked(func, HOST_INT_MASK_REG,
+           card->reg->host_int_enable);
+ if (ret) {
   dev_err(adapter->dev, "enable host interrupt failed\n");
-  return -1;
+  sdio_release_irq(func);
  }
- return 0;
+
+out:
+ sdio_release_host(func);
+ return ret;
 }
 
 /*
@@ -686,11 +837,13 @@ static int mwifiex_sdio_card_to_host(struct mwifiex_adapter *adapter,
 static int mwifiex_prog_fw_w_helper(struct mwifiex_adapter *adapter,
         struct mwifiex_fw_image *fw)
 {
+ struct sdio_mmc_card *card = adapter->card;
+ const struct mwifiex_sdio_card_reg *reg = card->reg;
  int ret;
  u8 *firmware = fw->fw_buf;
  u32 firmware_len = fw->fw_len;
  u32 offset = 0;
- u32 base0, base1;
+ u8 base0, base1;
  u8 *fwbuf;
  u16 len = 0;
  u32 txlen, tx_blocks = 0, tries;
@@ -727,7 +880,7 @@ static int mwifiex_prog_fw_w_helper(struct mwifiex_adapter *adapter,
    break;
 
   for (tries = 0; tries < MAX_POLL_TRIES; tries++) {
-   ret = mwifiex_read_reg(adapter, HOST_F1_RD_BASE_0,
+   ret = mwifiex_read_reg(adapter, reg->base_0_reg,
             &base0);
    if (ret) {
     dev_err(adapter->dev,
@@ -736,7 +889,7 @@ static int mwifiex_prog_fw_w_helper(struct mwifiex_adapter *adapter,
      base0, base0);
     goto done;
    }
-   ret = mwifiex_read_reg(adapter, HOST_F1_RD_BASE_1,
+   ret = mwifiex_read_reg(adapter, reg->base_1_reg,
             &base1);
    if (ret) {
     dev_err(adapter->dev,
@@ -828,10 +981,11 @@ done:
 static int mwifiex_check_fw_status(struct mwifiex_adapter *adapter,
        u32 poll_num)
 {
+ struct sdio_mmc_card *card = adapter->card;
  int ret = 0;
  u16 firmware_stat;
  u32 tries;
- u32 winner_status;
+ u8 winner_status;
 
  /* Wait for firmware initialization event */
  for (tries = 0; tries < poll_num; tries++) {
@@ -842,14 +996,14 @@ static int mwifiex_check_fw_status(struct mwifiex_adapter *adapter,
    ret = 0;
    break;
   } else {
-   mdelay(100);
+   msleep(100);
    ret = -1;
   }
  }
 
  if (ret) {
   if (mwifiex_read_reg
-      (adapter, CARD_FW_STATUS0_REG, &winner_status))
+      (adapter, card->reg->status_reg_0, &winner_status))
    winner_status = 0;
 
   if (winner_status)
@@ -861,65 +1015,6 @@ static int mwifiex_check_fw_status(struct mwifiex_adapter *adapter,
 }
 
 /*
- * This function reads the interrupt status from card.
- */
-static void mwifiex_interrupt_status(struct mwifiex_adapter *adapter)
-{
- struct sdio_mmc_card *card = adapter->card;
- u32 sdio_ireg;
- unsigned long flags;
-
- if (mwifiex_read_data_sync(adapter, card->mp_regs, MAX_MP_REGS,
-       REG_PORT | MWIFIEX_SDIO_BYTE_MODE_MASK,
-       0)) {
-  dev_err(adapter->dev, "read mp_regs failed\n");
-  return;
- }
-
- sdio_ireg = card->mp_regs[HOST_INTSTATUS_REG];
- if (sdio_ireg) {
-  /*
-   * DN_LD_HOST_INT_STATUS and/or UP_LD_HOST_INT_STATUS
-   * Clear the interrupt status register
-   */
-  dev_dbg(adapter->dev, "int: sdio_ireg = %#x\n", sdio_ireg);
-  spin_lock_irqsave(&adapter->int_lock, flags);
-  adapter->int_status |= sdio_ireg;
-  spin_unlock_irqrestore(&adapter->int_lock, flags);
- }
-}
-
-/*
- * SDIO interrupt handler.
- *
- * This function reads the interrupt status from firmware and handles
- * the interrupt in current thread (ksdioirqd) right away.
- */
-static void
-mwifiex_sdio_interrupt(struct sdio_func *func)
-{
- struct mwifiex_adapter *adapter;
- struct sdio_mmc_card *card;
-
- card = sdio_get_drvdata(func);
- if (!card || !card->adapter) {
-  pr_debug("int: func=%p card=%p adapter=%p\n",
-    func, card, card ? card->adapter : NULL);
-  return;
- }
- adapter = card->adapter;
-
- if (adapter->surprise_removed)
-  return;
-
- if (!adapter->pps_uapsd_mode && adapter->ps_state == PS_STATE_SLEEP)
-  adapter->ps_state = PS_STATE_AWAKE;
-
- mwifiex_interrupt_status(adapter);
- mwifiex_main_process(adapter);
-}
-
-/*
  * This function decodes a received packet.
  *
  * Based on the type, the packet is treated as either a data, or
@@ -966,7 +1061,7 @@ static int mwifiex_decode_rx_packet(struct mwifiex_adapter *adapter,
 
  case MWIFIEX_TYPE_EVENT:
   dev_dbg(adapter->dev, "info: --- Rx: Event ---\n");
-  adapter->event_cause = *(u32 *) skb->data;
+  adapter->event_cause = le32_to_cpu(*(__le32 *) skb->data);
 
   if ((skb->len > 0) && (skb->len  < MAX_EVENT_SIZE))
    memcpy(adapter->event_body,
@@ -1006,11 +1101,11 @@ static int mwifiex_sdio_card_to_host_mp_aggr(struct mwifiex_adapter *adapter,
  s32 f_aggr_cur = 0;
  struct sk_buff *skb_deaggr;
  u32 pind;
- u32 pkt_len, pkt_type = 0;
+ u32 pkt_len, pkt_type, mport;
  u8 *curr_ptr;
  u32 rx_len = skb->len;
 
- if (port == CTRL_PORT) {
+ if ((card->has_control_mask) && (port == CTRL_PORT)) {
   /* Read the command Resp without aggr */
   dev_dbg(adapter->dev, "info: %s: no aggregation for cmd "
    "response\n", __func__);
@@ -1027,7 +1122,10 @@ static int mwifiex_sdio_card_to_host_mp_aggr(struct mwifiex_adapter *adapter,
   goto rx_curr_single;
  }
 
- if (card->mp_rd_bitmap & (~((u16) CTRL_PORT_MASK))) {
+ if ((!card->has_control_mask && (card->mp_rd_bitmap &
+      card->reg->data_port_mask)) ||
+     (card->has_control_mask && (card->mp_rd_bitmap &
+     (~((u32) CTRL_PORT_MASK))))) {
   /* Some more data RX pending */
   dev_dbg(adapter->dev, "info: %s: not last packet\n", __func__);
 
@@ -1063,10 +1161,10 @@ static int mwifiex_sdio_card_to_host_mp_aggr(struct mwifiex_adapter *adapter,
  if (f_aggr_cur) {
   dev_dbg(adapter->dev, "info: current packet aggregation\n");
   /* Curr pkt can be aggregated */
-  MP_RX_AGGR_SETUP(card, skb, port);
+  mp_rx_aggr_setup(card, skb, port);
 
   if (MP_RX_AGGR_PKT_LIMIT_REACHED(card) ||
-      MP_RX_AGGR_PORT_LIMIT_REACHED(card)) {
+      mp_rx_aggr_port_limit_reached(card)) {
    dev_dbg(adapter->dev, "info: %s: aggregated packet "
     "limit reached\n", __func__);
    /* No more pkts allowed in Aggr buf, rx it */
@@ -1079,11 +1177,28 @@ static int mwifiex_sdio_card_to_host_mp_aggr(struct mwifiex_adapter *adapter,
   dev_dbg(adapter->dev, "info: do_rx_aggr: num of packets: %d\n",
    card->mpa_rx.pkt_cnt);
 
+  if (card->supports_sdio_new_mode) {
+   int i;
+   u32 port_count;
+
+   for (i = 0, port_count = 0; i < card->max_ports; i++)
+    if (card->mpa_rx.ports & BIT(i))
+     port_count++;
+
+   /* Reading data from "start_port + 0" to "start_port +
+    * port_count -1", so decrease the count by 1
+    */
+   port_count--;
+   mport = (adapter->ioport | SDIO_MPA_ADDR_BASE |
+     (port_count << 8)) + card->mpa_rx.start_port;
+  } else {
+   mport = (adapter->ioport | SDIO_MPA_ADDR_BASE |
+     (card->mpa_rx.ports << 4)) +
+     card->mpa_rx.start_port;
+  }
+
   if (mwifiex_read_data_sync(adapter, card->mpa_rx.buf,
-        card->mpa_rx.buf_len,
-        (adapter->ioport | 0x1000 |
-         (card->mpa_rx.ports << 4)) +
-        card->mpa_rx.start_port, 1))
+        card->mpa_rx.buf_len, mport, 1))
    goto error;
 
   curr_ptr = card->mpa_rx.buf;
@@ -1091,8 +1206,8 @@ static int mwifiex_sdio_card_to_host_mp_aggr(struct mwifiex_adapter *adapter,
   for (pind = 0; pind < card->mpa_rx.pkt_cnt; pind++) {
 
    /* get curr PKT len & type */
-   pkt_len = *(u16 *) &curr_ptr[0];
-   pkt_type = *(u16 *) &curr_ptr[2];
+   pkt_len = le16_to_cpu(*(__le16 *) &curr_ptr[0]);
+   pkt_type = le16_to_cpu(*(__le16 *) &curr_ptr[2]);
 
    /* copy pkt to deaggr buf */
    skb_deaggr = card->mpa_rx.skb_arr[pind];
@@ -1170,6 +1285,7 @@ error:
 static int mwifiex_process_int_status(struct mwifiex_adapter *adapter)
 {
  struct sdio_mmc_card *card = adapter->card;
+ const struct mwifiex_sdio_card_reg *reg = card->reg;
  int ret = 0;
  u8 sdio_ireg;
  struct sk_buff *skb;
@@ -1178,6 +1294,8 @@ static int mwifiex_process_int_status(struct mwifiex_adapter *adapter)
  u32 rx_blocks;
  u16 rx_len;
  unsigned long flags;
+ u32 bitmap;
+ u8 cr;
 
  spin_lock_irqsave(&adapter->int_lock, flags);
  sdio_ireg = adapter->int_status;
@@ -1187,10 +1305,60 @@ static int mwifiex_process_int_status(struct mwifiex_adapter *adapter)
  if (!sdio_ireg)
   return ret;
 
+ /* Following interrupt is only for SDIO new mode */
+ if (sdio_ireg & DN_LD_CMD_PORT_HOST_INT_STATUS && adapter->cmd_sent)
+  adapter->cmd_sent = false;
+
+ /* Following interrupt is only for SDIO new mode */
+ if (sdio_ireg & UP_LD_CMD_PORT_HOST_INT_STATUS) {
+  u32 pkt_type;
+
+  /* read the len of control packet */
+  rx_len = card->mp_regs[CMD_RD_LEN_1] << 8;
+  rx_len |= (u16) card->mp_regs[CMD_RD_LEN_0];
+  rx_blocks = DIV_ROUND_UP(rx_len, MWIFIEX_SDIO_BLOCK_SIZE);
+  if (rx_len <= INTF_HEADER_LEN ||
+      (rx_blocks * MWIFIEX_SDIO_BLOCK_SIZE) >
+       MWIFIEX_RX_DATA_BUF_SIZE)
+   return -1;
+  rx_len = (u16) (rx_blocks * MWIFIEX_SDIO_BLOCK_SIZE);
+
+  skb = dev_alloc_skb(rx_len);
+  if (!skb)
+   return -1;
+
+  skb_put(skb, rx_len);
+
+  if (mwifiex_sdio_card_to_host(adapter, &pkt_type, skb->data,
+           skb->len, adapter->ioport |
+       CMD_PORT_SLCT)) {
+   dev_err(adapter->dev,
+    "%s: failed to card_to_host", __func__);
+   dev_kfree_skb_any(skb);
+   goto term_cmd;
+  }
+
+  if ((pkt_type != MWIFIEX_TYPE_CMD) &&
+      (pkt_type != MWIFIEX_TYPE_EVENT))
+   dev_err(adapter->dev,
+    "%s:Received wrong packet on cmd port",
+    __func__);
+
+  mwifiex_decode_rx_packet(adapter, skb, pkt_type);
+ }
+
  if (sdio_ireg & DN_LD_HOST_INT_STATUS) {
-  card->mp_wr_bitmap = ((u16) card->mp_regs[WR_BITMAP_U]) << 8;
-  card->mp_wr_bitmap |= (u16) card->mp_regs[WR_BITMAP_L];
-  dev_dbg(adapter->dev, "int: DNLD: wr_bitmap=0x%04x\n",
+  bitmap = (u32) card->mp_regs[reg->wr_bitmap_l];
+  bitmap |= ((u32) card->mp_regs[reg->wr_bitmap_u]) << 8;
+  if (card->supports_sdio_new_mode) {
+   bitmap |=
+    ((u32) card->mp_regs[reg->wr_bitmap_1l]) << 16;
+   bitmap |=
+    ((u32) card->mp_regs[reg->wr_bitmap_1u]) << 24;
+  }
+  card->mp_wr_bitmap = bitmap;
+
+  dev_dbg(adapter->dev, "int: DNLD: wr_bitmap=0x%x\n",
    card->mp_wr_bitmap);
   if (adapter->data_sent &&
       (card->mp_wr_bitmap & card->mp_data_port_mask)) {
@@ -1203,11 +1371,11 @@ static int mwifiex_process_int_status(struct mwifiex_adapter *adapter)
  /* As firmware will not generate download ready interrupt if the port
     updated is command port only, cmd_sent should be done for any SDIO
     interrupt. */
- if (adapter->cmd_sent) {
+ if (card->has_control_mask && adapter->cmd_sent) {
   /* Check if firmware has attach buffer at command port and
      update just that in wr_bit_map. */
   card->mp_wr_bitmap |=
-   (u16) card->mp_regs[WR_BITMAP_L] & CTRL_PORT_MASK;
+   (u32) card->mp_regs[reg->wr_bitmap_l] & CTRL_PORT_MASK;
   if (card->mp_wr_bitmap & CTRL_PORT_MASK)
    adapter->cmd_sent = false;
  }
@@ -1215,9 +1383,16 @@ static int mwifiex_process_int_status(struct mwifiex_adapter *adapter)
  dev_dbg(adapter->dev, "info: cmd_sent=%d data_sent=%d\n",
   adapter->cmd_sent, adapter->data_sent);
  if (sdio_ireg & UP_LD_HOST_INT_STATUS) {
-  card->mp_rd_bitmap = ((u16) card->mp_regs[RD_BITMAP_U]) << 8;
-  card->mp_rd_bitmap |= (u16) card->mp_regs[RD_BITMAP_L];
-  dev_dbg(adapter->dev, "int: UPLD: rd_bitmap=0x%04x\n",
+  bitmap = (u32) card->mp_regs[reg->rd_bitmap_l];
+  bitmap |= ((u32) card->mp_regs[reg->rd_bitmap_u]) << 8;
+  if (card->supports_sdio_new_mode) {
+   bitmap |=
+    ((u32) card->mp_regs[reg->rd_bitmap_1l]) << 16;
+   bitmap |=
+    ((u32) card->mp_regs[reg->rd_bitmap_1u]) << 24;
+  }
+  card->mp_rd_bitmap = bitmap;
+  dev_dbg(adapter->dev, "int: UPLD: rd_bitmap=0x%x\n",
    card->mp_rd_bitmap);
 
   while (true) {
@@ -1227,8 +1402,8 @@ static int mwifiex_process_int_status(struct mwifiex_adapter *adapter)
      "info: no more rd_port available\n");
     break;
    }
-   len_reg_l = RD_LEN_P0_L + (port << 1);
-   len_reg_u = RD_LEN_P0_U + (port << 1);
+   len_reg_l = reg->rd_len_p0_l + (port << 1);
+   len_reg_u = reg->rd_len_p0_u + (port << 1);
    rx_len = ((u16) card->mp_regs[len_reg_u]) << 8;
    rx_len |= (u16) card->mp_regs[len_reg_l];
    dev_dbg(adapter->dev, "info: RX: port=%d rx_len=%u\n",
@@ -1260,37 +1435,33 @@ static int mwifiex_process_int_status(struct mwifiex_adapter *adapter)
 
    if (mwifiex_sdio_card_to_host_mp_aggr(adapter, skb,
              port)) {
-    u32 cr = 0;
-
     dev_err(adapter->dev, "card_to_host_mpa failed:"
      " int status=%#x\n", sdio_ireg);
-    if (mwifiex_read_reg(adapter,
-           CONFIGURATION_REG, &cr))
-     dev_err(adapter->dev,
-      "read CFG reg failed\n");
-
-    dev_dbg(adapter->dev,
-     "info: CFG reg val = %d\n", cr);
-    if (mwifiex_write_reg(adapter,
-            CONFIGURATION_REG,
-            (cr | 0x04)))
-     dev_err(adapter->dev,
-      "write CFG reg failed\n");
-
-    dev_dbg(adapter->dev, "info: write success\n");
-    if (mwifiex_read_reg(adapter,
-           CONFIGURATION_REG, &cr))
-     dev_err(adapter->dev,
-      "read CFG reg failed\n");
-
-    dev_dbg(adapter->dev,
-     "info: CFG reg val =%x\n", cr);
-    return -1;
+    goto term_cmd;
    }
   }
  }
 
  return 0;
+
+term_cmd:
+ /* terminate cmd */
+ if (mwifiex_read_reg(adapter, CONFIGURATION_REG, &cr))
+  dev_err(adapter->dev, "read CFG reg failed\n");
+ else
+  dev_dbg(adapter->dev, "info: CFG reg val = %d\n", cr);
+
+ if (mwifiex_write_reg(adapter, CONFIGURATION_REG, (cr | 0x04)))
+  dev_err(adapter->dev, "write CFG reg failed\n");
+ else
+  dev_dbg(adapter->dev, "info: write success\n");
+
+ if (mwifiex_read_reg(adapter, CONFIGURATION_REG, &cr))
+  dev_err(adapter->dev, "read CFG reg failed\n");
+ else
+  dev_dbg(adapter->dev, "info: CFG reg val =%x\n", cr);
+
+ return -1;
 }
 
 /*
@@ -1308,7 +1479,7 @@ static int mwifiex_process_int_status(struct mwifiex_adapter *adapter)
  * and return.
  */
 static int mwifiex_host_to_card_mp_aggr(struct mwifiex_adapter *adapter,
-     u8 *payload, u32 pkt_len, u8 port,
+     u8 *payload, u32 pkt_len, u32 port,
      u32 next_pkt_len)
 {
  struct sdio_mmc_card *card = adapter->card;
@@ -1317,8 +1488,11 @@ static int mwifiex_host_to_card_mp_aggr(struct mwifiex_adapter *adapter,
  s32 f_send_cur_buf = 0;
  s32 f_precopy_cur_buf = 0;
  s32 f_postcopy_cur_buf = 0;
+ u32 mport;
 
- if ((!card->mpa_tx.enabled) || (port == CTRL_PORT)) {
+ if (!card->mpa_tx.enabled ||
+     (card->has_control_mask && (port == CTRL_PORT)) ||
+     (card->supports_sdio_new_mode && (port == CMD_PORT_SLCT))) {
   dev_dbg(adapter->dev, "info: %s: tx aggregation disabled\n",
    __func__);
 
@@ -1332,7 +1506,7 @@ static int mwifiex_host_to_card_mp_aggr(struct mwifiex_adapter *adapter,
    __func__);
 
   if (MP_TX_AGGR_IN_PROGRESS(card)) {
-   if (!MP_TX_AGGR_PORT_LIMIT_REACHED(card) &&
+   if (!mp_tx_aggr_port_limit_reached(card) &&
        MP_TX_AGGR_BUF_HAS_ROOM(card, pkt_len)) {
     f_precopy_cur_buf = 1;
 
@@ -1345,7 +1519,7 @@ static int mwifiex_host_to_card_mp_aggr(struct mwifiex_adapter *adapter,
     /* No room in Aggr buf, send it */
     f_send_aggr_buf = 1;
 
-    if (MP_TX_AGGR_PORT_LIMIT_REACHED(card) ||
+    if (mp_tx_aggr_port_limit_reached(card) ||
         !(card->mp_wr_bitmap &
           (1 << card->curr_wr_port)))
      f_send_cur_buf = 1;
@@ -1384,7 +1558,7 @@ static int mwifiex_host_to_card_mp_aggr(struct mwifiex_adapter *adapter,
   MP_TX_AGGR_BUF_PUT(card, payload, pkt_len, port);
 
   if (MP_TX_AGGR_PKT_LIMIT_REACHED(card) ||
-      MP_TX_AGGR_PORT_LIMIT_REACHED(card))
+      mp_tx_aggr_port_limit_reached(card))
    /* No more pkts allowed in Aggr buf, send it */
    f_send_aggr_buf = 1;
  }
@@ -1393,11 +1567,28 @@ static int mwifiex_host_to_card_mp_aggr(struct mwifiex_adapter *adapter,
   dev_dbg(adapter->dev, "data: %s: send aggr buffer: %d %d\n",
    __func__,
     card->mpa_tx.start_port, card->mpa_tx.ports);
+  if (card->supports_sdio_new_mode) {
+   u32 port_count;
+   int i;
+
+   for (i = 0, port_count = 0; i < card->max_ports; i++)
+    if (card->mpa_tx.ports & BIT(i))
+     port_count++;
+
+   /* Writing data from "start_port + 0" to "start_port +
+    * port_count -1", so decrease the count by 1
+    */
+   port_count--;
+   mport = (adapter->ioport | SDIO_MPA_ADDR_BASE |
+     (port_count << 8)) + card->mpa_tx.start_port;
+  } else {
+   mport = (adapter->ioport | SDIO_MPA_ADDR_BASE |
+     (card->mpa_tx.ports << 4)) +
+     card->mpa_tx.start_port;
+  }
+
   ret = mwifiex_write_data_to_card(adapter, card->mpa_tx.buf,
-       card->mpa_tx.buf_len,
-       (adapter->ioport | 0x1000 |
-       (card->mpa_tx.ports << 4)) +
-        card->mpa_tx.start_port);
+       card->mpa_tx.buf_len, mport);
 
   MP_TX_AGGR_BUF_RESET(card);
  }
@@ -1437,7 +1628,7 @@ static int mwifiex_sdio_host_to_card(struct mwifiex_adapter *adapter,
  int ret;
  u32 buf_block_len;
  u32 blk_size;
- u8 port = CTRL_PORT;
+ u32 port = CTRL_PORT;
  u8 *payload = (u8 *)skb->data;
  u32 pkt_len = skb->len;
 
@@ -1468,6 +1659,9 @@ static int mwifiex_sdio_host_to_card(struct mwifiex_adapter *adapter,
       pkt_len > MWIFIEX_UPLD_SIZE)
    dev_err(adapter->dev, "%s: payload=%p, nb=%d\n",
     __func__, payload, pkt_len);
+
+  if (card->supports_sdio_new_mode)
+   port = CMD_PORT_SLCT;
  }
 
  /* Transfer data to card */
@@ -1484,8 +1678,12 @@ static int mwifiex_sdio_host_to_card(struct mwifiex_adapter *adapter,
  if (ret) {
   if (type == MWIFIEX_TYPE_CMD)
    adapter->cmd_sent = false;
-  if (type == MWIFIEX_TYPE_DATA)
+  if (type == MWIFIEX_TYPE_DATA) {
    adapter->data_sent = false;
+   /* restore curr_wr_port in error cases */
+   card->curr_wr_port = port;
+   card->mp_wr_bitmap |= (u32)(1 << card->curr_wr_port);
+  }
  } else {
   if (type == MWIFIEX_TYPE_DATA) {
    if (!(card->mp_wr_bitmap & (1 << card->curr_wr_port)))
@@ -1544,12 +1742,9 @@ mwifiex_unregister_dev(struct mwifiex_adapter *adapter)
  struct sdio_mmc_card *card = adapter->card;
 
  if (adapter->card) {
-  /* Release the SDIO IRQ */
   sdio_claim_host(card->func);
-  sdio_release_irq(card->func);
   sdio_disable_func(card->func);
   sdio_release_host(card->func);
-  sdio_set_drvdata(card->func, NULL);
  }
 }
 
@@ -1560,58 +1755,30 @@ mwifiex_unregister_dev(struct mwifiex_adapter *adapter)
  */
 static int mwifiex_register_dev(struct mwifiex_adapter *adapter)
 {
- int ret = 0;
+ int ret;
  struct sdio_mmc_card *card = adapter->card;
  struct sdio_func *func = card->func;
 
  /* save adapter pointer in card */
  card->adapter = adapter;
+ adapter->tx_buf_size = card->tx_buf_size;
 
  sdio_claim_host(func);
 
- /* Request the SDIO IRQ */
- ret = sdio_claim_irq(func, mwifiex_sdio_interrupt);
- if (ret) {
-  pr_err("claim irq failed: ret=%d\n", ret);
-  goto disable_func;
- }
-
  /* Set block size */
  ret = sdio_set_block_size(card->func, MWIFIEX_SDIO_BLOCK_SIZE);
+ sdio_release_host(func);
  if (ret) {
   pr_err("cannot set SDIO block size\n");
-  ret = -1;
-  goto release_irq;
+  return ret;
  }
 
- sdio_release_host(func);
- sdio_set_drvdata(func, card);
 
  adapter->dev = &func->dev;
 
- switch (func->device) {
- case SDIO_DEVICE_ID_MARVELL_8786:
-  strcpy(adapter->fw_name, SD8786_DEFAULT_FW_NAME);
-  break;
- case SDIO_DEVICE_ID_MARVELL_8797:
-  strcpy(adapter->fw_name, SD8797_DEFAULT_FW_NAME);
-  break;
- case SDIO_DEVICE_ID_MARVELL_8787:
- default:
-  strcpy(adapter->fw_name, SD8787_DEFAULT_FW_NAME);
-  break;
- }
+ strcpy(adapter->fw_name, card->firmware);
 
  return 0;
-
-release_irq:
- sdio_release_irq(func);
-disable_func:
- sdio_disable_func(func);
- sdio_release_host(func);
- adapter->card = NULL;
-
- return -1;
 }
 
 /*
@@ -1629,8 +1796,11 @@ disable_func:
 static int mwifiex_init_sdio(struct mwifiex_adapter *adapter)
 {
  struct sdio_mmc_card *card = adapter->card;
+ const struct mwifiex_sdio_card_reg *reg = card->reg;
  int ret;
- u32 sdio_ireg;
+ u8 sdio_ireg;
+
+ sdio_set_drvdata(card->func, card);
 
  /*
   * Read the HOST_INT_STATUS_REG for ACK the first interrupt got
@@ -1639,42 +1809,44 @@ static int mwifiex_init_sdio(struct mwifiex_adapter *adapter)
   */
  mwifiex_read_reg(adapter, HOST_INTSTATUS_REG, &sdio_ireg);
 
- /* Disable host interrupt mask register for SDIO */
- mwifiex_sdio_disable_host_int(adapter);
-
  /* Get SDIO ioport */
  mwifiex_init_sdio_ioport(adapter);
 
  /* Initialize SDIO variables in card */
  card->mp_rd_bitmap = 0;
  card->mp_wr_bitmap = 0;
- card->curr_rd_port = 1;
- card->curr_wr_port = 1;
+ card->curr_rd_port = reg->start_rd_port;
+ card->curr_wr_port = reg->start_wr_port;
 
- card->mp_data_port_mask = DATA_PORT_MASK;
+ card->mp_data_port_mask = reg->data_port_mask;
 
  card->mpa_tx.buf_len = 0;
  card->mpa_tx.pkt_cnt = 0;
  card->mpa_tx.start_port = 0;
 
  card->mpa_tx.enabled = 1;
- card->mpa_tx.pkt_aggr_limit = SDIO_MP_AGGR_DEF_PKT_LIMIT;
+ card->mpa_tx.pkt_aggr_limit = card->mp_agg_pkt_limit;
 
  card->mpa_rx.buf_len = 0;
  card->mpa_rx.pkt_cnt = 0;
  card->mpa_rx.start_port = 0;
 
  card->mpa_rx.enabled = 1;
- card->mpa_rx.pkt_aggr_limit = SDIO_MP_AGGR_DEF_PKT_LIMIT;
+ card->mpa_rx.pkt_aggr_limit = card->mp_agg_pkt_limit;
 
  /* Allocate buffers for SDIO MP-A */
- card->mp_regs = kzalloc(MAX_MP_REGS, GFP_KERNEL);
+ card->mp_regs = kzalloc(reg->max_mp_regs, GFP_KERNEL);
  if (!card->mp_regs)
   return -ENOMEM;
 
+ /* Allocate skb pointer buffers */
+ card->mpa_rx.skb_arr = kzalloc((sizeof(void *)) *
+           card->mp_agg_pkt_limit, GFP_KERNEL);
+ card->mpa_rx.len_arr = kzalloc(sizeof(*card->mpa_rx.len_arr) *
+           card->mp_agg_pkt_limit, GFP_KERNEL);
  ret = mwifiex_alloc_sdio_mpa_buffers(adapter,
-          SDIO_MP_TX_AGGR_DEF_BUF_SIZE,
-          SDIO_MP_RX_AGGR_DEF_BUF_SIZE);
+          card->mp_tx_agg_buf_size,
+          card->mp_rx_agg_buf_size);
  if (ret) {
   dev_err(adapter->dev, "failed to alloc sdio mp-a buffers\n");
   kfree(card->mp_regs);
@@ -1708,8 +1880,12 @@ static void mwifiex_cleanup_sdio(struct mwifiex_adapter *adapter)
  struct sdio_mmc_card *card = adapter->card;
 
  kfree(card->mp_regs);
+ kfree(card->mpa_rx.skb_arr);
+ kfree(card->mpa_rx.len_arr);
  kfree(card->mpa_tx.buf);
  kfree(card->mpa_rx.buf);
+ sdio_set_drvdata(card->func, NULL);
+ kfree(card);
 }
 
 /*
@@ -1719,16 +1895,20 @@ static void
 mwifiex_update_mp_end_port(struct mwifiex_adapter *adapter, u16 port)
 {
  struct sdio_mmc_card *card = adapter->card;
+ const struct mwifiex_sdio_card_reg *reg = card->reg;
  int i;
 
  card->mp_end_port = port;
 
- card->mp_data_port_mask = DATA_PORT_MASK;
+ card->mp_data_port_mask = reg->data_port_mask;
 
- for (i = 1; i <= MAX_PORT - card->mp_end_port; i++)
-  card->mp_data_port_mask &= ~(1 << (MAX_PORT - i));
+ if (reg->start_wr_port) {
+  for (i = 1; i <= card->max_ports - card->mp_end_port; i++)
+   card->mp_data_port_mask &=
+     ~(1 << (card->max_ports - i));
+ }
 
- card->curr_wr_port = 1;
+ card->curr_wr_port = reg->start_wr_port;
 
  dev_dbg(adapter->dev, "cmd: mp_end_port %d, data port mask 0x%x\n",
   port, card->mp_data_port_mask);
@@ -1772,6 +1952,7 @@ static struct mwifiex_if_ops sdio_ops = {
  .register_dev = mwifiex_register_dev,
  .unregister_dev = mwifiex_unregister_dev,
  .enable_int = mwifiex_sdio_enable_host_int,
+ .disable_int = mwifiex_sdio_disable_host_int,
  .process_int_status = mwifiex_process_int_status,
  .host_to_card = mwifiex_sdio_host_to_card,
  .wakeup = mwifiex_pm_wakeup_card,
@@ -1834,3 +2015,4 @@ MODULE_LICENSE("GPL v2");
 MODULE_FIRMWARE(SD8786_DEFAULT_FW_NAME);
 MODULE_FIRMWARE(SD8787_DEFAULT_FW_NAME);
 MODULE_FIRMWARE(SD8797_DEFAULT_FW_NAME);
+MODULE_FIRMWARE(SD8897_DEFAULT_FW_NAME);
diff --git a/drivers/net/wireless/mwifiex/sdio.h b/drivers/net/wireless/mwifiex/sdio.h
index 8cc5468..6eea30b 100644
--- a/drivers/net/wireless/mwifiex/sdio.h
+++ b/drivers/net/wireless/mwifiex/sdio.h
@@ -32,35 +32,40 @@
 #define SD8786_DEFAULT_FW_NAME "mrvl/sd8786_uapsta.bin"
 #define SD8787_DEFAULT_FW_NAME "mrvl/sd8787_uapsta.bin"
 #define SD8797_DEFAULT_FW_NAME "mrvl/sd8797_uapsta.bin"
+#define SD8897_DEFAULT_FW_NAME "mrvl/sd8897_uapsta.bin"
 
 #define BLOCK_MODE 1
 #define BYTE_MODE 0
 
 #define REG_PORT   0
-#define RD_BITMAP_L   0x04
-#define RD_BITMAP_U   0x05
-#define WR_BITMAP_L   0x06
-#define WR_BITMAP_U   0x07
-#define RD_LEN_P0_L   0x08
-#define RD_LEN_P0_U   0x09
 
 #define MWIFIEX_SDIO_IO_PORT_MASK  0xfffff
 
 #define MWIFIEX_SDIO_BYTE_MODE_MASK 0x80000000
 
+#define SDIO_MPA_ADDR_BASE  0x1000
 #define CTRL_PORT   0
 #define CTRL_PORT_MASK   0x0001
-#define DATA_PORT_MASK   0xfffe
 
-#define MAX_MP_REGS   64
-#define MAX_PORT   16
-
-#define SDIO_MP_AGGR_DEF_PKT_LIMIT 8
-
-#define SDIO_MP_TX_AGGR_DEF_BUF_SIZE        (8192) /* 8K */
-
-/* Multi port RX aggregation buffer size */
-#define SDIO_MP_RX_AGGR_DEF_BUF_SIZE        (16384) /* 16K */
+#define CMD_PORT_UPLD_INT_MASK  (0x1U<<6)
+#define CMD_PORT_DNLD_INT_MASK  (0x1U<<7)
+#define HOST_TERM_CMD53   (0x1U << 2)
+#define REG_PORT   0
+#define MEM_PORT   0x10000
+#define CMD_RD_LEN_0   0xB4
+#define CMD_RD_LEN_1   0xB5
+#define CARD_CONFIG_2_1_REG             0xCD
+#define CMD53_NEW_MODE   (0x1U << 0)
+#define CMD_CONFIG_0   0xB8
+#define CMD_PORT_RD_LEN_EN  (0x1U << 2)
+#define CMD_CONFIG_1   0xB9
+#define CMD_PORT_AUTO_EN  (0x1U << 0)
+#define CMD_PORT_SLCT   0x8000
+#define UP_LD_CMD_PORT_HOST_INT_STATUS (0x40U)
+#define DN_LD_CMD_PORT_HOST_INT_STATUS (0x80U)
+
+#define MWIFIEX_MP_AGGR_BUF_SIZE_16K (16384)
+#define MWIFIEX_MP_AGGR_BUF_SIZE_32K (32768)
 
 /* Misc. Config Register : Auto Re-enable interrupts */
 #define AUTO_RE_ENABLE_INT              BIT(4)
@@ -75,14 +80,8 @@
 
 /* Host Control Registers : Configuration */
 #define CONFIGURATION_REG  0x00
-/* Host Control Registers : Host without Command 53 finish host*/
-#define HOST_TO_CARD_EVENT       (0x1U << 3)
-/* Host Control Registers : Host without Command 53 finish host */
-#define HOST_WO_CMD53_FINISH_HOST (0x1U << 2)
 /* Host Control Registers : Host power up */
 #define HOST_POWER_UP   (0x1U << 1)
-/* Host Control Registers : Host power down */
-#define HOST_POWER_DOWN   (0x1U << 0)
 
 /* Host Control Registers : Host interrupt mask */
 #define HOST_INT_MASK_REG  0x02
@@ -90,10 +89,6 @@
 #define UP_LD_HOST_INT_MASK  (0x1U)
 /* Host Control Registers : Download host interrupt mask */
 #define DN_LD_HOST_INT_MASK  (0x2U)
-/* Enable Host interrupt mask */
-#define HOST_INT_ENABLE (UP_LD_HOST_INT_MASK | DN_LD_HOST_INT_MASK)
-/* Disable Host interrupt mask */
-#define HOST_INT_DISABLE  0xff
 
 /* Host Control Registers : Host interrupt status */
 #define HOST_INTSTATUS_REG  0x03
@@ -104,74 +99,15 @@
 
 /* Host Control Registers : Host interrupt RSR */
 #define HOST_INT_RSR_REG  0x01
-/* Host Control Registers : Upload host interrupt RSR */
-#define UP_LD_HOST_INT_RSR  (0x1U)
-#define SDIO_INT_MASK   0x3F
 
 /* Host Control Registers : Host interrupt status */
 #define HOST_INT_STATUS_REG  0x28
-/* Host Control Registers : Upload CRC error */
-#define UP_LD_CRC_ERR   (0x1U << 2)
-/* Host Control Registers : Upload restart */
-#define UP_LD_RESTART                   (0x1U << 1)
-/* Host Control Registers : Download restart */
-#define DN_LD_RESTART                   (0x1U << 0)
-
-/* Card Control Registers : Card status register */
-#define CARD_STATUS_REG                 0x30
+
 /* Card Control Registers : Card I/O ready */
 #define CARD_IO_READY                   (0x1U << 3)
-/* Card Control Registers : CIS card ready */
-#define CIS_CARD_RDY                    (0x1U << 2)
-/* Card Control Registers : Upload card ready */
-#define UP_LD_CARD_RDY                  (0x1U << 1)
 /* Card Control Registers : Download card ready */
 #define DN_LD_CARD_RDY                  (0x1U << 0)
 
-/* Card Control Registers : Host interrupt mask register */
-#define HOST_INTERRUPT_MASK_REG         0x34
-/* Card Control Registers : Host power interrupt mask */
-#define HOST_POWER_INT_MASK             (0x1U << 3)
-/* Card Control Registers : Abort card interrupt mask */
-#define ABORT_CARD_INT_MASK             (0x1U << 2)
-/* Card Control Registers : Upload card interrupt mask */
-#define UP_LD_CARD_INT_MASK             (0x1U << 1)
-/* Card Control Registers : Download card interrupt mask */
-#define DN_LD_CARD_INT_MASK             (0x1U << 0)
-
-/* Card Control Registers : Card interrupt status register */
-#define CARD_INTERRUPT_STATUS_REG       0x38
-/* Card Control Registers : Power up interrupt */
-#define POWER_UP_INT                    (0x1U << 4)
-/* Card Control Registers : Power down interrupt */
-#define POWER_DOWN_INT                  (0x1U << 3)
-
-/* Card Control Registers : Card interrupt RSR register */
-#define CARD_INTERRUPT_RSR_REG          0x3c
-/* Card Control Registers : Power up RSR */
-#define POWER_UP_RSR                    (0x1U << 4)
-/* Card Control Registers : Power down RSR */
-#define POWER_DOWN_RSR                  (0x1U << 3)
-
-/* Card Control Registers : Miscellaneous Configuration Register */
-#define CARD_MISC_CFG_REG               0x6C
-
-/* Host F1 read base 0 */
-#define HOST_F1_RD_BASE_0  0x0040
-/* Host F1 read base 1 */
-#define HOST_F1_RD_BASE_1  0x0041
-/* Host F1 card ready */
-#define HOST_F1_CARD_RDY  0x0020
-
-/* Firmware status 0 register */
-#define CARD_FW_STATUS0_REG  0x60
-/* Firmware status 1 register */
-#define CARD_FW_STATUS1_REG  0x61
-/* Rx length register */
-#define CARD_RX_LEN_REG   0x62
-/* Rx unit register */
-#define CARD_RX_UNIT_REG  0x63
-
 /* Max retry number of CMD53 write */
 #define MAX_WRITE_IOMEM_RETRY  2
 
@@ -192,7 +128,8 @@
  if (a->mpa_tx.start_port <= port)    \
   a->mpa_tx.ports |= (1<<(a->mpa_tx.pkt_cnt));  \
  else        \
-  a->mpa_tx.ports |= (1<<(a->mpa_tx.pkt_cnt+1+(MAX_PORT - \
+  a->mpa_tx.ports |= (1<<(a->mpa_tx.pkt_cnt+1+  \
+      (a->max_ports - \
       a->mp_end_port))); \
  a->mpa_tx.pkt_cnt++;      \
 } while (0)
@@ -201,12 +138,6 @@
 #define MP_TX_AGGR_PKT_LIMIT_REACHED(a)     \
    (a->mpa_tx.pkt_cnt == a->mpa_tx.pkt_aggr_limit)
 
-/* SDIO Tx aggregation port limit ? */
-#define MP_TX_AGGR_PORT_LIMIT_REACHED(a) ((a->curr_wr_port <  \
-   a->mpa_tx.start_port) && (((MAX_PORT -  \
-   a->mpa_tx.start_port) + a->curr_wr_port) >= \
-    SDIO_MP_AGGR_DEF_PKT_LIMIT))
-
 /* Reset SDIO Tx aggregation buffer parameters */
 #define MP_TX_AGGR_BUF_RESET(a) do {     \
  a->mpa_tx.pkt_cnt = 0;      \
@@ -219,12 +150,6 @@
 #define MP_RX_AGGR_PKT_LIMIT_REACHED(a)     \
    (a->mpa_rx.pkt_cnt == a->mpa_rx.pkt_aggr_limit)
 
-/* SDIO Tx aggregation port limit ? */
-#define MP_RX_AGGR_PORT_LIMIT_REACHED(a) ((a->curr_rd_port <  \
-   a->mpa_rx.start_port) && (((MAX_PORT -  \
-   a->mpa_rx.start_port) + a->curr_rd_port) >= \
-   SDIO_MP_AGGR_DEF_PKT_LIMIT))
-
 /* SDIO Rx aggregation in progress ? */
 #define MP_RX_AGGR_IN_PROGRESS(a) (a->mpa_rx.pkt_cnt > 0)
 
@@ -232,20 +157,6 @@
 #define MP_RX_AGGR_BUF_HAS_ROOM(a, rx_len)    \
    ((a->mpa_rx.buf_len+rx_len) <= a->mpa_rx.buf_size)
 
-/* Prepare to copy current packet from card to SDIO Rx aggregation buffer */
-#define MP_RX_AGGR_SETUP(a, skb, port) do {    \
- a->mpa_rx.buf_len += skb->len;     \
- if (!a->mpa_rx.pkt_cnt)      \
-  a->mpa_rx.start_port = port;    \
- if (a->mpa_rx.start_port <= port)    \
-  a->mpa_rx.ports |= (1<<(a->mpa_rx.pkt_cnt));  \
- else        \
-  a->mpa_rx.ports |= (1<<(a->mpa_rx.pkt_cnt+1));  \
- a->mpa_rx.skb_arr[a->mpa_rx.pkt_cnt] = skb;   \
- a->mpa_rx.len_arr[a->mpa_rx.pkt_cnt] = skb->len;  \
- a->mpa_rx.pkt_cnt++;      \
-} while (0)
-
 /* Reset SDIO Rx aggregation buffer parameters */
 #define MP_RX_AGGR_BUF_RESET(a) do {     \
  a->mpa_rx.pkt_cnt = 0;      \
@@ -254,14 +165,13 @@
  a->mpa_rx.start_port = 0;     \
 } while (0)
 
-
 /* data structure for SDIO MPA TX */
 struct mwifiex_sdio_mpa_tx {
  /* multiport tx aggregation buffer pointer */
  u8 *buf;
  u32 buf_len;
  u32 pkt_cnt;
- u16 ports;
+ u32 ports;
  u16 start_port;
  u8 enabled;
  u32 buf_size;
@@ -272,11 +182,11 @@ struct mwifiex_sdio_mpa_rx {
  u8 *buf;
  u32 buf_len;
  u32 pkt_cnt;
- u16 ports;
+ u32 ports;
  u16 start_port;
 
- struct sk_buff *skb_arr[SDIO_MP_AGGR_DEF_PKT_LIMIT];
- u32 len_arr[SDIO_MP_AGGR_DEF_PKT_LIMIT];
+ struct sk_buff **skb_arr;
+ u32 *len_arr;
 
  u8 enabled;
  u32 buf_size;
@@ -286,15 +196,50 @@ struct mwifiex_sdio_mpa_rx {
 int mwifiex_bus_register(void);
 void mwifiex_bus_unregister(void);
 
+struct mwifiex_sdio_card_reg {
+ u8 start_rd_port;
+ u8 start_wr_port;
+ u8 base_0_reg;
+ u8 base_1_reg;
+ u8 poll_reg;
+ u8 host_int_enable;
+ u8 status_reg_0;
+ u8 status_reg_1;
+ u8 sdio_int_mask;
+ u32 data_port_mask;
+ u8 max_mp_regs;
+ u8 rd_bitmap_l;
+ u8 rd_bitmap_u;
+ u8 rd_bitmap_1l;
+ u8 rd_bitmap_1u;
+ u8 wr_bitmap_l;
+ u8 wr_bitmap_u;
+ u8 wr_bitmap_1l;
+ u8 wr_bitmap_1u;
+ u8 rd_len_p0_l;
+ u8 rd_len_p0_u;
+ u8 card_misc_cfg_reg;
+};
+
 struct sdio_mmc_card {
  struct sdio_func *func;
  struct mwifiex_adapter *adapter;
 
- u16 mp_rd_bitmap;
- u16 mp_wr_bitmap;
+ const char *firmware;
+ const struct mwifiex_sdio_card_reg *reg;
+ u8 max_ports;
+ u8 mp_agg_pkt_limit;
+ bool supports_sdio_new_mode;
+ bool has_control_mask;
+ u16 tx_buf_size;
+ u32 mp_tx_agg_buf_size;
+ u32 mp_rx_agg_buf_size;
+
+ u32 mp_rd_bitmap;
+ u32 mp_wr_bitmap;
 
  u16 mp_end_port;
- u16 mp_data_port_mask;
+ u32 mp_data_port_mask;
 
  u8 curr_rd_port;
  u8 curr_wr_port;
@@ -305,6 +250,113 @@ struct sdio_mmc_card {
  struct mwifiex_sdio_mpa_rx mpa_rx;
 };
 
+struct mwifiex_sdio_device {
+ const char *firmware;
+ const struct mwifiex_sdio_card_reg *reg;
+ u8 max_ports;
+ u8 mp_agg_pkt_limit;
+ bool supports_sdio_new_mode;
+ bool has_control_mask;
+ u16 tx_buf_size;
+ u32 mp_tx_agg_buf_size;
+ u32 mp_rx_agg_buf_size;
+};
+
+static const struct mwifiex_sdio_card_reg mwifiex_reg_sd87xx = {
+ .start_rd_port = 1,
+ .start_wr_port = 1,
+ .base_0_reg = 0x0040,
+ .base_1_reg = 0x0041,
+ .poll_reg = 0x30,
+ .host_int_enable = UP_LD_HOST_INT_MASK | DN_LD_HOST_INT_MASK,
+ .status_reg_0 = 0x60,
+ .status_reg_1 = 0x61,
+ .sdio_int_mask = 0x3f,
+ .data_port_mask = 0x0000fffe,
+ .max_mp_regs = 64,
+ .rd_bitmap_l = 0x04,
+ .rd_bitmap_u = 0x05,
+ .wr_bitmap_l = 0x06,
+ .wr_bitmap_u = 0x07,
+ .rd_len_p0_l = 0x08,
+ .rd_len_p0_u = 0x09,
+ .card_misc_cfg_reg = 0x6c,
+};
+
+static const struct mwifiex_sdio_card_reg mwifiex_reg_sd8897 = {
+ .start_rd_port = 0,
+ .start_wr_port = 0,
+ .base_0_reg = 0x60,
+ .base_1_reg = 0x61,
+ .poll_reg = 0x50,
+ .host_int_enable = UP_LD_HOST_INT_MASK | DN_LD_HOST_INT_MASK |
+   CMD_PORT_UPLD_INT_MASK | CMD_PORT_DNLD_INT_MASK,
+ .status_reg_0 = 0xc0,
+ .status_reg_1 = 0xc1,
+ .sdio_int_mask = 0xff,
+ .data_port_mask = 0xffffffff,
+ .max_mp_regs = 184,
+ .rd_bitmap_l = 0x04,
+ .rd_bitmap_u = 0x05,
+ .rd_bitmap_1l = 0x06,
+ .rd_bitmap_1u = 0x07,
+ .wr_bitmap_l = 0x08,
+ .wr_bitmap_u = 0x09,
+ .wr_bitmap_1l = 0x0a,
+ .wr_bitmap_1u = 0x0b,
+ .rd_len_p0_l = 0x0c,
+ .rd_len_p0_u = 0x0d,
+ .card_misc_cfg_reg = 0xcc,
+};
+
+static const struct mwifiex_sdio_device mwifiex_sdio_sd8786 = {
+ .firmware = SD8786_DEFAULT_FW_NAME,
+ .reg = &mwifiex_reg_sd87xx,
+ .max_ports = 16,
+ .mp_agg_pkt_limit = 8,
+ .supports_sdio_new_mode = false,
+ .has_control_mask = true,
+ .tx_buf_size = MWIFIEX_TX_DATA_BUF_SIZE_2K,
+ .mp_tx_agg_buf_size = MWIFIEX_MP_AGGR_BUF_SIZE_16K,
+ .mp_rx_agg_buf_size = MWIFIEX_MP_AGGR_BUF_SIZE_16K,
+};
+
+static const struct mwifiex_sdio_device mwifiex_sdio_sd8787 = {
+ .firmware = SD8787_DEFAULT_FW_NAME,
+ .reg = &mwifiex_reg_sd87xx,
+ .max_ports = 16,
+ .mp_agg_pkt_limit = 8,
+ .supports_sdio_new_mode = false,
+ .has_control_mask = true,
+ .tx_buf_size = MWIFIEX_TX_DATA_BUF_SIZE_2K,
+ .mp_tx_agg_buf_size = MWIFIEX_MP_AGGR_BUF_SIZE_16K,
+ .mp_rx_agg_buf_size = MWIFIEX_MP_AGGR_BUF_SIZE_16K,
+};
+
+static const struct mwifiex_sdio_device mwifiex_sdio_sd8797 = {
+ .firmware = SD8797_DEFAULT_FW_NAME,
+ .reg = &mwifiex_reg_sd87xx,
+ .max_ports = 16,
+ .mp_agg_pkt_limit = 8,
+ .supports_sdio_new_mode = false,
+ .has_control_mask = true,
+ .tx_buf_size = MWIFIEX_TX_DATA_BUF_SIZE_2K,
+ .mp_tx_agg_buf_size = MWIFIEX_MP_AGGR_BUF_SIZE_16K,
+ .mp_rx_agg_buf_size = MWIFIEX_MP_AGGR_BUF_SIZE_16K,
+};
+
+static const struct mwifiex_sdio_device mwifiex_sdio_sd8897 = {
+ .firmware = SD8897_DEFAULT_FW_NAME,
+ .reg = &mwifiex_reg_sd8897,
+ .max_ports = 32,
+ .mp_agg_pkt_limit = 16,
+ .supports_sdio_new_mode = true,
+ .has_control_mask = false,
+ .tx_buf_size = MWIFIEX_TX_DATA_BUF_SIZE_4K,
+ .mp_tx_agg_buf_size = MWIFIEX_MP_AGGR_BUF_SIZE_32K,
+ .mp_rx_agg_buf_size = MWIFIEX_MP_AGGR_BUF_SIZE_32K,
+};
+
 /*
  * .cmdrsp_complete handler
  */
@@ -325,4 +377,77 @@ static inline int mwifiex_sdio_event_complete(struct mwifiex_adapter *adapter,
  return 0;
 }
 
+static inline bool
+mp_rx_aggr_port_limit_reached(struct sdio_mmc_card *card)
+{
+ u8 tmp;
+
+ if (card->curr_rd_port < card->mpa_rx.start_port) {
+  if (card->supports_sdio_new_mode)
+   tmp = card->mp_end_port >> 1;
+  else
+   tmp = card->mp_agg_pkt_limit;
+
+  if (((card->max_ports - card->mpa_rx.start_port) +
+      card->curr_rd_port) >= tmp)
+   return true;
+ }
+
+ if (!card->supports_sdio_new_mode)
+  return false;
+
+ if ((card->curr_rd_port - card->mpa_rx.start_port) >=
+     (card->mp_end_port >> 1))
+  return true;
+
+ return false;
+}
+
+static inline bool
+mp_tx_aggr_port_limit_reached(struct sdio_mmc_card *card)
+{
+ u16 tmp;
+
+ if (card->curr_wr_port < card->mpa_tx.start_port) {
+  if (card->supports_sdio_new_mode)
+   tmp = card->mp_end_port >> 1;
+  else
+   tmp = card->mp_agg_pkt_limit;
+
+  if (((card->max_ports - card->mpa_tx.start_port) +
+      card->curr_wr_port) >= tmp)
+   return true;
+ }
+
+ if (!card->supports_sdio_new_mode)
+  return false;
+
+ if ((card->curr_wr_port - card->mpa_tx.start_port) >=
+     (card->mp_end_port >> 1))
+  return true;
+
+ return false;
+}
+
+/* Prepare to copy current packet from card to SDIO Rx aggregation buffer */
+static inline void mp_rx_aggr_setup(struct sdio_mmc_card *card,
+        struct sk_buff *skb, u8 port)
+{
+ card->mpa_rx.buf_len += skb->len;
+
+ if (!card->mpa_rx.pkt_cnt)
+  card->mpa_rx.start_port = port;
+
+ if (card->supports_sdio_new_mode) {
+  card->mpa_rx.ports |= (1 << port);
+ } else {
+  if (card->mpa_rx.start_port <= port)
+   card->mpa_rx.ports |= 1 << (card->mpa_rx.pkt_cnt);
+  else
+   card->mpa_rx.ports |= 1 << (card->mpa_rx.pkt_cnt + 1);
+ }
+ card->mpa_rx.skb_arr[card->mpa_rx.pkt_cnt] = skb;
+ card->mpa_rx.len_arr[card->mpa_rx.pkt_cnt] = skb->len;
+ card->mpa_rx.pkt_cnt++;
+}
 #endif /* _MWIFIEX_SDIO_H */
diff --git a/drivers/net/wireless/mwifiex/sta_cmd.c b/drivers/net/wireless/mwifiex/sta_cmd.c
index b193e25..88202ce 100644
--- a/drivers/net/wireless/mwifiex/sta_cmd.c
+++ b/drivers/net/wireless/mwifiex/sta_cmd.c
@@ -185,6 +185,13 @@ static int mwifiex_cmd_tx_rate_cfg(struct mwifiex_private *priv,
        i++)
    rate_scope->ht_mcs_rate_bitmap[i] =
     cpu_to_le16(pbitmap_rates[2 + i]);
+  if (priv->adapter->fw_api_ver == MWIFIEX_FW_V15) {
+   for (i = 0;
+        i < ARRAY_SIZE(rate_scope->vht_mcs_rate_bitmap);
+        i++)
+    rate_scope->vht_mcs_rate_bitmap[i] =
+     cpu_to_le16(pbitmap_rates[10 + i]);
+  }
  } else {
   rate_scope->hr_dsss_rate_bitmap =
    cpu_to_le16(priv->bitmap_rates[0]);
@@ -195,6 +202,13 @@ static int mwifiex_cmd_tx_rate_cfg(struct mwifiex_private *priv,
        i++)
    rate_scope->ht_mcs_rate_bitmap[i] =
     cpu_to_le16(priv->bitmap_rates[2 + i]);
+  if (priv->adapter->fw_api_ver == MWIFIEX_FW_V15) {
+   for (i = 0;
+        i < ARRAY_SIZE(rate_scope->vht_mcs_rate_bitmap);
+        i++)
+    rate_scope->vht_mcs_rate_bitmap[i] =
+     cpu_to_le16(priv->bitmap_rates[10 + i]);
+  }
  }
 
  rate_drop = (struct mwifiex_rate_drop_pattern *) ((u8 *) rate_scope +
@@ -239,14 +253,14 @@ static int mwifiex_cmd_tx_power_cfg(struct host_cmd_ds_command *cmd,
    memmove(cmd_txp_cfg, txp,
     sizeof(struct host_cmd_ds_txpwr_cfg) +
     sizeof(struct mwifiex_types_power_group) +
-    pg_tlv->length);
+    le16_to_cpu(pg_tlv->length));
 
    pg_tlv = (struct mwifiex_types_power_group *) ((u8 *)
       cmd_txp_cfg +
       sizeof(struct host_cmd_ds_txpwr_cfg));
    cmd->size = cpu_to_le16(le16_to_cpu(cmd->size) +
       sizeof(struct mwifiex_types_power_group) +
-      pg_tlv->length);
+      le16_to_cpu(pg_tlv->length));
   } else {
    memmove(cmd_txp_cfg, txp, sizeof(*txp));
   }
@@ -327,7 +341,7 @@ mwifiex_cmd_802_11_hs_cfg(struct mwifiex_private *priv,
 {
  struct mwifiex_adapter *adapter = priv->adapter;
  struct host_cmd_ds_802_11_hs_cfg_enh *hs_cfg = &cmd->params.opt_hs_cfg;
- u16 hs_activate = false;
+ bool hs_activate = false;
 
  if (!hscfg_param)
   /* New Activate command */
@@ -354,7 +368,7 @@ mwifiex_cmd_802_11_hs_cfg(struct mwifiex_private *priv,
  }
  if (hs_activate) {
   hs_cfg->action = cpu_to_le16(HS_ACTIVATE);
-  hs_cfg->params.hs_activate.resp_ctrl = RESP_NEEDED;
+  hs_cfg->params.hs_activate.resp_ctrl = cpu_to_le16(RESP_NEEDED);
  } else {
   hs_cfg->action = cpu_to_le16(HS_CONFIGURE);
   hs_cfg->params.hs_config.conditions = hscfg_param->conditions;
@@ -532,8 +546,228 @@ mwifiex_set_keyparamset_wep(struct mwifiex_private *priv,
  return 0;
 }
 
+/* This function populates key material v2 command
+ * to set network key for AES & CMAC AES.
+ */
+static int mwifiex_set_aes_key_v2(struct mwifiex_private *priv,
+      struct host_cmd_ds_command *cmd,
+      struct mwifiex_ds_encrypt_key *enc_key,
+      struct host_cmd_ds_802_11_key_material_v2 *km)
+{
+ struct mwifiex_adapter *adapter = priv->adapter;
+ u16 size, len = KEY_PARAMS_FIXED_LEN;
+
+ if (enc_key->is_igtk_key) {
+  dev_dbg(adapter->dev, "%s: Set CMAC AES Key\n", __func__);
+  if (enc_key->is_rx_seq_valid)
+   memcpy(km->key_param_set.key_params.cmac_aes.ipn,
+          enc_key->pn, enc_key->pn_len);
+  km->key_param_set.key_info &= cpu_to_le16(~KEY_MCAST);
+  km->key_param_set.key_info |= cpu_to_le16(KEY_IGTK);
+  km->key_param_set.key_type = KEY_TYPE_ID_AES_CMAC;
+  km->key_param_set.key_params.cmac_aes.key_len =
+       cpu_to_le16(enc_key->key_len);
+  memcpy(km->key_param_set.key_params.cmac_aes.key,
+         enc_key->key_material, enc_key->key_len);
+  len += sizeof(struct mwifiex_cmac_aes_param);
+ } else {
+  dev_dbg(adapter->dev, "%s: Set AES Key\n", __func__);
+  if (enc_key->is_rx_seq_valid)
+   memcpy(km->key_param_set.key_params.aes.pn,
+          enc_key->pn, enc_key->pn_len);
+  km->key_param_set.key_type = KEY_TYPE_ID_AES;
+  km->key_param_set.key_params.aes.key_len =
+       cpu_to_le16(enc_key->key_len);
+  memcpy(km->key_param_set.key_params.aes.key,
+         enc_key->key_material, enc_key->key_len);
+  len += sizeof(struct mwifiex_aes_param);
+ }
+
+ km->key_param_set.len = cpu_to_le16(len);
+ size = len + sizeof(struct mwifiex_ie_types_header) +
+        sizeof(km->action) + S_DS_GEN;
+ cmd->size = cpu_to_le16(size);
+
+ return 0;
+}
+
+/* This function prepares command to set/get/reset network key(s).
+ * This function prepares key material command for V2 format.
+ * Preparation includes -
+ *      - Setting command ID, action and proper size
+ *      - Setting WEP keys, WAPI keys or WPA keys along with required
+ *        encryption (TKIP, AES) (as required)
+ *      - Ensuring correct endian-ness
+ */
+static int
+mwifiex_cmd_802_11_key_material_v2(struct mwifiex_private *priv,
+       struct host_cmd_ds_command *cmd,
+       u16 cmd_action, u32 cmd_oid,
+       struct mwifiex_ds_encrypt_key *enc_key)
+{
+ struct mwifiex_adapter *adapter = priv->adapter;
+ u8 *mac = enc_key->mac_addr;
+ u16 key_info, len = KEY_PARAMS_FIXED_LEN;
+ struct host_cmd_ds_802_11_key_material_v2 *km =
+      &cmd->params.key_material_v2;
+
+ cmd->command = cpu_to_le16(HostCmd_CMD_802_11_KEY_MATERIAL);
+ km->action = cpu_to_le16(cmd_action);
+
+ if (cmd_action == HostCmd_ACT_GEN_GET) {
+  dev_dbg(adapter->dev, "%s: Get key\n", __func__);
+  km->key_param_set.key_idx =
+     enc_key->key_index & KEY_INDEX_MASK;
+  km->key_param_set.type = cpu_to_le16(TLV_TYPE_KEY_PARAM_V2);
+  km->key_param_set.len = cpu_to_le16(KEY_PARAMS_FIXED_LEN);
+  memcpy(km->key_param_set.mac_addr, mac, ETH_ALEN);
+
+  if (enc_key->key_index & MWIFIEX_KEY_INDEX_UNICAST)
+   key_info = KEY_UNICAST;
+  else
+   key_info = KEY_MCAST;
+
+  if (enc_key->is_igtk_key)
+   key_info |= KEY_IGTK;
+
+  km->key_param_set.key_info = cpu_to_le16(key_info);
+
+  cmd->size = cpu_to_le16(sizeof(struct mwifiex_ie_types_header) +
+     S_DS_GEN + KEY_PARAMS_FIXED_LEN +
+     sizeof(km->action));
+  return 0;
+ }
+
+ memset(&km->key_param_set, 0,
+        sizeof(struct mwifiex_ie_type_key_param_set_v2));
+
+ if (enc_key->key_disable) {
+  dev_dbg(adapter->dev, "%s: Remove key\n", __func__);
+  km->action = cpu_to_le16(HostCmd_ACT_GEN_REMOVE);
+  km->key_param_set.type = cpu_to_le16(TLV_TYPE_KEY_PARAM_V2);
+  km->key_param_set.len = cpu_to_le16(KEY_PARAMS_FIXED_LEN);
+  km->key_param_set.key_idx = enc_key->key_index & KEY_INDEX_MASK;
+  key_info = KEY_MCAST | KEY_UNICAST;
+  km->key_param_set.key_info = cpu_to_le16(key_info);
+  memcpy(km->key_param_set.mac_addr, mac, ETH_ALEN);
+  cmd->size = cpu_to_le16(sizeof(struct mwifiex_ie_types_header) +
+     S_DS_GEN + KEY_PARAMS_FIXED_LEN +
+     sizeof(km->action));
+  return 0;
+ }
+
+ km->action = cpu_to_le16(HostCmd_ACT_GEN_SET);
+ km->key_param_set.key_idx = enc_key->key_index & KEY_INDEX_MASK;
+ km->key_param_set.type = cpu_to_le16(TLV_TYPE_KEY_PARAM_V2);
+ key_info = KEY_ENABLED;
+ memcpy(km->key_param_set.mac_addr, mac, ETH_ALEN);
+
+ if (enc_key->key_len <= WLAN_KEY_LEN_WEP104) {
+  dev_dbg(adapter->dev, "%s: Set WEP Key\n", __func__);
+  len += sizeof(struct mwifiex_wep_param);
+  km->key_param_set.len = cpu_to_le16(len);
+  km->key_param_set.key_type = KEY_TYPE_ID_WEP;
+
+  if (GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_UAP) {
+    key_info |= KEY_MCAST | KEY_UNICAST;
+  } else {
+   if (enc_key->is_current_wep_key) {
+    key_info |= KEY_MCAST | KEY_UNICAST;
+    if (km->key_param_set.key_idx ==
+        (priv->wep_key_curr_index & KEY_INDEX_MASK))
+     key_info |= KEY_DEFAULT;
+   } else {
+    if (mac) {
+     if (is_broadcast_ether_addr(mac))
+      key_info |= KEY_MCAST;
+     else
+      key_info |= KEY_UNICAST |
+           KEY_DEFAULT;
+    } else {
+     key_info |= KEY_MCAST;
+    }
+   }
+  }
+  km->key_param_set.key_info = cpu_to_le16(key_info);
+
+  km->key_param_set.key_params.wep.key_len =
+        cpu_to_le16(enc_key->key_len);
+  memcpy(km->key_param_set.key_params.wep.key,
+         enc_key->key_material, enc_key->key_len);
+
+  cmd->size = cpu_to_le16(sizeof(struct mwifiex_ie_types_header) +
+     len + sizeof(km->action) + S_DS_GEN);
+  return 0;
+ }
+
+ if (is_broadcast_ether_addr(mac))
+  key_info |= KEY_MCAST | KEY_RX_KEY;
+ else
+  key_info |= KEY_UNICAST | KEY_TX_KEY | KEY_RX_KEY;
+
+ if (enc_key->is_wapi_key) {
+  dev_dbg(adapter->dev, "%s: Set WAPI Key\n", __func__);
+  km->key_param_set.key_type = KEY_TYPE_ID_WAPI;
+  memcpy(km->key_param_set.key_params.wapi.pn, enc_key->pn,
+         PN_LEN);
+  km->key_param_set.key_params.wapi.key_len =
+      cpu_to_le16(enc_key->key_len);
+  memcpy(km->key_param_set.key_params.wapi.key,
+         enc_key->key_material, enc_key->key_len);
+  if (is_broadcast_ether_addr(mac))
+   priv->sec_info.wapi_key_on = true;
+
+  if (!priv->sec_info.wapi_key_on)
+   key_info |= KEY_DEFAULT;
+  km->key_param_set.key_info = cpu_to_le16(key_info);
+
+  len += sizeof(struct mwifiex_wapi_param);
+  km->key_param_set.len = cpu_to_le16(len);
+  cmd->size = cpu_to_le16(sizeof(struct mwifiex_ie_types_header) +
+     len + sizeof(km->action) + S_DS_GEN);
+  return 0;
+ }
+
+ if (priv->bss_mode == NL80211_IFTYPE_ADHOC) {
+  key_info |= KEY_DEFAULT;
+  /* Enable unicast bit for WPA-NONE/ADHOC_AES */
+  if (!priv->sec_info.wpa2_enabled &&
+      !is_broadcast_ether_addr(mac))
+   key_info |= KEY_UNICAST;
+ } else {
+  /* Enable default key for WPA/WPA2 */
+  if (!priv->wpa_is_gtk_set)
+   key_info |= KEY_DEFAULT;
+ }
+
+ km->key_param_set.key_info = cpu_to_le16(key_info);
+
+ if (enc_key->key_len == WLAN_KEY_LEN_CCMP)
+  return mwifiex_set_aes_key_v2(priv, cmd, enc_key, km);
+
+ if (enc_key->key_len == WLAN_KEY_LEN_TKIP) {
+  dev_dbg(adapter->dev, "%s: Set TKIP Key\n", __func__);
+  if (enc_key->is_rx_seq_valid)
+   memcpy(km->key_param_set.key_params.tkip.pn,
+          enc_key->pn, enc_key->pn_len);
+  km->key_param_set.key_type = KEY_TYPE_ID_TKIP;
+  km->key_param_set.key_params.tkip.key_len =
+      cpu_to_le16(enc_key->key_len);
+  memcpy(km->key_param_set.key_params.tkip.key,
+         enc_key->key_material, enc_key->key_len);
+
+  len += sizeof(struct mwifiex_tkip_param);
+  km->key_param_set.len = cpu_to_le16(len);
+  cmd->size = cpu_to_le16(sizeof(struct mwifiex_ie_types_header) +
+     len + sizeof(km->action) + S_DS_GEN);
+ }
+
+ return 0;
+}
+
 /*
  * This function prepares command to set/get/reset network key(s).
+ * This function prepares key material command for V1 format.
  *
  * Preparation includes -
  *      - Setting command ID, action and proper size
@@ -542,10 +776,10 @@ mwifiex_set_keyparamset_wep(struct mwifiex_private *priv,
  *      - Ensuring correct endian-ness
  */
 static int
-mwifiex_cmd_802_11_key_material(struct mwifiex_private *priv,
-    struct host_cmd_ds_command *cmd,
-    u16 cmd_action, u32 cmd_oid,
-    struct mwifiex_ds_encrypt_key *enc_key)
+mwifiex_cmd_802_11_key_material_v1(struct mwifiex_private *priv,
+       struct host_cmd_ds_command *cmd,
+       u16 cmd_action, u32 cmd_oid,
+       struct mwifiex_ds_encrypt_key *enc_key)
 {
  struct host_cmd_ds_802_11_key_material *key_material =
   &cmd->params.key_material;
@@ -707,8 +941,9 @@ mwifiex_cmd_802_11_key_material(struct mwifiex_private *priv,
   if (priv->bss_type == MWIFIEX_BSS_TYPE_UAP) {
    tlv_mac = (void *)((u8 *)&key_material->key_param_set +
         key_param_len);
-   tlv_mac->tlv.type = cpu_to_le16(TLV_TYPE_STA_MAC_ADDR);
-   tlv_mac->tlv.len = cpu_to_le16(ETH_ALEN);
+   tlv_mac->header.type =
+     cpu_to_le16(TLV_TYPE_STA_MAC_ADDR);
+   tlv_mac->header.len = cpu_to_le16(ETH_ALEN);
    memcpy(tlv_mac->mac_addr, enc_key->mac_addr, ETH_ALEN);
    cmd_size = key_param_len + S_DS_GEN +
        sizeof(key_material->action) +
@@ -723,6 +958,24 @@ mwifiex_cmd_802_11_key_material(struct mwifiex_private *priv,
  return ret;
 }
 
+/* Wrapper function for setting network key depending upon FW KEY API version */
+static int
+mwifiex_cmd_802_11_key_material(struct mwifiex_private *priv,
+    struct host_cmd_ds_command *cmd,
+    u16 cmd_action, u32 cmd_oid,
+    struct mwifiex_ds_encrypt_key *enc_key)
+{
+ if (priv->adapter->fw_key_api_major_ver == FW_KEY_API_VER_MAJOR_V2)
+  return mwifiex_cmd_802_11_key_material_v2(priv, cmd,
+         cmd_action, cmd_oid,
+         enc_key);
+
+ else
+  return mwifiex_cmd_802_11_key_material_v1(priv, cmd,
+         cmd_action, cmd_oid,
+         enc_key);
+}
+
 /*
  * This function prepares command to set/get 11d domain information.
  *
@@ -1069,7 +1322,7 @@ mwifiex_cmd_append_rpn_expression(struct mwifiex_private *priv,
  int i, byte_len;
  u8 *stack_ptr = *buffer;
 
- for (i = 0; i < MWIFIEX_MAX_FILTERS; i++) {
+ for (i = 0; i < MWIFIEX_MEF_MAX_FILTERS; i++) {
   filter = &mef_entry->filter[i];
   if (!filter->filt_type)
    break;
@@ -1078,7 +1331,7 @@ mwifiex_cmd_append_rpn_expression(struct mwifiex_private *priv,
   *stack_ptr = TYPE_DNUM;
   stack_ptr += 1;
 
-  byte_len = filter->byte_seq[MAX_BYTESEQ];
+  byte_len = filter->byte_seq[MWIFIEX_MEF_MAX_BYTESEQ];
   memcpy(stack_ptr, filter->byte_seq, byte_len);
   stack_ptr += byte_len;
   *stack_ptr = byte_len;
@@ -1134,6 +1387,279 @@ mwifiex_cmd_mef_cfg(struct mwifiex_private *priv,
  return 0;
 }
 
+/* This function parse cal data from ASCII to hex */
+static u32 mwifiex_parse_cal_cfg(u8 *src, size_t len, u8 *dst)
+{
+ u8 *s = src, *d = dst;
+
+ while (s - src < len) {
+  if (*s && (isspace(*s) || *s == '\t')) {
+   s++;
+   continue;
+  }
+  if (isxdigit(*s)) {
+   *d++ = simple_strtol(s, NULL, 16);
+   s += 2;
+  } else {
+   s++;
+  }
+ }
+
+ return d - dst;
+}
+
+int mwifiex_dnld_dt_cfgdata(struct mwifiex_private *priv,
+       struct device_node *node, const char *prefix)
+{
+#ifdef CONFIG_OF
+ struct property *prop;
+ size_t len = strlen(prefix);
+ int ret;
+
+ /* look for all matching property names */
+ for_each_property_of_node(node, prop) {
+  if (len > strlen(prop->name) ||
+      strncmp(prop->name, prefix, len))
+   continue;
+
+  /* property header is 6 bytes, data must fit in cmd buffer */
+  if (prop && prop->value && prop->length > 6 &&
+      prop->length <= MWIFIEX_SIZE_OF_CMD_BUFFER - S_DS_GEN) {
+   ret = mwifiex_send_cmd(priv, HostCmd_CMD_CFG_DATA,
+            HostCmd_ACT_GEN_SET, 0,
+            prop, true);
+   if (ret)
+    return ret;
+  }
+ }
+#endif
+ return 0;
+}
+
+/* This function prepares command of set_cfg_data. */
+static int mwifiex_cmd_cfg_data(struct mwifiex_private *priv,
+    struct host_cmd_ds_command *cmd, void *data_buf)
+{
+ struct mwifiex_adapter *adapter = priv->adapter;
+ struct property *prop = data_buf;
+ u32 len;
+ u8 *data = (u8 *)cmd + S_DS_GEN;
+ int ret;
+
+ if (prop) {
+  len = prop->length;
+  ret = of_property_read_u8_array(adapter->dt_node, prop->name,
+      data, len);
+  if (ret)
+   return ret;
+  dev_dbg(adapter->dev,
+   "download cfg_data from device tree: %s\n", prop->name);
+ } else if (adapter->cal_data->data && adapter->cal_data->size > 0) {
+  len = mwifiex_parse_cal_cfg((u8 *)adapter->cal_data->data,
+         adapter->cal_data->size, data);
+  dev_dbg(adapter->dev, "download cfg_data from config file\n");
+ } else {
+  return -1;
+ }
+
+ cmd->command = cpu_to_le16(HostCmd_CMD_CFG_DATA);
+ cmd->size = cpu_to_le16(S_DS_GEN + len);
+
+ return 0;
+}
+
+static int
+mwifiex_cmd_coalesce_cfg(struct mwifiex_private *priv,
+    struct host_cmd_ds_command *cmd,
+    u16 cmd_action, void *data_buf)
+{
+ struct host_cmd_ds_coalesce_cfg *coalesce_cfg =
+      &cmd->params.coalesce_cfg;
+ struct mwifiex_ds_coalesce_cfg *cfg = data_buf;
+ struct coalesce_filt_field_param *param;
+ u16 cnt, idx, length;
+ struct coalesce_receive_filt_rule *rule;
+
+ cmd->command = cpu_to_le16(HostCmd_CMD_COALESCE_CFG);
+ cmd->size = cpu_to_le16(S_DS_GEN);
+
+ coalesce_cfg->action = cpu_to_le16(cmd_action);
+ coalesce_cfg->num_of_rules = cpu_to_le16(cfg->num_of_rules);
+ rule = coalesce_cfg->rule;
+
+ for (cnt = 0; cnt < cfg->num_of_rules; cnt++) {
+  rule->header.type = cpu_to_le16(TLV_TYPE_COALESCE_RULE);
+  rule->max_coalescing_delay =
+   cpu_to_le16(cfg->rule[cnt].max_coalescing_delay);
+  rule->pkt_type = cfg->rule[cnt].pkt_type;
+  rule->num_of_fields = cfg->rule[cnt].num_of_fields;
+
+  length = 0;
+
+  param = rule->params;
+  for (idx = 0; idx < cfg->rule[cnt].num_of_fields; idx++) {
+   param->operation = cfg->rule[cnt].params[idx].operation;
+   param->operand_len =
+     cfg->rule[cnt].params[idx].operand_len;
+   param->offset =
+    cpu_to_le16(cfg->rule[cnt].params[idx].offset);
+   memcpy(param->operand_byte_stream,
+          cfg->rule[cnt].params[idx].operand_byte_stream,
+          param->operand_len);
+
+   length += sizeof(struct coalesce_filt_field_param);
+
+   param++;
+  }
+
+  /* Total rule length is sizeof max_coalescing_delay(u16),
+   * num_of_fields(u8), pkt_type(u8) and total length of the all
+   * params
+   */
+  rule->header.len = cpu_to_le16(length + sizeof(u16) +
+            sizeof(u8) + sizeof(u8));
+
+  /* Add the rule length to the command size*/
+  le16_add_cpu(&cmd->size, le16_to_cpu(rule->header.len) +
+        sizeof(struct mwifiex_ie_types_header));
+
+  rule = (void *)((u8 *)rule->params + length);
+ }
+
+ /* Add sizeof action, num_of_rules to total command length */
+ le16_add_cpu(&cmd->size, sizeof(u16) + sizeof(u16));
+
+ return 0;
+}
+
+static int
+mwifiex_cmd_tdls_oper(struct mwifiex_private *priv,
+        struct host_cmd_ds_command *cmd,
+        void *data_buf)
+{
+ struct host_cmd_ds_tdls_oper *tdls_oper = &cmd->params.tdls_oper;
+ struct mwifiex_ds_tdls_oper *oper = data_buf;
+ struct mwifiex_sta_node *sta_ptr;
+ struct host_cmd_tlv_rates *tlv_rates;
+ struct mwifiex_ie_types_htcap *ht_capab;
+ struct mwifiex_ie_types_qos_info *wmm_qos_info;
+ struct mwifiex_ie_types_extcap *extcap;
+ struct mwifiex_ie_types_vhtcap *vht_capab;
+ struct mwifiex_ie_types_aid *aid;
+ struct mwifiex_ie_types_tdls_idle_timeout *timeout;
+ u8 *pos, qos_info;
+ u16 config_len = 0;
+ struct station_parameters *params = priv->sta_params;
+
+ cmd->command = cpu_to_le16(HostCmd_CMD_TDLS_OPER);
+ cmd->size = cpu_to_le16(S_DS_GEN);
+ le16_add_cpu(&cmd->size, sizeof(struct host_cmd_ds_tdls_oper));
+
+ tdls_oper->reason = 0;
+ memcpy(tdls_oper->peer_mac, oper->peer_mac, ETH_ALEN);
+ sta_ptr = mwifiex_get_sta_entry(priv, oper->peer_mac);
+
+ pos = (u8 *)tdls_oper + sizeof(struct host_cmd_ds_tdls_oper);
+
+ switch (oper->tdls_action) {
+ case MWIFIEX_TDLS_DISABLE_LINK:
+  tdls_oper->tdls_action = cpu_to_le16(ACT_TDLS_DELETE);
+  break;
+ case MWIFIEX_TDLS_CREATE_LINK:
+  tdls_oper->tdls_action = cpu_to_le16(ACT_TDLS_CREATE);
+  break;
+ case MWIFIEX_TDLS_CONFIG_LINK:
+  tdls_oper->tdls_action = cpu_to_le16(ACT_TDLS_CONFIG);
+
+  if (!params) {
+   dev_err(priv->adapter->dev,
+    "TDLS config params not available for %pM\n",
+    oper->peer_mac);
+   return -ENODATA;
+  }
+
+  *(__le16 *)pos = cpu_to_le16(params->capability);
+  config_len += sizeof(params->capability);
+
+  qos_info = params->uapsd_queues | (params->max_sp << 5);
+  wmm_qos_info = (struct mwifiex_ie_types_qos_info *)(pos +
+            config_len);
+  wmm_qos_info->header.type = cpu_to_le16(WLAN_EID_QOS_CAPA);
+  wmm_qos_info->header.len = cpu_to_le16(sizeof(qos_info));
+  wmm_qos_info->qos_info = qos_info;
+  config_len += sizeof(struct mwifiex_ie_types_qos_info);
+
+  if (params->ht_capa) {
+   ht_capab = (struct mwifiex_ie_types_htcap *)(pos +
+            config_len);
+   ht_capab->header.type =
+         cpu_to_le16(WLAN_EID_HT_CAPABILITY);
+   ht_capab->header.len =
+       cpu_to_le16(sizeof(struct ieee80211_ht_cap));
+   memcpy(&ht_capab->ht_cap, params->ht_capa,
+          sizeof(struct ieee80211_ht_cap));
+   config_len += sizeof(struct mwifiex_ie_types_htcap);
+  }
+
+  if (params->supported_rates && params->supported_rates_len) {
+   tlv_rates = (struct host_cmd_tlv_rates *)(pos +
+          config_len);
+   tlv_rates->header.type =
+            cpu_to_le16(WLAN_EID_SUPP_RATES);
+   tlv_rates->header.len =
+           cpu_to_le16(params->supported_rates_len);
+   memcpy(tlv_rates->rates, params->supported_rates,
+          params->supported_rates_len);
+   config_len += sizeof(struct host_cmd_tlv_rates) +
+          params->supported_rates_len;
+  }
+
+  if (params->ext_capab && params->ext_capab_len) {
+   extcap = (struct mwifiex_ie_types_extcap *)(pos +
+            config_len);
+   extcap->header.type =
+        cpu_to_le16(WLAN_EID_EXT_CAPABILITY);
+   extcap->header.len = cpu_to_le16(params->ext_capab_len);
+   memcpy(extcap->ext_capab, params->ext_capab,
+          params->ext_capab_len);
+   config_len += sizeof(struct mwifiex_ie_types_extcap) +
+          params->ext_capab_len;
+  }
+  if (params->vht_capa) {
+   vht_capab = (struct mwifiex_ie_types_vhtcap *)(pos +
+            config_len);
+   vht_capab->header.type =
+        cpu_to_le16(WLAN_EID_VHT_CAPABILITY);
+   vht_capab->header.len =
+      cpu_to_le16(sizeof(struct ieee80211_vht_cap));
+   memcpy(&vht_capab->vht_cap, params->vht_capa,
+          sizeof(struct ieee80211_vht_cap));
+   config_len += sizeof(struct mwifiex_ie_types_vhtcap);
+  }
+  if (params->aid) {
+   aid = (struct mwifiex_ie_types_aid *)(pos + config_len);
+   aid->header.type = cpu_to_le16(WLAN_EID_AID);
+   aid->header.len = cpu_to_le16(sizeof(params->aid));
+   aid->aid = cpu_to_le16(params->aid);
+   config_len += sizeof(struct mwifiex_ie_types_aid);
+  }
+
+  timeout = (void *)(pos + config_len);
+  timeout->header.type = cpu_to_le16(TLV_TYPE_TDLS_IDLE_TIMEOUT);
+  timeout->header.len = cpu_to_le16(sizeof(timeout->value));
+  timeout->value = cpu_to_le16(MWIFIEX_TDLS_IDLE_TIMEOUT);
+  config_len += sizeof(struct mwifiex_ie_types_tdls_idle_timeout);
+
+  break;
+ default:
+  dev_err(priv->adapter->dev, "Unknown TDLS operation\n");
+  return -ENOTSUPP;
+ }
+
+ le16_add_cpu(&cmd->size, config_len);
+
+ return 0;
+}
 /*
  * This function prepares the commands before sending them to the firmware.
  *
@@ -1152,6 +1678,9 @@ int mwifiex_sta_prepare_cmd(struct mwifiex_private *priv, uint16_t cmd_no,
  case HostCmd_CMD_GET_HW_SPEC:
   ret = mwifiex_cmd_get_hw_spec(priv, cmd_ptr);
   break;
+ case HostCmd_CMD_CFG_DATA:
+  ret = mwifiex_cmd_cfg_data(priv, cmd_ptr, data_buf);
+  break;
  case HostCmd_CMD_MAC_CONTROL:
   ret = mwifiex_cmd_mac_control(priv, cmd_ptr, cmd_action,
            data_buf);
@@ -1323,6 +1852,9 @@ int mwifiex_sta_prepare_cmd(struct mwifiex_private *priv, uint16_t cmd_no,
   ret = mwifiex_cmd_ibss_coalescing_status(cmd_ptr, cmd_action,
         data_buf);
   break;
+ case HostCmd_CMD_802_11_SCAN_EXT:
+  ret = mwifiex_cmd_802_11_scan_ext(priv, cmd_ptr, data_buf);
+  break;
  case HostCmd_CMD_MAC_REG_ACCESS:
  case HostCmd_CMD_BBP_REG_ACCESS:
  case HostCmd_CMD_RF_REG_ACCESS:
@@ -1354,6 +1886,13 @@ int mwifiex_sta_prepare_cmd(struct mwifiex_private *priv, uint16_t cmd_no,
  case HostCmd_CMD_MEF_CFG:
   ret = mwifiex_cmd_mef_cfg(priv, cmd_ptr, data_buf);
   break;
+ case HostCmd_CMD_COALESCE_CFG:
+  ret = mwifiex_cmd_coalesce_cfg(priv, cmd_ptr, cmd_action,
+            data_buf);
+  break;
+ case HostCmd_CMD_TDLS_OPER:
+  ret = mwifiex_cmd_tdls_oper(priv, cmd_ptr, data_buf);
+  break;
  default:
   dev_err(priv->adapter->dev,
    "PREP_CMD: unknown cmd- %#x\n", cmd_no);
@@ -1384,6 +1923,7 @@ int mwifiex_sta_prepare_cmd(struct mwifiex_private *priv, uint16_t cmd_no,
  */
 int mwifiex_sta_init_cmd(struct mwifiex_private *priv, u8 first_sta)
 {
+ struct mwifiex_adapter *adapter = priv->adapter;
  int ret;
  u16 enable = true;
  struct mwifiex_ds_11n_amsdu_aggr_ctrl amsdu_aggr_ctrl;
@@ -1393,60 +1933,84 @@ int mwifiex_sta_init_cmd(struct mwifiex_private *priv, u8 first_sta)
 
  if (first_sta) {
   if (priv->adapter->iface_type == MWIFIEX_PCIE) {
-   ret = mwifiex_send_cmd_sync(priv,
-      HostCmd_CMD_PCIE_DESC_DETAILS,
-      HostCmd_ACT_GEN_SET, 0, NULL);
+   ret = mwifiex_send_cmd(priv,
+            HostCmd_CMD_PCIE_DESC_DETAILS,
+            HostCmd_ACT_GEN_SET, 0, NULL,
+            true);
    if (ret)
     return -1;
   }
 
-  ret = mwifiex_send_cmd_sync(priv, HostCmd_CMD_FUNC_INIT,
-         HostCmd_ACT_GEN_SET, 0, NULL);
+  ret = mwifiex_send_cmd(priv, HostCmd_CMD_FUNC_INIT,
+           HostCmd_ACT_GEN_SET, 0, NULL, true);
   if (ret)
    return -1;
+
+  /* Download calibration data to firmware.
+   * The cal-data can be read from device tree and/or
+   * a configuration file and downloaded to firmware.
+   */
+  adapter->dt_node =
+    of_find_node_by_name(NULL, "marvell_cfgdata");
+  if (adapter->dt_node) {
+   ret = mwifiex_dnld_dt_cfgdata(priv, adapter->dt_node,
+            "marvell,caldata");
+   if (ret)
+    return -1;
+  }
+
+  if (adapter->cal_data) {
+   ret = mwifiex_send_cmd(priv, HostCmd_CMD_CFG_DATA,
+            HostCmd_ACT_GEN_SET, 0, NULL,
+            true);
+   if (ret)
+    return -1;
+  }
+
   /* Read MAC address from HW */
-  ret = mwifiex_send_cmd_sync(priv, HostCmd_CMD_GET_HW_SPEC,
-         HostCmd_ACT_GEN_GET, 0, NULL);
+  ret = mwifiex_send_cmd(priv, HostCmd_CMD_GET_HW_SPEC,
+           HostCmd_ACT_GEN_GET, 0, NULL, true);
   if (ret)
    return -1;
 
   /* Reconfigure tx buf size */
-  ret = mwifiex_send_cmd_sync(priv,
-         HostCmd_CMD_RECONFIGURE_TX_BUFF,
-         HostCmd_ACT_GEN_SET, 0,
-         &priv->adapter->tx_buf_size);
+  ret = mwifiex_send_cmd(priv, HostCmd_CMD_RECONFIGURE_TX_BUFF,
+           HostCmd_ACT_GEN_SET, 0,
+           &priv->adapter->tx_buf_size, true);
   if (ret)
    return -1;
 
   if (priv->bss_type != MWIFIEX_BSS_TYPE_UAP) {
    /* Enable IEEE PS by default */
    priv->adapter->ps_mode = MWIFIEX_802_11_POWER_MODE_PSP;
-   ret = mwifiex_send_cmd_sync(
-     priv, HostCmd_CMD_802_11_PS_MODE_ENH,
-     EN_AUTO_PS, BITMAP_STA_PS, NULL);
+   ret = mwifiex_send_cmd(priv,
+            HostCmd_CMD_802_11_PS_MODE_ENH,
+            EN_AUTO_PS, BITMAP_STA_PS, NULL,
+            true);
    if (ret)
     return -1;
   }
  }
 
  /* get tx rate */
- ret = mwifiex_send_cmd_sync(priv, HostCmd_CMD_TX_RATE_CFG,
-        HostCmd_ACT_GEN_GET, 0, NULL);
+ ret = mwifiex_send_cmd(priv, HostCmd_CMD_TX_RATE_CFG,
+          HostCmd_ACT_GEN_GET, 0, NULL, true);
  if (ret)
   return -1;
  priv->data_rate = 0;
 
  /* get tx power */
- ret = mwifiex_send_cmd_sync(priv, HostCmd_CMD_RF_TX_PWR,
-        HostCmd_ACT_GEN_GET, 0, NULL);
+ ret = mwifiex_send_cmd(priv, HostCmd_CMD_RF_TX_PWR,
+          HostCmd_ACT_GEN_GET, 0, NULL, true);
  if (ret)
   return -1;
 
  if (priv->bss_type == MWIFIEX_BSS_TYPE_STA) {
   /* set ibss coalescing_status */
-  ret = mwifiex_send_cmd_sync(
-    priv, HostCmd_CMD_802_11_IBSS_COALESCING_STATUS,
-    HostCmd_ACT_GEN_SET, 0, &enable);
+  ret = mwifiex_send_cmd(
+    priv,
+    HostCmd_CMD_802_11_IBSS_COALESCING_STATUS,
+    HostCmd_ACT_GEN_SET, 0, &enable, true);
   if (ret)
    return -1;
  }
@@ -1454,16 +2018,16 @@ int mwifiex_sta_init_cmd(struct mwifiex_private *priv, u8 first_sta)
  memset(&amsdu_aggr_ctrl, 0, sizeof(amsdu_aggr_ctrl));
  amsdu_aggr_ctrl.enable = true;
  /* Send request to firmware */
- ret = mwifiex_send_cmd_sync(priv, HostCmd_CMD_AMSDU_AGGR_CTRL,
-        HostCmd_ACT_GEN_SET, 0,
-        &amsdu_aggr_ctrl);
+ ret = mwifiex_send_cmd(priv, HostCmd_CMD_AMSDU_AGGR_CTRL,
+          HostCmd_ACT_GEN_SET, 0,
+          &amsdu_aggr_ctrl, true);
  if (ret)
   return -1;
  /* MAC Control must be the last command in init_fw */
  /* set MAC Control */
- ret = mwifiex_send_cmd_sync(priv, HostCmd_CMD_MAC_CONTROL,
-        HostCmd_ACT_GEN_SET, 0,
-        &priv->curr_pkt_filter);
+ ret = mwifiex_send_cmd(priv, HostCmd_CMD_MAC_CONTROL,
+          HostCmd_ACT_GEN_SET, 0,
+          &priv->curr_pkt_filter, true);
  if (ret)
   return -1;
 
@@ -1472,10 +2036,9 @@ int mwifiex_sta_init_cmd(struct mwifiex_private *priv, u8 first_sta)
   /* Enable auto deep sleep */
   auto_ds.auto_ds = DEEP_SLEEP_ON;
   auto_ds.idle_time = DEEP_SLEEP_IDLE_TIME;
-  ret = mwifiex_send_cmd_sync(priv,
-         HostCmd_CMD_802_11_PS_MODE_ENH,
-         EN_AUTO_PS, BITMAP_AUTO_DS,
-         &auto_ds);
+  ret = mwifiex_send_cmd(priv, HostCmd_CMD_802_11_PS_MODE_ENH,
+           EN_AUTO_PS, BITMAP_AUTO_DS,
+           &auto_ds, true);
   if (ret)
    return -1;
  }
@@ -1483,9 +2046,9 @@ int mwifiex_sta_init_cmd(struct mwifiex_private *priv, u8 first_sta)
  if (priv->bss_type != MWIFIEX_BSS_TYPE_UAP) {
   /* Send cmd to FW to enable/disable 11D function */
   state_11d = ENABLE_11D;
-  ret = mwifiex_send_cmd_sync(priv, HostCmd_CMD_802_11_SNMP_MIB,
-         HostCmd_ACT_GEN_SET, DOT11D_I,
-         &state_11d);
+  ret = mwifiex_send_cmd(priv, HostCmd_CMD_802_11_SNMP_MIB,
+           HostCmd_ACT_GEN_SET, DOT11D_I,
+           &state_11d, true);
   if (ret)
    dev_err(priv->adapter->dev,
     "11D: failed to enable 11D\n");
@@ -1498,8 +2061,8 @@ int mwifiex_sta_init_cmd(struct mwifiex_private *priv, u8 first_sta)
   * (Short GI, Channel BW, Green field support etc.) for transmit
   */
  tx_cfg.tx_htcap = MWIFIEX_FW_DEF_HTTXCFG;
- ret = mwifiex_send_cmd_sync(priv, HostCmd_CMD_11N_CFG,
-        HostCmd_ACT_GEN_SET, 0, &tx_cfg);
+ ret = mwifiex_send_cmd(priv, HostCmd_CMD_11N_CFG,
+          HostCmd_ACT_GEN_SET, 0, &tx_cfg, true);
 
  ret = -EINPROGRESS;
 
diff --git a/drivers/net/wireless/mwifiex/sta_cmdresp.c b/drivers/net/wireless/mwifiex/sta_cmdresp.c
index 9f990e1..577f297 100644
--- a/drivers/net/wireless/mwifiex/sta_cmdresp.c
+++ b/drivers/net/wireless/mwifiex/sta_cmdresp.c
@@ -69,6 +69,7 @@ mwifiex_process_cmdresp_error(struct mwifiex_private *priv,
 
   break;
  case HostCmd_CMD_802_11_SCAN:
+ case HostCmd_CMD_802_11_SCAN_EXT:
   /* Cancel all pending scan command */
   spin_lock_irqsave(&adapter->scan_pending_q_lock, flags);
   list_for_each_entry_safe(cmd_node, tmp_node,
@@ -157,8 +158,8 @@ static int mwifiex_ret_802_11_rssi_info(struct mwifiex_private *priv,
 
  priv->subsc_evt_rssi_state = EVENT_HANDLED;
 
- mwifiex_send_cmd_async(priv, HostCmd_CMD_802_11_SUBSCRIBE_EVENT,
-          0, 0, subsc_evt);
+ mwifiex_send_cmd(priv, HostCmd_CMD_802_11_SUBSCRIBE_EVENT,
+    0, 0, subsc_evt, false);
 
  return 0;
 }
@@ -274,17 +275,20 @@ static int mwifiex_ret_tx_rate_cfg(struct mwifiex_private *priv,
  struct host_cmd_ds_tx_rate_cfg *rate_cfg = &resp->params.tx_rate_cfg;
  struct mwifiex_rate_scope *rate_scope;
  struct mwifiex_ie_types_header *head;
- u16 tlv, tlv_buf_len;
+ u16 tlv, tlv_buf_len, tlv_buf_left;
  u8 *tlv_buf;
  u32 i;
 
- tlv_buf = ((u8 *)rate_cfg) +
-   sizeof(struct host_cmd_ds_tx_rate_cfg);
- tlv_buf_len = *(u16 *) (tlv_buf + sizeof(u16));
+ tlv_buf = ((u8 *)rate_cfg) + sizeof(struct host_cmd_ds_tx_rate_cfg);
+ tlv_buf_left = le16_to_cpu(resp->size) - S_DS_GEN - sizeof(*rate_cfg);
 
- while (tlv_buf && tlv_buf_len > 0) {
-  tlv = (*tlv_buf);
-  tlv = tlv | (*(tlv_buf + 1) << 8);
+ while (tlv_buf_left >= sizeof(*head)) {
+  head = (struct mwifiex_ie_types_header *)tlv_buf;
+  tlv = le16_to_cpu(head->type);
+  tlv_buf_len = le16_to_cpu(head->len);
+
+  if (tlv_buf_left < (sizeof(*head) + tlv_buf_len))
+   break;
 
   switch (tlv) {
   case TLV_TYPE_RATE_SCOPE:
@@ -300,13 +304,21 @@ static int mwifiex_ret_tx_rate_cfg(struct mwifiex_private *priv,
     priv->bitmap_rates[2 + i] =
      le16_to_cpu(rate_scope->
           ht_mcs_rate_bitmap[i]);
+
+   if (priv->adapter->fw_api_ver == MWIFIEX_FW_V15) {
+    for (i = 0; i < ARRAY_SIZE(rate_scope->
+          vht_mcs_rate_bitmap);
+         i++)
+     priv->bitmap_rates[10 + i] =
+         le16_to_cpu(rate_scope->
+       vht_mcs_rate_bitmap[i]);
+   }
    break;
    /* Add RATE_DROP tlv here */
   }
 
-  head = (struct mwifiex_ie_types_header *) tlv_buf;
-  tlv_buf += le16_to_cpu(head->len) + sizeof(*head);
-  tlv_buf_len -= le16_to_cpu(head->len);
+  tlv_buf += (sizeof(*head) + tlv_buf_len);
+  tlv_buf_left -= (sizeof(*head) + tlv_buf_len);
  }
 
  priv->is_data_rate_auto = mwifiex_is_rate_auto(priv);
@@ -314,9 +326,8 @@ static int mwifiex_ret_tx_rate_cfg(struct mwifiex_private *priv,
  if (priv->is_data_rate_auto)
   priv->data_rate = 0;
  else
-  return mwifiex_send_cmd_async(priv,
-           HostCmd_CMD_802_11_TX_RATE_QUERY,
-           HostCmd_ACT_GEN_GET, 0, NULL);
+  return mwifiex_send_cmd(priv, HostCmd_CMD_802_11_TX_RATE_QUERY,
+     HostCmd_ACT_GEN_GET, 0, NULL, false);
 
  return 0;
 }
@@ -336,17 +347,20 @@ static int mwifiex_get_power_level(struct mwifiex_private *priv, void *data_buf)
  if (!data_buf)
   return -1;
 
- pg_tlv_hdr = (struct mwifiex_types_power_group *)
-  ((u8 *) data_buf + sizeof(struct host_cmd_ds_txpwr_cfg));
+ pg_tlv_hdr = (struct mwifiex_types_power_group *)((u8 *)data_buf);
  pg = (struct mwifiex_power_group *)
   ((u8 *) pg_tlv_hdr + sizeof(struct mwifiex_types_power_group));
- length = pg_tlv_hdr->length;
- if (length > 0) {
-  max_power = pg->power_max;
-  min_power = pg->power_min;
-  length -= sizeof(struct mwifiex_power_group);
- }
- while (length) {
+ length = le16_to_cpu(pg_tlv_hdr->length);
+
+ /* At least one structure required to update power */
+ if (length < sizeof(struct mwifiex_power_group))
+  return 0;
+
+ max_power = pg->power_max;
+ min_power = pg->power_min;
+ length -= sizeof(struct mwifiex_power_group);
+
+ while (length >= sizeof(struct mwifiex_power_group)) {
   pg++;
   if (max_power < pg->power_max)
    max_power = pg->power_max;
@@ -356,10 +370,8 @@ static int mwifiex_get_power_level(struct mwifiex_private *priv, void *data_buf)
 
   length -= sizeof(struct mwifiex_power_group);
  }
- if (pg_tlv_hdr->length > 0) {
-  priv->min_tx_power_level = (u8) min_power;
-  priv->max_tx_power_level = (u8) max_power;
- }
+ priv->min_tx_power_level = (u8) min_power;
+ priv->max_tx_power_level = (u8) max_power;
 
  return 0;
 }
@@ -379,19 +391,25 @@ static int mwifiex_ret_tx_power_cfg(struct mwifiex_private *priv,
  struct mwifiex_types_power_group *pg_tlv_hdr;
  struct mwifiex_power_group *pg;
  u16 action = le16_to_cpu(txp_cfg->action);
+ u16 tlv_buf_left;
 
- switch (action) {
- case HostCmd_ACT_GEN_GET:
-  pg_tlv_hdr = (struct mwifiex_types_power_group *)
-   ((u8 *) txp_cfg +
-    sizeof(struct host_cmd_ds_txpwr_cfg));
+ pg_tlv_hdr = (struct mwifiex_types_power_group *)
+  ((u8 *)txp_cfg +
+   sizeof(struct host_cmd_ds_txpwr_cfg));
+
+ pg = (struct mwifiex_power_group *)
+  ((u8 *)pg_tlv_hdr +
+   sizeof(struct mwifiex_types_power_group));
 
-  pg = (struct mwifiex_power_group *)
-   ((u8 *) pg_tlv_hdr +
-    sizeof(struct mwifiex_types_power_group));
+ tlv_buf_left = le16_to_cpu(resp->size) - S_DS_GEN - sizeof(*txp_cfg);
+ if (tlv_buf_left <
+   le16_to_cpu(pg_tlv_hdr->length) + sizeof(*pg_tlv_hdr))
+  return 0;
 
+ switch (action) {
+ case HostCmd_ACT_GEN_GET:
   if (adapter->hw_status == MWIFIEX_HW_STATUS_INITIALIZING)
-   mwifiex_get_power_level(priv, txp_cfg);
+   mwifiex_get_power_level(priv, pg_tlv_hdr);
 
   priv->tx_power_level = (u16) pg->power_min;
   break;
@@ -400,14 +418,6 @@ static int mwifiex_ret_tx_power_cfg(struct mwifiex_private *priv,
   if (!le32_to_cpu(txp_cfg->mode))
    break;
 
-  pg_tlv_hdr = (struct mwifiex_types_power_group *)
-   ((u8 *) txp_cfg +
-    sizeof(struct host_cmd_ds_txpwr_cfg));
-
-  pg = (struct mwifiex_power_group *)
-   ((u8 *) pg_tlv_hdr +
-    sizeof(struct mwifiex_types_power_group));
-
   if (pg->power_max == pg->power_min)
    priv->tx_power_level = (u16) pg->power_min;
   break;
@@ -560,13 +570,13 @@ static int mwifiex_ret_802_11_ad_hoc_stop(struct mwifiex_private *priv,
 }
 
 /*
- * This function handles the command response of set/get key material.
+ * This function handles the command response of set/get v1 key material.
  *
  * Handling includes updating the driver parameters to reflect the
  * changes.
  */
-static int mwifiex_ret_802_11_key_material(struct mwifiex_private *priv,
-        struct host_cmd_ds_command *resp)
+static int mwifiex_ret_802_11_key_material_v1(struct mwifiex_private *priv,
+           struct host_cmd_ds_command *resp)
 {
  struct host_cmd_ds_802_11_key_material *key =
       &resp->params.key_material;
@@ -589,6 +599,51 @@ static int mwifiex_ret_802_11_key_material(struct mwifiex_private *priv,
 }
 
 /*
+ * This function handles the command response of set/get v2 key material.
+ *
+ * Handling includes updating the driver parameters to reflect the
+ * changes.
+ */
+static int mwifiex_ret_802_11_key_material_v2(struct mwifiex_private *priv,
+           struct host_cmd_ds_command *resp)
+{
+ struct host_cmd_ds_802_11_key_material_v2 *key_v2;
+ __le16 len;
+
+ key_v2 = &resp->params.key_material_v2;
+ if (le16_to_cpu(key_v2->action) == HostCmd_ACT_GEN_SET) {
+  if ((le16_to_cpu(key_v2->key_param_set.key_info) & KEY_MCAST)) {
+   dev_dbg(priv->adapter->dev, "info: key: GTK is set\n");
+   priv->wpa_is_gtk_set = true;
+   priv->scan_block = false;
+  }
+ }
+
+ if (key_v2->key_param_set.key_type != KEY_TYPE_ID_AES)
+  return 0;
+
+ memset(priv->aes_key_v2.key_param_set.key_params.aes.key, 0,
+        WLAN_KEY_LEN_CCMP);
+ priv->aes_key_v2.key_param_set.key_params.aes.key_len =
+    key_v2->key_param_set.key_params.aes.key_len;
+ len = priv->aes_key_v2.key_param_set.key_params.aes.key_len;
+ memcpy(priv->aes_key_v2.key_param_set.key_params.aes.key,
+        key_v2->key_param_set.key_params.aes.key, le16_to_cpu(len));
+
+ return 0;
+}
+
+/* Wrapper function for processing response of key material command */
+static int mwifiex_ret_802_11_key_material(struct mwifiex_private *priv,
+        struct host_cmd_ds_command *resp)
+{
+ if (priv->adapter->fw_key_api_major_ver == FW_KEY_API_VER_MAJOR_V2)
+  return mwifiex_ret_802_11_key_material_v2(priv, resp);
+ else
+  return mwifiex_ret_802_11_key_material_v1(priv, resp);
+}
+
+/*
  * This function handles the command response of get 11d domain information.
  */
 static int mwifiex_ret_802_11d_domain_info(struct mwifiex_private *priv,
@@ -781,8 +836,7 @@ static int mwifiex_ret_ibss_coalescing_status(struct mwifiex_private *priv,
  }
 
  /* If BSSID is diff, modify current BSS parameters */
- if (memcmp(priv->curr_bss_params.bss_descriptor.mac_address,
-     ibss_coal_resp->bssid, ETH_ALEN)) {
+ if (!ether_addr_equal(priv->curr_bss_params.bss_descriptor.mac_address, ibss_coal_resp->bssid)) {
   /* BSSID */
   memcpy(priv->curr_bss_params.bss_descriptor.mac_address,
          ibss_coal_resp->bssid, ETH_ALEN);
@@ -800,7 +854,66 @@ static int mwifiex_ret_ibss_coalescing_status(struct mwifiex_private *priv,
 
  return 0;
 }
+static int mwifiex_ret_tdls_oper(struct mwifiex_private *priv,
+     struct host_cmd_ds_command *resp)
+{
+ struct host_cmd_ds_tdls_oper *cmd_tdls_oper = &resp->params.tdls_oper;
+ u16 reason = le16_to_cpu(cmd_tdls_oper->reason);
+ u16 action = le16_to_cpu(cmd_tdls_oper->tdls_action);
+ struct mwifiex_sta_node *node =
+      mwifiex_get_sta_entry(priv, cmd_tdls_oper->peer_mac);
+
+ switch (action) {
+ case ACT_TDLS_DELETE:
+  if (reason) {
+   if (!node || reason == TDLS_ERR_LINK_NONEXISTENT)
+    dev_dbg(priv->adapter->dev,
+     "TDLS link delete for %pM failed: reason %d\n",
+     cmd_tdls_oper->peer_mac, reason);
+   else
+    dev_err(priv->adapter->dev,
+     "TDLS link delete for %pM failed: reason %d\n",
+     cmd_tdls_oper->peer_mac, reason);
+  } else {
+   dev_dbg(priv->adapter->dev,
+    "TDLS link delete for %pM successful\n",
+    cmd_tdls_oper->peer_mac);
+  }
+  break;
+ case ACT_TDLS_CREATE:
+  if (reason) {
+   dev_err(priv->adapter->dev,
+    "TDLS link creation for %pM failed: reason %d",
+    cmd_tdls_oper->peer_mac, reason);
+   if (node && reason != TDLS_ERR_LINK_EXISTS)
+    node->tdls_status = TDLS_SETUP_FAILURE;
+  } else {
+   dev_dbg(priv->adapter->dev,
+    "TDLS link creation for %pM successful",
+    cmd_tdls_oper->peer_mac);
+  }
+  break;
+ case ACT_TDLS_CONFIG:
+  if (reason) {
+   dev_err(priv->adapter->dev,
+    "TDLS link config for %pM failed, reason %d\n",
+    cmd_tdls_oper->peer_mac, reason);
+   if (node)
+    node->tdls_status = TDLS_SETUP_FAILURE;
+  } else {
+   dev_dbg(priv->adapter->dev,
+    "TDLS link config for %pM successful\n",
+    cmd_tdls_oper->peer_mac);
+  }
+  break;
+ default:
+  dev_err(priv->adapter->dev,
+   "Unknown TDLS command action respnse %d", action);
+  return -1;
+ }
 
+ return 0;
+}
 /*
  * This function handles the command response for subscribe event command.
  */
@@ -818,6 +931,18 @@ static int mwifiex_ret_subsc_evt(struct mwifiex_private *priv,
  return 0;
 }
 
+/* This function handles the command response of set_cfg_data */
+static int mwifiex_ret_cfg_data(struct mwifiex_private *priv,
+    struct host_cmd_ds_command *resp)
+{
+ if (resp->result != HostCmd_RESULT_OK) {
+  dev_err(priv->adapter->dev, "Cal data cmd resp failed\n");
+  return -1;
+ }
+
+ return 0;
+}
+
 /*
  * This function handles the command responses.
  *
@@ -841,6 +966,9 @@ int mwifiex_process_sta_cmdresp(struct mwifiex_private *priv, u16 cmdresp_no,
  case HostCmd_CMD_GET_HW_SPEC:
   ret = mwifiex_ret_get_hw_spec(priv, resp);
   break;
+ case HostCmd_CMD_CFG_DATA:
+  ret = mwifiex_ret_cfg_data(priv, resp);
+  break;
  case HostCmd_CMD_MAC_CONTROL:
   break;
  case HostCmd_CMD_802_11_MAC_ADDRESS:
@@ -856,6 +984,10 @@ int mwifiex_process_sta_cmdresp(struct mwifiex_private *priv, u16 cmdresp_no,
   ret = mwifiex_ret_802_11_scan(priv, resp);
   adapter->curr_cmd->wait_q_enabled = false;
   break;
+ case HostCmd_CMD_802_11_SCAN_EXT:
+  ret = mwifiex_ret_802_11_scan_ext(priv);
+  adapter->curr_cmd->wait_q_enabled = false;
+  break;
  case HostCmd_CMD_802_11_BG_SCAN_QUERY:
   ret = mwifiex_ret_802_11_scan(priv, resp);
   dev_dbg(adapter->dev,
@@ -978,8 +1110,15 @@ int mwifiex_process_sta_cmdresp(struct mwifiex_private *priv, u16 cmdresp_no,
  case HostCmd_CMD_UAP_BSS_STOP:
   priv->bss_started = 0;
   break;
+ case HostCmd_CMD_UAP_STA_DEAUTH:
+  break;
  case HostCmd_CMD_MEF_CFG:
   break;
+ case HostCmd_CMD_COALESCE_CFG:
+  break;
+ case HostCmd_CMD_TDLS_OPER:
+  ret = mwifiex_ret_tdls_oper(priv, resp);
+  break;
  default:
   dev_err(adapter->dev, "CMD_RESP: unknown cmd response %#x\n",
    resp->command);
diff --git a/drivers/net/wireless/mwifiex/sta_event.c b/drivers/net/wireless/mwifiex/sta_event.c
index 41aafc7..f6395ef 100644
--- a/drivers/net/wireless/mwifiex/sta_event.c
+++ b/drivers/net/wireless/mwifiex/sta_event.c
@@ -54,6 +54,10 @@ mwifiex_reset_connect_state(struct mwifiex_private *priv, u16 reason_code)
 
  priv->scan_block = false;
 
+ if ((GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_STA) &&
+     ISSUPP_TDLS_ENABLED(priv->adapter->fw_cap_info))
+  mwifiex_disable_all_tdls_links(priv);
+
  /* Free Tx and Rx packets, report disconnect to upper layer */
  mwifiex_clean_txrx(priv);
 
@@ -112,13 +116,14 @@ mwifiex_reset_connect_state(struct mwifiex_private *priv, u16 reason_code)
  adapter->tx_lock_flag = false;
  adapter->pps_uapsd_mode = false;
 
- if (adapter->num_cmd_timeout && adapter->curr_cmd)
+ if (adapter->is_cmd_timedout && adapter->curr_cmd)
   return;
  priv->media_connected = false;
  dev_dbg(adapter->dev,
   "info: successfully disconnected from %pM: reason code %d\n",
   priv->cfg_bssid, reason_code);
- if (priv->bss_mode == NL80211_IFTYPE_STATION) {
+ if (priv->bss_mode == NL80211_IFTYPE_STATION ||
+     priv->bss_mode == NL80211_IFTYPE_P2P_CLIENT) {
   cfg80211_disconnected(priv->netdev, reason_code, NULL, 0,
           GFP_KERNEL);
  }
@@ -129,6 +134,46 @@ mwifiex_reset_connect_state(struct mwifiex_private *priv, u16 reason_code)
   netif_carrier_off(priv->netdev);
 }
 
+static int mwifiex_parse_tdls_event(struct mwifiex_private *priv,
+        struct sk_buff *event_skb)
+{
+ int ret = 0;
+ struct mwifiex_adapter *adapter = priv->adapter;
+ struct mwifiex_sta_node *sta_ptr;
+ struct mwifiex_tdls_generic_event *tdls_evt =
+   (void *)event_skb->data + sizeof(adapter->event_cause);
+
+ /* reserved 2 bytes are not mandatory in tdls event */
+ if (event_skb->len < (sizeof(struct mwifiex_tdls_generic_event) -
+         sizeof(u16) - sizeof(adapter->event_cause))) {
+  dev_err(adapter->dev, "Invalid event length!\n");
+  return -1;
+ }
+
+ sta_ptr = mwifiex_get_sta_entry(priv, tdls_evt->peer_mac);
+ if (!sta_ptr) {
+  dev_err(adapter->dev, "cannot get sta entry!\n");
+  return -1;
+ }
+
+ switch (le16_to_cpu(tdls_evt->type)) {
+ case TDLS_EVENT_LINK_TEAR_DOWN:
+  cfg80211_tdls_oper_request(priv->netdev,
+        tdls_evt->peer_mac,
+        NL80211_TDLS_TEARDOWN,
+        le16_to_cpu(tdls_evt->u.reason_code),
+        GFP_KERNEL);
+  ret = mwifiex_tdls_oper(priv, tdls_evt->peer_mac,
+     MWIFIEX_TDLS_DISABLE_LINK);
+  queue_work(adapter->workqueue, &adapter->main_work);
+  break;
+ default:
+  break;
+ }
+
+ return ret;
+}
+
 /*
  * This function handles events generated by firmware.
  *
@@ -201,6 +246,11 @@ int mwifiex_process_sta_event(struct mwifiex_private *priv)
 
  case EVENT_DEAUTHENTICATED:
   dev_dbg(adapter->dev, "event: Deauthenticated\n");
+  if (priv->wps.session_enable) {
+   dev_dbg(adapter->dev,
+    "info: receive deauth event in wps session\n");
+   break;
+  }
   adapter->dbg.num_event_deauth++;
   if (priv->media_connected) {
    reason_code =
@@ -211,6 +261,11 @@ int mwifiex_process_sta_event(struct mwifiex_private *priv)
 
  case EVENT_DISASSOCIATED:
   dev_dbg(adapter->dev, "event: Disassociated\n");
+  if (priv->wps.session_enable) {
+   dev_dbg(adapter->dev,
+    "info: receive disassoc event in wps session\n");
+   break;
+  }
   adapter->dbg.num_event_disassoc++;
   if (priv->media_connected) {
    reason_code =
@@ -278,9 +333,8 @@ int mwifiex_process_sta_event(struct mwifiex_private *priv)
 
  case EVENT_HS_ACT_REQ:
   dev_dbg(adapter->dev, "event: HS_ACT_REQ\n");
-  ret = mwifiex_send_cmd_async(priv,
-          HostCmd_CMD_802_11_HS_CFG_ENH,
-          0, 0, NULL);
+  ret = mwifiex_send_cmd(priv, HostCmd_CMD_802_11_HS_CFG_ENH,
+           0, 0, NULL, false);
   break;
 
  case EVENT_MIC_ERR_UNICAST:
@@ -311,27 +365,34 @@ int mwifiex_process_sta_event(struct mwifiex_private *priv)
 
  case EVENT_BG_SCAN_REPORT:
   dev_dbg(adapter->dev, "event: BGS_REPORT\n");
-  ret = mwifiex_send_cmd_async(priv,
-          HostCmd_CMD_802_11_BG_SCAN_QUERY,
-          HostCmd_ACT_GEN_GET, 0, NULL);
+  ret = mwifiex_send_cmd(priv, HostCmd_CMD_802_11_BG_SCAN_QUERY,
+           HostCmd_ACT_GEN_GET, 0, NULL, false);
   break;
 
  case EVENT_PORT_RELEASE:
   dev_dbg(adapter->dev, "event: PORT RELEASE\n");
   break;
 
+ case EVENT_EXT_SCAN_REPORT:
+  dev_dbg(adapter->dev, "event: EXT_SCAN Report\n");
+  if (adapter->ext_scan)
+   ret = mwifiex_handle_event_ext_scan_report(priv,
+      adapter->event_skb->data);
+
+  break;
+
  case EVENT_WMM_STATUS_CHANGE:
   dev_dbg(adapter->dev, "event: WMM status changed\n");
-  ret = mwifiex_send_cmd_async(priv, HostCmd_CMD_WMM_GET_STATUS,
-          0, 0, NULL);
+  ret = mwifiex_send_cmd(priv, HostCmd_CMD_WMM_GET_STATUS,
+           0, 0, NULL, false);
   break;
 
  case EVENT_RSSI_LOW:
   cfg80211_cqm_rssi_notify(priv->netdev,
       NL80211_CQM_RSSI_THRESHOLD_EVENT_LOW,
       GFP_KERNEL);
-  mwifiex_send_cmd_async(priv, HostCmd_CMD_RSSI_INFO,
-           HostCmd_ACT_GEN_GET, 0, NULL);
+  mwifiex_send_cmd(priv, HostCmd_CMD_RSSI_INFO,
+     HostCmd_ACT_GEN_GET, 0, NULL, false);
   priv->subsc_evt_rssi_state = RSSI_LOW_RECVD;
   dev_dbg(adapter->dev, "event: Beacon RSSI_LOW\n");
   break;
@@ -345,8 +406,8 @@ int mwifiex_process_sta_event(struct mwifiex_private *priv)
   cfg80211_cqm_rssi_notify(priv->netdev,
       NL80211_CQM_RSSI_THRESHOLD_EVENT_HIGH,
       GFP_KERNEL);
-  mwifiex_send_cmd_async(priv, HostCmd_CMD_RSSI_INFO,
-           HostCmd_ACT_GEN_GET, 0, NULL);
+  mwifiex_send_cmd(priv, HostCmd_CMD_RSSI_INFO,
+     HostCmd_ACT_GEN_GET, 0, NULL, false);
   priv->subsc_evt_rssi_state = RSSI_HIGH_RECVD;
   dev_dbg(adapter->dev, "event: Beacon RSSI_HIGH\n");
   break;
@@ -373,15 +434,15 @@ int mwifiex_process_sta_event(struct mwifiex_private *priv)
   break;
  case EVENT_IBSS_COALESCED:
   dev_dbg(adapter->dev, "event: IBSS_COALESCED\n");
-  ret = mwifiex_send_cmd_async(priv,
+  ret = mwifiex_send_cmd(priv,
     HostCmd_CMD_802_11_IBSS_COALESCING_STATUS,
-    HostCmd_ACT_GEN_GET, 0, NULL);
+    HostCmd_ACT_GEN_GET, 0, NULL, false);
   break;
  case EVENT_ADDBA:
   dev_dbg(adapter->dev, "event: ADDBA Request\n");
-  mwifiex_send_cmd_async(priv, HostCmd_CMD_11N_ADDBA_RSP,
-           HostCmd_ACT_GEN_SET, 0,
-           adapter->event_body);
+  mwifiex_send_cmd(priv, HostCmd_CMD_11N_ADDBA_RSP,
+     HostCmd_ACT_GEN_SET, 0,
+     adapter->event_body, false);
   break;
  case EVENT_DELBA:
   dev_dbg(adapter->dev, "event: DELBA Request\n");
@@ -427,6 +488,21 @@ int mwifiex_process_sta_event(struct mwifiex_private *priv)
 
   break;
 
+ case EVENT_CHANNEL_SWITCH_ANN:
+  dev_dbg(adapter->dev, "event: Channel Switch Announcement\n");
+  priv->csa_expire_time =
+    jiffies + msecs_to_jiffies(DFS_CHAN_MOVE_TIME);
+  priv->csa_chan = priv->curr_bss_params.bss_descriptor.channel;
+  ret = mwifiex_send_cmd(priv, HostCmd_CMD_802_11_DEAUTHENTICATE,
+   HostCmd_ACT_GEN_SET, 0,
+   priv->curr_bss_params.bss_descriptor.mac_address,
+   false);
+  break;
+
+ case EVENT_TDLS_GENERIC_EVENT:
+  ret = mwifiex_parse_tdls_event(priv, adapter->event_skb);
+  break;
+
  default:
   dev_dbg(adapter->dev, "event: unknown event id: %#x\n",
    eventcause);
diff --git a/drivers/net/wireless/mwifiex/sta_ioctl.c b/drivers/net/wireless/mwifiex/sta_ioctl.c
index 23aa910..536c14a 100644
--- a/drivers/net/wireless/mwifiex/sta_ioctl.c
+++ b/drivers/net/wireless/mwifiex/sta_ioctl.c
@@ -60,10 +60,12 @@ int mwifiex_wait_queue_complete(struct mwifiex_adapter *adapter,
  int status;
 
  /* Wait for completion */
- status = wait_event_interruptible(adapter->cmd_wait_q.wait,
-       *(cmd_queued->condition));
- if (status) {
+ status = wait_event_interruptible_timeout(adapter->cmd_wait_q.wait,
+        *(cmd_queued->condition),
+        (12 * HZ));
+ if (status <= 0) {
   dev_err(adapter->dev, "cmd_wait_q terminated: %d\n", status);
+  mwifiex_cancel_all_pending_cmd(adapter);
   return status;
  }
 
@@ -108,19 +110,19 @@ int mwifiex_request_set_multicast_list(struct mwifiex_private *priv,
     "info: Set multicast list=%d\n",
     mcast_list->num_multicast_addr);
    /* Send multicast addresses to firmware */
-   ret = mwifiex_send_cmd_async(priv,
-    HostCmd_CMD_MAC_MULTICAST_ADR,
-    HostCmd_ACT_GEN_SET, 0,
-    mcast_list);
+   ret = mwifiex_send_cmd(priv,
+            HostCmd_CMD_MAC_MULTICAST_ADR,
+            HostCmd_ACT_GEN_SET, 0,
+            mcast_list, false);
   }
  }
  dev_dbg(priv->adapter->dev,
   "info: old_pkt_filter=%#x, curr_pkt_filter=%#x\n",
         old_pkt_filter, priv->curr_pkt_filter);
  if (old_pkt_filter != priv->curr_pkt_filter) {
-  ret = mwifiex_send_cmd_async(priv, HostCmd_CMD_MAC_CONTROL,
-          HostCmd_ACT_GEN_SET,
-          0, &priv->curr_pkt_filter);
+  ret = mwifiex_send_cmd(priv, HostCmd_CMD_MAC_CONTROL,
+           HostCmd_ACT_GEN_SET,
+           0, &priv->curr_pkt_filter, false);
  }
 
  return ret;
@@ -178,9 +180,22 @@ int mwifiex_fill_new_bss_desc(struct mwifiex_private *priv,
   */
  bss_desc->disable_11ac = true;
 
+ if (bss_desc->cap_info_bitmap & WLAN_CAPABILITY_SPECTRUM_MGMT)
+  bss_desc->sensed_11h = true;
+
  return mwifiex_update_bss_desc_with_ie(priv->adapter, bss_desc);
 }
 
+void mwifiex_dnld_txpwr_table(struct mwifiex_private *priv)
+{
+ if (priv->adapter->dt_node) {
+  char txpwr[] = {"marvell,00_txpwrlimit"};
+
+  memcpy(&txpwr[8], priv->adapter->country_code, 2);
+  mwifiex_dnld_dt_cfgdata(priv, priv->adapter->dt_node, txpwr);
+ }
+}
+
 static int mwifiex_process_country_ie(struct mwifiex_private *priv,
           struct cfg80211_bss *bss)
 {
@@ -202,6 +217,14 @@ static int mwifiex_process_country_ie(struct mwifiex_private *priv,
   return 0;
  }
 
+ if (!strncmp(priv->adapter->country_code, &country_ie[2], 2)) {
+  rcu_read_unlock();
+  wiphy_dbg(priv->wdev->wiphy,
+     "11D: skip setting domain info in FW\n");
+  return 0;
+ }
+ memcpy(priv->adapter->country_code, &country_ie[2], 2);
+
  domain_info->country_code[0] = country_ie[2];
  domain_info->country_code[1] = country_ie[3];
  domain_info->country_code[2] = ' ';
@@ -216,13 +239,15 @@ static int mwifiex_process_country_ie(struct mwifiex_private *priv,
 
  rcu_read_unlock();
 
- if (mwifiex_send_cmd_async(priv, HostCmd_CMD_802_11D_DOMAIN_INFO,
-       HostCmd_ACT_GEN_SET, 0, NULL)) {
+ if (mwifiex_send_cmd(priv, HostCmd_CMD_802_11D_DOMAIN_INFO,
+        HostCmd_ACT_GEN_SET, 0, NULL, false)) {
   wiphy_err(priv->adapter->wiphy,
      "11D: setting domain info in FW\n");
   return -1;
  }
 
+ mwifiex_dnld_txpwr_table(priv);
+
  return 0;
 }
 
@@ -254,31 +279,38 @@ int mwifiex_bss_start(struct mwifiex_private *priv, struct cfg80211_bss *bss,
    goto done;
  }
 
- if (priv->bss_mode == NL80211_IFTYPE_STATION) {
-  /* Infra mode */
+ if (priv->bss_mode == NL80211_IFTYPE_STATION ||
+     priv->bss_mode == NL80211_IFTYPE_P2P_CLIENT) {
+  u8 config_bands;
+
   ret = mwifiex_deauthenticate(priv, NULL);
   if (ret)
    goto done;
 
-  if (bss_desc) {
-   u8 config_bands = 0;
+  if (!bss_desc)
+   return -1;
 
-   if (mwifiex_band_to_radio_type((u8) bss_desc->bss_band)
-       == HostCmd_SCAN_RADIO_TYPE_BG)
-    config_bands = BAND_B | BAND_G | BAND_GN |
-            BAND_GAC;
-   else
-    config_bands = BAND_A | BAND_AN | BAND_AAC;
+  if (mwifiex_band_to_radio_type(bss_desc->bss_band) ==
+      HostCmd_SCAN_RADIO_TYPE_BG)
+   config_bands = BAND_B | BAND_G | BAND_GN;
+  else
+   config_bands = BAND_A | BAND_AN | BAND_AAC;
 
-   if (!((config_bands | adapter->fw_bands) &
-         ~adapter->fw_bands))
-    adapter->config_bands = config_bands;
-  }
+  if (!((config_bands | adapter->fw_bands) & ~adapter->fw_bands))
+   adapter->config_bands = config_bands;
 
   ret = mwifiex_check_network_compatibility(priv, bss_desc);
   if (ret)
    goto done;
 
+  if (mwifiex_11h_get_csa_closed_channel(priv) ==
+       (u8)bss_desc->channel) {
+   dev_err(adapter->dev,
+    "Attempt to reconnect on csa closed chan(%d)\n",
+    bss_desc->channel);
+   goto done;
+  }
+
   dev_dbg(adapter->dev, "info: SSID found in scan list ... "
           "associating...\n");
 
@@ -309,8 +341,8 @@ int mwifiex_bss_start(struct mwifiex_private *priv, struct cfg80211_bss *bss,
   if (bss_desc && bss_desc->ssid.ssid_len &&
       (!mwifiex_ssid_cmp(&priv->curr_bss_params.bss_descriptor.
            ssid, &bss_desc->ssid))) {
-   kfree(bss_desc);
-   return 0;
+   ret = 0;
+   goto done;
   }
 
   /* Exit Adhoc mode first */
@@ -399,16 +431,13 @@ static int mwifiex_set_hs_params(struct mwifiex_private *priv, u16 action,
     status = -1;
     break;
    }
-   if (cmd_type == MWIFIEX_SYNC_CMD)
-    status = mwifiex_send_cmd_sync(priv,
-      HostCmd_CMD_802_11_HS_CFG_ENH,
-      HostCmd_ACT_GEN_SET, 0,
-      &adapter->hs_cfg);
-   else
-    status = mwifiex_send_cmd_async(priv,
-      HostCmd_CMD_802_11_HS_CFG_ENH,
-      HostCmd_ACT_GEN_SET, 0,
-      &adapter->hs_cfg);
+
+   status = mwifiex_send_cmd(priv,
+        HostCmd_CMD_802_11_HS_CFG_ENH,
+        HostCmd_ACT_GEN_SET, 0,
+        &adapter->hs_cfg,
+        cmd_type == MWIFIEX_SYNC_CMD);
+
    if (hs_cfg->conditions == HS_CFG_CANCEL)
     /* Restore previous condition */
     adapter->hs_cfg.conditions =
@@ -481,6 +510,9 @@ int mwifiex_enable_hs(struct mwifiex_adapter *adapter)
  memset(&hscfg, 0, sizeof(struct mwifiex_ds_hs_cfg));
  hscfg.is_invoke_hostcmd = true;
 
+ adapter->hs_enabling = true;
+ mwifiex_cancel_all_pending_cmd(adapter);
+
  if (mwifiex_set_hs_params(mwifiex_get_priv(adapter,
          MWIFIEX_BSS_ROLE_STA),
       HostCmd_ACT_GEN_SET, MWIFIEX_SYNC_CMD,
@@ -489,8 +521,9 @@ int mwifiex_enable_hs(struct mwifiex_adapter *adapter)
   return false;
  }
 
- if (wait_event_interruptible(adapter->hs_activate_wait_q,
-         adapter->hs_activate_wait_q_woken)) {
+ if (wait_event_interruptible_timeout(adapter->hs_activate_wait_q,
+          adapter->hs_activate_wait_q_woken,
+          (10 * HZ)) <= 0) {
   dev_err(adapter->dev, "hs_activate_wait_q terminated\n");
   return false;
  }
@@ -556,8 +589,8 @@ int mwifiex_disable_auto_ds(struct mwifiex_private *priv)
 
  auto_ds.auto_ds = DEEP_SLEEP_OFF;
 
- return mwifiex_send_cmd_sync(priv, HostCmd_CMD_802_11_PS_MODE_ENH,
-         DIS_AUTO_PS, BITMAP_AUTO_DS, &auto_ds);
+ return mwifiex_send_cmd(priv, HostCmd_CMD_802_11_PS_MODE_ENH,
+    DIS_AUTO_PS, BITMAP_AUTO_DS, &auto_ds, true);
 }
 EXPORT_SYMBOL_GPL(mwifiex_disable_auto_ds);
 
@@ -571,8 +604,8 @@ int mwifiex_drv_get_data_rate(struct mwifiex_private *priv, u32 *rate)
 {
  int ret;
 
- ret = mwifiex_send_cmd_sync(priv, HostCmd_CMD_802_11_TX_RATE_QUERY,
-        HostCmd_ACT_GEN_GET, 0, NULL);
+ ret = mwifiex_send_cmd(priv, HostCmd_CMD_802_11_TX_RATE_QUERY,
+          HostCmd_ACT_GEN_GET, 0, NULL, true);
 
  if (!ret) {
   if (priv->is_data_rate_auto)
@@ -628,8 +661,9 @@ int mwifiex_set_tx_power(struct mwifiex_private *priv,
   txp_cfg->mode = cpu_to_le32(1);
   pg_tlv = (struct mwifiex_types_power_group *)
     (buf + sizeof(struct host_cmd_ds_txpwr_cfg));
-  pg_tlv->type = TLV_TYPE_POWER_GROUP;
-  pg_tlv->length = 4 * sizeof(struct mwifiex_power_group);
+  pg_tlv->type = cpu_to_le16(TLV_TYPE_POWER_GROUP);
+  pg_tlv->length =
+   cpu_to_le16(4 * sizeof(struct mwifiex_power_group));
   pg = (struct mwifiex_power_group *)
        (buf + sizeof(struct host_cmd_ds_txpwr_cfg)
         + sizeof(struct mwifiex_types_power_group));
@@ -667,8 +701,8 @@ int mwifiex_set_tx_power(struct mwifiex_private *priv,
   pg->power_max = (s8) dbm;
   pg->ht_bandwidth = HT_BW_40;
  }
- ret = mwifiex_send_cmd_sync(priv, HostCmd_CMD_TXPWR_CFG,
-        HostCmd_ACT_GEN_SET, 0, buf);
+ ret = mwifiex_send_cmd(priv, HostCmd_CMD_TXPWR_CFG,
+          HostCmd_ACT_GEN_SET, 0, buf, true);
 
  kfree(buf);
  return ret;
@@ -691,12 +725,11 @@ int mwifiex_drv_set_power(struct mwifiex_private *priv, u32 *ps_mode)
  else
   adapter->ps_mode = MWIFIEX_802_11_POWER_MODE_CAM;
  sub_cmd = (*ps_mode) ? EN_AUTO_PS : DIS_AUTO_PS;
- ret = mwifiex_send_cmd_sync(priv, HostCmd_CMD_802_11_PS_MODE_ENH,
-        sub_cmd, BITMAP_STA_PS, NULL);
+ ret = mwifiex_send_cmd(priv, HostCmd_CMD_802_11_PS_MODE_ENH,
+          sub_cmd, BITMAP_STA_PS, NULL, true);
  if ((!ret) && (sub_cmd == DIS_AUTO_PS))
-  ret = mwifiex_send_cmd_async(priv,
-          HostCmd_CMD_802_11_PS_MODE_ENH,
-          GET_PS, 0, NULL);
+  ret = mwifiex_send_cmd(priv, HostCmd_CMD_802_11_PS_MODE_ENH,
+           GET_PS, 0, NULL, false);
 
  return ret;
 }
@@ -787,15 +820,16 @@ static int mwifiex_set_wps_ie(struct mwifiex_private *priv,
           u8 *ie_data_ptr, u16 ie_len)
 {
  if (ie_len) {
-  priv->wps_ie = kzalloc(MWIFIEX_MAX_VSIE_LEN, GFP_KERNEL);
-  if (!priv->wps_ie)
-   return -ENOMEM;
-  if (ie_len > sizeof(priv->wps_ie)) {
+  if (ie_len > MWIFIEX_MAX_VSIE_LEN) {
    dev_dbg(priv->adapter->dev,
     "info: failed to copy WPS IE, too big\n");
-   kfree(priv->wps_ie);
    return -1;
   }
+
+  priv->wps_ie = kzalloc(MWIFIEX_MAX_VSIE_LEN, GFP_KERNEL);
+  if (!priv->wps_ie)
+   return -ENOMEM;
+
   memcpy(priv->wps_ie, ie_data_ptr, ie_len);
   priv->wps_ie_len = ie_len;
   dev_dbg(priv->adapter->dev, "cmd: Set wps_ie_len=%d IE=%#x\n",
@@ -819,9 +853,9 @@ static int mwifiex_sec_ioctl_set_wapi_key(struct mwifiex_private *priv,
           struct mwifiex_ds_encrypt_key *encrypt_key)
 {
 
- return mwifiex_send_cmd_sync(priv, HostCmd_CMD_802_11_KEY_MATERIAL,
-         HostCmd_ACT_GEN_SET, KEY_INFO_ENABLED,
-         encrypt_key);
+ return mwifiex_send_cmd(priv, HostCmd_CMD_802_11_KEY_MATERIAL,
+    HostCmd_ACT_GEN_SET, KEY_INFO_ENABLED,
+    encrypt_key, true);
 }
 
 /*
@@ -833,6 +867,7 @@ static int mwifiex_sec_ioctl_set_wapi_key(struct mwifiex_private *priv,
 static int mwifiex_sec_ioctl_set_wep_key(struct mwifiex_private *priv,
          struct mwifiex_ds_encrypt_key *encrypt_key)
 {
+ struct mwifiex_adapter *adapter = priv->adapter;
  int ret;
  struct mwifiex_wep_key *wep_key;
  int index;
@@ -847,10 +882,17 @@ static int mwifiex_sec_ioctl_set_wep_key(struct mwifiex_private *priv,
   /* Copy the required key as the current key */
   wep_key = &priv->wep_key[index];
   if (!wep_key->key_length) {
-   dev_err(priv->adapter->dev,
+   dev_err(adapter->dev,
     "key not set, so cannot enable it\n");
    return -1;
   }
+
+  if (adapter->fw_key_api_major_ver == FW_KEY_API_VER_MAJOR_V2) {
+   memcpy(encrypt_key->key_material,
+          wep_key->key_material, wep_key->key_length);
+   encrypt_key->key_len = wep_key->key_length;
+  }
+
   priv->wep_key_curr_index = (u16) index;
   priv->sec_info.wep_enabled = 1;
  } else {
@@ -865,21 +907,32 @@ static int mwifiex_sec_ioctl_set_wep_key(struct mwifiex_private *priv,
   priv->sec_info.wep_enabled = 1;
  }
  if (wep_key->key_length) {
+  void *enc_key;
+
+  if (encrypt_key->key_disable)
+   memset(&priv->wep_key[index], 0,
+          sizeof(struct mwifiex_wep_key));
+
+  if (adapter->fw_key_api_major_ver == FW_KEY_API_VER_MAJOR_V2)
+   enc_key = encrypt_key;
+  else
+   enc_key = NULL;
+
   /* Send request to firmware */
-  ret = mwifiex_send_cmd_async(priv,
-          HostCmd_CMD_802_11_KEY_MATERIAL,
-          HostCmd_ACT_GEN_SET, 0, NULL);
+  ret = mwifiex_send_cmd(priv, HostCmd_CMD_802_11_KEY_MATERIAL,
+           HostCmd_ACT_GEN_SET, 0, enc_key, false);
   if (ret)
    return ret;
  }
+
  if (priv->sec_info.wep_enabled)
   priv->curr_pkt_filter |= HostCmd_ACT_MAC_WEP_ENABLE;
  else
   priv->curr_pkt_filter &= ~HostCmd_ACT_MAC_WEP_ENABLE;
 
- ret = mwifiex_send_cmd_sync(priv, HostCmd_CMD_MAC_CONTROL,
-        HostCmd_ACT_GEN_SET, 0,
-        &priv->curr_pkt_filter);
+ ret = mwifiex_send_cmd(priv, HostCmd_CMD_MAC_CONTROL,
+          HostCmd_ACT_GEN_SET, 0,
+          &priv->curr_pkt_filter, true);
 
  return ret;
 }
@@ -914,10 +967,9 @@ static int mwifiex_sec_ioctl_set_wpa_key(struct mwifiex_private *priv,
    */
   /* Send the key as PTK to firmware */
   encrypt_key->key_index = MWIFIEX_KEY_INDEX_UNICAST;
-  ret = mwifiex_send_cmd_async(priv,
-          HostCmd_CMD_802_11_KEY_MATERIAL,
-          HostCmd_ACT_GEN_SET,
-          KEY_INFO_ENABLED, encrypt_key);
+  ret = mwifiex_send_cmd(priv, HostCmd_CMD_802_11_KEY_MATERIAL,
+           HostCmd_ACT_GEN_SET,
+           KEY_INFO_ENABLED, encrypt_key, false);
   if (ret)
    return ret;
 
@@ -941,15 +993,13 @@ static int mwifiex_sec_ioctl_set_wpa_key(struct mwifiex_private *priv,
   encrypt_key->key_index = MWIFIEX_KEY_INDEX_UNICAST;
 
  if (remove_key)
-  ret = mwifiex_send_cmd_sync(priv,
-         HostCmd_CMD_802_11_KEY_MATERIAL,
-         HostCmd_ACT_GEN_SET,
-         !KEY_INFO_ENABLED, encrypt_key);
+  ret = mwifiex_send_cmd(priv, HostCmd_CMD_802_11_KEY_MATERIAL,
+           HostCmd_ACT_GEN_SET,
+           !KEY_INFO_ENABLED, encrypt_key, true);
  else
-  ret = mwifiex_send_cmd_sync(priv,
-         HostCmd_CMD_802_11_KEY_MATERIAL,
-         HostCmd_ACT_GEN_SET,
-         KEY_INFO_ENABLED, encrypt_key);
+  ret = mwifiex_send_cmd(priv, HostCmd_CMD_802_11_KEY_MATERIAL,
+           HostCmd_ACT_GEN_SET,
+           KEY_INFO_ENABLED, encrypt_key, true);
 
  return ret;
 }
@@ -1012,19 +1062,27 @@ int mwifiex_set_encode(struct mwifiex_private *priv, struct key_params *kp,
 
  memset(&encrypt_key, 0, sizeof(struct mwifiex_ds_encrypt_key));
  encrypt_key.key_len = key_len;
+ encrypt_key.key_index = key_index;
 
  if (kp && kp->cipher == WLAN_CIPHER_SUITE_AES_CMAC)
   encrypt_key.is_igtk_key = true;
 
  if (!disable) {
-  encrypt_key.key_index = key_index;
   if (key_len)
    memcpy(encrypt_key.key_material, key, key_len);
+  else
+   encrypt_key.is_current_wep_key = true;
+
   if (mac_addr)
    memcpy(encrypt_key.mac_addr, mac_addr, ETH_ALEN);
-  if (kp && kp->seq && kp->seq_len)
+  if (kp && kp->seq && kp->seq_len) {
    memcpy(encrypt_key.pn, kp->seq, kp->seq_len);
+   encrypt_key.pn_len = kp->seq_len;
+   encrypt_key.is_rx_seq_valid = true;
+  }
  } else {
+  if (GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_UAP)
+   return 0;
   encrypt_key.key_disable = true;
   if (mac_addr)
    memcpy(encrypt_key.mac_addr, mac_addr, ETH_ALEN);
@@ -1045,8 +1103,8 @@ mwifiex_get_ver_ext(struct mwifiex_private *priv)
  struct mwifiex_ver_ext ver_ext;
 
  memset(&ver_ext, 0, sizeof(struct host_cmd_ds_version_ext));
- if (mwifiex_send_cmd_sync(priv, HostCmd_CMD_VERSION_EXT,
-      HostCmd_ACT_GEN_GET, 0, &ver_ext))
+ if (mwifiex_send_cmd(priv, HostCmd_CMD_VERSION_EXT,
+        HostCmd_ACT_GEN_GET, 0, &ver_ext, true))
   return -1;
 
  return 0;
@@ -1071,8 +1129,8 @@ mwifiex_remain_on_chan_cfg(struct mwifiex_private *priv, u16 action,
    ieee80211_frequency_to_channel(chan->center_freq);
   roc_cfg.duration = cpu_to_le32(duration);
  }
- if (mwifiex_send_cmd_sync(priv, HostCmd_CMD_REMAIN_ON_CHAN,
-      action, 0, &roc_cfg)) {
+ if (mwifiex_send_cmd(priv, HostCmd_CMD_REMAIN_ON_CHAN,
+        action, 0, &roc_cfg, true)) {
   dev_err(priv->adapter->dev, "failed to remain on channel\n");
   return -1;
  }
@@ -1104,8 +1162,8 @@ mwifiex_set_bss_role(struct mwifiex_private *priv, u8 bss_role)
   break;
  }
 
- mwifiex_send_cmd_sync(priv, HostCmd_CMD_SET_BSS_MODE,
-         HostCmd_ACT_GEN_SET, 0, NULL);
+ mwifiex_send_cmd(priv, HostCmd_CMD_SET_BSS_MODE,
+    HostCmd_ACT_GEN_SET, 0, NULL, true);
 
  return mwifiex_sta_init_cmd(priv, false);
 }
@@ -1120,8 +1178,8 @@ int
 mwifiex_get_stats_info(struct mwifiex_private *priv,
          struct mwifiex_ds_get_stats *log)
 {
- return mwifiex_send_cmd_sync(priv, HostCmd_CMD_802_11_GET_LOG,
-         HostCmd_ACT_GEN_GET, 0, log);
+ return mwifiex_send_cmd(priv, HostCmd_CMD_802_11_GET_LOG,
+    HostCmd_ACT_GEN_GET, 0, log, true);
 }
 
 /*
@@ -1163,8 +1221,7 @@ static int mwifiex_reg_mem_ioctl_reg_rw(struct mwifiex_private *priv,
   return -1;
  }
 
- return mwifiex_send_cmd_sync(priv, cmd_no, action, 0, reg_rw);
-
+ return mwifiex_send_cmd(priv, cmd_no, action, 0, reg_rw, true);
 }
 
 /*
@@ -1229,8 +1286,8 @@ mwifiex_eeprom_read(struct mwifiex_private *priv, u16 offset, u16 bytes,
  rd_eeprom.byte_count = cpu_to_le16((u16) bytes);
 
  /* Send request to firmware */
- ret = mwifiex_send_cmd_sync(priv, HostCmd_CMD_802_11_EEPROM_ACCESS,
-        HostCmd_ACT_GEN_GET, 0, &rd_eeprom);
+ ret = mwifiex_send_cmd(priv, HostCmd_CMD_802_11_EEPROM_ACCESS,
+          HostCmd_ACT_GEN_GET, 0, &rd_eeprom, true);
 
  if (!ret)
   memcpy(value, rd_eeprom.value, MAX_EEPROM_DATA);
@@ -1359,7 +1416,7 @@ static int mwifiex_misc_ioctl_gen_ie(struct mwifiex_private *priv,
  * with requisite parameters and calls the IOCTL handler.
  */
 int
-mwifiex_set_gen_ie(struct mwifiex_private *priv, u8 *ie, int ie_len)
+mwifiex_set_gen_ie(struct mwifiex_private *priv, const u8 *ie, int ie_len)
 {
  struct mwifiex_ds_misc_gen_ie gen_ie;
 
diff --git a/drivers/net/wireless/mwifiex/sta_rx.c b/drivers/net/wireless/mwifiex/sta_rx.c
index b5c1095..8b639d7 100644
--- a/drivers/net/wireless/mwifiex/sta_rx.c
+++ b/drivers/net/wireless/mwifiex/sta_rx.c
@@ -17,6 +17,8 @@
  * this warranty disclaimer.
  */
 
+#include <uapi/linux/ipv6.h>
+#include <net/ndisc.h>
 #include "decl.h"
 #include "ioctl.h"
 #include "util.h"
@@ -25,6 +27,46 @@
 #include "11n_aggr.h"
 #include "11n_rxreorder.h"
 
+/* This function checks if a frame is IPv4 ARP or IPv6 Neighbour advertisement
+ * frame. If frame has both source and destination mac address as same, this
+ * function drops such gratuitous frames.
+ */
+static bool
+mwifiex_discard_gratuitous_arp(struct mwifiex_private *priv,
+          struct sk_buff *skb)
+{
+ const struct mwifiex_arp_eth_header *arp;
+ struct ethhdr *eth;
+ struct ipv6hdr *ipv6;
+ struct icmp6hdr *icmpv6;
+
+ eth = (struct ethhdr *)skb->data;
+ switch (ntohs(eth->h_proto)) {
+ case ETH_P_ARP:
+  arp = (void *)(skb->data + sizeof(struct ethhdr));
+  if (arp->hdr.ar_op == htons(ARPOP_REPLY) ||
+      arp->hdr.ar_op == htons(ARPOP_REQUEST)) {
+   if (!memcmp(arp->ar_sip, arp->ar_tip, 4))
+    return true;
+  }
+  break;
+ case ETH_P_IPV6:
+  ipv6 = (void *)(skb->data + sizeof(struct ethhdr));
+  icmpv6 = (void *)(skb->data + sizeof(struct ethhdr) +
+      sizeof(struct ipv6hdr));
+  if (NDISC_NEIGHBOUR_ADVERTISEMENT == icmpv6->icmp6_type) {
+   if (!memcmp(&ipv6->saddr, &ipv6->daddr,
+        sizeof(struct in6_addr)))
+    return true;
+  }
+  break;
+ default:
+  break;
+ }
+
+ return false;
+}
+
 /*
  * This function processes the received packet and forwards it
  * to kernel/upper layer.
@@ -45,16 +87,22 @@ int mwifiex_process_rx_packet(struct mwifiex_private *priv,
  struct rx_packet_hdr *rx_pkt_hdr;
  struct rxpd *local_rx_pd;
  int hdr_chop;
- struct ethhdr *eth_hdr;
- u8 rfc1042_eth_hdr[ETH_ALEN] = { 0xaa, 0xaa, 0x03, 0x00, 0x00, 0x00 };
+ struct ethhdr *eth;
+ u16 rx_pkt_off, rx_pkt_len;
+ u8 *offset;
 
  local_rx_pd = (struct rxpd *) (skb->data);
 
- rx_pkt_hdr = (void *)local_rx_pd +
-       le16_to_cpu(local_rx_pd->rx_pkt_offset);
+ rx_pkt_off = le16_to_cpu(local_rx_pd->rx_pkt_offset);
+ rx_pkt_len = le16_to_cpu(local_rx_pd->rx_pkt_length);
+ rx_pkt_hdr = (void *)local_rx_pd + rx_pkt_off;
 
- if (!memcmp(&rx_pkt_hdr->rfc1042_hdr,
-      rfc1042_eth_hdr, sizeof(rfc1042_eth_hdr))) {
+ if ((!memcmp(&rx_pkt_hdr->rfc1042_hdr, bridge_tunnel_header,
+       sizeof(bridge_tunnel_header))) ||
+     (!memcmp(&rx_pkt_hdr->rfc1042_hdr, rfc1042_header,
+       sizeof(rfc1042_header)) &&
+      ntohs(rx_pkt_hdr->rfc1042_hdr.snap_type) != ETH_P_AARP &&
+      ntohs(rx_pkt_hdr->rfc1042_hdr.snap_type) != ETH_P_IPX)) {
   /*
    *  Replace the 803 header and rfc1042 header (llc/snap) with an
    *    EthernetII header, keep the src/dst and snap_type
@@ -64,7 +112,7 @@ int mwifiex_process_rx_packet(struct mwifiex_private *priv,
    *  To create the Ethernet II, just move the src, dst address
    *    right before the snap_type.
    */
-  eth_hdr = (struct ethhdr *)
+  eth = (struct ethhdr *)
    ((u8 *) &rx_pkt_hdr->eth803_hdr
     + sizeof(rx_pkt_hdr->eth803_hdr) +
     sizeof(rx_pkt_hdr->rfc1042_hdr)
@@ -72,14 +120,14 @@ int mwifiex_process_rx_packet(struct mwifiex_private *priv,
     - sizeof(rx_pkt_hdr->eth803_hdr.h_source)
     - sizeof(rx_pkt_hdr->rfc1042_hdr.snap_type));
 
-  memcpy(eth_hdr->h_source, rx_pkt_hdr->eth803_hdr.h_source,
-         sizeof(eth_hdr->h_source));
-  memcpy(eth_hdr->h_dest, rx_pkt_hdr->eth803_hdr.h_dest,
-         sizeof(eth_hdr->h_dest));
+  memcpy(eth->h_source, rx_pkt_hdr->eth803_hdr.h_source,
+         sizeof(eth->h_source));
+  memcpy(eth->h_dest, rx_pkt_hdr->eth803_hdr.h_dest,
+         sizeof(eth->h_dest));
 
   /* Chop off the rxpd + the excess memory from the 802.2/llc/snap
      header that was removed. */
-  hdr_chop = (u8 *) eth_hdr - (u8 *) local_rx_pd;
+  hdr_chop = (u8 *) eth - (u8 *) local_rx_pd;
  } else {
   /* Chop off the rxpd */
   hdr_chop = (u8 *) &rx_pkt_hdr->eth803_hdr -
@@ -90,6 +138,19 @@ int mwifiex_process_rx_packet(struct mwifiex_private *priv,
     either the reconstructed EthII frame or the 802.2/llc/snap frame */
  skb_pull(skb, hdr_chop);
 
+ if (priv->hs2_enabled &&
+     mwifiex_discard_gratuitous_arp(priv, skb)) {
+  dev_dbg(priv->adapter->dev, "Bypassed Gratuitous ARP\n");
+  dev_kfree_skb_any(skb);
+  return 0;
+ }
+
+ if (ISSUPP_TDLS_ENABLED(priv->adapter->fw_cap_info) &&
+     ntohs(rx_pkt_hdr->eth803_hdr.h_proto) == ETH_P_TDLS) {
+  offset = (u8 *)local_rx_pd + rx_pkt_off;
+  mwifiex_process_tdls_action_frame(priv, offset, rx_pkt_len);
+ }
+
  priv->rxpd_rate = local_rx_pd->rx_rate;
 
  priv->rxpd_htinfo = local_rx_pd->ht_info;
@@ -122,6 +183,7 @@ int mwifiex_process_sta_rx_packet(struct mwifiex_private *priv,
  struct rx_packet_hdr *rx_pkt_hdr;
  u8 ta[ETH_ALEN];
  u16 rx_pkt_type, rx_pkt_offset, rx_pkt_length, seq_num;
+ struct mwifiex_sta_node *sta_ptr;
 
  local_rx_pd = (struct rxpd *) (skb->data);
  rx_pkt_type = le16_to_cpu(local_rx_pd->rx_pkt_type);
@@ -136,35 +198,11 @@ int mwifiex_process_sta_rx_packet(struct mwifiex_private *priv,
    "wrong rx packet: len=%d, rx_pkt_offset=%d, rx_pkt_length=%d\n",
    skb->len, rx_pkt_offset, rx_pkt_length);
   priv->stats.rx_dropped++;
-
-  if (adapter->if_ops.data_complete)
-   adapter->if_ops.data_complete(adapter, skb);
-  else
-   dev_kfree_skb_any(skb);
-
+  dev_kfree_skb_any(skb);
   return ret;
  }
 
- if (rx_pkt_type == PKT_TYPE_AMSDU) {
-  struct sk_buff_head list;
-  struct sk_buff *rx_skb;
-
-  __skb_queue_head_init(&list);
-
-  skb_pull(skb, rx_pkt_offset);
-  skb_trim(skb, rx_pkt_length);
-
-  ieee80211_amsdu_to_8023s(skb, &list, priv->curr_addr,
-      priv->wdev->iftype, 0, false);
-
-  while (!skb_queue_empty(&list)) {
-   rx_skb = __skb_dequeue(&list);
-   ret = mwifiex_recv_packet(priv, rx_skb);
-   if (ret == -1)
-    dev_err(adapter->dev, "Rx of A-MSDU failed");
-  }
-  return 0;
- } else if (rx_pkt_type == PKT_TYPE_MGMT) {
+ if (rx_pkt_type == PKT_TYPE_MGMT) {
   ret = mwifiex_process_mgmt_packet(priv, skb);
   if (ret)
    dev_err(adapter->dev, "Rx of mgmt packet failed");
@@ -176,14 +214,25 @@ int mwifiex_process_sta_rx_packet(struct mwifiex_private *priv,
   * If the packet is not an unicast packet then send the packet
   * directly to os. Don't pass thru rx reordering
   */
- if (!IS_11N_ENABLED(priv) ||
-     memcmp(priv->curr_addr, rx_pkt_hdr->eth803_hdr.h_dest, ETH_ALEN)) {
+ if ((!IS_11N_ENABLED(priv) &&
+      !(ISSUPP_TDLS_ENABLED(priv->adapter->fw_cap_info) &&
+        !(local_rx_pd->flags & MWIFIEX_RXPD_FLAGS_TDLS_PACKET))) ||
+     !ether_addr_equal_unaligned(priv->curr_addr, rx_pkt_hdr->eth803_hdr.h_dest)) {
   mwifiex_process_rx_packet(priv, skb);
   return ret;
  }
 
- if (mwifiex_queuing_ra_based(priv)) {
+ if (mwifiex_queuing_ra_based(priv) ||
+     (ISSUPP_TDLS_ENABLED(priv->adapter->fw_cap_info) &&
+      local_rx_pd->flags & MWIFIEX_RXPD_FLAGS_TDLS_PACKET)) {
   memcpy(ta, rx_pkt_hdr->eth803_hdr.h_source, ETH_ALEN);
+  if (local_rx_pd->flags & MWIFIEX_RXPD_FLAGS_TDLS_PACKET &&
+      local_rx_pd->priority < MAX_NUM_TID) {
+   sta_ptr = mwifiex_get_sta_entry(priv, ta);
+   if (sta_ptr)
+    sta_ptr->rx_seq[local_rx_pd->priority] =
+           le16_to_cpu(local_rx_pd->seq_num);
+  }
  } else {
   if (rx_pkt_type != PKT_TYPE_BAR)
    priv->rx_seq[local_rx_pd->priority] = seq_num;
@@ -195,12 +244,8 @@ int mwifiex_process_sta_rx_packet(struct mwifiex_private *priv,
  ret = mwifiex_11n_rx_reorder_pkt(priv, seq_num, local_rx_pd->priority,
       ta, (u8) rx_pkt_type, skb);
 
- if (ret || (rx_pkt_type == PKT_TYPE_BAR)) {
-  if (adapter->if_ops.data_complete)
-   adapter->if_ops.data_complete(adapter, skb);
-  else
-   dev_kfree_skb_any(skb);
- }
+ if (ret || (rx_pkt_type == PKT_TYPE_BAR))
+  dev_kfree_skb_any(skb);
 
  if (ret)
   priv->stats.rx_dropped++;
diff --git a/drivers/net/wireless/mwifiex/sta_tx.c b/drivers/net/wireless/mwifiex/sta_tx.c
index 7b581af..70eb863 100644
--- a/drivers/net/wireless/mwifiex/sta_tx.c
+++ b/drivers/net/wireless/mwifiex/sta_tx.c
@@ -95,6 +95,9 @@ void *mwifiex_process_sta_txpd(struct mwifiex_private *priv,
   }
  }
 
+ if (tx_info->flags & MWIFIEX_BUF_FLAG_TDLS_PKT)
+  local_tx_pd->flags |= MWIFIEX_TXPD_FLAGS_TDLS_PACKET;
+
  /* Offset of actual data */
  pkt_offset = sizeof(struct txpd) + pad;
  if (pkt_type == PKT_TYPE_MGMT) {
@@ -125,6 +128,7 @@ int mwifiex_send_null_packet(struct mwifiex_private *priv, u8 flags)
 {
  struct mwifiex_adapter *adapter = priv->adapter;
  struct txpd *local_tx_pd;
+ struct mwifiex_tx_param tx_param;
 /* sizeof(struct txpd) + Interface specific header */
 #define NULL_PACKET_HDR 64
  u32 data_len = NULL_PACKET_HDR;
@@ -146,8 +150,10 @@ int mwifiex_send_null_packet(struct mwifiex_private *priv, u8 flags)
   return -1;
 
  tx_info = MWIFIEX_SKB_TXCB(skb);
+ memset(tx_info, 0, sizeof(*tx_info));
  tx_info->bss_num = priv->bss_num;
  tx_info->bss_type = priv->bss_type;
+ tx_info->pkt_len = data_len - (sizeof(struct txpd) + INTF_HEADER_LEN);
  skb_reserve(skb, sizeof(struct txpd) + INTF_HEADER_LEN);
  skb_push(skb, sizeof(struct txpd));
 
@@ -164,8 +170,9 @@ int mwifiex_send_null_packet(struct mwifiex_private *priv, u8 flags)
          skb, NULL);
  } else {
   skb_push(skb, INTF_HEADER_LEN);
+  tx_param.next_pkt_len = 0;
   ret = adapter->if_ops.host_to_card(adapter, MWIFIEX_TYPE_DATA,
-         skb, NULL);
+         skb, &tx_param);
  }
  switch (ret) {
  case -EBUSY:
diff --git a/drivers/net/wireless/mwifiex/tdls.c b/drivers/net/wireless/mwifiex/tdls.c
new file mode 100644
index 0000000..0e88364
--- /dev/null
+++ b/drivers/net/wireless/mwifiex/tdls.c
@@ -0,0 +1,1103 @@
+/* Marvell Wireless LAN device driver: TDLS handling
+ *
+ * Copyright (C) 2014, Marvell International Ltd.
+ *
+ * This software file (the "File") is distributed by Marvell International
+ * Ltd. under the terms of the GNU General Public License Version 2, June 1991
+ * (the "License").  You may use, redistribute and/or modify this File in
+ * accordance with the terms and conditions of the License, a copy of which
+ * is available on the worldwide web at
+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.
+ *
+ * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE
+ * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about
+ * this warranty disclaimer.
+ */
+
+#include "main.h"
+#include "wmm.h"
+#include "11n.h"
+#include "11n_rxreorder.h"
+#include "11ac.h"
+
+#define TDLS_REQ_FIX_LEN      6
+#define TDLS_RESP_FIX_LEN     8
+#define TDLS_CONFIRM_FIX_LEN  6
+
+static void mwifiex_restore_tdls_packets(struct mwifiex_private *priv,
+      const u8 *mac, u8 status)
+{
+ struct mwifiex_ra_list_tbl *ra_list;
+ struct list_head *tid_list;
+ struct sk_buff *skb, *tmp;
+ struct mwifiex_txinfo *tx_info;
+ unsigned long flags;
+ u32 tid;
+ u8 tid_down;
+
+ dev_dbg(priv->adapter->dev, "%s: %pM\n", __func__, mac);
+ spin_lock_irqsave(&priv->wmm.ra_list_spinlock, flags);
+
+ skb_queue_walk_safe(&priv->tdls_txq, skb, tmp) {
+  if (!ether_addr_equal(mac, skb->data))
+   continue;
+
+  __skb_unlink(skb, &priv->tdls_txq);
+  tx_info = MWIFIEX_SKB_TXCB(skb);
+  tid = skb->priority;
+  tid_down = mwifiex_wmm_downgrade_tid(priv, tid);
+
+  if (status == TDLS_SETUP_COMPLETE) {
+   ra_list = mwifiex_wmm_get_queue_raptr(priv, tid, mac);
+   ra_list->tdls_link = true;
+   tx_info->flags |= MWIFIEX_BUF_FLAG_TDLS_PKT;
+  } else {
+   tid_list = &priv->wmm.tid_tbl_ptr[tid_down].ra_list;
+   if (!list_empty(tid_list))
+    ra_list = list_first_entry(tid_list,
+           struct mwifiex_ra_list_tbl, list);
+   else
+    ra_list = NULL;
+   tx_info->flags &= ~MWIFIEX_BUF_FLAG_TDLS_PKT;
+  }
+
+  if (!ra_list) {
+   mwifiex_write_data_complete(priv->adapter, skb, 0, -1);
+   continue;
+  }
+
+  skb_queue_tail(&ra_list->skb_head, skb);
+
+  ra_list->ba_pkt_count++;
+  ra_list->total_pkt_count++;
+
+  if (atomic_read(&priv->wmm.highest_queued_prio) <
+             tos_to_tid_inv[tid_down])
+   atomic_set(&priv->wmm.highest_queued_prio,
+       tos_to_tid_inv[tid_down]);
+
+  atomic_inc(&priv->wmm.tx_pkts_queued);
+ }
+
+ spin_unlock_irqrestore(&priv->wmm.ra_list_spinlock, flags);
+ return;
+}
+
+static void mwifiex_hold_tdls_packets(struct mwifiex_private *priv,
+          const u8 *mac)
+{
+ struct mwifiex_ra_list_tbl *ra_list;
+ struct list_head *ra_list_head;
+ struct sk_buff *skb, *tmp;
+ unsigned long flags;
+ int i;
+
+ dev_dbg(priv->adapter->dev, "%s: %pM\n", __func__, mac);
+ spin_lock_irqsave(&priv->wmm.ra_list_spinlock, flags);
+
+ for (i = 0; i < MAX_NUM_TID; i++) {
+  if (!list_empty(&priv->wmm.tid_tbl_ptr[i].ra_list)) {
+   ra_list_head = &priv->wmm.tid_tbl_ptr[i].ra_list;
+   list_for_each_entry(ra_list, ra_list_head, list) {
+    skb_queue_walk_safe(&ra_list->skb_head, skb,
+          tmp) {
+     if (!ether_addr_equal(mac, skb->data))
+      continue;
+     __skb_unlink(skb, &ra_list->skb_head);
+     atomic_dec(&priv->wmm.tx_pkts_queued);
+     ra_list->total_pkt_count--;
+     skb_queue_tail(&priv->tdls_txq, skb);
+    }
+   }
+  }
+ }
+
+ spin_unlock_irqrestore(&priv->wmm.ra_list_spinlock, flags);
+ return;
+}
+
+/* This function appends rate TLV to scan config command. */
+static int
+mwifiex_tdls_append_rates_ie(struct mwifiex_private *priv,
+        struct sk_buff *skb)
+{
+ u8 rates[MWIFIEX_SUPPORTED_RATES], *pos;
+ u16 rates_size, supp_rates_size, ext_rates_size;
+
+ memset(rates, 0, sizeof(rates));
+ rates_size = mwifiex_get_supported_rates(priv, rates);
+
+ supp_rates_size = min_t(u16, rates_size, MWIFIEX_TDLS_SUPPORTED_RATES);
+
+ if (skb_tailroom(skb) < rates_size + 4) {
+  dev_err(priv->adapter->dev,
+   "Insuffient space while adding rates\n");
+  return -ENOMEM;
+ }
+
+ pos = skb_put(skb, supp_rates_size + 2);
+ *pos++ = WLAN_EID_SUPP_RATES;
+ *pos++ = supp_rates_size;
+ memcpy(pos, rates, supp_rates_size);
+
+ if (rates_size > MWIFIEX_TDLS_SUPPORTED_RATES) {
+  ext_rates_size = rates_size - MWIFIEX_TDLS_SUPPORTED_RATES;
+  pos = skb_put(skb, ext_rates_size + 2);
+  *pos++ = WLAN_EID_EXT_SUPP_RATES;
+  *pos++ = ext_rates_size;
+  memcpy(pos, rates + MWIFIEX_TDLS_SUPPORTED_RATES,
+         ext_rates_size);
+ }
+
+ return 0;
+}
+
+static void mwifiex_tdls_add_aid(struct mwifiex_private *priv,
+    struct sk_buff *skb)
+{
+ struct ieee_types_assoc_rsp *assoc_rsp;
+ u8 *pos;
+
+ assoc_rsp = (struct ieee_types_assoc_rsp *)&priv->assoc_rsp_buf;
+ pos = (void *)skb_put(skb, 4);
+ *pos++ = WLAN_EID_AID;
+ *pos++ = 2;
+ *pos++ = le16_to_cpu(assoc_rsp->a_id);
+
+ return;
+}
+
+static int mwifiex_tdls_add_vht_capab(struct mwifiex_private *priv,
+          struct sk_buff *skb)
+{
+ struct ieee80211_vht_cap vht_cap;
+ u8 *pos;
+
+ pos = (void *)skb_put(skb, sizeof(struct ieee80211_vht_cap) + 2);
+ *pos++ = WLAN_EID_VHT_CAPABILITY;
+ *pos++ = sizeof(struct ieee80211_vht_cap);
+
+ memset(&vht_cap, 0, sizeof(struct ieee80211_vht_cap));
+
+ mwifiex_fill_vht_cap_tlv(priv, &vht_cap, priv->curr_bss_params.band);
+ memcpy(pos, &vht_cap, sizeof(vht_cap));
+
+ return 0;
+}
+
+static int
+mwifiex_tdls_add_ht_oper(struct mwifiex_private *priv, const u8 *mac,
+    u8 vht_enabled, struct sk_buff *skb)
+{
+ struct ieee80211_ht_operation *ht_oper;
+ struct mwifiex_sta_node *sta_ptr;
+ struct mwifiex_bssdescriptor *bss_desc =
+     &priv->curr_bss_params.bss_descriptor;
+ u8 *pos;
+
+ sta_ptr = mwifiex_get_sta_entry(priv, mac);
+ if (unlikely(!sta_ptr)) {
+  dev_warn(priv->adapter->dev,
+    "TDLS peer station not found in list\n");
+  return -1;
+ }
+
+ pos = (void *)skb_put(skb, sizeof(struct ieee80211_ht_operation) + 2);
+ *pos++ = WLAN_EID_HT_OPERATION;
+ *pos++ = sizeof(struct ieee80211_ht_operation);
+ ht_oper = (void *)pos;
+
+ ht_oper->primary_chan = bss_desc->channel;
+
+ /* follow AP's channel bandwidth */
+ if (ISSUPP_CHANWIDTH40(priv->adapter->hw_dot_11n_dev_cap) &&
+     bss_desc->bcn_ht_cap &&
+     ISALLOWED_CHANWIDTH40(bss_desc->bcn_ht_oper->ht_param))
+  ht_oper->ht_param = bss_desc->bcn_ht_oper->ht_param;
+
+ if (vht_enabled) {
+  ht_oper->ht_param =
+     mwifiex_get_sec_chan_offset(bss_desc->channel);
+  ht_oper->ht_param |= BIT(2);
+ }
+
+ memcpy(&sta_ptr->tdls_cap.ht_oper, ht_oper,
+        sizeof(struct ieee80211_ht_operation));
+
+ return 0;
+}
+
+static int mwifiex_tdls_add_vht_oper(struct mwifiex_private *priv,
+         const u8 *mac, struct sk_buff *skb)
+{
+ struct mwifiex_bssdescriptor *bss_desc;
+ struct ieee80211_vht_operation *vht_oper;
+ struct ieee80211_vht_cap *vht_cap, *ap_vht_cap = NULL;
+ struct mwifiex_sta_node *sta_ptr;
+ struct mwifiex_adapter *adapter = priv->adapter;
+ u8 supp_chwd_set, peer_supp_chwd_set;
+ u8 *pos, ap_supp_chwd_set, chan_bw;
+ u16 mcs_map_user, mcs_map_resp, mcs_map_result;
+ u16 mcs_user, mcs_resp, nss;
+ u32 usr_vht_cap_info;
+
+ bss_desc = &priv->curr_bss_params.bss_descriptor;
+
+ sta_ptr = mwifiex_get_sta_entry(priv, mac);
+ if (unlikely(!sta_ptr)) {
+  dev_warn(adapter->dev, "TDLS peer station not found in list\n");
+  return -1;
+ }
+
+ if (!mwifiex_is_bss_in_11ac_mode(priv)) {
+  if (sta_ptr->tdls_cap.extcap.ext_capab[7] &
+     WLAN_EXT_CAPA8_TDLS_WIDE_BW_ENABLED) {
+   dev_dbg(adapter->dev,
+    "TDLS peer doesn't support wider bandwitdh\n");
+   return 0;
+  }
+ } else {
+  ap_vht_cap = bss_desc->bcn_vht_cap;
+ }
+
+ pos = (void *)skb_put(skb, sizeof(struct ieee80211_vht_operation) + 2);
+ *pos++ = WLAN_EID_VHT_OPERATION;
+ *pos++ = sizeof(struct ieee80211_vht_operation);
+ vht_oper = (struct ieee80211_vht_operation *)pos;
+
+ if (bss_desc->bss_band & BAND_A)
+  usr_vht_cap_info = adapter->usr_dot_11ac_dev_cap_a;
+ else
+  usr_vht_cap_info = adapter->usr_dot_11ac_dev_cap_bg;
+
+ /* find the minmum bandwith between AP/TDLS peers */
+ vht_cap = &sta_ptr->tdls_cap.vhtcap;
+ supp_chwd_set = GET_VHTCAP_CHWDSET(usr_vht_cap_info);
+ peer_supp_chwd_set =
+    GET_VHTCAP_CHWDSET(le32_to_cpu(vht_cap->vht_cap_info));
+ supp_chwd_set = min_t(u8, supp_chwd_set, peer_supp_chwd_set);
+
+ /* We need check AP's bandwidth when TDLS_WIDER_BANDWIDTH is off */
+
+ if (ap_vht_cap && sta_ptr->tdls_cap.extcap.ext_capab[7] &
+     WLAN_EXT_CAPA8_TDLS_WIDE_BW_ENABLED) {
+  ap_supp_chwd_set =
+        GET_VHTCAP_CHWDSET(le32_to_cpu(ap_vht_cap->vht_cap_info));
+  supp_chwd_set = min_t(u8, supp_chwd_set, ap_supp_chwd_set);
+ }
+
+ switch (supp_chwd_set) {
+ case IEEE80211_VHT_CHANWIDTH_80MHZ:
+  vht_oper->chan_width = IEEE80211_VHT_CHANWIDTH_80MHZ;
+  break;
+ case IEEE80211_VHT_CHANWIDTH_160MHZ:
+  vht_oper->chan_width = IEEE80211_VHT_CHANWIDTH_160MHZ;
+  break;
+ case IEEE80211_VHT_CHANWIDTH_80P80MHZ:
+  vht_oper->chan_width = IEEE80211_VHT_CHANWIDTH_80P80MHZ;
+  break;
+ default:
+  vht_oper->chan_width = IEEE80211_VHT_CHANWIDTH_USE_HT;
+  break;
+ }
+
+ mcs_map_user = GET_DEVRXMCSMAP(adapter->usr_dot_11ac_mcs_support);
+ mcs_map_resp = le16_to_cpu(vht_cap->supp_mcs.rx_mcs_map);
+ mcs_map_result = 0;
+
+ for (nss = 1; nss <= 8; nss++) {
+  mcs_user = GET_VHTNSSMCS(mcs_map_user, nss);
+  mcs_resp = GET_VHTNSSMCS(mcs_map_resp, nss);
+
+  if ((mcs_user == IEEE80211_VHT_MCS_NOT_SUPPORTED) ||
+      (mcs_resp == IEEE80211_VHT_MCS_NOT_SUPPORTED))
+   SET_VHTNSSMCS(mcs_map_result, nss,
+          IEEE80211_VHT_MCS_NOT_SUPPORTED);
+  else
+   SET_VHTNSSMCS(mcs_map_result, nss,
+          min_t(u16, mcs_user, mcs_resp));
+ }
+
+ vht_oper->basic_mcs_set = cpu_to_le16(mcs_map_result);
+
+ switch (vht_oper->chan_width) {
+ case IEEE80211_VHT_CHANWIDTH_80MHZ:
+  chan_bw = IEEE80211_VHT_CHANWIDTH_80MHZ;
+  break;
+ case IEEE80211_VHT_CHANWIDTH_160MHZ:
+  chan_bw = IEEE80211_VHT_CHANWIDTH_160MHZ;
+  break;
+ case IEEE80211_VHT_CHANWIDTH_80P80MHZ:
+  chan_bw = IEEE80211_VHT_CHANWIDTH_80MHZ;
+  break;
+ default:
+  chan_bw = IEEE80211_VHT_CHANWIDTH_USE_HT;
+  break;
+ }
+ vht_oper->center_freq_seg1_idx =
+   mwifiex_get_center_freq_index(priv, BAND_AAC,
+            bss_desc->channel,
+            chan_bw);
+
+ return 0;
+}
+
+static void mwifiex_tdls_add_ext_capab(struct mwifiex_private *priv,
+           struct sk_buff *skb)
+{
+ struct ieee_types_extcap *extcap;
+
+ extcap = (void *)skb_put(skb, sizeof(struct ieee_types_extcap));
+ extcap->ieee_hdr.element_id = WLAN_EID_EXT_CAPABILITY;
+ extcap->ieee_hdr.len = 8;
+ memset(extcap->ext_capab, 0, 8);
+ extcap->ext_capab[4] |= WLAN_EXT_CAPA5_TDLS_ENABLED;
+
+ if (priv->adapter->is_hw_11ac_capable)
+  extcap->ext_capab[7] |= WLAN_EXT_CAPA8_TDLS_WIDE_BW_ENABLED;
+}
+
+static void mwifiex_tdls_add_qos_capab(struct sk_buff *skb)
+{
+ u8 *pos = (void *)skb_put(skb, 3);
+
+ *pos++ = WLAN_EID_QOS_CAPA;
+ *pos++ = 1;
+ *pos++ = MWIFIEX_TDLS_DEF_QOS_CAPAB;
+}
+
+static int mwifiex_prep_tdls_encap_data(struct mwifiex_private *priv,
+     const u8 *peer, u8 action_code,
+     u8 dialog_token,
+     u16 status_code, struct sk_buff *skb)
+{
+ struct ieee80211_tdls_data *tf;
+ int ret;
+ u16 capab;
+ struct ieee80211_ht_cap *ht_cap;
+ u8 radio, *pos;
+
+ capab = priv->curr_bss_params.bss_descriptor.cap_info_bitmap;
+
+ tf = (void *)skb_put(skb, offsetof(struct ieee80211_tdls_data, u));
+ memcpy(tf->da, peer, ETH_ALEN);
+ memcpy(tf->sa, priv->curr_addr, ETH_ALEN);
+ tf->ether_type = cpu_to_be16(ETH_P_TDLS);
+ tf->payload_type = WLAN_TDLS_SNAP_RFTYPE;
+
+ switch (action_code) {
+ case WLAN_TDLS_SETUP_REQUEST:
+  tf->category = WLAN_CATEGORY_TDLS;
+  tf->action_code = WLAN_TDLS_SETUP_REQUEST;
+  skb_put(skb, sizeof(tf->u.setup_req));
+  tf->u.setup_req.dialog_token = dialog_token;
+  tf->u.setup_req.capability = cpu_to_le16(capab);
+  ret = mwifiex_tdls_append_rates_ie(priv, skb);
+  if (ret) {
+   dev_kfree_skb_any(skb);
+   return ret;
+  }
+
+  pos = (void *)skb_put(skb, sizeof(struct ieee80211_ht_cap) + 2);
+  *pos++ = WLAN_EID_HT_CAPABILITY;
+  *pos++ = sizeof(struct ieee80211_ht_cap);
+  ht_cap = (void *)pos;
+  radio = mwifiex_band_to_radio_type(priv->curr_bss_params.band);
+  ret = mwifiex_fill_cap_info(priv, radio, ht_cap);
+  if (ret) {
+   dev_kfree_skb_any(skb);
+   return ret;
+  }
+
+  if (priv->adapter->is_hw_11ac_capable) {
+   ret = mwifiex_tdls_add_vht_capab(priv, skb);
+   if (ret) {
+    dev_kfree_skb_any(skb);
+    return ret;
+   }
+   mwifiex_tdls_add_aid(priv, skb);
+  }
+
+  mwifiex_tdls_add_ext_capab(priv, skb);
+  mwifiex_tdls_add_qos_capab(skb);
+  break;
+
+ case WLAN_TDLS_SETUP_RESPONSE:
+  tf->category = WLAN_CATEGORY_TDLS;
+  tf->action_code = WLAN_TDLS_SETUP_RESPONSE;
+  skb_put(skb, sizeof(tf->u.setup_resp));
+  tf->u.setup_resp.status_code = cpu_to_le16(status_code);
+  tf->u.setup_resp.dialog_token = dialog_token;
+  tf->u.setup_resp.capability = cpu_to_le16(capab);
+  ret = mwifiex_tdls_append_rates_ie(priv, skb);
+  if (ret) {
+   dev_kfree_skb_any(skb);
+   return ret;
+  }
+
+  pos = (void *)skb_put(skb, sizeof(struct ieee80211_ht_cap) + 2);
+  *pos++ = WLAN_EID_HT_CAPABILITY;
+  *pos++ = sizeof(struct ieee80211_ht_cap);
+  ht_cap = (void *)pos;
+  radio = mwifiex_band_to_radio_type(priv->curr_bss_params.band);
+  ret = mwifiex_fill_cap_info(priv, radio, ht_cap);
+  if (ret) {
+   dev_kfree_skb_any(skb);
+   return ret;
+  }
+
+  if (priv->adapter->is_hw_11ac_capable) {
+   ret = mwifiex_tdls_add_vht_capab(priv, skb);
+   if (ret) {
+    dev_kfree_skb_any(skb);
+    return ret;
+   }
+   mwifiex_tdls_add_aid(priv, skb);
+  }
+
+  mwifiex_tdls_add_ext_capab(priv, skb);
+  mwifiex_tdls_add_qos_capab(skb);
+  break;
+
+ case WLAN_TDLS_SETUP_CONFIRM:
+  tf->category = WLAN_CATEGORY_TDLS;
+  tf->action_code = WLAN_TDLS_SETUP_CONFIRM;
+  skb_put(skb, sizeof(tf->u.setup_cfm));
+  tf->u.setup_cfm.status_code = cpu_to_le16(status_code);
+  tf->u.setup_cfm.dialog_token = dialog_token;
+  if (priv->adapter->is_hw_11ac_capable) {
+   ret = mwifiex_tdls_add_vht_oper(priv, peer, skb);
+   if (ret) {
+    dev_kfree_skb_any(skb);
+    return ret;
+   }
+   ret = mwifiex_tdls_add_ht_oper(priv, peer, 1, skb);
+   if (ret) {
+    dev_kfree_skb_any(skb);
+    return ret;
+   }
+  } else {
+   ret = mwifiex_tdls_add_ht_oper(priv, peer, 0, skb);
+   if (ret) {
+    dev_kfree_skb_any(skb);
+    return ret;
+   }
+  }
+  break;
+
+ case WLAN_TDLS_TEARDOWN:
+  tf->category = WLAN_CATEGORY_TDLS;
+  tf->action_code = WLAN_TDLS_TEARDOWN;
+  skb_put(skb, sizeof(tf->u.teardown));
+  tf->u.teardown.reason_code = cpu_to_le16(status_code);
+  break;
+
+ case WLAN_TDLS_DISCOVERY_REQUEST:
+  tf->category = WLAN_CATEGORY_TDLS;
+  tf->action_code = WLAN_TDLS_DISCOVERY_REQUEST;
+  skb_put(skb, sizeof(tf->u.discover_req));
+  tf->u.discover_req.dialog_token = dialog_token;
+  break;
+ default:
+  dev_err(priv->adapter->dev, "Unknown TDLS frame type.\n");
+  return -EINVAL;
+ }
+
+ return 0;
+}
+
+static void
+mwifiex_tdls_add_link_ie(struct sk_buff *skb, const u8 *src_addr,
+    const u8 *peer, const u8 *bssid)
+{
+ struct ieee80211_tdls_lnkie *lnkid;
+
+ lnkid = (void *)skb_put(skb, sizeof(struct ieee80211_tdls_lnkie));
+ lnkid->ie_type = WLAN_EID_LINK_ID;
+ lnkid->ie_len = sizeof(struct ieee80211_tdls_lnkie) -
+   sizeof(struct ieee_types_header);
+
+ memcpy(lnkid->bssid, bssid, ETH_ALEN);
+ memcpy(lnkid->init_sta, src_addr, ETH_ALEN);
+ memcpy(lnkid->resp_sta, peer, ETH_ALEN);
+}
+
+int mwifiex_send_tdls_data_frame(struct mwifiex_private *priv, const u8 *peer,
+     u8 action_code, u8 dialog_token,
+     u16 status_code, const u8 *extra_ies,
+     size_t extra_ies_len)
+{
+ struct sk_buff *skb;
+ struct mwifiex_txinfo *tx_info;
+ struct timeval tv;
+ int ret;
+ u16 skb_len;
+
+ skb_len = MWIFIEX_MIN_DATA_HEADER_LEN +
+    max(sizeof(struct ieee80211_mgmt),
+        sizeof(struct ieee80211_tdls_data)) +
+    MWIFIEX_MGMT_FRAME_HEADER_SIZE +
+    MWIFIEX_SUPPORTED_RATES +
+    3 + /* Qos Info */
+    sizeof(struct ieee_types_extcap) +
+    sizeof(struct ieee80211_ht_cap) +
+    sizeof(struct ieee_types_bss_co_2040) +
+    sizeof(struct ieee80211_ht_operation) +
+    sizeof(struct ieee80211_tdls_lnkie) +
+    extra_ies_len;
+
+ if (priv->adapter->is_hw_11ac_capable)
+  skb_len += sizeof(struct ieee_types_vht_cap) +
+      sizeof(struct ieee_types_vht_oper) +
+      sizeof(struct ieee_types_aid);
+
+ skb = dev_alloc_skb(skb_len);
+ if (!skb) {
+  dev_err(priv->adapter->dev,
+   "allocate skb failed for management frame\n");
+  return -ENOMEM;
+ }
+ skb_reserve(skb, MWIFIEX_MIN_DATA_HEADER_LEN);
+
+ switch (action_code) {
+ case WLAN_TDLS_SETUP_REQUEST:
+ case WLAN_TDLS_SETUP_CONFIRM:
+ case WLAN_TDLS_TEARDOWN:
+ case WLAN_TDLS_DISCOVERY_REQUEST:
+  ret = mwifiex_prep_tdls_encap_data(priv, peer, action_code,
+         dialog_token, status_code,
+         skb);
+  if (ret) {
+   dev_kfree_skb_any(skb);
+   return ret;
+  }
+  if (extra_ies_len)
+   memcpy(skb_put(skb, extra_ies_len), extra_ies,
+          extra_ies_len);
+  mwifiex_tdls_add_link_ie(skb, priv->curr_addr, peer,
+      priv->cfg_bssid);
+  break;
+ case WLAN_TDLS_SETUP_RESPONSE:
+  ret = mwifiex_prep_tdls_encap_data(priv, peer, action_code,
+         dialog_token, status_code,
+         skb);
+  if (ret) {
+   dev_kfree_skb_any(skb);
+   return ret;
+  }
+  if (extra_ies_len)
+   memcpy(skb_put(skb, extra_ies_len), extra_ies,
+          extra_ies_len);
+  mwifiex_tdls_add_link_ie(skb, peer, priv->curr_addr,
+      priv->cfg_bssid);
+  break;
+ }
+
+ switch (action_code) {
+ case WLAN_TDLS_SETUP_REQUEST:
+ case WLAN_TDLS_SETUP_RESPONSE:
+  skb->priority = MWIFIEX_PRIO_BK;
+  break;
+ default:
+  skb->priority = MWIFIEX_PRIO_VI;
+  break;
+ }
+
+ tx_info = MWIFIEX_SKB_TXCB(skb);
+ memset(tx_info, 0, sizeof(*tx_info));
+ tx_info->bss_num = priv->bss_num;
+ tx_info->bss_type = priv->bss_type;
+
+ do_gettimeofday(&tv);
+ skb->tstamp = timeval_to_ktime(tv);
+ mwifiex_queue_tx_pkt(priv, skb);
+
+ return 0;
+}
+
+static int
+mwifiex_construct_tdls_action_frame(struct mwifiex_private *priv,
+        const u8 *peer,
+        u8 action_code, u8 dialog_token,
+        u16 status_code, struct sk_buff *skb)
+{
+ struct ieee80211_mgmt *mgmt;
+ u8 bc_addr[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
+ int ret;
+ u16 capab;
+ struct ieee80211_ht_cap *ht_cap;
+ u8 radio, *pos;
+
+ capab = priv->curr_bss_params.bss_descriptor.cap_info_bitmap;
+
+ mgmt = (void *)skb_put(skb, offsetof(struct ieee80211_mgmt, u));
+
+ memset(mgmt, 0, 24);
+ memcpy(mgmt->da, peer, ETH_ALEN);
+ memcpy(mgmt->sa, priv->curr_addr, ETH_ALEN);
+ memcpy(mgmt->bssid, priv->cfg_bssid, ETH_ALEN);
+ mgmt->frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT |
+       IEEE80211_STYPE_ACTION);
+
+ /* add address 4 */
+ pos = skb_put(skb, ETH_ALEN);
+
+ switch (action_code) {
+ case WLAN_PUB_ACTION_TDLS_DISCOVER_RES:
+  skb_put(skb, sizeof(mgmt->u.action.u.tdls_discover_resp) + 1);
+  mgmt->u.action.category = WLAN_CATEGORY_PUBLIC;
+  mgmt->u.action.u.tdls_discover_resp.action_code =
+           WLAN_PUB_ACTION_TDLS_DISCOVER_RES;
+  mgmt->u.action.u.tdls_discover_resp.dialog_token =
+           dialog_token;
+  mgmt->u.action.u.tdls_discover_resp.capability =
+            cpu_to_le16(capab);
+  /* move back for addr4 */
+  memmove(pos + ETH_ALEN, &mgmt->u.action.category,
+   sizeof(mgmt->u.action.u.tdls_discover_resp));
+  /* init address 4 */
+  memcpy(pos, bc_addr, ETH_ALEN);
+
+  ret = mwifiex_tdls_append_rates_ie(priv, skb);
+  if (ret) {
+   dev_kfree_skb_any(skb);
+   return ret;
+  }
+
+  pos = (void *)skb_put(skb, sizeof(struct ieee80211_ht_cap) + 2);
+  *pos++ = WLAN_EID_HT_CAPABILITY;
+  *pos++ = sizeof(struct ieee80211_ht_cap);
+  ht_cap = (void *)pos;
+  radio = mwifiex_band_to_radio_type(priv->curr_bss_params.band);
+  ret = mwifiex_fill_cap_info(priv, radio, ht_cap);
+  if (ret) {
+   dev_kfree_skb_any(skb);
+   return ret;
+  }
+
+  if (priv->adapter->is_hw_11ac_capable) {
+   ret = mwifiex_tdls_add_vht_capab(priv, skb);
+   if (ret) {
+    dev_kfree_skb_any(skb);
+    return ret;
+   }
+   mwifiex_tdls_add_aid(priv, skb);
+  }
+
+  mwifiex_tdls_add_ext_capab(priv, skb);
+  mwifiex_tdls_add_qos_capab(skb);
+  break;
+ default:
+  dev_err(priv->adapter->dev, "Unknown TDLS action frame type\n");
+  return -EINVAL;
+ }
+
+ return 0;
+}
+
+int mwifiex_send_tdls_action_frame(struct mwifiex_private *priv, const u8 *peer,
+       u8 action_code, u8 dialog_token,
+       u16 status_code, const u8 *extra_ies,
+       size_t extra_ies_len)
+{
+ struct sk_buff *skb;
+ struct mwifiex_txinfo *tx_info;
+ struct timeval tv;
+ u8 *pos;
+ u32 pkt_type, tx_control;
+ u16 pkt_len, skb_len;
+
+ skb_len = MWIFIEX_MIN_DATA_HEADER_LEN +
+    max(sizeof(struct ieee80211_mgmt),
+        sizeof(struct ieee80211_tdls_data)) +
+    MWIFIEX_MGMT_FRAME_HEADER_SIZE +
+    MWIFIEX_SUPPORTED_RATES +
+    sizeof(struct ieee_types_extcap) +
+    sizeof(struct ieee80211_ht_cap) +
+    sizeof(struct ieee_types_bss_co_2040) +
+    sizeof(struct ieee80211_ht_operation) +
+    sizeof(struct ieee80211_tdls_lnkie) +
+    extra_ies_len +
+    3 + /* Qos Info */
+    ETH_ALEN; /* Address4 */
+
+ if (priv->adapter->is_hw_11ac_capable)
+  skb_len += sizeof(struct ieee_types_vht_cap) +
+      sizeof(struct ieee_types_vht_oper) +
+      sizeof(struct ieee_types_aid);
+
+ skb = dev_alloc_skb(skb_len);
+ if (!skb) {
+  dev_err(priv->adapter->dev,
+   "allocate skb failed for management frame\n");
+  return -ENOMEM;
+ }
+
+ skb_reserve(skb, MWIFIEX_MIN_DATA_HEADER_LEN);
+
+ pkt_type = PKT_TYPE_MGMT;
+ tx_control = 0;
+ pos = skb_put(skb, MWIFIEX_MGMT_FRAME_HEADER_SIZE + sizeof(pkt_len));
+ memset(pos, 0, MWIFIEX_MGMT_FRAME_HEADER_SIZE + sizeof(pkt_len));
+ memcpy(pos, &pkt_type, sizeof(pkt_type));
+ memcpy(pos + sizeof(pkt_type), &tx_control, sizeof(tx_control));
+
+ if (mwifiex_construct_tdls_action_frame(priv, peer, action_code,
+      dialog_token, status_code,
+      skb)) {
+  dev_kfree_skb_any(skb);
+  return -EINVAL;
+ }
+
+ if (extra_ies_len)
+  memcpy(skb_put(skb, extra_ies_len), extra_ies, extra_ies_len);
+
+ /* the TDLS link IE is always added last we are the responder */
+
+ mwifiex_tdls_add_link_ie(skb, peer, priv->curr_addr,
+     priv->cfg_bssid);
+
+ skb->priority = MWIFIEX_PRIO_VI;
+
+ tx_info = MWIFIEX_SKB_TXCB(skb);
+ memset(tx_info, 0, sizeof(*tx_info));
+ tx_info->bss_num = priv->bss_num;
+ tx_info->bss_type = priv->bss_type;
+ tx_info->flags |= MWIFIEX_BUF_FLAG_TDLS_PKT;
+
+ pkt_len = skb->len - MWIFIEX_MGMT_FRAME_HEADER_SIZE - sizeof(pkt_len);
+ memcpy(skb->data + MWIFIEX_MGMT_FRAME_HEADER_SIZE, &pkt_len,
+        sizeof(pkt_len));
+ do_gettimeofday(&tv);
+ skb->tstamp = timeval_to_ktime(tv);
+ mwifiex_queue_tx_pkt(priv, skb);
+
+ return 0;
+}
+
+/* This function process tdls action frame from peer.
+ * Peer capabilities are stored into station node structure.
+ */
+void mwifiex_process_tdls_action_frame(struct mwifiex_private *priv,
+           u8 *buf, int len)
+{
+ struct mwifiex_sta_node *sta_ptr;
+ u8 *peer, *pos, *end;
+ u8 i, action, basic;
+ int ie_len = 0;
+
+ if (len < (sizeof(struct ethhdr) + 3))
+  return;
+ if (*(buf + sizeof(struct ethhdr)) != WLAN_TDLS_SNAP_RFTYPE)
+  return;
+ if (*(buf + sizeof(struct ethhdr) + 1) != WLAN_CATEGORY_TDLS)
+  return;
+
+ peer = buf + ETH_ALEN;
+ action = *(buf + sizeof(struct ethhdr) + 2);
+
+ /* just handle TDLS setup request/response/confirm */
+ if (action > WLAN_TDLS_SETUP_CONFIRM)
+  return;
+
+ dev_dbg(priv->adapter->dev,
+  "rx:tdls action: peer=%pM, action=%d\n", peer, action);
+
+ sta_ptr = mwifiex_add_sta_entry(priv, peer);
+ if (!sta_ptr)
+  return;
+
+ switch (action) {
+ case WLAN_TDLS_SETUP_REQUEST:
+  if (len < (sizeof(struct ethhdr) + TDLS_REQ_FIX_LEN))
+   return;
+
+  pos = buf + sizeof(struct ethhdr) + 4;
+  /* payload 1+ category 1 + action 1 + dialog 1 */
+  sta_ptr->tdls_cap.capab = cpu_to_le16(*(u16 *)pos);
+  ie_len = len - sizeof(struct ethhdr) - TDLS_REQ_FIX_LEN;
+  pos += 2;
+  break;
+
+ case WLAN_TDLS_SETUP_RESPONSE:
+  if (len < (sizeof(struct ethhdr) + TDLS_RESP_FIX_LEN))
+   return;
+  /* payload 1+ category 1 + action 1 + dialog 1 + status code 2*/
+  pos = buf + sizeof(struct ethhdr) + 6;
+  sta_ptr->tdls_cap.capab = cpu_to_le16(*(u16 *)pos);
+  ie_len = len - sizeof(struct ethhdr) - TDLS_RESP_FIX_LEN;
+  pos += 2;
+  break;
+
+ case WLAN_TDLS_SETUP_CONFIRM:
+  if (len < (sizeof(struct ethhdr) + TDLS_CONFIRM_FIX_LEN))
+   return;
+  pos = buf + sizeof(struct ethhdr) + TDLS_CONFIRM_FIX_LEN;
+  ie_len = len - sizeof(struct ethhdr) - TDLS_CONFIRM_FIX_LEN;
+  break;
+ default:
+  dev_warn(priv->adapter->dev, "Unknown TDLS frame type.\n");
+  return;
+ }
+
+ for (end = pos + ie_len; pos + 1 < end; pos += 2 + pos[1]) {
+  if (pos + 2 + pos[1] > end)
+   break;
+
+  switch (*pos) {
+  case WLAN_EID_SUPP_RATES:
+   sta_ptr->tdls_cap.rates_len = pos[1];
+   for (i = 0; i < pos[1]; i++)
+    sta_ptr->tdls_cap.rates[i] = pos[i + 2];
+   break;
+
+  case WLAN_EID_EXT_SUPP_RATES:
+   basic = sta_ptr->tdls_cap.rates_len;
+   for (i = 0; i < pos[1]; i++)
+    sta_ptr->tdls_cap.rates[basic + i] = pos[i + 2];
+   sta_ptr->tdls_cap.rates_len += pos[1];
+   break;
+  case WLAN_EID_HT_CAPABILITY:
+   memcpy((u8 *)&sta_ptr->tdls_cap.ht_capb, pos,
+          sizeof(struct ieee80211_ht_cap));
+   sta_ptr->is_11n_enabled = 1;
+   break;
+  case WLAN_EID_HT_OPERATION:
+   memcpy(&sta_ptr->tdls_cap.ht_oper, pos,
+          sizeof(struct ieee80211_ht_operation));
+   break;
+  case WLAN_EID_BSS_COEX_2040:
+   sta_ptr->tdls_cap.coex_2040 = pos[2];
+   break;
+  case WLAN_EID_EXT_CAPABILITY:
+   memcpy((u8 *)&sta_ptr->tdls_cap.extcap, pos,
+          sizeof(struct ieee_types_header) +
+          min_t(u8, pos[1], 8));
+   break;
+  case WLAN_EID_RSN:
+   memcpy((u8 *)&sta_ptr->tdls_cap.rsn_ie, pos,
+          sizeof(struct ieee_types_header) + pos[1]);
+   break;
+  case WLAN_EID_QOS_CAPA:
+   sta_ptr->tdls_cap.qos_info = pos[2];
+   break;
+  case WLAN_EID_VHT_OPERATION:
+   if (priv->adapter->is_hw_11ac_capable)
+    memcpy(&sta_ptr->tdls_cap.vhtoper, pos,
+           sizeof(struct ieee80211_vht_operation));
+   break;
+  case WLAN_EID_VHT_CAPABILITY:
+   if (priv->adapter->is_hw_11ac_capable) {
+    memcpy((u8 *)&sta_ptr->tdls_cap.vhtcap, pos,
+           sizeof(struct ieee80211_vht_cap));
+    sta_ptr->is_11ac_enabled = 1;
+   }
+   break;
+  case WLAN_EID_AID:
+   if (priv->adapter->is_hw_11ac_capable)
+    sta_ptr->tdls_cap.aid =
+           le16_to_cpu(*(__le16 *)(pos + 2));
+  default:
+   break;
+  }
+ }
+
+ return;
+}
+
+static int
+mwifiex_tdls_process_config_link(struct mwifiex_private *priv, const u8 *peer)
+{
+ struct mwifiex_sta_node *sta_ptr;
+ struct mwifiex_ds_tdls_oper tdls_oper;
+
+ memset(&tdls_oper, 0, sizeof(struct mwifiex_ds_tdls_oper));
+ sta_ptr = mwifiex_get_sta_entry(priv, peer);
+
+ if (!sta_ptr || sta_ptr->tdls_status == TDLS_SETUP_FAILURE) {
+  dev_err(priv->adapter->dev,
+   "link absent for peer %pM; cannot config\n", peer);
+  return -EINVAL;
+ }
+
+ memcpy(&tdls_oper.peer_mac, peer, ETH_ALEN);
+ tdls_oper.tdls_action = MWIFIEX_TDLS_CONFIG_LINK;
+ return mwifiex_send_cmd(priv, HostCmd_CMD_TDLS_OPER,
+    HostCmd_ACT_GEN_SET, 0, &tdls_oper, true);
+}
+
+static int
+mwifiex_tdls_process_create_link(struct mwifiex_private *priv, const u8 *peer)
+{
+ struct mwifiex_sta_node *sta_ptr;
+ struct mwifiex_ds_tdls_oper tdls_oper;
+
+ memset(&tdls_oper, 0, sizeof(struct mwifiex_ds_tdls_oper));
+ sta_ptr = mwifiex_get_sta_entry(priv, peer);
+
+ if (sta_ptr && sta_ptr->tdls_status == TDLS_SETUP_INPROGRESS) {
+  dev_dbg(priv->adapter->dev,
+   "Setup already in progress for peer %pM\n", peer);
+  return 0;
+ }
+
+ sta_ptr = mwifiex_add_sta_entry(priv, peer);
+ if (!sta_ptr)
+  return -ENOMEM;
+
+ sta_ptr->tdls_status = TDLS_SETUP_INPROGRESS;
+ mwifiex_hold_tdls_packets(priv, peer);
+ memcpy(&tdls_oper.peer_mac, peer, ETH_ALEN);
+ tdls_oper.tdls_action = MWIFIEX_TDLS_CREATE_LINK;
+ return mwifiex_send_cmd(priv, HostCmd_CMD_TDLS_OPER,
+    HostCmd_ACT_GEN_SET, 0, &tdls_oper, true);
+}
+
+static int
+mwifiex_tdls_process_disable_link(struct mwifiex_private *priv, const u8 *peer)
+{
+ struct mwifiex_sta_node *sta_ptr;
+ struct mwifiex_ds_tdls_oper tdls_oper;
+ unsigned long flags;
+
+ memset(&tdls_oper, 0, sizeof(struct mwifiex_ds_tdls_oper));
+ sta_ptr = mwifiex_get_sta_entry(priv, peer);
+
+ if (sta_ptr) {
+  if (sta_ptr->is_11n_enabled) {
+   mwifiex_11n_cleanup_reorder_tbl(priv);
+   spin_lock_irqsave(&priv->wmm.ra_list_spinlock,
+       flags);
+   mwifiex_11n_delete_all_tx_ba_stream_tbl(priv);
+   spin_unlock_irqrestore(&priv->wmm.ra_list_spinlock,
+            flags);
+  }
+  mwifiex_del_sta_entry(priv, peer);
+ }
+
+ mwifiex_restore_tdls_packets(priv, peer, TDLS_LINK_TEARDOWN);
+ memcpy(&tdls_oper.peer_mac, peer, ETH_ALEN);
+ tdls_oper.tdls_action = MWIFIEX_TDLS_DISABLE_LINK;
+ return mwifiex_send_cmd(priv, HostCmd_CMD_TDLS_OPER,
+    HostCmd_ACT_GEN_SET, 0, &tdls_oper, true);
+}
+
+static int
+mwifiex_tdls_process_enable_link(struct mwifiex_private *priv, const u8 *peer)
+{
+ struct mwifiex_sta_node *sta_ptr;
+ struct ieee80211_mcs_info mcs;
+ unsigned long flags;
+ int i;
+
+ sta_ptr = mwifiex_get_sta_entry(priv, peer);
+
+ if (sta_ptr && (sta_ptr->tdls_status != TDLS_SETUP_FAILURE)) {
+  dev_dbg(priv->adapter->dev,
+   "tdls: enable link %pM success\n", peer);
+
+  sta_ptr->tdls_status = TDLS_SETUP_COMPLETE;
+
+  mcs = sta_ptr->tdls_cap.ht_capb.mcs;
+  if (mcs.rx_mask[0] != 0xff)
+   sta_ptr->is_11n_enabled = true;
+  if (sta_ptr->is_11n_enabled) {
+   if (le16_to_cpu(sta_ptr->tdls_cap.ht_capb.cap_info) &
+       IEEE80211_HT_CAP_MAX_AMSDU)
+    sta_ptr->max_amsdu =
+     MWIFIEX_TX_DATA_BUF_SIZE_8K;
+   else
+    sta_ptr->max_amsdu =
+     MWIFIEX_TX_DATA_BUF_SIZE_4K;
+
+   for (i = 0; i < MAX_NUM_TID; i++)
+    sta_ptr->ampdu_sta[i] =
+           priv->aggr_prio_tbl[i].ampdu_user;
+  } else {
+   for (i = 0; i < MAX_NUM_TID; i++)
+    sta_ptr->ampdu_sta[i] = BA_STREAM_NOT_ALLOWED;
+  }
+
+  memset(sta_ptr->rx_seq, 0xff, sizeof(sta_ptr->rx_seq));
+  mwifiex_restore_tdls_packets(priv, peer, TDLS_SETUP_COMPLETE);
+ } else {
+  dev_dbg(priv->adapter->dev,
+   "tdls: enable link %pM failed\n", peer);
+  if (sta_ptr) {
+   mwifiex_11n_cleanup_reorder_tbl(priv);
+   spin_lock_irqsave(&priv->wmm.ra_list_spinlock,
+       flags);
+   mwifiex_11n_delete_all_tx_ba_stream_tbl(priv);
+   spin_unlock_irqrestore(&priv->wmm.ra_list_spinlock,
+            flags);
+   mwifiex_del_sta_entry(priv, peer);
+  }
+  mwifiex_restore_tdls_packets(priv, peer, TDLS_LINK_TEARDOWN);
+
+  return -1;
+ }
+
+ return 0;
+}
+
+int mwifiex_tdls_oper(struct mwifiex_private *priv, const u8 *peer, u8 action)
+{
+ switch (action) {
+ case MWIFIEX_TDLS_ENABLE_LINK:
+  return mwifiex_tdls_process_enable_link(priv, peer);
+ case MWIFIEX_TDLS_DISABLE_LINK:
+  return mwifiex_tdls_process_disable_link(priv, peer);
+ case MWIFIEX_TDLS_CREATE_LINK:
+  return mwifiex_tdls_process_create_link(priv, peer);
+ case MWIFIEX_TDLS_CONFIG_LINK:
+  return mwifiex_tdls_process_config_link(priv, peer);
+ }
+ return 0;
+}
+
+int mwifiex_get_tdls_link_status(struct mwifiex_private *priv, const u8 *mac)
+{
+ struct mwifiex_sta_node *sta_ptr;
+
+ sta_ptr = mwifiex_get_sta_entry(priv, mac);
+ if (sta_ptr)
+  return sta_ptr->tdls_status;
+
+ return TDLS_NOT_SETUP;
+}
+
+void mwifiex_disable_all_tdls_links(struct mwifiex_private *priv)
+{
+ struct mwifiex_sta_node *sta_ptr;
+ struct mwifiex_ds_tdls_oper tdls_oper;
+ unsigned long flags;
+
+ if (list_empty(&priv->sta_list))
+  return;
+
+ list_for_each_entry(sta_ptr, &priv->sta_list, list) {
+  memset(&tdls_oper, 0, sizeof(struct mwifiex_ds_tdls_oper));
+
+  if (sta_ptr->is_11n_enabled) {
+   mwifiex_11n_cleanup_reorder_tbl(priv);
+   spin_lock_irqsave(&priv->wmm.ra_list_spinlock,
+       flags);
+   mwifiex_11n_delete_all_tx_ba_stream_tbl(priv);
+   spin_unlock_irqrestore(&priv->wmm.ra_list_spinlock,
+            flags);
+  }
+
+  mwifiex_restore_tdls_packets(priv, sta_ptr->mac_addr,
+          TDLS_LINK_TEARDOWN);
+  memcpy(&tdls_oper.peer_mac, sta_ptr->mac_addr, ETH_ALEN);
+  tdls_oper.tdls_action = MWIFIEX_TDLS_DISABLE_LINK;
+  if (mwifiex_send_cmd(priv, HostCmd_CMD_TDLS_OPER,
+         HostCmd_ACT_GEN_SET, 0, &tdls_oper, false))
+   dev_warn(priv->adapter->dev,
+     "Disable link failed for TDLS peer %pM",
+     sta_ptr->mac_addr);
+ }
+
+ mwifiex_del_all_sta_list(priv);
+}
diff --git a/drivers/net/wireless/mwifiex/txrx.c b/drivers/net/wireless/mwifiex/txrx.c
index 8f923d0..fd7e5b9 100644
--- a/drivers/net/wireless/mwifiex/txrx.c
+++ b/drivers/net/wireless/mwifiex/txrx.c
@@ -40,6 +40,7 @@ int mwifiex_handle_rx_packet(struct mwifiex_adapter *adapter,
   mwifiex_get_priv(adapter, MWIFIEX_BSS_ROLE_ANY);
  struct rxpd *local_rx_pd;
  struct mwifiex_rxinfo *rx_info = MWIFIEX_SKB_RXCB(skb);
+ int ret;
 
  local_rx_pd = (struct rxpd *) (skb->data);
  /* Get the BSS number from rxpd, get corresponding priv */
@@ -54,13 +55,20 @@ int mwifiex_handle_rx_packet(struct mwifiex_adapter *adapter,
   return -1;
  }
 
+ memset(rx_info, 0, sizeof(*rx_info));
  rx_info->bss_num = priv->bss_num;
  rx_info->bss_type = priv->bss_type;
 
  if (priv->bss_role == MWIFIEX_BSS_ROLE_UAP)
-  return mwifiex_process_uap_rx_packet(priv, skb);
+  ret = mwifiex_process_uap_rx_packet(priv, skb);
+ else
+  ret = mwifiex_process_sta_rx_packet(priv, skb);
+
+ /* Decrement RX pending counter for each packet */
+ if (adapter->if_ops.data_complete)
+  adapter->if_ops.data_complete(adapter);
 
- return mwifiex_process_sta_rx_packet(priv, skb);
+ return ret;
 }
 EXPORT_SYMBOL_GPL(mwifiex_handle_rx_packet);
 
@@ -105,7 +113,7 @@ int mwifiex_process_tx(struct mwifiex_private *priv, struct sk_buff *skb,
 
  switch (ret) {
  case -ENOSR:
-  dev_err(adapter->dev, "data: -ENOSR is returned\n");
+  dev_dbg(adapter->dev, "data: -ENOSR is returned\n");
   break;
  case -EBUSY:
   if ((GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_STA) &&
@@ -168,7 +176,7 @@ int mwifiex_write_data_complete(struct mwifiex_adapter *adapter,
  mwifiex_set_trans_start(priv->netdev);
  if (!status) {
   priv->stats.tx_packets++;
-  priv->stats.tx_bytes += skb->len;
+  priv->stats.tx_bytes += tx_info->pkt_len;
   if (priv->tx_timeout_cnt)
    priv->tx_timeout_cnt = 0;
  } else {
diff --git a/drivers/net/wireless/mwifiex/uap_cmd.c b/drivers/net/wireless/mwifiex/uap_cmd.c
index b04b1db..3264355 100644
--- a/drivers/net/wireless/mwifiex/uap_cmd.c
+++ b/drivers/net/wireless/mwifiex/uap_cmd.c
@@ -159,6 +159,7 @@ mwifiex_set_ht_params(struct mwifiex_private *priv,
         struct cfg80211_ap_settings *params)
 {
  const u8 *ht_ie;
+ u16 cap_info;
 
  if (!ISSUPP_11NENABLED(priv->adapter->fw_cap_info))
   return;
@@ -168,6 +169,27 @@ mwifiex_set_ht_params(struct mwifiex_private *priv,
  if (ht_ie) {
   memcpy(&bss_cfg->ht_cap, ht_ie + 2,
          sizeof(struct ieee80211_ht_cap));
+  cap_info = le16_to_cpu(bss_cfg->ht_cap.cap_info);
+  memset(&bss_cfg->ht_cap.mcs, 0,
+         priv->adapter->number_of_antenna);
+  switch (GET_RXSTBC(cap_info)) {
+  case MWIFIEX_RX_STBC1:
+   /* HT_CAP 1X1 mode */
+   bss_cfg->ht_cap.mcs.rx_mask[0] = 0xff;
+   break;
+  case MWIFIEX_RX_STBC12: /* fall through */
+  case MWIFIEX_RX_STBC123:
+   /* HT_CAP 2X2 mode */
+   bss_cfg->ht_cap.mcs.rx_mask[0] = 0xff;
+   bss_cfg->ht_cap.mcs.rx_mask[1] = 0xff;
+   break;
+  default:
+   dev_warn(priv->adapter->dev,
+     "Unsupported RX-STBC, default to 2x2\n");
+   bss_cfg->ht_cap.mcs.rx_mask[0] = 0xff;
+   bss_cfg->ht_cap.mcs.rx_mask[1] = 0xff;
+   break;
+  }
   priv->ap_11n_enabled = 1;
  } else {
   memset(&bss_cfg->ht_cap , 0, sizeof(struct ieee80211_ht_cap));
@@ -226,8 +248,8 @@ void mwifiex_set_vht_width(struct mwifiex_private *priv,
  if (ap_11ac_enable && width >= NL80211_CHAN_WIDTH_80)
   vht_cfg.misc_config |= VHT_BW_80_160_80P80;
 
- mwifiex_send_cmd_sync(priv, HostCmd_CMD_11AC_CFG,
-         HostCmd_ACT_GEN_SET, 0, &vht_cfg);
+ mwifiex_send_cmd(priv, HostCmd_CMD_11AC_CFG,
+    HostCmd_ACT_GEN_SET, 0, &vht_cfg, true);
 
  return;
 }
@@ -293,9 +315,9 @@ mwifiex_uap_bss_wpa(u8 **tlv_buf, void *cmd_buf, u16 *param_size)
  u8 *tlv = *tlv_buf;
 
  tlv_akmp = (struct host_cmd_tlv_akmp *)tlv;
- tlv_akmp->tlv.type = cpu_to_le16(TLV_TYPE_UAP_AKMP);
- tlv_akmp->tlv.len = cpu_to_le16(sizeof(struct host_cmd_tlv_akmp) -
-     sizeof(struct host_cmd_tlv));
+ tlv_akmp->header.type = cpu_to_le16(TLV_TYPE_UAP_AKMP);
+ tlv_akmp->header.len = cpu_to_le16(sizeof(struct host_cmd_tlv_akmp) -
+     sizeof(struct mwifiex_ie_types_header));
  tlv_akmp->key_mgmt_operation = cpu_to_le16(bss_cfg->key_mgmt_operation);
  tlv_akmp->key_mgmt = cpu_to_le16(bss_cfg->key_mgmt);
  cmd_size += sizeof(struct host_cmd_tlv_akmp);
@@ -303,10 +325,10 @@ mwifiex_uap_bss_wpa(u8 **tlv_buf, void *cmd_buf, u16 *param_size)
 
  if (bss_cfg->wpa_cfg.pairwise_cipher_wpa & VALID_CIPHER_BITMAP) {
   pwk_cipher = (struct host_cmd_tlv_pwk_cipher *)tlv;
-  pwk_cipher->tlv.type = cpu_to_le16(TLV_TYPE_PWK_CIPHER);
-  pwk_cipher->tlv.len =
+  pwk_cipher->header.type = cpu_to_le16(TLV_TYPE_PWK_CIPHER);
+  pwk_cipher->header.len =
    cpu_to_le16(sizeof(struct host_cmd_tlv_pwk_cipher) -
-        sizeof(struct host_cmd_tlv));
+        sizeof(struct mwifiex_ie_types_header));
   pwk_cipher->proto = cpu_to_le16(PROTOCOL_WPA);
   pwk_cipher->cipher = bss_cfg->wpa_cfg.pairwise_cipher_wpa;
   cmd_size += sizeof(struct host_cmd_tlv_pwk_cipher);
@@ -315,10 +337,10 @@ mwifiex_uap_bss_wpa(u8 **tlv_buf, void *cmd_buf, u16 *param_size)
 
  if (bss_cfg->wpa_cfg.pairwise_cipher_wpa2 & VALID_CIPHER_BITMAP) {
   pwk_cipher = (struct host_cmd_tlv_pwk_cipher *)tlv;
-  pwk_cipher->tlv.type = cpu_to_le16(TLV_TYPE_PWK_CIPHER);
-  pwk_cipher->tlv.len =
+  pwk_cipher->header.type = cpu_to_le16(TLV_TYPE_PWK_CIPHER);
+  pwk_cipher->header.len =
    cpu_to_le16(sizeof(struct host_cmd_tlv_pwk_cipher) -
-        sizeof(struct host_cmd_tlv));
+        sizeof(struct mwifiex_ie_types_header));
   pwk_cipher->proto = cpu_to_le16(PROTOCOL_WPA2);
   pwk_cipher->cipher = bss_cfg->wpa_cfg.pairwise_cipher_wpa2;
   cmd_size += sizeof(struct host_cmd_tlv_pwk_cipher);
@@ -327,10 +349,10 @@ mwifiex_uap_bss_wpa(u8 **tlv_buf, void *cmd_buf, u16 *param_size)
 
  if (bss_cfg->wpa_cfg.group_cipher & VALID_CIPHER_BITMAP) {
   gwk_cipher = (struct host_cmd_tlv_gwk_cipher *)tlv;
-  gwk_cipher->tlv.type = cpu_to_le16(TLV_TYPE_GWK_CIPHER);
-  gwk_cipher->tlv.len =
+  gwk_cipher->header.type = cpu_to_le16(TLV_TYPE_GWK_CIPHER);
+  gwk_cipher->header.len =
    cpu_to_le16(sizeof(struct host_cmd_tlv_gwk_cipher) -
-        sizeof(struct host_cmd_tlv));
+        sizeof(struct mwifiex_ie_types_header));
   gwk_cipher->cipher = bss_cfg->wpa_cfg.group_cipher;
   cmd_size += sizeof(struct host_cmd_tlv_gwk_cipher);
   tlv += sizeof(struct host_cmd_tlv_gwk_cipher);
@@ -338,13 +360,15 @@ mwifiex_uap_bss_wpa(u8 **tlv_buf, void *cmd_buf, u16 *param_size)
 
  if (bss_cfg->wpa_cfg.length) {
   passphrase = (struct host_cmd_tlv_passphrase *)tlv;
-  passphrase->tlv.type = cpu_to_le16(TLV_TYPE_UAP_WPA_PASSPHRASE);
-  passphrase->tlv.len = cpu_to_le16(bss_cfg->wpa_cfg.length);
+  passphrase->header.type =
+    cpu_to_le16(TLV_TYPE_UAP_WPA_PASSPHRASE);
+  passphrase->header.len = cpu_to_le16(bss_cfg->wpa_cfg.length);
   memcpy(passphrase->passphrase, bss_cfg->wpa_cfg.passphrase,
          bss_cfg->wpa_cfg.length);
-  cmd_size += sizeof(struct host_cmd_tlv) +
+  cmd_size += sizeof(struct mwifiex_ie_types_header) +
        bss_cfg->wpa_cfg.length;
-  tlv += sizeof(struct host_cmd_tlv) + bss_cfg->wpa_cfg.length;
+  tlv += sizeof(struct mwifiex_ie_types_header) +
+    bss_cfg->wpa_cfg.length;
  }
 
  *param_size = cmd_size;
@@ -403,16 +427,17 @@ mwifiex_uap_bss_wep(u8 **tlv_buf, void *cmd_buf, u16 *param_size)
       (bss_cfg->wep_cfg[i].length == WLAN_KEY_LEN_WEP40 ||
        bss_cfg->wep_cfg[i].length == WLAN_KEY_LEN_WEP104)) {
    wep_key = (struct host_cmd_tlv_wep_key *)tlv;
-   wep_key->tlv.type = cpu_to_le16(TLV_TYPE_UAP_WEP_KEY);
-   wep_key->tlv.len =
+   wep_key->header.type =
+    cpu_to_le16(TLV_TYPE_UAP_WEP_KEY);
+   wep_key->header.len =
     cpu_to_le16(bss_cfg->wep_cfg[i].length + 2);
    wep_key->key_index = bss_cfg->wep_cfg[i].key_index;
    wep_key->is_default = bss_cfg->wep_cfg[i].is_default;
    memcpy(wep_key->key, bss_cfg->wep_cfg[i].key,
           bss_cfg->wep_cfg[i].length);
-   cmd_size += sizeof(struct host_cmd_tlv) + 2 +
+   cmd_size += sizeof(struct mwifiex_ie_types_header) + 2 +
         bss_cfg->wep_cfg[i].length;
-   tlv += sizeof(struct host_cmd_tlv) + 2 +
+   tlv += sizeof(struct mwifiex_ie_types_header) + 2 +
         bss_cfg->wep_cfg[i].length;
   }
  }
@@ -449,16 +474,17 @@ mwifiex_uap_bss_param_prepare(u8 *tlv, void *cmd_buf, u16 *param_size)
 
  if (bss_cfg->ssid.ssid_len) {
   ssid = (struct host_cmd_tlv_ssid *)tlv;
-  ssid->tlv.type = cpu_to_le16(TLV_TYPE_UAP_SSID);
-  ssid->tlv.len = cpu_to_le16((u16)bss_cfg->ssid.ssid_len);
+  ssid->header.type = cpu_to_le16(TLV_TYPE_UAP_SSID);
+  ssid->header.len = cpu_to_le16((u16)bss_cfg->ssid.ssid_len);
   memcpy(ssid->ssid, bss_cfg->ssid.ssid, bss_cfg->ssid.ssid_len);
-  cmd_size += sizeof(struct host_cmd_tlv) +
+  cmd_size += sizeof(struct mwifiex_ie_types_header) +
        bss_cfg->ssid.ssid_len;
-  tlv += sizeof(struct host_cmd_tlv) + bss_cfg->ssid.ssid_len;
+  tlv += sizeof(struct mwifiex_ie_types_header) +
+    bss_cfg->ssid.ssid_len;
 
   bcast_ssid = (struct host_cmd_tlv_bcast_ssid *)tlv;
-  bcast_ssid->tlv.type = cpu_to_le16(TLV_TYPE_UAP_BCAST_SSID);
-  bcast_ssid->tlv.len =
+  bcast_ssid->header.type = cpu_to_le16(TLV_TYPE_UAP_BCAST_SSID);
+  bcast_ssid->header.len =
     cpu_to_le16(sizeof(bcast_ssid->bcast_ctl));
   bcast_ssid->bcast_ctl = bss_cfg->bcast_ssid_ctl;
   cmd_size += sizeof(struct host_cmd_tlv_bcast_ssid);
@@ -466,13 +492,13 @@ mwifiex_uap_bss_param_prepare(u8 *tlv, void *cmd_buf, u16 *param_size)
  }
  if (bss_cfg->rates[0]) {
   tlv_rates = (struct host_cmd_tlv_rates *)tlv;
-  tlv_rates->tlv.type = cpu_to_le16(TLV_TYPE_UAP_RATES);
+  tlv_rates->header.type = cpu_to_le16(TLV_TYPE_UAP_RATES);
 
   for (i = 0; i < MWIFIEX_SUPPORTED_RATES && bss_cfg->rates[i];
        i++)
    tlv_rates->rates[i] = bss_cfg->rates[i];
 
-  tlv_rates->tlv.len = cpu_to_le16(i);
+  tlv_rates->header.len = cpu_to_le16(i);
   cmd_size += sizeof(struct host_cmd_tlv_rates) + i;
   tlv += sizeof(struct host_cmd_tlv_rates) + i;
  }
@@ -482,10 +508,10 @@ mwifiex_uap_bss_param_prepare(u8 *tlv, void *cmd_buf, u16 *param_size)
      (bss_cfg->band_cfg == BAND_CONFIG_A &&
       bss_cfg->channel <= MAX_CHANNEL_BAND_A))) {
   chan_band = (struct host_cmd_tlv_channel_band *)tlv;
-  chan_band->tlv.type = cpu_to_le16(TLV_TYPE_CHANNELBANDLIST);
-  chan_band->tlv.len =
+  chan_band->header.type = cpu_to_le16(TLV_TYPE_CHANNELBANDLIST);
+  chan_band->header.len =
    cpu_to_le16(sizeof(struct host_cmd_tlv_channel_band) -
-        sizeof(struct host_cmd_tlv));
+        sizeof(struct mwifiex_ie_types_header));
   chan_band->band_config = bss_cfg->band_cfg;
   chan_band->channel = bss_cfg->channel;
   cmd_size += sizeof(struct host_cmd_tlv_channel_band);
@@ -494,11 +520,11 @@ mwifiex_uap_bss_param_prepare(u8 *tlv, void *cmd_buf, u16 *param_size)
  if (bss_cfg->beacon_period >= MIN_BEACON_PERIOD &&
      bss_cfg->beacon_period <= MAX_BEACON_PERIOD) {
   beacon_period = (struct host_cmd_tlv_beacon_period *)tlv;
-  beacon_period->tlv.type =
+  beacon_period->header.type =
      cpu_to_le16(TLV_TYPE_UAP_BEACON_PERIOD);
-  beacon_period->tlv.len =
+  beacon_period->header.len =
    cpu_to_le16(sizeof(struct host_cmd_tlv_beacon_period) -
-        sizeof(struct host_cmd_tlv));
+        sizeof(struct mwifiex_ie_types_header));
   beacon_period->period = cpu_to_le16(bss_cfg->beacon_period);
   cmd_size += sizeof(struct host_cmd_tlv_beacon_period);
   tlv += sizeof(struct host_cmd_tlv_beacon_period);
@@ -506,21 +532,22 @@ mwifiex_uap_bss_param_prepare(u8 *tlv, void *cmd_buf, u16 *param_size)
  if (bss_cfg->dtim_period >= MIN_DTIM_PERIOD &&
      bss_cfg->dtim_period <= MAX_DTIM_PERIOD) {
   dtim_period = (struct host_cmd_tlv_dtim_period *)tlv;
-  dtim_period->tlv.type = cpu_to_le16(TLV_TYPE_UAP_DTIM_PERIOD);
-  dtim_period->tlv.len =
+  dtim_period->header.type =
+   cpu_to_le16(TLV_TYPE_UAP_DTIM_PERIOD);
+  dtim_period->header.len =
    cpu_to_le16(sizeof(struct host_cmd_tlv_dtim_period) -
-        sizeof(struct host_cmd_tlv));
+        sizeof(struct mwifiex_ie_types_header));
   dtim_period->period = bss_cfg->dtim_period;
   cmd_size += sizeof(struct host_cmd_tlv_dtim_period);
   tlv += sizeof(struct host_cmd_tlv_dtim_period);
  }
  if (bss_cfg->rts_threshold <= MWIFIEX_RTS_MAX_VALUE) {
   rts_threshold = (struct host_cmd_tlv_rts_threshold *)tlv;
-  rts_threshold->tlv.type =
+  rts_threshold->header.type =
      cpu_to_le16(TLV_TYPE_UAP_RTS_THRESHOLD);
-  rts_threshold->tlv.len =
+  rts_threshold->header.len =
    cpu_to_le16(sizeof(struct host_cmd_tlv_rts_threshold) -
-        sizeof(struct host_cmd_tlv));
+        sizeof(struct mwifiex_ie_types_header));
   rts_threshold->rts_thr = cpu_to_le16(bss_cfg->rts_threshold);
   cmd_size += sizeof(struct host_cmd_tlv_frag_threshold);
   tlv += sizeof(struct host_cmd_tlv_frag_threshold);
@@ -528,21 +555,22 @@ mwifiex_uap_bss_param_prepare(u8 *tlv, void *cmd_buf, u16 *param_size)
  if ((bss_cfg->frag_threshold >= MWIFIEX_FRAG_MIN_VALUE) &&
      (bss_cfg->frag_threshold <= MWIFIEX_FRAG_MAX_VALUE)) {
   frag_threshold = (struct host_cmd_tlv_frag_threshold *)tlv;
-  frag_threshold->tlv.type =
+  frag_threshold->header.type =
     cpu_to_le16(TLV_TYPE_UAP_FRAG_THRESHOLD);
-  frag_threshold->tlv.len =
+  frag_threshold->header.len =
    cpu_to_le16(sizeof(struct host_cmd_tlv_frag_threshold) -
-        sizeof(struct host_cmd_tlv));
+        sizeof(struct mwifiex_ie_types_header));
   frag_threshold->frag_thr = cpu_to_le16(bss_cfg->frag_threshold);
   cmd_size += sizeof(struct host_cmd_tlv_frag_threshold);
   tlv += sizeof(struct host_cmd_tlv_frag_threshold);
  }
  if (bss_cfg->retry_limit <= MWIFIEX_RETRY_LIMIT) {
   retry_limit = (struct host_cmd_tlv_retry_limit *)tlv;
-  retry_limit->tlv.type = cpu_to_le16(TLV_TYPE_UAP_RETRY_LIMIT);
-  retry_limit->tlv.len =
+  retry_limit->header.type =
+   cpu_to_le16(TLV_TYPE_UAP_RETRY_LIMIT);
+  retry_limit->header.len =
    cpu_to_le16(sizeof(struct host_cmd_tlv_retry_limit) -
-        sizeof(struct host_cmd_tlv));
+        sizeof(struct mwifiex_ie_types_header));
   retry_limit->limit = (u8)bss_cfg->retry_limit;
   cmd_size += sizeof(struct host_cmd_tlv_retry_limit);
   tlv += sizeof(struct host_cmd_tlv_retry_limit);
@@ -557,21 +585,21 @@ mwifiex_uap_bss_param_prepare(u8 *tlv, void *cmd_buf, u16 *param_size)
  if ((bss_cfg->auth_mode <= WLAN_AUTH_SHARED_KEY) ||
      (bss_cfg->auth_mode == MWIFIEX_AUTH_MODE_AUTO)) {
   auth_type = (struct host_cmd_tlv_auth_type *)tlv;
-  auth_type->tlv.type = cpu_to_le16(TLV_TYPE_AUTH_TYPE);
-  auth_type->tlv.len =
+  auth_type->header.type = cpu_to_le16(TLV_TYPE_AUTH_TYPE);
+  auth_type->header.len =
    cpu_to_le16(sizeof(struct host_cmd_tlv_auth_type) -
-   sizeof(struct host_cmd_tlv));
+   sizeof(struct mwifiex_ie_types_header));
   auth_type->auth_type = (u8)bss_cfg->auth_mode;
   cmd_size += sizeof(struct host_cmd_tlv_auth_type);
   tlv += sizeof(struct host_cmd_tlv_auth_type);
  }
  if (bss_cfg->protocol) {
   encrypt_protocol = (struct host_cmd_tlv_encrypt_protocol *)tlv;
-  encrypt_protocol->tlv.type =
+  encrypt_protocol->header.type =
    cpu_to_le16(TLV_TYPE_UAP_ENCRY_PROTOCOL);
-  encrypt_protocol->tlv.len =
+  encrypt_protocol->header.len =
    cpu_to_le16(sizeof(struct host_cmd_tlv_encrypt_protocol)
-   - sizeof(struct host_cmd_tlv));
+   - sizeof(struct mwifiex_ie_types_header));
   encrypt_protocol->proto = cpu_to_le16(bss_cfg->protocol);
   cmd_size += sizeof(struct host_cmd_tlv_encrypt_protocol);
   tlv += sizeof(struct host_cmd_tlv_encrypt_protocol);
@@ -608,9 +636,9 @@ mwifiex_uap_bss_param_prepare(u8 *tlv, void *cmd_buf, u16 *param_size)
 
  if (bss_cfg->sta_ao_timer) {
   ao_timer = (struct host_cmd_tlv_ageout_timer *)tlv;
-  ao_timer->tlv.type = cpu_to_le16(TLV_TYPE_UAP_AO_TIMER);
-  ao_timer->tlv.len = cpu_to_le16(sizeof(*ao_timer) -
-      sizeof(struct host_cmd_tlv));
+  ao_timer->header.type = cpu_to_le16(TLV_TYPE_UAP_AO_TIMER);
+  ao_timer->header.len = cpu_to_le16(sizeof(*ao_timer) -
+     sizeof(struct mwifiex_ie_types_header));
   ao_timer->sta_ao_timer = cpu_to_le32(bss_cfg->sta_ao_timer);
   cmd_size += sizeof(*ao_timer);
   tlv += sizeof(*ao_timer);
@@ -618,9 +646,10 @@ mwifiex_uap_bss_param_prepare(u8 *tlv, void *cmd_buf, u16 *param_size)
 
  if (bss_cfg->ps_sta_ao_timer) {
   ps_ao_timer = (struct host_cmd_tlv_ageout_timer *)tlv;
-  ps_ao_timer->tlv.type = cpu_to_le16(TLV_TYPE_UAP_PS_AO_TIMER);
-  ps_ao_timer->tlv.len = cpu_to_le16(sizeof(*ps_ao_timer) -
-         sizeof(struct host_cmd_tlv));
+  ps_ao_timer->header.type =
+    cpu_to_le16(TLV_TYPE_UAP_PS_AO_TIMER);
+  ps_ao_timer->header.len = cpu_to_le16(sizeof(*ps_ao_timer) -
+    sizeof(struct mwifiex_ie_types_header));
   ps_ao_timer->sta_ao_timer =
      cpu_to_le32(bss_cfg->ps_sta_ao_timer);
   cmd_size += sizeof(*ps_ao_timer);
@@ -636,16 +665,17 @@ mwifiex_uap_bss_param_prepare(u8 *tlv, void *cmd_buf, u16 *param_size)
 static int mwifiex_uap_custom_ie_prepare(u8 *tlv, void *cmd_buf, u16 *ie_size)
 {
  struct mwifiex_ie_list *ap_ie = cmd_buf;
- struct host_cmd_tlv *tlv_ie = (struct host_cmd_tlv *)tlv;
+ struct mwifiex_ie_types_header *tlv_ie = (void *)tlv;
 
  if (!ap_ie || !ap_ie->len || !ap_ie->ie_list)
   return -1;
 
- *ie_size += le16_to_cpu(ap_ie->len) + sizeof(struct host_cmd_tlv);
+ *ie_size += le16_to_cpu(ap_ie->len) +
+   sizeof(struct mwifiex_ie_types_header);
 
  tlv_ie->type = cpu_to_le16(TLV_TYPE_MGMT_IE);
  tlv_ie->len = ap_ie->len;
- tlv += sizeof(struct host_cmd_tlv);
+ tlv += sizeof(struct mwifiex_ie_types_header);
 
  memcpy(tlv, ap_ie->ie_list, le16_to_cpu(ap_ie->len));
 
@@ -689,6 +719,23 @@ mwifiex_cmd_uap_sys_config(struct host_cmd_ds_command *cmd, u16 cmd_action,
  return 0;
 }
 
+/* This function prepares AP specific deauth command with mac supplied in
+ * function parameter.
+ */
+static int mwifiex_cmd_uap_sta_deauth(struct mwifiex_private *priv,
+          struct host_cmd_ds_command *cmd, u8 *mac)
+{
+ struct host_cmd_ds_sta_deauth *sta_deauth = &cmd->params.sta_deauth;
+
+ cmd->command = cpu_to_le16(HostCmd_CMD_UAP_STA_DEAUTH);
+ memcpy(sta_deauth->mac, mac, ETH_ALEN);
+ sta_deauth->reason = cpu_to_le16(WLAN_REASON_DEAUTH_LEAVING);
+
+ cmd->size = cpu_to_le16(sizeof(struct host_cmd_ds_sta_deauth) +
+    S_DS_GEN);
+ return 0;
+}
+
 /* This function prepares the AP specific commands before sending them
  * to the firmware.
  * This is a generic function which calls specific command preparation
@@ -710,6 +757,10 @@ int mwifiex_uap_prepare_cmd(struct mwifiex_private *priv, u16 cmd_no,
   cmd->command = cpu_to_le16(cmd_no);
   cmd->size = cpu_to_le16(S_DS_GEN);
   break;
+ case HostCmd_CMD_UAP_STA_DEAUTH:
+  if (mwifiex_cmd_uap_sta_deauth(priv, cmd, data_buf))
+   return -1;
+  break;
  default:
   dev_err(priv->adapter->dev,
    "PREP_CMD: unknown cmd %#x\n", cmd_no);
diff --git a/drivers/net/wireless/mwifiex/uap_event.c b/drivers/net/wireless/mwifiex/uap_event.c
index 21c640d..92e77a3 100644
--- a/drivers/net/wireless/mwifiex/uap_event.c
+++ b/drivers/net/wireless/mwifiex/uap_event.c
@@ -21,129 +21,8 @@
 #include "main.h"
 #include "11n.h"
 
-/*
- * This function will return the pointer to station entry in station list
- * table which matches specified mac address.
- * This function should be called after acquiring RA list spinlock.
- * NULL is returned if station entry is not found in associated STA list.
- */
-struct mwifiex_sta_node *
-mwifiex_get_sta_entry(struct mwifiex_private *priv, u8 *mac)
-{
- struct mwifiex_sta_node *node;
 
- if (!mac)
-  return NULL;
 
- list_for_each_entry(node, &priv->sta_list, list) {
-  if (!memcmp(node->mac_addr, mac, ETH_ALEN))
-   return node;
- }
-
- return NULL;
-}
-
-/*
- * This function will add a sta_node entry to associated station list
- * table with the given mac address.
- * If entry exist already, existing entry is returned.
- * If received mac address is NULL, NULL is returned.
- */
-static struct mwifiex_sta_node *
-mwifiex_add_sta_entry(struct mwifiex_private *priv, u8 *mac)
-{
- struct mwifiex_sta_node *node;
- unsigned long flags;
-
- if (!mac)
-  return NULL;
-
- spin_lock_irqsave(&priv->sta_list_spinlock, flags);
- node = mwifiex_get_sta_entry(priv, mac);
- if (node)
-  goto done;
-
- node = kzalloc(sizeof(struct mwifiex_sta_node), GFP_ATOMIC);
- if (!node)
-  goto done;
-
- memcpy(node->mac_addr, mac, ETH_ALEN);
- list_add_tail(&node->list, &priv->sta_list);
-
-done:
- spin_unlock_irqrestore(&priv->sta_list_spinlock, flags);
- return node;
-}
-
-/*
- * This function will search for HT IE in association request IEs
- * and set station HT parameters accordingly.
- */
-static void
-mwifiex_set_sta_ht_cap(struct mwifiex_private *priv, const u8 *ies,
-         int ies_len, struct mwifiex_sta_node *node)
-{
- const struct ieee80211_ht_cap *ht_cap;
-
- if (!ies)
-  return;
-
- ht_cap = (void *)cfg80211_find_ie(WLAN_EID_HT_CAPABILITY, ies, ies_len);
- if (ht_cap) {
-  node->is_11n_enabled = 1;
-  node->max_amsdu = le16_to_cpu(ht_cap->cap_info) &
-      IEEE80211_HT_CAP_MAX_AMSDU ?
-      MWIFIEX_TX_DATA_BUF_SIZE_8K :
-      MWIFIEX_TX_DATA_BUF_SIZE_4K;
- } else {
-  node->is_11n_enabled = 0;
- }
-
- return;
-}
-
-/*
- * This function will delete a station entry from station list
- */
-static void mwifiex_del_sta_entry(struct mwifiex_private *priv, u8 *mac)
-{
- struct mwifiex_sta_node *node, *tmp;
- unsigned long flags;
-
- spin_lock_irqsave(&priv->sta_list_spinlock, flags);
-
- node = mwifiex_get_sta_entry(priv, mac);
- if (node) {
-  list_for_each_entry_safe(node, tmp, &priv->sta_list,
-      list) {
-   list_del(&node->list);
-   kfree(node);
-  }
- }
-
- spin_unlock_irqrestore(&priv->sta_list_spinlock, flags);
- return;
-}
-
-/*
- * This function will delete all stations from associated station list.
- */
-static void mwifiex_del_all_sta_list(struct mwifiex_private *priv)
-{
- struct mwifiex_sta_node *node, *tmp;
- unsigned long flags;
-
- spin_lock_irqsave(&priv->sta_list_spinlock, flags);
-
- list_for_each_entry_safe(node, tmp, &priv->sta_list, list) {
-  list_del(&node->list);
-  kfree(node);
- }
-
- INIT_LIST_HEAD(&priv->sta_list);
- spin_unlock_irqrestore(&priv->sta_list_spinlock, flags);
- return;
-}
 
 /*
  * This function handles AP interface specific events generated by firmware.
@@ -271,9 +150,9 @@ int mwifiex_process_uap_event(struct mwifiex_private *priv)
  case EVENT_ADDBA:
   dev_dbg(adapter->dev, "event: ADDBA Request\n");
   if (priv->media_connected)
-   mwifiex_send_cmd_async(priv, HostCmd_CMD_11N_ADDBA_RSP,
-            HostCmd_ACT_GEN_SET, 0,
-            adapter->event_body);
+   mwifiex_send_cmd(priv, HostCmd_CMD_11N_ADDBA_RSP,
+      HostCmd_ACT_GEN_SET, 0,
+      adapter->event_body, false);
   break;
  case EVENT_DELBA:
   dev_dbg(adapter->dev, "event: DELBA Request\n");
@@ -287,6 +166,12 @@ int mwifiex_process_uap_event(struct mwifiex_private *priv)
    mwifiex_11n_ba_stream_timeout(priv, ba_timeout);
   }
   break;
+ case EVENT_EXT_SCAN_REPORT:
+  dev_dbg(adapter->dev, "event: EXT_SCAN Report\n");
+  if (adapter->ext_scan)
+   return mwifiex_handle_event_ext_scan_report(priv,
+      adapter->event_skb->data);
+  break;
  default:
   dev_dbg(adapter->dev, "event: unknown event id: %#x\n",
    eventcause);
@@ -295,3 +180,19 @@ int mwifiex_process_uap_event(struct mwifiex_private *priv)
 
  return 0;
 }
+
+/* This function deletes station entry from associated station list.
+ * Also if both AP and STA are 11n enabled, RxReorder tables and TxBA stream
+ * tables created for this station are deleted.
+ */
+void mwifiex_uap_del_sta_data(struct mwifiex_private *priv,
+         struct mwifiex_sta_node *node)
+{
+ if (priv->ap_11n_enabled && node->is_11n_enabled) {
+  mwifiex_11n_del_rx_reorder_tbl_by_ta(priv, node->mac_addr);
+  mwifiex_del_tx_ba_stream_tbl_by_ra(priv, node->mac_addr);
+ }
+ mwifiex_del_sta_entry(priv, node->mac_addr);
+
+ return;
+}
diff --git a/drivers/net/wireless/mwifiex/uap_txrx.c b/drivers/net/wireless/mwifiex/uap_txrx.c
index 48e6724..b0601b9 100644
--- a/drivers/net/wireless/mwifiex/uap_txrx.c
+++ b/drivers/net/wireless/mwifiex/uap_txrx.c
@@ -24,6 +24,69 @@
 #include "11n_aggr.h"
 #include "11n_rxreorder.h"
 
+/* This function checks if particular RA list has packets more than low bridge
+ * packet threshold and then deletes packet from this RA list.
+ * Function deletes packets from such RA list and returns true. If no such list
+ * is found, false is returned.
+ */
+static bool
+mwifiex_uap_del_tx_pkts_in_ralist(struct mwifiex_private *priv,
+      struct list_head *ra_list_head)
+{
+ struct mwifiex_ra_list_tbl *ra_list;
+ struct sk_buff *skb, *tmp;
+ bool pkt_deleted = false;
+ struct mwifiex_txinfo *tx_info;
+ struct mwifiex_adapter *adapter = priv->adapter;
+
+ list_for_each_entry(ra_list, ra_list_head, list) {
+  if (skb_queue_empty(&ra_list->skb_head))
+   continue;
+
+  skb_queue_walk_safe(&ra_list->skb_head, skb, tmp) {
+   tx_info = MWIFIEX_SKB_TXCB(skb);
+   if (tx_info->flags & MWIFIEX_BUF_FLAG_BRIDGED_PKT) {
+    __skb_unlink(skb, &ra_list->skb_head);
+    mwifiex_write_data_complete(adapter, skb, 0,
+           -1);
+    atomic_dec(&priv->wmm.tx_pkts_queued);
+    pkt_deleted = true;
+   }
+   if ((atomic_read(&adapter->pending_bridged_pkts) <=
+          MWIFIEX_BRIDGED_PKTS_THR_LOW))
+    break;
+  }
+ }
+
+ return pkt_deleted;
+}
+
+/* This function deletes packets from particular RA List. RA list index
+ * from which packets are deleted is preserved so that packets from next RA
+ * list are deleted upon subsequent call thus maintaining fairness.
+ */
+static void mwifiex_uap_cleanup_tx_queues(struct mwifiex_private *priv)
+{
+ unsigned long flags;
+ struct list_head *ra_list;
+ int i;
+
+ spin_lock_irqsave(&priv->wmm.ra_list_spinlock, flags);
+
+ for (i = 0; i < MAX_NUM_TID; i++, priv->del_list_idx++) {
+  if (priv->del_list_idx == MAX_NUM_TID)
+   priv->del_list_idx = 0;
+  ra_list = &priv->wmm.tid_tbl_ptr[priv->del_list_idx].ra_list;
+  if (mwifiex_uap_del_tx_pkts_in_ralist(priv, ra_list)) {
+   priv->del_list_idx++;
+   break;
+  }
+ }
+
+ spin_unlock_irqrestore(&priv->wmm.ra_list_spinlock, flags);
+}
+
+
 static void mwifiex_uap_queue_bridged_pkt(struct mwifiex_private *priv,
       struct sk_buff *skb)
 {
@@ -35,21 +98,25 @@ static void mwifiex_uap_queue_bridged_pkt(struct mwifiex_private *priv,
  int hdr_chop;
  struct timeval tv;
  struct ethhdr *p_ethhdr;
- u8 rfc1042_eth_hdr[ETH_ALEN] = { 0xaa, 0xaa, 0x03, 0x00, 0x00, 0x00 };
 
  uap_rx_pd = (struct uap_rxpd *)(skb->data);
  rx_pkt_hdr = (void *)uap_rx_pd + le16_to_cpu(uap_rx_pd->rx_pkt_offset);
 
  if ((atomic_read(&adapter->pending_bridged_pkts) >=
-          MWIFIEX_BRIDGED_PKTS_THRESHOLD)) {
+          MWIFIEX_BRIDGED_PKTS_THR_HIGH)) {
   dev_err(priv->adapter->dev,
    "Tx: Bridge packet limit reached. Drop packet!\n");
   kfree_skb(skb);
+  mwifiex_uap_cleanup_tx_queues(priv);
   return;
  }
 
- if (!memcmp(&rx_pkt_hdr->rfc1042_hdr,
-      rfc1042_eth_hdr, sizeof(rfc1042_eth_hdr))) {
+ if ((!memcmp(&rx_pkt_hdr->rfc1042_hdr, bridge_tunnel_header,
+       sizeof(bridge_tunnel_header))) ||
+     (!memcmp(&rx_pkt_hdr->rfc1042_hdr, rfc1042_header,
+       sizeof(rfc1042_header)) &&
+      ntohs(rx_pkt_hdr->rfc1042_hdr.snap_type) != ETH_P_AARP &&
+      ntohs(rx_pkt_hdr->rfc1042_hdr.snap_type) != ETH_P_IPX)) {
   /* Replace the 803 header and rfc1042 header (llc/snap) with
    * an Ethernet II header, keep the src/dst and snap_type
    * (ethertype).
@@ -80,7 +147,7 @@ static void mwifiex_uap_queue_bridged_pkt(struct mwifiex_private *priv,
   hdr_chop = (u8 *)&rx_pkt_hdr->eth803_hdr - (u8 *)uap_rx_pd;
  }
 
- /* Chop off the leading header bytes so the it points
+ /* Chop off the leading header bytes so that it points
   * to the start of either the reconstructed EthII frame
   * or the 802.2/llc/snap frame.
   */
@@ -108,20 +175,30 @@ static void mwifiex_uap_queue_bridged_pkt(struct mwifiex_private *priv,
  }
 
  tx_info = MWIFIEX_SKB_TXCB(skb);
+ memset(tx_info, 0, sizeof(*tx_info));
  tx_info->bss_num = priv->bss_num;
  tx_info->bss_type = priv->bss_type;
  tx_info->flags |= MWIFIEX_BUF_FLAG_BRIDGED_PKT;
 
+ if (is_unicast_ether_addr(rx_pkt_hdr->eth803_hdr.h_dest)) {
+  /* Update bridge packet statistics as the
+   * packet is not going to kernel/upper layer.
+   */
+  priv->stats.rx_bytes += skb->len;
+  priv->stats.rx_packets++;
+
+  /* Sending bridge packet to TX queue, so save the packet
+   * length in TXCB to update statistics in TX complete.
+   */
+  tx_info->pkt_len = skb->len;
+ }
+
  do_gettimeofday(&tv);
  skb->tstamp = timeval_to_ktime(tv);
  mwifiex_wmm_add_buf_txqueue(priv, skb);
  atomic_inc(&adapter->tx_pending);
  atomic_inc(&adapter->pending_bridged_pkts);
 
- if ((atomic_read(&adapter->tx_pending) >= MAX_TX_PENDING)) {
-  mwifiex_set_trans_start(priv->netdev);
-  mwifiex_stop_net_dev_queue(priv->netdev, priv->adapter);
- }
  return;
 }
 
@@ -204,36 +281,11 @@ int mwifiex_process_uap_rx_packet(struct mwifiex_private *priv,
    skb->len, le16_to_cpu(uap_rx_pd->rx_pkt_offset),
    le16_to_cpu(uap_rx_pd->rx_pkt_length));
   priv->stats.rx_dropped++;
-
-  if (adapter->if_ops.data_complete)
-   adapter->if_ops.data_complete(adapter, skb);
-  else
-   dev_kfree_skb_any(skb);
-
+  dev_kfree_skb_any(skb);
   return 0;
  }
 
- if (le16_to_cpu(uap_rx_pd->rx_pkt_type) == PKT_TYPE_AMSDU) {
-  struct sk_buff_head list;
-  struct sk_buff *rx_skb;
-
-  __skb_queue_head_init(&list);
-  skb_pull(skb, le16_to_cpu(uap_rx_pd->rx_pkt_offset));
-  skb_trim(skb, le16_to_cpu(uap_rx_pd->rx_pkt_length));
-
-  ieee80211_amsdu_to_8023s(skb, &list, priv->curr_addr,
-      priv->wdev->iftype, 0, false);
-
-  while (!skb_queue_empty(&list)) {
-   rx_skb = __skb_dequeue(&list);
-   ret = mwifiex_recv_packet(priv, rx_skb);
-   if (ret)
-    dev_err(adapter->dev,
-     "AP:Rx A-MSDU failed");
-  }
-
-  return 0;
- } else if (rx_pkt_type == PKT_TYPE_MGMT) {
+ if (rx_pkt_type == PKT_TYPE_MGMT) {
   ret = mwifiex_process_mgmt_packet(priv, skb);
   if (ret)
    dev_err(adapter->dev, "Rx of mgmt packet failed");
@@ -263,12 +315,8 @@ int mwifiex_process_uap_rx_packet(struct mwifiex_private *priv,
       uap_rx_pd->priority, ta, pkt_type,
       skb);
 
- if (ret || (rx_pkt_type == PKT_TYPE_BAR)) {
-  if (adapter->if_ops.data_complete)
-   adapter->if_ops.data_complete(adapter, skb);
-  else
-   dev_kfree_skb_any(skb);
- }
+ if (ret || (rx_pkt_type == PKT_TYPE_BAR))
+  dev_kfree_skb_any(skb);
 
  if (ret)
   priv->stats.rx_dropped++;
diff --git a/drivers/net/wireless/mwifiex/usb.c b/drivers/net/wireless/mwifiex/usb.c
index b7adf3d..a8ce813 100644
--- a/drivers/net/wireless/mwifiex/usb.c
+++ b/drivers/net/wireless/mwifiex/usb.c
@@ -22,15 +22,19 @@
 
 #define USB_VERSION "1.0"
 
-static const char usbdriver_name[] = "usb8797";
-
 static u8 user_rmmod;
 static struct mwifiex_if_ops usb_ops;
 static struct semaphore add_remove_card_sem;
 
 static struct usb_device_id mwifiex_usb_table[] = {
- {USB_DEVICE(USB8797_VID, USB8797_PID_1)},
- {USB_DEVICE_AND_INTERFACE_INFO(USB8797_VID, USB8797_PID_2,
+ /* 8797 */
+ {USB_DEVICE(USB8XXX_VID, USB8797_PID_1)},
+ {USB_DEVICE_AND_INTERFACE_INFO(USB8XXX_VID, USB8797_PID_2,
+           USB_CLASS_VENDOR_SPEC,
+           USB_SUBCLASS_VENDOR_SPEC, 0xff)},
+ /* 8897 */
+ {USB_DEVICE(USB8XXX_VID, USB8897_PID_1)},
+ {USB_DEVICE_AND_INTERFACE_INFO(USB8XXX_VID, USB8897_PID_2,
            USB_CLASS_VENDOR_SPEC,
            USB_SUBCLASS_VENDOR_SPEC, 0xff)},
  { } /* Terminating entry */
@@ -343,10 +347,20 @@ static int mwifiex_usb_probe(struct usb_interface *intf,
    id_vendor, id_product, bcd_device);
 
  /* PID_1 is used for firmware downloading only */
- if (id_product == USB8797_PID_1)
-  card->usb_boot_state = USB8797_FW_DNLD;
- else
-  card->usb_boot_state = USB8797_FW_READY;
+ switch (id_product) {
+ case USB8797_PID_1:
+ case USB8897_PID_1:
+  card->usb_boot_state = USB8XXX_FW_DNLD;
+  break;
+ case USB8797_PID_2:
+ case USB8897_PID_2:
+  card->usb_boot_state = USB8XXX_FW_READY;
+  break;
+ default:
+  pr_warning("unknown id_product %#x\n", id_product);
+  card->usb_boot_state = USB8XXX_FW_DNLD;
+  break;
+ }
 
  card->udev = udev;
  card->intf = intf;
@@ -445,6 +459,7 @@ static int mwifiex_usb_suspend(struct usb_interface *intf, pm_message_t message)
   * 'suspended' state and a 'disconnect' one.
   */
  adapter->is_suspended = true;
+ adapter->hs_enabling = false;
 
  if (atomic_read(&card->rx_cmd_urb_pending) && card->rx_cmd.urb)
   usb_kill_urb(card->rx_cmd.urb);
@@ -511,13 +526,6 @@ static int mwifiex_usb_resume(struct usb_interface *intf)
          MWIFIEX_BSS_ROLE_ANY),
       MWIFIEX_ASYNC_CMD);
 
-#ifdef CONFIG_PM
- /* Resume handler may be called due to remote wakeup,
-  * force to exit suspend anyway
-  */
- usb_disable_autosuspend(card->udev);
-#endif /* CONFIG_PM */
-
  return 0;
 }
 
@@ -525,7 +533,6 @@ static void mwifiex_usb_disconnect(struct usb_interface *intf)
 {
  struct usb_card_rec *card = usb_get_intfdata(intf);
  struct mwifiex_adapter *adapter;
- int i;
 
  if (!card || !card->adapter) {
   pr_err("%s: card or card->adapter is NULL\n", __func__);
@@ -536,21 +543,13 @@ static void mwifiex_usb_disconnect(struct usb_interface *intf)
  if (!adapter->priv_num)
   return;
 
- /* In case driver is removed when asynchronous FW downloading is
-  * in progress
-  */
- wait_for_completion(&adapter->fw_load);
-
  if (user_rmmod) {
 #ifdef CONFIG_PM
   if (adapter->is_suspended)
    mwifiex_usb_resume(intf);
 #endif
-  for (i = 0; i < adapter->priv_num; i++)
-   if ((GET_BSS_ROLE(adapter->priv[i]) ==
-        MWIFIEX_BSS_ROLE_STA) &&
-       adapter->priv[i]->media_connected)
-    mwifiex_deauthenticate(adapter->priv[i], NULL);
+
+  mwifiex_deauthenticate_all(adapter);
 
   mwifiex_init_shutdown_fw(mwifiex_get_priv(adapter,
          MWIFIEX_BSS_ROLE_ANY),
@@ -570,13 +569,13 @@ static void mwifiex_usb_disconnect(struct usb_interface *intf)
 }
 
 static struct usb_driver mwifiex_usb_driver = {
- .name = usbdriver_name,
+ .name = "mwifiex_usb",
  .probe = mwifiex_usb_probe,
  .disconnect = mwifiex_usb_disconnect,
  .id_table = mwifiex_usb_table,
  .suspend = mwifiex_usb_suspend,
  .resume = mwifiex_usb_resume,
- .supports_autosuspend = 1,
+ .soft_unbind = 1,
 };
 
 static int mwifiex_usb_tx_init(struct mwifiex_adapter *adapter)
@@ -774,17 +773,37 @@ static int mwifiex_register_dev(struct mwifiex_adapter *adapter)
 
  card->adapter = adapter;
  adapter->dev = &card->udev->dev;
- strcpy(adapter->fw_name, USB8797_DEFAULT_FW_NAME);
+
+ switch (le16_to_cpu(card->udev->descriptor.idProduct)) {
+ case USB8897_PID_1:
+ case USB8897_PID_2:
+  adapter->tx_buf_size = MWIFIEX_TX_DATA_BUF_SIZE_4K;
+  strcpy(adapter->fw_name, USB8897_DEFAULT_FW_NAME);
+  break;
+ case USB8797_PID_1:
+ case USB8797_PID_2:
+ default:
+  adapter->tx_buf_size = MWIFIEX_TX_DATA_BUF_SIZE_2K;
+  strcpy(adapter->fw_name, USB8797_DEFAULT_FW_NAME);
+  break;
+ }
 
  return 0;
 }
 
+static void mwifiex_unregister_dev(struct mwifiex_adapter *adapter)
+{
+ struct usb_card_rec *card = (struct usb_card_rec *)adapter->card;
+
+ card->adapter = NULL;
+}
+
 static int mwifiex_prog_fw_w_helper(struct mwifiex_adapter *adapter,
         struct mwifiex_fw_image *fw)
 {
  int ret = 0;
  u8 *firmware = fw->fw_buf, *recv_buff;
- u32 retries = USB8797_FW_MAX_RETRY, dlen;
+ u32 retries = USB8XXX_FW_MAX_RETRY, dlen;
  u32 fw_seqnum = 0, tlen = 0, dnld_cmd = 0;
  struct fw_data *fwdata;
  struct fw_sync_header sync_fw;
@@ -886,7 +905,7 @@ static int mwifiex_prog_fw_w_helper(struct mwifiex_adapter *adapter,
     continue;
    }
 
-   retries = USB8797_FW_MAX_RETRY;
+   retries = USB8XXX_FW_MAX_RETRY;
    break;
   }
   fw_seqnum++;
@@ -910,13 +929,13 @@ static int mwifiex_usb_dnld_fw(struct mwifiex_adapter *adapter,
  int ret;
  struct usb_card_rec *card = (struct usb_card_rec *)adapter->card;
 
- if (card->usb_boot_state == USB8797_FW_DNLD) {
+ if (card->usb_boot_state == USB8XXX_FW_DNLD) {
   ret = mwifiex_prog_fw_w_helper(adapter, fw);
   if (ret)
    return -1;
 
   /* Boot state changes after successful firmware download */
-  if (card->usb_boot_state == USB8797_FW_DNLD)
+  if (card->usb_boot_state == USB8XXX_FW_DNLD)
    return -1;
  }
 
@@ -949,11 +968,9 @@ static int mwifiex_usb_cmd_event_complete(struct mwifiex_adapter *adapter,
  return 0;
 }
 
-static int mwifiex_usb_data_complete(struct mwifiex_adapter *adapter,
-         struct sk_buff *skb)
+static int mwifiex_usb_data_complete(struct mwifiex_adapter *adapter)
 {
  atomic_dec(&adapter->rx_pending);
- dev_kfree_skb_any(skb);
 
  return 0;
 }
@@ -971,6 +988,7 @@ static int mwifiex_pm_wakeup_card(struct mwifiex_adapter *adapter)
 
 static struct mwifiex_if_ops usb_ops = {
  .register_dev =  mwifiex_register_dev,
+ .unregister_dev = mwifiex_unregister_dev,
  .wakeup =  mwifiex_pm_wakeup_card,
  .wakeup_complete = mwifiex_pm_wakeup_card_complete,
 
@@ -1030,4 +1048,5 @@ MODULE_AUTHOR("Marvell International Ltd.");
 MODULE_DESCRIPTION("Marvell WiFi-Ex USB Driver version" USB_VERSION);
 MODULE_VERSION(USB_VERSION);
 MODULE_LICENSE("GPL v2");
-MODULE_FIRMWARE("mrvl/usb8797_uapsta.bin");
+MODULE_FIRMWARE(USB8797_DEFAULT_FW_NAME);
+MODULE_FIRMWARE(USB8897_DEFAULT_FW_NAME);
diff --git a/drivers/net/wireless/mwifiex/usb.h b/drivers/net/wireless/mwifiex/usb.h
index 98c4316..15b73d1 100644
--- a/drivers/net/wireless/mwifiex/usb.h
+++ b/drivers/net/wireless/mwifiex/usb.h
@@ -22,19 +22,23 @@
 
 #include <linux/usb.h>
 
-#define USB8797_VID  0x1286
+#define USB8XXX_VID  0x1286
+
 #define USB8797_PID_1  0x2043
 #define USB8797_PID_2  0x2044
+#define USB8897_PID_1  0x2045
+#define USB8897_PID_2  0x2046
 
-#define USB8797_FW_DNLD  1
-#define USB8797_FW_READY 2
-#define USB8797_FW_MAX_RETRY 3
+#define USB8XXX_FW_DNLD  1
+#define USB8XXX_FW_READY 2
+#define USB8XXX_FW_MAX_RETRY 3
 
 #define MWIFIEX_TX_DATA_URB 6
 #define MWIFIEX_RX_DATA_URB 6
 #define MWIFIEX_USB_TIMEOUT 100
 
 #define USB8797_DEFAULT_FW_NAME "mrvl/usb8797_uapsta.bin"
+#define USB8897_DEFAULT_FW_NAME "mrvl/usb8897_uapsta.bin"
 
 #define FW_DNLD_TX_BUF_SIZE 620
 #define FW_DNLD_RX_BUF_SIZE 2048
diff --git a/drivers/net/wireless/mwifiex/util.c b/drivers/net/wireless/mwifiex/util.c
index e57ac0d..6da5abf 100644
--- a/drivers/net/wireless/mwifiex/util.c
+++ b/drivers/net/wireless/mwifiex/util.c
@@ -72,7 +72,7 @@ int mwifiex_init_shutdown_fw(struct mwifiex_private *priv,
   return -1;
  }
 
- return mwifiex_send_cmd_sync(priv, cmd, HostCmd_ACT_GEN_SET, 0, NULL);
+ return mwifiex_send_cmd(priv, cmd, HostCmd_ACT_GEN_SET, 0, NULL, true);
 }
 EXPORT_SYMBOL_GPL(mwifiex_init_shutdown_fw);
 
@@ -104,6 +104,7 @@ int mwifiex_get_debug_info(struct mwifiex_private *priv,
   info->pm_wakeup_fw_try = adapter->pm_wakeup_fw_try;
   info->is_hs_configured = adapter->is_hs_configured;
   info->hs_activated = adapter->hs_activated;
+  info->is_cmd_timedout = adapter->is_cmd_timedout;
   info->num_cmd_host_to_card_failure
     = adapter->dbg.num_cmd_host_to_card_failure;
   info->num_cmd_sleep_cfm_host_to_card_failure
@@ -119,7 +120,6 @@ int mwifiex_get_debug_info(struct mwifiex_private *priv,
   info->num_cmd_assoc_failure =
      adapter->dbg.num_cmd_assoc_failure;
   info->num_tx_timeout = adapter->dbg.num_tx_timeout;
-  info->num_cmd_timeout = adapter->dbg.num_cmd_timeout;
   info->timeout_cmd_id = adapter->dbg.timeout_cmd_id;
   info->timeout_cmd_act = adapter->dbg.timeout_cmd_act;
   memcpy(info->last_cmd_id, adapter->dbg.last_cmd_id,
@@ -171,8 +171,8 @@ mwifiex_process_mgmt_packet(struct mwifiex_private *priv,
  rx_pd->rx_pkt_length = cpu_to_le16(pkt_len);
 
  cfg80211_rx_mgmt(priv->wdev, priv->roc_cfg.chan.center_freq,
-    CAL_RSSI(rx_pd->snr, rx_pd->nf),
-    skb->data, pkt_len, GFP_ATOMIC);
+    CAL_RSSI(rx_pd->snr, rx_pd->nf), skb->data, pkt_len,
+    0, GFP_ATOMIC);
 
  return 0;
 }
@@ -191,6 +191,9 @@ int mwifiex_recv_packet(struct mwifiex_private *priv, struct sk_buff *skb)
  if (!skb)
   return -1;
 
+ priv->stats.rx_bytes += skb->len;
+ priv->stats.rx_packets++;
+
  skb->dev = priv->netdev;
  skb->protocol = eth_type_trans(skb, priv->netdev);
  skb->ip_summed = CHECKSUM_NONE;
@@ -217,8 +220,6 @@ int mwifiex_recv_packet(struct mwifiex_private *priv, struct sk_buff *skb)
      (skb->truesize > MWIFIEX_RX_DATA_BUF_SIZE))
   skb->truesize += (skb->len - MWIFIEX_RX_DATA_BUF_SIZE);
 
- priv->stats.rx_bytes += skb->len;
- priv->stats.rx_packets++;
  if (in_interrupt())
   netif_rx(skb);
  else
@@ -251,3 +252,117 @@ int mwifiex_complete_cmd(struct mwifiex_adapter *adapter,
 
  return 0;
 }
+
+/* This function will return the pointer to station entry in station list
+ * table which matches specified mac address.
+ * This function should be called after acquiring RA list spinlock.
+ * NULL is returned if station entry is not found in associated STA list.
+ */
+struct mwifiex_sta_node *
+mwifiex_get_sta_entry(struct mwifiex_private *priv, const u8 *mac)
+{
+ struct mwifiex_sta_node *node;
+
+ if (!mac)
+  return NULL;
+
+ list_for_each_entry(node, &priv->sta_list, list) {
+  if (!memcmp(node->mac_addr, mac, ETH_ALEN))
+   return node;
+ }
+
+ return NULL;
+}
+
+/* This function will add a sta_node entry to associated station list
+ * table with the given mac address.
+ * If entry exist already, existing entry is returned.
+ * If received mac address is NULL, NULL is returned.
+ */
+struct mwifiex_sta_node *
+mwifiex_add_sta_entry(struct mwifiex_private *priv, const u8 *mac)
+{
+ struct mwifiex_sta_node *node;
+ unsigned long flags;
+
+ if (!mac)
+  return NULL;
+
+ spin_lock_irqsave(&priv->sta_list_spinlock, flags);
+ node = mwifiex_get_sta_entry(priv, mac);
+ if (node)
+  goto done;
+
+ node = kzalloc(sizeof(*node), GFP_ATOMIC);
+ if (!node)
+  goto done;
+
+ memcpy(node->mac_addr, mac, ETH_ALEN);
+ list_add_tail(&node->list, &priv->sta_list);
+
+done:
+ spin_unlock_irqrestore(&priv->sta_list_spinlock, flags);
+ return node;
+}
+
+/* This function will search for HT IE in association request IEs
+ * and set station HT parameters accordingly.
+ */
+void
+mwifiex_set_sta_ht_cap(struct mwifiex_private *priv, const u8 *ies,
+         int ies_len, struct mwifiex_sta_node *node)
+{
+ const struct ieee80211_ht_cap *ht_cap;
+
+ if (!ies)
+  return;
+
+ ht_cap = (void *)cfg80211_find_ie(WLAN_EID_HT_CAPABILITY, ies, ies_len);
+ if (ht_cap) {
+  node->is_11n_enabled = 1;
+  node->max_amsdu = le16_to_cpu(ht_cap->cap_info) &
+      IEEE80211_HT_CAP_MAX_AMSDU ?
+      MWIFIEX_TX_DATA_BUF_SIZE_8K :
+      MWIFIEX_TX_DATA_BUF_SIZE_4K;
+ } else {
+  node->is_11n_enabled = 0;
+ }
+
+ return;
+}
+
+/* This function will delete a station entry from station list */
+void mwifiex_del_sta_entry(struct mwifiex_private *priv, const u8 *mac)
+{
+ struct mwifiex_sta_node *node;
+ unsigned long flags;
+
+ spin_lock_irqsave(&priv->sta_list_spinlock, flags);
+
+ node = mwifiex_get_sta_entry(priv, mac);
+ if (node) {
+  list_del(&node->list);
+  kfree(node);
+ }
+
+ spin_unlock_irqrestore(&priv->sta_list_spinlock, flags);
+ return;
+}
+
+/* This function will delete all stations from associated station list. */
+void mwifiex_del_all_sta_list(struct mwifiex_private *priv)
+{
+ struct mwifiex_sta_node *node, *tmp;
+ unsigned long flags;
+
+ spin_lock_irqsave(&priv->sta_list_spinlock, flags);
+
+ list_for_each_entry_safe(node, tmp, &priv->sta_list, list) {
+  list_del(&node->list);
+  kfree(node);
+ }
+
+ INIT_LIST_HEAD(&priv->sta_list);
+ spin_unlock_irqrestore(&priv->sta_list_spinlock, flags);
+ return;
+}
diff --git a/drivers/net/wireless/mwifiex/util.h b/drivers/net/wireless/mwifiex/util.h
index cb2d058..caadb37 100644
--- a/drivers/net/wireless/mwifiex/util.h
+++ b/drivers/net/wireless/mwifiex/util.h
@@ -20,18 +20,57 @@
 #ifndef _MWIFIEX_UTIL_H_
 #define _MWIFIEX_UTIL_H_
 
+struct mwifiex_dma_mapping {
+ dma_addr_t addr;
+ size_t len;
+};
+
+struct mwifiex_cb {
+ struct mwifiex_dma_mapping dma_mapping;
+ union {
+  struct mwifiex_rxinfo rx_info;
+  struct mwifiex_txinfo tx_info;
+ };
+};
+
 static inline struct mwifiex_rxinfo *MWIFIEX_SKB_RXCB(struct sk_buff *skb)
 {
- return (struct mwifiex_rxinfo *)(skb->cb + sizeof(dma_addr_t));
+ struct mwifiex_cb *cb = (struct mwifiex_cb *)skb->cb;
+
+ BUILD_BUG_ON(sizeof(struct mwifiex_cb) > sizeof(skb->cb));
+ return &cb->rx_info;
 }
 
 static inline struct mwifiex_txinfo *MWIFIEX_SKB_TXCB(struct sk_buff *skb)
 {
- return (struct mwifiex_txinfo *)(skb->cb + sizeof(dma_addr_t));
+ struct mwifiex_cb *cb = (struct mwifiex_cb *)skb->cb;
+
+ return &cb->tx_info;
 }
 
-static inline void MWIFIEX_SKB_PACB(struct sk_buff *skb, dma_addr_t *buf_pa)
+static inline void mwifiex_store_mapping(struct sk_buff *skb,
+      struct mwifiex_dma_mapping *mapping)
 {
- memcpy(buf_pa, skb->cb, sizeof(dma_addr_t));
+ struct mwifiex_cb *cb = (struct mwifiex_cb *)skb->cb;
+
+ memcpy(&cb->dma_mapping, mapping, sizeof(*mapping));
 }
+
+static inline void mwifiex_get_mapping(struct sk_buff *skb,
+           struct mwifiex_dma_mapping *mapping)
+{
+ struct mwifiex_cb *cb = (struct mwifiex_cb *)skb->cb;
+
+ memcpy(mapping, &cb->dma_mapping, sizeof(*mapping));
+}
+
+static inline dma_addr_t MWIFIEX_SKB_DMA_ADDR(struct sk_buff *skb)
+{
+ struct mwifiex_dma_mapping mapping;
+
+ mwifiex_get_mapping(skb, &mapping);
+
+ return mapping.addr;
+}
+
 #endif /* !_MWIFIEX_UTIL_H_ */
diff --git a/drivers/net/wireless/mwifiex/wmm.c b/drivers/net/wireless/mwifiex/wmm.c
index ae31e8d..d3671d0 100644
--- a/drivers/net/wireless/mwifiex/wmm.c
+++ b/drivers/net/wireless/mwifiex/wmm.c
@@ -37,6 +37,9 @@
 /* Offset for TOS field in the IP header */
 #define IPTOS_OFFSET 5
 
+static bool disable_tx_amsdu;
+module_param(disable_tx_amsdu, bool, 0644);
+
 /* WMM information IE */
 static const u8 wmm_info_ie[] = { WLAN_EID_VENDOR_SPECIFIC, 0x07,
  0x00, 0x50, 0xf2, 0x02,
@@ -61,21 +64,6 @@ static u8 tos_to_tid[] = {
  0x07   /* 1 1 1 AC_VO */
 };
 
-/*
- * This table inverses the tos_to_tid operation to get a priority
- * which is in sequential order, and can be compared.
- * Use this to compare the priority of two different TIDs.
- */
-static u8 tos_to_tid_inv[] = {
- 0x02,  /* from tos_to_tid[2] = 0 */
- 0x00,  /* from tos_to_tid[0] = 1 */
- 0x01,  /* from tos_to_tid[1] = 2 */
- 0x03,
- 0x04,
- 0x05,
- 0x06,
- 0x07};
-
 static u8 ac_to_tid[4][2] = { {1, 2}, {0, 3}, {4, 5}, {6, 7} };
 
 /*
@@ -104,7 +92,7 @@ mwifiex_wmm_ac_debug_print(const struct ieee_types_wmm_ac_parameters *ac_param)
  * The function also initializes the list with the provided RA.
  */
 static struct mwifiex_ra_list_tbl *
-mwifiex_wmm_allocate_ralist_node(struct mwifiex_adapter *adapter, u8 *ra)
+mwifiex_wmm_allocate_ralist_node(struct mwifiex_adapter *adapter, const u8 *ra)
 {
  struct mwifiex_ra_list_tbl *ra_list;
 
@@ -117,7 +105,7 @@ mwifiex_wmm_allocate_ralist_node(struct mwifiex_adapter *adapter, u8 *ra)
 
  memcpy(ra_list->ra, ra, ETH_ALEN);
 
- ra_list->total_pkts_size = 0;
+ ra_list->total_pkt_count = 0;
 
  dev_dbg(adapter->dev, "info: allocated ra_list %p\n", ra_list);
 
@@ -151,8 +139,7 @@ static u8 mwifiex_get_random_ba_threshold(void)
  * This function allocates and adds a RA list for all TIDs
  * with the given RA.
  */
-void
-mwifiex_ralist_add(struct mwifiex_private *priv, u8 *ra)
+void mwifiex_ralist_add(struct mwifiex_private *priv, const u8 *ra)
 {
  int i;
  struct mwifiex_ra_list_tbl *ra_list;
@@ -172,8 +159,16 @@ mwifiex_ralist_add(struct mwifiex_private *priv, u8 *ra)
    break;
 
   ra_list->is_11n_enabled = 0;
+  ra_list->tdls_link = false;
   if (!mwifiex_queuing_ra_based(priv)) {
-   ra_list->is_11n_enabled = IS_11N_ENABLED(priv);
+   if (mwifiex_get_tdls_link_status(priv, ra) ==
+       TDLS_SETUP_COMPLETE) {
+    ra_list->tdls_link = true;
+    ra_list->is_11n_enabled =
+     mwifiex_tdls_peer_11n_enabled(priv, ra);
+   } else {
+    ra_list->is_11n_enabled = IS_11N_ENABLED(priv);
+   }
   } else {
    ra_list->is_11n_enabled =
           mwifiex_is_sta_11n_enabled(priv, node);
@@ -185,7 +180,7 @@ mwifiex_ralist_add(struct mwifiex_private *priv, u8 *ra)
    ra_list, ra_list->is_11n_enabled);
 
   if (ra_list->is_11n_enabled) {
-   ra_list->pkt_count = 0;
+   ra_list->ba_pkt_count = 0;
    ra_list->ba_packet_thr =
            mwifiex_get_random_ba_threshold();
   }
@@ -210,8 +205,9 @@ static void mwifiex_wmm_default_queue_priorities(struct mwifiex_private *priv)
  * This function map ACs to TIDs.
  */
 static void
-mwifiex_wmm_queue_priorities_tid(struct mwifiex_wmm_desc *wmm)
+mwifiex_wmm_queue_priorities_tid(struct mwifiex_private *priv)
 {
+ struct mwifiex_wmm_desc *wmm = &priv->wmm;
  u8 *queue_priority = wmm->queue_priority;
  int i;
 
@@ -221,7 +217,7 @@ mwifiex_wmm_queue_priorities_tid(struct mwifiex_wmm_desc *wmm)
  }
 
  for (i = 0; i < MAX_NUM_TID; ++i)
-  tos_to_tid_inv[tos_to_tid[i]] = (u8)i;
+  priv->tos_to_tid_inv[tos_to_tid[i]] = (u8)i;
 
  atomic_set(&wmm->highest_queued_prio, HIGH_PRIO_TID);
 }
@@ -282,7 +278,7 @@ mwifiex_wmm_setup_queue_priorities(struct mwifiex_private *priv,
   }
  }
 
- mwifiex_wmm_queue_priorities_tid(&priv->wmm);
+ mwifiex_wmm_queue_priorities_tid(priv);
 }
 
 /*
@@ -385,8 +381,7 @@ mwifiex_wmm_convert_tos_to_ac(struct mwifiex_adapter *adapter, u32 tos)
  * AP is disabled (due to call admission control (ACM bit). Mapping
  * of TID to AC is taken care of internally.
  */
-static u8
-mwifiex_wmm_downgrade_tid(struct mwifiex_private *priv, u32 tid)
+u8 mwifiex_wmm_downgrade_tid(struct mwifiex_private *priv, u32 tid)
 {
  enum mwifiex_wmm_ac_e ac, ac_down;
  u8 new_tid;
@@ -418,20 +413,19 @@ mwifiex_wmm_init(struct mwifiex_adapter *adapter)
    continue;
 
   for (i = 0; i < MAX_NUM_TID; ++i) {
-   priv->aggr_prio_tbl[i].amsdu = tos_to_tid_inv[i];
-   priv->aggr_prio_tbl[i].ampdu_ap = tos_to_tid_inv[i];
-   priv->aggr_prio_tbl[i].ampdu_user = tos_to_tid_inv[i];
+   if (!disable_tx_amsdu &&
+       adapter->tx_buf_size > MWIFIEX_TX_DATA_BUF_SIZE_2K)
+    priv->aggr_prio_tbl[i].amsdu =
+       priv->tos_to_tid_inv[i];
+   else
+    priv->aggr_prio_tbl[i].amsdu =
+       BA_STREAM_NOT_ALLOWED;
+   priv->aggr_prio_tbl[i].ampdu_ap =
+       priv->tos_to_tid_inv[i];
+   priv->aggr_prio_tbl[i].ampdu_user =
+       priv->tos_to_tid_inv[i];
   }
 
-  priv->aggr_prio_tbl[6].amsdu
-     = priv->aggr_prio_tbl[6].ampdu_ap
-     = priv->aggr_prio_tbl[6].ampdu_user
-     = BA_STREAM_NOT_ALLOWED;
-
-  priv->aggr_prio_tbl[7].amsdu = priv->aggr_prio_tbl[7].ampdu_ap
-     = priv->aggr_prio_tbl[7].ampdu_user
-     = BA_STREAM_NOT_ALLOWED;
-
   mwifiex_set_ba_params(priv);
   mwifiex_reset_11n_rx_seq_num(priv);
 
@@ -543,6 +537,7 @@ void
 mwifiex_clean_txrx(struct mwifiex_private *priv)
 {
  unsigned long flags;
+ struct sk_buff *skb, *tmp;
 
  mwifiex_11n_cleanup_reorder_tbl(priv);
  spin_lock_irqsave(&priv->wmm.ra_list_spinlock, flags);
@@ -556,9 +551,13 @@ mwifiex_clean_txrx(struct mwifiex_private *priv)
  mwifiex_wmm_delete_all_ralist(priv);
  memcpy(tos_to_tid, ac_to_tid, sizeof(tos_to_tid));
 
- if (priv->adapter->if_ops.clean_pcie_ring)
+ if (priv->adapter->if_ops.clean_pcie_ring &&
+     !priv->adapter->surprise_removed)
   priv->adapter->if_ops.clean_pcie_ring(priv->adapter);
  spin_unlock_irqrestore(&priv->wmm.ra_list_spinlock, flags);
+
+ skb_queue_walk_safe(&priv->tdls_txq, skb, tmp)
+  mwifiex_write_data_complete(priv->adapter, skb, 0, -1);
 }
 
 /*
@@ -567,7 +566,7 @@ mwifiex_clean_txrx(struct mwifiex_private *priv)
  */
 static struct mwifiex_ra_list_tbl *
 mwifiex_wmm_get_ralist_node(struct mwifiex_private *priv, u8 tid,
-       u8 *ra_addr)
+       const u8 *ra_addr)
 {
  struct mwifiex_ra_list_tbl *ra_list;
 
@@ -587,8 +586,9 @@ mwifiex_wmm_get_ralist_node(struct mwifiex_private *priv, u8 tid,
  * If no such node is found, a new node is added first and then
  * retrieved.
  */
-static struct mwifiex_ra_list_tbl *
-mwifiex_wmm_get_queue_raptr(struct mwifiex_private *priv, u8 tid, u8 *ra_addr)
+struct mwifiex_ra_list_tbl *
+mwifiex_wmm_get_queue_raptr(struct mwifiex_private *priv, u8 tid,
+       const u8 *ra_addr)
 {
  struct mwifiex_ra_list_tbl *ra_list;
 
@@ -637,6 +637,21 @@ mwifiex_wmm_add_buf_txqueue(struct mwifiex_private *priv,
  struct mwifiex_ra_list_tbl *ra_list;
  u8 ra[ETH_ALEN], tid_down;
  unsigned long flags;
+ struct list_head list_head;
+ int tdls_status = TDLS_NOT_SETUP;
+ struct ethhdr *eth_hdr = (struct ethhdr *)skb->data;
+ struct mwifiex_txinfo *tx_info = MWIFIEX_SKB_TXCB(skb);
+
+ memcpy(ra, eth_hdr->h_dest, ETH_ALEN);
+
+ if (GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_STA &&
+     ISSUPP_TDLS_ENABLED(adapter->fw_cap_info)) {
+  if (ntohs(eth_hdr->h_proto) == ETH_P_TDLS)
+   dev_dbg(adapter->dev,
+    "TDLS setup packet for %pM. Don't block\n", ra);
+  else if (memcmp(priv->cfg_bssid, ra, ETH_ALEN))
+   tdls_status = mwifiex_get_tdls_link_status(priv, ra);
+ }
 
  if (!priv->media_connected && !mwifiex_is_skb_mgmt_frame(skb)) {
   dev_dbg(adapter->dev, "data: drop packet in disconnect\n");
@@ -655,12 +670,27 @@ mwifiex_wmm_add_buf_txqueue(struct mwifiex_private *priv,
     have only 1 raptr for a tid in case of infra */
  if (!mwifiex_queuing_ra_based(priv) &&
      !mwifiex_is_skb_mgmt_frame(skb)) {
-  if (!list_empty(&priv->wmm.tid_tbl_ptr[tid_down].ra_list))
-   ra_list = list_first_entry(
-    &priv->wmm.tid_tbl_ptr[tid_down].ra_list,
-    struct mwifiex_ra_list_tbl, list);
-  else
-   ra_list = NULL;
+  switch (tdls_status) {
+  case TDLS_SETUP_COMPLETE:
+   ra_list = mwifiex_wmm_get_queue_raptr(priv, tid_down,
+             ra);
+   tx_info->flags |= MWIFIEX_BUF_FLAG_TDLS_PKT;
+   break;
+  case TDLS_SETUP_INPROGRESS:
+   skb_queue_tail(&priv->tdls_txq, skb);
+   spin_unlock_irqrestore(&priv->wmm.ra_list_spinlock,
+            flags);
+   return;
+  default:
+   list_head = priv->wmm.tid_tbl_ptr[tid_down].ra_list;
+   if (!list_empty(&list_head))
+    ra_list = list_first_entry(
+     &list_head, struct mwifiex_ra_list_tbl,
+     list);
+   else
+    ra_list = NULL;
+   break;
+  }
  } else {
   memcpy(ra, skb->data, ETH_ALEN);
   if (ra[0] & 0x01 || mwifiex_is_skb_mgmt_frame(skb))
@@ -676,13 +706,13 @@ mwifiex_wmm_add_buf_txqueue(struct mwifiex_private *priv,
 
  skb_queue_tail(&ra_list->skb_head, skb);
 
- ra_list->total_pkts_size += skb->len;
- ra_list->pkt_count++;
+ ra_list->ba_pkt_count++;
+ ra_list->total_pkt_count++;
 
  if (atomic_read(&priv->wmm.highest_queued_prio) <
-      tos_to_tid_inv[tid_down])
+      priv->tos_to_tid_inv[tid_down])
   atomic_set(&priv->wmm.highest_queued_prio,
-      tos_to_tid_inv[tid_down]);
+      priv->tos_to_tid_inv[tid_down]);
 
  atomic_inc(&priv->wmm.tx_pkts_queued);
 
@@ -705,7 +735,7 @@ int mwifiex_ret_wmm_get_status(struct mwifiex_private *priv,
 {
  u8 *curr = (u8 *) &resp->params.get_wmm_status;
  uint16_t resp_len = le16_to_cpu(resp->size), tlv_len;
- int valid = true;
+ bool valid = true;
 
  struct mwifiex_ie_types_data *tlv_hdr;
  struct mwifiex_ie_types_wmm_queue_status *tlv_wmm_qstatus;
@@ -719,6 +749,9 @@ int mwifiex_ret_wmm_get_status(struct mwifiex_private *priv,
   tlv_hdr = (struct mwifiex_ie_types_data *) curr;
   tlv_len = le16_to_cpu(tlv_hdr->header.len);
 
+  if (resp_len < tlv_len + sizeof(tlv_hdr->header))
+   break;
+
   switch (le16_to_cpu(tlv_hdr->header.type)) {
   case TLV_TYPE_WMMQSTATUS:
    tlv_wmm_qstatus =
@@ -1034,7 +1067,7 @@ mwifiex_send_single_packet(struct mwifiex_private *priv,
  tx_info = MWIFIEX_SKB_TXCB(skb);
  dev_dbg(adapter->dev, "data: dequeuing the packet %p %p\n", ptr, skb);
 
- ptr->total_pkts_size -= skb->len;
+ ptr->total_pkt_count--;
 
  if (!skb_queue_empty(&ptr->skb_head))
   skb_next = skb_peek(&ptr->skb_head);
@@ -1059,8 +1092,8 @@ mwifiex_send_single_packet(struct mwifiex_private *priv,
 
   skb_queue_tail(&ptr->skb_head, skb);
 
-  ptr->total_pkts_size += skb->len;
-  ptr->pkt_count++;
+  ptr->total_pkt_count++;
+  ptr->ba_pkt_count++;
   tx_info->flags |= MWIFIEX_BUF_FLAG_REQUEUED_PKT;
   spin_unlock_irqrestore(&priv->wmm.ra_list_spinlock,
            ra_list_flags);
@@ -1212,16 +1245,25 @@ mwifiex_dequeue_tx_packet(struct mwifiex_adapter *adapter)
 
  if (!ptr->is_11n_enabled ||
      mwifiex_is_ba_stream_setup(priv, ptr, tid) ||
-     priv->wps.session_enable ||
-     ((priv->sec_info.wpa_enabled ||
-       priv->sec_info.wpa2_enabled) &&
-      !priv->wpa_is_gtk_set)) {
-  mwifiex_send_single_packet(priv, ptr, ptr_index, flags);
-  /* ra_list_spinlock has been freed in
-     mwifiex_send_single_packet() */
+     priv->wps.session_enable) {
+  if (ptr->is_11n_enabled &&
+      mwifiex_is_ba_stream_setup(priv, ptr, tid) &&
+      mwifiex_is_amsdu_in_ampdu_allowed(priv, ptr, tid) &&
+      mwifiex_is_amsdu_allowed(priv, tid) &&
+      mwifiex_is_11n_aggragation_possible(priv, ptr,
+       adapter->tx_buf_size))
+   mwifiex_11n_aggregate_pkt(priv, ptr, ptr_index, flags);
+   /* ra_list_spinlock has been freed in
+    * mwifiex_11n_aggregate_pkt()
+    */
+  else
+   mwifiex_send_single_packet(priv, ptr, ptr_index, flags);
+   /* ra_list_spinlock has been freed in
+    * mwifiex_send_single_packet()
+    */
  } else {
-  if (mwifiex_is_ampdu_allowed(priv, tid) &&
-      ptr->pkt_count > ptr->ba_packet_thr) {
+  if (mwifiex_is_ampdu_allowed(priv, ptr, tid) &&
+      ptr->ba_pkt_count > ptr->ba_packet_thr) {
    if (mwifiex_space_avail_for_new_ba_stream(adapter)) {
     mwifiex_create_ba_tbl(priv, ptr->ra, tid,
             BA_SETUP_INPROGRESS);
diff --git a/drivers/net/wireless/mwifiex/wmm.h b/drivers/net/wireless/mwifiex/wmm.h
index 644d6e0..eca56e3 100644
--- a/drivers/net/wireless/mwifiex/wmm.h
+++ b/drivers/net/wireless/mwifiex/wmm.h
@@ -34,6 +34,21 @@ enum ieee_types_wmm_ecw_bitmasks {
 static const u16 mwifiex_1d_to_wmm_queue[8] = { 1, 0, 0, 1, 2, 2, 3, 3 };
 
 /*
+ * This table inverses the tos_to_tid operation to get a priority
+ * which is in sequential order, and can be compared.
+ * Use this to compare the priority of two different TIDs.
+ */
+static const u8 tos_to_tid_inv[] = {
+ 0x02,  /* from tos_to_tid[2] = 0 */
+ 0x00,  /* from tos_to_tid[0] = 1 */
+ 0x01,  /* from tos_to_tid[1] = 2 */
+ 0x03,
+ 0x04,
+ 0x05,
+ 0x06,
+ 0x07};
+
+/*
  * This function retrieves the TID of the given RA list.
  */
 static inline int
@@ -83,11 +98,10 @@ mwifiex_wmm_is_ra_list_empty(struct list_head *ra_list_hhead)
 }
 
 void mwifiex_wmm_add_buf_txqueue(struct mwifiex_private *priv,
-     struct sk_buff *skb);
-void mwifiex_ralist_add(struct mwifiex_private *priv, u8 *ra);
+     struct sk_buff *skb);
+void mwifiex_ralist_add(struct mwifiex_private *priv, const u8 *ra);
 void mwifiex_rotate_priolists(struct mwifiex_private *priv,
-         struct mwifiex_ra_list_tbl *ra,
-         int tid);
+         struct mwifiex_ra_list_tbl *ra, int tid);
 
 int mwifiex_wmm_lists_empty(struct mwifiex_adapter *adapter);
 void mwifiex_wmm_process_tx(struct mwifiex_adapter *adapter);
@@ -95,21 +109,22 @@ int mwifiex_is_ralist_valid(struct mwifiex_private *priv,
        struct mwifiex_ra_list_tbl *ra_list, int tid);
 
 u8 mwifiex_wmm_compute_drv_pkt_delay(struct mwifiex_private *priv,
-          const struct sk_buff *skb);
+         const struct sk_buff *skb);
 void mwifiex_wmm_init(struct mwifiex_adapter *adapter);
 
-extern u32 mwifiex_wmm_process_association_req(struct mwifiex_private *priv,
-       u8 **assoc_buf,
-       struct ieee_types_wmm_parameter
-       *wmmie,
-       struct ieee80211_ht_cap
-       *htcap);
+u32 mwifiex_wmm_process_association_req(struct mwifiex_private *priv,
+     u8 **assoc_buf,
+     struct ieee_types_wmm_parameter *wmmie,
+     struct ieee80211_ht_cap *htcap);
 
 void mwifiex_wmm_setup_queue_priorities(struct mwifiex_private *priv,
-     struct ieee_types_wmm_parameter
-     *wmm_ie);
+     struct ieee_types_wmm_parameter *wmm_ie);
 void mwifiex_wmm_setup_ac_downgrade(struct mwifiex_private *priv);
-extern int mwifiex_ret_wmm_get_status(struct mwifiex_private *priv,
-          const struct host_cmd_ds_command *resp);
+int mwifiex_ret_wmm_get_status(struct mwifiex_private *priv,
+          const struct host_cmd_ds_command *resp);
+struct mwifiex_ra_list_tbl *
+mwifiex_wmm_get_queue_raptr(struct mwifiex_private *priv, u8 tid,
+       const u8 *ra_addr);
+u8 mwifiex_wmm_downgrade_tid(struct mwifiex_private *priv, u32 tid);
 
 #endif /* !_MWIFIEX_WMM_H_ */
-- 
1.7.1