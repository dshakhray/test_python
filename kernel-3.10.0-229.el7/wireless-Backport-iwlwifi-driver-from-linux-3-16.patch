From 8a87920c7510cf99028ccd75b70fc735f950e1fd Mon Sep 17 00:00:00 2001
From: Stanislaw Gruszka <sgruszka@redhat.com>
Date: Fri, 5 Sep 2014 11:23:44 -0400
Subject: [wireless] Backport iwlwifi driver from linux 3.16

Message-id: <1409916232-5882-8-git-send-email-sgruszka@redhat.com>
Patchwork-id: 91438
O-Subject: [RHEL7 PATCH 07/15] Backport iwlwifi driver from linux 3.16
Bugzilla: 1085079 1107878 1136324
RH-Acked-by: John Linville <linville@redhat.com>
RH-Acked-by: Prarit Bhargava <prarit@redhat.com>
RH-Acked-by: John Greene <jogreene@redhat.com>

BZ#1136324
BZ#1085079

Decription:
Sync iwlwifi driver to code from linux 3.16 (up to commit
19583ca584d6f574384e17fe7613dfaeadcdc4a6).

Brew:
https://brewweb.devel.redhat.com/taskinfo?taskID=7918052

Testing:
Tested on Intel 7265, 6300, 5100 adapters.

Signed-off-by: Jarod Wilson <jarod@redhat.com>

diff --git a/drivers/net/wireless/iwlwifi/Kconfig b/drivers/net/wireless/iwlwifi/Kconfig
index 56c2040..7fd5042 100644
--- a/drivers/net/wireless/iwlwifi/Kconfig
+++ b/drivers/net/wireless/iwlwifi/Kconfig
@@ -2,10 +2,6 @@ config IWLWIFI
  tristate "Intel Wireless WiFi Next Gen AGN - Wireless-N/Advanced-N/Ultimate-N (iwlwifi) "
  depends on PCI && MAC80211 && HAS_IOMEM
  select FW_LOADER
- select NEW_LEDS
- select LEDS_CLASS
- select LEDS_TRIGGERS
- select MAC80211_LEDS
  ---help---
    Select to build the driver supporting the:
 
@@ -22,6 +18,8 @@ config IWLWIFI
   Intel Wireless WiFi Link 6150BGN 2 Adapter
   Intel 100 Series Wi-Fi Adapters (100BGN and 130BGN)
   Intel 2000 Series Wi-Fi Adapters
+  Intel 7260 Wi-Fi Adapter
+  Intel 3160 Wi-Fi Adapter
 
 
    This driver uses the kernel's mac80211 subsystem.
@@ -41,22 +39,29 @@ config IWLWIFI
    say M here and read <file:Documentation/kbuild/modules.txt>.  The
    module will be called iwlwifi.
 
+config IWLWIFI_LEDS
+ bool
+ depends on IWLWIFI
+ depends on LEDS_CLASS=y || LEDS_CLASS=IWLWIFI
+ select LEDS_TRIGGERS
+ select MAC80211_LEDS
+ default y
+
 config IWLDVM
  tristate "Intel Wireless WiFi DVM Firmware support"
  depends on IWLWIFI
  default IWLWIFI
  help
-   This is the driver supporting the DVM firmware which is
-   currently the only firmware available for existing devices.
+   This is the driver that supports the DVM firmware which is
+   used by most existing devices (with the exception of 7260
+   and 3160).
 
 config IWLMVM
  tristate "Intel Wireless WiFi MVM Firmware support"
  depends on IWLWIFI
  help
-   This is the driver supporting the MVM firmware which is
-   currently only available for 7000 series devices.
-
-   Say yes if you have such a device.
+   This is the driver that supports the MVM firmware which is
+   currently only available for 7260 and 3160 devices.
 
 # don't call it _MODULE -- will confuse Kconfig/fixdep/...
 config IWLWIFI_OPMODE_MODULAR
@@ -67,6 +72,19 @@ config IWLWIFI_OPMODE_MODULAR
 comment "WARNING: iwlwifi is useless without IWLDVM or IWLMVM"
  depends on IWLWIFI && IWLDVM=n && IWLMVM=n
 
+config IWLWIFI_BCAST_FILTERING
+ bool "Enable broadcast filtering"
+ depends on IWLMVM
+ help
+   Say Y here to enable default bcast filtering configuration.
+
+   Enabling broadcast filtering will drop any incoming wireless
+   broadcast frames, except some very specific predefined
+   patterns (e.g. incoming arp requests).
+
+   If unsure, don't enable this option, as some programs might
+   expect incoming broadcasts for their normal operations.
+
 menu "Debugging Options"
  depends on IWLWIFI
 
@@ -127,30 +145,3 @@ config IWLWIFI_DEVICE_TRACING
    If unsure, say Y so we can help you better when problems
    occur.
 endmenu
-
-config IWLWIFI_DEVICE_TESTMODE
- def_bool y
- depends on IWLWIFI
- depends on NL80211_TESTMODE
- help
-   This option enables the testmode support for iwlwifi device through
-   NL80211_TESTMODE. This provide the capabilities of enable user space
-   validation applications to interacts with the device through the
-   generic netlink message via NL80211_TESTMODE channel.
-
-config IWLWIFI_P2P
- def_bool y
- bool "iwlwifi experimental P2P support"
- depends on IWLWIFI
- help
-   This option enables experimental P2P support for some devices
-   based on microcode support. Since P2P support is still under
-   development, this option may even enable it for some devices
-   now that turn out to not support it in the future due to
-   microcode restrictions.
-
-   To determine if your microcode supports the experimental P2P
-   offered by this option, check if the driver advertises AP
-   support when it is loaded.
-
-   Say Y only if you want to experiment with P2P.
diff --git a/drivers/net/wireless/iwlwifi/Makefile b/drivers/net/wireless/iwlwifi/Makefile
index 3b5613e..3d32f41 100644
--- a/drivers/net/wireless/iwlwifi/Makefile
+++ b/drivers/net/wireless/iwlwifi/Makefile
@@ -7,14 +7,15 @@ iwlwifi-objs  += iwl-notif-wait.o
 iwlwifi-objs  += iwl-eeprom-read.o iwl-eeprom-parse.o
 iwlwifi-objs  += iwl-phy-db.o iwl-nvm-parse.o
 iwlwifi-objs  += pcie/drv.o pcie/rx.o pcie/tx.o pcie/trans.o
-iwlwifi-objs  += iwl-1000.o iwl-2000.o iwl-5000.o iwl-6000.o iwl-7000.o
+iwlwifi-$(CONFIG_IWLDVM) += iwl-1000.o iwl-2000.o iwl-5000.o iwl-6000.o
+iwlwifi-$(CONFIG_IWLMVM) += iwl-7000.o iwl-8000.o
+
+iwlwifi-objs += $(iwlwifi-m)
 
 iwlwifi-$(CONFIG_IWLWIFI_DEVICE_TRACING) += iwl-devtrace.o
-iwlwifi-$(CONFIG_IWLWIFI_DEVICE_TESTMODE) += iwl-test.o
 
 ccflags-y += -D__CHECK_ENDIAN__ -I$(src)
 
-
 obj-$(CONFIG_IWLDVM) += dvm/
 obj-$(CONFIG_IWLMVM) += mvm/
 
diff --git a/drivers/net/wireless/iwlwifi/dvm/Makefile b/drivers/net/wireless/iwlwifi/dvm/Makefile
index 5ff76b2..4d19685 100644
--- a/drivers/net/wireless/iwlwifi/dvm/Makefile
+++ b/drivers/net/wireless/iwlwifi/dvm/Makefile
@@ -4,10 +4,10 @@ iwldvm-objs  += main.o rs.o mac80211.o ucode.o tx.o
 iwldvm-objs  += lib.o calib.o tt.o sta.o rx.o
 
 iwldvm-objs  += power.o
-iwldvm-objs  += scan.o led.o
+iwldvm-objs  += scan.o
 iwldvm-objs  += rxon.o devices.o
 
+iwldvm-$(CONFIG_IWLWIFI_LEDS) += led.o
 iwldvm-$(CONFIG_IWLWIFI_DEBUGFS) += debugfs.o
-iwldvm-$(CONFIG_IWLWIFI_DEVICE_TESTMODE) += testmode.o
 
 ccflags-y += -D__CHECK_ENDIAN__ -I$(src)/../
diff --git a/drivers/net/wireless/iwlwifi/dvm/agn.h b/drivers/net/wireless/iwlwifi/dvm/agn.h
index 48545ab..c160dad 100644
--- a/drivers/net/wireless/iwlwifi/dvm/agn.h
+++ b/drivers/net/wireless/iwlwifi/dvm/agn.h
@@ -5,7 +5,7 @@
  *
  * GPL LICENSE SUMMARY
  *
- * Copyright(c) 2008 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2008 - 2014 Intel Corporation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of version 2 of the GNU General Public License as
@@ -30,7 +30,7 @@
  *
  * BSD LICENSE
  *
- * Copyright(c) 2005 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2005 - 2014 Intel Corporation. All rights reserved.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -76,13 +76,16 @@
 #define IWL_INVALID_STATION 255
 
 /* device operations */
-extern struct iwl_lib_ops iwl1000_lib;
-extern struct iwl_lib_ops iwl2000_lib;
-extern struct iwl_lib_ops iwl2030_lib;
-extern struct iwl_lib_ops iwl5000_lib;
-extern struct iwl_lib_ops iwl5150_lib;
-extern struct iwl_lib_ops iwl6000_lib;
-extern struct iwl_lib_ops iwl6030_lib;
+extern const struct iwl_dvm_cfg iwl_dvm_1000_cfg;
+extern const struct iwl_dvm_cfg iwl_dvm_2000_cfg;
+extern const struct iwl_dvm_cfg iwl_dvm_105_cfg;
+extern const struct iwl_dvm_cfg iwl_dvm_2030_cfg;
+extern const struct iwl_dvm_cfg iwl_dvm_5000_cfg;
+extern const struct iwl_dvm_cfg iwl_dvm_5150_cfg;
+extern const struct iwl_dvm_cfg iwl_dvm_6000_cfg;
+extern const struct iwl_dvm_cfg iwl_dvm_6005_cfg;
+extern const struct iwl_dvm_cfg iwl_dvm_6050_cfg;
+extern const struct iwl_dvm_cfg iwl_dvm_6030_cfg;
 
 
 #define TIME_UNIT  1024
@@ -103,11 +106,10 @@ extern struct iwl_lib_ops iwl6030_lib;
 #define STATUS_CHANNEL_SWITCH_PENDING 11
 #define STATUS_SCAN_COMPLETE 12
 #define STATUS_POWER_PMI 13
-#define STATUS_SCAN_ROC_EXPIRED 14
 
 struct iwl_ucode_capabilities;
 
-extern struct ieee80211_ops iwlagn_hw_ops;
+extern const struct ieee80211_ops iwlagn_hw_ops;
 
 static inline void iwl_set_calib_hdr(struct iwl_calib_hdr *hdr, u8 cmd)
 {
@@ -247,7 +249,6 @@ u8 iwl_toggle_tx_ant(struct iwl_priv *priv, u8 ant_idx, u8 valid);
 
 /* scan */
 void iwlagn_post_scan(struct iwl_priv *priv);
-void iwlagn_disable_roc(struct iwl_priv *priv);
 int iwl_force_rf_reset(struct iwl_priv *priv, bool external);
 void iwl_init_scan_params(struct iwl_priv *priv);
 int iwl_scan_cancel(struct iwl_priv *priv);
@@ -262,10 +263,6 @@ int __must_check iwl_scan_initiate(struct iwl_priv *priv,
        enum iwl_scan_type scan_type,
        enum ieee80211_band band);
 
-void iwl_scan_roc_expired(struct iwl_priv *priv);
-void iwl_scan_offchannel_skb(struct iwl_priv *priv);
-void iwl_scan_offchannel_skb_status(struct iwl_priv *priv);
-
 /* For faster active scanning, scan will move to the next channel if fewer than
  * PLCP_QUIET_THRESH packets are heard on this channel within
  * ACTIVE_QUIET_TIME after sending probe request.  This shortens the dwell
@@ -291,8 +288,8 @@ void iwlagn_bt_adjust_rssi_monitor(struct iwl_priv *priv, bool rssi_ena);
 
 static inline bool iwl_advanced_bt_coexist(struct iwl_priv *priv)
 {
- return priv->cfg->bt_params &&
-        priv->cfg->bt_params->advanced_bt_coexist;
+ return priv->lib->bt_params &&
+        priv->lib->bt_params->advanced_bt_coexist;
 }
 
 #ifdef CONFIG_IWLWIFI_DEBUG
@@ -400,44 +397,7 @@ static inline __le32 iwl_hw_set_rate_n_flags(u8 rate, u32 flags)
  return cpu_to_le32(flags|(u32)rate);
 }
 
-extern int iwl_alive_start(struct iwl_priv *priv);
-
-/* testmode support */
-#ifdef CONFIG_IWLWIFI_DEVICE_TESTMODE
-
-extern int iwlagn_mac_testmode_cmd(struct ieee80211_hw *hw, void *data,
-       int len);
-extern int iwlagn_mac_testmode_dump(struct ieee80211_hw *hw,
-        struct sk_buff *skb,
-        struct netlink_callback *cb,
-        void *data, int len);
-extern void iwl_testmode_init(struct iwl_priv *priv);
-extern void iwl_testmode_free(struct iwl_priv *priv);
-
-#else
-
-static inline
-int iwlagn_mac_testmode_cmd(struct ieee80211_hw *hw, void *data, int len)
-{
- return -ENOSYS;
-}
-
-static inline
-int iwlagn_mac_testmode_dump(struct ieee80211_hw *hw, struct sk_buff *skb,
-        struct netlink_callback *cb,
-        void *data, int len)
-{
- return -ENOSYS;
-}
-
-static inline void iwl_testmode_init(struct iwl_priv *priv)
-{
-}
-
-static inline void iwl_testmode_free(struct iwl_priv *priv)
-{
-}
-#endif
+int iwl_alive_start(struct iwl_priv *priv);
 
 #ifdef CONFIG_IWLWIFI_DEBUG
 void iwl_print_rx_config_cmd(struct iwl_priv *priv,
@@ -520,7 +480,7 @@ do {         \
 } while (0)
 #endif    /* CONFIG_IWLWIFI_DEBUG */
 
-extern const char *iwl_dvm_cmd_strings[REPLY_MAX];
+extern const char *const iwl_dvm_cmd_strings[REPLY_MAX];
 
 static inline const char *iwl_dvm_get_cmd_string(u8 cmd)
 {
diff --git a/drivers/net/wireless/iwlwifi/dvm/calib.c b/drivers/net/wireless/iwlwifi/dvm/calib.c
index d6c4cf2..20e6aa9 100644
--- a/drivers/net/wireless/iwlwifi/dvm/calib.c
+++ b/drivers/net/wireless/iwlwifi/dvm/calib.c
@@ -5,7 +5,7 @@
  *
  * GPL LICENSE SUMMARY
  *
- * Copyright(c) 2008 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2008 - 2014 Intel Corporation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of version 2 of the GNU General Public License as
@@ -30,7 +30,7 @@
  *
  * BSD LICENSE
  *
- * Copyright(c) 2005 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2005 - 2014 Intel Corporation. All rights reserved.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -94,7 +94,6 @@ int iwl_send_calib_results(struct iwl_priv *priv)
 {
  struct iwl_host_cmd hcmd = {
   .id = REPLY_PHY_CALIBRATION_CMD,
-  .flags = CMD_SYNC,
  };
  struct iwl_calib_result *res;
 
@@ -521,7 +520,7 @@ static int iwl_enhance_sensitivity_write(struct iwl_priv *priv)
 
  iwl_prepare_legacy_sensitivity_tbl(priv, data, &cmd.enhance_table[0]);
 
- if (priv->cfg->base_params->hd_v2) {
+ if (priv->lib->hd_v2) {
   cmd.enhance_table[HD_INA_NON_SQUARE_DET_OFDM_INDEX] =
    HD_INA_NON_SQUARE_DET_OFDM_DATA_V2;
   cmd.enhance_table[HD_INA_NON_SQUARE_DET_CCK_INDEX] =
@@ -895,7 +894,7 @@ static void iwlagn_gain_computation(struct iwl_priv *priv,
    continue;
   }
 
-  delta_g = (priv->cfg->base_params->chain_noise_scale *
+  delta_g = (priv->lib->chain_noise_scale *
    ((s32)average_noise[default_chain] -
    (s32)average_noise[i])) / 1500;
 
@@ -1051,8 +1050,8 @@ void iwl_chain_noise_calibration(struct iwl_priv *priv)
   return;
 
  /* Analyze signal for disconnected antenna */
- if (priv->cfg->bt_params &&
-     priv->cfg->bt_params->advanced_bt_coexist) {
+ if (priv->lib->bt_params &&
+     priv->lib->bt_params->advanced_bt_coexist) {
   /* Disable disconnected antenna algorithm for advanced
      bt coex, assuming valid antennas are connected */
   data->active_chains = priv->nvm_data->valid_rx_ant;
diff --git a/drivers/net/wireless/iwlwifi/dvm/calib.h b/drivers/net/wireless/iwlwifi/dvm/calib.h
index cfddde1..aeae4e8 100644
--- a/drivers/net/wireless/iwlwifi/dvm/calib.h
+++ b/drivers/net/wireless/iwlwifi/dvm/calib.h
@@ -5,7 +5,7 @@
  *
  * GPL LICENSE SUMMARY
  *
- * Copyright(c) 2008 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2008 - 2014 Intel Corporation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of version 2 of the GNU General Public License as
@@ -30,7 +30,7 @@
  *
  * BSD LICENSE
  *
- * Copyright(c) 2005 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2005 - 2014 Intel Corporation. All rights reserved.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/drivers/net/wireless/iwlwifi/dvm/commands.h b/drivers/net/wireless/iwlwifi/dvm/commands.h
index 95ca026..751ae1d 100644
--- a/drivers/net/wireless/iwlwifi/dvm/commands.h
+++ b/drivers/net/wireless/iwlwifi/dvm/commands.h
@@ -5,7 +5,7 @@
  *
  * GPL LICENSE SUMMARY
  *
- * Copyright(c) 2005 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2005 - 2014 Intel Corporation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of version 2 of the GNU General Public License as
@@ -30,7 +30,7 @@
  *
  * BSD LICENSE
  *
- * Copyright(c) 2005 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2005 - 2014 Intel Corporation. All rights reserved.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -838,10 +838,6 @@ struct iwl_qosparam_cmd {
 #define STA_MODIFY_DELBA_TID_MSK 0x10
 #define STA_MODIFY_SLEEP_TX_COUNT_MSK 0x20
 
-/* Receiver address (actually, Rx station's index into station table),
- * combined with Traffic ID (QOS priority), in format used by Tx Scheduler */
-#define BUILD_RAxTID(sta_id, tid) (((sta_id) << 4) + (tid))
-
 /* agn */
 struct iwl_keyinfo {
  __le16 key_flags;
@@ -1225,14 +1221,6 @@ struct iwl_rx_mpdu_res_start {
 #define TX_CMD_SEC_KEY128 0x08
 
 /*
- * security overhead sizes
- */
-#define WEP_IV_LEN 4
-#define WEP_ICV_LEN 4
-#define CCMP_MIC_LEN 8
-#define TKIP_ICV_LEN 4
-
-/*
  * REPLY_TX = 0x1c (command)
  */
 
diff --git a/drivers/net/wireless/iwlwifi/dvm/debugfs.c b/drivers/net/wireless/iwlwifi/dvm/debugfs.c
index d532948..0ffb6ff 100644
--- a/drivers/net/wireless/iwlwifi/dvm/debugfs.c
+++ b/drivers/net/wireless/iwlwifi/dvm/debugfs.c
@@ -2,7 +2,7 @@
  *
  * GPL LICENSE SUMMARY
  *
- * Copyright(c) 2008 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2008 - 2014 Intel Corporation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of version 2 of the GNU General Public License as
@@ -69,19 +69,7 @@
 } while (0)
 
 /* file operation */
-#define DEBUGFS_READ_FUNC(name)                                         \
-static ssize_t iwl_dbgfs_##name##_read(struct file *file,               \
-     char __user *user_buf,          \
-     size_t count, loff_t *ppos);
-
-#define DEBUGFS_WRITE_FUNC(name)                                        \
-static ssize_t iwl_dbgfs_##name##_write(struct file *file,              \
-     const char __user *user_buf,    \
-     size_t count, loff_t *ppos);
-
-
 #define DEBUGFS_READ_FILE_OPS(name)                                     \
- DEBUGFS_READ_FUNC(name);                                        \
 static const struct file_operations iwl_dbgfs_##name##_ops = {          \
  .read = iwl_dbgfs_##name##_read,    \
  .open = simple_open,      \
@@ -89,7 +77,6 @@ static const struct file_operations iwl_dbgfs_##name##_ops = {          \
 };
 
 #define DEBUGFS_WRITE_FILE_OPS(name)                                    \
- DEBUGFS_WRITE_FUNC(name);                                       \
 static const struct file_operations iwl_dbgfs_##name##_ops = {          \
  .write = iwl_dbgfs_##name##_write,                              \
  .open = simple_open,      \
@@ -98,8 +85,6 @@ static const struct file_operations iwl_dbgfs_##name##_ops = {          \
 
 
 #define DEBUGFS_READ_WRITE_FILE_OPS(name)                               \
- DEBUGFS_READ_FUNC(name);                                        \
- DEBUGFS_WRITE_FUNC(name);                                       \
 static const struct file_operations iwl_dbgfs_##name##_ops = {          \
  .write = iwl_dbgfs_##name##_write,                              \
  .read = iwl_dbgfs_##name##_read,                                \
@@ -367,12 +352,12 @@ static ssize_t iwl_dbgfs_channels_read(struct file *file, char __user *user_buf,
      channels[i].max_power,
      channels[i].flags & IEEE80211_CHAN_RADAR ?
      " (IEEE 802.11h required)" : "",
-     ((channels[i].flags & IEEE80211_CHAN_NO_IBSS)
+     ((channels[i].flags & IEEE80211_CHAN_NO_IR)
      || (channels[i].flags &
      IEEE80211_CHAN_RADAR)) ? "" :
      ", IBSS",
      channels[i].flags &
-     IEEE80211_CHAN_PASSIVE_SCAN ?
+     IEEE80211_CHAN_NO_IR ?
      "passive only" : "active/passive");
  }
  supp_band = iwl_get_hw_mode(priv, IEEE80211_BAND_5GHZ);
@@ -390,12 +375,12 @@ static ssize_t iwl_dbgfs_channels_read(struct file *file, char __user *user_buf,
      channels[i].max_power,
      channels[i].flags & IEEE80211_CHAN_RADAR ?
      " (IEEE 802.11h required)" : "",
-     ((channels[i].flags & IEEE80211_CHAN_NO_IBSS)
+     ((channels[i].flags & IEEE80211_CHAN_NO_IR)
      || (channels[i].flags &
      IEEE80211_CHAN_RADAR)) ? "" :
      ", IBSS",
      channels[i].flags &
-     IEEE80211_CHAN_PASSIVE_SCAN ?
+     IEEE80211_CHAN_NO_IR ?
      "passive only" : "active/passive");
  }
  ret = simple_read_from_buffer(user_buf, count, ppos, buf, pos);
@@ -1496,7 +1481,7 @@ static ssize_t iwl_dbgfs_ucode_bt_stats_read(struct file *file,
 
  /* make request to uCode to retrieve statistics information */
  mutex_lock(&priv->mutex);
- ret = iwl_send_statistics_request(priv, CMD_SYNC, false);
+ ret = iwl_send_statistics_request(priv, 0, false);
  mutex_unlock(&priv->mutex);
 
  if (ret)
@@ -1883,7 +1868,7 @@ static ssize_t iwl_dbgfs_clear_ucode_statistics_write(struct file *file,
 
  /* make request to uCode to retrieve statistics information */
  mutex_lock(&priv->mutex);
- iwl_send_statistics_request(priv, CMD_SYNC, true);
+ iwl_send_statistics_request(priv, 0, true);
  mutex_unlock(&priv->mutex);
 
  return count;
@@ -2203,7 +2188,6 @@ static int iwl_cmd_echo_test(struct iwl_priv *priv)
  struct iwl_host_cmd cmd = {
   .id = REPLY_ECHO,
   .len = { 0 },
-  .flags = CMD_SYNC,
  };
 
  ret = iwl_dvm_send_cmd(priv, &cmd);
@@ -2335,7 +2319,7 @@ static ssize_t iwl_dbgfs_fw_restart_write(struct file *file,
  mutex_lock(&priv->mutex);
 
  /* take the return value to make compiler happy - it will fail anyway */
- ret = iwl_dvm_send_cmd_pdu(priv, REPLY_ERROR, CMD_SYNC, 0, NULL);
+ ret = iwl_dvm_send_cmd_pdu(priv, REPLY_ERROR, 0, 0, NULL);
 
  mutex_unlock(&priv->mutex);
 
diff --git a/drivers/net/wireless/iwlwifi/dvm/dev.h b/drivers/net/wireless/iwlwifi/dvm/dev.h
index 71ea775..a6f22c3 100644
--- a/drivers/net/wireless/iwlwifi/dvm/dev.h
+++ b/drivers/net/wireless/iwlwifi/dvm/dev.h
@@ -1,6 +1,6 @@
 /******************************************************************************
  *
- * Copyright(c) 2003 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2003 - 2014 Intel Corporation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
@@ -52,8 +52,6 @@
 #include "rs.h"
 #include "tt.h"
 
-#include "iwl-test.h"
-
 /* CT-KILL constants */
 #define CT_KILL_THRESHOLD_LEGACY   110 /* in Celsius */
 #define CT_KILL_THRESHOLD    114 /* in Celsius */
@@ -272,7 +270,7 @@ struct iwl_sensitivity_ranges {
  * iwlXXXX_     <-- Hardware specific (implemented in iwl-XXXX.c for XXXX)
  *
  ****************************************************************************/
-extern void iwl_update_chain_flags(struct iwl_priv *priv);
+void iwl_update_chain_flags(struct iwl_priv *priv);
 extern const u8 iwl_bcast_addr[ETH_ALEN];
 
 #define IWL_OPERATION_MODE_AUTO     0
@@ -542,7 +540,6 @@ struct iwl_rxon_context {
 enum iwl_scan_type {
  IWL_SCAN_NORMAL,
  IWL_SCAN_RADIO_RESET,
- IWL_SCAN_ROC,
 };
 
 /**
@@ -568,16 +565,61 @@ struct iwl_hw_params {
  const struct iwl_sensitivity_ranges *sens;
 };
 
-struct iwl_lib_ops {
- /* set hw dependent parameters */
+/**
+ * struct iwl_dvm_bt_params - DVM specific BT (coex) parameters
+ * @advanced_bt_coexist: support advanced bt coexist
+ * @bt_init_traffic_load: specify initial bt traffic load
+ * @bt_prio_boost: default bt priority boost value
+ * @agg_time_limit: maximum number of uSec in aggregation
+ * @bt_sco_disable: uCode should not response to BT in SCO/ESCO mode
+ */
+struct iwl_dvm_bt_params {
+ bool advanced_bt_coexist;
+ u8 bt_init_traffic_load;
+ u32 bt_prio_boost;
+ u16 agg_time_limit;
+ bool bt_sco_disable;
+ bool bt_session_2;
+};
+
+/**
+ * struct iwl_dvm_cfg - DVM firmware specific device configuration
+ * @set_hw_params: set hardware parameters
+ * @set_channel_switch: send channel switch command
+ * @nic_config: apply device specific configuration
+ * @temperature: read temperature
+ * @adv_thermal_throttle: support advance thermal throttle
+ * @support_ct_kill_exit: support ct kill exit condition
+ * @plcp_delta_threshold: plcp error rate threshold used to trigger
+ * radio tuning when there is a high receiving plcp error rate
+ * @chain_noise_scale: default chain noise scale used for gain computation
+ * @hd_v2: v2 of enhanced sensitivity value, used for 2000 series and up
+ * @no_idle_support: do not support idle mode
+ * @bt_params: pointer to BT parameters
+ * @need_temp_offset_calib: need to perform temperature offset calibration
+ * @no_xtal_calib: some devices do not need crystal calibration data,
+ * don't send it to those
+ * @temp_offset_v2: support v2 of temperature offset calibration
+ * @adv_pm: advanced power management
+ */
+struct iwl_dvm_cfg {
  void (*set_hw_params)(struct iwl_priv *priv);
  int (*set_channel_switch)(struct iwl_priv *priv,
       struct ieee80211_channel_switch *ch_switch);
- /* device specific configuration */
  void (*nic_config)(struct iwl_priv *priv);
-
- /* temperature */
  void (*temperature)(struct iwl_priv *priv);
+
+ const struct iwl_dvm_bt_params *bt_params;
+ s32 chain_noise_scale;
+ u8 plcp_delta_threshold;
+ bool adv_thermal_throttle;
+ bool support_ct_kill_exit;
+ bool hd_v2;
+ bool no_idle_support;
+ bool need_temp_offset_calib;
+ bool no_xtal_calib;
+ bool temp_offset_v2;
+ bool adv_pm;
 };
 
 struct iwl_wipan_noa_data {
@@ -610,7 +652,7 @@ struct iwl_priv {
  struct device *dev;  /* for debug prints only */
  const struct iwl_cfg *cfg;
  const struct iwl_fw *fw;
- const struct iwl_lib_ops *lib;
+ const struct iwl_dvm_cfg *lib;
  unsigned long status;
 
  spinlock_t sta_lock;
@@ -646,10 +688,6 @@ struct iwl_priv {
  struct iwl_spectrum_notification measure_report;
  u8 measurement_status;
 
-#define IWL_OWNERSHIP_DRIVER 0
-#define IWL_OWNERSHIP_TM 1
- u8 ucode_owner;
-
  /* ucode beacon time */
  u32 ucode_beacon_time;
  int missed_beacon_threshold;
@@ -786,12 +824,6 @@ struct iwl_priv {
  struct reply_tx_error_statistics reply_tx_stats;
  struct reply_agg_tx_error_statistics reply_agg_tx_stats;
 
- /* remain-on-channel offload support */
- struct ieee80211_channel *hw_roc_channel;
- struct delayed_work hw_roc_disable_work;
- int hw_roc_duration;
- bool hw_roc_setup, hw_roc_start_notified;
-
  /* bt coex */
  u8 bt_enable_flag;
  u8 bt_status;
@@ -844,7 +876,7 @@ struct iwl_priv {
 #endif /* CONFIG_IWLWIFI_DEBUGFS */
 
  struct iwl_nvm_data *nvm_data;
- /* eeprom blob for debugfs/testmode */
+ /* eeprom blob for debugfs */
  u8 *eeprom_blob;
  size_t eeprom_blob_size;
 
@@ -856,13 +888,10 @@ struct iwl_priv {
 
  struct iwl_event_log event_log;
 
+#ifdef CONFIG_IWLWIFI_LEDS
  struct led_classdev led;
  unsigned long blink_on, blink_off;
  bool led_registered;
-
-#ifdef CONFIG_IWLWIFI_DEVICE_TESTMODE
- struct iwl_test tst;
- u32 tm_fixed_rate;
 #endif
 
  /* WoWLAN GTK rekey data */
@@ -870,6 +899,9 @@ struct iwl_priv {
  __le64 replay_ctr;
  __le16 last_seq_ctl;
  bool have_rekey_data;
+#ifdef CONFIG_PM_SLEEP
+ struct wiphy_wowlan_support wowlan_support;
+#endif
 
  /* device_pointers: pointers to ucode event tables */
  struct {
diff --git a/drivers/net/wireless/iwlwifi/dvm/devices.c b/drivers/net/wireless/iwlwifi/dvm/devices.c
index c48907c..34b41e5 100644
--- a/drivers/net/wireless/iwlwifi/dvm/devices.c
+++ b/drivers/net/wireless/iwlwifi/dvm/devices.c
@@ -1,6 +1,6 @@
 /******************************************************************************
  *
- * Copyright(c) 2008 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2008 - 2014 Intel Corporation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
@@ -174,10 +174,13 @@ static void iwl1000_hw_set_hw_params(struct iwl_priv *priv)
  priv->hw_params.sens = &iwl1000_sensitivity;
 }
 
-struct iwl_lib_ops iwl1000_lib = {
+const struct iwl_dvm_cfg iwl_dvm_1000_cfg = {
  .set_hw_params = iwl1000_hw_set_hw_params,
  .nic_config = iwl1000_nic_config,
  .temperature = iwlagn_temperature,
+ .support_ct_kill_exit = true,
+ .plcp_delta_threshold = IWL_MAX_PLCP_ERR_EXT_LONG_THRESHOLD_DEF,
+ .chain_noise_scale = 1000,
 };
 
 
@@ -232,16 +235,56 @@ static void iwl2000_hw_set_hw_params(struct iwl_priv *priv)
  priv->hw_params.sens = &iwl2000_sensitivity;
 }
 
-struct iwl_lib_ops iwl2000_lib = {
+const struct iwl_dvm_cfg iwl_dvm_2000_cfg = {
  .set_hw_params = iwl2000_hw_set_hw_params,
  .nic_config = iwl2000_nic_config,
  .temperature = iwlagn_temperature,
+ .adv_thermal_throttle = true,
+ .support_ct_kill_exit = true,
+ .plcp_delta_threshold = IWL_MAX_PLCP_ERR_THRESHOLD_DEF,
+ .chain_noise_scale = 1000,
+ .hd_v2 = true,
+ .need_temp_offset_calib = true,
+ .temp_offset_v2 = true,
 };
 
-struct iwl_lib_ops iwl2030_lib = {
+const struct iwl_dvm_cfg iwl_dvm_105_cfg = {
  .set_hw_params = iwl2000_hw_set_hw_params,
  .nic_config = iwl2000_nic_config,
  .temperature = iwlagn_temperature,
+ .adv_thermal_throttle = true,
+ .support_ct_kill_exit = true,
+ .plcp_delta_threshold = IWL_MAX_PLCP_ERR_THRESHOLD_DEF,
+ .chain_noise_scale = 1000,
+ .hd_v2 = true,
+ .need_temp_offset_calib = true,
+ .temp_offset_v2 = true,
+ .adv_pm = true,
+};
+
+static const struct iwl_dvm_bt_params iwl2030_bt_params = {
+ /* Due to bluetooth, we transmit 2.4 GHz probes only on antenna A */
+ .advanced_bt_coexist = true,
+ .agg_time_limit = BT_AGG_THRESHOLD_DEF,
+ .bt_init_traffic_load = IWL_BT_COEX_TRAFFIC_LOAD_NONE,
+ .bt_prio_boost = IWLAGN_BT_PRIO_BOOST_DEFAULT32,
+ .bt_sco_disable = true,
+ .bt_session_2 = true,
+};
+
+const struct iwl_dvm_cfg iwl_dvm_2030_cfg = {
+ .set_hw_params = iwl2000_hw_set_hw_params,
+ .nic_config = iwl2000_nic_config,
+ .temperature = iwlagn_temperature,
+ .adv_thermal_throttle = true,
+ .support_ct_kill_exit = true,
+ .plcp_delta_threshold = IWL_MAX_PLCP_ERR_THRESHOLD_DEF,
+ .chain_noise_scale = 1000,
+ .hd_v2 = true,
+ .bt_params = &iwl2030_bt_params,
+ .need_temp_offset_calib = true,
+ .temp_offset_v2 = true,
+ .adv_pm = true,
 };
 
 /*
@@ -274,7 +317,7 @@ static const struct iwl_sensitivity_ranges iwl5000_sensitivity = {
  .nrg_th_cca = 62,
 };
 
-static struct iwl_sensitivity_ranges iwl5150_sensitivity = {
+static const struct iwl_sensitivity_ranges iwl5150_sensitivity = {
  .min_nrg_cck = 95,
  .auto_corr_min_ofdm = 90,
  .auto_corr_min_ofdm_mrc = 170,
@@ -374,7 +417,6 @@ static int iwl5000_hw_channel_switch(struct iwl_priv *priv,
  struct iwl_host_cmd hcmd = {
   .id = REPLY_CHANNEL_SWITCH,
   .len = { sizeof(cmd), },
-  .flags = CMD_SYNC,
   .data = { &cmd, },
  };
 
@@ -420,16 +462,23 @@ static int iwl5000_hw_channel_switch(struct iwl_priv *priv,
  return iwl_dvm_send_cmd(priv, &hcmd);
 }
 
-struct iwl_lib_ops iwl5000_lib = {
+const struct iwl_dvm_cfg iwl_dvm_5000_cfg = {
  .set_hw_params = iwl5000_hw_set_hw_params,
  .set_channel_switch = iwl5000_hw_channel_switch,
  .temperature = iwlagn_temperature,
+ .plcp_delta_threshold = IWL_MAX_PLCP_ERR_LONG_THRESHOLD_DEF,
+ .chain_noise_scale = 1000,
+ .no_idle_support = true,
 };
 
-struct iwl_lib_ops iwl5150_lib = {
+const struct iwl_dvm_cfg iwl_dvm_5150_cfg = {
  .set_hw_params = iwl5150_hw_set_hw_params,
  .set_channel_switch = iwl5000_hw_channel_switch,
  .temperature = iwl5150_temperature,
+ .plcp_delta_threshold = IWL_MAX_PLCP_ERR_LONG_THRESHOLD_DEF,
+ .chain_noise_scale = 1000,
+ .no_idle_support = true,
+ .no_xtal_calib = true,
 };
 
 
@@ -529,7 +578,6 @@ static int iwl6000_hw_channel_switch(struct iwl_priv *priv,
  struct iwl_host_cmd hcmd = {
   .id = REPLY_CHANNEL_SWITCH,
   .len = { sizeof(*cmd), },
-  .flags = CMD_SYNC,
   .dataflags[0] = IWL_HCMD_DFL_NOCOPY,
  };
  int err;
@@ -584,16 +632,59 @@ static int iwl6000_hw_channel_switch(struct iwl_priv *priv,
  return err;
 }
 
-struct iwl_lib_ops iwl6000_lib = {
+const struct iwl_dvm_cfg iwl_dvm_6000_cfg = {
  .set_hw_params = iwl6000_hw_set_hw_params,
  .set_channel_switch = iwl6000_hw_channel_switch,
  .nic_config = iwl6000_nic_config,
  .temperature = iwlagn_temperature,
+ .adv_thermal_throttle = true,
+ .support_ct_kill_exit = true,
+ .plcp_delta_threshold = IWL_MAX_PLCP_ERR_THRESHOLD_DEF,
+ .chain_noise_scale = 1000,
+};
+
+const struct iwl_dvm_cfg iwl_dvm_6005_cfg = {
+ .set_hw_params = iwl6000_hw_set_hw_params,
+ .set_channel_switch = iwl6000_hw_channel_switch,
+ .nic_config = iwl6000_nic_config,
+ .temperature = iwlagn_temperature,
+ .adv_thermal_throttle = true,
+ .support_ct_kill_exit = true,
+ .plcp_delta_threshold = IWL_MAX_PLCP_ERR_THRESHOLD_DEF,
+ .chain_noise_scale = 1000,
+ .need_temp_offset_calib = true,
+};
+
+const struct iwl_dvm_cfg iwl_dvm_6050_cfg = {
+ .set_hw_params = iwl6000_hw_set_hw_params,
+ .set_channel_switch = iwl6000_hw_channel_switch,
+ .nic_config = iwl6000_nic_config,
+ .temperature = iwlagn_temperature,
+ .adv_thermal_throttle = true,
+ .support_ct_kill_exit = true,
+ .plcp_delta_threshold = IWL_MAX_PLCP_ERR_THRESHOLD_DEF,
+ .chain_noise_scale = 1500,
+};
+
+static const struct iwl_dvm_bt_params iwl6000_bt_params = {
+ /* Due to bluetooth, we transmit 2.4 GHz probes only on antenna A */
+ .advanced_bt_coexist = true,
+ .agg_time_limit = BT_AGG_THRESHOLD_DEF,
+ .bt_init_traffic_load = IWL_BT_COEX_TRAFFIC_LOAD_NONE,
+ .bt_prio_boost = IWLAGN_BT_PRIO_BOOST_DEFAULT,
+ .bt_sco_disable = true,
 };
 
-struct iwl_lib_ops iwl6030_lib = {
+const struct iwl_dvm_cfg iwl_dvm_6030_cfg = {
  .set_hw_params = iwl6000_hw_set_hw_params,
  .set_channel_switch = iwl6000_hw_channel_switch,
  .nic_config = iwl6000_nic_config,
  .temperature = iwlagn_temperature,
+ .adv_thermal_throttle = true,
+ .support_ct_kill_exit = true,
+ .plcp_delta_threshold = IWL_MAX_PLCP_ERR_THRESHOLD_DEF,
+ .chain_noise_scale = 1000,
+ .bt_params = &iwl6000_bt_params,
+ .need_temp_offset_calib = true,
+ .adv_pm = true,
 };
diff --git a/drivers/net/wireless/iwlwifi/dvm/led.c b/drivers/net/wireless/iwlwifi/dvm/led.c
index 33c7e15..ca4d669 100644
--- a/drivers/net/wireless/iwlwifi/dvm/led.c
+++ b/drivers/net/wireless/iwlwifi/dvm/led.c
@@ -1,6 +1,6 @@
 /******************************************************************************
  *
- * Copyright(c) 2003 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2003 - 2014 Intel Corporation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
@@ -27,7 +27,6 @@
 
 #include <linux/kernel.h>
 #include <linux/module.h>
-#include <linux/init.h>
 #include <linux/delay.h>
 #include <linux/skbuff.h>
 #include <linux/netdevice.h>
diff --git a/drivers/net/wireless/iwlwifi/dvm/led.h b/drivers/net/wireless/iwlwifi/dvm/led.h
index 8749dcf..1c6b225 100644
--- a/drivers/net/wireless/iwlwifi/dvm/led.h
+++ b/drivers/net/wireless/iwlwifi/dvm/led.h
@@ -1,6 +1,6 @@
 /******************************************************************************
  *
- * Copyright(c) 2003 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2003 - 2014 Intel Corporation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
@@ -36,8 +36,20 @@ struct iwl_priv;
 #define IWL_LED_ACTIVITY       (0<<1)
 #define IWL_LED_LINK           (1<<1)
 
+#ifdef CONFIG_IWLWIFI_LEDS
 void iwlagn_led_enable(struct iwl_priv *priv);
 void iwl_leds_init(struct iwl_priv *priv);
 void iwl_leds_exit(struct iwl_priv *priv);
+#else
+static inline void iwlagn_led_enable(struct iwl_priv *priv)
+{
+}
+static inline void iwl_leds_init(struct iwl_priv *priv)
+{
+}
+static inline void iwl_leds_exit(struct iwl_priv *priv)
+{
+}
+#endif
 
 #endif /* __iwl_leds_h__ */
diff --git a/drivers/net/wireless/iwlwifi/dvm/lib.c b/drivers/net/wireless/iwlwifi/dvm/lib.c
index 54f5533..2191621 100644
--- a/drivers/net/wireless/iwlwifi/dvm/lib.c
+++ b/drivers/net/wireless/iwlwifi/dvm/lib.c
@@ -2,7 +2,7 @@
  *
  * GPL LICENSE SUMMARY
  *
- * Copyright(c) 2008 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2008 - 2014 Intel Corporation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of version 2 of the GNU General Public License as
@@ -29,7 +29,6 @@
 #include <linux/etherdevice.h>
 #include <linux/kernel.h>
 #include <linux/module.h>
-#include <linux/init.h>
 #include <linux/sched.h>
 #include <net/mac80211.h>
 
@@ -82,7 +81,7 @@ int iwlagn_send_tx_power(struct iwl_priv *priv)
  else
   tx_ant_cfg_cmd = REPLY_TX_POWER_DBM_CMD;
 
- return iwl_dvm_send_cmd_pdu(priv, tx_ant_cfg_cmd, CMD_SYNC,
+ return iwl_dvm_send_cmd_pdu(priv, tx_ant_cfg_cmd, 0,
    sizeof(tx_power_cmd), &tx_power_cmd);
 }
 
@@ -142,7 +141,6 @@ int iwlagn_txfifo_flush(struct iwl_priv *priv, u32 scd_q_msk)
  struct iwl_host_cmd cmd = {
   .id = REPLY_TXFIFO_FLUSH,
   .len = { sizeof(struct iwl_txfifo_flush_cmd), },
-  .flags = CMD_SYNC,
   .data = { &flush_cmd, },
  };
 
@@ -181,7 +179,7 @@ void iwlagn_dev_txfifo_flush(struct iwl_priv *priv)
   goto done;
  }
  IWL_DEBUG_INFO(priv, "wait transmit/flush all frames\n");
- iwl_trans_wait_tx_queue_empty(priv->trans);
+ iwl_trans_wait_tx_queue_empty(priv->trans, 0xffffffff);
 done:
  ieee80211_wake_queues(priv->hw);
  mutex_unlock(&priv->mutex);
@@ -254,23 +252,23 @@ void iwlagn_send_advance_bt_config(struct iwl_priv *priv)
  BUILD_BUG_ON(sizeof(iwlagn_def_3w_lookup) !=
    sizeof(basic.bt3_lookup_table));
 
- if (priv->cfg->bt_params) {
+ if (priv->lib->bt_params) {
   /*
    * newer generation of devices (2000 series and newer)
    * use the version 2 of the bt command
    * we need to make sure sending the host command
    * with correct data structure to avoid uCode assert
    */
-  if (priv->cfg->bt_params->bt_session_2) {
+  if (priv->lib->bt_params->bt_session_2) {
    bt_cmd_v2.prio_boost = cpu_to_le32(
-    priv->cfg->bt_params->bt_prio_boost);
+    priv->lib->bt_params->bt_prio_boost);
    bt_cmd_v2.tx_prio_boost = 0;
    bt_cmd_v2.rx_prio_boost = 0;
   } else {
    /* older version only has 8 bits */
-   WARN_ON(priv->cfg->bt_params->bt_prio_boost & ~0xFF);
+   WARN_ON(priv->lib->bt_params->bt_prio_boost & ~0xFF);
    bt_cmd_v1.prio_boost =
-    priv->cfg->bt_params->bt_prio_boost;
+    priv->lib->bt_params->bt_prio_boost;
    bt_cmd_v1.tx_prio_boost = 0;
    bt_cmd_v1.rx_prio_boost = 0;
   }
@@ -330,16 +328,16 @@ void iwlagn_send_advance_bt_config(struct iwl_priv *priv)
          priv->bt_full_concurrent ?
          "full concurrency" : "3-wire");
 
- if (priv->cfg->bt_params->bt_session_2) {
+ if (priv->lib->bt_params->bt_session_2) {
   memcpy(&bt_cmd_v2.basic, &basic,
    sizeof(basic));
   ret = iwl_dvm_send_cmd_pdu(priv, REPLY_BT_CONFIG,
-   CMD_SYNC, sizeof(bt_cmd_v2), &bt_cmd_v2);
+   0, sizeof(bt_cmd_v2), &bt_cmd_v2);
  } else {
   memcpy(&bt_cmd_v1.basic, &basic,
    sizeof(basic));
   ret = iwl_dvm_send_cmd_pdu(priv, REPLY_BT_CONFIG,
-   CMD_SYNC, sizeof(bt_cmd_v1), &bt_cmd_v1);
+   0, sizeof(bt_cmd_v1), &bt_cmd_v1);
  }
  if (ret)
   IWL_ERR(priv, "failed to send BT Coex Config\n");
@@ -758,8 +756,8 @@ static bool is_single_rx_stream(struct iwl_priv *priv)
  */
 static int iwl_get_active_rx_chain_count(struct iwl_priv *priv)
 {
- if (priv->cfg->bt_params &&
-     priv->cfg->bt_params->advanced_bt_coexist &&
+ if (priv->lib->bt_params &&
+     priv->lib->bt_params->advanced_bt_coexist &&
      (priv->bt_full_concurrent ||
       priv->bt_traffic_load >= IWL_BT_COEX_TRAFFIC_LOAD_HIGH)) {
   /*
@@ -830,8 +828,8 @@ void iwlagn_set_rxon_chain(struct iwl_priv *priv, struct iwl_rxon_context *ctx)
  else
   active_chains = priv->nvm_data->valid_rx_ant;
 
- if (priv->cfg->bt_params &&
-     priv->cfg->bt_params->advanced_bt_coexist &&
+ if (priv->lib->bt_params &&
+     priv->lib->bt_params->advanced_bt_coexist &&
      (priv->bt_full_concurrent ||
       priv->bt_traffic_load >= IWL_BT_COEX_TRAFFIC_LOAD_HIGH)) {
   /*
@@ -1045,7 +1043,6 @@ int iwlagn_send_patterns(struct iwl_priv *priv,
  struct iwl_host_cmd cmd = {
   .id = REPLY_WOWLAN_PATTERNS,
   .dataflags[0] = IWL_HCMD_DFL_NOCOPY,
-  .flags = CMD_SYNC,
  };
  int i, err;
 
@@ -1202,7 +1199,6 @@ int iwlagn_suspend(struct iwl_priv *priv, struct cfg80211_wowlan *wowlan)
   if (key_data.use_rsc_tsc) {
    struct iwl_host_cmd rsc_tsc_cmd = {
     .id = REPLY_WOWLAN_TSC_RSC_PARAMS,
-    .flags = CMD_SYNC,
     .data[0] = key_data.rsc_tsc,
     .dataflags[0] = IWL_HCMD_DFL_NOCOPY,
     .len[0] = sizeof(*key_data.rsc_tsc),
@@ -1216,7 +1212,7 @@ int iwlagn_suspend(struct iwl_priv *priv, struct cfg80211_wowlan *wowlan)
   if (key_data.use_tkip) {
    ret = iwl_dvm_send_cmd_pdu(priv,
        REPLY_WOWLAN_TKIP_PARAMS,
-       CMD_SYNC, sizeof(tkip_cmd),
+       0, sizeof(tkip_cmd),
        &tkip_cmd);
    if (ret)
     goto out;
@@ -1232,20 +1228,20 @@ int iwlagn_suspend(struct iwl_priv *priv, struct cfg80211_wowlan *wowlan)
 
    ret = iwl_dvm_send_cmd_pdu(priv,
        REPLY_WOWLAN_KEK_KCK_MATERIAL,
-       CMD_SYNC, sizeof(kek_kck_cmd),
+       0, sizeof(kek_kck_cmd),
        &kek_kck_cmd);
    if (ret)
     goto out;
   }
  }
 
- ret = iwl_dvm_send_cmd_pdu(priv, REPLY_D3_CONFIG, CMD_SYNC,
+ ret = iwl_dvm_send_cmd_pdu(priv, REPLY_D3_CONFIG, 0,
          sizeof(d3_cfg_cmd), &d3_cfg_cmd);
  if (ret)
   goto out;
 
  ret = iwl_dvm_send_cmd_pdu(priv, REPLY_WOWLAN_WAKEUP_FILTER,
-     CMD_SYNC, sizeof(wakeup_filter_cmd),
+     0, sizeof(wakeup_filter_cmd),
      &wakeup_filter_cmd);
  if (ret)
   goto out;
@@ -1288,12 +1284,6 @@ int iwl_dvm_send_cmd(struct iwl_priv *priv, struct iwl_host_cmd *cmd)
  if (!(cmd->flags & CMD_ASYNC))
   lockdep_assert_held(&priv->mutex);
 
- if (priv->ucode_owner == IWL_OWNERSHIP_TM &&
-     !(cmd->flags & CMD_ON_DEMAND)) {
-  IWL_DEBUG_HC(priv, "tm own the uCode, no regular hcmd send\n");
-  return -EIO;
- }
-
  return iwl_trans_send_cmd(priv->trans, cmd);
 }
 
diff --git a/drivers/net/wireless/iwlwifi/dvm/mac80211.c b/drivers/net/wireless/iwlwifi/dvm/mac80211.c
index e04f3da..29af7b5 100644
--- a/drivers/net/wireless/iwlwifi/dvm/mac80211.c
+++ b/drivers/net/wireless/iwlwifi/dvm/mac80211.c
@@ -1,6 +1,6 @@
 /******************************************************************************
  *
- * Copyright(c) 2003 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2003 - 2014 Intel Corporation. All rights reserved.
  *
  * Portions of this file are derived from the ipw3945 project, as well
  * as portions of the ieee80211 subsystem header files.
@@ -28,7 +28,6 @@
  *****************************************************************************/
 #include <linux/kernel.h>
 #include <linux/module.h>
-#include <linux/init.h>
 #include <linux/slab.h>
 #include <linux/dma-mapping.h>
 #include <linux/delay.h>
@@ -76,29 +75,6 @@ static const struct ieee80211_iface_limit iwlagn_2sta_limits[] = {
  },
 };
 
-static const struct ieee80211_iface_limit iwlagn_p2p_sta_go_limits[] = {
- {
-  .max = 1,
-  .types = BIT(NL80211_IFTYPE_STATION),
- },
- {
-  .max = 1,
-  .types = BIT(NL80211_IFTYPE_P2P_GO) |
-    BIT(NL80211_IFTYPE_AP),
- },
-};
-
-static const struct ieee80211_iface_limit iwlagn_p2p_2sta_limits[] = {
- {
-  .max = 2,
-  .types = BIT(NL80211_IFTYPE_STATION),
- },
- {
-  .max = 1,
-  .types = BIT(NL80211_IFTYPE_P2P_CLIENT),
- },
-};
-
 static const struct ieee80211_iface_combination
 iwlagn_iface_combinations_dualmode[] = {
  { .num_different_channels = 1,
@@ -114,21 +90,6 @@ iwlagn_iface_combinations_dualmode[] = {
  },
 };
 
-static const struct ieee80211_iface_combination
-iwlagn_iface_combinations_p2p[] = {
- { .num_different_channels = 1,
-   .max_interfaces = 2,
-   .beacon_int_infra_match = true,
-   .limits = iwlagn_p2p_sta_go_limits,
-   .n_limits = ARRAY_SIZE(iwlagn_p2p_sta_go_limits),
- },
- { .num_different_channels = 1,
-   .max_interfaces = 2,
-   .limits = iwlagn_p2p_2sta_limits,
-   .n_limits = ARRAY_SIZE(iwlagn_p2p_2sta_limits),
- },
-};
-
 /*
  * Not a mac80211 entry point function, but it fits in with all the
  * other mac80211 functions grouped here.
@@ -186,42 +147,37 @@ int iwlagn_mac_setup_register(struct iwl_priv *priv,
 
  BUILD_BUG_ON(NUM_IWL_RXON_CTX != 2);
 
- if (hw->wiphy->interface_modes & BIT(NL80211_IFTYPE_P2P_CLIENT)) {
-  hw->wiphy->iface_combinations = iwlagn_iface_combinations_p2p;
-  hw->wiphy->n_iface_combinations =
-   ARRAY_SIZE(iwlagn_iface_combinations_p2p);
- } else if (hw->wiphy->interface_modes & BIT(NL80211_IFTYPE_AP)) {
+ if (hw->wiphy->interface_modes & BIT(NL80211_IFTYPE_AP)) {
   hw->wiphy->iface_combinations =
    iwlagn_iface_combinations_dualmode;
   hw->wiphy->n_iface_combinations =
    ARRAY_SIZE(iwlagn_iface_combinations_dualmode);
  }
 
- hw->wiphy->max_remain_on_channel_duration = 500;
-
- hw->wiphy->flags |= WIPHY_FLAG_CUSTOM_REGULATORY |
-       WIPHY_FLAG_DISABLE_BEACON_HINTS |
-       WIPHY_FLAG_IBSS_RSN;
+ hw->wiphy->flags |= WIPHY_FLAG_IBSS_RSN;
+ hw->wiphy->regulatory_flags |= REGULATORY_CUSTOM_REG |
+           REGULATORY_DISABLE_BEACON_HINTS;
 
 #ifdef CONFIG_PM_SLEEP
  if (priv->fw->img[IWL_UCODE_WOWLAN].sec[0].len &&
      priv->trans->ops->d3_suspend &&
      priv->trans->ops->d3_resume &&
      device_can_wakeup(priv->trans->dev)) {
-  hw->wiphy->wowlan.flags = WIPHY_WOWLAN_MAGIC_PKT |
-       WIPHY_WOWLAN_DISCONNECT |
-       WIPHY_WOWLAN_EAP_IDENTITY_REQ |
-       WIPHY_WOWLAN_RFKILL_RELEASE;
+  priv->wowlan_support.flags = WIPHY_WOWLAN_MAGIC_PKT |
+          WIPHY_WOWLAN_DISCONNECT |
+          WIPHY_WOWLAN_EAP_IDENTITY_REQ |
+          WIPHY_WOWLAN_RFKILL_RELEASE;
   if (!iwlwifi_mod_params.sw_crypto)
-   hw->wiphy->wowlan.flags |=
+   priv->wowlan_support.flags |=
     WIPHY_WOWLAN_SUPPORTS_GTK_REKEY |
     WIPHY_WOWLAN_GTK_REKEY_FAILURE;
 
-  hw->wiphy->wowlan.n_patterns = IWLAGN_WOWLAN_MAX_PATTERNS;
-  hw->wiphy->wowlan.pattern_min_len =
+  priv->wowlan_support.n_patterns = IWLAGN_WOWLAN_MAX_PATTERNS;
+  priv->wowlan_support.pattern_min_len =
      IWLAGN_WOWLAN_MIN_PATTERN_LEN;
-  hw->wiphy->wowlan.pattern_max_len =
+  priv->wowlan_support.pattern_max_len =
      IWLAGN_WOWLAN_MAX_PATTERN_LEN;
+  hw->wiphy->wowlan = &priv->wowlan_support;
  }
 #endif
 
@@ -365,12 +321,6 @@ static void iwlagn_mac_stop(struct ieee80211_hw *hw)
 
  flush_workqueue(priv->workqueue);
 
- /* User space software may expect getting rfkill changes
-  * even if interface is down, trans->down will leave the RF
-  * kill interrupt enabled
-  */
- iwl_trans_stop_hw(priv->trans, false);
-
  IWL_DEBUG_MAC80211(priv, "leave\n");
 }
 
@@ -426,7 +376,11 @@ static int iwlagn_mac_suspend(struct ieee80211_hw *hw,
  if (ret)
   goto error;
 
- iwl_trans_d3_suspend(priv->trans);
+ /* let the ucode operate on its own */
+ iwl_write32(priv->trans, CSR_UCODE_DRV_GP1_SET,
+      CSR_UCODE_DRV_GP1_BIT_D3_CFG_COMPLETE);
+
+ iwl_trans_d3_suspend(priv->trans, false);
 
  goto out;
 
@@ -452,9 +406,8 @@ static bool iwl_resume_status_fn(struct iwl_notif_wait_data *notif_wait,
 {
  struct iwl_resume_data *resume_data = data;
  struct iwl_priv *priv = resume_data->priv;
- u32 len = le32_to_cpu(pkt->len_n_flags) & FH_RSCSR_FRAME_SIZE_MSK;
 
- if (len - 4 != sizeof(*resume_data->cmd)) {
+ if (iwl_rx_packet_payload_len(pkt) != sizeof(*resume_data->cmd)) {
   IWL_ERR(priv, "rx wrong size data\n");
   return true;
  }
@@ -500,7 +453,7 @@ static int iwlagn_mac_resume(struct ieee80211_hw *hw)
  /* we'll clear ctx->vif during iwlagn_prepare_restart() */
  vif = ctx->vif;
 
- ret = iwl_trans_d3_resume(priv->trans, &d3_status);
+ ret = iwl_trans_d3_resume(priv->trans, &d3_status, false);
  if (ret)
   goto out_unlock;
 
@@ -509,6 +462,10 @@ static int iwlagn_mac_resume(struct ieee80211_hw *hw)
   goto out_unlock;
  }
 
+ /* uCode is no longer operating by itself */
+ iwl_write32(priv->trans, CSR_UCODE_DRV_GP1_CLR,
+      CSR_UCODE_DRV_GP1_BIT_D3_CFG_COMPLETE);
+
  base = priv->device_pointers.error_event_table;
  if (!iwlagn_hw_valid_rtc_data_addr(base)) {
   IWL_WARN(priv, "Invalid error table during resume!\n");
@@ -739,6 +696,24 @@ static int iwlagn_mac_set_key(struct ieee80211_hw *hw, enum set_key_cmd cmd,
  return ret;
 }
 
+static inline bool iwl_enable_rx_ampdu(const struct iwl_cfg *cfg)
+{
+ if (iwlwifi_mod_params.disable_11n & IWL_DISABLE_HT_RXAGG)
+  return false;
+ return true;
+}
+
+static inline bool iwl_enable_tx_ampdu(const struct iwl_cfg *cfg)
+{
+ if (iwlwifi_mod_params.disable_11n & IWL_DISABLE_HT_TXAGG)
+  return false;
+ if (iwlwifi_mod_params.disable_11n & IWL_ENABLE_HT_TXAGG)
+  return true;
+
+ /* disabled by default */
+ return false;
+}
+
 static int iwlagn_mac_ampdu_action(struct ieee80211_hw *hw,
        struct ieee80211_vif *vif,
        enum ieee80211_ampdu_mlme_action action,
@@ -760,7 +735,7 @@ static int iwlagn_mac_ampdu_action(struct ieee80211_hw *hw,
 
  switch (action) {
  case IEEE80211_AMPDU_RX_START:
-  if (iwlwifi_mod_params.disable_11n & IWL_DISABLE_HT_RXAGG)
+  if (!iwl_enable_rx_ampdu(priv->cfg))
    break;
   IWL_DEBUG_HT(priv, "start Rx\n");
   ret = iwl_sta_rx_agg_start(priv, sta, tid, *ssn);
@@ -772,7 +747,7 @@ static int iwlagn_mac_ampdu_action(struct ieee80211_hw *hw,
  case IEEE80211_AMPDU_TX_START:
   if (!priv->trans->ops->txq_enable)
    break;
-  if (iwlwifi_mod_params.disable_11n & IWL_DISABLE_HT_TXAGG)
+  if (!iwl_enable_tx_ampdu(priv->cfg))
    break;
   IWL_DEBUG_HT(priv, "start Tx\n");
   ret = iwlagn_tx_agg_start(priv, vif, sta, tid, ssn);
@@ -1116,7 +1091,8 @@ static void iwlagn_configure_filter(struct ieee80211_hw *hw,
    FIF_BCN_PRBRESP_PROMISC | FIF_CONTROL;
 }
 
-static void iwlagn_mac_flush(struct ieee80211_hw *hw, u32 queues, bool drop)
+static void iwlagn_mac_flush(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
+        u32 queues, bool drop)
 {
  struct iwl_priv *priv = IWL_MAC80211_GET_DVM(hw);
 
@@ -1144,132 +1120,12 @@ static void iwlagn_mac_flush(struct ieee80211_hw *hw, u32 queues, bool drop)
   }
  }
  IWL_DEBUG_MAC80211(priv, "wait transmit/flush all frames\n");
- iwl_trans_wait_tx_queue_empty(priv->trans);
+ iwl_trans_wait_tx_queue_empty(priv->trans, 0xffffffff);
 done:
  mutex_unlock(&priv->mutex);
  IWL_DEBUG_MAC80211(priv, "leave\n");
 }
 
-static int iwlagn_mac_remain_on_channel(struct ieee80211_hw *hw,
-         struct ieee80211_vif *vif,
-         struct ieee80211_channel *channel,
-         int duration,
-         enum ieee80211_roc_type type)
-{
- struct iwl_priv *priv = IWL_MAC80211_GET_DVM(hw);
- struct iwl_rxon_context *ctx = &priv->contexts[IWL_RXON_CTX_PAN];
- int err = 0;
-
- if (!(priv->valid_contexts & BIT(IWL_RXON_CTX_PAN)))
-  return -EOPNOTSUPP;
-
- if (!(ctx->interface_modes & BIT(NL80211_IFTYPE_P2P_CLIENT)))
-  return -EOPNOTSUPP;
-
- IWL_DEBUG_MAC80211(priv, "enter\n");
- mutex_lock(&priv->mutex);
-
- if (test_bit(STATUS_SCAN_HW, &priv->status)) {
-  /* mac80211 should not scan while ROC or ROC while scanning */
-  if (WARN_ON_ONCE(priv->scan_type != IWL_SCAN_RADIO_RESET)) {
-   err = -EBUSY;
-   goto out;
-  }
-
-  iwl_scan_cancel_timeout(priv, 100);
-
-  if (test_bit(STATUS_SCAN_HW, &priv->status)) {
-   err = -EBUSY;
-   goto out;
-  }
- }
-
- priv->hw_roc_channel = channel;
- /* convert from ms to TU */
- priv->hw_roc_duration = DIV_ROUND_UP(1000 * duration, 1024);
- priv->hw_roc_start_notified = false;
- cancel_delayed_work(&priv->hw_roc_disable_work);
-
- if (!ctx->is_active) {
-  static const struct iwl_qos_info default_qos_data = {
-   .def_qos_parm = {
-    .ac[0] = {
-     .cw_min = cpu_to_le16(3),
-     .cw_max = cpu_to_le16(7),
-     .aifsn = 2,
-     .edca_txop = cpu_to_le16(1504),
-    },
-    .ac[1] = {
-     .cw_min = cpu_to_le16(7),
-     .cw_max = cpu_to_le16(15),
-     .aifsn = 2,
-     .edca_txop = cpu_to_le16(3008),
-    },
-    .ac[2] = {
-     .cw_min = cpu_to_le16(15),
-     .cw_max = cpu_to_le16(1023),
-     .aifsn = 3,
-    },
-    .ac[3] = {
-     .cw_min = cpu_to_le16(15),
-     .cw_max = cpu_to_le16(1023),
-     .aifsn = 7,
-    },
-   },
-  };
-
-  ctx->is_active = true;
-  ctx->qos_data = default_qos_data;
-  ctx->staging.dev_type = RXON_DEV_TYPE_P2P;
-  memcpy(ctx->staging.node_addr,
-         priv->contexts[IWL_RXON_CTX_BSS].staging.node_addr,
-         ETH_ALEN);
-  memcpy(ctx->staging.bssid_addr,
-         priv->contexts[IWL_RXON_CTX_BSS].staging.node_addr,
-         ETH_ALEN);
-  err = iwlagn_commit_rxon(priv, ctx);
-  if (err)
-   goto out;
-  ctx->staging.filter_flags |= RXON_FILTER_ASSOC_MSK |
-          RXON_FILTER_PROMISC_MSK |
-          RXON_FILTER_CTL2HOST_MSK;
-
-  err = iwlagn_commit_rxon(priv, ctx);
-  if (err) {
-   iwlagn_disable_roc(priv);
-   goto out;
-  }
-  priv->hw_roc_setup = true;
- }
-
- err = iwl_scan_initiate(priv, ctx->vif, IWL_SCAN_ROC, channel->band);
- if (err)
-  iwlagn_disable_roc(priv);
-
- out:
- mutex_unlock(&priv->mutex);
- IWL_DEBUG_MAC80211(priv, "leave\n");
-
- return err;
-}
-
-static int iwlagn_mac_cancel_remain_on_channel(struct ieee80211_hw *hw)
-{
- struct iwl_priv *priv = IWL_MAC80211_GET_DVM(hw);
-
- if (!(priv->valid_contexts & BIT(IWL_RXON_CTX_PAN)))
-  return -EOPNOTSUPP;
-
- IWL_DEBUG_MAC80211(priv, "enter\n");
- mutex_lock(&priv->mutex);
- iwl_scan_cancel_timeout(priv, priv->hw_roc_duration);
- iwlagn_disable_roc(priv);
- mutex_unlock(&priv->mutex);
- IWL_DEBUG_MAC80211(priv, "leave\n");
-
- return 0;
-}
-
 static void iwlagn_mac_rssi_callback(struct ieee80211_hw *hw,
          struct ieee80211_vif *vif,
          enum ieee80211_rssi_event rssi_event)
@@ -1279,8 +1135,8 @@ static void iwlagn_mac_rssi_callback(struct ieee80211_hw *hw,
  IWL_DEBUG_MAC80211(priv, "enter\n");
  mutex_lock(&priv->mutex);
 
- if (priv->cfg->bt_params &&
-   priv->cfg->bt_params->advanced_bt_coexist) {
+ if (priv->lib->bt_params &&
+     priv->lib->bt_params->advanced_bt_coexist) {
   if (rssi_event == RSSI_EVENT_LOW)
    priv->bt_enable_pspoll = true;
   else if (rssi_event == RSSI_EVENT_HIGH)
@@ -1390,7 +1246,7 @@ static int iwl_setup_interface(struct iwl_priv *priv,
   return err;
  }
 
- if (priv->cfg->bt_params && priv->cfg->bt_params->advanced_bt_coexist &&
+ if (priv->lib->bt_params && priv->lib->bt_params->advanced_bt_coexist &&
      vif->type == NL80211_IFTYPE_ADHOC) {
   /*
    * pretend to have high BT traffic as long as we
@@ -1425,12 +1281,8 @@ static int iwlagn_mac_add_interface(struct ieee80211_hw *hw,
  IWL_DEBUG_MAC80211(priv, "enter: type %d, addr %pM\n",
       viftype, vif->addr);
 
- cancel_delayed_work_sync(&priv->hw_roc_disable_work);
-
  mutex_lock(&priv->mutex);
 
- iwlagn_disable_roc(priv);
-
  if (!iwl_is_ready_rf(priv)) {
   IWL_WARN(priv, "Try to add interface when device not ready\n");
   err = -EINVAL;
@@ -1731,7 +1583,7 @@ static void iwlagn_mac_sta_notify(struct ieee80211_hw *hw,
  IWL_DEBUG_MAC80211(priv, "leave\n");
 }
 
-struct ieee80211_ops iwlagn_hw_ops = {
+const struct ieee80211_ops iwlagn_hw_ops = {
  .tx = iwlagn_mac_tx,
  .start = iwlagn_mac_start,
  .stop = iwlagn_mac_stop,
@@ -1757,11 +1609,7 @@ struct ieee80211_ops iwlagn_hw_ops = {
  .channel_switch = iwlagn_mac_channel_switch,
  .flush = iwlagn_mac_flush,
  .tx_last_beacon = iwlagn_mac_tx_last_beacon,
- .remain_on_channel = iwlagn_mac_remain_on_channel,
- .cancel_remain_on_channel = iwlagn_mac_cancel_remain_on_channel,
  .rssi_callback = iwlagn_mac_rssi_callback,
- CFG80211_TESTMODE_CMD(iwlagn_mac_testmode_cmd)
- CFG80211_TESTMODE_DUMP(iwlagn_mac_testmode_dump)
  .set_tim = iwlagn_mac_set_tim,
 };
 
diff --git a/drivers/net/wireless/iwlwifi/dvm/main.c b/drivers/net/wireless/iwlwifi/dvm/main.c
index a8afc7b..0b7f46f 100644
--- a/drivers/net/wireless/iwlwifi/dvm/main.c
+++ b/drivers/net/wireless/iwlwifi/dvm/main.c
@@ -1,6 +1,6 @@
 /******************************************************************************
  *
- * Copyright(c) 2003 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2003 - 2014 Intel Corporation. All rights reserved.
  *
  * Portions of this file are derived from the ipw3945 project, as well
  * as portions of the ieee80211 subsystem header files.
@@ -128,7 +128,6 @@ int iwlagn_send_beacon_cmd(struct iwl_priv *priv)
  struct iwl_tx_beacon_cmd *tx_beacon_cmd;
  struct iwl_host_cmd cmd = {
   .id = REPLY_TX_BEACON,
-  .flags = CMD_SYNC,
  };
  struct ieee80211_tx_info *info;
  u32 frame_size;
@@ -252,13 +251,17 @@ static void iwl_bg_bt_runtime_config(struct work_struct *work)
  struct iwl_priv *priv =
   container_of(work, struct iwl_priv, bt_runtime_config);
 
+ mutex_lock(&priv->mutex);
  if (test_bit(STATUS_EXIT_PENDING, &priv->status))
-  return;
+  goto out;
 
  /* dont send host command if rf-kill is on */
  if (!iwl_is_ready_rf(priv))
-  return;
+  goto out;
+
  iwlagn_send_advance_bt_config(priv);
+out:
+ mutex_unlock(&priv->mutex);
 }
 
 static void iwl_bg_bt_full_concurrency(struct work_struct *work)
@@ -307,8 +310,7 @@ int iwl_send_statistics_request(struct iwl_priv *priv, u8 flags, bool clear)
      sizeof(struct iwl_statistics_cmd),
      &statistics_cmd);
  else
-  return iwl_dvm_send_cmd_pdu(priv, REPLY_STATISTICS_CMD,
-     CMD_SYNC,
+  return iwl_dvm_send_cmd_pdu(priv, REPLY_STATISTICS_CMD, 0,
      sizeof(struct iwl_statistics_cmd),
      &statistics_cmd);
 }
@@ -587,11 +589,6 @@ static void iwl_init_context(struct iwl_priv *priv, u32 ucode_flags)
  priv->contexts[IWL_RXON_CTX_PAN].interface_modes =
   BIT(NL80211_IFTYPE_STATION) | BIT(NL80211_IFTYPE_AP);
 
- if (ucode_flags & IWL_UCODE_TLV_FLAGS_P2P)
-  priv->contexts[IWL_RXON_CTX_PAN].interface_modes |=
-   BIT(NL80211_IFTYPE_P2P_CLIENT) |
-   BIT(NL80211_IFTYPE_P2P_GO);
-
  priv->contexts[IWL_RXON_CTX_PAN].ap_devtype = RXON_DEV_TYPE_CP;
  priv->contexts[IWL_RXON_CTX_PAN].station_devtype = RXON_DEV_TYPE_2STA;
  priv->contexts[IWL_RXON_CTX_PAN].unused_devtype = RXON_DEV_TYPE_P2P;
@@ -615,7 +612,7 @@ static void iwl_rf_kill_ct_config(struct iwl_priv *priv)
 
  priv->thermal_throttle.ct_kill_toggle = false;
 
- if (priv->cfg->base_params->support_ct_kill_exit) {
+ if (priv->lib->support_ct_kill_exit) {
   adv_cmd.critical_temperature_enter =
    cpu_to_le32(priv->hw_params.ct_kill_threshold);
   adv_cmd.critical_temperature_exit =
@@ -623,7 +620,7 @@ static void iwl_rf_kill_ct_config(struct iwl_priv *priv)
 
   ret = iwl_dvm_send_cmd_pdu(priv,
            REPLY_CT_KILL_CONFIG_CMD,
-           CMD_SYNC, sizeof(adv_cmd), &adv_cmd);
+           0, sizeof(adv_cmd), &adv_cmd);
   if (ret)
    IWL_ERR(priv, "REPLY_CT_KILL_CONFIG_CMD failed\n");
   else
@@ -638,7 +635,7 @@ static void iwl_rf_kill_ct_config(struct iwl_priv *priv)
 
   ret = iwl_dvm_send_cmd_pdu(priv,
            REPLY_CT_KILL_CONFIG_CMD,
-           CMD_SYNC, sizeof(cmd), &cmd);
+           0, sizeof(cmd), &cmd);
   if (ret)
    IWL_ERR(priv, "REPLY_CT_KILL_CONFIG_CMD failed\n");
   else
@@ -674,9 +671,7 @@ static int iwlagn_send_tx_ant_config(struct iwl_priv *priv, u8 valid_tx_ant)
 
  if (IWL_UCODE_API(priv->fw->ucode_ver) > 1) {
   IWL_DEBUG_HC(priv, "select valid tx ant: %u\n", valid_tx_ant);
-  return iwl_dvm_send_cmd_pdu(priv,
-     TX_ANT_CONFIGURATION_CMD,
-     CMD_SYNC,
+  return iwl_dvm_send_cmd_pdu(priv, TX_ANT_CONFIGURATION_CMD, 0,
      sizeof(struct iwl_tx_ant_config_cmd),
      &tx_ant_cmd);
  } else {
@@ -704,7 +699,7 @@ static void iwl_send_bt_config(struct iwl_priv *priv)
   (bt_cmd.flags == BT_COEX_DISABLE) ? "disable" : "active");
 
  if (iwl_dvm_send_cmd_pdu(priv, REPLY_BT_CONFIG,
-        CMD_SYNC, sizeof(struct iwl_bt_cmd), &bt_cmd))
+        0, sizeof(struct iwl_bt_cmd), &bt_cmd))
   IWL_ERR(priv, "failed to send BT Coex Config\n");
 }
 
@@ -732,10 +727,10 @@ int iwl_alive_start(struct iwl_priv *priv)
  }
 
  /* download priority table before any calibration request */
- if (priv->cfg->bt_params &&
-     priv->cfg->bt_params->advanced_bt_coexist) {
+ if (priv->lib->bt_params &&
+     priv->lib->bt_params->advanced_bt_coexist) {
   /* Configure Bluetooth device coexistence support */
-  if (priv->cfg->bt_params->bt_sco_disable)
+  if (priv->lib->bt_params->bt_sco_disable)
    priv->bt_enable_pspoll = false;
   else
    priv->bt_enable_pspoll = true;
@@ -758,7 +753,7 @@ int iwl_alive_start(struct iwl_priv *priv)
       BT_COEX_PRIO_TBL_EVT_INIT_CALIB2);
   if (ret)
    return ret;
- } else if (priv->cfg->bt_params) {
+ } else if (priv->lib->bt_params) {
   /*
    * default is 2-wire BT coexexistence support
    */
@@ -854,14 +849,6 @@ void iwl_down(struct iwl_priv *priv)
 
  iwl_scan_cancel_timeout(priv, 200);
 
- /*
-  * If active, scanning won't cancel it, so say it expired.
-  * No race since we hold the mutex here and a new one
-  * can't come in at this time.
-  */
- if (priv->ucode_loaded && priv->cur_ucode != IWL_UCODE_INIT)
-  ieee80211_remain_on_channel_expired(priv->hw);
-
  exit_pending =
   test_and_set_bit(STATUS_EXIT_PENDING, &priv->status);
 
@@ -873,9 +860,9 @@ void iwl_down(struct iwl_priv *priv)
  priv->bt_status = 0;
  priv->cur_rssi_ctx = NULL;
  priv->bt_is_sco = 0;
- if (priv->cfg->bt_params)
+ if (priv->lib->bt_params)
   priv->bt_traffic_load =
-    priv->cfg->bt_params->bt_init_traffic_load;
+    priv->lib->bt_params->bt_init_traffic_load;
  else
   priv->bt_traffic_load = 0;
  priv->bt_full_concurrent = false;
@@ -996,47 +983,12 @@ static void iwl_bg_restart(struct work_struct *data)
    ieee80211_restart_hw(priv->hw);
   else
    IWL_ERR(priv,
-    "Cannot request restart before registrating with mac80211");
+    "Cannot request restart before registrating with mac80211\n");
  } else {
   WARN_ON(1);
  }
 }
 
-
-
-
-void iwlagn_disable_roc(struct iwl_priv *priv)
-{
- struct iwl_rxon_context *ctx = &priv->contexts[IWL_RXON_CTX_PAN];
-
- lockdep_assert_held(&priv->mutex);
-
- if (!priv->hw_roc_setup)
-  return;
-
- ctx->staging.dev_type = RXON_DEV_TYPE_P2P;
- ctx->staging.filter_flags &= ~RXON_FILTER_ASSOC_MSK;
-
- priv->hw_roc_channel = NULL;
-
- memset(ctx->staging.node_addr, 0, ETH_ALEN);
-
- iwlagn_commit_rxon(priv, ctx);
-
- ctx->is_active = false;
- priv->hw_roc_setup = false;
-}
-
-static void iwlagn_disable_roc_work(struct work_struct *work)
-{
- struct iwl_priv *priv = container_of(work, struct iwl_priv,
-          hw_roc_disable_work.work);
-
- mutex_lock(&priv->mutex);
- iwlagn_disable_roc(priv);
- mutex_unlock(&priv->mutex);
-}
-
 /*****************************************************************************
  *
  * driver setup and teardown
@@ -1053,12 +1005,10 @@ static void iwl_setup_deferred_work(struct iwl_priv *priv)
  INIT_WORK(&priv->tx_flush, iwl_bg_tx_flush);
  INIT_WORK(&priv->bt_full_concurrency, iwl_bg_bt_full_concurrency);
  INIT_WORK(&priv->bt_runtime_config, iwl_bg_bt_runtime_config);
- INIT_DELAYED_WORK(&priv->hw_roc_disable_work,
-     iwlagn_disable_roc_work);
 
  iwl_setup_scan_deferred_work(priv);
 
- if (priv->cfg->bt_params)
+ if (priv->lib->bt_params)
   iwlagn_bt_setup_deferred_work(priv);
 
  init_timer(&priv->statistics_periodic);
@@ -1072,7 +1022,7 @@ static void iwl_setup_deferred_work(struct iwl_priv *priv)
 
 void iwl_cancel_deferred_work(struct iwl_priv *priv)
 {
- if (priv->cfg->bt_params)
+ if (priv->lib->bt_params)
   iwlagn_bt_cancel_deferred_work(priv);
 
  cancel_work_sync(&priv->run_time_calib_work);
@@ -1082,7 +1032,6 @@ void iwl_cancel_deferred_work(struct iwl_priv *priv)
 
  cancel_work_sync(&priv->bt_full_concurrency);
  cancel_work_sync(&priv->bt_runtime_config);
- cancel_delayed_work_sync(&priv->hw_roc_disable_work);
 
  del_timer_sync(&priv->statistics_periodic);
  del_timer_sync(&priv->ucode_trace);
@@ -1098,16 +1047,13 @@ static int iwl_init_drv(struct iwl_priv *priv)
 
  priv->band = IEEE80211_BAND_2GHZ;
 
- priv->plcp_delta_threshold =
-  priv->cfg->base_params->plcp_delta_threshold;
+ priv->plcp_delta_threshold = priv->lib->plcp_delta_threshold;
 
  priv->iw_mode = NL80211_IFTYPE_STATION;
  priv->current_ht_config.smps = IEEE80211_SMPS_STATIC;
  priv->missed_beacon_threshold = IWL_MISSED_BEACON_THRESHOLD_DEF;
  priv->agg_tids_count = 0;
 
- priv->ucode_owner = IWL_OWNERSHIP_DRIVER;
-
  priv->rx_statistics_jiffies = jiffies;
 
  /* Choose which receivers/antennas to use */
@@ -1116,8 +1062,8 @@ static int iwl_init_drv(struct iwl_priv *priv)
  iwl_init_scan_params(priv);
 
  /* init bt coex */
- if (priv->cfg->bt_params &&
-     priv->cfg->bt_params->advanced_bt_coexist) {
+ if (priv->lib->bt_params &&
+     priv->lib->bt_params->advanced_bt_coexist) {
   priv->kill_ack_mask = IWLAGN_BT_KILL_ACK_MASK_DEFAULT;
   priv->kill_cts_mask = IWLAGN_BT_KILL_CTS_MASK_DEFAULT;
   priv->bt_valid = IWLAGN_BT_ALL_VALID_MSK;
@@ -1172,24 +1118,11 @@ static void iwl_option_config(struct iwl_priv *priv)
 #else
  IWL_INFO(priv, "CONFIG_IWLWIFI_DEVICE_TRACING disabled\n");
 #endif
-
-#ifdef CONFIG_IWLWIFI_DEVICE_TESTMODE
- IWL_INFO(priv, "CONFIG_IWLWIFI_DEVICE_TESTMODE enabled\n");
-#else
- IWL_INFO(priv, "CONFIG_IWLWIFI_DEVICE_TESTMODE disabled\n");
-#endif
-
-#ifdef CONFIG_IWLWIFI_P2P
- IWL_INFO(priv, "CONFIG_IWLWIFI_P2P enabled\n");
-#else
- IWL_INFO(priv, "CONFIG_IWLWIFI_P2P disabled\n");
-#endif
 }
 
 static int iwl_eeprom_init_hw_params(struct iwl_priv *priv)
 {
  struct iwl_nvm_data *data = priv->nvm_data;
- char *debug_msg;
 
  if (data->sku_cap_11n_enable &&
      !priv->cfg->ht_params) {
@@ -1203,8 +1136,8 @@ static int iwl_eeprom_init_hw_params(struct iwl_priv *priv)
   return -EINVAL;
  }
 
- debug_msg = "Device SKU: 24GHz %s %s, 52GHz %s %s, 11.n %s %s\n";
- IWL_DEBUG_INFO(priv, debug_msg,
+ IWL_DEBUG_INFO(priv,
+         "Device SKU: 24GHz %s %s, 52GHz %s %s, 11.n %s %s\n",
          data->sku_cap_band_24GHz_enable ? "" : "NOT", "enabled",
          data->sku_cap_band_52GHz_enable ? "" : "NOT", "enabled",
          data->sku_cap_11n_enable ? "" : "NOT", "enabled");
@@ -1264,31 +1197,37 @@ static struct iwl_op_mode *iwl_op_mode_dvm_start(struct iwl_trans *trans,
  switch (priv->cfg->device_family) {
  case IWL_DEVICE_FAMILY_1000:
  case IWL_DEVICE_FAMILY_100:
-  priv->lib = &iwl1000_lib;
+  priv->lib = &iwl_dvm_1000_cfg;
   break;
  case IWL_DEVICE_FAMILY_2000:
+  priv->lib = &iwl_dvm_2000_cfg;
+  break;
  case IWL_DEVICE_FAMILY_105:
-  priv->lib = &iwl2000_lib;
+  priv->lib = &iwl_dvm_105_cfg;
   break;
  case IWL_DEVICE_FAMILY_2030:
  case IWL_DEVICE_FAMILY_135:
-  priv->lib = &iwl2030_lib;
+  priv->lib = &iwl_dvm_2030_cfg;
   break;
  case IWL_DEVICE_FAMILY_5000:
-  priv->lib = &iwl5000_lib;
+  priv->lib = &iwl_dvm_5000_cfg;
   break;
  case IWL_DEVICE_FAMILY_5150:
-  priv->lib = &iwl5150_lib;
+  priv->lib = &iwl_dvm_5150_cfg;
   break;
  case IWL_DEVICE_FAMILY_6000:
- case IWL_DEVICE_FAMILY_6005:
  case IWL_DEVICE_FAMILY_6000i:
+  priv->lib = &iwl_dvm_6000_cfg;
+  break;
+ case IWL_DEVICE_FAMILY_6005:
+  priv->lib = &iwl_dvm_6005_cfg;
+  break;
  case IWL_DEVICE_FAMILY_6050:
  case IWL_DEVICE_FAMILY_6150:
-  priv->lib = &iwl6000_lib;
+  priv->lib = &iwl_dvm_6050_cfg;
   break;
  case IWL_DEVICE_FAMILY_6030:
-  priv->lib = &iwl6030_lib;
+  priv->lib = &iwl_dvm_6030_cfg;
   break;
  default:
   break;
@@ -1318,10 +1257,6 @@ static struct iwl_op_mode *iwl_op_mode_dvm_start(struct iwl_trans *trans,
 
  ucode_flags = fw->ucode_capa.flags;
 
-#ifndef CONFIG_IWLWIFI_P2P
- ucode_flags &= ~IWL_UCODE_TLV_FLAGS_P2P;
-#endif
-
  if (ucode_flags & IWL_UCODE_TLV_FLAGS_PAN) {
   priv->sta_key_max_num = STA_KEY_MAX_NUM_PAN;
   trans_cfg.cmd_queue = IWL_IPAN_CMD_QUEUE_NUM;
@@ -1350,8 +1285,8 @@ static struct iwl_op_mode *iwl_op_mode_dvm_start(struct iwl_trans *trans,
    IWL_BT_ANTENNA_COUPLING_THRESHOLD) ?
    true : false;
 
- /* enable/disable bt channel inhibition */
- priv->bt_ch_announce = iwlwifi_mod_params.bt_ch_announce;
+ /* bt channel inhibition enabled*/
+ priv->bt_ch_announce = true;
  IWL_DEBUG_INFO(priv, "BT channel inhibition is %s\n",
          (priv->bt_ch_announce) ? "On" : "Off");
 
@@ -1377,7 +1312,7 @@ static struct iwl_op_mode *iwl_op_mode_dvm_start(struct iwl_trans *trans,
  }
 
  /* Reset chip to save power until we load uCode during "up". */
- iwl_trans_stop_hw(priv->trans, false);
+ iwl_trans_stop_device(priv->trans);
 
  priv->nvm_data = iwl_parse_eeprom_data(priv->trans->dev, priv->cfg,
         priv->eeprom_blob,
@@ -1410,13 +1345,12 @@ static struct iwl_op_mode *iwl_op_mode_dvm_start(struct iwl_trans *trans,
  iwl_set_hw_params(priv);
 
  if (!(priv->nvm_data->sku_cap_ipan_enable)) {
-  IWL_DEBUG_INFO(priv, "Your EEPROM disabled PAN");
+  IWL_DEBUG_INFO(priv, "Your EEPROM disabled PAN\n");
   ucode_flags &= ~IWL_UCODE_TLV_FLAGS_PAN;
   /*
    * if not PAN, then don't support P2P -- might be a uCode
    * packaging bug or due to the eeprom check above
    */
-  ucode_flags &= ~IWL_UCODE_TLV_FLAGS_P2P;
   priv->sta_key_max_num = STA_KEY_MAX_NUM;
   trans_cfg.cmd_queue = IWL_DEFAULT_CMD_QUEUE_NUM;
 
@@ -1446,7 +1380,6 @@ static struct iwl_op_mode *iwl_op_mode_dvm_start(struct iwl_trans *trans,
   ********************/
  iwl_setup_deferred_work(priv);
  iwl_setup_rx_handlers(priv);
- iwl_testmode_init(priv);
 
  iwl_power_initialize(priv);
  iwl_tt_initialize(priv);
@@ -1483,7 +1416,6 @@ out_mac80211_unregister:
  iwlagn_mac_unregister(priv);
 out_destroy_workqueue:
  iwl_tt_exit(priv);
- iwl_testmode_free(priv);
  iwl_cancel_deferred_work(priv);
  destroy_workqueue(priv->workqueue);
  priv->workqueue = NULL;
@@ -1505,7 +1437,6 @@ static void iwl_op_mode_dvm_stop(struct iwl_op_mode *op_mode)
 
  IWL_DEBUG_INFO(priv, "*** UNLOAD DRIVER ***\n");
 
- iwl_testmode_free(priv);
  iwlagn_mac_unregister(priv);
 
  iwl_tt_exit(priv);
@@ -1526,7 +1457,7 @@ static void iwl_op_mode_dvm_stop(struct iwl_op_mode *op_mode)
 
  dev_kfree_skb(priv->beacon_skb);
 
- iwl_trans_stop_hw(priv->trans, true);
+ iwl_trans_op_mode_leave(priv->trans);
  ieee80211_free_hw(priv->hw);
 }
 
@@ -1854,14 +1785,9 @@ int iwl_dump_nic_event_log(struct iwl_priv *priv, bool full_log,
   return pos;
  }
 
-#ifdef CONFIG_IWLWIFI_DEBUG
  if (!(iwl_have_debug_level(IWL_DL_FW_ERRORS)) && !full_log)
   size = (size > DEFAULT_DUMP_EVENT_LOG_ENTRIES)
    ? DEFAULT_DUMP_EVENT_LOG_ENTRIES : size;
-#else
- size = (size > DEFAULT_DUMP_EVENT_LOG_ENTRIES)
-  ? DEFAULT_DUMP_EVENT_LOG_ENTRIES : size;
-#endif
  IWL_ERR(priv, "Start IWL Event Log Dump: display last %u entries\n",
   size);
 
@@ -1905,10 +1831,8 @@ static void iwlagn_fw_error(struct iwl_priv *priv, bool ondemand)
  unsigned int reload_msec;
  unsigned long reload_jiffies;
 
-#ifdef CONFIG_IWLWIFI_DEBUG
  if (iwl_have_debug_level(IWL_DL_FW_ERRORS))
   iwl_print_rx_config_cmd(priv, IWL_RXON_CTX_BSS);
-#endif
 
  /* uCode is no longer loaded. */
  priv->ucode_loaded = false;
@@ -2090,10 +2014,10 @@ void iwlagn_lift_passive_no_rx(struct iwl_priv *priv)
 
  for (mq = 0; mq < IWLAGN_FIRST_AMPDU_QUEUE; mq++) {
   if (!test_bit(mq, &priv->transport_queue_stop)) {
-   IWL_DEBUG_TX_QUEUES(priv, "Wake queue %d", mq);
+   IWL_DEBUG_TX_QUEUES(priv, "Wake queue %d\n", mq);
    ieee80211_wake_queue(priv->hw, mq);
   } else {
-   IWL_DEBUG_TX_QUEUES(priv, "Don't wake queue %d", mq);
+   IWL_DEBUG_TX_QUEUES(priv, "Don't wake queue %d\n", mq);
   }
  }
 
@@ -2110,7 +2034,7 @@ static void iwl_free_skb(struct iwl_op_mode *op_mode, struct sk_buff *skb)
  ieee80211_free_txskb(priv->hw, skb);
 }
 
-static void iwl_set_hw_rfkill_state(struct iwl_op_mode *op_mode, bool state)
+static bool iwl_set_hw_rfkill_state(struct iwl_op_mode *op_mode, bool state)
 {
  struct iwl_priv *priv = IWL_OP_MODE_GET_DVM(op_mode);
 
@@ -2120,6 +2044,19 @@ static void iwl_set_hw_rfkill_state(struct iwl_op_mode *op_mode, bool state)
   clear_bit(STATUS_RF_KILL_HW, &priv->status);
 
  wiphy_rfkill_set_hw_state(priv->hw->wiphy, state);
+
+ return false;
+}
+
+static void iwl_napi_add(struct iwl_op_mode *op_mode,
+    struct napi_struct *napi,
+    struct net_device *napi_dev,
+    int (*poll)(struct napi_struct *, int),
+    int weight)
+{
+ struct iwl_priv *priv = IWL_OP_MODE_GET_DVM(op_mode);
+
+ ieee80211_napi_add(priv->hw, napi, napi_dev, poll, weight);
 }
 
 static const struct iwl_op_mode_ops iwl_dvm_ops = {
@@ -2134,6 +2071,7 @@ static const struct iwl_op_mode_ops iwl_dvm_ops = {
  .cmd_queue_full = iwl_cmd_queue_full,
  .nic_config = iwl_nic_config,
  .wimax_active = iwl_wimax_active,
+ .napi_add = iwl_napi_add,
 };
 
 /*****************************************************************************
diff --git a/drivers/net/wireless/iwlwifi/dvm/power.c b/drivers/net/wireless/iwlwifi/dvm/power.c
index bd69018..f2c1439 100644
--- a/drivers/net/wireless/iwlwifi/dvm/power.c
+++ b/drivers/net/wireless/iwlwifi/dvm/power.c
@@ -1,6 +1,6 @@
 /******************************************************************************
  *
- * Copyright(c) 2007 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2007 - 2014 Intel Corporation. All rights reserved.
  *
  * Portions of this file are derived from the ipw3945 project, as well
  * as portions of the ieee80211 subsystem header files.
@@ -30,7 +30,6 @@
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/slab.h>
-#include <linux/init.h>
 #include <net/mac80211.h>
 #include "iwl-io.h"
 #include "iwl-debug.h"
@@ -163,7 +162,7 @@ static void iwl_static_sleep_cmd(struct iwl_priv *priv,
  u8 skip;
  u32 slp_itrvl;
 
- if (priv->cfg->adv_pm) {
+ if (priv->lib->adv_pm) {
   table = apm_range_2;
   if (period <= IWL_DTIM_RANGE_1_MAX)
    table = apm_range_1;
@@ -217,7 +216,7 @@ static void iwl_static_sleep_cmd(struct iwl_priv *priv,
   cmd->flags &= ~IWL_POWER_SHADOW_REG_ENA;
 
  if (iwl_advanced_bt_coexist(priv)) {
-  if (!priv->cfg->bt_params->bt_sco_disable)
+  if (!priv->lib->bt_params->bt_sco_disable)
    cmd->flags |= IWL_POWER_BT_SCO_ENA;
   else
    cmd->flags &= ~IWL_POWER_BT_SCO_ENA;
@@ -279,7 +278,7 @@ static int iwl_set_power(struct iwl_priv *priv, struct iwl_powertable_cmd *cmd)
    le32_to_cpu(cmd->sleep_interval[3]),
    le32_to_cpu(cmd->sleep_interval[4]));
 
- return iwl_dvm_send_cmd_pdu(priv, POWER_TABLE_CMD, CMD_SYNC,
+ return iwl_dvm_send_cmd_pdu(priv, POWER_TABLE_CMD, 0,
     sizeof(struct iwl_powertable_cmd), cmd);
 }
 
@@ -293,7 +292,7 @@ static void iwl_power_build_cmd(struct iwl_priv *priv,
 
  if (priv->wowlan)
   iwl_static_sleep_cmd(priv, cmd, IWL_POWER_INDEX_5, dtimper);
- else if (!priv->cfg->base_params->no_idle_support &&
+ else if (!priv->lib->no_idle_support &&
    priv->hw->conf.flags & IEEE80211_CONF_IDLE)
   iwl_static_sleep_cmd(priv, cmd, IWL_POWER_INDEX_5, 20);
  else if (iwl_tt_is_low_power_state(priv)) {
@@ -362,7 +361,7 @@ int iwl_power_set_mode(struct iwl_priv *priv, struct iwl_powertable_cmd *cmd,
 
   memcpy(&priv->power_data.sleep_cmd, cmd, sizeof(*cmd));
  } else
-  IWL_ERR(priv, "set power fail, ret = %d", ret);
+  IWL_ERR(priv, "set power fail, ret = %d\n", ret);
 
  return ret;
 }
diff --git a/drivers/net/wireless/iwlwifi/dvm/power.h b/drivers/net/wireless/iwlwifi/dvm/power.h
index 7b03e13..570d3a5 100644
--- a/drivers/net/wireless/iwlwifi/dvm/power.h
+++ b/drivers/net/wireless/iwlwifi/dvm/power.h
@@ -1,6 +1,6 @@
 /******************************************************************************
  *
- * Copyright(c) 2007 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2007 - 2014 Intel Corporation. All rights reserved.
  *
  * Portions of this file are derived from the ipw3945 project, as well
  * as portions of the ieee80211 subsystem header files.
diff --git a/drivers/net/wireless/iwlwifi/dvm/rs.c b/drivers/net/wireless/iwlwifi/dvm/rs.c
index 10fbb17..32b78a6 100644
--- a/drivers/net/wireless/iwlwifi/dvm/rs.c
+++ b/drivers/net/wireless/iwlwifi/dvm/rs.c
@@ -1,6 +1,6 @@
 /******************************************************************************
  *
- * Copyright(c) 2005 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2005 - 2014 Intel Corporation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
@@ -24,7 +24,6 @@
  *
  *****************************************************************************/
 #include <linux/kernel.h>
-#include <linux/init.h>
 #include <linux/skbuff.h>
 #include <linux/slab.h>
 #include <net/mac80211.h>
@@ -177,46 +176,46 @@ static void rs_dbgfs_set_mcs(struct iwl_lq_sta *lq_sta,
  * (2.4 GHz) band.
  */
 
-static s32 expected_tpt_legacy[IWL_RATE_COUNT] = {
+static const u16 expected_tpt_legacy[IWL_RATE_COUNT] = {
  7, 13, 35, 58, 40, 57, 72, 98, 121, 154, 177, 186, 0
 };
 
-static s32 expected_tpt_siso20MHz[4][IWL_RATE_COUNT] = {
+static const u16 expected_tpt_siso20MHz[4][IWL_RATE_COUNT] = {
  {0, 0, 0, 0, 42, 0,  76, 102, 124, 159, 183, 193, 202}, /* Norm */
  {0, 0, 0, 0, 46, 0,  82, 110, 132, 168, 192, 202, 210}, /* SGI */
  {0, 0, 0, 0, 47, 0,  91, 133, 171, 242, 305, 334, 362}, /* AGG */
  {0, 0, 0, 0, 52, 0, 101, 145, 187, 264, 330, 361, 390}, /* AGG+SGI */
 };
 
-static s32 expected_tpt_siso40MHz[4][IWL_RATE_COUNT] = {
+static const u16 expected_tpt_siso40MHz[4][IWL_RATE_COUNT] = {
  {0, 0, 0, 0,  77, 0, 127, 160, 184, 220, 242, 250, 257}, /* Norm */
  {0, 0, 0, 0,  83, 0, 135, 169, 193, 229, 250, 257, 264}, /* SGI */
  {0, 0, 0, 0,  94, 0, 177, 249, 313, 423, 512, 550, 586}, /* AGG */
  {0, 0, 0, 0, 104, 0, 193, 270, 338, 454, 545, 584, 620}, /* AGG+SGI */
 };
 
-static s32 expected_tpt_mimo2_20MHz[4][IWL_RATE_COUNT] = {
+static const u16 expected_tpt_mimo2_20MHz[4][IWL_RATE_COUNT] = {
  {0, 0, 0, 0,  74, 0, 123, 155, 179, 214, 236, 244, 251}, /* Norm */
  {0, 0, 0, 0,  81, 0, 131, 164, 188, 223, 243, 251, 257}, /* SGI */
  {0, 0, 0, 0,  89, 0, 167, 235, 296, 402, 488, 526, 560}, /* AGG */
  {0, 0, 0, 0,  97, 0, 182, 255, 320, 431, 520, 558, 593}, /* AGG+SGI*/
 };
 
-static s32 expected_tpt_mimo2_40MHz[4][IWL_RATE_COUNT] = {
+static const u16 expected_tpt_mimo2_40MHz[4][IWL_RATE_COUNT] = {
  {0, 0, 0, 0, 123, 0, 182, 214, 235, 264, 279, 285, 289}, /* Norm */
  {0, 0, 0, 0, 131, 0, 191, 222, 242, 270, 284, 289, 293}, /* SGI */
  {0, 0, 0, 0, 171, 0, 305, 410, 496, 634, 731, 771, 805}, /* AGG */
  {0, 0, 0, 0, 186, 0, 329, 439, 527, 667, 764, 803, 838}, /* AGG+SGI */
 };
 
-static s32 expected_tpt_mimo3_20MHz[4][IWL_RATE_COUNT] = {
+static const u16 expected_tpt_mimo3_20MHz[4][IWL_RATE_COUNT] = {
  {0, 0, 0, 0,  99, 0, 153, 186, 208, 239, 256, 263, 268}, /* Norm */
  {0, 0, 0, 0, 106, 0, 162, 194, 215, 246, 262, 268, 273}, /* SGI */
  {0, 0, 0, 0, 134, 0, 249, 346, 431, 574, 685, 732, 775}, /* AGG */
  {0, 0, 0, 0, 148, 0, 272, 376, 465, 614, 727, 775, 818}, /* AGG+SGI */
 };
 
-static s32 expected_tpt_mimo3_40MHz[4][IWL_RATE_COUNT] = {
+static const u16 expected_tpt_mimo3_40MHz[4][IWL_RATE_COUNT] = {
  {0, 0, 0, 0, 152, 0, 211, 239, 255, 279,  290,  294,  297}, /* Norm */
  {0, 0, 0, 0, 160, 0, 219, 245, 261, 284,  294,  297,  300}, /* SGI */
  {0, 0, 0, 0, 254, 0, 443, 584, 695, 868,  984, 1030, 1070}, /* AGG */
@@ -351,12 +350,6 @@ static void rs_program_fix_rate(struct iwl_priv *priv,
  lq_sta->active_mimo2_rate  = 0x1FD0; /* 6 - 60 MBits, no 9, no CCK */
  lq_sta->active_mimo3_rate  = 0x1FD0; /* 6 - 60 MBits, no 9, no CCK */
 
-#ifdef CONFIG_IWLWIFI_DEVICE_TESTMODE
- /* testmode has higher priority to overwirte the fixed rate */
- if (priv->tm_fixed_rate)
-  lq_sta->dbg_fixed_rate = priv->tm_fixed_rate;
-#endif
-
  IWL_DEBUG_RATE(priv, "sta_id %d rate 0x%X\n",
   lq_sta->lq.sta_id, lq_sta->dbg_fixed_rate);
 
@@ -419,23 +412,18 @@ static int rs_tl_turn_on_agg_for_tid(struct iwl_priv *priv,
 
  load = rs_tl_get_load(lq_data, tid);
 
- if ((iwlwifi_mod_params.auto_agg) || (load > IWL_AGG_LOAD_THRESHOLD)) {
-  IWL_DEBUG_HT(priv, "Starting Tx agg: STA: %pM tid: %d\n",
-    sta->addr, tid);
-  ret = ieee80211_start_tx_ba_session(sta, tid, 5000);
-  if (ret == -EAGAIN) {
-   /*
-    * driver and mac80211 is out of sync
-    * this might be cause by reloading firmware
-    * stop the tx ba session here
-    */
-   IWL_ERR(priv, "Fail start Tx agg on tid: %d\n",
-    tid);
-   ieee80211_stop_tx_ba_session(sta, tid);
-  }
- } else {
-  IWL_DEBUG_HT(priv, "Aggregation not enabled for tid %d "
-   "because load = %u\n", tid, load);
+ IWL_DEBUG_HT(priv, "Starting Tx agg: STA: %pM tid: %d\n",
+   sta->addr, tid);
+ ret = ieee80211_start_tx_ba_session(sta, tid, 5000);
+ if (ret == -EAGAIN) {
+  /*
+   * driver and mac80211 is out of sync
+   * this might be cause by reloading firmware
+   * stop the tx ba session here
+   */
+  IWL_ERR(priv, "Fail start Tx agg on tid: %d\n",
+   tid);
+  ieee80211_stop_tx_ba_session(sta, tid);
  }
  return ret;
 }
@@ -1083,12 +1071,7 @@ done:
  if (sta && sta->supp_rates[sband->band])
   rs_rate_scale_perform(priv, skb, sta, lq_sta);
 
-#if defined(CONFIG_MAC80211_DEBUGFS) && defined(CONFIG_IWLWIFI_DEVICE_TESTMODE)
- if ((priv->tm_fixed_rate) &&
-     (priv->tm_fixed_rate != lq_sta->dbg_fixed_rate))
-  rs_program_fix_rate(priv, lq_sta);
-#endif
- if (priv->cfg->bt_params && priv->cfg->bt_params->advanced_bt_coexist)
+ if (priv->lib->bt_params && priv->lib->bt_params->advanced_bt_coexist)
   rs_bt_update_lq(priv, ctx, lq_sta);
 }
 
@@ -1128,7 +1111,7 @@ static void rs_set_expected_tpt_table(struct iwl_lq_sta *lq_sta,
           struct iwl_scale_tbl_info *tbl)
 {
  /* Used to choose among HT tables */
- s32 (*ht_tbl_pointer)[IWL_RATE_COUNT];
+ const u16 (*ht_tbl_pointer)[IWL_RATE_COUNT];
 
  /* Check for invalid LQ type */
  if (WARN_ON_ONCE(!is_legacy(tbl->lq_type) && !is_Ht(tbl->lq_type))) {
@@ -1190,9 +1173,8 @@ static s32 rs_get_best_rate(struct iwl_priv *priv,
      &(lq_sta->lq_info[lq_sta->active_tbl]);
  s32 active_sr = active_tbl->win[index].success_ratio;
  s32 active_tpt = active_tbl->expected_tpt[index];
-
  /* expected "search" throughput */
- s32 *tpt_tbl = tbl->expected_tpt;
+ const u16 *tpt_tbl = tbl->expected_tpt;
 
  s32 new_rate, high, low, start_hi;
  u16 high_low;
@@ -1471,7 +1453,7 @@ static int rs_move_legacy_other(struct iwl_priv *priv,
    tbl->action = IWL_LEGACY_SWITCH_SISO;
   break;
  default:
-  IWL_ERR(priv, "Invalid BT load %d", priv->bt_traffic_load);
+  IWL_ERR(priv, "Invalid BT load %d\n", priv->bt_traffic_load);
   break;
  }
 
@@ -1646,7 +1628,7 @@ static int rs_move_siso_to_other(struct iwl_priv *priv,
    tbl->action = IWL_SISO_SWITCH_ANTENNA1;
   break;
  default:
-  IWL_ERR(priv, "Invalid BT load %d", priv->bt_traffic_load);
+  IWL_ERR(priv, "Invalid BT load %d\n", priv->bt_traffic_load);
   break;
  }
 
@@ -1817,7 +1799,7 @@ static int rs_move_mimo2_to_other(struct iwl_priv *priv,
    tbl->action = IWL_MIMO2_SWITCH_SISO_A;
   break;
  default:
-  IWL_ERR(priv, "Invalid BT load %d", priv->bt_traffic_load);
+  IWL_ERR(priv, "Invalid BT load %d\n", priv->bt_traffic_load);
   break;
  }
 
@@ -1987,7 +1969,7 @@ static int rs_move_mimo3_to_other(struct iwl_priv *priv,
    tbl->action = IWL_MIMO3_SWITCH_SISO_A;
   break;
  default:
-  IWL_ERR(priv, "Invalid BT load %d", priv->bt_traffic_load);
+  IWL_ERR(priv, "Invalid BT load %d\n", priv->bt_traffic_load);
   break;
  }
 
@@ -2727,7 +2709,7 @@ static void rs_initialize_lq(struct iwl_priv *priv,
  rs_set_expected_tpt_table(lq_sta, tbl);
  rs_fill_link_cmd(NULL, lq_sta, rate);
  priv->stations[lq_sta->lq.sta_id].lq = &lq_sta->lq;
- iwl_send_lq_cmd(priv, ctx, &lq_sta->lq, CMD_SYNC, true);
+ iwl_send_lq_cmd(priv, ctx, &lq_sta->lq, 0, true);
 }
 
 static void rs_get_rate(void *priv_r, struct ieee80211_sta *sta, void *priv_sta,
@@ -2842,9 +2824,6 @@ void iwl_rs_rate_init(struct iwl_priv *priv, struct ieee80211_sta *sta, u8 sta_i
 
  lq_sta->flush_timer = 0;
  lq_sta->supp_rates = sta->supp_rates[sband->band];
- for (j = 0; j < LQ_SIZE; j++)
-  for (i = 0; i < IWL_RATE_COUNT; i++)
-   rs_rate_scale_clear_window(&lq_sta->lq_info[j].win[i]);
 
  IWL_DEBUG_RATE(priv, "LQ: *** rate scale station global init for station %d ***\n",
          sta_id);
@@ -2913,9 +2892,6 @@ void iwl_rs_rate_init(struct iwl_priv *priv, struct ieee80211_sta *sta, u8 sta_i
  if (sband->band == IEEE80211_BAND_5GHZ)
   lq_sta->last_txrate_idx += IWL_FIRST_OFDM_RATE;
  lq_sta->is_agg = 0;
-#ifdef CONFIG_IWLWIFI_DEVICE_TESTMODE
- priv->tm_fixed_rate = 0;
-#endif
 #ifdef CONFIG_MAC80211_DEBUGFS
  lq_sta->dbg_fixed_rate = 0;
 #endif
@@ -3064,11 +3040,11 @@ static void rs_fill_link_cmd(struct iwl_priv *priv,
   * overwrite if needed, pass aggregation time limit
   * to uCode in uSec
   */
- if (priv && priv->cfg->bt_params &&
-     priv->cfg->bt_params->agg_time_limit &&
+ if (priv && priv->lib->bt_params &&
+     priv->lib->bt_params->agg_time_limit &&
      priv->bt_traffic_load >= IWL_BT_COEX_TRAFFIC_LOAD_HIGH)
   lq_cmd->agg_params.agg_time_limit =
-   cpu_to_le16(priv->cfg->bt_params->agg_time_limit);
+   cpu_to_le16(priv->lib->bt_params->agg_time_limit);
 }
 
 static void *rs_alloc(struct ieee80211_hw *hw, struct dentry *debugfsdir)
@@ -3338,11 +3314,12 @@ static void rs_remove_debugfs(void *priv, void *priv_sta)
  * station is added we ignore it.
  */
 static void rs_rate_init_stub(void *priv_r, struct ieee80211_supported_band *sband,
-    struct ieee80211_sta *sta, void *priv_sta)
+         struct cfg80211_chan_def *chandef,
+         struct ieee80211_sta *sta, void *priv_sta)
 {
 }
-static struct rate_control_ops rs_ops = {
- .module = NULL,
+
+static const struct rate_control_ops rs_ops = {
  .name = RS_NAME,
  .tx_status = rs_tx_status,
  .get_rate = rs_get_rate,
diff --git a/drivers/net/wireless/iwlwifi/dvm/rs.h b/drivers/net/wireless/iwlwifi/dvm/rs.h
index 5d83cab..f6bd25c 100644
--- a/drivers/net/wireless/iwlwifi/dvm/rs.h
+++ b/drivers/net/wireless/iwlwifi/dvm/rs.h
@@ -1,6 +1,6 @@
 /******************************************************************************
  *
- * Copyright(c) 2003 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2003 - 2014 Intel Corporation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
@@ -315,7 +315,7 @@ struct iwl_scale_tbl_info {
  u8 is_dup; /* 1 = duplicated data streams */
  u8 action; /* change modulation; IWL_[LEGACY/SISO/MIMO]_SWITCH_* */
  u8 max_search; /* maximun number of tables we can search */
- s32 *expected_tpt; /* throughput metrics; expected_tpt_G, etc. */
+ const u16 *expected_tpt; /* throughput metrics; expected_tpt_G, etc. */
  u32 current_rate;  /* rate_n_flags, uCode API format */
  struct iwl_rate_scale_data win[IWL_RATE_COUNT]; /* rate histories */
 };
@@ -389,13 +389,6 @@ struct iwl_lq_sta {
  u8 last_bt_traffic;
 };
 
-static inline u8 num_of_ant(u8 mask)
-{
- return  !!((mask) & ANT_A) +
-  !!((mask) & ANT_B) +
-  !!((mask) & ANT_C);
-}
-
 static inline u8 first_antenna(u8 mask)
 {
  if (mask & ANT_A)
@@ -407,8 +400,8 @@ static inline u8 first_antenna(u8 mask)
 
 
 /* Initialize station's rate scaling information after adding station */
-extern void iwl_rs_rate_init(struct iwl_priv *priv,
-        struct ieee80211_sta *sta, u8 sta_id);
+void iwl_rs_rate_init(struct iwl_priv *priv, struct ieee80211_sta *sta,
+        u8 sta_id);
 
 /**
  * iwl_rate_control_register - Register the rate control algorithm callbacks
@@ -420,7 +413,7 @@ extern void iwl_rs_rate_init(struct iwl_priv *priv,
  * ieee80211_register_hw
  *
  */
-extern int iwlagn_rate_control_register(void);
+int iwlagn_rate_control_register(void);
 
 /**
  * iwl_rate_control_unregister - Unregister the rate control callbacks
@@ -428,6 +421,6 @@ extern int iwlagn_rate_control_register(void);
  * This should be called after calling ieee80211_unregister_hw, but before
  * the driver is unloaded.
  */
-extern void iwlagn_rate_control_unregister(void);
+void iwlagn_rate_control_unregister(void);
 
 #endif /* __iwl_agn__rs__ */
diff --git a/drivers/net/wireless/iwlwifi/dvm/rx.c b/drivers/net/wireless/iwlwifi/dvm/rx.c
index a4eed20..debec96 100644
--- a/drivers/net/wireless/iwlwifi/dvm/rx.c
+++ b/drivers/net/wireless/iwlwifi/dvm/rx.c
@@ -1,6 +1,6 @@
 /******************************************************************************
  *
- * Copyright(c) 2003 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2003 - 2014 Intel Corporation. All rights reserved.
  *
  * Portions of this file are derived from the ipw3945 project, as well
  * as portionhelp of the ieee80211 subsystem header files.
@@ -39,7 +39,7 @@
 
 #define IWL_CMD_ENTRY(x) [x] = #x
 
-const char *iwl_dvm_cmd_strings[REPLY_MAX] = {
+const char *const iwl_dvm_cmd_strings[REPLY_MAX] = {
  IWL_CMD_ENTRY(REPLY_ALIVE),
  IWL_CMD_ENTRY(REPLY_ERROR),
  IWL_CMD_ENTRY(REPLY_ECHO),
@@ -205,8 +205,7 @@ static int iwlagn_rx_pm_debug_statistics_notif(struct iwl_priv *priv,
           struct iwl_device_cmd *cmd)
 {
  struct iwl_rx_packet *pkt = rxb_addr(rxb);
- u32 __maybe_unused len =
-  le32_to_cpu(pkt->len_n_flags) & FH_RSCSR_FRAME_SIZE_MSK;
+ u32 __maybe_unused len = iwl_rx_packet_len(pkt);
  IWL_DEBUG_RADIO(priv, "Dumping %d bytes of unhandled "
    "notification for PM_DEBUG_STATISTIC_NOTIFIC:\n", len);
  iwl_print_hex_dump(priv, IWL_DL_RADIO, pkt->data, len);
@@ -335,8 +334,7 @@ static void iwlagn_recover_from_statistics(struct iwl_priv *priv,
  if (msecs < 99)
   return;
 
- if (iwlwifi_mod_params.plcp_check &&
-     !iwlagn_good_plcp_health(priv, cur_ofdm, cur_ofdm_ht, msecs))
+ if (!iwlagn_good_plcp_health(priv, cur_ofdm, cur_ofdm_ht, msecs))
   iwl_force_rf_reset(priv, false);
 }
 
@@ -458,7 +456,7 @@ static int iwlagn_rx_statistics(struct iwl_priv *priv,
  const int reg_recalib_period = 60;
  int change;
  struct iwl_rx_packet *pkt = rxb_addr(rxb);
- u32 len = le32_to_cpu(pkt->len_n_flags) & FH_RSCSR_FRAME_SIZE_MSK;
+ u32 len = iwl_rx_packet_payload_len(pkt);
  __le32 *flag;
  struct statistics_general_common *common;
  struct statistics_rx_non_phy *rx_non_phy;
@@ -468,8 +466,6 @@ static int iwlagn_rx_statistics(struct iwl_priv *priv,
  struct statistics_tx *tx;
  struct statistics_bt_activity *bt_activity;
 
- len -= sizeof(struct iwl_cmd_header); /* skip header */
-
  IWL_DEBUG_RX(priv, "Statistics notification received (%d bytes).\n",
        len);
 
@@ -790,7 +786,7 @@ static void iwlagn_pass_packet_to_mac80211(struct iwl_priv *priv,
 
  memcpy(IEEE80211_SKB_RXCB(skb), stats, sizeof(*stats));
 
- ieee80211_rx_ni(priv->hw, skb);
+ ieee80211_rx(priv->hw, skb);
 }
 
 static u32 iwlagn_translate_rx_status(struct iwl_priv *priv, u32 decrypt_in)
@@ -1102,7 +1098,7 @@ void iwl_setup_rx_handlers(struct iwl_priv *priv)
  iwl_notification_wait_init(&priv->notif_wait);
 
  /* Set up BT Rx handlers */
- if (priv->cfg->bt_params)
+ if (priv->lib->bt_params)
   iwlagn_bt_rx_handler_setup(priv);
 }
 
@@ -1120,32 +1116,17 @@ int iwl_rx_dispatch(struct iwl_op_mode *op_mode, struct iwl_rx_cmd_buffer *rxb,
   */
  iwl_notification_wait_notify(&priv->notif_wait, pkt);
 
-#ifdef CONFIG_IWLWIFI_DEVICE_TESTMODE
- /*
-  * RX data may be forwarded to userspace in one
-  * of two cases: the user owns the fw through testmode or when
-  * the user requested to monitor the rx w/o affecting the regular flow.
-  * In these cases the iwl_test object will handle forwarding the rx
-  * data to user space.
-  * Note that if the ownership flag != IWL_OWNERSHIP_TM the flow
-  * continues.
-  */
- iwl_test_rx(&priv->tst, rxb);
-#endif
-
- if (priv->ucode_owner != IWL_OWNERSHIP_TM) {
-  /* Based on type of command response or notification,
-   *   handle those that need handling via function in
-   *   rx_handlers table.  See iwl_setup_rx_handlers() */
-  if (priv->rx_handlers[pkt->hdr.cmd]) {
-   priv->rx_handlers_stats[pkt->hdr.cmd]++;
-   err = priv->rx_handlers[pkt->hdr.cmd] (priv, rxb, cmd);
-  } else {
-   /* No handling needed */
-   IWL_DEBUG_RX(priv, "No handler needed for %s, 0x%02x\n",
-         iwl_dvm_get_cmd_string(pkt->hdr.cmd),
-         pkt->hdr.cmd);
-  }
+ /* Based on type of command response or notification,
+  *   handle those that need handling via function in
+  *   rx_handlers table.  See iwl_setup_rx_handlers() */
+ if (priv->rx_handlers[pkt->hdr.cmd]) {
+  priv->rx_handlers_stats[pkt->hdr.cmd]++;
+  err = priv->rx_handlers[pkt->hdr.cmd] (priv, rxb, cmd);
+ } else {
+  /* No handling needed */
+  IWL_DEBUG_RX(priv, "No handler needed for %s, 0x%02x\n",
+        iwl_dvm_get_cmd_string(pkt->hdr.cmd),
+        pkt->hdr.cmd);
  }
  return err;
 }
diff --git a/drivers/net/wireless/iwlwifi/dvm/rxon.c b/drivers/net/wireless/iwlwifi/dvm/rxon.c
index cd1ad00..6dc5dd3 100644
--- a/drivers/net/wireless/iwlwifi/dvm/rxon.c
+++ b/drivers/net/wireless/iwlwifi/dvm/rxon.c
@@ -1,6 +1,6 @@
 /******************************************************************************
  *
- * Copyright(c) 2003 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2003 - 2014 Intel Corporation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
@@ -104,7 +104,7 @@ static int iwlagn_disable_bss(struct iwl_priv *priv,
 
  send->filter_flags &= ~RXON_FILTER_ASSOC_MSK;
  ret = iwl_dvm_send_cmd_pdu(priv, ctx->rxon_cmd,
-    CMD_SYNC, sizeof(*send), send);
+    0, sizeof(*send), send);
 
  send->filter_flags = old_filter;
 
@@ -134,7 +134,7 @@ static int iwlagn_disable_pan(struct iwl_priv *priv,
  send->filter_flags &= ~RXON_FILTER_ASSOC_MSK;
  send->dev_type = RXON_DEV_TYPE_P2P;
  ret = iwl_dvm_send_cmd_pdu(priv, ctx->rxon_cmd,
-    CMD_SYNC, sizeof(*send), send);
+    0, sizeof(*send), send);
 
  send->filter_flags = old_filter;
  send->dev_type = old_dev_type;
@@ -160,7 +160,7 @@ static int iwlagn_disconn_pan(struct iwl_priv *priv,
  int ret;
 
  send->filter_flags &= ~RXON_FILTER_ASSOC_MSK;
- ret = iwl_dvm_send_cmd_pdu(priv, ctx->rxon_cmd, CMD_SYNC,
+ ret = iwl_dvm_send_cmd_pdu(priv, ctx->rxon_cmd, 0,
     sizeof(*send), send);
 
  send->filter_flags = old_filter;
@@ -189,7 +189,7 @@ static void iwlagn_update_qos(struct iwl_priv *priv,
         ctx->qos_data.qos_active,
         ctx->qos_data.def_qos_parm.qos_flags);
 
- ret = iwl_dvm_send_cmd_pdu(priv, ctx->qos_cmd, CMD_SYNC,
+ ret = iwl_dvm_send_cmd_pdu(priv, ctx->qos_cmd, 0,
           sizeof(struct iwl_qosparam_cmd),
           &ctx->qos_data.def_qos_parm);
  if (ret)
@@ -353,7 +353,7 @@ static int iwl_send_rxon_timing(struct iwl_priv *priv,
    le16_to_cpu(ctx->timing.atim_window));
 
  return iwl_dvm_send_cmd_pdu(priv, ctx->rxon_timing_cmd,
-    CMD_SYNC, sizeof(ctx->timing), &ctx->timing);
+    0, sizeof(ctx->timing), &ctx->timing);
 }
 
 static int iwlagn_rxon_disconn(struct iwl_priv *priv,
@@ -495,7 +495,7 @@ static int iwlagn_rxon_connect(struct iwl_priv *priv,
   * Associated RXON doesn't clear the station table in uCode,
   * so we don't need to restore stations etc. after this.
   */
- ret = iwl_dvm_send_cmd_pdu(priv, ctx->rxon_cmd, CMD_SYNC,
+ ret = iwl_dvm_send_cmd_pdu(priv, ctx->rxon_cmd, 0,
         sizeof(struct iwl_rxon_cmd), &ctx->staging);
  if (ret) {
   IWL_ERR(priv, "Error setting new RXON (%d)\n", ret);
@@ -564,11 +564,7 @@ int iwlagn_set_pan_params(struct iwl_priv *priv)
  cmd.slots[0].type = 0; /* BSS */
  cmd.slots[1].type = 1; /* PAN */
 
- if (priv->hw_roc_setup) {
-  /* both contexts must be used for this to happen */
-  slot1 = IWL_MIN_SLOT_TIME;
-  slot0 = 3000;
- } else if (ctx_bss->vif && ctx_pan->vif) {
+ if (ctx_bss->vif && ctx_pan->vif) {
   int bcnint = ctx_pan->beacon_int;
   int dtim = ctx_pan->vif->bss_conf.dtim_period ?: 1;
 
@@ -614,7 +610,7 @@ int iwlagn_set_pan_params(struct iwl_priv *priv)
  cmd.slots[0].width = cpu_to_le16(slot0);
  cmd.slots[1].width = cpu_to_le16(slot1);
 
- ret = iwl_dvm_send_cmd_pdu(priv, REPLY_WIPAN_PARAMS, CMD_SYNC,
+ ret = iwl_dvm_send_cmd_pdu(priv, REPLY_WIPAN_PARAMS, 0,
    sizeof(cmd), &cmd);
  if (ret)
   IWL_ERR(priv, "Error setting PAN parameters (%d)\n", ret);
@@ -827,7 +823,7 @@ static int iwl_check_rxon_cmd(struct iwl_priv *priv,
 
  if ((rxon->flags & (RXON_FLG_CCK_MSK | RXON_FLG_AUTO_DETECT_MSK))
    == (RXON_FLG_CCK_MSK | RXON_FLG_AUTO_DETECT_MSK)) {
-  IWL_WARN(priv, "CCK and auto detect");
+  IWL_WARN(priv, "CCK and auto detect\n");
   errors |= BIT(8);
  }
 
@@ -1072,13 +1068,6 @@ int iwlagn_commit_rxon(struct iwl_priv *priv, struct iwl_rxon_context *ctx)
  /* recalculate basic rates */
  iwl_calc_basic_rates(priv, ctx);
 
- /*
-  * force CTS-to-self frames protection if RTS-CTS is not preferred
-  * one aggregation protection method
-  */
- if (!priv->hw_params.use_rts_for_aggregation)
-  ctx->staging.flags |= RXON_FLG_SELF_CTS_EN;
-
  if ((ctx->vif && ctx->vif->bss_conf.use_short_slot) ||
      !(ctx->staging.flags & RXON_FLG_BAND_24G_MSK))
   ctx->staging.flags |= RXON_FLG_SHORT_SLOT_MSK;
@@ -1399,7 +1388,7 @@ static void iwlagn_chain_noise_reset(struct iwl_priv *priv)
    priv->phy_calib_chain_noise_reset_cmd);
   ret = iwl_dvm_send_cmd_pdu(priv,
      REPLY_PHY_CALIBRATION_CMD,
-     CMD_SYNC, sizeof(cmd), &cmd);
+     0, sizeof(cmd), &cmd);
   if (ret)
    IWL_ERR(priv,
     "Could not send REPLY_PHY_CALIBRATION_CMD\n");
@@ -1484,11 +1473,6 @@ void iwlagn_bss_info_changed(struct ieee80211_hw *hw,
  else
   ctx->staging.flags &= ~RXON_FLG_TGG_PROTECT_MSK;
 
- if (bss_conf->use_cts_prot)
-  ctx->staging.flags |= RXON_FLG_SELF_CTS_EN;
- else
-  ctx->staging.flags &= ~RXON_FLG_SELF_CTS_EN;
-
  memcpy(ctx->staging.bssid_addr, bss_conf->bssid, ETH_ALEN);
 
  if (vif->type == NL80211_IFTYPE_AP ||
diff --git a/drivers/net/wireless/iwlwifi/dvm/scan.c b/drivers/net/wireless/iwlwifi/dvm/scan.c
index d69b558..43bef90 100644
--- a/drivers/net/wireless/iwlwifi/dvm/scan.c
+++ b/drivers/net/wireless/iwlwifi/dvm/scan.c
@@ -2,7 +2,7 @@
  *
  * GPL LICENSE SUMMARY
  *
- * Copyright(c) 2008 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2008 - 2014 Intel Corporation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of version 2 of the GNU General Public License as
@@ -59,7 +59,7 @@ static int iwl_send_scan_abort(struct iwl_priv *priv)
  int ret;
  struct iwl_host_cmd cmd = {
   .id = REPLY_SCAN_ABORT_CMD,
-  .flags = CMD_SYNC | CMD_WANT_SKB,
+  .flags = CMD_WANT_SKB,
  };
  __le32 *status;
 
@@ -100,9 +100,6 @@ static void iwl_complete_scan(struct iwl_priv *priv, bool aborted)
   ieee80211_scan_completed(priv->hw, aborted);
  }
 
- if (priv->scan_type == IWL_SCAN_ROC)
-  iwl_scan_roc_expired(priv);
-
  priv->scan_type = IWL_SCAN_NORMAL;
  priv->scan_vif = NULL;
  priv->scan_request = NULL;
@@ -130,9 +127,6 @@ static void iwl_process_scan_complete(struct iwl_priv *priv)
   goto out_settings;
  }
 
- if (priv->scan_type == IWL_SCAN_ROC)
-  iwl_scan_roc_expired(priv);
-
  if (priv->scan_type != IWL_SCAN_NORMAL && !aborted) {
   int err;
 
@@ -284,12 +278,6 @@ static int iwl_rx_scan_start_notif(struct iwl_priv *priv,
          le32_to_cpu(notif->tsf_low),
          notif->status, notif->beacon_timer);
 
- if (priv->scan_type == IWL_SCAN_ROC &&
-     !priv->hw_roc_start_notified) {
-  ieee80211_ready_on_channel(priv->hw);
-  priv->hw_roc_start_notified = true;
- }
-
  return 0;
 }
 
@@ -556,7 +544,7 @@ static int iwl_get_channels_for_scan(struct iwl_priv *priv,
   channel = chan->hw_value;
   scan_ch->channel = cpu_to_le16(channel);
 
-  if (!is_active || (chan->flags & IEEE80211_CHAN_PASSIVE_SCAN))
+  if (!is_active || (chan->flags & IEEE80211_CHAN_NO_IR))
    scan_ch->type = SCAN_CHANNEL_TYPE_PASSIVE;
   else
    scan_ch->type = SCAN_CHANNEL_TYPE_ACTIVE;
@@ -651,7 +639,6 @@ static int iwlagn_request_scan(struct iwl_priv *priv, struct ieee80211_vif *vif)
  struct iwl_host_cmd cmd = {
   .id = REPLY_SCAN_CMD,
   .len = { sizeof(struct iwl_scan_cmd), },
-  .flags = CMD_SYNC,
  };
  struct iwl_scan_cmd *scan;
  struct iwl_rxon_context *ctx = &priv->contexts[IWL_RXON_CTX_BSS];
@@ -697,8 +684,7 @@ static int iwlagn_request_scan(struct iwl_priv *priv, struct ieee80211_vif *vif)
  scan->quiet_plcp_th = IWL_PLCP_QUIET_THRESH;
  scan->quiet_time = IWL_ACTIVE_QUIET_TIME;
 
- if (priv->scan_type != IWL_SCAN_ROC &&
-     iwl_is_any_associated(priv)) {
+ if (iwl_is_any_associated(priv)) {
   u16 interval = 0;
   u32 extra;
   u32 suspend_time = 100;
@@ -706,9 +692,6 @@ static int iwlagn_request_scan(struct iwl_priv *priv, struct ieee80211_vif *vif)
 
   IWL_DEBUG_INFO(priv, "Scanning while associated...\n");
   switch (priv->scan_type) {
-  case IWL_SCAN_ROC:
-   WARN_ON(1);
-   break;
   case IWL_SCAN_RADIO_RESET:
    interval = 0;
    break;
@@ -728,11 +711,6 @@ static int iwlagn_request_scan(struct iwl_priv *priv, struct ieee80211_vif *vif)
   scan->suspend_time = cpu_to_le32(scan_suspend_time);
   IWL_DEBUG_SCAN(priv, "suspend_time 0x%X beacon interval %d\n",
           scan_suspend_time, interval);
- } else if (priv->scan_type == IWL_SCAN_ROC) {
-  scan->suspend_time = 0;
-  scan->max_out_time = 0;
-  scan->quiet_time = 0;
-  scan->quiet_plcp_th = 0;
  }
 
  switch (priv->scan_type) {
@@ -774,9 +752,6 @@ static int iwlagn_request_scan(struct iwl_priv *priv, struct ieee80211_vif *vif)
   } else
    IWL_DEBUG_SCAN(priv, "Start passive scan.\n");
   break;
- case IWL_SCAN_ROC:
-  IWL_DEBUG_SCAN(priv, "Start ROC scan.\n");
-  break;
  }
 
  scan->tx_cmd.tx_flags = TX_CMD_FLG_SEQ_CTL_MSK;
@@ -801,8 +776,8 @@ static int iwlagn_request_scan(struct iwl_priv *priv, struct ieee80211_vif *vif)
    * Internal scans are passive, so we can indiscriminately set
    * the BT ignore flag on 2.4 GHz since it applies to TX only.
    */
-  if (priv->cfg->bt_params &&
-      priv->cfg->bt_params->advanced_bt_coexist)
+  if (priv->lib->bt_params &&
+      priv->lib->bt_params->advanced_bt_coexist)
    scan->tx_cmd.tx_flags |= TX_CMD_FLG_IGNORE_BT;
   break;
  case IEEE80211_BAND_5GHZ:
@@ -844,8 +819,8 @@ static int iwlagn_request_scan(struct iwl_priv *priv, struct ieee80211_vif *vif)
  band = priv->scan_band;
 
  if (band == IEEE80211_BAND_2GHZ &&
-     priv->cfg->bt_params &&
-     priv->cfg->bt_params->advanced_bt_coexist) {
+     priv->lib->bt_params &&
+     priv->lib->bt_params->advanced_bt_coexist) {
   /* transmit 2.4 GHz probes only on first antenna */
   scan_tx_antennas = first_antenna(scan_tx_antennas);
  }
@@ -873,8 +848,8 @@ static int iwlagn_request_scan(struct iwl_priv *priv, struct ieee80211_vif *vif)
 
   rx_ant = first_antenna(active_chains);
  }
- if (priv->cfg->bt_params &&
-     priv->cfg->bt_params->advanced_bt_coexist &&
+ if (priv->lib->bt_params &&
+     priv->lib->bt_params->advanced_bt_coexist &&
      priv->bt_full_concurrent) {
   /* operated as 1x1 in full concurrency mode */
   rx_ant = first_antenna(rx_ant);
@@ -898,7 +873,6 @@ static int iwlagn_request_scan(struct iwl_priv *priv, struct ieee80211_vif *vif)
      scan_cmd_size - sizeof(*scan));
   break;
  case IWL_SCAN_RADIO_RESET:
- case IWL_SCAN_ROC:
   /* use bcast addr, will not be transmitted but must be valid */
   cmd_len = iwl_fill_probe_req(
      (struct ieee80211_mgmt *)scan->data,
@@ -926,46 +900,6 @@ static int iwlagn_request_scan(struct iwl_priv *priv, struct ieee80211_vif *vif)
     is_active, n_probes,
     (void *)&scan->data[cmd_len]);
   break;
- case IWL_SCAN_ROC: {
-  struct iwl_scan_channel *scan_ch;
-  int n_chan, i;
-  u16 dwell;
-
-  dwell = iwl_limit_dwell(priv, priv->hw_roc_duration);
-  n_chan = DIV_ROUND_UP(priv->hw_roc_duration, dwell);
-
-  scan->channel_count = n_chan;
-
-  scan_ch = (void *)&scan->data[cmd_len];
-
-  for (i = 0; i < n_chan; i++) {
-   scan_ch->type = SCAN_CHANNEL_TYPE_PASSIVE;
-   scan_ch->channel =
-    cpu_to_le16(priv->hw_roc_channel->hw_value);
-
-   if (i == n_chan - 1)
-    dwell = priv->hw_roc_duration - i * dwell;
-
-   scan_ch->active_dwell =
-   scan_ch->passive_dwell = cpu_to_le16(dwell);
-
-   /* Set txpower levels to defaults */
-   scan_ch->dsp_atten = 110;
-
-   /* NOTE: if we were doing 6Mb OFDM for scans we'd use
-    * power level:
-    * scan_ch->tx_gain = ((1 << 5) | (2 << 3)) | 3;
-    */
-   if (priv->hw_roc_channel->band == IEEE80211_BAND_5GHZ)
-    scan_ch->tx_gain = ((1 << 5) | (3 << 3)) | 3;
-   else
-    scan_ch->tx_gain = ((1 << 5) | (5 << 3));
-
-   scan_ch++;
-  }
-  }
-
-  break;
  }
 
  if (scan->channel_count == 0) {
@@ -1035,7 +969,6 @@ int __must_check iwl_scan_initiate(struct iwl_priv *priv,
 
  IWL_DEBUG_SCAN(priv, "Starting %sscan...\n",
    scan_type == IWL_SCAN_NORMAL ? "" :
-   scan_type == IWL_SCAN_ROC ? "remain-on-channel " :
    "internal short ");
 
  set_bit(STATUS_SCANNING, &priv->status);
@@ -1149,40 +1082,3 @@ void iwl_cancel_scan_deferred_work(struct iwl_priv *priv)
   mutex_unlock(&priv->mutex);
  }
 }
-
-void iwl_scan_roc_expired(struct iwl_priv *priv)
-{
- /*
-  * The status bit should be set here, to prevent a race
-  * where the atomic_read returns 1, but before the execution continues
-  * iwl_scan_offchannel_skb_status() checks if the status bit is set
-  */
- set_bit(STATUS_SCAN_ROC_EXPIRED, &priv->status);
-
- if (atomic_read(&priv->num_aux_in_flight) == 0) {
-  ieee80211_remain_on_channel_expired(priv->hw);
-  priv->hw_roc_channel = NULL;
-  schedule_delayed_work(&priv->hw_roc_disable_work,
-          10 * HZ);
-
-  clear_bit(STATUS_SCAN_ROC_EXPIRED, &priv->status);
- } else {
-  IWL_DEBUG_SCAN(priv, "ROC done with %d frames in aux\n",
-          atomic_read(&priv->num_aux_in_flight));
- }
-}
-
-void iwl_scan_offchannel_skb(struct iwl_priv *priv)
-{
- WARN_ON(!priv->hw_roc_start_notified);
- atomic_inc(&priv->num_aux_in_flight);
-}
-
-void iwl_scan_offchannel_skb_status(struct iwl_priv *priv)
-{
- if (atomic_dec_return(&priv->num_aux_in_flight) == 0 &&
-     test_bit(STATUS_SCAN_ROC_EXPIRED, &priv->status)) {
-  IWL_DEBUG_SCAN(priv, "0 aux frames. Calling ROC expired\n");
-  iwl_scan_roc_expired(priv);
- }
-}
diff --git a/drivers/net/wireless/iwlwifi/dvm/sta.c b/drivers/net/wireless/iwlwifi/dvm/sta.c
index c3c13ce..6ec86ad 100644
--- a/drivers/net/wireless/iwlwifi/dvm/sta.c
+++ b/drivers/net/wireless/iwlwifi/dvm/sta.c
@@ -1,6 +1,6 @@
 /******************************************************************************
  *
- * Copyright(c) 2003 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2003 - 2014 Intel Corporation. All rights reserved.
  *
  * Portions of this file are derived from the ipw3945 project, as well
  * as portions of the ieee80211 subsystem header files.
@@ -39,7 +39,7 @@ static int iwl_sta_ucode_activate(struct iwl_priv *priv, u8 sta_id)
  lockdep_assert_held(&priv->sta_lock);
 
  if (sta_id >= IWLAGN_STATION_COUNT) {
-  IWL_ERR(priv, "invalid sta_id %u", sta_id);
+  IWL_ERR(priv, "invalid sta_id %u\n", sta_id);
   return -EINVAL;
  }
  if (!(priv->stations[sta_id].used & IWL_STA_DRIVER_ACTIVE))
@@ -165,7 +165,7 @@ int iwl_send_add_sta(struct iwl_priv *priv,
  iwl_free_resp(&cmd);
 
  if (cmd.handler_status)
-  IWL_ERR(priv, "%s - error in the CMD response %d", __func__,
+  IWL_ERR(priv, "%s - error in the CMD response %d\n", __func__,
    cmd.handler_status);
 
  return cmd.handler_status;
@@ -261,7 +261,7 @@ int iwl_sta_update_ht(struct iwl_priv *priv, struct iwl_rxon_context *ctx,
  cmd.station_flags = flags;
  cmd.sta.sta_id = sta_id;
 
- return iwl_send_add_sta(priv, &cmd, CMD_SYNC);
+ return iwl_send_add_sta(priv, &cmd, 0);
 }
 
 static void iwl_set_ht_add_station(struct iwl_priv *priv, u8 index,
@@ -413,7 +413,7 @@ int iwl_add_station_common(struct iwl_priv *priv, struct iwl_rxon_context *ctx,
  spin_unlock_bh(&priv->sta_lock);
 
  /* Add station to device's station table */
- ret = iwl_send_add_sta(priv, &sta_cmd, CMD_SYNC);
+ ret = iwl_send_add_sta(priv, &sta_cmd, 0);
  if (ret) {
   spin_lock_bh(&priv->sta_lock);
   IWL_ERR(priv, "Adding station %pM failed.\n",
@@ -456,7 +456,6 @@ static int iwl_send_remove_station(struct iwl_priv *priv,
  struct iwl_host_cmd cmd = {
   .id = REPLY_REMOVE_STA,
   .len = { sizeof(struct iwl_rem_sta_cmd), },
-  .flags = CMD_SYNC,
   .data = { &rm_sta_cmd, },
  };
 
@@ -590,6 +589,7 @@ void iwl_deactivate_station(struct iwl_priv *priv, const u8 sta_id,
    sizeof(priv->tid_data[sta_id][tid]));
 
  priv->stations[sta_id].used &= ~IWL_STA_DRIVER_ACTIVE;
+ priv->stations[sta_id].used &= ~IWL_STA_UCODE_INPROGRESS;
 
  priv->num_stations--;
 
@@ -739,7 +739,7 @@ void iwl_restore_stations(struct iwl_priv *priv, struct iwl_rxon_context *ctx)
      send_lq = true;
    }
    spin_unlock_bh(&priv->sta_lock);
-   ret = iwl_send_add_sta(priv, &sta_cmd, CMD_SYNC);
+   ret = iwl_send_add_sta(priv, &sta_cmd, 0);
    if (ret) {
     spin_lock_bh(&priv->sta_lock);
     IWL_ERR(priv, "Adding station %pM failed.\n",
@@ -755,8 +755,7 @@ void iwl_restore_stations(struct iwl_priv *priv, struct iwl_rxon_context *ctx)
     * current LQ command
     */
    if (send_lq)
-    iwl_send_lq_cmd(priv, ctx, &lq,
-      CMD_SYNC, true);
+    iwl_send_lq_cmd(priv, ctx, &lq, 0, true);
    spin_lock_bh(&priv->sta_lock);
    priv->stations[i].used &= ~IWL_STA_UCODE_INPROGRESS;
   }
@@ -967,7 +966,7 @@ int iwlagn_add_bssid_station(struct iwl_priv *priv,
   return -ENOMEM;
  }
 
- ret = iwl_send_lq_cmd(priv, ctx, link_cmd, CMD_SYNC, true);
+ ret = iwl_send_lq_cmd(priv, ctx, link_cmd, 0, true);
  if (ret)
   IWL_ERR(priv, "Link quality command failed (%d)\n", ret);
 
@@ -998,7 +997,6 @@ static int iwl_send_static_wepkey_cmd(struct iwl_priv *priv,
  struct iwl_host_cmd cmd = {
   .id = ctx->wep_key_cmd,
   .data = { wep_cmd, },
-  .flags = CMD_SYNC,
  };
 
  might_sleep();
@@ -1247,7 +1245,7 @@ int iwl_remove_dynamic_key(struct iwl_priv *priv,
  sta_cmd.sta.modify_mask = STA_MODIFY_KEY_MASK;
  sta_cmd.mode = STA_CONTROL_MODIFY_MSK;
 
- return iwl_send_add_sta(priv, &sta_cmd, CMD_SYNC);
+ return iwl_send_add_sta(priv, &sta_cmd, 0);
 }
 
 int iwl_set_dynamic_key(struct iwl_priv *priv,
@@ -1283,13 +1281,13 @@ int iwl_set_dynamic_key(struct iwl_priv *priv,
   ieee80211_get_key_rx_seq(keyconf, 0, &seq);
   ieee80211_get_tkip_rx_p1k(keyconf, addr, seq.tkip.iv32, p1k);
   ret = iwlagn_send_sta_key(priv, keyconf, sta_id,
-       seq.tkip.iv32, p1k, CMD_SYNC);
+       seq.tkip.iv32, p1k, 0);
   break;
  case WLAN_CIPHER_SUITE_CCMP:
  case WLAN_CIPHER_SUITE_WEP40:
  case WLAN_CIPHER_SUITE_WEP104:
   ret = iwlagn_send_sta_key(priv, keyconf, sta_id,
-       0, NULL, CMD_SYNC);
+       0, NULL, 0);
   break;
  default:
   IWL_ERR(priv, "Unknown cipher %x\n", keyconf->cipher);
@@ -1408,7 +1406,7 @@ int iwl_sta_tx_modify_enable_tid(struct iwl_priv *priv, int sta_id, int tid)
  memcpy(&sta_cmd, &priv->stations[sta_id].sta, sizeof(struct iwl_addsta_cmd));
  spin_unlock_bh(&priv->sta_lock);
 
- return iwl_send_add_sta(priv, &sta_cmd, CMD_SYNC);
+ return iwl_send_add_sta(priv, &sta_cmd, 0);
 }
 
 int iwl_sta_rx_agg_start(struct iwl_priv *priv, struct ieee80211_sta *sta,
@@ -1432,7 +1430,7 @@ int iwl_sta_rx_agg_start(struct iwl_priv *priv, struct ieee80211_sta *sta,
  memcpy(&sta_cmd, &priv->stations[sta_id].sta, sizeof(struct iwl_addsta_cmd));
  spin_unlock_bh(&priv->sta_lock);
 
- return iwl_send_add_sta(priv, &sta_cmd, CMD_SYNC);
+ return iwl_send_add_sta(priv, &sta_cmd, 0);
 }
 
 int iwl_sta_rx_agg_stop(struct iwl_priv *priv, struct ieee80211_sta *sta,
@@ -1457,7 +1455,7 @@ int iwl_sta_rx_agg_stop(struct iwl_priv *priv, struct ieee80211_sta *sta,
  memcpy(&sta_cmd, &priv->stations[sta_id].sta, sizeof(struct iwl_addsta_cmd));
  spin_unlock_bh(&priv->sta_lock);
 
- return iwl_send_add_sta(priv, &sta_cmd, CMD_SYNC);
+ return iwl_send_add_sta(priv, &sta_cmd, 0);
 }
 
 
diff --git a/drivers/net/wireless/iwlwifi/dvm/tt.c b/drivers/net/wireless/iwlwifi/dvm/tt.c
index 03f9bc0..acb981a 100644
--- a/drivers/net/wireless/iwlwifi/dvm/tt.c
+++ b/drivers/net/wireless/iwlwifi/dvm/tt.c
@@ -1,6 +1,6 @@
 /******************************************************************************
  *
- * Copyright(c) 2007 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2007 - 2014 Intel Corporation. All rights reserved.
  *
  * Portions of this file are derived from the ipw3945 project, as well
  * as portions of the ieee80211 subsystem header files.
@@ -30,7 +30,6 @@
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/slab.h>
-#include <linux/init.h>
 #include <net/mac80211.h>
 #include "iwl-io.h"
 #include "iwl-modparams.h"
@@ -237,7 +236,7 @@ static void iwl_prepare_ct_kill_task(struct iwl_priv *priv)
 {
  IWL_DEBUG_TEMP(priv, "Prepare to enter IWL_TI_CT_KILL\n");
  /* make request to retrieve statistics information */
- iwl_send_statistics_request(priv, CMD_SYNC, false);
+ iwl_send_statistics_request(priv, 0, false);
  /* Reschedule the ct_kill wait timer */
  mod_timer(&priv->thermal_throttle.ct_kill_waiting_tm,
    jiffies + msecs_to_jiffies(CT_KILL_WAITING_DURATION));
@@ -627,7 +626,7 @@ void iwl_tt_initialize(struct iwl_priv *priv)
  INIT_WORK(&priv->ct_enter, iwl_bg_ct_enter);
  INIT_WORK(&priv->ct_exit, iwl_bg_ct_exit);
 
- if (priv->cfg->base_params->adv_thermal_throttle) {
+ if (priv->lib->adv_thermal_throttle) {
   IWL_DEBUG_TEMP(priv, "Advanced Thermal Throttling\n");
   tt->restriction = kcalloc(IWL_TI_STATE_MAX,
        sizeof(struct iwl_tt_restriction),
diff --git a/drivers/net/wireless/iwlwifi/dvm/tt.h b/drivers/net/wireless/iwlwifi/dvm/tt.h
index 9356c4b..5077265 100644
--- a/drivers/net/wireless/iwlwifi/dvm/tt.h
+++ b/drivers/net/wireless/iwlwifi/dvm/tt.h
@@ -1,6 +1,6 @@
 /******************************************************************************
  *
- * Copyright(c) 2007 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2007 - 2014 Intel Corporation. All rights reserved.
  *
  * Portions of this file are derived from the ipw3945 project, as well
  * as portions of the ieee80211 subsystem header files.
diff --git a/drivers/net/wireless/iwlwifi/dvm/tx.c b/drivers/net/wireless/iwlwifi/dvm/tx.c
index 20e65d3..3255a17 100644
--- a/drivers/net/wireless/iwlwifi/dvm/tx.c
+++ b/drivers/net/wireless/iwlwifi/dvm/tx.c
@@ -2,7 +2,7 @@
  *
  * GPL LICENSE SUMMARY
  *
- * Copyright(c) 2008 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2008 - 2014 Intel Corporation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of version 2 of the GNU General Public License as
@@ -29,7 +29,6 @@
 
 #include <linux/kernel.h>
 #include <linux/module.h>
-#include <linux/init.h>
 #include <linux/sched.h>
 #include <linux/ieee80211.h>
 #include "iwl-io.h"
@@ -83,11 +82,11 @@ static void iwlagn_tx_cmd_build_basic(struct iwl_priv *priv,
  else if (ieee80211_is_back_req(fc))
   tx_flags |= TX_CMD_FLG_ACK_MSK | TX_CMD_FLG_IMM_BA_RSP_MASK;
  else if (info->band == IEEE80211_BAND_2GHZ &&
-   priv->cfg->bt_params &&
-   priv->cfg->bt_params->advanced_bt_coexist &&
+   priv->lib->bt_params &&
+   priv->lib->bt_params->advanced_bt_coexist &&
    (ieee80211_is_auth(fc) || ieee80211_is_assoc_req(fc) ||
    ieee80211_is_reassoc_req(fc) ||
-   skb->protocol == cpu_to_be16(ETH_P_PAE)))
+   info->control.flags & IEEE80211_TX_CTRL_PORT_CTRL_PROTO))
   tx_flags |= TX_CMD_FLG_IGNORE_BT;
 
 
@@ -162,18 +161,6 @@ static void iwlagn_tx_cmd_build_rate(struct iwl_priv *priv,
  if (ieee80211_is_data(fc)) {
   tx_cmd->initial_rate_index = 0;
   tx_cmd->tx_flags |= TX_CMD_FLG_STA_RATE_MSK;
-#ifdef CONFIG_IWLWIFI_DEVICE_TESTMODE
-  if (priv->tm_fixed_rate) {
-   /*
-    * rate overwrite by testmode
-    * we not only send lq command to change rate
-    * we also re-enforce per data pkt base.
-    */
-   tx_cmd->tx_flags &= ~TX_CMD_FLG_STA_RATE_MSK;
-   memcpy(&tx_cmd->rate_n_flags, &priv->tm_fixed_rate,
-          sizeof(tx_cmd->rate_n_flags));
-  }
-#endif
   return;
  } else if (ieee80211_is_back_req(fc))
   tx_cmd->tx_flags |= TX_CMD_FLG_STA_RATE_MSK;
@@ -202,8 +189,8 @@ static void iwlagn_tx_cmd_build_rate(struct iwl_priv *priv,
   rate_flags |= RATE_MCS_CCK_MSK;
 
  /* Set up antennas */
-  if (priv->cfg->bt_params &&
-      priv->cfg->bt_params->advanced_bt_coexist &&
+  if (priv->lib->bt_params &&
+      priv->lib->bt_params->advanced_bt_coexist &&
       priv->bt_full_concurrent) {
   /* operated as 1x1 in full concurrency mode */
   priv->mgmt_tx_ant = iwl_toggle_tx_ant(priv, priv->mgmt_tx_ant,
@@ -380,6 +367,7 @@ int iwlagn_tx_skb(struct iwl_priv *priv,
   goto drop_unlock_priv;
 
  memset(dev_cmd, 0, sizeof(*dev_cmd));
+ dev_cmd->hdr.cmd = REPLY_TX;
  tx_cmd = (struct iwl_tx_cmd *) dev_cmd->payload;
 
  /* Total # bytes to be transmitted */
@@ -414,10 +402,10 @@ int iwlagn_tx_skb(struct iwl_priv *priv,
   /* aggregation is on for this <sta,tid> */
   if (info->flags & IEEE80211_TX_CTL_AMPDU &&
       tid_data->agg.state != IWL_AGG_ON) {
-   IWL_ERR(priv, "TX_CTL_AMPDU while not in AGG:"
-    " Tx flags = 0x%08x, agg.state = %d",
+   IWL_ERR(priv,
+    "TX_CTL_AMPDU while not in AGG: Tx flags = 0x%08x, agg.state = %d\n",
     info->flags, tid_data->agg.state);
-   IWL_ERR(priv, "sta_id = %d, tid = %d seq_num = %d",
+   IWL_ERR(priv, "sta_id = %d, tid = %d seq_num = %d\n",
     sta_id, tid,
     IEEE80211_SEQ_TO_SN(tid_data->seq_number));
    goto drop_unlock_sta;
@@ -428,7 +416,7 @@ int iwlagn_tx_skb(struct iwl_priv *priv,
    */
   if (WARN_ONCE(tid_data->agg.state != IWL_AGG_ON &&
          tid_data->agg.state != IWL_AGG_OFF,
-      "Tx while agg.state = %d", tid_data->agg.state))
+         "Tx while agg.state = %d\n", tid_data->agg.state))
    goto drop_unlock_sta;
 
   seq_number = tid_data->seq_number;
@@ -482,9 +470,6 @@ int iwlagn_tx_skb(struct iwl_priv *priv,
  if (sta_priv && sta_priv->client && !is_agg)
   atomic_inc(&sta_priv->pending_frames);
 
- if (info->flags & IEEE80211_TX_CTL_TX_OFFCHAN)
-  iwl_scan_offchannel_skb(priv);
-
  return 0;
 
 drop_unlock_sta:
@@ -793,8 +778,8 @@ static void iwlagn_check_ratid_empty(struct iwl_priv *priv, int sta_id, u8 tid)
   /* There are no packets for this RA / TID in the HW any more */
   if (tid_data->agg.ssn == tid_data->next_reclaimed) {
    IWL_DEBUG_TX_QUEUES(priv,
-    "Can continue DELBA flow ssn = next_recl ="
-    " %d", tid_data->next_reclaimed);
+    "Can continue DELBA flow ssn = next_recl = %d\n",
+    tid_data->next_reclaimed);
    iwl_trans_txq_disable(priv->trans,
            tid_data->agg.txq_id);
    iwlagn_dealloc_agg_txq(priv, tid_data->agg.txq_id);
@@ -806,8 +791,8 @@ static void iwlagn_check_ratid_empty(struct iwl_priv *priv, int sta_id, u8 tid)
   /* There are no packets for this RA / TID in the HW any more */
   if (tid_data->agg.ssn == tid_data->next_reclaimed) {
    IWL_DEBUG_TX_QUEUES(priv,
-    "Can continue ADDBA flow ssn = next_recl ="
-    " %d", tid_data->next_reclaimed);
+    "Can continue ADDBA flow ssn = next_recl = %d\n",
+    tid_data->next_reclaimed);
    tid_data->agg.state = IWL_AGG_STARTING;
    ieee80211_start_tx_ba_cb_irqsafe(vif, addr, tid);
   }
@@ -978,8 +963,8 @@ static void iwl_rx_reply_tx_agg(struct iwl_priv *priv,
   * notification again.
   */
  if (tx_resp->bt_kill_count && tx_resp->frame_count == 1 &&
-     priv->cfg->bt_params &&
-     priv->cfg->bt_params->advanced_bt_coexist) {
+     priv->lib->bt_params &&
+     priv->lib->bt_params->advanced_bt_coexist) {
   IWL_DEBUG_COEX(priv, "receive reply tx w/ bt_kill\n");
  }
 
@@ -1162,7 +1147,6 @@ int iwlagn_rx_reply_tx(struct iwl_priv *priv, struct iwl_rx_cmd_buffer *rxb,
  struct sk_buff *skb;
  struct iwl_rxon_context *ctx;
  bool is_agg = (txq_id >= IWLAGN_FIRST_AMPDU_QUEUE);
- bool is_offchannel_skb;
 
  tid = (tx_resp->ra_tid & IWLAGN_TX_RES_TID_MSK) >>
   IWLAGN_TX_RES_TID_POS;
@@ -1182,8 +1166,6 @@ int iwlagn_rx_reply_tx(struct iwl_priv *priv, struct iwl_rx_cmd_buffer *rxb,
 
  __skb_queue_head_init(&skbs);
 
- is_offchannel_skb = false;
-
  if (tx_resp->frame_count == 1) {
   u16 next_reclaimed = le16_to_cpu(tx_resp->seq_ctl);
   next_reclaimed = IEEE80211_SEQ_TO_SN(next_reclaimed + 0x10);
@@ -1234,8 +1216,8 @@ int iwlagn_rx_reply_tx(struct iwl_priv *priv, struct iwl_rx_cmd_buffer *rxb,
        ctx->vif->type == NL80211_IFTYPE_STATION) {
     /* block and stop all queues */
     priv->passive_no_rx = true;
-    IWL_DEBUG_TX_QUEUES(priv, "stop all queues: "
-          "passive channel");
+    IWL_DEBUG_TX_QUEUES(priv,
+     "stop all queues: passive channel\n");
     ieee80211_stop_queues(priv->hw);
 
     IWL_DEBUG_TX_REPLY(priv,
@@ -1260,8 +1242,6 @@ int iwlagn_rx_reply_tx(struct iwl_priv *priv, struct iwl_rx_cmd_buffer *rxb,
    if (!is_agg)
     iwlagn_non_agg_tx_status(priv, ctx, hdr->addr1);
 
-   is_offchannel_skb =
-    (info->flags & IEEE80211_TX_CTL_TX_OFFCHAN);
    freed++;
   }
 
@@ -1275,14 +1255,6 @@ int iwlagn_rx_reply_tx(struct iwl_priv *priv, struct iwl_rx_cmd_buffer *rxb,
   if (!is_agg && freed != 1)
    IWL_ERR(priv, "Q: %d, freed %d\n", txq_id, freed);
 
-  /*
-   * An offchannel frame can be send only on the AUX queue, where
-   * there is no aggregation (and reordering) so it only is single
-   * skb is expected to be processed.
-   */
-  if (is_offchannel_skb && freed != 1)
-   IWL_ERR(priv, "OFFCHANNEL SKB freed %d\n", freed);
-
   IWL_DEBUG_TX_REPLY(priv, "TXQ %d status %s (0x%08x)\n", txq_id,
        iwl_get_tx_fail_reason(status), status);
 
@@ -1299,12 +1271,9 @@ int iwlagn_rx_reply_tx(struct iwl_priv *priv, struct iwl_rx_cmd_buffer *rxb,
 
  while (!skb_queue_empty(&skbs)) {
   skb = __skb_dequeue(&skbs);
-  ieee80211_tx_status_ni(priv->hw, skb);
+  ieee80211_tx_status(priv->hw, skb);
  }
 
- if (is_offchannel_skb)
-  iwl_scan_offchannel_skb_status(priv);
-
  return 0;
 }
 
@@ -1322,8 +1291,6 @@ int iwlagn_rx_reply_compressed_ba(struct iwl_priv *priv,
  struct iwl_compressed_ba_resp *ba_resp = (void *)pkt->data;
  struct iwl_ht_agg *agg;
  struct sk_buff_head reclaimed_skbs;
- struct ieee80211_tx_info *info;
- struct ieee80211_hdr *hdr;
  struct sk_buff *skb;
  int sta_id;
  int tid;
@@ -1410,22 +1377,28 @@ int iwlagn_rx_reply_compressed_ba(struct iwl_priv *priv,
  freed = 0;
 
  skb_queue_walk(&reclaimed_skbs, skb) {
-  hdr = (struct ieee80211_hdr *)skb->data;
+  struct ieee80211_hdr *hdr = (void *)skb->data;
+  struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
 
   if (ieee80211_is_data_qos(hdr->frame_control))
    freed++;
   else
    WARN_ON_ONCE(1);
 
-  info = IEEE80211_SKB_CB(skb);
   iwl_trans_free_tx_cmd(priv->trans, info->driver_data[1]);
 
+  memset(&info->status, 0, sizeof(info->status));
+  /* Packet was transmitted successfully, failures come as single
+   * frames because before failing a frame the firmware transmits
+   * it without aggregation at least once.
+   */
+  info->flags |= IEEE80211_TX_STAT_ACK;
+
   if (freed == 1) {
    /* this is the first skb we deliver in this batch */
    /* put the rate scaling data there */
    info = IEEE80211_SKB_CB(skb);
    memset(&info->status, 0, sizeof(info->status));
-   info->flags |= IEEE80211_TX_STAT_ACK;
    info->flags |= IEEE80211_TX_STAT_AMPDU;
    info->status.ampdu_ack_len = ba_resp->txed_2_done;
    info->status.ampdu_len = ba_resp->txed;
@@ -1438,7 +1411,7 @@ int iwlagn_rx_reply_compressed_ba(struct iwl_priv *priv,
 
  while (!skb_queue_empty(&reclaimed_skbs)) {
   skb = __skb_dequeue(&reclaimed_skbs);
-  ieee80211_tx_status_ni(priv->hw, skb);
+  ieee80211_tx_status(priv->hw, skb);
  }
 
  return 0;
diff --git a/drivers/net/wireless/iwlwifi/dvm/ucode.c b/drivers/net/wireless/iwlwifi/dvm/ucode.c
index 0a1cdc5..d5cee15 100644
--- a/drivers/net/wireless/iwlwifi/dvm/ucode.c
+++ b/drivers/net/wireless/iwlwifi/dvm/ucode.c
@@ -2,7 +2,7 @@
  *
  * GPL LICENSE SUMMARY
  *
- * Copyright(c) 2008 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2008 - 2014 Intel Corporation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of version 2 of the GNU General Public License as
@@ -28,7 +28,6 @@
  *****************************************************************************/
 
 #include <linux/kernel.h>
-#include <linux/init.h>
 
 #include "iwl-io.h"
 #include "iwl-agn-hw.h"
@@ -132,8 +131,8 @@ int iwl_init_alive_start(struct iwl_priv *priv)
 {
  int ret;
 
- if (priv->cfg->bt_params &&
-     priv->cfg->bt_params->advanced_bt_coexist) {
+ if (priv->lib->bt_params &&
+     priv->lib->bt_params->advanced_bt_coexist) {
   /*
    * Tell uCode we are ready to perform calibration
    * need to perform this before any calibration
@@ -155,8 +154,8 @@ int iwl_init_alive_start(struct iwl_priv *priv)
   * temperature offset calibration is only needed for runtime ucode,
   * so prepare the value now.
   */
- if (priv->cfg->need_temp_offset_calib) {
-  if (priv->cfg->temp_offset_v2)
+ if (priv->lib->need_temp_offset_calib) {
+  if (priv->lib->temp_offset_v2)
    return iwl_set_temperature_offset_calib_v2(priv);
   else
    return iwl_set_temperature_offset_calib(priv);
@@ -173,7 +172,7 @@ static int iwl_send_wimax_coex(struct iwl_priv *priv)
  memset(&coex_cmd, 0, sizeof(coex_cmd));
 
  return iwl_dvm_send_cmd_pdu(priv,
-    COEX_PRIORITY_TABLE_CMD, CMD_SYNC,
+    COEX_PRIORITY_TABLE_CMD, 0,
     sizeof(coex_cmd), &coex_cmd);
 }
 
@@ -206,7 +205,7 @@ void iwl_send_prio_tbl(struct iwl_priv *priv)
  memcpy(prio_tbl_cmd.prio_tbl, iwl_bt_prio_tbl,
   sizeof(iwl_bt_prio_tbl));
  if (iwl_dvm_send_cmd_pdu(priv,
-    REPLY_BT_COEX_PRIO_TABLE, CMD_SYNC,
+    REPLY_BT_COEX_PRIO_TABLE, 0,
     sizeof(prio_tbl_cmd), &prio_tbl_cmd))
   IWL_ERR(priv, "failed to send BT prio tbl command\n");
 }
@@ -219,7 +218,7 @@ int iwl_send_bt_env(struct iwl_priv *priv, u8 action, u8 type)
  env_cmd.action = action;
  env_cmd.type = type;
  ret = iwl_dvm_send_cmd_pdu(priv,
-          REPLY_BT_COEX_PROT_ENV, CMD_SYNC,
+          REPLY_BT_COEX_PROT_ENV, 0,
           sizeof(env_cmd), &env_cmd);
  if (ret)
   IWL_ERR(priv, "failed to send BT env command\n");
@@ -277,7 +276,7 @@ static int iwl_alive_notify(struct iwl_priv *priv)
  if (ret)
   return ret;
 
- if (!priv->cfg->no_xtal_calib) {
+ if (!priv->lib->no_xtal_calib) {
   ret = iwl_set_Xtal_calib(priv);
   if (ret)
    return ret;
@@ -330,15 +329,14 @@ int iwl_load_ucode_wait_alive(struct iwl_priv *priv,
  enum iwl_ucode_type old_type;
  static const u8 alive_cmd[] = { REPLY_ALIVE };
 
- old_type = priv->cur_ucode;
- priv->cur_ucode = ucode_type;
  fw = iwl_get_ucode_image(priv, ucode_type);
+ if (WARN_ON(!fw))
+  return -EINVAL;
 
+ old_type = priv->cur_ucode;
+ priv->cur_ucode = ucode_type;
  priv->ucode_loaded = false;
 
- if (!fw)
-  return -EINVAL;
-
  iwl_init_notification_wait(&priv->notif_wait, &alive_wait,
        alive_cmd, ARRAY_SIZE(alive_cmd),
        iwl_alive_fn, &alive_data);
@@ -390,7 +388,6 @@ static bool iwlagn_wait_calib(struct iwl_notif_wait_data *notif_wait,
 {
  struct iwl_priv *priv = data;
  struct iwl_calib_hdr *hdr;
- int len;
 
  if (pkt->hdr.cmd != CALIBRATION_RES_NOTIFICATION) {
   WARN_ON(pkt->hdr.cmd != CALIBRATION_COMPLETE_NOTIFICATION);
@@ -398,12 +395,8 @@ static bool iwlagn_wait_calib(struct iwl_notif_wait_data *notif_wait,
  }
 
  hdr = (struct iwl_calib_hdr *)pkt->data;
- len = le32_to_cpu(pkt->len_n_flags) & FH_RSCSR_FRAME_SIZE_MSK;
-
- /* reduce the size by the length field itself */
- len -= sizeof(__le32);
 
- if (iwl_calib_set(priv, hdr, len))
+ if (iwl_calib_set(priv, hdr, iwl_rx_packet_payload_len(pkt)))
   IWL_ERR(priv, "Failed to record calibration data %d\n",
    hdr->op_code);
 
diff --git a/drivers/net/wireless/iwlwifi/iwl-1000.c b/drivers/net/wireless/iwlwifi/iwl-1000.c
index c080ae3..c3817fa 100644
--- a/drivers/net/wireless/iwlwifi/iwl-1000.c
+++ b/drivers/net/wireless/iwlwifi/iwl-1000.c
@@ -1,6 +1,6 @@
 /******************************************************************************
  *
- * Copyright(c) 2008 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2008 - 2014 Intel Corporation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
@@ -60,11 +60,9 @@ static const struct iwl_base_params iwl1000_base_params = {
  .max_ll_items = OTP_MAX_LL_ITEMS_1000,
  .shadow_ram_support = false,
  .led_compensation = 51,
- .support_ct_kill_exit = true,
- .plcp_delta_threshold = IWL_MAX_PLCP_ERR_EXT_LONG_THRESHOLD_DEF,
- .chain_noise_scale = 1000,
  .wd_timeout = IWL_WATCHDOG_DISABLED,
  .max_event_log_size = 128,
+ .scd_chain_ext_wa = true,
 };
 
 static const struct iwl_ht_params iwl1000_ht_params = {
diff --git a/drivers/net/wireless/iwlwifi/iwl-2000.c b/drivers/net/wireless/iwlwifi/iwl-2000.c
index a6ddd2f..21e5d08 100644
--- a/drivers/net/wireless/iwlwifi/iwl-2000.c
+++ b/drivers/net/wireless/iwlwifi/iwl-2000.c
@@ -1,6 +1,6 @@
 /******************************************************************************
  *
- * Copyright(c) 2008 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2008 - 2014 Intel Corporation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
@@ -72,14 +72,10 @@ static const struct iwl_base_params iwl2000_base_params = {
  .max_ll_items = OTP_MAX_LL_ITEMS_2x00,
  .shadow_ram_support = true,
  .led_compensation = 51,
- .adv_thermal_throttle = true,
- .support_ct_kill_exit = true,
- .plcp_delta_threshold = IWL_MAX_PLCP_ERR_THRESHOLD_DEF,
- .chain_noise_scale = 1000,
  .wd_timeout = IWL_DEF_WD_TIMEOUT,
  .max_event_log_size = 512,
  .shadow_reg_enable = false, /* TODO: fix bugs using this feature */
- .hd_v2 = true,
+ .scd_chain_ext_wa = true,
 };
 
 
@@ -90,14 +86,10 @@ static const struct iwl_base_params iwl2030_base_params = {
  .max_ll_items = OTP_MAX_LL_ITEMS_2x00,
  .shadow_ram_support = true,
  .led_compensation = 57,
- .adv_thermal_throttle = true,
- .support_ct_kill_exit = true,
- .plcp_delta_threshold = IWL_MAX_PLCP_ERR_THRESHOLD_DEF,
- .chain_noise_scale = 1000,
  .wd_timeout = IWL_LONG_WD_TIMEOUT,
  .max_event_log_size = 512,
  .shadow_reg_enable = false, /* TODO: fix bugs using this feature */
- .hd_v2 = true,
+ .scd_chain_ext_wa = true,
 };
 
 static const struct iwl_ht_params iwl2000_ht_params = {
@@ -106,16 +98,6 @@ static const struct iwl_ht_params iwl2000_ht_params = {
  .ht40_bands = BIT(IEEE80211_BAND_2GHZ),
 };
 
-static const struct iwl_bt_params iwl2030_bt_params = {
- /* Due to bluetooth, we transmit 2.4 GHz probes only on antenna A */
- .advanced_bt_coexist = true,
- .agg_time_limit = BT_AGG_THRESHOLD_DEF,
- .bt_init_traffic_load = IWL_BT_COEX_TRAFFIC_LOAD_NONE,
- .bt_prio_boost = IWLAGN_BT_PRIO_BOOST_DEFAULT32,
- .bt_sco_disable = true,
- .bt_session_2 = true,
-};
-
 static const struct iwl_eeprom_params iwl20x0_eeprom_params = {
  .regulatory_bands = {
   EEPROM_REG_BAND_1_CHANNELS,
@@ -137,12 +119,10 @@ static const struct iwl_eeprom_params iwl20x0_eeprom_params = {
  .device_family = IWL_DEVICE_FAMILY_2000,  \
  .max_inst_size = IWL60_RTC_INST_SIZE,   \
  .max_data_size = IWL60_RTC_DATA_SIZE,   \
- .nvm_ver = EEPROM_2000_EEPROM_VERSION,  \
- .nvm_calib_ver = EEPROM_2000_TX_POWER_VERSION, \
+ .nvm_ver = EEPROM_2000_EEPROM_VERSION,   \
+ .nvm_calib_ver = EEPROM_2000_TX_POWER_VERSION,  \
  .base_params = &iwl2000_base_params,   \
  .eeprom_params = &iwl20x0_eeprom_params,  \
- .need_temp_offset_calib = true,    \
- .temp_offset_v2 = true,     \
  .led_mode = IWL_LED_RF_STATE
 
 const struct iwl_cfg iwl2000_2bgn_cfg = {
@@ -168,12 +148,8 @@ const struct iwl_cfg iwl2000_2bgn_d_cfg = {
  .nvm_ver = EEPROM_2000_EEPROM_VERSION,  \
  .nvm_calib_ver = EEPROM_2000_TX_POWER_VERSION, \
  .base_params = &iwl2030_base_params,   \
- .bt_params = &iwl2030_bt_params,   \
  .eeprom_params = &iwl20x0_eeprom_params,  \
- .need_temp_offset_calib = true,    \
- .temp_offset_v2 = true,     \
- .led_mode = IWL_LED_RF_STATE,    \
- .adv_pm = true
+ .led_mode = IWL_LED_RF_STATE
 
 const struct iwl_cfg iwl2030_2bgn_cfg = {
  .name = "Intel(R) Centrino(R) Wireless-N 2230 BGN",
@@ -193,10 +169,7 @@ const struct iwl_cfg iwl2030_2bgn_cfg = {
  .nvm_calib_ver = EEPROM_2000_TX_POWER_VERSION, \
  .base_params = &iwl2000_base_params,   \
  .eeprom_params = &iwl20x0_eeprom_params,  \
- .need_temp_offset_calib = true,    \
- .temp_offset_v2 = true,     \
  .led_mode = IWL_LED_RF_STATE,    \
- .adv_pm = true,      \
  .rx_with_siso_diversity = true
 
 const struct iwl_cfg iwl105_bgn_cfg = {
@@ -222,12 +195,8 @@ const struct iwl_cfg iwl105_bgn_d_cfg = {
  .nvm_ver = EEPROM_2000_EEPROM_VERSION,  \
  .nvm_calib_ver = EEPROM_2000_TX_POWER_VERSION, \
  .base_params = &iwl2030_base_params,   \
- .bt_params = &iwl2030_bt_params,   \
  .eeprom_params = &iwl20x0_eeprom_params,  \
- .need_temp_offset_calib = true,    \
- .temp_offset_v2 = true,     \
  .led_mode = IWL_LED_RF_STATE,    \
- .adv_pm = true,      \
  .rx_with_siso_diversity = true
 
 const struct iwl_cfg iwl135_bgn_cfg = {
diff --git a/drivers/net/wireless/iwlwifi/iwl-5000.c b/drivers/net/wireless/iwlwifi/iwl-5000.c
index 403f3f2..332bbed 100644
--- a/drivers/net/wireless/iwlwifi/iwl-5000.c
+++ b/drivers/net/wireless/iwlwifi/iwl-5000.c
@@ -1,6 +1,6 @@
 /******************************************************************************
  *
- * Copyright(c) 2007 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2007 - 2014 Intel Corporation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
@@ -59,11 +59,9 @@ static const struct iwl_base_params iwl5000_base_params = {
  .num_of_queues = IWLAGN_NUM_QUEUES,
  .pll_cfg_val = CSR50_ANA_PLL_CFG_VAL,
  .led_compensation = 51,
- .plcp_delta_threshold = IWL_MAX_PLCP_ERR_LONG_THRESHOLD_DEF,
- .chain_noise_scale = 1000,
  .wd_timeout = IWL_WATCHDOG_DISABLED,
  .max_event_log_size = 512,
- .no_idle_support = true,
+ .scd_chain_ext_wa = true,
 };
 
 static const struct iwl_ht_params iwl5000_ht_params = {
@@ -159,7 +157,6 @@ const struct iwl_cfg iwl5350_agn_cfg = {
  .nvm_calib_ver = EEPROM_5050_TX_POWER_VERSION, \
  .base_params = &iwl5000_base_params,   \
  .eeprom_params = &iwl5000_eeprom_params,  \
- .no_xtal_calib = true,     \
  .led_mode = IWL_LED_BLINK,    \
  .internal_wimax_coex = true
 
diff --git a/drivers/net/wireless/iwlwifi/iwl-6000.c b/drivers/net/wireless/iwlwifi/iwl-6000.c
index 5282088..8f2c3c8 100644
--- a/drivers/net/wireless/iwlwifi/iwl-6000.c
+++ b/drivers/net/wireless/iwlwifi/iwl-6000.c
@@ -1,6 +1,6 @@
 /******************************************************************************
  *
- * Copyright(c) 2008 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2008 - 2014 Intel Corporation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
@@ -82,13 +82,10 @@ static const struct iwl_base_params iwl6000_base_params = {
  .max_ll_items = OTP_MAX_LL_ITEMS_6x00,
  .shadow_ram_support = true,
  .led_compensation = 51,
- .adv_thermal_throttle = true,
- .support_ct_kill_exit = true,
- .plcp_delta_threshold = IWL_MAX_PLCP_ERR_THRESHOLD_DEF,
- .chain_noise_scale = 1000,
  .wd_timeout = IWL_DEF_WD_TIMEOUT,
  .max_event_log_size = 512,
  .shadow_reg_enable = false, /* TODO: fix bugs using this feature */
+ .scd_chain_ext_wa = true,
 };
 
 static const struct iwl_base_params iwl6050_base_params = {
@@ -98,13 +95,10 @@ static const struct iwl_base_params iwl6050_base_params = {
  .max_ll_items = OTP_MAX_LL_ITEMS_6x50,
  .shadow_ram_support = true,
  .led_compensation = 51,
- .adv_thermal_throttle = true,
- .support_ct_kill_exit = true,
- .plcp_delta_threshold = IWL_MAX_PLCP_ERR_THRESHOLD_DEF,
- .chain_noise_scale = 1500,
  .wd_timeout = IWL_DEF_WD_TIMEOUT,
  .max_event_log_size = 1024,
  .shadow_reg_enable = false, /* TODO: fix bugs using this feature */
+ .scd_chain_ext_wa = true,
 };
 
 static const struct iwl_base_params iwl6000_g2_base_params = {
@@ -114,13 +108,10 @@ static const struct iwl_base_params iwl6000_g2_base_params = {
  .max_ll_items = OTP_MAX_LL_ITEMS_6x00,
  .shadow_ram_support = true,
  .led_compensation = 57,
- .adv_thermal_throttle = true,
- .support_ct_kill_exit = true,
- .plcp_delta_threshold = IWL_MAX_PLCP_ERR_THRESHOLD_DEF,
- .chain_noise_scale = 1000,
  .wd_timeout = IWL_LONG_WD_TIMEOUT,
  .max_event_log_size = 512,
  .shadow_reg_enable = false, /* TODO: fix bugs using this feature */
+ .scd_chain_ext_wa = true,
 };
 
 static const struct iwl_ht_params iwl6000_ht_params = {
@@ -129,15 +120,6 @@ static const struct iwl_ht_params iwl6000_ht_params = {
  .ht40_bands = BIT(IEEE80211_BAND_2GHZ) | BIT(IEEE80211_BAND_5GHZ),
 };
 
-static const struct iwl_bt_params iwl6000_bt_params = {
- /* Due to bluetooth, we transmit 2.4 GHz probes only on antenna A */
- .advanced_bt_coexist = true,
- .agg_time_limit = BT_AGG_THRESHOLD_DEF,
- .bt_init_traffic_load = IWL_BT_COEX_TRAFFIC_LOAD_NONE,
- .bt_prio_boost = IWLAGN_BT_PRIO_BOOST_DEFAULT,
- .bt_sco_disable = true,
-};
-
 static const struct iwl_eeprom_params iwl6000_eeprom_params = {
  .regulatory_bands = {
   EEPROM_REG_BAND_1_CHANNELS,
@@ -163,7 +145,6 @@ static const struct iwl_eeprom_params iwl6000_eeprom_params = {
  .nvm_calib_ver = EEPROM_6005_TX_POWER_VERSION, \
  .base_params = &iwl6000_g2_base_params,   \
  .eeprom_params = &iwl6000_eeprom_params,  \
- .need_temp_offset_calib = true,    \
  .led_mode = IWL_LED_RF_STATE
 
 const struct iwl_cfg iwl6005_2agn_cfg = {
@@ -217,11 +198,8 @@ const struct iwl_cfg iwl6005_2agn_mow2_cfg = {
  .nvm_ver = EEPROM_6030_EEPROM_VERSION,  \
  .nvm_calib_ver = EEPROM_6030_TX_POWER_VERSION, \
  .base_params = &iwl6000_g2_base_params,   \
- .bt_params = &iwl6000_bt_params,   \
  .eeprom_params = &iwl6000_eeprom_params,  \
- .need_temp_offset_calib = true,    \
- .led_mode = IWL_LED_RF_STATE,    \
- .adv_pm = true      \
+ .led_mode = IWL_LED_RF_STATE
 
 const struct iwl_cfg iwl6030_2agn_cfg = {
  .name = "Intel(R) Centrino(R) Advanced-N 6230 AGN",
@@ -256,11 +234,8 @@ const struct iwl_cfg iwl6030_2bg_cfg = {
  .nvm_ver = EEPROM_6030_EEPROM_VERSION,  \
  .nvm_calib_ver = EEPROM_6030_TX_POWER_VERSION, \
  .base_params = &iwl6000_g2_base_params,   \
- .bt_params = &iwl6000_bt_params,   \
  .eeprom_params = &iwl6000_eeprom_params,  \
- .need_temp_offset_calib = true,    \
- .led_mode = IWL_LED_RF_STATE,    \
- .adv_pm = true
+ .led_mode = IWL_LED_RF_STATE
 
 const struct iwl_cfg iwl6035_2agn_cfg = {
  .name = "Intel(R) Centrino(R) Advanced-N 6235 AGN",
diff --git a/drivers/net/wireless/iwlwifi/iwl-7000.c b/drivers/net/wireless/iwlwifi/iwl-7000.c
index 0b892b0..4873006 100644
--- a/drivers/net/wireless/iwlwifi/iwl-7000.c
+++ b/drivers/net/wireless/iwlwifi/iwl-7000.c
@@ -5,7 +5,7 @@
  *
  * GPL LICENSE SUMMARY
  *
- * Copyright(c) 2012 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2012 - 2014 Intel Corporation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of version 2 of the GNU General Public License as
@@ -30,7 +30,7 @@
  *
  * BSD LICENSE
  *
- * Copyright(c) 2012 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2012 - 2014 Intel Corporation. All rights reserved.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -67,22 +67,24 @@
 #include "iwl-agn-hw.h"
 
 /* Highest firmware API version supported */
-#define IWL7260_UCODE_API_MAX 7
-#define IWL3160_UCODE_API_MAX 7
+#define IWL7260_UCODE_API_MAX 9
+#define IWL3160_UCODE_API_MAX 9
 
 /* Oldest version we won't warn about */
-#define IWL7260_UCODE_API_OK 7
-#define IWL3160_UCODE_API_OK 7
+#define IWL7260_UCODE_API_OK 9
+#define IWL3160_UCODE_API_OK 9
 
 /* Lowest firmware API version supported */
-#define IWL7260_UCODE_API_MIN 7
-#define IWL3160_UCODE_API_MIN 7
+#define IWL7260_UCODE_API_MIN 8
+#define IWL3160_UCODE_API_MIN 8
 
 /* NVM versions */
 #define IWL7260_NVM_VERSION  0x0a1d
 #define IWL7260_TX_POWER_VERSION 0xffff /* meaningless */
 #define IWL3160_NVM_VERSION  0x709
 #define IWL3160_TX_POWER_VERSION 0xffff /* meaningless */
+#define IWL7265_NVM_VERSION  0x0a1d
+#define IWL7265_TX_POWER_VERSION 0xffff /* meaningless */
 
 #define IWL7260_FW_PRE "iwlwifi-7260-"
 #define IWL7260_MODULE_FIRMWARE(api) IWL7260_FW_PRE __stringify(api) ".ucode"
@@ -90,23 +92,26 @@
 #define IWL3160_FW_PRE "iwlwifi-3160-"
 #define IWL3160_MODULE_FIRMWARE(api) IWL3160_FW_PRE __stringify(api) ".ucode"
 
+#define IWL7265_FW_PRE "iwlwifi-7265-"
+#define IWL7265_MODULE_FIRMWARE(api) IWL7265_FW_PRE __stringify(api) ".ucode"
+
+#define NVM_HW_SECTION_NUM_FAMILY_7000  0
+
 static const struct iwl_base_params iwl7000_base_params = {
- .eeprom_size = OTP_LOW_IMAGE_SIZE,
+ .eeprom_size = OTP_LOW_IMAGE_SIZE_FAMILY_7000,
  .num_of_queues = IWLAGN_NUM_QUEUES,
  .pll_cfg_val = 0,
  .shadow_ram_support = true,
  .led_compensation = 57,
- .adv_thermal_throttle = true,
- .support_ct_kill_exit = true,
- .plcp_delta_threshold = IWL_MAX_PLCP_ERR_THRESHOLD_DEF,
- .chain_noise_scale = 1000,
  .wd_timeout = IWL_LONG_WD_TIMEOUT,
  .max_event_log_size = 512,
  .shadow_reg_enable = true,
+ .pcie_l1_allowed = true,
+ .apmg_wake_up_wa = true,
 };
 
 static const struct iwl_ht_params iwl7000_ht_params = {
- .use_rts_for_aggregation = true, /* use rts/cts protection */
+ .stbc = true,
  .ht40_bands = BIT(IEEE80211_BAND_2GHZ) | BIT(IEEE80211_BAND_5GHZ),
 };
 
@@ -118,10 +123,8 @@ static const struct iwl_ht_params iwl7000_ht_params = {
  .max_inst_size = IWL60_RTC_INST_SIZE,   \
  .max_data_size = IWL60_RTC_DATA_SIZE,   \
  .base_params = &iwl7000_base_params,   \
- /* TODO: .bt_params? */     \
- .need_temp_offset_calib = true,    \
  .led_mode = IWL_LED_RF_STATE,    \
- .adv_pm = true      \
+ .nvm_hw_section_num = NVM_HW_SECTION_NUM_FAMILY_7000
 
 
 const struct iwl_cfg iwl7260_2ac_cfg = {
@@ -131,6 +134,20 @@ const struct iwl_cfg iwl7260_2ac_cfg = {
  .ht_params = &iwl7000_ht_params,
  .nvm_ver = IWL7260_NVM_VERSION,
  .nvm_calib_ver = IWL7260_TX_POWER_VERSION,
+ .host_interrupt_operation_mode = true,
+ .lp_xtal_workaround = true,
+};
+
+const struct iwl_cfg iwl7260_2ac_cfg_high_temp = {
+ .name = "Intel(R) Dual Band Wireless AC 7260",
+ .fw_name_pre = IWL7260_FW_PRE,
+ IWL_DEVICE_7000,
+ .ht_params = &iwl7000_ht_params,
+ .nvm_ver = IWL7260_NVM_VERSION,
+ .nvm_calib_ver = IWL7260_TX_POWER_VERSION,
+ .high_temp = true,
+ .host_interrupt_operation_mode = true,
+ .lp_xtal_workaround = true,
 };
 
 const struct iwl_cfg iwl7260_2n_cfg = {
@@ -140,6 +157,8 @@ const struct iwl_cfg iwl7260_2n_cfg = {
  .ht_params = &iwl7000_ht_params,
  .nvm_ver = IWL7260_NVM_VERSION,
  .nvm_calib_ver = IWL7260_TX_POWER_VERSION,
+ .host_interrupt_operation_mode = true,
+ .lp_xtal_workaround = true,
 };
 
 const struct iwl_cfg iwl7260_n_cfg = {
@@ -149,6 +168,8 @@ const struct iwl_cfg iwl7260_n_cfg = {
  .ht_params = &iwl7000_ht_params,
  .nvm_ver = IWL7260_NVM_VERSION,
  .nvm_calib_ver = IWL7260_TX_POWER_VERSION,
+ .host_interrupt_operation_mode = true,
+ .lp_xtal_workaround = true,
 };
 
 const struct iwl_cfg iwl3160_2ac_cfg = {
@@ -158,6 +179,7 @@ const struct iwl_cfg iwl3160_2ac_cfg = {
  .ht_params = &iwl7000_ht_params,
  .nvm_ver = IWL3160_NVM_VERSION,
  .nvm_calib_ver = IWL3160_TX_POWER_VERSION,
+ .host_interrupt_operation_mode = true,
 };
 
 const struct iwl_cfg iwl3160_2n_cfg = {
@@ -167,6 +189,7 @@ const struct iwl_cfg iwl3160_2n_cfg = {
  .ht_params = &iwl7000_ht_params,
  .nvm_ver = IWL3160_NVM_VERSION,
  .nvm_calib_ver = IWL3160_TX_POWER_VERSION,
+ .host_interrupt_operation_mode = true,
 };
 
 const struct iwl_cfg iwl3160_n_cfg = {
@@ -176,7 +199,50 @@ const struct iwl_cfg iwl3160_n_cfg = {
  .ht_params = &iwl7000_ht_params,
  .nvm_ver = IWL3160_NVM_VERSION,
  .nvm_calib_ver = IWL3160_TX_POWER_VERSION,
+ .host_interrupt_operation_mode = true,
+};
+
+static const struct iwl_pwr_tx_backoff iwl7265_pwr_tx_backoffs[] = {
+ {.pwr = 1600, .backoff = 0},
+ {.pwr = 1300, .backoff = 467},
+ {.pwr = 900,  .backoff = 1900},
+ {.pwr = 800, .backoff = 2630},
+ {.pwr = 700, .backoff = 3720},
+ {.pwr = 600, .backoff = 5550},
+ {.pwr = 500, .backoff = 9350},
+ {0},
+};
+
+const struct iwl_cfg iwl7265_2ac_cfg = {
+ .name = "Intel(R) Dual Band Wireless AC 7265",
+ .fw_name_pre = IWL7265_FW_PRE,
+ IWL_DEVICE_7000,
+ .ht_params = &iwl7000_ht_params,
+ .nvm_ver = IWL7265_NVM_VERSION,
+ .nvm_calib_ver = IWL7265_TX_POWER_VERSION,
+ .pwr_tx_backoffs = iwl7265_pwr_tx_backoffs,
+};
+
+const struct iwl_cfg iwl7265_2n_cfg = {
+ .name = "Intel(R) Dual Band Wireless N 7265",
+ .fw_name_pre = IWL7265_FW_PRE,
+ IWL_DEVICE_7000,
+ .ht_params = &iwl7000_ht_params,
+ .nvm_ver = IWL7265_NVM_VERSION,
+ .nvm_calib_ver = IWL7265_TX_POWER_VERSION,
+ .pwr_tx_backoffs = iwl7265_pwr_tx_backoffs,
+};
+
+const struct iwl_cfg iwl7265_n_cfg = {
+ .name = "Intel(R) Wireless N 7265",
+ .fw_name_pre = IWL7265_FW_PRE,
+ IWL_DEVICE_7000,
+ .ht_params = &iwl7000_ht_params,
+ .nvm_ver = IWL7265_NVM_VERSION,
+ .nvm_calib_ver = IWL7265_TX_POWER_VERSION,
+ .pwr_tx_backoffs = iwl7265_pwr_tx_backoffs,
 };
 
 MODULE_FIRMWARE(IWL7260_MODULE_FIRMWARE(IWL7260_UCODE_API_OK));
 MODULE_FIRMWARE(IWL3160_MODULE_FIRMWARE(IWL3160_UCODE_API_OK));
+MODULE_FIRMWARE(IWL7265_MODULE_FIRMWARE(IWL7260_UCODE_API_OK));
diff --git a/drivers/net/wireless/iwlwifi/iwl-8000.c b/drivers/net/wireless/iwlwifi/iwl-8000.c
new file mode 100644
index 0000000..51c4153
--- /dev/null
+++ b/drivers/net/wireless/iwlwifi/iwl-8000.c
@@ -0,0 +1,135 @@
+/******************************************************************************
+ *
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ * redistributing this file, you may do so under either license.
+ *
+ * GPL LICENSE SUMMARY
+ *
+ * Copyright(c) 2014 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110,
+ * USA
+ *
+ * The full GNU General Public License is included in this distribution
+ * in the file called COPYING.
+ *
+ * Contact Information:
+ *  Intel Linux Wireless <ilw@linux.intel.com>
+ * Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497
+ *
+ * BSD LICENSE
+ *
+ * Copyright(c) 2014 Intel Corporation. All rights reserved.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *  * Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *  * Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *  * Neither the name Intel Corporation nor the names of its
+ *    contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *****************************************************************************/
+
+#include <linux/module.h>
+#include <linux/stringify.h>
+#include "iwl-config.h"
+#include "iwl-agn-hw.h"
+
+/* Highest firmware API version supported */
+#define IWL8000_UCODE_API_MAX 8
+
+/* Oldest version we won't warn about */
+#define IWL8000_UCODE_API_OK 8
+
+/* Lowest firmware API version supported */
+#define IWL8000_UCODE_API_MIN 8
+
+/* NVM versions */
+#define IWL8000_NVM_VERSION  0x0a1d
+#define IWL8000_TX_POWER_VERSION 0xffff /* meaningless */
+
+#define IWL8000_FW_PRE "iwlwifi-8000-"
+#define IWL8000_MODULE_FIRMWARE(api) IWL8000_FW_PRE __stringify(api) ".ucode"
+
+#define NVM_HW_SECTION_NUM_FAMILY_8000  10
+#define DEFAULT_NVM_FILE_FAMILY_8000  "iwl_nvm_8000.bin"
+
+static const struct iwl_base_params iwl8000_base_params = {
+ .eeprom_size = OTP_LOW_IMAGE_SIZE_FAMILY_8000,
+ .num_of_queues = IWLAGN_NUM_QUEUES,
+ .pll_cfg_val = 0,
+ .shadow_ram_support = true,
+ .led_compensation = 57,
+ .wd_timeout = IWL_LONG_WD_TIMEOUT,
+ .max_event_log_size = 512,
+ .shadow_reg_enable = true,
+ .pcie_l1_allowed = true,
+};
+
+static const struct iwl_ht_params iwl8000_ht_params = {
+ .ht40_bands = BIT(IEEE80211_BAND_2GHZ) | BIT(IEEE80211_BAND_5GHZ),
+};
+
+#define IWL_DEVICE_8000      \
+ .ucode_api_max = IWL8000_UCODE_API_MAX,   \
+ .ucode_api_ok = IWL8000_UCODE_API_OK,   \
+ .ucode_api_min = IWL8000_UCODE_API_MIN,   \
+ .device_family = IWL_DEVICE_FAMILY_8000,  \
+ .max_inst_size = IWL60_RTC_INST_SIZE,   \
+ .max_data_size = IWL60_RTC_DATA_SIZE,   \
+ .base_params = &iwl8000_base_params,   \
+ .led_mode = IWL_LED_RF_STATE,    \
+ .nvm_hw_section_num = NVM_HW_SECTION_NUM_FAMILY_8000
+
+const struct iwl_cfg iwl8260_2ac_cfg = {
+ .name = "Intel(R) Dual Band Wireless AC 8260",
+ .fw_name_pre = IWL8000_FW_PRE,
+ IWL_DEVICE_8000,
+ .ht_params = &iwl8000_ht_params,
+ .nvm_ver = IWL8000_NVM_VERSION,
+ .nvm_calib_ver = IWL8000_TX_POWER_VERSION,
+ .default_nvm_file = DEFAULT_NVM_FILE_FAMILY_8000,
+};
+
+const struct iwl_cfg iwl8260_n_cfg = {
+ .name = "Intel(R) Dual Band Wireless-AC 8260",
+ .fw_name_pre = IWL8000_FW_PRE,
+ IWL_DEVICE_8000,
+ .ht_params = &iwl8000_ht_params,
+ .nvm_ver = IWL8000_NVM_VERSION,
+ .nvm_calib_ver = IWL8000_TX_POWER_VERSION,
+ .default_nvm_file = DEFAULT_NVM_FILE_FAMILY_8000,
+};
+
+MODULE_FIRMWARE(IWL8000_MODULE_FIRMWARE(IWL8000_UCODE_API_OK));
diff --git a/drivers/net/wireless/iwlwifi/iwl-agn-hw.h b/drivers/net/wireless/iwlwifi/iwl-agn-hw.h
index 6d73f94..04a483d 100644
--- a/drivers/net/wireless/iwlwifi/iwl-agn-hw.h
+++ b/drivers/net/wireless/iwlwifi/iwl-agn-hw.h
@@ -5,7 +5,7 @@
  *
  * GPL LICENSE SUMMARY
  *
- * Copyright(c) 2007 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2007 - 2014 Intel Corporation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of version 2 of the GNU General Public License as
@@ -30,7 +30,7 @@
  *
  * BSD LICENSE
  *
- * Copyright(c) 2005 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2005 - 2014 Intel Corporation. All rights reserved.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -102,9 +102,7 @@
 
 /* EEPROM */
 #define IWLAGN_EEPROM_IMG_SIZE  2048
-/* OTP */
-/* lower blocks contain EEPROM image and calibration data */
-#define OTP_LOW_IMAGE_SIZE  (2 * 512 * sizeof(u16)) /* 2 KB */
+
 /* high blocks contain PAPD data */
 #define OTP_HIGH_IMAGE_SIZE_6x00        (6 * 512 * sizeof(u16)) /* 6 KB */
 #define OTP_HIGH_IMAGE_SIZE_1000        (0x200 * sizeof(u16)) /* 1024 bytes */
diff --git a/drivers/net/wireless/iwlwifi/iwl-config.h b/drivers/net/wireless/iwlwifi/iwl-config.h
index 44e3370..b704790 100644
--- a/drivers/net/wireless/iwlwifi/iwl-config.h
+++ b/drivers/net/wireless/iwlwifi/iwl-config.h
@@ -5,7 +5,7 @@
  *
  * GPL LICENSE SUMMARY
  *
- * Copyright(c) 2007 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2007 - 2014 Intel Corporation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of version 2 of the GNU General Public License as
@@ -30,7 +30,7 @@
  *
  * BSD LICENSE
  *
- * Copyright(c) 2005 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2005 - 2014 Intel Corporation. All rights reserved.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -84,6 +84,7 @@ enum iwl_device_family {
  IWL_DEVICE_FAMILY_6050,
  IWL_DEVICE_FAMILY_6150,
  IWL_DEVICE_FAMILY_7000,
+ IWL_DEVICE_FAMILY_8000,
 };
 
 /*
@@ -129,6 +130,12 @@ enum iwl_led_mode {
 #define ANT_BC  (ANT_B | ANT_C)
 #define ANT_ABC  (ANT_A | ANT_B | ANT_C)
 
+static inline u8 num_of_ant(u8 mask)
+{
+ return  !!((mask) & ANT_A) +
+  !!((mask) & ANT_B) +
+  !!((mask) & ANT_C);
+}
 
 /*
  * @max_ll_items: max number of OTP blocks
@@ -136,17 +143,12 @@ enum iwl_led_mode {
  * @led_compensation: compensate on the led on/off time per HW according
  * to the deviation to achieve the desired led frequency.
  * The detail algorithm is described in iwl-led.c
- * @chain_noise_num_beacons: number of beacons used to compute chain noise
- * @adv_thermal_throttle: support advance thermal throttle
- * @support_ct_kill_exit: support ct kill exit condition
- * @plcp_delta_threshold: plcp error rate threshold used to trigger
- * radio tuning when there is a high receiving plcp error rate
- * @chain_noise_scale: default chain noise scale used for gain computation
  * @wd_timeout: TX queues watchdog timeout
  * @max_event_log_size: size of event log buffer size for ucode event logging
  * @shadow_reg_enable: HW shadow register support
- * @hd_v2: v2 of enhanced sensitivity value, used for 2000 series and up
- * @no_idle_support: do not support idle mode
+ * @apmg_wake_up_wa: should the MAC access REQ be asserted when a command
+ * is in flight. This is due to a HW bug in 7260, 3160 and 7265.
+ * @scd_chain_ext_wa: should the chain extension feature in SCD be disabled.
  */
 struct iwl_base_params {
  int eeprom_size;
@@ -157,40 +159,23 @@ struct iwl_base_params {
  const u16 max_ll_items;
  const bool shadow_ram_support;
  u16 led_compensation;
- bool adv_thermal_throttle;
- bool support_ct_kill_exit;
- u8 plcp_delta_threshold;
- s32 chain_noise_scale;
  unsigned int wd_timeout;
  u32 max_event_log_size;
  const bool shadow_reg_enable;
- const bool hd_v2;
- const bool no_idle_support;
-};
-
-/*
- * @advanced_bt_coexist: support advanced bt coexist
- * @bt_init_traffic_load: specify initial bt traffic load
- * @bt_prio_boost: default bt priority boost value
- * @agg_time_limit: maximum number of uSec in aggregation
- * @bt_sco_disable: uCode should not response to BT in SCO/ESCO mode
- */
-struct iwl_bt_params {
- bool advanced_bt_coexist;
- u8 bt_init_traffic_load;
- u32 bt_prio_boost;
- u16 agg_time_limit;
- bool bt_sco_disable;
- bool bt_session_2;
+ const bool pcie_l1_allowed;
+ const bool apmg_wake_up_wa;
+ const bool scd_chain_ext_wa;
 };
 
 /*
+ * @stbc: support Tx STBC and 1*SS Rx STBC
  * @use_rts_for_aggregation: use rts/cts protection for HT traffic
  * @ht40_bands: bitmap of bands (using %IEEE80211_BAND_*) that support HT40
  */
 struct iwl_ht_params {
  enum ieee80211_smps_mode smps_mode;
  const bool ht_greenfield_support; /* if used set to true */
+ const bool stbc;
  bool use_rts_for_aggregation;
  u8 ht40_bands;
 };
@@ -208,11 +193,25 @@ struct iwl_ht_params {
 #define EEPROM_6000_REG_BAND_24_HT40_CHANNELS 0x80
 #define EEPROM_REGULATORY_BAND_NO_HT40  0
 
+/* lower blocks contain EEPROM image and calibration data */
+#define OTP_LOW_IMAGE_SIZE  (2 * 512 * sizeof(u16)) /* 2 KB */
+#define OTP_LOW_IMAGE_SIZE_FAMILY_7000 (16 * 512 * sizeof(u16)) /* 16 KB */
+#define OTP_LOW_IMAGE_SIZE_FAMILY_8000 (32 * 512 * sizeof(u16)) /* 32 KB */
+
 struct iwl_eeprom_params {
  const u8 regulatory_bands[7];
  bool enhanced_txpower;
 };
 
+/* Tx-backoff power threshold
+ * @pwr: The power limit in mw
+ * @backoff: The tx-backoff in uSec
+ */
+struct iwl_pwr_tx_backoff {
+ u32 pwr;
+ u32 backoff;
+};
+
 /**
  * struct iwl_cfg
  * @name: Offical name of the device
@@ -231,16 +230,16 @@ struct iwl_eeprom_params {
  * @nvm_calib_ver: NVM calibration version
  * @lib: pointer to the lib ops
  * @base_params: pointer to basic parameters
- * @ht_params: point to ht patameters
- * @bt_params: pointer to bt parameters
- * @need_temp_offset_calib: need to perform temperature offset calibration
- * @no_xtal_calib: some devices do not need crystal calibration data,
- * don't send it to those
+ * @ht_params: point to ht parameters
  * @led_mode: 0=blinking, 1=On(RF On)/Off(RF Off)
- * @adv_pm: advance power management
  * @rx_with_siso_diversity: 1x1 device with rx antenna diversity
  * @internal_wimax_coex: internal wifi/wimax combo device
- * @temp_offset_v2: support v2 of temperature offset calibration
+ * @high_temp: Is this NIC is designated to be in high temperature.
+ * @host_interrupt_operation_mode: device needs host interrupt operation
+ * mode set
+ * @d0i3: device uses d0i3 instead of d3
+ * @nvm_hw_section_num: the ID of the HW NVM section
+ * @pwr_tx_backoffs: translation table between power limits and backoffs
  *
  * We enable the driver to be backward compatible wrt. hardware features.
  * API differences in uCode shouldn't be handled here but through TLVs
@@ -258,26 +257,31 @@ struct iwl_cfg {
  const u32 max_inst_size;
  u8   valid_tx_ant;
  u8   valid_rx_ant;
+ bool bt_shared_single_ant;
  u16  nvm_ver;
  u16  nvm_calib_ver;
  /* params not likely to change within a device family */
  const struct iwl_base_params *base_params;
  /* params likely to change within a device family */
  const struct iwl_ht_params *ht_params;
- const struct iwl_bt_params *bt_params;
  const struct iwl_eeprom_params *eeprom_params;
- const bool need_temp_offset_calib; /* if used set to true */
- const bool no_xtal_calib;
  enum iwl_led_mode led_mode;
- const bool adv_pm;
  const bool rx_with_siso_diversity;
  const bool internal_wimax_coex;
- const bool temp_offset_v2;
+ const bool host_interrupt_operation_mode;
+ bool high_temp;
+ bool d0i3;
+ u8   nvm_hw_section_num;
+ bool lp_xtal_workaround;
+ const struct iwl_pwr_tx_backoff *pwr_tx_backoffs;
+ bool no_power_up_nic_in_init;
+ const char *default_nvm_file;
 };
 
 /*
  * This list declares the config structures for all devices.
  */
+#if IS_ENABLED(CONFIG_IWLDVM)
 extern const struct iwl_cfg iwl5300_agn_cfg;
 extern const struct iwl_cfg iwl5100_agn_cfg;
 extern const struct iwl_cfg iwl5350_agn_cfg;
@@ -320,11 +324,20 @@ extern const struct iwl_cfg iwl6035_2agn_sff_cfg;
 extern const struct iwl_cfg iwl105_bgn_cfg;
 extern const struct iwl_cfg iwl105_bgn_d_cfg;
 extern const struct iwl_cfg iwl135_bgn_cfg;
+#endif /* CONFIG_IWLDVM */
+#if IS_ENABLED(CONFIG_IWLMVM)
 extern const struct iwl_cfg iwl7260_2ac_cfg;
+extern const struct iwl_cfg iwl7260_2ac_cfg_high_temp;
 extern const struct iwl_cfg iwl7260_2n_cfg;
 extern const struct iwl_cfg iwl7260_n_cfg;
 extern const struct iwl_cfg iwl3160_2ac_cfg;
 extern const struct iwl_cfg iwl3160_2n_cfg;
 extern const struct iwl_cfg iwl3160_n_cfg;
+extern const struct iwl_cfg iwl7265_2ac_cfg;
+extern const struct iwl_cfg iwl7265_2n_cfg;
+extern const struct iwl_cfg iwl7265_n_cfg;
+extern const struct iwl_cfg iwl8260_2ac_cfg;
+extern const struct iwl_cfg iwl8260_n_cfg;
+#endif /* CONFIG_IWLMVM */
 
 #endif /* __IWL_CONFIG_H__ */
diff --git a/drivers/net/wireless/iwlwifi/iwl-csr.h b/drivers/net/wireless/iwlwifi/iwl-csr.h
index 20e845d..fe129c9 100644
--- a/drivers/net/wireless/iwlwifi/iwl-csr.h
+++ b/drivers/net/wireless/iwlwifi/iwl-csr.h
@@ -5,7 +5,7 @@
  *
  * GPL LICENSE SUMMARY
  *
- * Copyright(c) 2005 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2005 - 2014 Intel Corporation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of version 2 of the GNU General Public License as
@@ -30,7 +30,7 @@
  *
  * BSD LICENSE
  *
- * Copyright(c) 2005 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2005 - 2014 Intel Corporation. All rights reserved.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -139,6 +139,13 @@
 #define CSR_ANA_PLL_CFG         (CSR_BASE+0x20c)
 
 /*
+ * CSR HW resources monitor registers
+ */
+#define CSR_MONITOR_CFG_REG  (CSR_BASE+0x214)
+#define CSR_MONITOR_STATUS_REG  (CSR_BASE+0x228)
+#define CSR_MONITOR_XTAL_RESOURCES (0x00000010)
+
+/*
  * CSR Hardware Revision Workaround Register.  Indicates hardware rev;
  * "step" determines CCK backoff for txpower calculation.  Used for 4965 only.
  * See also CSR_HW_REV register.
@@ -173,6 +180,7 @@
 #define CSR_HW_IF_CONFIG_REG_BIT_NIC_READY (0x00400000) /* PCI_OWN_SEM */
 #define CSR_HW_IF_CONFIG_REG_BIT_NIC_PREPARE_DONE (0x02000000) /* ME_OWN */
 #define CSR_HW_IF_CONFIG_REG_PREPARE    (0x08000000) /* WAKE_ME */
+#define CSR_HW_IF_CONFIG_REG_PERSIST_MODE   (0x40000000) /* PERSISTENCE */
 
 #define CSR_INT_PERIODIC_DIS   (0x00) /* disable periodic int*/
 #define CSR_INT_PERIODIC_ENA   (0xFF) /* 255*32 usec ~ 8 msec*/
@@ -198,7 +206,8 @@
      CSR_INT_BIT_RF_KILL | \
      CSR_INT_BIT_SW_RX   | \
      CSR_INT_BIT_WAKEUP  | \
-     CSR_INT_BIT_ALIVE)
+     CSR_INT_BIT_ALIVE   | \
+     CSR_INT_BIT_RX_PERIODIC)
 
 /* interrupt flags in FH (flow handler) (PCI busmaster DMA) */
 #define CSR_FH_INT_BIT_ERR       (1 << 31) /* Error */
@@ -239,6 +248,7 @@
  *         001 -- MAC power-down
  *         010 -- PHY (radio) power-down
  *         011 -- Error
+ *    10:  XTAL ON request
  *   9-6:  SYS_CONFIG
  *         Indicates current system configuration, reflecting pins on chip
  *         as forced high/low by device circuit board.
@@ -270,6 +280,7 @@
 #define CSR_GP_CNTRL_REG_FLAG_INIT_DONE              (0x00000004)
 #define CSR_GP_CNTRL_REG_FLAG_MAC_ACCESS_REQ         (0x00000008)
 #define CSR_GP_CNTRL_REG_FLAG_GOING_TO_SLEEP         (0x00000010)
+#define CSR_GP_CNTRL_REG_FLAG_XTAL_ON       (0x00000400)
 
 #define CSR_GP_CNTRL_REG_VAL_MAC_ACCESS_EN           (0x00000001)
 
@@ -395,6 +406,34 @@
 #define CSR_DRAM_INIT_TBL_WRAP_CHECK (1 << 27)
 
 /*
+ * SHR target access (Shared block memory space)
+ *
+ * Shared internal registers can be accessed directly from PCI bus through SHR
+ * arbiter without need for the MAC HW to be powered up. This is possible due to
+ * indirect read/write via HEEP_CTRL_WRD_PCIEX_CTRL (0xEC) and
+ * HEEP_CTRL_WRD_PCIEX_DATA (0xF4) registers.
+ *
+ * Use iwl_write32()/iwl_read32() family to access these registers. The MAC HW
+ * need not be powered up so no "grab inc access" is required.
+ */
+
+/*
+ * Registers for accessing shared registers (e.g. SHR_APMG_GP1,
+ * SHR_APMG_XTAL_CFG). For example, to read from SHR_APMG_GP1 register (0x1DC),
+ * first, write to the control register:
+ * HEEP_CTRL_WRD_PCIEX_CTRL[15:0] = 0x1DC (offset of the SHR_APMG_GP1 register)
+ * HEEP_CTRL_WRD_PCIEX_CTRL[29:28] = 2 (read access)
+ * second, read from the data register HEEP_CTRL_WRD_PCIEX_DATA[31:0].
+ *
+ * To write the register, first, write to the data register
+ * HEEP_CTRL_WRD_PCIEX_DATA[31:0] and then:
+ * HEEP_CTRL_WRD_PCIEX_CTRL[15:0] = 0x1DC (offset of the SHR_APMG_GP1 register)
+ * HEEP_CTRL_WRD_PCIEX_CTRL[29:28] = 3 (write access)
+ */
+#define HEEP_CTRL_WRD_PCIEX_CTRL_REG (CSR_BASE+0x0ec)
+#define HEEP_CTRL_WRD_PCIEX_DATA_REG (CSR_BASE+0x0f4)
+
+/*
  * HBUS (Host-side Bus)
  *
  * HBUS registers are mapped directly into PCI bus space, but are used
@@ -463,13 +502,29 @@
  * the CSR_INT_COALESCING is an 8 bit register in 32-usec unit
  *
  * default interrupt coalescing timer is 64 x 32 = 2048 usecs
- * default interrupt coalescing calibration timer is 16 x 32 = 512 usecs
  */
 #define IWL_HOST_INT_TIMEOUT_MAX (0xFF)
 #define IWL_HOST_INT_TIMEOUT_DEF (0x40)
 #define IWL_HOST_INT_TIMEOUT_MIN (0x0)
-#define IWL_HOST_INT_CALIB_TIMEOUT_MAX (0xFF)
-#define IWL_HOST_INT_CALIB_TIMEOUT_DEF (0x10)
-#define IWL_HOST_INT_CALIB_TIMEOUT_MIN (0x0)
+#define IWL_HOST_INT_OPER_MODE  BIT(31)
+
+/*****************************************************************************
+ *                        7000/3000 series SHR DTS addresses                 *
+ *****************************************************************************/
+
+/* Diode Results Register Structure: */
+enum dtd_diode_reg {
+ DTS_DIODE_REG_DIG_VAL   = 0x000000FF, /* bits [7:0] */
+ DTS_DIODE_REG_VREF_LOW   = 0x0000FF00, /* bits [15:8] */
+ DTS_DIODE_REG_VREF_HIGH   = 0x00FF0000, /* bits [23:16] */
+ DTS_DIODE_REG_VREF_ID   = 0x03000000, /* bits [25:24] */
+ DTS_DIODE_REG_PASS_ONCE   = 0x80000000, /* bits [31:31] */
+ DTS_DIODE_REG_FLAGS_MSK   = 0xFF000000, /* bits [31:24] */
+/* Those are the masks INSIDE the flags bit-field: */
+ DTS_DIODE_REG_FLAGS_VREFS_ID_POS = 0,
+ DTS_DIODE_REG_FLAGS_VREFS_ID  = 0x00000003, /* bits [1:0] */
+ DTS_DIODE_REG_FLAGS_PASS_ONCE_POS = 7,
+ DTS_DIODE_REG_FLAGS_PASS_ONCE  = 0x00000080, /* bits [7:7] */
+};
 
 #endif /* !__iwl_csr_h__ */
diff --git a/drivers/net/wireless/iwlwifi/iwl-debug.c b/drivers/net/wireless/iwlwifi/iwl-debug.c
index 8a44f59..09feff4 100644
--- a/drivers/net/wireless/iwlwifi/iwl-debug.c
+++ b/drivers/net/wireless/iwlwifi/iwl-debug.c
@@ -61,8 +61,6 @@
  *
  *****************************************************************************/
 
-#define DEBUG
-
 #include <linux/device.h>
 #include <linux/interrupt.h>
 #include <linux/export.h>
@@ -128,8 +126,8 @@ void __iwl_dbg(struct device *dev,
 #ifdef CONFIG_IWLWIFI_DEBUG
  if (iwl_have_debug_level(level) &&
      (!limit || net_ratelimit()))
-  dev_dbg(dev, "%c %s %pV", in_interrupt() ? 'I' : 'U',
-   function, &vaf);
+  dev_printk(KERN_DEBUG, dev, "%c %s %pV",
+      in_interrupt() ? 'I' : 'U', function, &vaf);
 #endif
  trace_iwlwifi_dbg(level, in_interrupt(), function, &vaf);
  va_end(args);
diff --git a/drivers/net/wireless/iwlwifi/iwl-debug.h b/drivers/net/wireless/iwlwifi/iwl-debug.h
index 8cf5db7..2950835 100644
--- a/drivers/net/wireless/iwlwifi/iwl-debug.h
+++ b/drivers/net/wireless/iwlwifi/iwl-debug.h
@@ -1,6 +1,6 @@
 /******************************************************************************
  *
- * Copyright(c) 2003 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2003 - 2014 Intel Corporation. All rights reserved.
  *
  * Portions of this file are derived from the ipw3945 project.
  *
@@ -34,7 +34,11 @@
 
 static inline bool iwl_have_debug_level(u32 level)
 {
+#ifdef CONFIG_IWLWIFI_DEBUG
  return iwlwifi_mod_params.debug_level & level;
+#else
+ return false;
+#endif
 }
 
 void __iwl_err(struct device *dev, bool rfkill_prefix, bool only_trace,
@@ -43,12 +47,32 @@ void __iwl_warn(struct device *dev, const char *fmt, ...) __printf(2, 3);
 void __iwl_info(struct device *dev, const char *fmt, ...) __printf(2, 3);
 void __iwl_crit(struct device *dev, const char *fmt, ...) __printf(2, 3);
 
+/* not all compilers can evaluate strlen() at compile time, so use sizeof() */
+#define CHECK_FOR_NEWLINE(f) BUILD_BUG_ON(f[sizeof(f) - 2] != '\n')
+
 /* No matter what is m (priv, bus, trans), this will work */
-#define IWL_ERR(m, f, a...) __iwl_err((m)->dev, false, false, f, ## a)
-#define IWL_ERR_DEV(d, f, a...) __iwl_err((d), false, false, f, ## a)
-#define IWL_WARN(m, f, a...) __iwl_warn((m)->dev, f, ## a)
-#define IWL_INFO(m, f, a...) __iwl_info((m)->dev, f, ## a)
-#define IWL_CRIT(m, f, a...) __iwl_crit((m)->dev, f, ## a)
+#define IWL_ERR_DEV(d, f, a...)      \
+ do {        \
+  CHECK_FOR_NEWLINE(f);     \
+  __iwl_err((d), false, false, f, ## a);   \
+ } while (0)
+#define IWL_ERR(m, f, a...)      \
+ IWL_ERR_DEV((m)->dev, f, ## a)
+#define IWL_WARN(m, f, a...)      \
+ do {        \
+  CHECK_FOR_NEWLINE(f);     \
+  __iwl_warn((m)->dev, f, ## a);    \
+ } while (0)
+#define IWL_INFO(m, f, a...)      \
+ do {        \
+  CHECK_FOR_NEWLINE(f);     \
+  __iwl_info((m)->dev, f, ## a);    \
+ } while (0)
+#define IWL_CRIT(m, f, a...)      \
+ do {        \
+  CHECK_FOR_NEWLINE(f);     \
+  __iwl_crit((m)->dev, f, ## a);    \
+ } while (0)
 
 #if defined(CONFIG_IWLWIFI_DEBUG) || defined(CONFIG_IWLWIFI_DEVICE_TRACING)
 void __iwl_dbg(struct device *dev,
@@ -68,12 +92,17 @@ do {         \
          DUMP_PREFIX_OFFSET, 16, 1, p, len, 1);  \
 } while (0)
 
+#define __IWL_DEBUG_DEV(dev, level, limit, fmt, args...)  \
+ do {        \
+  CHECK_FOR_NEWLINE(fmt);     \
+  __iwl_dbg(dev, level, limit, __func__, fmt, ##args); \
+ } while (0)
 #define IWL_DEBUG(m, level, fmt, args...)    \
- __iwl_dbg((m)->dev, level, false, __func__, fmt, ##args)
+ __IWL_DEBUG_DEV((m)->dev, level, false, fmt, ##args)
 #define IWL_DEBUG_DEV(dev, level, fmt, args...)    \
- __iwl_dbg((dev), level, false, __func__, fmt, ##args)
+ __IWL_DEBUG_DEV(dev, level, false, fmt, ##args)
 #define IWL_DEBUG_LIMIT(m, level, fmt, args...)    \
- __iwl_dbg((m)->dev, level, true, __func__, fmt, ##args)
+ __IWL_DEBUG_DEV((m)->dev, level, true, fmt, ##args)
 
 #ifdef CONFIG_IWLWIFI_DEBUG
 #define iwl_print_hex_dump(m, level, p, len)    \
@@ -122,6 +151,7 @@ do {                                               \
 /* 0x00000F00 - 0x00000100 */
 #define IWL_DL_POWER  0x00000100
 #define IWL_DL_TEMP  0x00000200
+#define IWL_DL_RPM  0x00000400
 #define IWL_DL_SCAN  0x00000800
 /* 0x0000F000 - 0x00001000 */
 #define IWL_DL_ASSOC  0x00001000
@@ -141,6 +171,7 @@ do {                                               \
 #define IWL_DL_RX  0x01000000
 #define IWL_DL_ISR  0x02000000
 #define IWL_DL_HT  0x04000000
+#define IWL_DL_EXTERNAL  0x08000000
 /* 0xF0000000 - 0x10000000 */
 #define IWL_DL_11H  0x10000000
 #define IWL_DL_STATS  0x20000000
@@ -149,6 +180,7 @@ do {                                               \
 
 #define IWL_DEBUG_INFO(p, f, a...) IWL_DEBUG(p, IWL_DL_INFO, f, ## a)
 #define IWL_DEBUG_MAC80211(p, f, a...) IWL_DEBUG(p, IWL_DL_MAC80211, f, ## a)
+#define IWL_DEBUG_EXTERNAL(p, f, a...) IWL_DEBUG(p, IWL_DL_EXTERNAL, f, ## a)
 #define IWL_DEBUG_TEMP(p, f, a...) IWL_DEBUG(p, IWL_DL_TEMP, f, ## a)
 #define IWL_DEBUG_SCAN(p, f, a...) IWL_DEBUG(p, IWL_DL_SCAN, f, ## a)
 #define IWL_DEBUG_RX(p, f, a...) IWL_DEBUG(p, IWL_DL_RX, f, ## a)
@@ -183,5 +215,6 @@ do {                                               \
 #define IWL_DEBUG_RADIO(p, f, a...) IWL_DEBUG(p, IWL_DL_RADIO, f, ## a)
 #define IWL_DEBUG_POWER(p, f, a...) IWL_DEBUG(p, IWL_DL_POWER, f, ## a)
 #define IWL_DEBUG_11H(p, f, a...) IWL_DEBUG(p, IWL_DL_11H, f, ## a)
+#define IWL_DEBUG_RPM(p, f, a...) IWL_DEBUG(p, IWL_DL_RPM, f, ## a)
 
 #endif
diff --git a/drivers/net/wireless/iwlwifi/iwl-devtrace.c b/drivers/net/wireless/iwlwifi/iwl-devtrace.c
index 8f61c71..23e7351 100644
--- a/drivers/net/wireless/iwlwifi/iwl-devtrace.c
+++ b/drivers/net/wireless/iwlwifi/iwl-devtrace.c
@@ -1,6 +1,6 @@
 /******************************************************************************
  *
- * Copyright(c) 2009 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2009 - 2014 Intel Corporation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
diff --git a/drivers/net/wireless/iwlwifi/iwl-devtrace.h b/drivers/net/wireless/iwlwifi/iwl-devtrace.h
index 4491c1c..78bd41b 100644
--- a/drivers/net/wireless/iwlwifi/iwl-devtrace.h
+++ b/drivers/net/wireless/iwlwifi/iwl-devtrace.h
@@ -1,6 +1,6 @@
 /******************************************************************************
  *
- * Copyright(c) 2009 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2009 - 2014 Intel Corporation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
@@ -33,10 +33,11 @@
 static inline bool iwl_trace_data(struct sk_buff *skb)
 {
  struct ieee80211_hdr *hdr = (void *)skb->data;
+ struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
 
- if (ieee80211_is_data(hdr->frame_control))
-  return skb->protocol != cpu_to_be16(ETH_P_PAE);
- return false;
+ if (!ieee80211_is_data(hdr->frame_control))
+  return false;
+ return !(info->control.flags & IEEE80211_TX_CTRL_PORT_CTRL_PROTO);
 }
 
 static inline size_t iwl_rx_trace_len(const struct iwl_trans *trans,
diff --git a/drivers/net/wireless/iwlwifi/iwl-drv.c b/drivers/net/wireless/iwlwifi/iwl-drv.c
index 40fed1f..f2a5c12 100644
--- a/drivers/net/wireless/iwlwifi/iwl-drv.c
+++ b/drivers/net/wireless/iwlwifi/iwl-drv.c
@@ -5,7 +5,7 @@
  *
  * GPL LICENSE SUMMARY
  *
- * Copyright(c) 2007 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2007 - 2014 Intel Corporation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of version 2 of the GNU General Public License as
@@ -30,7 +30,7 @@
  *
  * BSD LICENSE
  *
- * Copyright(c) 2005 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2005 - 2014 Intel Corporation. All rights reserved.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -128,7 +128,7 @@ struct iwl_drv {
  const struct iwl_cfg *cfg;
 
  int fw_index;                   /* firmware we're trying to load */
- char firmware_name[25];         /* name of firmware file to load */
+ char firmware_name[32];         /* name of firmware file to load */
 
  struct completion request_firmware_complete;
 
@@ -237,7 +237,8 @@ static int iwl_request_firmware(struct iwl_drv *drv, bool first)
   return -ENOENT;
  }
 
- sprintf(drv->firmware_name, "%s%s%s", name_pre, tag, ".ucode");
+ snprintf(drv->firmware_name, sizeof(drv->firmware_name), "%s%s.ucode",
+   name_pre, tag);
 
  IWL_DEBUG_INFO(drv, "attempting to load firmware %s'%s'\n",
          (drv->fw_index == UCODE_EXPERIMENTAL_INDEX)
@@ -322,6 +323,41 @@ static void set_sec_offset(struct iwl_firmware_pieces *pieces,
  pieces->img[type].sec[sec].offset = offset;
 }
 
+static int iwl_store_cscheme(struct iwl_fw *fw, const u8 *data, const u32 len)
+{
+ int i, j;
+ struct iwl_fw_cscheme_list *l = (struct iwl_fw_cscheme_list *)data;
+ struct iwl_fw_cipher_scheme *fwcs;
+ struct ieee80211_cipher_scheme *cs;
+ u32 cipher;
+
+ if (len < sizeof(*l) ||
+     len < sizeof(l->size) + l->size * sizeof(l->cs[0]))
+  return -EINVAL;
+
+ for (i = 0, j = 0; i < IWL_UCODE_MAX_CS && i < l->size; i++) {
+  fwcs = &l->cs[j];
+  cipher = le32_to_cpu(fwcs->cipher);
+
+  /* we skip schemes with zero cipher suite selector */
+  if (!cipher)
+   continue;
+
+  cs = &fw->cs[j++];
+  cs->cipher = cipher;
+  cs->iftype = BIT(NL80211_IFTYPE_STATION);
+  cs->hdr_len = fwcs->hdr_len;
+  cs->pn_len = fwcs->pn_len;
+  cs->pn_off = fwcs->pn_off;
+  cs->key_idx_off = fwcs->key_idx_off;
+  cs->key_idx_mask = fwcs->key_idx_mask;
+  cs->key_idx_shift = fwcs->key_idx_shift;
+  cs->mic_len = fwcs->mic_len;
+ }
+
+ return 0;
+}
+
 /*
  * Gets uCode section from tlv.
  */
@@ -368,6 +404,38 @@ static int iwl_set_default_calib(struct iwl_drv *drv, const u8 *data)
  return 0;
 }
 
+static int iwl_set_ucode_api_flags(struct iwl_drv *drv, const u8 *data,
+       struct iwl_ucode_capabilities *capa)
+{
+ const struct iwl_ucode_api *ucode_api = (void *)data;
+ u32 api_index = le32_to_cpu(ucode_api->api_index);
+
+ if (api_index >= IWL_API_ARRAY_SIZE) {
+  IWL_ERR(drv, "api_index larger than supported by driver\n");
+  return -EINVAL;
+ }
+
+ capa->api[api_index] = le32_to_cpu(ucode_api->api_flags);
+
+ return 0;
+}
+
+static int iwl_set_ucode_capabilities(struct iwl_drv *drv, const u8 *data,
+          struct iwl_ucode_capabilities *capa)
+{
+ const struct iwl_ucode_capa *ucode_capa = (void *)data;
+ u32 api_index = le32_to_cpu(ucode_capa->api_index);
+
+ if (api_index >= IWL_CAPABILITIES_ARRAY_SIZE) {
+  IWL_ERR(drv, "api_index larger than supported by driver\n");
+  return -EINVAL;
+ }
+
+ capa->capa[api_index] = le32_to_cpu(ucode_capa->api_capa);
+
+ return 0;
+}
+
 static int iwl_parse_v1_v2_firmware(struct iwl_drv *drv,
         const struct firmware *ucode_raw,
         struct iwl_firmware_pieces *pieces)
@@ -483,6 +551,7 @@ static int iwl_parse_tlv_firmware(struct iwl_drv *drv,
  const u8 *tlv_data;
  char buildstr[25];
  u32 build;
+ int num_of_cpus;
 
  if (len < sizeof(*ucode)) {
   IWL_ERR(drv, "uCode has invalid length: %zd\n", len);
@@ -601,6 +670,18 @@ static int iwl_parse_tlv_firmware(struct iwl_drv *drv,
     */
    capa->flags = le32_to_cpup((__le32 *)tlv_data);
    break;
+  case IWL_UCODE_TLV_API_CHANGES_SET:
+   if (tlv_len != sizeof(struct iwl_ucode_api))
+    goto invalid_tlv_len;
+   if (iwl_set_ucode_api_flags(drv, tlv_data, capa))
+    goto tlv_error;
+   break;
+  case IWL_UCODE_TLV_ENABLED_CAPABILITIES:
+   if (tlv_len != sizeof(struct iwl_ucode_capa))
+    goto invalid_tlv_len;
+   if (iwl_set_ucode_capabilities(drv, tlv_data, capa))
+    goto tlv_error;
+   break;
   case IWL_UCODE_TLV_INIT_EVTLOG_PTR:
    if (tlv_len != sizeof(u32))
     goto invalid_tlv_len;
@@ -691,6 +772,52 @@ static int iwl_parse_tlv_firmware(struct iwl_drv *drv,
    if (tlv_len != sizeof(u32))
     goto invalid_tlv_len;
    drv->fw.phy_config = le32_to_cpup((__le32 *)tlv_data);
+   drv->fw.valid_tx_ant = (drv->fw.phy_config &
+      FW_PHY_CFG_TX_CHAIN) >>
+      FW_PHY_CFG_TX_CHAIN_POS;
+   drv->fw.valid_rx_ant = (drv->fw.phy_config &
+      FW_PHY_CFG_RX_CHAIN) >>
+      FW_PHY_CFG_RX_CHAIN_POS;
+   break;
+   case IWL_UCODE_TLV_SECURE_SEC_RT:
+   iwl_store_ucode_sec(pieces, tlv_data, IWL_UCODE_REGULAR,
+         tlv_len);
+   drv->fw.mvm_fw = true;
+   drv->fw.img[IWL_UCODE_REGULAR].is_secure = true;
+   break;
+  case IWL_UCODE_TLV_SECURE_SEC_INIT:
+   iwl_store_ucode_sec(pieces, tlv_data, IWL_UCODE_INIT,
+         tlv_len);
+   drv->fw.mvm_fw = true;
+   drv->fw.img[IWL_UCODE_INIT].is_secure = true;
+   break;
+  case IWL_UCODE_TLV_SECURE_SEC_WOWLAN:
+   iwl_store_ucode_sec(pieces, tlv_data, IWL_UCODE_WOWLAN,
+         tlv_len);
+   drv->fw.mvm_fw = true;
+   drv->fw.img[IWL_UCODE_WOWLAN].is_secure = true;
+   break;
+  case IWL_UCODE_TLV_NUM_OF_CPU:
+   if (tlv_len != sizeof(u32))
+    goto invalid_tlv_len;
+   num_of_cpus =
+    le32_to_cpup((__le32 *)tlv_data);
+
+   if (num_of_cpus == 2) {
+    drv->fw.img[IWL_UCODE_REGULAR].is_dual_cpus =
+     true;
+    drv->fw.img[IWL_UCODE_INIT].is_dual_cpus =
+     true;
+    drv->fw.img[IWL_UCODE_WOWLAN].is_dual_cpus =
+     true;
+   } else if ((num_of_cpus > 2) || (num_of_cpus < 1)) {
+    IWL_ERR(drv, "Driver support upto 2 CPUs\n");
+    return -EINVAL;
+   }
+   break;
+  case IWL_UCODE_TLV_CSCHEME:
+   if (iwl_store_cscheme(&drv->fw, tlv_data, tlv_len))
+    goto invalid_tlv_len;
    break;
   default:
    IWL_DEBUG_INFO(drv, "unknown TLV: %d\n", tlv_type);
@@ -843,7 +970,7 @@ static void iwl_req_fw_callback(const struct firmware *ucode_raw, void *context)
  int i;
  bool load_module = false;
 
- fw->ucode_capa.max_probe_length = 200;
+ fw->ucode_capa.max_probe_length = IWL_DEFAULT_MAX_PROBE_LENGTH;
  fw->ucode_capa.standard_phy_calibration_size =
    IWL_DEFAULT_STANDARD_PHY_CALIBRATE_TBL_SIZE;
 
@@ -1032,8 +1159,10 @@ struct iwl_drv *iwl_drv_start(struct iwl_trans *trans,
  int ret;
 
  drv = kzalloc(sizeof(*drv), GFP_KERNEL);
- if (!drv)
-  return NULL;
+ if (!drv) {
+  ret = -ENOMEM;
+  goto err;
+ }
 
  drv->trans = trans;
  drv->dev = trans->dev;
@@ -1078,7 +1207,7 @@ err_free_dbgfs:
 err_free_drv:
 #endif
  kfree(drv);
-
+err:
  return ERR_PTR(ret);
 }
 
@@ -1111,12 +1240,10 @@ void iwl_drv_stop(struct iwl_drv *drv)
 /* shared module parameters */
 struct iwl_mod_params iwlwifi_mod_params = {
  .restart_fw = true,
- .plcp_check = true,
  .bt_coex_active = true,
  .power_level = IWL_POWER_INDEX_1,
- .bt_ch_announce = true,
- .auto_agg = true,
  .wd_disable = true,
+ .uapsd_disable = false,
  /* the rest are 0 by default */
 };
 IWL_EXPORT_SYMBOL(iwlwifi_mod_params);
@@ -1211,7 +1338,7 @@ module_param_named(swcrypto, iwlwifi_mod_params.sw_crypto, int, S_IRUGO);
 MODULE_PARM_DESC(swcrypto, "using crypto in software (default 0 [hardware])");
 module_param_named(11n_disable, iwlwifi_mod_params.disable_11n, uint, S_IRUGO);
 MODULE_PARM_DESC(11n_disable,
- "disable 11n functionality, bitmap: 1: full, 2: agg TX, 4: agg RX");
+ "disable 11n functionality, bitmap: 1: full, 2: disable agg TX, 4: disable agg RX, 8 enable agg TX");
 module_param_named(amsdu_size_8K, iwlwifi_mod_params.amsdu_size_8K,
      int, S_IRUGO);
 MODULE_PARM_DESC(amsdu_size_8K, "enable 8K amsdu size (default 0)");
@@ -1223,18 +1350,16 @@ module_param_named(antenna_coupling, iwlwifi_mod_params.ant_coupling,
 MODULE_PARM_DESC(antenna_coupling,
    "specify antenna coupling in dB (defualt: 0 dB)");
 
-module_param_named(bt_ch_inhibition, iwlwifi_mod_params.bt_ch_announce,
-     bool, S_IRUGO);
-MODULE_PARM_DESC(bt_ch_inhibition,
-   "Enable BT channel inhibition (default: enable)");
-
-module_param_named(plcp_check, iwlwifi_mod_params.plcp_check, bool, S_IRUGO);
-MODULE_PARM_DESC(plcp_check, "Check plcp health (default: 1 [enabled])");
-
 module_param_named(wd_disable, iwlwifi_mod_params.wd_disable, int, S_IRUGO);
 MODULE_PARM_DESC(wd_disable,
-  "Disable stuck queue watchdog timer 0=system default, "
-  "1=disable, 2=enable (default: 0)");
+  "Disable stuck queue watchdog timer 0=system default, 1=disable (default: 1)");
+
+module_param_named(nvm_file, iwlwifi_mod_params.nvm_file, charp, S_IRUGO);
+MODULE_PARM_DESC(nvm_file, "NVM file name");
+
+module_param_named(uapsd_disable, iwlwifi_mod_params.uapsd_disable,
+     bool, S_IRUGO);
+MODULE_PARM_DESC(uapsd_disable, "disable U-APSD functionality (default: N)");
 
 /*
  * set bt_coex_active to true, uCode will do kill/defer
@@ -1269,8 +1394,3 @@ module_param_named(power_level, iwlwifi_mod_params.power_level,
   int, S_IRUGO);
 MODULE_PARM_DESC(power_level,
    "default power save level (range from 1 - 5, default: 1)");
-
-module_param_named(auto_agg, iwlwifi_mod_params.auto_agg,
-  bool, S_IRUGO);
-MODULE_PARM_DESC(auto_agg,
-   "enable agg w/o check traffic load (default: enable)");
diff --git a/drivers/net/wireless/iwlwifi/iwl-drv.h b/drivers/net/wireless/iwlwifi/iwl-drv.h
index 7d14509..3c72cb7 100644
--- a/drivers/net/wireless/iwlwifi/iwl-drv.h
+++ b/drivers/net/wireless/iwlwifi/iwl-drv.h
@@ -5,7 +5,7 @@
  *
  * GPL LICENSE SUMMARY
  *
- * Copyright(c) 2008 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2008 - 2014 Intel Corporation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of version 2 of the GNU General Public License as
@@ -30,7 +30,7 @@
  *
  * BSD LICENSE
  *
- * Copyright(c) 2005 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2005 - 2014 Intel Corporation. All rights reserved.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -62,15 +62,28 @@
 
 #ifndef __iwl_drv_h__
 #define __iwl_drv_h__
-
-#include <linux/module.h>
+#include <linux/export.h>
 
 /* for all modules */
 #define DRV_NAME        "iwlwifi"
 #define IWLWIFI_VERSION "in-tree:"
-#define DRV_COPYRIGHT "Copyright(c) 2003-2013 Intel Corporation"
+#define DRV_COPYRIGHT "Copyright(c) 2003- 2014 Intel Corporation"
 #define DRV_AUTHOR     "<ilw@linux.intel.com>"
 
+/* radio config bits (actual values from NVM definition) */
+#define NVM_RF_CFG_DASH_MSK(x)   (x & 0x3)         /* bits 0-1   */
+#define NVM_RF_CFG_STEP_MSK(x)   ((x >> 2)  & 0x3) /* bits 2-3   */
+#define NVM_RF_CFG_TYPE_MSK(x)   ((x >> 4)  & 0x3) /* bits 4-5   */
+#define NVM_RF_CFG_PNUM_MSK(x)   ((x >> 6)  & 0x3) /* bits 6-7   */
+#define NVM_RF_CFG_TX_ANT_MSK(x) ((x >> 8)  & 0xF) /* bits 8-11  */
+#define NVM_RF_CFG_RX_ANT_MSK(x) ((x >> 12) & 0xF) /* bits 12-15 */
+
+#define NVM_RF_CFG_FLAVOR_MSK_FAMILY_8000(x)   (x & 0xF)
+#define NVM_RF_CFG_DASH_MSK_FAMILY_8000(x)   ((x >> 4) & 0xF)
+#define NVM_RF_CFG_STEP_MSK_FAMILY_8000(x)   ((x >> 8) & 0xF)
+#define NVM_RF_CFG_TYPE_MSK_FAMILY_8000(x)   ((x >> 12) & 0xFFF)
+#define NVM_RF_CFG_TX_ANT_MSK_FAMILY_8000(x) ((x >> 24) & 0xF)
+#define NVM_RF_CFG_RX_ANT_MSK_FAMILY_8000(x) ((x >> 28) & 0xF)
 
 /**
  * DOC: Driver system flows - drv component
diff --git a/drivers/net/wireless/iwlwifi/iwl-eeprom-parse.c b/drivers/net/wireless/iwlwifi/iwl-eeprom-parse.c
index 600c9fd..c44cf11 100644
--- a/drivers/net/wireless/iwlwifi/iwl-eeprom-parse.c
+++ b/drivers/net/wireless/iwlwifi/iwl-eeprom-parse.c
@@ -5,7 +5,7 @@
  *
  * GPL LICENSE SUMMARY
  *
- * Copyright(c) 2008 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2008 - 2014 Intel Corporation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of version 2 of the GNU General Public License as
@@ -30,7 +30,7 @@
  *
  * BSD LICENSE
  *
- * Copyright(c) 2005 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2005 - 2014 Intel Corporation. All rights reserved.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -614,10 +614,10 @@ static int iwl_init_channel_map(struct device *dev, const struct iwl_cfg *cfg,
    channel->flags = IEEE80211_CHAN_NO_HT40;
 
    if (!(eeprom_ch->flags & EEPROM_CHANNEL_IBSS))
-    channel->flags |= IEEE80211_CHAN_NO_IBSS;
+    channel->flags |= IEEE80211_CHAN_NO_IR;
 
    if (!(eeprom_ch->flags & EEPROM_CHANNEL_ACTIVE))
-    channel->flags |= IEEE80211_CHAN_PASSIVE_SCAN;
+    channel->flags |= IEEE80211_CHAN_NO_IR;
 
    if (eeprom_ch->flags & EEPROM_CHANNEL_RADAR)
     channel->flags |= IEEE80211_CHAN_RADAR;
@@ -732,17 +732,16 @@ int iwl_init_sband_channels(struct iwl_nvm_data *data,
 void iwl_init_ht_hw_capab(const struct iwl_cfg *cfg,
      struct iwl_nvm_data *data,
      struct ieee80211_sta_ht_cap *ht_info,
-     enum ieee80211_band band)
+     enum ieee80211_band band,
+     u8 tx_chains, u8 rx_chains)
 {
  int max_bit_rate = 0;
- u8 rx_chains;
- u8 tx_chains;
 
- tx_chains = hweight8(data->valid_tx_ant);
+ tx_chains = hweight8(tx_chains);
  if (cfg->rx_with_siso_diversity)
   rx_chains = 1;
  else
-  rx_chains = hweight8(data->valid_rx_ant);
+  rx_chains = hweight8(rx_chains);
 
  if (!(data->sku_cap_11n_enable) || !cfg->ht_params) {
   ht_info->ht_supported = false;
@@ -752,6 +751,13 @@ void iwl_init_ht_hw_capab(const struct iwl_cfg *cfg,
  ht_info->ht_supported = true;
  ht_info->cap = IEEE80211_HT_CAP_DSSSCCK40;
 
+ if (cfg->ht_params->stbc) {
+  ht_info->cap |= (1 << IEEE80211_HT_CAP_RX_STBC_SHIFT);
+
+  if (tx_chains > 1)
+   ht_info->cap |= IEEE80211_HT_CAP_TX_STBC;
+ }
+
  if (iwlwifi_mod_params.amsdu_size_8K)
   ht_info->cap |= IEEE80211_HT_CAP_MAX_AMSDU;
 
@@ -806,7 +812,8 @@ static void iwl_init_sbands(struct device *dev, const struct iwl_cfg *cfg,
  sband->n_bitrates = N_RATES_24;
  n_used += iwl_init_sband_channels(data, sband, n_channels,
        IEEE80211_BAND_2GHZ);
- iwl_init_ht_hw_capab(cfg, data, &sband->ht_cap, IEEE80211_BAND_2GHZ);
+ iwl_init_ht_hw_capab(cfg, data, &sband->ht_cap, IEEE80211_BAND_2GHZ,
+        data->valid_tx_ant, data->valid_rx_ant);
 
  sband = &data->bands[IEEE80211_BAND_5GHZ];
  sband->band = IEEE80211_BAND_5GHZ;
@@ -814,7 +821,8 @@ static void iwl_init_sbands(struct device *dev, const struct iwl_cfg *cfg,
  sband->n_bitrates = N_RATES_52;
  n_used += iwl_init_sband_channels(data, sband, n_channels,
        IEEE80211_BAND_5GHZ);
- iwl_init_ht_hw_capab(cfg, data, &sband->ht_cap, IEEE80211_BAND_5GHZ);
+ iwl_init_ht_hw_capab(cfg, data, &sband->ht_cap, IEEE80211_BAND_5GHZ,
+        data->valid_tx_ant, data->valid_rx_ant);
 
  if (n_channels != n_used)
   IWL_ERR_DEV(dev, "EEPROM: used only %d of %d channels\n",
diff --git a/drivers/net/wireless/iwlwifi/iwl-eeprom-parse.h b/drivers/net/wireless/iwlwifi/iwl-eeprom-parse.h
index 37f1153..f0548b8 100644
--- a/drivers/net/wireless/iwlwifi/iwl-eeprom-parse.h
+++ b/drivers/net/wireless/iwlwifi/iwl-eeprom-parse.h
@@ -5,7 +5,7 @@
  *
  * GPL LICENSE SUMMARY
  *
- * Copyright(c) 2008 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2008 - 2014 Intel Corporation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of version 2 of the GNU General Public License as
@@ -30,7 +30,7 @@
  *
  * BSD LICENSE
  *
- * Copyright(c) 2005 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2005 - 2014 Intel Corporation. All rights reserved.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -81,16 +81,17 @@ struct iwl_nvm_data {
  bool sku_cap_band_24GHz_enable;
  bool sku_cap_band_52GHz_enable;
  bool sku_cap_11n_enable;
+ bool sku_cap_11ac_enable;
  bool sku_cap_amt_enable;
  bool sku_cap_ipan_enable;
 
- u8 radio_cfg_type;
+ u16 radio_cfg_type;
  u8 radio_cfg_step;
  u8 radio_cfg_dash;
  u8 radio_cfg_pnum;
  u8 valid_tx_ant, valid_rx_ant;
 
- u16 nvm_version;
+ u32 nvm_version;
  s8 max_tx_pwr_half_dbm;
 
  struct ieee80211_supported_band bands[IEEE80211_NUM_BANDS];
@@ -133,6 +134,7 @@ int iwl_init_sband_channels(struct iwl_nvm_data *data,
 void iwl_init_ht_hw_capab(const struct iwl_cfg *cfg,
      struct iwl_nvm_data *data,
      struct ieee80211_sta_ht_cap *ht_info,
-     enum ieee80211_band band);
+     enum ieee80211_band band,
+     u8 tx_chains, u8 rx_chains);
 
 #endif /* __iwl_eeprom_parse_h__ */
diff --git a/drivers/net/wireless/iwlwifi/iwl-eeprom-read.c b/drivers/net/wireless/iwlwifi/iwl-eeprom-read.c
index e5f2e36..25d0105 100644
--- a/drivers/net/wireless/iwlwifi/iwl-eeprom-read.c
+++ b/drivers/net/wireless/iwlwifi/iwl-eeprom-read.c
@@ -5,7 +5,7 @@
  *
  * GPL LICENSE SUMMARY
  *
- * Copyright(c) 2008 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2008 - 2014 Intel Corporation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of version 2 of the GNU General Public License as
@@ -30,7 +30,7 @@
  *
  * BSD LICENSE
  *
- * Copyright(c) 2005 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2005 - 2014 Intel Corporation. All rights reserved.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/drivers/net/wireless/iwlwifi/iwl-eeprom-read.h b/drivers/net/wireless/iwlwifi/iwl-eeprom-read.h
index 8e941f8..a6d3bdf 100644
--- a/drivers/net/wireless/iwlwifi/iwl-eeprom-read.h
+++ b/drivers/net/wireless/iwlwifi/iwl-eeprom-read.h
@@ -5,7 +5,7 @@
  *
  * GPL LICENSE SUMMARY
  *
- * Copyright(c) 2008 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2008 - 2014 Intel Corporation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of version 2 of the GNU General Public License as
@@ -30,7 +30,7 @@
  *
  * BSD LICENSE
  *
- * Copyright(c) 2005 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2005 - 2014 Intel Corporation. All rights reserved.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/drivers/net/wireless/iwlwifi/iwl-fh.h b/drivers/net/wireless/iwlwifi/iwl-fh.h
index 484d318..9564ae1 100644
--- a/drivers/net/wireless/iwlwifi/iwl-fh.h
+++ b/drivers/net/wireless/iwlwifi/iwl-fh.h
@@ -5,7 +5,7 @@
  *
  * GPL LICENSE SUMMARY
  *
- * Copyright(c) 2005 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2005 - 2014 Intel Corporation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of version 2 of the GNU General Public License as
@@ -30,7 +30,7 @@
  *
  * BSD LICENSE
  *
- * Copyright(c) 2005 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2005 - 2014 Intel Corporation. All rights reserved.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/drivers/net/wireless/iwlwifi/iwl-fw-error-dump.h b/drivers/net/wireless/iwlwifi/iwl-fw-error-dump.h
new file mode 100644
index 0000000..2953ffc
--- /dev/null
+++ b/drivers/net/wireless/iwlwifi/iwl-fw-error-dump.h
@@ -0,0 +1,134 @@
+/******************************************************************************
+ *
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ * redistributing this file, you may do so under either license.
+ *
+ * GPL LICENSE SUMMARY
+ *
+ * Copyright(c) 2014 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110,
+ * USA
+ *
+ * The full GNU General Public License is included in this distribution
+ * in the file called COPYING.
+ *
+ * Contact Information:
+ *  Intel Linux Wireless <ilw@linux.intel.com>
+ * Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497
+ *
+ * BSD LICENSE
+ *
+ * Copyright(c) 2014 Intel Corporation. All rights reserved.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *  * Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *  * Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *  * Neither the name Intel Corporation nor the names of its
+ *    contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *****************************************************************************/
+
+#ifndef __fw_error_dump_h__
+#define __fw_error_dump_h__
+
+#include <linux/types.h>
+
+#define IWL_FW_ERROR_DUMP_BARKER 0x14789632
+
+/**
+ * enum iwl_fw_error_dump_type - types of data in the dump file
+ * @IWL_FW_ERROR_DUMP_SRAM:
+ * @IWL_FW_ERROR_DUMP_REG:
+ * @IWL_FW_ERROR_DUMP_RXF:
+ * @IWL_FW_ERROR_DUMP_TXCMD: last TX command data, structured as
+ * &struct iwl_fw_error_dump_txcmd packets
+ */
+enum iwl_fw_error_dump_type {
+ IWL_FW_ERROR_DUMP_SRAM = 0,
+ IWL_FW_ERROR_DUMP_REG = 1,
+ IWL_FW_ERROR_DUMP_RXF = 2,
+ IWL_FW_ERROR_DUMP_TXCMD = 3,
+
+ IWL_FW_ERROR_DUMP_MAX,
+};
+
+/**
+ * struct iwl_fw_error_dump_data - data for one type
+ * @type: %enum iwl_fw_error_dump_type
+ * @len: the length starting from %data - must be a multiplier of 4.
+ * @data: the data itself padded to be a multiplier of 4.
+ */
+struct iwl_fw_error_dump_data {
+ __le32 type;
+ __le32 len;
+ __u8 data[];
+} __packed;
+
+/**
+ * struct iwl_fw_error_dump_file - the layout of the header of the file
+ * @barker: must be %IWL_FW_ERROR_DUMP_BARKER
+ * @file_len: the length of all the file starting from %barker
+ * @data: array of %struct iwl_fw_error_dump_data
+ */
+struct iwl_fw_error_dump_file {
+ __le32 barker;
+ __le32 file_len;
+ u8 data[0];
+} __packed;
+
+/**
+ * struct iwl_fw_error_dump_txcmd - TX command data
+ * @cmdlen: original length of command
+ * @caplen: captured length of command (may be less)
+ * @data: captured command data, @caplen bytes
+ */
+struct iwl_fw_error_dump_txcmd {
+ __le32 cmdlen;
+ __le32 caplen;
+ u8 data[];
+} __packed;
+
+/**
+ * iwl_mvm_fw_error_next_data - advance fw error dump data pointer
+ * @data: previous data block
+ * Returns: next data block
+ */
+static inline struct iwl_fw_error_dump_data *
+iwl_mvm_fw_error_next_data(struct iwl_fw_error_dump_data *data)
+{
+ return (void *)(data->data + le32_to_cpu(data->len));
+}
+
+#endif /* __fw_error_dump_h__ */
diff --git a/drivers/net/wireless/iwlwifi/iwl-fw-file.h b/drivers/net/wireless/iwlwifi/iwl-fw-file.h
index 8b6c6fd..b45e576 100644
--- a/drivers/net/wireless/iwlwifi/iwl-fw-file.h
+++ b/drivers/net/wireless/iwlwifi/iwl-fw-file.h
@@ -5,7 +5,7 @@
  *
  * GPL LICENSE SUMMARY
  *
- * Copyright(c) 2008 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2008 - 2014 Intel Corporation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of version 2 of the GNU General Public License as
@@ -30,7 +30,7 @@
  *
  * BSD LICENSE
  *
- * Copyright(c) 2005 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2005 - 2014 Intel Corporation. All rights reserved.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -121,6 +121,13 @@ enum iwl_ucode_tlv_type {
  IWL_UCODE_TLV_SEC_WOWLAN = 21,
  IWL_UCODE_TLV_DEF_CALIB  = 22,
  IWL_UCODE_TLV_PHY_SKU  = 23,
+ IWL_UCODE_TLV_SECURE_SEC_RT = 24,
+ IWL_UCODE_TLV_SECURE_SEC_INIT = 25,
+ IWL_UCODE_TLV_SECURE_SEC_WOWLAN = 26,
+ IWL_UCODE_TLV_NUM_OF_CPU = 27,
+ IWL_UCODE_TLV_CSCHEME  = 28,
+ IWL_UCODE_TLV_API_CHANGES_SET = 29,
+ IWL_UCODE_TLV_ENABLED_CAPABILITIES = 30,
 };
 
 struct iwl_ucode_tlv {
@@ -153,4 +160,19 @@ struct iwl_tlv_ucode_header {
  u8 data[0];
 };
 
+/*
+ * ucode TLVs
+ *
+ * ability to get extension for: flags & capabilities from ucode binaries files
+ */
+struct iwl_ucode_api {
+ __le32 api_index;
+ __le32 api_flags;
+} __packed;
+
+struct iwl_ucode_capa {
+ __le32 api_index;
+ __le32 api_capa;
+} __packed;
+
 #endif  /* __iwl_fw_file_h__ */
diff --git a/drivers/net/wireless/iwlwifi/iwl-fw.h b/drivers/net/wireless/iwlwifi/iwl-fw.h
index c4c446d..b1a3332 100644
--- a/drivers/net/wireless/iwlwifi/iwl-fw.h
+++ b/drivers/net/wireless/iwlwifi/iwl-fw.h
@@ -5,7 +5,7 @@
  *
  * GPL LICENSE SUMMARY
  *
- * Copyright(c) 2008 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2008 - 2014 Intel Corporation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of version 2 of the GNU General Public License as
@@ -30,7 +30,7 @@
  *
  * BSD LICENSE
  *
- * Copyright(c) 2005 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2005 - 2014 Intel Corporation. All rights reserved.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -74,13 +74,63 @@
  * @IWL_UCODE_TLV_FLAGS_MFP: This uCode image supports MFP (802.11w).
  * @IWL_UCODE_TLV_FLAGS_P2P: This uCode image supports P2P.
  * @IWL_UCODE_TLV_FLAGS_DW_BC_TABLE: The SCD byte count table is in DWORDS
+ * @IWL_UCODE_TLV_FLAGS_UAPSD_SUPPORT: This uCode image supports uAPSD
+ * @IWL_UCODE_TLV_FLAGS_SHORT_BL: 16 entries of black list instead of 64 in scan
+ * offload profile config command.
+ * @IWL_UCODE_TLV_FLAGS_D3_6_IPV6_ADDRS: D3 image supports up to six
+ * (rather than two) IPv6 addresses
+ * @IWL_UCODE_TLV_FLAGS_NO_BASIC_SSID: not sending a probe with the SSID element
+ * from the probe request template.
+ * @IWL_UCODE_TLV_FLAGS_NEW_NSOFFL_SMALL: new NS offload (small version)
+ * @IWL_UCODE_TLV_FLAGS_NEW_NSOFFL_LARGE: new NS offload (large version)
+ * @IWL_UCODE_TLV_FLAGS_P2P_PM: P2P client supports PM as a stand alone MAC
+ * @IWL_UCODE_TLV_FLAGS_P2P_BSS_PS_DCM: support power save on BSS station and
+ * P2P client interfaces simultaneously if they are in different bindings.
+ * @IWL_UCODE_TLV_FLAGS_P2P_BSS_PS_SCM: support power save on BSS station and
+ * P2P client interfaces simultaneously if they are in same bindings.
+ * @IWL_UCODE_TLV_FLAGS_UAPSD_SUPPORT: General support for uAPSD
+ * @IWL_UCODE_TLV_FLAGS_P2P_PS_UAPSD: P2P client supports uAPSD power save
+ * @IWL_UCODE_TLV_FLAGS_BCAST_FILTERING: uCode supports broadcast filtering.
+ * @IWL_UCODE_TLV_FLAGS_GO_UAPSD: AP/GO interfaces support uAPSD clients
+ * @IWL_UCODE_TLV_FLAGS_EBS_SUPPORT: this uCode image supports EBS.
  */
 enum iwl_ucode_tlv_flag {
- IWL_UCODE_TLV_FLAGS_PAN  = BIT(0),
- IWL_UCODE_TLV_FLAGS_NEWSCAN = BIT(1),
- IWL_UCODE_TLV_FLAGS_MFP  = BIT(2),
- IWL_UCODE_TLV_FLAGS_P2P  = BIT(3),
- IWL_UCODE_TLV_FLAGS_DW_BC_TABLE = BIT(4),
+ IWL_UCODE_TLV_FLAGS_PAN   = BIT(0),
+ IWL_UCODE_TLV_FLAGS_NEWSCAN  = BIT(1),
+ IWL_UCODE_TLV_FLAGS_MFP   = BIT(2),
+ IWL_UCODE_TLV_FLAGS_P2P   = BIT(3),
+ IWL_UCODE_TLV_FLAGS_DW_BC_TABLE  = BIT(4),
+ IWL_UCODE_TLV_FLAGS_SHORT_BL  = BIT(7),
+ IWL_UCODE_TLV_FLAGS_D3_6_IPV6_ADDRS = BIT(10),
+ IWL_UCODE_TLV_FLAGS_NO_BASIC_SSID = BIT(12),
+ IWL_UCODE_TLV_FLAGS_NEW_NSOFFL_SMALL = BIT(15),
+ IWL_UCODE_TLV_FLAGS_NEW_NSOFFL_LARGE = BIT(16),
+ IWL_UCODE_TLV_FLAGS_P2P_PM  = BIT(21),
+ IWL_UCODE_TLV_FLAGS_BSS_P2P_PS_DCM = BIT(22),
+ IWL_UCODE_TLV_FLAGS_BSS_P2P_PS_SCM = BIT(23),
+ IWL_UCODE_TLV_FLAGS_UAPSD_SUPPORT = BIT(24),
+ IWL_UCODE_TLV_FLAGS_EBS_SUPPORT  = BIT(25),
+ IWL_UCODE_TLV_FLAGS_P2P_PS_UAPSD = BIT(26),
+ IWL_UCODE_TLV_FLAGS_BCAST_FILTERING = BIT(29),
+ IWL_UCODE_TLV_FLAGS_GO_UAPSD  = BIT(30),
+};
+
+/**
+ * enum iwl_ucode_tlv_api - ucode api
+ * @IWL_UCODE_TLV_API_WOWLAN_CONFIG_TID: wowlan config includes tid field.
+ * @IWL_UCODE_TLV_API_CSA_FLOW: ucode can do unbind-bind flow for CSA.
+ */
+enum iwl_ucode_tlv_api {
+ IWL_UCODE_TLV_API_WOWLAN_CONFIG_TID = BIT(0),
+ IWL_UCODE_TLV_API_CSA_FLOW  = BIT(4),
+};
+
+/**
+ * enum iwl_ucode_tlv_capa - ucode capabilities
+ * @IWL_UCODE_TLV_CAPA_D0I3_SUPPORT: supports D0i3
+ */
+enum iwl_ucode_tlv_capa {
+ IWL_UCODE_TLV_CAPA_D0I3_SUPPORT  = BIT(0),
 };
 
 /* The default calibrate table size if not specified by firmware file */
@@ -88,6 +138,9 @@ enum iwl_ucode_tlv_flag {
 #define IWL_MAX_STANDARD_PHY_CALIBRATE_TBL_SIZE  19
 #define IWL_MAX_PHY_CALIBRATE_TBL_SIZE   253
 
+/* The default max probe length if not specified by the firmware file */
+#define IWL_DEFAULT_MAX_PROBE_LENGTH 200
+
 /**
  * enum iwl_ucode_type
  *
@@ -106,22 +159,30 @@ enum iwl_ucode_type {
 
 /*
  * enumeration of ucode section.
- * This enumeration is used for legacy tlv style (before 16.0 uCode).
+ * This enumeration is used directly for older firmware (before 16.0).
+ * For new firmware, there can be up to 4 sections (see below) but the
+ * first one packaged into the firmware file is the DATA section and
+ * some debugging code accesses that.
  */
 enum iwl_ucode_sec {
- IWL_UCODE_SECTION_INST,
  IWL_UCODE_SECTION_DATA,
+ IWL_UCODE_SECTION_INST,
 };
 /*
  * For 16.0 uCode and above, there is no differentiation between sections,
  * just an offset to the HW address.
  */
-#define IWL_UCODE_SECTION_MAX 4
+#define IWL_UCODE_SECTION_MAX 12
+#define IWL_API_ARRAY_SIZE 1
+#define IWL_CAPABILITIES_ARRAY_SIZE 1
+#define CPU1_CPU2_SEPARATOR_SECTION 0xFFFFCCCC
 
 struct iwl_ucode_capabilities {
  u32 max_probe_length;
  u32 standard_phy_calibration_size;
  u32 flags;
+ u32 api[IWL_API_ARRAY_SIZE];
+ u32 capa[IWL_CAPABILITIES_ARRAY_SIZE];
 };
 
 /* one for each uCode image (inst/data, init/runtime/wowlan) */
@@ -133,6 +194,13 @@ struct fw_desc {
 
 struct fw_img {
  struct fw_desc sec[IWL_UCODE_SECTION_MAX];
+ bool is_secure;
+ bool is_dual_cpus;
+};
+
+struct iwl_sf_region {
+ u32 addr;
+ u32 size;
 };
 
 /* uCode version contains 4 values: Major/Minor/API/Serial */
@@ -167,6 +235,44 @@ enum iwl_fw_phy_cfg {
  FW_PHY_CFG_RX_CHAIN = 0xf << FW_PHY_CFG_RX_CHAIN_POS,
 };
 
+#define IWL_UCODE_MAX_CS  1
+
+/**
+ * struct iwl_fw_cipher_scheme - a cipher scheme supported by FW.
+ * @cipher: a cipher suite selector
+ * @flags: cipher scheme flags (currently reserved for a future use)
+ * @hdr_len: a size of MPDU security header
+ * @pn_len: a size of PN
+ * @pn_off: an offset of pn from the beginning of the security header
+ * @key_idx_off: an offset of key index byte in the security header
+ * @key_idx_mask: a bit mask of key_idx bits
+ * @key_idx_shift: bit shift needed to get key_idx
+ * @mic_len: mic length in bytes
+ * @hw_cipher: a HW cipher index used in host commands
+ */
+struct iwl_fw_cipher_scheme {
+ __le32 cipher;
+ u8 flags;
+ u8 hdr_len;
+ u8 pn_len;
+ u8 pn_off;
+ u8 key_idx_off;
+ u8 key_idx_mask;
+ u8 key_idx_shift;
+ u8 mic_len;
+ u8 hw_cipher;
+} __packed;
+
+/**
+ * struct iwl_fw_cscheme_list - a cipher scheme list
+ * @size: a number of entries
+ * @cs: cipher scheme entries
+ */
+struct iwl_fw_cscheme_list {
+ u8 size;
+ struct iwl_fw_cipher_scheme cs[];
+} __packed;
+
 /**
  * struct iwl_fw - variables associated with the firmware
  *
@@ -182,6 +288,7 @@ enum iwl_fw_phy_cfg {
  * @inst_evtlog_size: event log size for runtime ucode.
  * @inst_errlog_ptr: error log offfset for runtime ucode.
  * @mvm_fw: indicates this is MVM firmware
+ * @cipher_scheme: optional external cipher scheme.
  */
 struct iwl_fw {
  u32 ucode_ver;
@@ -199,20 +306,12 @@ struct iwl_fw {
 
  struct iwl_tlv_calib_ctrl default_calib[IWL_UCODE_TYPE_MAX];
  u32 phy_config;
+ u8 valid_tx_ant;
+ u8 valid_rx_ant;
 
  bool mvm_fw;
-};
 
-static inline u8 iwl_fw_valid_tx_ant(const struct iwl_fw *fw)
-{
- return (fw->phy_config & FW_PHY_CFG_TX_CHAIN) >>
-  FW_PHY_CFG_TX_CHAIN_POS;
-}
-
-static inline u8 iwl_fw_valid_rx_ant(const struct iwl_fw *fw)
-{
- return (fw->phy_config & FW_PHY_CFG_RX_CHAIN) >>
-  FW_PHY_CFG_RX_CHAIN_POS;
-}
+ struct ieee80211_cipher_scheme cs[IWL_UCODE_MAX_CS];
+};
 
 #endif  /* __iwl_fw_h__ */
diff --git a/drivers/net/wireless/iwlwifi/iwl-io.c b/drivers/net/wireless/iwlwifi/iwl-io.c
index 305c81f..5eef4ae 100644
--- a/drivers/net/wireless/iwlwifi/iwl-io.c
+++ b/drivers/net/wireless/iwlwifi/iwl-io.c
@@ -1,6 +1,6 @@
 /******************************************************************************
  *
- * Copyright(c) 2003 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2003 - 2014 Intel Corporation. All rights reserved.
  *
  * Portions of this file are derived from the ipw3945 project.
  *
@@ -33,6 +33,8 @@
 #include "iwl-io.h"
 #include "iwl-csr.h"
 #include "iwl-debug.h"
+#include "iwl-prph.h"
+#include "iwl-fh.h"
 
 #define IWL_POLL_INTERVAL 10 /* microseconds */
 
@@ -92,14 +94,14 @@ int iwl_poll_direct_bit(struct iwl_trans *trans, u32 addr, u32 mask,
 }
 IWL_EXPORT_SYMBOL(iwl_poll_direct_bit);
 
-static inline u32 __iwl_read_prph(struct iwl_trans *trans, u32 ofs)
+u32 __iwl_read_prph(struct iwl_trans *trans, u32 ofs)
 {
  u32 val = iwl_trans_read_prph(trans, ofs);
  trace_iwlwifi_dev_ioread_prph32(trans->dev, ofs, val);
  return val;
 }
 
-static inline void __iwl_write_prph(struct iwl_trans *trans, u32 ofs, u32 val)
+void __iwl_write_prph(struct iwl_trans *trans, u32 ofs, u32 val)
 {
  trace_iwlwifi_dev_iowrite_prph32(trans->dev, ofs, val);
  iwl_trans_write_prph(trans, ofs, val);
@@ -129,6 +131,21 @@ void iwl_write_prph(struct iwl_trans *trans, u32 ofs, u32 val)
 }
 IWL_EXPORT_SYMBOL(iwl_write_prph);
 
+int iwl_poll_prph_bit(struct iwl_trans *trans, u32 addr,
+        u32 bits, u32 mask, int timeout)
+{
+ int t = 0;
+
+ do {
+  if ((iwl_read_prph(trans, addr) & mask) == (bits & mask))
+   return t;
+  udelay(IWL_POLL_INTERVAL);
+  t += IWL_POLL_INTERVAL;
+ } while (t < timeout);
+
+ return -ETIMEDOUT;
+}
+
 void iwl_set_bits_prph(struct iwl_trans *trans, u32 ofs, u32 mask)
 {
  unsigned long flags;
@@ -166,3 +183,85 @@ void iwl_clear_bits_prph(struct iwl_trans *trans, u32 ofs, u32 mask)
  }
 }
 IWL_EXPORT_SYMBOL(iwl_clear_bits_prph);
+
+void iwl_force_nmi(struct iwl_trans *trans)
+{
+ /*
+  * In HW previous to the 8000 HW family, and in the 8000 HW family
+  * itself when the revision step==0, the DEVICE_SET_NMI_REG is used
+  * to force an NMI. Otherwise, a different register -
+  * DEVICE_SET_NMI_8000B_REG - is used.
+  */
+ if ((trans->cfg->device_family != IWL_DEVICE_FAMILY_8000) ||
+     ((trans->hw_rev & 0xc) == 0x0))
+  iwl_write_prph(trans, DEVICE_SET_NMI_REG, DEVICE_SET_NMI_VAL);
+ else
+  iwl_write_prph(trans, DEVICE_SET_NMI_8000B_REG,
+          DEVICE_SET_NMI_8000B_VAL);
+}
+IWL_EXPORT_SYMBOL(iwl_force_nmi);
+
+static const char *get_fh_string(int cmd)
+{
+#define IWL_CMD(x) case x: return #x
+ switch (cmd) {
+ IWL_CMD(FH_RSCSR_CHNL0_STTS_WPTR_REG);
+ IWL_CMD(FH_RSCSR_CHNL0_RBDCB_BASE_REG);
+ IWL_CMD(FH_RSCSR_CHNL0_WPTR);
+ IWL_CMD(FH_MEM_RCSR_CHNL0_CONFIG_REG);
+ IWL_CMD(FH_MEM_RSSR_SHARED_CTRL_REG);
+ IWL_CMD(FH_MEM_RSSR_RX_STATUS_REG);
+ IWL_CMD(FH_MEM_RSSR_RX_ENABLE_ERR_IRQ2DRV);
+ IWL_CMD(FH_TSSR_TX_STATUS_REG);
+ IWL_CMD(FH_TSSR_TX_ERROR_REG);
+ default:
+  return "UNKNOWN";
+ }
+#undef IWL_CMD
+}
+
+int iwl_dump_fh(struct iwl_trans *trans, char **buf)
+{
+ int i;
+ static const u32 fh_tbl[] = {
+  FH_RSCSR_CHNL0_STTS_WPTR_REG,
+  FH_RSCSR_CHNL0_RBDCB_BASE_REG,
+  FH_RSCSR_CHNL0_WPTR,
+  FH_MEM_RCSR_CHNL0_CONFIG_REG,
+  FH_MEM_RSSR_SHARED_CTRL_REG,
+  FH_MEM_RSSR_RX_STATUS_REG,
+  FH_MEM_RSSR_RX_ENABLE_ERR_IRQ2DRV,
+  FH_TSSR_TX_STATUS_REG,
+  FH_TSSR_TX_ERROR_REG
+ };
+
+#ifdef CONFIG_IWLWIFI_DEBUGFS
+ if (buf) {
+  int pos = 0;
+  size_t bufsz = ARRAY_SIZE(fh_tbl) * 48 + 40;
+
+  *buf = kmalloc(bufsz, GFP_KERNEL);
+  if (!*buf)
+   return -ENOMEM;
+
+  pos += scnprintf(*buf + pos, bufsz - pos,
+    "FH register values:\n");
+
+  for (i = 0; i < ARRAY_SIZE(fh_tbl); i++)
+   pos += scnprintf(*buf + pos, bufsz - pos,
+    "  %34s: 0X%08x\n",
+    get_fh_string(fh_tbl[i]),
+    iwl_read_direct32(trans, fh_tbl[i]));
+
+  return pos;
+ }
+#endif
+
+ IWL_ERR(trans, "FH register values:\n");
+ for (i = 0; i <  ARRAY_SIZE(fh_tbl); i++)
+  IWL_ERR(trans, "  %34s: 0X%08x\n",
+   get_fh_string(fh_tbl[i]),
+   iwl_read_direct32(trans, fh_tbl[i]));
+
+ return 0;
+}
diff --git a/drivers/net/wireless/iwlwifi/iwl-io.h b/drivers/net/wireless/iwlwifi/iwl-io.h
index fd9f5b9..705d12c 100644
--- a/drivers/net/wireless/iwlwifi/iwl-io.h
+++ b/drivers/net/wireless/iwlwifi/iwl-io.h
@@ -1,6 +1,6 @@
 /******************************************************************************
  *
- * Copyright(c) 2003 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2003 - 2014 Intel Corporation. All rights reserved.
  *
  * Portions of this file are derived from the ipw3945 project.
  *
@@ -70,11 +70,19 @@ u32 iwl_read_direct32(struct iwl_trans *trans, u32 reg);
 void iwl_write_direct32(struct iwl_trans *trans, u32 reg, u32 value);
 
 
+u32 __iwl_read_prph(struct iwl_trans *trans, u32 ofs);
 u32 iwl_read_prph(struct iwl_trans *trans, u32 ofs);
+void __iwl_write_prph(struct iwl_trans *trans, u32 ofs, u32 val);
 void iwl_write_prph(struct iwl_trans *trans, u32 ofs, u32 val);
+int iwl_poll_prph_bit(struct iwl_trans *trans, u32 addr,
+        u32 bits, u32 mask, int timeout);
 void iwl_set_bits_prph(struct iwl_trans *trans, u32 ofs, u32 mask);
 void iwl_set_bits_mask_prph(struct iwl_trans *trans, u32 ofs,
        u32 bits, u32 mask);
 void iwl_clear_bits_prph(struct iwl_trans *trans, u32 ofs, u32 mask);
+void iwl_force_nmi(struct iwl_trans *trans);
+
+/* Error handling */
+int iwl_dump_fh(struct iwl_trans *trans, char **buf);
 
 #endif
diff --git a/drivers/net/wireless/iwlwifi/iwl-modparams.h b/drivers/net/wireless/iwlwifi/iwl-modparams.h
index d6f6c37..d051857 100644
--- a/drivers/net/wireless/iwlwifi/iwl-modparams.h
+++ b/drivers/net/wireless/iwlwifi/iwl-modparams.h
@@ -5,7 +5,7 @@
  *
  * GPL LICENSE SUMMARY
  *
- * Copyright(c) 2007 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2007 - 2014 Intel Corporation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of version 2 of the GNU General Public License as
@@ -30,7 +30,7 @@
  *
  * BSD LICENSE
  *
- * Copyright(c) 2005 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2005 - 2014 Intel Corporation. All rights reserved.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -79,9 +79,12 @@ enum iwl_power_level {
  IWL_POWER_NUM
 };
 
-#define IWL_DISABLE_HT_ALL BIT(0)
-#define IWL_DISABLE_HT_TXAGG BIT(1)
-#define IWL_DISABLE_HT_RXAGG BIT(2)
+enum iwl_disable_11n {
+ IWL_DISABLE_HT_ALL  = BIT(0),
+ IWL_DISABLE_HT_TXAGG  = BIT(1),
+ IWL_DISABLE_HT_RXAGG  = BIT(2),
+ IWL_ENABLE_HT_TXAGG  = BIT(3),
+};
 
 /**
  * struct iwl_mod_params
@@ -90,35 +93,33 @@ enum iwl_power_level {
  *
  * @sw_crypto: using hardware encryption, default = 0
  * @disable_11n: disable 11n capabilities, default = 0,
- * use IWL_DISABLE_HT_* constants
+ * use IWL_[DIS,EN]ABLE_HT_* constants
  * @amsdu_size_8K: enable 8K amsdu size, default = 0
  * @restart_fw: restart firmware, default = 1
- * @plcp_check: enable plcp health check, default = true
- * @wd_disable: enable stuck queue check, default = 0
+ * @wd_disable: disable stuck queue check, default = 1
  * @bt_coex_active: enable bt coex, default = true
  * @led_mode: system default, default = 0
  * @power_save: disable power save, default = false
  * @power_level: power level, default = 1
  * @debug_level: levels are IWL_DL_*
  * @ant_coupling: antenna coupling in dB, default = 0
- * @bt_ch_announce: BT channel inhibition, default = enable
- * @auto_agg: enable agg. without check, default = true
  */
 struct iwl_mod_params {
  int sw_crypto;
  unsigned int disable_11n;
  int amsdu_size_8K;
  bool restart_fw;
- bool plcp_check;
  int  wd_disable;
  bool bt_coex_active;
  int led_mode;
  bool power_save;
  int power_level;
+#ifdef CONFIG_IWLWIFI_DEBUG
  u32 debug_level;
+#endif
  int ant_coupling;
- bool bt_ch_announce;
- bool auto_agg;
+ char *nvm_file;
+ bool uapsd_disable;
 };
 
 #endif /* #__iwl_modparams_h__ */
diff --git a/drivers/net/wireless/iwlwifi/iwl-notif-wait.c b/drivers/net/wireless/iwlwifi/iwl-notif-wait.c
index 940b8a9..b5bc959 100644
--- a/drivers/net/wireless/iwlwifi/iwl-notif-wait.c
+++ b/drivers/net/wireless/iwlwifi/iwl-notif-wait.c
@@ -5,7 +5,7 @@
  *
  * GPL LICENSE SUMMARY
  *
- * Copyright(c) 2007 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2007 - 2014 Intel Corporation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of version 2 of the GNU General Public License as
@@ -30,7 +30,7 @@
  *
  * BSD LICENSE
  *
- * Copyright(c) 2005 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2005 - 2014 Intel Corporation. All rights reserved.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/drivers/net/wireless/iwlwifi/iwl-notif-wait.h b/drivers/net/wireless/iwlwifi/iwl-notif-wait.h
index 2e2f1c8..95af97a 100644
--- a/drivers/net/wireless/iwlwifi/iwl-notif-wait.h
+++ b/drivers/net/wireless/iwlwifi/iwl-notif-wait.h
@@ -5,7 +5,7 @@
  *
  * GPL LICENSE SUMMARY
  *
- * Copyright(c) 2007 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2007 - 2014 Intel Corporation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of version 2 of the GNU General Public License as
@@ -30,7 +30,7 @@
  *
  * BSD LICENSE
  *
- * Copyright(c) 2005 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2005 - 2014 Intel Corporation. All rights reserved.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/drivers/net/wireless/iwlwifi/iwl-nvm-parse.c b/drivers/net/wireless/iwlwifi/iwl-nvm-parse.c
index 6199a0a..85eee79 100644
--- a/drivers/net/wireless/iwlwifi/iwl-nvm-parse.c
+++ b/drivers/net/wireless/iwlwifi/iwl-nvm-parse.c
@@ -5,7 +5,7 @@
  *
  * GPL LICENSE SUMMARY
  *
- * Copyright(c) 2008 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2008 - 2014 Intel Corporation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of version 2 of the GNU General Public License as
@@ -30,7 +30,7 @@
  *
  * BSD LICENSE
  *
- * Copyright(c) 2005 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2005 - 2014 Intel Corporation. All rights reserved.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -62,6 +62,7 @@
 #include <linux/types.h>
 #include <linux/slab.h>
 #include <linux/export.h>
+#include <linux/etherdevice.h>
 #include "iwl-drv.h"
 #include "iwl-modparams.h"
 #include "iwl-nvm-parse.h"
@@ -71,7 +72,7 @@ enum wkp_nvm_offsets {
  /* NVM HW-Section offset (in words) definitions */
  HW_ADDR = 0x15,
 
-/* NVM SW-Section offset (in words) definitions */
+ /* NVM SW-Section offset (in words) definitions */
  NVM_SW_SECTION = 0x1C0,
  NVM_VERSION = 0,
  RADIO_CFG = 1,
@@ -79,26 +80,40 @@ enum wkp_nvm_offsets {
  N_HW_ADDRS = 3,
  NVM_CHANNELS = 0x1E0 - NVM_SW_SECTION,
 
-/* NVM calibration section offset (in words) definitions */
+ /* NVM calibration section offset (in words) definitions */
  NVM_CALIB_SECTION = 0x2B8,
  XTAL_CALIB = 0x316 - NVM_CALIB_SECTION
 };
 
+enum family_8000_nvm_offsets {
+ /* NVM HW-Section offset (in words) definitions */
+ HW_ADDR0_FAMILY_8000 = 0x12,
+ HW_ADDR1_FAMILY_8000 = 0x16,
+ MAC_ADDRESS_OVERRIDE_FAMILY_8000 = 1,
+
+ /* NVM SW-Section offset (in words) definitions */
+ NVM_SW_SECTION_FAMILY_8000 = 0x1C0,
+ NVM_VERSION_FAMILY_8000 = 0,
+ RADIO_CFG_FAMILY_8000 = 2,
+ SKU_FAMILY_8000 = 4,
+ N_HW_ADDRS_FAMILY_8000 = 5,
+
+ /* NVM REGULATORY -Section offset (in words) definitions */
+ NVM_CHANNELS_FAMILY_8000 = 0,
+
+ /* NVM calibration section offset (in words) definitions */
+ NVM_CALIB_SECTION_FAMILY_8000 = 0x2B8,
+ XTAL_CALIB_FAMILY_8000 = 0x316 - NVM_CALIB_SECTION_FAMILY_8000
+};
+
 /* SKU Capabilities (actual values from NVM definition) */
 enum nvm_sku_bits {
  NVM_SKU_CAP_BAND_24GHZ = BIT(0),
  NVM_SKU_CAP_BAND_52GHZ = BIT(1),
  NVM_SKU_CAP_11N_ENABLE = BIT(2),
+ NVM_SKU_CAP_11AC_ENABLE = BIT(3),
 };
 
-/* radio config bits (actual values from NVM definition) */
-#define NVM_RF_CFG_DASH_MSK(x)   (x & 0x3)         /* bits 0-1   */
-#define NVM_RF_CFG_STEP_MSK(x)   ((x >> 2)  & 0x3) /* bits 2-3   */
-#define NVM_RF_CFG_TYPE_MSK(x)   ((x >> 4)  & 0x3) /* bits 4-5   */
-#define NVM_RF_CFG_PNUM_MSK(x)   ((x >> 6)  & 0x3) /* bits 6-7   */
-#define NVM_RF_CFG_TX_ANT_MSK(x) ((x >> 8)  & 0xF) /* bits 8-11  */
-#define NVM_RF_CFG_RX_ANT_MSK(x) ((x >> 12) & 0xF) /* bits 12-15 */
-
 /*
  * These are the channel numbers in the order that they are stored in the NVM
  */
@@ -111,12 +126,24 @@ static const u8 iwl_nvm_channels[] = {
  149, 153, 157, 161, 165
 };
 
-#define IWL_NUM_CHANNELS ARRAY_SIZE(iwl_nvm_channels)
-#define NUM_2GHZ_CHANNELS 14
-#define FIRST_2GHZ_HT_MINUS 5
-#define LAST_2GHZ_HT_PLUS 9
-#define LAST_5GHZ_HT  161
+static const u8 iwl_nvm_channels_family_8000[] = {
+ /* 2.4 GHz */
+ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14,
+ /* 5 GHz */
+ 36, 40, 44, 48, 52, 56, 60, 64, 68, 72, 76, 80, 84, 88, 92,
+ 96, 100, 104, 108, 112, 116, 120, 124, 128, 132, 136, 140, 144,
+ 149, 153, 157, 161, 165, 169, 173, 177, 181
+};
 
+#define IWL_NUM_CHANNELS  ARRAY_SIZE(iwl_nvm_channels)
+#define IWL_NUM_CHANNELS_FAMILY_8000 ARRAY_SIZE(iwl_nvm_channels_family_8000)
+#define NUM_2GHZ_CHANNELS  14
+#define NUM_2GHZ_CHANNELS_FAMILY_8000 14
+#define FIRST_2GHZ_HT_MINUS  5
+#define LAST_2GHZ_HT_PLUS  9
+#define LAST_5GHZ_HT   161
+
+#define DEFAULT_MAX_TX_POWER 16
 
 /* rate data (static) */
 static struct ieee80211_rate iwl_cfg80211_rates[] = {
@@ -177,15 +204,32 @@ static int iwl_init_channel_map(struct device *dev, const struct iwl_cfg *cfg,
  struct ieee80211_channel *channel;
  u16 ch_flags;
  bool is_5ghz;
+ int num_of_ch, num_2ghz_channels;
+ const u8 *nvm_chan;
+
+ if (cfg->device_family != IWL_DEVICE_FAMILY_8000) {
+  num_of_ch = IWL_NUM_CHANNELS;
+  nvm_chan = &iwl_nvm_channels[0];
+  num_2ghz_channels = NUM_2GHZ_CHANNELS;
+ } else {
+  num_of_ch = IWL_NUM_CHANNELS_FAMILY_8000;
+  nvm_chan = &iwl_nvm_channels_family_8000[0];
+  num_2ghz_channels = NUM_2GHZ_CHANNELS_FAMILY_8000;
+ }
 
- for (ch_idx = 0; ch_idx < IWL_NUM_CHANNELS; ch_idx++) {
+ for (ch_idx = 0; ch_idx < num_of_ch; ch_idx++) {
   ch_flags = __le16_to_cpup(nvm_ch_flags + ch_idx);
+
+  if (ch_idx >= num_2ghz_channels &&
+      !data->sku_cap_band_52GHz_enable)
+   ch_flags &= ~NVM_CHANNEL_VALID;
+
   if (!(ch_flags & NVM_CHANNEL_VALID)) {
    IWL_DEBUG_EEPROM(dev,
       "Ch. %d Flags %x [%sGHz] - No traffic\n",
-      iwl_nvm_channels[ch_idx],
+      nvm_chan[ch_idx],
       ch_flags,
-      (ch_idx >= NUM_2GHZ_CHANNELS) ?
+      (ch_idx >= num_2ghz_channels) ?
       "5.2" : "2.4");
    continue;
   }
@@ -193,8 +237,8 @@ static int iwl_init_channel_map(struct device *dev, const struct iwl_cfg *cfg,
   channel = &data->channels[n_channels];
   n_channels++;
 
-  channel->hw_value = iwl_nvm_channels[ch_idx];
-  channel->band = (ch_idx < NUM_2GHZ_CHANNELS) ?
+  channel->hw_value = nvm_chan[ch_idx];
+  channel->band = (ch_idx < num_2ghz_channels) ?
     IEEE80211_BAND_2GHZ : IEEE80211_BAND_5GHZ;
   channel->center_freq =
    ieee80211_channel_to_frequency(
@@ -202,15 +246,15 @@ static int iwl_init_channel_map(struct device *dev, const struct iwl_cfg *cfg,
 
   /* TODO: Need to be dependent to the NVM */
   channel->flags = IEEE80211_CHAN_NO_HT40;
-  if (ch_idx < NUM_2GHZ_CHANNELS &&
+  if (ch_idx < num_2ghz_channels &&
       (ch_flags & NVM_CHANNEL_40MHZ)) {
-   if (iwl_nvm_channels[ch_idx] <= LAST_2GHZ_HT_PLUS)
+   if (nvm_chan[ch_idx] <= LAST_2GHZ_HT_PLUS)
     channel->flags &= ~IEEE80211_CHAN_NO_HT40PLUS;
-   if (iwl_nvm_channels[ch_idx] >= FIRST_2GHZ_HT_MINUS)
+   if (nvm_chan[ch_idx] >= FIRST_2GHZ_HT_MINUS)
     channel->flags &= ~IEEE80211_CHAN_NO_HT40MINUS;
-  } else if (iwl_nvm_channels[ch_idx] <= LAST_5GHZ_HT &&
+  } else if (nvm_chan[ch_idx] <= LAST_5GHZ_HT &&
       (ch_flags & NVM_CHANNEL_40MHZ)) {
-   if ((ch_idx - NUM_2GHZ_CHANNELS) % 2 == 0)
+   if ((ch_idx - num_2ghz_channels) % 2 == 0)
     channel->flags &= ~IEEE80211_CHAN_NO_HT40PLUS;
    else
     channel->flags &= ~IEEE80211_CHAN_NO_HT40MINUS;
@@ -221,18 +265,21 @@ static int iwl_init_channel_map(struct device *dev, const struct iwl_cfg *cfg,
    channel->flags |= IEEE80211_CHAN_NO_160MHZ;
 
   if (!(ch_flags & NVM_CHANNEL_IBSS))
-   channel->flags |= IEEE80211_CHAN_NO_IBSS;
+   channel->flags |= IEEE80211_CHAN_NO_IR;
 
   if (!(ch_flags & NVM_CHANNEL_ACTIVE))
-   channel->flags |= IEEE80211_CHAN_PASSIVE_SCAN;
+   channel->flags |= IEEE80211_CHAN_NO_IR;
 
   if (ch_flags & NVM_CHANNEL_RADAR)
    channel->flags |= IEEE80211_CHAN_RADAR;
 
   /* Initialize regulatory-based run-time data */
 
-  /* TODO: read the real value from the NVM */
-  channel->max_power = 0;
+  /*
+   * Default value - highest tx power value.  max_power
+   * is not used in mvm, and is used for backwards compatibility
+   */
+  channel->max_power = DEFAULT_MAX_TX_POWER;
   is_5ghz = channel->band == IEEE80211_BAND_5GHZ;
   IWL_DEBUG_EEPROM(dev,
      "Ch. %d [%sGHz] %s%s%s%s%s%s(0x%02x %ddBm): Ad-Hoc %ssupported\n",
@@ -256,17 +303,25 @@ static int iwl_init_channel_map(struct device *dev, const struct iwl_cfg *cfg,
 
 static void iwl_init_vht_hw_capab(const struct iwl_cfg *cfg,
       struct iwl_nvm_data *data,
-      struct ieee80211_sta_vht_cap *vht_cap)
+      struct ieee80211_sta_vht_cap *vht_cap,
+      u8 tx_chains, u8 rx_chains)
 {
- /* For now, assume new devices with NVM are VHT capable */
+ int num_rx_ants = num_of_ant(rx_chains);
+ int num_tx_ants = num_of_ant(tx_chains);
 
  vht_cap->vht_supported = true;
 
  vht_cap->cap = IEEE80211_VHT_CAP_SHORT_GI_80 |
          IEEE80211_VHT_CAP_RXSTBC_1 |
          IEEE80211_VHT_CAP_SU_BEAMFORMEE_CAPABLE |
+         3 << IEEE80211_VHT_CAP_BEAMFORMEE_STS_SHIFT |
          7 << IEEE80211_VHT_CAP_MAX_A_MPDU_LENGTH_EXPONENT_SHIFT;
 
+ if (num_tx_ants > 1)
+  vht_cap->cap |= IEEE80211_VHT_CAP_TXSTBC;
+ else
+  vht_cap->cap |= IEEE80211_VHT_CAP_TX_ANTENNA_PATTERN;
+
  if (iwlwifi_mod_params.amsdu_size_8K)
   vht_cap->cap |= IEEE80211_VHT_CAP_MAX_MPDU_LENGTH_7991;
 
@@ -280,9 +335,8 @@ static void iwl_init_vht_hw_capab(const struct iwl_cfg *cfg,
        IEEE80211_VHT_MCS_NOT_SUPPORTED << 12 |
        IEEE80211_VHT_MCS_NOT_SUPPORTED << 14);
 
- if (data->valid_rx_ant == 1 || cfg->rx_with_siso_diversity) {
-  vht_cap->cap |= IEEE80211_VHT_CAP_RX_ANTENNA_PATTERN |
-    IEEE80211_VHT_CAP_TX_ANTENNA_PATTERN;
+ if (num_rx_ants == 1 || cfg->rx_with_siso_diversity) {
+  vht_cap->cap |= IEEE80211_VHT_CAP_RX_ANTENNA_PATTERN;
   /* this works because NOT_SUPPORTED == 3 */
   vht_cap->vht_mcs.rx_mcs_map |=
    cpu_to_le16(IEEE80211_VHT_MCS_NOT_SUPPORTED << 2);
@@ -292,20 +346,31 @@ static void iwl_init_vht_hw_capab(const struct iwl_cfg *cfg,
 }
 
 static void iwl_init_sbands(struct device *dev, const struct iwl_cfg *cfg,
-       struct iwl_nvm_data *data, const __le16 *nvm_sw)
+       struct iwl_nvm_data *data,
+       const __le16 *ch_section, bool enable_vht,
+       u8 tx_chains, u8 rx_chains)
 {
- int n_channels = iwl_init_channel_map(dev, cfg, data,
-   &nvm_sw[NVM_CHANNELS]);
+ int n_channels;
  int n_used = 0;
  struct ieee80211_supported_band *sband;
 
+ if (cfg->device_family != IWL_DEVICE_FAMILY_8000)
+  n_channels = iwl_init_channel_map(
+    dev, cfg, data,
+    &ch_section[NVM_CHANNELS]);
+ else
+  n_channels = iwl_init_channel_map(
+    dev, cfg, data,
+    &ch_section[NVM_CHANNELS_FAMILY_8000]);
+
  sband = &data->bands[IEEE80211_BAND_2GHZ];
  sband->band = IEEE80211_BAND_2GHZ;
  sband->bitrates = &iwl_cfg80211_rates[RATES_24_OFFS];
  sband->n_bitrates = N_RATES_24;
  n_used += iwl_init_sband_channels(data, sband, n_channels,
        IEEE80211_BAND_2GHZ);
- iwl_init_ht_hw_capab(cfg, data, &sband->ht_cap, IEEE80211_BAND_2GHZ);
+ iwl_init_ht_hw_capab(cfg, data, &sband->ht_cap, IEEE80211_BAND_2GHZ,
+        tx_chains, rx_chains);
 
  sband = &data->bands[IEEE80211_BAND_5GHZ];
  sband->band = IEEE80211_BAND_5GHZ;
@@ -313,80 +378,192 @@ static void iwl_init_sbands(struct device *dev, const struct iwl_cfg *cfg,
  sband->n_bitrates = N_RATES_52;
  n_used += iwl_init_sband_channels(data, sband, n_channels,
        IEEE80211_BAND_5GHZ);
- iwl_init_ht_hw_capab(cfg, data, &sband->ht_cap, IEEE80211_BAND_5GHZ);
- iwl_init_vht_hw_capab(cfg, data, &sband->vht_cap);
+ iwl_init_ht_hw_capab(cfg, data, &sband->ht_cap, IEEE80211_BAND_5GHZ,
+        tx_chains, rx_chains);
+ if (enable_vht)
+  iwl_init_vht_hw_capab(cfg, data, &sband->vht_cap,
+          tx_chains, rx_chains);
 
  if (n_channels != n_used)
   IWL_ERR_DEV(dev, "NVM: used only %d of %d channels\n",
        n_used, n_channels);
 }
 
+static int iwl_get_sku(const struct iwl_cfg *cfg,
+         const __le16 *nvm_sw)
+{
+ if (cfg->device_family != IWL_DEVICE_FAMILY_8000)
+  return le16_to_cpup(nvm_sw + SKU);
+ else
+  return le32_to_cpup((__le32 *)(nvm_sw + SKU_FAMILY_8000));
+}
+
+static int iwl_get_nvm_version(const struct iwl_cfg *cfg,
+          const __le16 *nvm_sw)
+{
+ if (cfg->device_family != IWL_DEVICE_FAMILY_8000)
+  return le16_to_cpup(nvm_sw + NVM_VERSION);
+ else
+  return le32_to_cpup((__le32 *)(nvm_sw +
+            NVM_VERSION_FAMILY_8000));
+}
+
+static int iwl_get_radio_cfg(const struct iwl_cfg *cfg,
+        const __le16 *nvm_sw)
+{
+ if (cfg->device_family != IWL_DEVICE_FAMILY_8000)
+  return le16_to_cpup(nvm_sw + RADIO_CFG);
+ else
+  return le32_to_cpup((__le32 *)(nvm_sw + RADIO_CFG_FAMILY_8000));
+}
+
+#define N_HW_ADDRS_MASK_FAMILY_8000 0xF
+static int iwl_get_n_hw_addrs(const struct iwl_cfg *cfg,
+         const __le16 *nvm_sw)
+{
+ if (cfg->device_family != IWL_DEVICE_FAMILY_8000)
+  return le16_to_cpup(nvm_sw + N_HW_ADDRS);
+ else
+  return le32_to_cpup((__le32 *)(nvm_sw + N_HW_ADDRS_FAMILY_8000))
+         & N_HW_ADDRS_MASK_FAMILY_8000;
+}
+
+static void iwl_set_radio_cfg(const struct iwl_cfg *cfg,
+         struct iwl_nvm_data *data,
+         u32 radio_cfg)
+{
+ if (cfg->device_family != IWL_DEVICE_FAMILY_8000) {
+  data->radio_cfg_type = NVM_RF_CFG_TYPE_MSK(radio_cfg);
+  data->radio_cfg_step = NVM_RF_CFG_STEP_MSK(radio_cfg);
+  data->radio_cfg_dash = NVM_RF_CFG_DASH_MSK(radio_cfg);
+  data->radio_cfg_pnum = NVM_RF_CFG_PNUM_MSK(radio_cfg);
+  return;
+ }
+
+ /* set the radio configuration for family 8000 */
+ data->radio_cfg_type = NVM_RF_CFG_TYPE_MSK_FAMILY_8000(radio_cfg);
+ data->radio_cfg_step = NVM_RF_CFG_STEP_MSK_FAMILY_8000(radio_cfg);
+ data->radio_cfg_dash = NVM_RF_CFG_DASH_MSK_FAMILY_8000(radio_cfg);
+ data->radio_cfg_pnum = NVM_RF_CFG_FLAVOR_MSK_FAMILY_8000(radio_cfg);
+}
+
+static void iwl_set_hw_address(const struct iwl_cfg *cfg,
+          struct iwl_nvm_data *data,
+          const __le16 *nvm_sec)
+{
+ const u8 *hw_addr = (const u8 *)(nvm_sec + HW_ADDR);
+
+ /* The byte order is little endian 16 bit, meaning 214365 */
+ data->hw_addr[0] = hw_addr[1];
+ data->hw_addr[1] = hw_addr[0];
+ data->hw_addr[2] = hw_addr[3];
+ data->hw_addr[3] = hw_addr[2];
+ data->hw_addr[4] = hw_addr[5];
+ data->hw_addr[5] = hw_addr[4];
+}
+
+static void iwl_set_hw_address_family_8000(const struct iwl_cfg *cfg,
+        struct iwl_nvm_data *data,
+        const __le16 *mac_override,
+        const __le16 *nvm_hw)
+{
+ const u8 *hw_addr;
+
+ if (mac_override) {
+  hw_addr = (const u8 *)(mac_override +
+     MAC_ADDRESS_OVERRIDE_FAMILY_8000);
+
+  /* The byte order is little endian 16 bit, meaning 214365 */
+  data->hw_addr[0] = hw_addr[1];
+  data->hw_addr[1] = hw_addr[0];
+  data->hw_addr[2] = hw_addr[3];
+  data->hw_addr[3] = hw_addr[2];
+  data->hw_addr[4] = hw_addr[5];
+  data->hw_addr[5] = hw_addr[4];
+
+  if (is_valid_ether_addr(hw_addr))
+   return;
+ }
+
+ /* take the MAC address from the OTP */
+ hw_addr = (const u8 *)(nvm_hw + HW_ADDR0_FAMILY_8000);
+ data->hw_addr[0] = hw_addr[3];
+ data->hw_addr[1] = hw_addr[2];
+ data->hw_addr[2] = hw_addr[1];
+ data->hw_addr[3] = hw_addr[0];
+
+ hw_addr = (const u8 *)(nvm_hw + HW_ADDR1_FAMILY_8000);
+ data->hw_addr[4] = hw_addr[1];
+ data->hw_addr[5] = hw_addr[0];
+}
+
 struct iwl_nvm_data *
 iwl_parse_nvm_data(struct device *dev, const struct iwl_cfg *cfg,
      const __le16 *nvm_hw, const __le16 *nvm_sw,
-     const __le16 *nvm_calib)
+     const __le16 *nvm_calib, const __le16 *regulatory,
+     const __le16 *mac_override, u8 tx_chains, u8 rx_chains)
 {
  struct iwl_nvm_data *data;
- u8 hw_addr[ETH_ALEN];
- u16 radio_cfg, sku;
-
- data = kzalloc(sizeof(*data) +
-         sizeof(struct ieee80211_channel) * IWL_NUM_CHANNELS,
-         GFP_KERNEL);
+ u32 sku;
+ u32 radio_cfg;
+
+ if (cfg->device_family != IWL_DEVICE_FAMILY_8000)
+  data = kzalloc(sizeof(*data) +
+          sizeof(struct ieee80211_channel) *
+          IWL_NUM_CHANNELS,
+          GFP_KERNEL);
+ else
+  data = kzalloc(sizeof(*data) +
+          sizeof(struct ieee80211_channel) *
+          IWL_NUM_CHANNELS_FAMILY_8000,
+          GFP_KERNEL);
  if (!data)
   return NULL;
 
- data->nvm_version = le16_to_cpup(nvm_sw + NVM_VERSION);
+ data->nvm_version = iwl_get_nvm_version(cfg, nvm_sw);
 
- radio_cfg = le16_to_cpup(nvm_sw + RADIO_CFG);
- data->radio_cfg_type = NVM_RF_CFG_TYPE_MSK(radio_cfg);
- data->radio_cfg_step = NVM_RF_CFG_STEP_MSK(radio_cfg);
- data->radio_cfg_dash = NVM_RF_CFG_DASH_MSK(radio_cfg);
- data->radio_cfg_pnum = NVM_RF_CFG_PNUM_MSK(radio_cfg);
- data->valid_tx_ant = NVM_RF_CFG_TX_ANT_MSK(radio_cfg);
- data->valid_rx_ant = NVM_RF_CFG_RX_ANT_MSK(radio_cfg);
+ radio_cfg = iwl_get_radio_cfg(cfg, nvm_sw);
+ iwl_set_radio_cfg(cfg, data, radio_cfg);
 
- sku = le16_to_cpup(nvm_sw + SKU);
+ sku = iwl_get_sku(cfg, nvm_sw);
  data->sku_cap_band_24GHz_enable = sku & NVM_SKU_CAP_BAND_24GHZ;
  data->sku_cap_band_52GHz_enable = sku & NVM_SKU_CAP_BAND_52GHZ;
  data->sku_cap_11n_enable = sku & NVM_SKU_CAP_11N_ENABLE;
+ data->sku_cap_11ac_enable = sku & NVM_SKU_CAP_11AC_ENABLE;
  if (iwlwifi_mod_params.disable_11n & IWL_DISABLE_HT_ALL)
   data->sku_cap_11n_enable = false;
 
- /* check overrides (some devices have wrong NVM) */
- if (cfg->valid_tx_ant)
-  data->valid_tx_ant = cfg->valid_tx_ant;
- if (cfg->valid_rx_ant)
-  data->valid_rx_ant = cfg->valid_rx_ant;
+ data->n_hw_addrs = iwl_get_n_hw_addrs(cfg, nvm_sw);
 
- if (!data->valid_tx_ant || !data->valid_rx_ant) {
-  IWL_ERR_DEV(dev, "invalid antennas (0x%x, 0x%x)\n",
-       data->valid_tx_ant, data->valid_rx_ant);
-  kfree(data);
-  return NULL;
+ if (cfg->device_family != IWL_DEVICE_FAMILY_8000) {
+  /* Checking for required sections */
+  if (!nvm_calib) {
+   IWL_ERR_DEV(dev,
+        "Can't parse empty Calib NVM sections\n");
+   kfree(data);
+   return NULL;
+  }
+  /* in family 8000 Xtal calibration values moved to OTP */
+  data->xtal_calib[0] = *(nvm_calib + XTAL_CALIB);
+  data->xtal_calib[1] = *(nvm_calib + XTAL_CALIB + 1);
  }
 
- data->n_hw_addrs = le16_to_cpup(nvm_sw + N_HW_ADDRS);
+ if (cfg->device_family != IWL_DEVICE_FAMILY_8000) {
+  iwl_set_hw_address(cfg, data, nvm_hw);
 
- data->xtal_calib[0] = *(nvm_calib + XTAL_CALIB);
- data->xtal_calib[1] = *(nvm_calib + XTAL_CALIB + 1);
+  iwl_init_sbands(dev, cfg, data, nvm_sw,
+    sku & NVM_SKU_CAP_11AC_ENABLE, tx_chains,
+    rx_chains);
+ } else {
+  /* MAC address in family 8000 */
+  iwl_set_hw_address_family_8000(cfg, data, mac_override, nvm_hw);
 
- /* The byte order is little endian 16 bit, meaning 214365 */
- memcpy(hw_addr, nvm_hw + HW_ADDR, ETH_ALEN);
- data->hw_addr[0] = hw_addr[1];
- data->hw_addr[1] = hw_addr[0];
- data->hw_addr[2] = hw_addr[3];
- data->hw_addr[3] = hw_addr[2];
- data->hw_addr[4] = hw_addr[5];
- data->hw_addr[5] = hw_addr[4];
-
- iwl_init_sbands(dev, cfg, data, nvm_sw);
+  iwl_init_sbands(dev, cfg, data, regulatory,
+    sku & NVM_SKU_CAP_11AC_ENABLE, tx_chains,
+    rx_chains);
+ }
 
- data->calib_version = 255;   /* TODO:
-     this value will prevent some checks from
-     failing, we need to check if this
-     field is still needed, and if it does,
-     where is it in the NVM*/
+ data->calib_version = 255;
 
  return data;
 }
diff --git a/drivers/net/wireless/iwlwifi/iwl-nvm-parse.h b/drivers/net/wireless/iwlwifi/iwl-nvm-parse.h
index e57fb98..c9c45a3 100644
--- a/drivers/net/wireless/iwlwifi/iwl-nvm-parse.h
+++ b/drivers/net/wireless/iwlwifi/iwl-nvm-parse.h
@@ -5,7 +5,7 @@
  *
  * GPL LICENSE SUMMARY
  *
- * Copyright(c) 2008 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2008 - 2014 Intel Corporation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of version 2 of the GNU General Public License as
@@ -30,7 +30,7 @@
  *
  * BSD LICENSE
  *
- * Copyright(c) 2005 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2005 - 2014 Intel Corporation. All rights reserved.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -75,6 +75,7 @@
 struct iwl_nvm_data *
 iwl_parse_nvm_data(struct device *dev, const struct iwl_cfg *cfg,
      const __le16 *nvm_hw, const __le16 *nvm_sw,
-     const __le16 *nvm_calib);
+     const __le16 *nvm_calib, const __le16 *regulatory,
+     const __le16 *mac_override, u8 tx_chains, u8 rx_chains);
 
 #endif /* __iwl_nvm_parse_h__ */
diff --git a/drivers/net/wireless/iwlwifi/iwl-op-mode.h b/drivers/net/wireless/iwlwifi/iwl-op-mode.h
index 98c7aa7..99785c8 100644
--- a/drivers/net/wireless/iwlwifi/iwl-op-mode.h
+++ b/drivers/net/wireless/iwlwifi/iwl-op-mode.h
@@ -5,7 +5,7 @@
  *
  * GPL LICENSE SUMMARY
  *
- * Copyright(c) 2007 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2007 - 2014 Intel Corporation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of version 2 of the GNU General Public License as
@@ -30,7 +30,7 @@
  *
  * BSD LICENSE
  *
- * Copyright(c) 2005 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2005 - 2014 Intel Corporation. All rights reserved.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -63,6 +63,7 @@
 #ifndef __iwl_op_mode_h__
 #define __iwl_op_mode_h__
 
+#include <linux/netdevice.h>
 #include <linux/debugfs.h>
 
 struct iwl_op_mode;
@@ -93,7 +94,7 @@ struct iwl_cfg;
  * 1) The driver layer (iwl-drv.c) chooses the op_mode based on the
  *    capabilities advertized by the fw file (in TLV format).
  * 2) The driver layer starts the op_mode (ops->start)
- * 3) The op_mode registers registers mac80211
+ * 3) The op_mode registers mac80211
  * 4) The op_mode is governed by mac80211
  * 5) The driver layer stops the op_mode
  */
@@ -112,14 +113,18 @@ struct iwl_cfg;
  * @stop: stop the op_mode. Must free all the memory allocated.
  * May sleep
  * @rx: Rx notification to the op_mode. rxb is the Rx buffer itself. Cmd is the
- * HCMD the this Rx responds to.
- * This callback may sleep, it is called from a threaded IRQ handler.
+ * HCMD this Rx responds to. Can't sleep.
+ * @napi_add: NAPI initialisation. The transport is fully responsible for NAPI,
+ * but the higher layers need to know about it (in particular mac80211 to
+ * to able to call the right NAPI RX functions); this function is needed
+ * to eventually call netif_napi_add() with higher layer involvement.
  * @queue_full: notifies that a HW queue is full.
  * Must be atomic and called with BH disabled.
  * @queue_not_full: notifies that a HW queue is not full any more.
  * Must be atomic and called with BH disabled.
  * @hw_rf_kill:notifies of a change in the HW rf kill switch. True means that
- * the radio is killed. May sleep.
+ * the radio is killed. Return %true if the device should be stopped by
+ * the transport immediately after the call. May sleep.
  * @free_skb: allows the transport layer to free skbs that haven't been
  * reclaimed by the op_mode. This can happen when the driver is freed and
  * there are Tx packets pending in the transport layer.
@@ -131,6 +136,8 @@ struct iwl_cfg;
  * @nic_config: configure NIC, called before firmware is started.
  * May sleep
  * @wimax_active: invoked when WiMax becomes active. May sleep
+ * @enter_d0i3: configure the fw to enter d0i3. May sleep.
+ * @exit_d0i3: configure the fw to exit d0i3. May sleep.
  */
 struct iwl_op_mode_ops {
  struct iwl_op_mode *(*start)(struct iwl_trans *trans,
@@ -140,14 +147,21 @@ struct iwl_op_mode_ops {
  void (*stop)(struct iwl_op_mode *op_mode);
  int (*rx)(struct iwl_op_mode *op_mode, struct iwl_rx_cmd_buffer *rxb,
     struct iwl_device_cmd *cmd);
+ void (*napi_add)(struct iwl_op_mode *op_mode,
+    struct napi_struct *napi,
+    struct net_device *napi_dev,
+    int (*poll)(struct napi_struct *, int),
+    int weight);
  void (*queue_full)(struct iwl_op_mode *op_mode, int queue);
  void (*queue_not_full)(struct iwl_op_mode *op_mode, int queue);
- void (*hw_rf_kill)(struct iwl_op_mode *op_mode, bool state);
+ bool (*hw_rf_kill)(struct iwl_op_mode *op_mode, bool state);
  void (*free_skb)(struct iwl_op_mode *op_mode, struct sk_buff *skb);
  void (*nic_error)(struct iwl_op_mode *op_mode);
  void (*cmd_queue_full)(struct iwl_op_mode *op_mode);
  void (*nic_config)(struct iwl_op_mode *op_mode);
  void (*wimax_active)(struct iwl_op_mode *op_mode);
+ int (*enter_d0i3)(struct iwl_op_mode *op_mode);
+ int (*exit_d0i3)(struct iwl_op_mode *op_mode);
 };
 
 int iwl_opmode_register(const char *name, const struct iwl_op_mode_ops *ops);
@@ -155,14 +169,12 @@ void iwl_opmode_deregister(const char *name);
 
 /**
  * struct iwl_op_mode - operational mode
+ * @ops: pointer to its own ops
  *
  * This holds an implementation of the mac80211 / fw API.
- *
- * @ops - pointer to its own ops
  */
 struct iwl_op_mode {
  const struct iwl_op_mode_ops *ops;
- const struct iwl_trans *trans;
 
  char op_mode_specific[0] __aligned(sizeof(void *));
 };
@@ -177,7 +189,6 @@ static inline int iwl_op_mode_rx(struct iwl_op_mode *op_mode,
       struct iwl_rx_cmd_buffer *rxb,
       struct iwl_device_cmd *cmd)
 {
- might_sleep();
  return op_mode->ops->rx(op_mode, rxb, cmd);
 }
 
@@ -193,11 +204,11 @@ static inline void iwl_op_mode_queue_not_full(struct iwl_op_mode *op_mode,
  op_mode->ops->queue_not_full(op_mode, queue);
 }
 
-static inline void iwl_op_mode_hw_rf_kill(struct iwl_op_mode *op_mode,
-       bool state)
+static inline bool __must_check
+iwl_op_mode_hw_rf_kill(struct iwl_op_mode *op_mode, bool state)
 {
  might_sleep();
- op_mode->ops->hw_rf_kill(op_mode, state);
+ return op_mode->ops->hw_rf_kill(op_mode, state);
 }
 
 static inline void iwl_op_mode_free_skb(struct iwl_op_mode *op_mode,
@@ -228,4 +239,33 @@ static inline void iwl_op_mode_wimax_active(struct iwl_op_mode *op_mode)
  op_mode->ops->wimax_active(op_mode);
 }
 
+static inline int iwl_op_mode_enter_d0i3(struct iwl_op_mode *op_mode)
+{
+ might_sleep();
+
+ if (!op_mode->ops->enter_d0i3)
+  return 0;
+ return op_mode->ops->enter_d0i3(op_mode);
+}
+
+static inline int iwl_op_mode_exit_d0i3(struct iwl_op_mode *op_mode)
+{
+ might_sleep();
+
+ if (!op_mode->ops->exit_d0i3)
+  return 0;
+ return op_mode->ops->exit_d0i3(op_mode);
+}
+
+static inline void iwl_op_mode_napi_add(struct iwl_op_mode *op_mode,
+     struct napi_struct *napi,
+     struct net_device *napi_dev,
+     int (*poll)(struct napi_struct *, int),
+     int weight)
+{
+ if (!op_mode->ops->napi_add)
+  return;
+ op_mode->ops->napi_add(op_mode, napi, napi_dev, poll, weight);
+}
+
 #endif /* __iwl_op_mode_h__ */
diff --git a/drivers/net/wireless/iwlwifi/iwl-phy-db.c b/drivers/net/wireless/iwlwifi/iwl-phy-db.c
index 25745da..d4fb5ca 100644
--- a/drivers/net/wireless/iwlwifi/iwl-phy-db.c
+++ b/drivers/net/wireless/iwlwifi/iwl-phy-db.c
@@ -5,7 +5,7 @@
  *
  * GPL LICENSE SUMMARY
  *
- * Copyright(c) 2007 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2007 - 2014 Intel Corporation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of version 2 of the GNU General Public License as
@@ -30,7 +30,7 @@
  *
  * BSD LICENSE
  *
- * Copyright(c) 2005 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2005 - 2014 Intel Corporation. All rights reserved.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -72,7 +72,7 @@
 #include "iwl-trans.h"
 
 #define CHANNEL_NUM_SIZE 4 /* num of channels in calib_ch size */
-#define IWL_NUM_PAPD_CH_GROUPS 4
+#define IWL_NUM_PAPD_CH_GROUPS 7
 #define IWL_NUM_TXP_CH_GROUPS 9
 
 struct iwl_phy_db_entry {
@@ -92,20 +92,16 @@ struct iwl_phy_db_entry {
 struct iwl_phy_db {
  struct iwl_phy_db_entry cfg;
  struct iwl_phy_db_entry calib_nch;
- struct iwl_phy_db_entry calib_ch;
  struct iwl_phy_db_entry calib_ch_group_papd[IWL_NUM_PAPD_CH_GROUPS];
  struct iwl_phy_db_entry calib_ch_group_txp[IWL_NUM_TXP_CH_GROUPS];
 
- u32 channel_num;
- u32 channel_size;
-
  struct iwl_trans *trans;
 };
 
 enum iwl_phy_db_section_type {
  IWL_PHY_DB_CFG = 1,
  IWL_PHY_DB_CALIB_NCH,
- IWL_PHY_DB_CALIB_CH,
+ IWL_PHY_DB_UNUSED,
  IWL_PHY_DB_CALIB_CHG_PAPD,
  IWL_PHY_DB_CALIB_CHG_TXP,
  IWL_PHY_DB_MAX
@@ -169,8 +165,6 @@ iwl_phy_db_get_section(struct iwl_phy_db *phy_db,
   return &phy_db->cfg;
  case IWL_PHY_DB_CALIB_NCH:
   return &phy_db->calib_nch;
- case IWL_PHY_DB_CALIB_CH:
-  return &phy_db->calib_ch;
  case IWL_PHY_DB_CALIB_CHG_PAPD:
   if (chg_id >= IWL_NUM_PAPD_CH_GROUPS)
    return NULL;
@@ -208,7 +202,6 @@ void iwl_phy_db_free(struct iwl_phy_db *phy_db)
 
  iwl_phy_db_free_section(phy_db, IWL_PHY_DB_CFG, 0);
  iwl_phy_db_free_section(phy_db, IWL_PHY_DB_CALIB_NCH, 0);
- iwl_phy_db_free_section(phy_db, IWL_PHY_DB_CALIB_CH, 0);
  for (i = 0; i < IWL_NUM_PAPD_CH_GROUPS; i++)
   iwl_phy_db_free_section(phy_db, IWL_PHY_DB_CALIB_CHG_PAPD, i);
  for (i = 0; i < IWL_NUM_TXP_CH_GROUPS; i++)
@@ -248,13 +241,6 @@ int iwl_phy_db_set_section(struct iwl_phy_db *phy_db, struct iwl_rx_packet *pkt,
 
  entry->size = size;
 
- if (type == IWL_PHY_DB_CALIB_CH) {
-  phy_db->channel_num =
-   le32_to_cpup((__le32 *)phy_db_notif->data);
-  phy_db->channel_size =
-   (size - CHANNEL_NUM_SIZE) / phy_db->channel_num;
- }
-
  IWL_DEBUG_INFO(phy_db->trans,
          "%s(%d): [PHYDB]SET: Type %d , Size: %d\n",
          __func__, __LINE__, type, size);
@@ -328,10 +314,7 @@ int iwl_phy_db_get_section_data(struct iwl_phy_db *phy_db,
     u32 type, u8 **data, u16 *size, u16 ch_id)
 {
  struct iwl_phy_db_entry *entry;
- u32 channel_num;
- u32 channel_size;
  u16 ch_group_id = 0;
- u16 index;
 
  if (!phy_db)
   return -EINVAL;
@@ -346,21 +329,8 @@ int iwl_phy_db_get_section_data(struct iwl_phy_db *phy_db,
  if (!entry)
   return -EINVAL;
 
- if (type == IWL_PHY_DB_CALIB_CH) {
-  index = ch_id_to_ch_index(ch_id);
-  channel_num = phy_db->channel_num;
-  channel_size = phy_db->channel_size;
-  if (index >= channel_num) {
-   IWL_ERR(phy_db->trans, "Wrong channel number %d\n",
-    ch_id);
-   return -EINVAL;
-  }
-  *data = entry->data + CHANNEL_NUM_SIZE + index * channel_size;
-  *size = channel_size;
- } else {
-  *data = entry->data;
-  *size = entry->size;
- }
+ *data = entry->data;
+ *size = entry->size;
 
  IWL_DEBUG_INFO(phy_db->trans,
          "%s(%d): [PHYDB] GET: Type %d , Size: %d\n",
@@ -375,7 +345,6 @@ static int iwl_send_phy_db_cmd(struct iwl_phy_db *phy_db, u16 type,
  struct iwl_phy_db_cmd phy_db_cmd;
  struct iwl_host_cmd cmd = {
   .id = PHY_DB_CMD,
-  .flags = CMD_SYNC,
  };
 
  IWL_DEBUG_INFO(phy_db->trans,
@@ -413,6 +382,9 @@ static int iwl_phy_db_send_all_channel_groups(
   if (!entry)
    return -EINVAL;
 
+  if (!entry->size)
+   continue;
+
   /* Send the requested PHY DB section */
   err = iwl_send_phy_db_cmd(phy_db,
        type,
@@ -420,13 +392,13 @@ static int iwl_phy_db_send_all_channel_groups(
        entry->data);
   if (err) {
    IWL_ERR(phy_db->trans,
-    "Can't SEND phy_db section %d (%d), err %d",
+    "Can't SEND phy_db section %d (%d), err %d\n",
     type, i, err);
    return err;
   }
 
   IWL_DEBUG_INFO(phy_db->trans,
-          "Sent PHY_DB HCMD, type = %d num = %d",
+          "Sent PHY_DB HCMD, type = %d num = %d\n",
           type, i);
  }
 
@@ -478,7 +450,7 @@ int iwl_send_phy_db_data(struct iwl_phy_db *phy_db)
        IWL_NUM_PAPD_CH_GROUPS);
  if (err) {
   IWL_ERR(phy_db->trans,
-   "Cannot send channel specific PAPD groups");
+   "Cannot send channel specific PAPD groups\n");
   return err;
  }
 
@@ -488,7 +460,7 @@ int iwl_send_phy_db_data(struct iwl_phy_db *phy_db)
        IWL_NUM_TXP_CH_GROUPS);
  if (err) {
   IWL_ERR(phy_db->trans,
-   "Cannot send channel specific TX power groups");
+   "Cannot send channel specific TX power groups\n");
   return err;
  }
 
diff --git a/drivers/net/wireless/iwlwifi/iwl-phy-db.h b/drivers/net/wireless/iwlwifi/iwl-phy-db.h
index ce983af..9ee18d0 100644
--- a/drivers/net/wireless/iwlwifi/iwl-phy-db.h
+++ b/drivers/net/wireless/iwlwifi/iwl-phy-db.h
@@ -5,7 +5,7 @@
  *
  * GPL LICENSE SUMMARY
  *
- * Copyright(c) 2007 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2007 - 2014 Intel Corporation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of version 2 of the GNU General Public License as
@@ -30,7 +30,7 @@
  *
  * BSD LICENSE
  *
- * Copyright(c) 2005 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2005 - 2014 Intel Corporation. All rights reserved.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/drivers/net/wireless/iwlwifi/iwl-prph.h b/drivers/net/wireless/iwlwifi/iwl-prph.h
index 386f2a7..4997e27 100644
--- a/drivers/net/wireless/iwlwifi/iwl-prph.h
+++ b/drivers/net/wireless/iwlwifi/iwl-prph.h
@@ -5,7 +5,7 @@
  *
  * GPL LICENSE SUMMARY
  *
- * Copyright(c) 2005 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2005 - 2014 Intel Corporation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of version 2 of the GNU General Public License as
@@ -30,7 +30,7 @@
  *
  * BSD LICENSE
  *
- * Copyright(c) 2005 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2005 - 2014 Intel Corporation. All rights reserved.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -95,11 +95,59 @@
 #define APMG_SVR_VOLTAGE_CONFIG_BIT_MSK (0x000001E0) /* bit 8:5 */
 #define APMG_SVR_DIGITAL_VOLTAGE_1_32  (0x00000060)
 
-#define APMG_PCIDEV_STT_VAL_L1_ACT_DIS  (0x00000800)
+#define APMG_PCIDEV_STT_VAL_PERSIST_DIS (0x00000200)
+#define APMG_PCIDEV_STT_VAL_L1_ACT_DIS (0x00000800)
+
+#define APMG_RTC_INT_STT_RFKILL  (0x10000000)
 
 /* Device system time */
 #define DEVICE_SYSTEM_TIME_REG 0xA0206C
 
+/* Device NMI register */
+#define DEVICE_SET_NMI_REG 0x00a01c30
+#define DEVICE_SET_NMI_VAL 0x1
+#define DEVICE_SET_NMI_8000B_REG 0x00a01c24
+#define DEVICE_SET_NMI_8000B_VAL 0x1000000
+
+/* Shared registers (0x0..0x3ff, via target indirect or periphery */
+#define SHR_BASE 0x00a10000
+
+/* Shared GP1 register */
+#define SHR_APMG_GP1_REG  0x01dc
+#define SHR_APMG_GP1_REG_PRPH  (SHR_BASE + SHR_APMG_GP1_REG)
+#define SHR_APMG_GP1_WF_XTAL_LP_EN 0x00000004
+#define SHR_APMG_GP1_CHICKEN_BIT_SELECT 0x80000000
+
+/* Shared DL_CFG register */
+#define SHR_APMG_DL_CFG_REG   0x01c4
+#define SHR_APMG_DL_CFG_REG_PRPH  (SHR_BASE + SHR_APMG_DL_CFG_REG)
+#define SHR_APMG_DL_CFG_RTCS_CLK_SELECTOR_MSK 0x000000c0
+#define SHR_APMG_DL_CFG_RTCS_CLK_INTERNAL_XTAL 0x00000080
+#define SHR_APMG_DL_CFG_DL_CLOCK_POWER_UP 0x00000100
+
+/* Shared APMG_XTAL_CFG register */
+#define SHR_APMG_XTAL_CFG_REG  0x1c0
+#define SHR_APMG_XTAL_CFG_XTAL_ON_REQ 0x80000000
+
+/*
+ * Device reset for family 8000
+ * write to bit 24 in order to reset the CPU
+*/
+#define RELEASE_CPU_RESET  (0x300C)
+#define RELEASE_CPU_RESET_BIT  BIT(24)
+
+/*****************************************************************************
+ *                        7000/3000 series SHR DTS addresses                 *
+ *****************************************************************************/
+
+#define SHR_MISC_WFM_DTS_EN (0x00a10024)
+#define DTSC_CFG_MODE  (0x00a10604)
+#define DTSC_VREF_AVG  (0x00a10648)
+#define DTSC_VREF5_AVG  (0x00a1064c)
+#define DTSC_CFG_MODE_PERIODIC (0x2)
+#define DTSC_PTAT_AVG  (0x00a10650)
+
+
 /**
  * Tx Scheduler
  *
@@ -260,4 +308,55 @@ static inline unsigned int SCD_QUEUE_STATUS_BITS(unsigned int chnl)
 
 /*********************** END TX SCHEDULER *************************************/
 
+/* Oscillator clock */
+#define OSC_CLK    (0xa04068)
+#define OSC_CLK_FORCE_CONTROL  (0x8)
+
+/* SECURE boot registers */
+#define LMPM_SECURE_BOOT_CONFIG_ADDR (0x100)
+enum secure_boot_config_reg {
+ LMPM_SECURE_BOOT_CONFIG_INSPECTOR_BURNED_IN_OTP = 0x00000001,
+ LMPM_SECURE_BOOT_CONFIG_INSPECTOR_NOT_REQ = 0x00000002,
+};
+
+#define LMPM_SECURE_BOOT_CPU1_STATUS_ADDR (0x1E30)
+#define LMPM_SECURE_BOOT_CPU2_STATUS_ADDR (0x1E34)
+enum secure_boot_status_reg {
+ LMPM_SECURE_BOOT_CPU_STATUS_VERF_STATUS  = 0x00000001,
+ LMPM_SECURE_BOOT_CPU_STATUS_VERF_COMPLETED = 0x00000002,
+ LMPM_SECURE_BOOT_CPU_STATUS_VERF_SUCCESS = 0x00000004,
+ LMPM_SECURE_BOOT_CPU_STATUS_VERF_FAIL  = 0x00000008,
+ LMPM_SECURE_BOOT_CPU_STATUS_SIGN_VERF_FAIL = 0x00000010,
+ LMPM_SECURE_BOOT_STATUS_SUCCESS   = 0x00000003,
+};
+
+#define CSR_UCODE_LOAD_STATUS_ADDR (0x1E70)
+enum secure_load_status_reg {
+ LMPM_CPU_UCODE_LOADING_STARTED   = 0x00000001,
+ LMPM_CPU_HDRS_LOADING_COMPLETED   = 0x00000003,
+ LMPM_CPU_UCODE_LOADING_COMPLETED  = 0x00000007,
+ LMPM_CPU_STATUS_NUM_OF_LAST_COMPLETED  = 0x000000F8,
+ LMPM_CPU_STATUS_NUM_OF_LAST_LOADED_BLOCK = 0x0000FF00,
+};
+
+#define LMPM_SECURE_INSPECTOR_CODE_ADDR (0x1E38)
+#define LMPM_SECURE_INSPECTOR_DATA_ADDR (0x1E3C)
+#define LMPM_SECURE_UCODE_LOAD_CPU1_HDR_ADDR (0x1E78)
+#define LMPM_SECURE_UCODE_LOAD_CPU2_HDR_ADDR (0x1E7C)
+
+#define LMPM_SECURE_INSPECTOR_CODE_MEM_SPACE (0x400000)
+#define LMPM_SECURE_INSPECTOR_DATA_MEM_SPACE (0x402000)
+#define LMPM_SECURE_CPU1_HDR_MEM_SPACE  (0x420000)
+#define LMPM_SECURE_CPU2_HDR_MEM_SPACE  (0x420400)
+
+#define LMPM_SECURE_TIME_OUT (100)
+
+/* Rx FIFO */
+#define RXF_SIZE_ADDR   (0xa00c88)
+#define RXF_SIZE_BYTE_CND_POS  (7)
+#define RXF_SIZE_BYTE_CNT_MSK  (0x3ff << RXF_SIZE_BYTE_CND_POS)
+
+#define RXF_LD_FENCE_OFFSET_ADDR (0xa00c10)
+#define RXF_FIFO_RD_FENCE_ADDR  (0xa00c0c)
+
 #endif    /* __iwl_prph_h__ */
diff --git a/drivers/net/wireless/iwlwifi/iwl-test.c b/drivers/net/wireless/iwlwifi/iwl-test.c
deleted file mode 100644
index 5cfd55b..0000000
--- a/drivers/net/wireless/iwlwifi/iwl-test.c
+++ /dev/null
@@ -1,852 +0,0 @@
-/******************************************************************************
- *
- * This file is provided under a dual BSD/GPLv2 license.  When using or
- * redistributing this file, you may do so under either license.
- *
- * GPL LICENSE SUMMARY
- *
- * Copyright(c) 2010 - 2013 Intel Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110,
- * USA
- *
- * The full GNU General Public License is included in this distribution
- * in the file called COPYING.
- *
- * Contact Information:
- *  Intel Linux Wireless <ilw@linux.intel.com>
- * Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497
- *
- * BSD LICENSE
- *
- * Copyright(c) 2010 - 2013 Intel Corporation. All rights reserved.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- *  * Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- *  * Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *  * Neither the name Intel Corporation nor the names of its
- *    contributors may be used to endorse or promote products derived
- *    from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- *
- *****************************************************************************/
-
-#include <linux/export.h>
-#include <net/netlink.h>
-
-#include "iwl-drv.h"
-#include "iwl-io.h"
-#include "iwl-fh.h"
-#include "iwl-prph.h"
-#include "iwl-trans.h"
-#include "iwl-test.h"
-#include "iwl-csr.h"
-#include "iwl-testmode.h"
-
-/*
- * Periphery registers absolute lower bound. This is used in order to
- * differentiate registery access through HBUS_TARG_PRPH_* and
- * HBUS_TARG_MEM_* accesses.
- */
-#define IWL_ABS_PRPH_START (0xA00000)
-
-/*
- * The TLVs used in the gnl message policy between the kernel module and
- * user space application. iwl_testmode_gnl_msg_policy is to be carried
- * through the NL80211_CMD_TESTMODE channel regulated by nl80211.
- * See iwl-testmode.h
- */
-static
-struct nla_policy iwl_testmode_gnl_msg_policy[IWL_TM_ATTR_MAX] = {
- [IWL_TM_ATTR_COMMAND] = { .type = NLA_U32, },
-
- [IWL_TM_ATTR_UCODE_CMD_ID] = { .type = NLA_U8, },
- [IWL_TM_ATTR_UCODE_CMD_DATA] = { .type = NLA_UNSPEC, },
-
- [IWL_TM_ATTR_REG_OFFSET] = { .type = NLA_U32, },
- [IWL_TM_ATTR_REG_VALUE8] = { .type = NLA_U8, },
- [IWL_TM_ATTR_REG_VALUE32] = { .type = NLA_U32, },
-
- [IWL_TM_ATTR_SYNC_RSP] = { .type = NLA_UNSPEC, },
- [IWL_TM_ATTR_UCODE_RX_PKT] = { .type = NLA_UNSPEC, },
-
- [IWL_TM_ATTR_EEPROM] = { .type = NLA_UNSPEC, },
-
- [IWL_TM_ATTR_TRACE_ADDR] = { .type = NLA_UNSPEC, },
- [IWL_TM_ATTR_TRACE_DUMP] = { .type = NLA_UNSPEC, },
- [IWL_TM_ATTR_TRACE_SIZE] = { .type = NLA_U32, },
-
- [IWL_TM_ATTR_FIXRATE] = { .type = NLA_U32, },
-
- [IWL_TM_ATTR_UCODE_OWNER] = { .type = NLA_U8, },
-
- [IWL_TM_ATTR_MEM_ADDR] = { .type = NLA_U32, },
- [IWL_TM_ATTR_BUFFER_SIZE] = { .type = NLA_U32, },
- [IWL_TM_ATTR_BUFFER_DUMP] = { .type = NLA_UNSPEC, },
-
- [IWL_TM_ATTR_FW_VERSION] = { .type = NLA_U32, },
- [IWL_TM_ATTR_DEVICE_ID] = { .type = NLA_U32, },
- [IWL_TM_ATTR_FW_TYPE] = { .type = NLA_U32, },
- [IWL_TM_ATTR_FW_INST_SIZE] = { .type = NLA_U32, },
- [IWL_TM_ATTR_FW_DATA_SIZE] = { .type = NLA_U32, },
-
- [IWL_TM_ATTR_ENABLE_NOTIFICATION] = {.type = NLA_FLAG, },
-};
-
-static inline void iwl_test_trace_clear(struct iwl_test *tst)
-{
- memset(&tst->trace, 0, sizeof(struct iwl_test_trace));
-}
-
-static void iwl_test_trace_stop(struct iwl_test *tst)
-{
- if (!tst->trace.enabled)
-  return;
-
- if (tst->trace.cpu_addr && tst->trace.dma_addr)
-  dma_free_coherent(tst->trans->dev,
-      tst->trace.tsize,
-      tst->trace.cpu_addr,
-      tst->trace.dma_addr);
-
- iwl_test_trace_clear(tst);
-}
-
-static inline void iwl_test_mem_clear(struct iwl_test *tst)
-{
- memset(&tst->mem, 0, sizeof(struct iwl_test_mem));
-}
-
-static inline void iwl_test_mem_stop(struct iwl_test *tst)
-{
- if (!tst->mem.in_read)
-  return;
-
- iwl_test_mem_clear(tst);
-}
-
-/*
- * Initializes the test object
- * During the lifetime of the test object it is assumed that the transport is
- * started. The test object should be stopped before the transport is stopped.
- */
-void iwl_test_init(struct iwl_test *tst, struct iwl_trans *trans,
-     struct iwl_test_ops *ops)
-{
- tst->trans = trans;
- tst->ops = ops;
-
- iwl_test_trace_clear(tst);
- iwl_test_mem_clear(tst);
-}
-EXPORT_SYMBOL_GPL(iwl_test_init);
-
-/*
- * Stop the test object
- */
-void iwl_test_free(struct iwl_test *tst)
-{
- iwl_test_mem_stop(tst);
- iwl_test_trace_stop(tst);
-}
-EXPORT_SYMBOL_GPL(iwl_test_free);
-
-static inline int iwl_test_send_cmd(struct iwl_test *tst,
-        struct iwl_host_cmd *cmd)
-{
- return tst->ops->send_cmd(tst->trans->op_mode, cmd);
-}
-
-static inline bool iwl_test_valid_hw_addr(struct iwl_test *tst, u32 addr)
-{
- return tst->ops->valid_hw_addr(addr);
-}
-
-static inline u32 iwl_test_fw_ver(struct iwl_test *tst)
-{
- return tst->ops->get_fw_ver(tst->trans->op_mode);
-}
-
-static inline struct sk_buff*
-iwl_test_alloc_reply(struct iwl_test *tst, int len)
-{
- return tst->ops->alloc_reply(tst->trans->op_mode, len);
-}
-
-static inline int iwl_test_reply(struct iwl_test *tst, struct sk_buff *skb)
-{
- return tst->ops->reply(tst->trans->op_mode, skb);
-}
-
-static inline struct sk_buff*
-iwl_test_alloc_event(struct iwl_test *tst, int len)
-{
- return tst->ops->alloc_event(tst->trans->op_mode, len);
-}
-
-static inline void
-iwl_test_event(struct iwl_test *tst, struct sk_buff *skb)
-{
- return tst->ops->event(tst->trans->op_mode, skb);
-}
-
-/*
- * This function handles the user application commands to the fw. The fw
- * commands are sent in a synchronuous manner. In case that the user requested
- * to get commands response, it is send to the user.
- */
-static int iwl_test_fw_cmd(struct iwl_test *tst, struct nlattr **tb)
-{
- struct iwl_host_cmd cmd;
- struct iwl_rx_packet *pkt;
- struct sk_buff *skb;
- void *reply_buf;
- u32 reply_len;
- int ret;
- bool cmd_want_skb;
-
- memset(&cmd, 0, sizeof(struct iwl_host_cmd));
-
- if (!tb[IWL_TM_ATTR_UCODE_CMD_ID] ||
-     !tb[IWL_TM_ATTR_UCODE_CMD_DATA]) {
-  IWL_ERR(tst->trans, "Missing fw command mandatory fields\n");
-  return -ENOMSG;
- }
-
- cmd.flags = CMD_ON_DEMAND | CMD_SYNC;
- cmd_want_skb = nla_get_flag(tb[IWL_TM_ATTR_UCODE_CMD_SKB]);
- if (cmd_want_skb)
-  cmd.flags |= CMD_WANT_SKB;
-
- cmd.id = nla_get_u8(tb[IWL_TM_ATTR_UCODE_CMD_ID]);
- cmd.data[0] = nla_data(tb[IWL_TM_ATTR_UCODE_CMD_DATA]);
- cmd.len[0] = nla_len(tb[IWL_TM_ATTR_UCODE_CMD_DATA]);
- cmd.dataflags[0] = IWL_HCMD_DFL_NOCOPY;
- IWL_DEBUG_INFO(tst->trans, "test fw cmd=0x%x, flags 0x%x, len %d\n",
-         cmd.id, cmd.flags, cmd.len[0]);
-
- ret = iwl_test_send_cmd(tst, &cmd);
- if (ret) {
-  IWL_ERR(tst->trans, "Failed to send hcmd\n");
-  return ret;
- }
- if (!cmd_want_skb)
-  return ret;
-
- /* Handling return of SKB to the user */
- pkt = cmd.resp_pkt;
- if (!pkt) {
-  IWL_ERR(tst->trans, "HCMD received a null response packet\n");
-  return ret;
- }
-
- reply_len = le32_to_cpu(pkt->len_n_flags) & FH_RSCSR_FRAME_SIZE_MSK;
- skb = iwl_test_alloc_reply(tst, reply_len + 20);
- reply_buf = kmemdup(&pkt->hdr, reply_len, GFP_KERNEL);
- if (!skb || !reply_buf) {
-  kfree_skb(skb);
-  kfree(reply_buf);
-  return -ENOMEM;
- }
-
- /* The reply is in a page, that we cannot send to user space. */
- iwl_free_resp(&cmd);
-
- if (nla_put_u32(skb, IWL_TM_ATTR_COMMAND,
-   IWL_TM_CMD_DEV2APP_UCODE_RX_PKT) ||
-     nla_put(skb, IWL_TM_ATTR_UCODE_RX_PKT, reply_len, reply_buf))
-  goto nla_put_failure;
- return iwl_test_reply(tst, skb);
-
-nla_put_failure:
- IWL_DEBUG_INFO(tst->trans, "Failed creating NL attributes\n");
- kfree(reply_buf);
- kfree_skb(skb);
- return -ENOMSG;
-}
-
-/*
- * Handles the user application commands for register access.
- */
-static int iwl_test_reg(struct iwl_test *tst, struct nlattr **tb)
-{
- u32 ofs, val32, cmd;
- u8 val8;
- struct sk_buff *skb;
- int status = 0;
- struct iwl_trans *trans = tst->trans;
-
- if (!tb[IWL_TM_ATTR_REG_OFFSET]) {
-  IWL_ERR(trans, "Missing reg offset\n");
-  return -ENOMSG;
- }
-
- ofs = nla_get_u32(tb[IWL_TM_ATTR_REG_OFFSET]);
- IWL_DEBUG_INFO(trans, "test reg access cmd offset=0x%x\n", ofs);
-
- cmd = nla_get_u32(tb[IWL_TM_ATTR_COMMAND]);
-
- /*
-  * Allow access only to FH/CSR/HBUS in direct mode.
-  * Since we don't have the upper bounds for the CSR and HBUS segments,
-  * we will use only the upper bound of FH for sanity check.
-  */
- if (ofs >= FH_MEM_UPPER_BOUND) {
-  IWL_ERR(trans, "offset out of segment (0x0 - 0x%x)\n",
-   FH_MEM_UPPER_BOUND);
-  return -EINVAL;
- }
-
- switch (cmd) {
- case IWL_TM_CMD_APP2DEV_DIRECT_REG_READ32:
-  val32 = iwl_read_direct32(tst->trans, ofs);
-  IWL_DEBUG_INFO(trans, "32 value to read 0x%x\n", val32);
-
-  skb = iwl_test_alloc_reply(tst, 20);
-  if (!skb) {
-   IWL_ERR(trans, "Memory allocation fail\n");
-   return -ENOMEM;
-  }
-  if (nla_put_u32(skb, IWL_TM_ATTR_REG_VALUE32, val32))
-   goto nla_put_failure;
-  status = iwl_test_reply(tst, skb);
-  if (status < 0)
-   IWL_ERR(trans, "Error sending msg : %d\n", status);
-  break;
-
- case IWL_TM_CMD_APP2DEV_DIRECT_REG_WRITE32:
-  if (!tb[IWL_TM_ATTR_REG_VALUE32]) {
-   IWL_ERR(trans, "Missing value to write\n");
-   return -ENOMSG;
-  } else {
-   val32 = nla_get_u32(tb[IWL_TM_ATTR_REG_VALUE32]);
-   IWL_DEBUG_INFO(trans, "32b write val=0x%x\n", val32);
-   iwl_write_direct32(tst->trans, ofs, val32);
-  }
-  break;
-
- case IWL_TM_CMD_APP2DEV_DIRECT_REG_WRITE8:
-  if (!tb[IWL_TM_ATTR_REG_VALUE8]) {
-   IWL_ERR(trans, "Missing value to write\n");
-   return -ENOMSG;
-  } else {
-   val8 = nla_get_u8(tb[IWL_TM_ATTR_REG_VALUE8]);
-   IWL_DEBUG_INFO(trans, "8b write val=0x%x\n", val8);
-   iwl_write8(tst->trans, ofs, val8);
-  }
-  break;
-
- default:
-  IWL_ERR(trans, "Unknown test register cmd ID\n");
-  return -ENOMSG;
- }
-
- return status;
-
-nla_put_failure:
- kfree_skb(skb);
- return -EMSGSIZE;
-}
-
-/*
- * Handles the request to start FW tracing. Allocates of the trace buffer
- * and sends a reply to user space with the address of the allocated buffer.
- */
-static int iwl_test_trace_begin(struct iwl_test *tst, struct nlattr **tb)
-{
- struct sk_buff *skb;
- int status = 0;
-
- if (tst->trace.enabled)
-  return -EBUSY;
-
- if (!tb[IWL_TM_ATTR_TRACE_SIZE])
-  tst->trace.size = TRACE_BUFF_SIZE_DEF;
- else
-  tst->trace.size =
-   nla_get_u32(tb[IWL_TM_ATTR_TRACE_SIZE]);
-
- if (!tst->trace.size)
-  return -EINVAL;
-
- if (tst->trace.size < TRACE_BUFF_SIZE_MIN ||
-     tst->trace.size > TRACE_BUFF_SIZE_MAX)
-  return -EINVAL;
-
- tst->trace.tsize = tst->trace.size + TRACE_BUFF_PADD;
- tst->trace.cpu_addr = dma_alloc_coherent(tst->trans->dev,
-       tst->trace.tsize,
-       &tst->trace.dma_addr,
-       GFP_KERNEL);
- if (!tst->trace.cpu_addr)
-  return -ENOMEM;
-
- tst->trace.enabled = true;
- tst->trace.trace_addr = (u8 *)PTR_ALIGN(tst->trace.cpu_addr, 0x100);
-
- memset(tst->trace.trace_addr, 0x03B, tst->trace.size);
-
- skb = iwl_test_alloc_reply(tst, sizeof(tst->trace.dma_addr) + 20);
- if (!skb) {
-  IWL_ERR(tst->trans, "Memory allocation fail\n");
-  iwl_test_trace_stop(tst);
-  return -ENOMEM;
- }
-
- if (nla_put(skb, IWL_TM_ATTR_TRACE_ADDR,
-      sizeof(tst->trace.dma_addr),
-      (u64 *)&tst->trace.dma_addr))
-  goto nla_put_failure;
-
- status = iwl_test_reply(tst, skb);
- if (status < 0)
-  IWL_ERR(tst->trans, "Error sending msg : %d\n", status);
-
- tst->trace.nchunks = DIV_ROUND_UP(tst->trace.size,
-       DUMP_CHUNK_SIZE);
-
- return status;
-
-nla_put_failure:
- kfree_skb(skb);
- if (nla_get_u32(tb[IWL_TM_ATTR_COMMAND]) ==
-     IWL_TM_CMD_APP2DEV_BEGIN_TRACE)
-  iwl_test_trace_stop(tst);
- return -EMSGSIZE;
-}
-
-/*
- * Handles indirect read from the periphery or the SRAM. The read is performed
- * to a temporary buffer. The user space application should later issue a dump
- */
-static int iwl_test_indirect_read(struct iwl_test *tst, u32 addr, u32 size)
-{
- struct iwl_trans *trans = tst->trans;
- unsigned long flags;
- int i;
-
- if (size & 0x3)
-  return -EINVAL;
-
- tst->mem.size = size;
- tst->mem.addr = kmalloc(tst->mem.size, GFP_KERNEL);
- if (tst->mem.addr == NULL)
-  return -ENOMEM;
-
- /* Hard-coded periphery absolute address */
- if (IWL_ABS_PRPH_START <= addr &&
-     addr < IWL_ABS_PRPH_START + PRPH_END) {
-   if (!iwl_trans_grab_nic_access(trans, false, &flags)) {
-    return -EIO;
-   }
-   iwl_write32(trans, HBUS_TARG_PRPH_RADDR,
-        addr | (3 << 24));
-   for (i = 0; i < size; i += 4)
-    *(u32 *)(tst->mem.addr + i) =
-     iwl_read32(trans, HBUS_TARG_PRPH_RDAT);
-   iwl_trans_release_nic_access(trans, &flags);
- } else { /* target memory (SRAM) */
-  iwl_trans_read_mem(trans, addr, tst->mem.addr,
-       tst->mem.size / 4);
- }
-
- tst->mem.nchunks =
-  DIV_ROUND_UP(tst->mem.size, DUMP_CHUNK_SIZE);
- tst->mem.in_read = true;
- return 0;
-
-}
-
-/*
- * Handles indirect write to the periphery or SRAM. The  is performed to a
- * temporary buffer.
- */
-static int iwl_test_indirect_write(struct iwl_test *tst, u32 addr,
- u32 size, unsigned char *buf)
-{
- struct iwl_trans *trans = tst->trans;
- u32 val, i;
- unsigned long flags;
-
- if (IWL_ABS_PRPH_START <= addr &&
-     addr < IWL_ABS_PRPH_START + PRPH_END) {
-  /* Periphery writes can be 1-3 bytes long, or DWORDs */
-  if (size < 4) {
-   memcpy(&val, buf, size);
-   if (!iwl_trans_grab_nic_access(trans, false, &flags))
-     return -EIO;
-   iwl_write32(trans, HBUS_TARG_PRPH_WADDR,
-        (addr & 0x0000FFFF) |
-        ((size - 1) << 24));
-   iwl_write32(trans, HBUS_TARG_PRPH_WDAT, val);
-   iwl_trans_release_nic_access(trans, &flags);
-  } else {
-   if (size % 4)
-    return -EINVAL;
-   for (i = 0; i < size; i += 4)
-    iwl_write_prph(trans, addr+i,
-            *(u32 *)(buf+i));
-  }
- } else if (iwl_test_valid_hw_addr(tst, addr)) {
-  iwl_trans_write_mem(trans, addr, buf, size / 4);
- } else {
-  return -EINVAL;
- }
- return 0;
-}
-
-/*
- * Handles the user application commands for indirect read/write
- * to/from the periphery or the SRAM.
- */
-static int iwl_test_indirect_mem(struct iwl_test *tst, struct nlattr **tb)
-{
- u32 addr, size, cmd;
- unsigned char *buf;
-
- /* Both read and write should be blocked, for atomicity */
- if (tst->mem.in_read)
-  return -EBUSY;
-
- cmd = nla_get_u32(tb[IWL_TM_ATTR_COMMAND]);
- if (!tb[IWL_TM_ATTR_MEM_ADDR]) {
-  IWL_ERR(tst->trans, "Error finding memory offset address\n");
-  return -ENOMSG;
- }
- addr = nla_get_u32(tb[IWL_TM_ATTR_MEM_ADDR]);
- if (!tb[IWL_TM_ATTR_BUFFER_SIZE]) {
-  IWL_ERR(tst->trans, "Error finding size for memory reading\n");
-  return -ENOMSG;
- }
- size = nla_get_u32(tb[IWL_TM_ATTR_BUFFER_SIZE]);
-
- if (cmd == IWL_TM_CMD_APP2DEV_INDIRECT_BUFFER_READ) {
-  return iwl_test_indirect_read(tst, addr,  size);
- } else {
-  if (!tb[IWL_TM_ATTR_BUFFER_DUMP])
-   return -EINVAL;
-  buf = (unsigned char *)nla_data(tb[IWL_TM_ATTR_BUFFER_DUMP]);
-  return iwl_test_indirect_write(tst, addr, size, buf);
- }
-}
-
-/*
- * Enable notifications to user space
- */
-static int iwl_test_notifications(struct iwl_test *tst,
-      struct nlattr **tb)
-{
- tst->notify = nla_get_flag(tb[IWL_TM_ATTR_ENABLE_NOTIFICATION]);
- return 0;
-}
-
-/*
- * Handles the request to get the device id
- */
-static int iwl_test_get_dev_id(struct iwl_test *tst, struct nlattr **tb)
-{
- u32 devid = tst->trans->hw_id;
- struct sk_buff *skb;
- int status;
-
- IWL_DEBUG_INFO(tst->trans, "hw version: 0x%x\n", devid);
-
- skb = iwl_test_alloc_reply(tst, 20);
- if (!skb) {
-  IWL_ERR(tst->trans, "Memory allocation fail\n");
-  return -ENOMEM;
- }
-
- if (nla_put_u32(skb, IWL_TM_ATTR_DEVICE_ID, devid))
-  goto nla_put_failure;
- status = iwl_test_reply(tst, skb);
- if (status < 0)
-  IWL_ERR(tst->trans, "Error sending msg : %d\n", status);
-
- return 0;
-
-nla_put_failure:
- kfree_skb(skb);
- return -EMSGSIZE;
-}
-
-/*
- * Handles the request to get the FW version
- */
-static int iwl_test_get_fw_ver(struct iwl_test *tst, struct nlattr **tb)
-{
- struct sk_buff *skb;
- int status;
- u32 ver = iwl_test_fw_ver(tst);
-
- IWL_DEBUG_INFO(tst->trans, "uCode version raw: 0x%x\n", ver);
-
- skb = iwl_test_alloc_reply(tst, 20);
- if (!skb) {
-  IWL_ERR(tst->trans, "Memory allocation fail\n");
-  return -ENOMEM;
- }
-
- if (nla_put_u32(skb, IWL_TM_ATTR_FW_VERSION, ver))
-  goto nla_put_failure;
-
- status = iwl_test_reply(tst, skb);
- if (status < 0)
-  IWL_ERR(tst->trans, "Error sending msg : %d\n", status);
-
- return 0;
-
-nla_put_failure:
- kfree_skb(skb);
- return -EMSGSIZE;
-}
-
-/*
- * Parse the netlink message and validate that the IWL_TM_ATTR_CMD exists
- */
-int iwl_test_parse(struct iwl_test *tst, struct nlattr **tb,
-     void *data, int len)
-{
- int result;
-
- result = nla_parse(tb, IWL_TM_ATTR_MAX - 1, data, len,
-   iwl_testmode_gnl_msg_policy);
- if (result) {
-  IWL_ERR(tst->trans, "Fail parse gnl msg: %d\n", result);
-  return result;
- }
-
- /* IWL_TM_ATTR_COMMAND is absolutely mandatory */
- if (!tb[IWL_TM_ATTR_COMMAND]) {
-  IWL_ERR(tst->trans, "Missing testmode command type\n");
-  return -ENOMSG;
- }
- return 0;
-}
-IWL_EXPORT_SYMBOL(iwl_test_parse);
-
-/*
- * Handle test commands.
- * Returns 1 for unknown commands (not handled by the test object); negative
- * value in case of error.
- */
-int iwl_test_handle_cmd(struct iwl_test *tst, struct nlattr **tb)
-{
- int result;
-
- switch (nla_get_u32(tb[IWL_TM_ATTR_COMMAND])) {
- case IWL_TM_CMD_APP2DEV_UCODE:
-  IWL_DEBUG_INFO(tst->trans, "test cmd to uCode\n");
-  result = iwl_test_fw_cmd(tst, tb);
-  break;
-
- case IWL_TM_CMD_APP2DEV_DIRECT_REG_READ32:
- case IWL_TM_CMD_APP2DEV_DIRECT_REG_WRITE32:
- case IWL_TM_CMD_APP2DEV_DIRECT_REG_WRITE8:
-  IWL_DEBUG_INFO(tst->trans, "test cmd to register\n");
-  result = iwl_test_reg(tst, tb);
-  break;
-
- case IWL_TM_CMD_APP2DEV_BEGIN_TRACE:
-  IWL_DEBUG_INFO(tst->trans, "test uCode trace cmd to driver\n");
-  result = iwl_test_trace_begin(tst, tb);
-  break;
-
- case IWL_TM_CMD_APP2DEV_END_TRACE:
-  iwl_test_trace_stop(tst);
-  result = 0;
-  break;
-
- case IWL_TM_CMD_APP2DEV_INDIRECT_BUFFER_READ:
- case IWL_TM_CMD_APP2DEV_INDIRECT_BUFFER_WRITE:
-  IWL_DEBUG_INFO(tst->trans, "test indirect memory cmd\n");
-  result = iwl_test_indirect_mem(tst, tb);
-  break;
-
- case IWL_TM_CMD_APP2DEV_NOTIFICATIONS:
-  IWL_DEBUG_INFO(tst->trans, "test notifications cmd\n");
-  result = iwl_test_notifications(tst, tb);
-  break;
-
- case IWL_TM_CMD_APP2DEV_GET_FW_VERSION:
-  IWL_DEBUG_INFO(tst->trans, "test get FW ver cmd\n");
-  result = iwl_test_get_fw_ver(tst, tb);
-  break;
-
- case IWL_TM_CMD_APP2DEV_GET_DEVICE_ID:
-  IWL_DEBUG_INFO(tst->trans, "test Get device ID cmd\n");
-  result = iwl_test_get_dev_id(tst, tb);
-  break;
-
- default:
-  IWL_DEBUG_INFO(tst->trans, "Unknown test command\n");
-  result = 1;
-  break;
- }
- return result;
-}
-IWL_EXPORT_SYMBOL(iwl_test_handle_cmd);
-
-static int iwl_test_trace_dump(struct iwl_test *tst, struct sk_buff *skb,
-          struct netlink_callback *cb)
-{
- int idx, length;
-
- if (!tst->trace.enabled || !tst->trace.trace_addr)
-  return -EFAULT;
-
- idx = cb->args[4];
- if (idx >= tst->trace.nchunks)
-  return -ENOENT;
-
- length = DUMP_CHUNK_SIZE;
- if (((idx + 1) == tst->trace.nchunks) &&
-     (tst->trace.size % DUMP_CHUNK_SIZE))
-  length = tst->trace.size %
-   DUMP_CHUNK_SIZE;
-
- if (nla_put(skb, IWL_TM_ATTR_TRACE_DUMP, length,
-      tst->trace.trace_addr + (DUMP_CHUNK_SIZE * idx)))
-  goto nla_put_failure;
-
- cb->args[4] = ++idx;
- return 0;
-
- nla_put_failure:
- return -ENOBUFS;
-}
-
-static int iwl_test_buffer_dump(struct iwl_test *tst, struct sk_buff *skb,
-    struct netlink_callback *cb)
-{
- int idx, length;
-
- if (!tst->mem.in_read)
-  return -EFAULT;
-
- idx = cb->args[4];
- if (idx >= tst->mem.nchunks) {
-  iwl_test_mem_stop(tst);
-  return -ENOENT;
- }
-
- length = DUMP_CHUNK_SIZE;
- if (((idx + 1) == tst->mem.nchunks) &&
-     (tst->mem.size % DUMP_CHUNK_SIZE))
-  length = tst->mem.size % DUMP_CHUNK_SIZE;
-
- if (nla_put(skb, IWL_TM_ATTR_BUFFER_DUMP, length,
-      tst->mem.addr + (DUMP_CHUNK_SIZE * idx)))
-  goto nla_put_failure;
-
- cb->args[4] = ++idx;
- return 0;
-
- nla_put_failure:
- return -ENOBUFS;
-}
-
-/*
- * Handle dump commands.
- * Returns 1 for unknown commands (not handled by the test object); negative
- * value in case of error.
- */
-int iwl_test_dump(struct iwl_test *tst, u32 cmd, struct sk_buff *skb,
-    struct netlink_callback *cb)
-{
- int result;
-
- switch (cmd) {
- case IWL_TM_CMD_APP2DEV_READ_TRACE:
-  IWL_DEBUG_INFO(tst->trans, "uCode trace cmd\n");
-  result = iwl_test_trace_dump(tst, skb, cb);
-  break;
-
- case IWL_TM_CMD_APP2DEV_INDIRECT_BUFFER_DUMP:
-  IWL_DEBUG_INFO(tst->trans, "testmode sram dump cmd\n");
-  result = iwl_test_buffer_dump(tst, skb, cb);
-  break;
-
- default:
-  result = 1;
-  break;
- }
- return result;
-}
-IWL_EXPORT_SYMBOL(iwl_test_dump);
-
-/*
- * Multicast a spontaneous messages from the device to the user space.
- */
-static void iwl_test_send_rx(struct iwl_test *tst,
-        struct iwl_rx_cmd_buffer *rxb)
-{
- struct sk_buff *skb;
- struct iwl_rx_packet *data;
- int length;
-
- data = rxb_addr(rxb);
- length = le32_to_cpu(data->len_n_flags) & FH_RSCSR_FRAME_SIZE_MSK;
-
- /* the length doesn't include len_n_flags field, so add it manually */
- length += sizeof(__le32);
-
- skb = iwl_test_alloc_event(tst, length + 20);
- if (skb == NULL) {
-  IWL_ERR(tst->trans, "Out of memory for message to user\n");
-  return;
- }
-
- if (nla_put_u32(skb, IWL_TM_ATTR_COMMAND,
-   IWL_TM_CMD_DEV2APP_UCODE_RX_PKT) ||
-     nla_put(skb, IWL_TM_ATTR_UCODE_RX_PKT, length, data))
-  goto nla_put_failure;
-
- iwl_test_event(tst, skb);
- return;
-
-nla_put_failure:
- kfree_skb(skb);
- IWL_ERR(tst->trans, "Ouch, overran buffer, check allocation!\n");
-}
-
-/*
- * Called whenever a Rx frames is recevied from the device. If notifications to
- * the user space are requested, sends the frames to the user.
- */
-void iwl_test_rx(struct iwl_test *tst, struct iwl_rx_cmd_buffer *rxb)
-{
- if (tst->notify)
-  iwl_test_send_rx(tst, rxb);
-}
-IWL_EXPORT_SYMBOL(iwl_test_rx);
diff --git a/drivers/net/wireless/iwlwifi/iwl-test.h b/drivers/net/wireless/iwlwifi/iwl-test.h
deleted file mode 100644
index 8fbd217..0000000
--- a/drivers/net/wireless/iwlwifi/iwl-test.h
+++ /dev/null
@@ -1,161 +0,0 @@
-/******************************************************************************
- *
- * This file is provided under a dual BSD/GPLv2 license.  When using or
- * redistributing this file, you may do so under either license.
- *
- * GPL LICENSE SUMMARY
- *
- * Copyright(c) 2010 - 2013 Intel Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110,
- * USA
- *
- * The full GNU General Public License is included in this distribution
- * in the file called COPYING.
- *
- * Contact Information:
- *  Intel Linux Wireless <ilw@linux.intel.com>
- * Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497
- *
- * BSD LICENSE
- *
- * Copyright(c) 2010 - 2013 Intel Corporation. All rights reserved.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- *  * Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- *  * Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *  * Neither the name Intel Corporation nor the names of its
- *    contributors may be used to endorse or promote products derived
- *    from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- *
- *****************************************************************************/
-
-#ifndef __IWL_TEST_H__
-#define __IWL_TEST_H__
-
-#include <linux/types.h>
-#include "iwl-trans.h"
-
-struct iwl_test_trace {
- u32 size;
- u32 tsize;
- u32 nchunks;
- u8 *cpu_addr;
- u8 *trace_addr;
- dma_addr_t dma_addr;
- bool enabled;
-};
-
-struct iwl_test_mem {
- u32 size;
- u32 nchunks;
- u8 *addr;
- bool in_read;
-};
-
-/*
- * struct iwl_test_ops: callback to the op mode
- *
- * The structure defines the callbacks that the op_mode should handle,
- * inorder to handle logic that is out of the scope of iwl_test. The
- * op_mode must set all the callbacks.
-
- * @send_cmd: handler that is used by the test object to request the
- *  op_mode to send a command to the fw.
- *
- * @valid_hw_addr: handler that is used by the test object to request the
- *  op_mode to check if the given address is a valid address.
- *
- * @get_fw_ver: handler used to get the FW version.
- *
- * @alloc_reply: handler used by the test object to request the op_mode
- *  to allocate an skb for sending a reply to the user, and initialize
- *  the skb. It is assumed that the test object only fills the required
- *  attributes.
- *
- * @reply: handler used by the test object to request the op_mode to reply
- *  to a request. The skb is an skb previously allocated by the the
- *  alloc_reply callback.
- I
- * @alloc_event: handler used by the test object to request the op_mode
- *  to allocate an skb for sending an event, and initialize
- *  the skb. It is assumed that the test object only fills the required
- *  attributes.
- *
- * @reply: handler used by the test object to request the op_mode to send
- *  an event. The skb is an skb previously allocated by the the
- *  alloc_event callback.
- */
-struct iwl_test_ops {
- int (*send_cmd)(struct iwl_op_mode *op_modes,
-   struct iwl_host_cmd *cmd);
- bool (*valid_hw_addr)(u32 addr);
- u32 (*get_fw_ver)(struct iwl_op_mode *op_mode);
-
- struct sk_buff *(*alloc_reply)(struct iwl_op_mode *op_mode, int len);
- int (*reply)(struct iwl_op_mode *op_mode, struct sk_buff *skb);
- struct sk_buff* (*alloc_event)(struct iwl_op_mode *op_mode, int len);
- void (*event)(struct iwl_op_mode *op_mode, struct sk_buff *skb);
-};
-
-struct iwl_test {
- struct iwl_trans *trans;
- struct iwl_test_ops *ops;
- struct iwl_test_trace trace;
- struct iwl_test_mem mem;
- bool notify;
-};
-
-void iwl_test_init(struct iwl_test *tst, struct iwl_trans *trans,
-     struct iwl_test_ops *ops);
-
-void iwl_test_free(struct iwl_test *tst);
-
-int iwl_test_parse(struct iwl_test *tst, struct nlattr **tb,
-     void *data, int len);
-
-int iwl_test_handle_cmd(struct iwl_test *tst, struct nlattr **tb);
-
-int iwl_test_dump(struct iwl_test *tst, u32 cmd, struct sk_buff *skb,
-    struct netlink_callback *cb);
-
-void iwl_test_rx(struct iwl_test *tst, struct iwl_rx_cmd_buffer *rxb);
-
-static inline void iwl_test_enable_notifications(struct iwl_test *tst,
-       bool enable)
-{
- tst->notify = enable;
-}
-
-#endif
diff --git a/drivers/net/wireless/iwlwifi/iwl-testmode.h b/drivers/net/wireless/iwlwifi/iwl-testmode.h
deleted file mode 100644
index 98f48a9..0000000
--- a/drivers/net/wireless/iwlwifi/iwl-testmode.h
+++ /dev/null
@@ -1,309 +0,0 @@
-/******************************************************************************
- *
- * This file is provided under a dual BSD/GPLv2 license.  When using or
- * redistributing this file, you may do so under either license.
- *
- * GPL LICENSE SUMMARY
- *
- * Copyright(c) 2010 - 2013 Intel Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110,
- * USA
- *
- * The full GNU General Public License is included in this distribution
- * in the file called COPYING.
- *
- * Contact Information:
- *  Intel Linux Wireless <ilw@linux.intel.com>
- * Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497
- *
- * BSD LICENSE
- *
- * Copyright(c) 2010 - 2013 Intel Corporation. All rights reserved.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- *  * Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- *  * Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *  * Neither the name Intel Corporation nor the names of its
- *    contributors may be used to endorse or promote products derived
- *    from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- *
- *****************************************************************************/
-#ifndef __IWL_TESTMODE_H__
-#define __IWL_TESTMODE_H__
-
-#include <linux/types.h>
-
-
-/*
- * Commands from user space to kernel space(IWL_TM_CMD_ID_APP2DEV_XX) and
- * from and kernel space to user space(IWL_TM_CMD_ID_DEV2APP_XX).
- * The command ID is carried with IWL_TM_ATTR_COMMAND.
- *
- * @IWL_TM_CMD_APP2DEV_UCODE:
- * commands from user application to the uCode,
- * the actual uCode host command ID is carried with
- * IWL_TM_ATTR_UCODE_CMD_ID
- *
- * @IWL_TM_CMD_APP2DEV_DIRECT_REG_READ32:
- * @IWL_TM_CMD_APP2DEV_DIRECT_REG_WRITE32:
- * @IWL_TM_CMD_APP2DEV_DIRECT_REG_WRITE8:
- * commands from user applicaiton to access register
- *
- * @IWL_TM_CMD_APP2DEV_GET_DEVICENAME: retrieve device name
- * @IWL_TM_CMD_APP2DEV_LOAD_INIT_FW: load initial uCode image
- * @IWL_TM_CMD_APP2DEV_CFG_INIT_CALIB: perform calibration
- * @IWL_TM_CMD_APP2DEV_LOAD_RUNTIME_FW: load runtime uCode image
- * @IWL_TM_CMD_APP2DEV_GET_EEPROM: request EEPROM data
- * @IWL_TM_CMD_APP2DEV_FIXRATE_REQ: set fix MCS
- * commands fom user space for pure driver level operations
- *
- * @IWL_TM_CMD_APP2DEV_BEGIN_TRACE:
- * @IWL_TM_CMD_APP2DEV_END_TRACE:
- * @IWL_TM_CMD_APP2DEV_READ_TRACE:
- * commands fom user space for uCode trace operations
- *
- * @IWL_TM_CMD_DEV2APP_SYNC_RSP:
- * commands from kernel space to carry the synchronous response
- * to user application
- * @IWL_TM_CMD_DEV2APP_UCODE_RX_PKT:
- * commands from kernel space to multicast the spontaneous messages
- * to user application, or reply of host commands
- * @IWL_TM_CMD_DEV2APP_EEPROM_RSP:
- * commands from kernel space to carry the eeprom response
- * to user application
- *
- * @IWL_TM_CMD_APP2DEV_OWNERSHIP:
- * commands from user application to own change the ownership of the uCode
- * if application has the ownership, the only host command from
- * testmode will deliver to uCode. Default owner is driver
- *
- * @IWL_TM_CMD_APP2DEV_LOAD_WOWLAN_FW: load Wake On Wireless LAN uCode image
- * @IWL_TM_CMD_APP2DEV_GET_FW_VERSION: retrieve uCode version
- * @IWL_TM_CMD_APP2DEV_GET_DEVICE_ID: retrieve ID information in device
- * @IWL_TM_CMD_APP2DEV_GET_FW_INFO:
- * retrieve information of existing loaded uCode image
- *
- * @IWL_TM_CMD_APP2DEV_INDIRECT_BUFFER_READ:
- * @IWL_TM_CMD_APP2DEV_INDIRECT_BUFFER_DUMP:
- * @IWL_TM_CMD_APP2DEV_INDIRECT_BUFFER_WRITE:
- * Commands to read/write data from periphery or SRAM memory ranges.
- * Fore reading, a READ command is sent from the userspace and the data
- * is returned when the user calls a DUMP command.
- * For writing, only a WRITE command is used.
- * @IWL_TM_CMD_APP2DEV_NOTIFICATIONS:
- * Command to enable/disable notifications (currently RX packets) from the
- * driver to userspace.
- */
-enum iwl_tm_cmd_t {
- IWL_TM_CMD_APP2DEV_UCODE  = 1,
- IWL_TM_CMD_APP2DEV_DIRECT_REG_READ32 = 2,
- IWL_TM_CMD_APP2DEV_DIRECT_REG_WRITE32 = 3,
- IWL_TM_CMD_APP2DEV_DIRECT_REG_WRITE8 = 4,
- IWL_TM_CMD_APP2DEV_GET_DEVICENAME = 5,
- IWL_TM_CMD_APP2DEV_LOAD_INIT_FW  = 6,
- IWL_TM_CMD_APP2DEV_CFG_INIT_CALIB = 7,
- IWL_TM_CMD_APP2DEV_LOAD_RUNTIME_FW = 8,
- IWL_TM_CMD_APP2DEV_GET_EEPROM  = 9,
- IWL_TM_CMD_APP2DEV_FIXRATE_REQ  = 10,
- IWL_TM_CMD_APP2DEV_BEGIN_TRACE  = 11,
- IWL_TM_CMD_APP2DEV_END_TRACE  = 12,
- IWL_TM_CMD_APP2DEV_READ_TRACE  = 13,
- IWL_TM_CMD_DEV2APP_SYNC_RSP  = 14,
- IWL_TM_CMD_DEV2APP_UCODE_RX_PKT  = 15,
- IWL_TM_CMD_DEV2APP_EEPROM_RSP  = 16,
- IWL_TM_CMD_APP2DEV_OWNERSHIP  = 17,
- RESERVED_18    = 18,
- RESERVED_19    = 19,
- RESERVED_20    = 20,
- RESERVED_21    = 21,
- IWL_TM_CMD_APP2DEV_LOAD_WOWLAN_FW = 22,
- IWL_TM_CMD_APP2DEV_GET_FW_VERSION = 23,
- IWL_TM_CMD_APP2DEV_GET_DEVICE_ID = 24,
- IWL_TM_CMD_APP2DEV_GET_FW_INFO  = 25,
- IWL_TM_CMD_APP2DEV_INDIRECT_BUFFER_READ = 26,
- IWL_TM_CMD_APP2DEV_INDIRECT_BUFFER_DUMP = 27,
- IWL_TM_CMD_APP2DEV_INDIRECT_BUFFER_WRITE = 28,
- IWL_TM_CMD_APP2DEV_NOTIFICATIONS = 29,
- IWL_TM_CMD_MAX    = 30,
-};
-
-/*
- * Atrribute filed in testmode command
- * See enum iwl_tm_cmd_t.
- *
- * @IWL_TM_ATTR_NOT_APPLICABLE:
- * The attribute is not applicable or invalid
- * @IWL_TM_ATTR_COMMAND:
- * From user space to kernel space:
- * the command either destines to ucode, driver, or register;
- * From kernel space to user space:
- * the command either carries synchronous response,
- * or the spontaneous message multicast from the device;
- *
- * @IWL_TM_ATTR_UCODE_CMD_ID:
- * @IWL_TM_ATTR_UCODE_CMD_DATA:
- * When IWL_TM_ATTR_COMMAND is IWL_TM_CMD_APP2DEV_UCODE,
- * The mandatory fields are :
- * IWL_TM_ATTR_UCODE_CMD_ID for recognizable command ID;
- * IWL_TM_ATTR_UCODE_CMD_DATA for the actual command payload
- * to the ucode
- *
- * @IWL_TM_ATTR_REG_OFFSET:
- * @IWL_TM_ATTR_REG_VALUE8:
- * @IWL_TM_ATTR_REG_VALUE32:
- * When IWL_TM_ATTR_COMMAND is IWL_TM_CMD_APP2DEV_REG_XXX,
- * The mandatory fields are:
- * IWL_TM_ATTR_REG_OFFSET for the offset of the target register;
- * IWL_TM_ATTR_REG_VALUE8 or IWL_TM_ATTR_REG_VALUE32 for value
- *
- * @IWL_TM_ATTR_SYNC_RSP:
- * When IWL_TM_ATTR_COMMAND is IWL_TM_CMD_DEV2APP_SYNC_RSP,
- * The mandatory fields are:
- * IWL_TM_ATTR_SYNC_RSP for the data content responding to the user
- * application command
- *
- * @IWL_TM_ATTR_UCODE_RX_PKT:
- * When IWL_TM_ATTR_COMMAND is IWL_TM_CMD_DEV2APP_UCODE_RX_PKT,
- * The mandatory fields are:
- * IWL_TM_ATTR_UCODE_RX_PKT for the data content multicast to the user
- * application
- *
- * @IWL_TM_ATTR_EEPROM:
- * When IWL_TM_ATTR_COMMAND is IWL_TM_CMD_DEV2APP_EEPROM,
- * The mandatory fields are:
- * IWL_TM_ATTR_EEPROM for the data content responging to the user
- * application
- *
- * @IWL_TM_ATTR_TRACE_ADDR:
- * @IWL_TM_ATTR_TRACE_SIZE:
- * @IWL_TM_ATTR_TRACE_DUMP:
- * When IWL_TM_ATTR_COMMAND is IWL_TM_CMD_APP2DEV_XXX_TRACE,
- * The mandatory fields are:
- * IWL_TM_ATTR_MEM_TRACE_ADDR for the trace address
- * IWL_TM_ATTR_MEM_TRACE_SIZE for the trace buffer size
- * IWL_TM_ATTR_MEM_TRACE_DUMP for the trace dump
- *
- * @IWL_TM_ATTR_FIXRATE:
- * When IWL_TM_ATTR_COMMAND is IWL_TM_CMD_APP2DEV_FIXRATE_REQ,
- * The mandatory fields are:
- * IWL_TM_ATTR_FIXRATE for the fixed rate
- *
- * @IWL_TM_ATTR_UCODE_OWNER:
- * When IWL_TM_ATTR_COMMAND is IWL_TM_CMD_APP2DEV_OWNERSHIP,
- * The mandatory fields are:
- * IWL_TM_ATTR_UCODE_OWNER for the new owner
- *
- * @IWL_TM_ATTR_MEM_ADDR:
- * @IWL_TM_ATTR_BUFFER_SIZE:
- * When IWL_TM_ATTR_COMMAND is IWL_TM_CMD_APP2DEV_INDIRECT_BUFFER_READ
- * or IWL_TM_CMD_APP2DEV_INDIRECT_BUFFER_WRITE.
- * The mandatory fields are:
- * IWL_TM_ATTR_MEM_ADDR for the address in SRAM/periphery to read/write
- * IWL_TM_ATTR_BUFFER_SIZE for the buffer size of data to read/write.
- *
- * @IWL_TM_ATTR_BUFFER_DUMP:
- * When IWL_TM_ATTR_COMMAND is IWL_TM_CMD_APP2DEV_INDIRECT_BUFFER_DUMP,
- * IWL_TM_ATTR_BUFFER_DUMP is used for the data that was read.
- * When IWL_TM_ATTR_COMMAND is IWL_TM_CMD_APP2DEV_INDIRECT_BUFFER_WRITE,
- * this attribute contains the data to write.
- *
- * @IWL_TM_ATTR_FW_VERSION:
- * When IWL_TM_ATTR_COMMAND is IWL_TM_CMD_APP2DEV_GET_FW_VERSION,
- * IWL_TM_ATTR_FW_VERSION for the uCode version
- *
- * @IWL_TM_ATTR_DEVICE_ID:
- * When IWL_TM_ATTR_COMMAND is IWL_TM_CMD_APP2DEV_GET_DEVICE_ID,
- * IWL_TM_ATTR_DEVICE_ID for the device ID information
- *
- * @IWL_TM_ATTR_FW_TYPE:
- * @IWL_TM_ATTR_FW_INST_SIZE:
- * @IWL_TM_ATTR_FW_DATA_SIZE:
- * When IWL_TM_ATTR_COMMAND is IWL_TM_CMD_APP2DEV_GET_FW_INFO,
- * The mandatory fields are:
- * IWL_TM_ATTR_FW_TYPE for the uCode type (INIT/RUNTIME/...)
- * IWL_TM_ATTR_FW_INST_SIZE for the size of instruction section
- * IWL_TM_ATTR_FW_DATA_SIZE for the size of data section
- *
- * @IWL_TM_ATTR_UCODE_CMD_SKB:
- * When IWL_TM_ATTR_COMMAND is IWL_TM_CMD_APP2DEV_UCODE this flag
- * indicates that the user wants to receive the response of the command
- * in a reply SKB. If it's not present, the response is not returned.
- * @IWL_TM_ATTR_ENABLE_NOTIFICATIONS:
- * When IWL_TM_ATTR_COMMAND is IWL_TM_CMD_APP2DEV_NOTIFICATIONS, this
- * flag enables (if present) or disables (if not) the forwarding
- * to userspace.
- */
-enum iwl_tm_attr_t {
- IWL_TM_ATTR_NOT_APPLICABLE  = 0,
- IWL_TM_ATTR_COMMAND   = 1,
- IWL_TM_ATTR_UCODE_CMD_ID  = 2,
- IWL_TM_ATTR_UCODE_CMD_DATA  = 3,
- IWL_TM_ATTR_REG_OFFSET   = 4,
- IWL_TM_ATTR_REG_VALUE8   = 5,
- IWL_TM_ATTR_REG_VALUE32   = 6,
- IWL_TM_ATTR_SYNC_RSP   = 7,
- IWL_TM_ATTR_UCODE_RX_PKT  = 8,
- IWL_TM_ATTR_EEPROM   = 9,
- IWL_TM_ATTR_TRACE_ADDR   = 10,
- IWL_TM_ATTR_TRACE_SIZE   = 11,
- IWL_TM_ATTR_TRACE_DUMP   = 12,
- IWL_TM_ATTR_FIXRATE   = 13,
- IWL_TM_ATTR_UCODE_OWNER   = 14,
- IWL_TM_ATTR_MEM_ADDR   = 15,
- IWL_TM_ATTR_BUFFER_SIZE   = 16,
- IWL_TM_ATTR_BUFFER_DUMP   = 17,
- IWL_TM_ATTR_FW_VERSION   = 18,
- IWL_TM_ATTR_DEVICE_ID   = 19,
- IWL_TM_ATTR_FW_TYPE   = 20,
- IWL_TM_ATTR_FW_INST_SIZE  = 21,
- IWL_TM_ATTR_FW_DATA_SIZE  = 22,
- IWL_TM_ATTR_UCODE_CMD_SKB  = 23,
- IWL_TM_ATTR_ENABLE_NOTIFICATION  = 24,
- IWL_TM_ATTR_MAX    = 25,
-};
-
-/* uCode trace buffer */
-#define TRACE_BUFF_SIZE_MAX 0x200000
-#define TRACE_BUFF_SIZE_MIN 0x20000
-#define TRACE_BUFF_SIZE_DEF TRACE_BUFF_SIZE_MIN
-#define TRACE_BUFF_PADD  0x2000
-
-/* Maximum data size of each dump it packet */
-#define DUMP_CHUNK_SIZE  (PAGE_SIZE - 1024)
-
-/* Address offset of data segment in SRAM */
-#define SRAM_DATA_SEG_OFFSET   0x800000
-
-#endif
diff --git a/drivers/net/wireless/iwlwifi/iwl-trans.h b/drivers/net/wireless/iwlwifi/iwl-trans.h
index 72d2ecc..34d49e1 100644
--- a/drivers/net/wireless/iwlwifi/iwl-trans.h
+++ b/drivers/net/wireless/iwlwifi/iwl-trans.h
@@ -5,7 +5,7 @@
  *
  * GPL LICENSE SUMMARY
  *
- * Copyright(c) 2007 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2007 - 2014 Intel Corporation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of version 2 of the GNU General Public License as
@@ -30,7 +30,7 @@
  *
  * BSD LICENSE
  *
- * Copyright(c) 2005 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2005 - 2014 Intel Corporation. All rights reserved.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -70,6 +70,7 @@
 #include "iwl-debug.h"
 #include "iwl-config.h"
 #include "iwl-fw.h"
+#include "iwl-op-mode.h"
 
 /**
  * DOC: Transport layer - what is it ?
@@ -100,8 +101,7 @@
  *    start_fw
  *
  * 5) Then when finished (or reset):
- *    stop_fw (a.k.a. stop device for the moment)
- *    stop_hw
+ *    stop_device
  *
  * 6) Eventually, the free function will be called.
  */
@@ -176,20 +176,38 @@ struct iwl_rx_packet {
  u8 data[];
 } __packed;
 
+static inline u32 iwl_rx_packet_len(const struct iwl_rx_packet *pkt)
+{
+ return le32_to_cpu(pkt->len_n_flags) & FH_RSCSR_FRAME_SIZE_MSK;
+}
+
+static inline u32 iwl_rx_packet_payload_len(const struct iwl_rx_packet *pkt)
+{
+ return iwl_rx_packet_len(pkt) - sizeof(pkt->hdr);
+}
+
 /**
  * enum CMD_MODE - how to send the host commands ?
  *
- * @CMD_SYNC: The caller will be stalled until the fw responds to the command
- * @CMD_ASYNC: Return right away and don't want for the response
- * @CMD_WANT_SKB: valid only with CMD_SYNC. The caller needs the buffer of the
- * response. The caller needs to call iwl_free_resp when done.
- * @CMD_ON_DEMAND: This command is sent by the test mode pipe.
+ * @CMD_ASYNC: Return right away and don't wait for the response
+ * @CMD_WANT_SKB: Not valid with CMD_ASYNC. The caller needs the buffer of
+ * the response. The caller needs to call iwl_free_resp when done.
+ * @CMD_HIGH_PRIO: The command is high priority - it goes to the front of the
+ * command queue, but after other high priority commands. valid only
+ * with CMD_ASYNC.
+ * @CMD_SEND_IN_IDLE: The command should be sent even when the trans is idle.
+ * @CMD_MAKE_TRANS_IDLE: The command response should mark the trans as idle.
+ * @CMD_WAKE_UP_TRANS: The command response should wake up the trans
+ * (i.e. mark it as non-idle).
  */
 enum CMD_MODE {
- CMD_SYNC  = 0,
  CMD_ASYNC  = BIT(0),
  CMD_WANT_SKB  = BIT(1),
- CMD_ON_DEMAND  = BIT(2),
+ CMD_SEND_IN_RFKILL = BIT(2),
+ CMD_HIGH_PRIO  = BIT(3),
+ CMD_SEND_IN_IDLE = BIT(4),
+ CMD_MAKE_TRANS_IDLE = BIT(5),
+ CMD_WAKE_UP_TRANS = BIT(6),
 };
 
 #define DEF_CMD_PAYLOAD_SIZE 320
@@ -219,7 +237,7 @@ struct iwl_device_cmd {
  *
  * @IWL_HCMD_DFL_NOCOPY: By default, the command is copied to the host command's
  * ring. The transport layer doesn't map the command's buffer to DMA, but
- * rather copies it to an previously allocated DMA buffer. This flag tells
+ * rather copies it to a previously allocated DMA buffer. This flag tells
  * the transport layer not to copy the command, but to map the existing
  * buffer (that is passed in) instead. This saves the memcpy and allows
  * commands that are bigger than the fixed buffer to be submitted.
@@ -244,7 +262,7 @@ enum iwl_hcmd_dataflag {
  * @handler_status: return value of the handler of the command
  * (put in setup_rx_handlers) - valid for SYNC mode only
  * @flags: can be CMD_*
- * @len: array of the lenths of the chunks in data
+ * @len: array of the lengths of the chunks in data
  * @dataflags: IWL_HCMD_DFL_*
  * @id: id of the host command
  */
@@ -319,6 +337,29 @@ enum iwl_d3_status {
 };
 
 /**
+ * enum iwl_trans_status: transport status flags
+ * @STATUS_SYNC_HCMD_ACTIVE: a SYNC command is being processed
+ * @STATUS_DEVICE_ENABLED: APM is enabled
+ * @STATUS_TPOWER_PMI: the device might be asleep (need to wake it up)
+ * @STATUS_INT_ENABLED: interrupts are enabled
+ * @STATUS_RFKILL: the HW RFkill switch is in KILL position
+ * @STATUS_FW_ERROR: the fw is in error state
+ * @STATUS_TRANS_GOING_IDLE: shutting down the trans, only special commands
+ * are sent
+ * @STATUS_TRANS_IDLE: the trans is idle - general commands are not to be sent
+ */
+enum iwl_trans_status {
+ STATUS_SYNC_HCMD_ACTIVE,
+ STATUS_DEVICE_ENABLED,
+ STATUS_TPOWER_PMI,
+ STATUS_INT_ENABLED,
+ STATUS_RFKILL,
+ STATUS_FW_ERROR,
+ STATUS_TRANS_GOING_IDLE,
+ STATUS_TRANS_IDLE,
+};
+
+/**
  * struct iwl_trans_config - transport configuration
  *
  * @op_mode: pointer to the upper layer.
@@ -345,12 +386,12 @@ struct iwl_trans_config {
  u8 cmd_queue;
  u8 cmd_fifo;
  const u8 *no_reclaim_cmds;
- int n_no_reclaim_cmds;
+ unsigned int n_no_reclaim_cmds;
 
  bool rx_buf_size_8k;
  bool bc_table_dword;
  unsigned int queue_watchdog_timeout;
- const char **command_names;
+ const char *const *command_names;
 };
 
 struct iwl_trans;
@@ -362,9 +403,7 @@ struct iwl_trans;
  *
  * @start_hw: starts the HW- from that point on, the HW can send interrupts
  * May sleep
- * @stop_hw: stops the HW- from that point on, the HW will be in low power but
- * will still issue interrupt if the HW RF kill is triggered unless
- * op_mode_leaving is true.
+ * @op_mode_leave: Turn off the HW RF kill indication if on
  * May sleep
  * @start_fw: allocates and inits all the resources for the transport
  * layer. Also kick a fw image.
@@ -372,8 +411,11 @@ struct iwl_trans;
  * @fw_alive: called when the fw sends alive notification. If the fw provides
  * the SCD base address in SRAM, then provide it here, or 0 otherwise.
  * May sleep
- * @stop_device:stops the whole device (embedded CPU put to reset)
- * May sleep
+ * @stop_device: stops the whole device (embedded CPU put to reset) and stops
+ * the HW. From that point on, the HW will be in low power but will still
+ * issue interrupt if the HW RF kill is triggered. This callback must do
+ * the right thing and not crash even if start_hw() was called but not
+ * start_fw(). May sleep
  * @d3_suspend: put the device into the correct mode for WoWLAN during
  * suspend. This is optional, if not implemented WoWLAN will not be
  * supported. This callback may sleep.
@@ -383,7 +425,7 @@ struct iwl_trans;
  * @send_cmd:send a host command. Must return -ERFKILL if RFkill is asserted.
  * If RFkill is asserted in the middle of a SYNC host command, it must
  * return -ERFKILL straight away.
- * May sleep only if CMD_SYNC is set
+ * May sleep only if CMD_ASYNC is not set
  * @tx: send an skb
  * Must be atomic
  * @reclaim: free packet until ssn. Returns a list of freed packets.
@@ -393,12 +435,9 @@ struct iwl_trans;
  * this one. The op_mode must not configure the HCMD queue. May sleep.
  * @txq_disable: de-configure a Tx queue to send AMPDUs
  * Must be atomic
- * @wait_tx_queue_empty: wait until all tx queues are empty
- * May sleep
+ * @wait_tx_queue_empty: wait until tx queues are empty. May sleep.
  * @dbgfs_register: add the dbgfs files under this directory. Files will be
  * automatically deleted.
- * @suspend: stop the device unless WoWLAN is configured
- * @resume: resume activity of the device
  * @write8: write a u8 to a register at offset ofs from the BAR
  * @write32: write a u32 to a register at offset ofs from the BAR
  * @read32: read a u32 register at offset ofs from the BAR
@@ -417,18 +456,31 @@ struct iwl_trans;
  * @release_nic_access: let the NIC go to sleep. The "flags" parameter
  * must be the same one that was sent before to the grab_nic_access.
  * @set_bits_mask - set SRAM register according to value and mask.
+ * @ref: grab a reference to the transport/FW layers, disallowing
+ * certain low power states
+ * @unref: release a reference previously taken with @ref. Note that
+ * initially the reference count is 1, making an initial @unref
+ * necessary to allow low power states.
+ * @dump_data: fill a data dump with debug data, maybe containing last
+ * TX'ed commands and similar. When called with a NULL buffer and
+ * zero buffer length, provide only the (estimated) required buffer
+ * length. Return the used buffer length.
+ * Note that the transport must fill in the proper file headers.
  */
 struct iwl_trans_ops {
 
  int (*start_hw)(struct iwl_trans *iwl_trans);
- void (*stop_hw)(struct iwl_trans *iwl_trans, bool op_mode_leaving);
+ void (*op_mode_leave)(struct iwl_trans *iwl_trans);
  int (*start_fw)(struct iwl_trans *trans, const struct fw_img *fw,
    bool run_in_rfkill);
+ int (*update_sf)(struct iwl_trans *trans,
+    struct iwl_sf_region *st_fwrd_space);
  void (*fw_alive)(struct iwl_trans *trans, u32 scd_addr);
  void (*stop_device)(struct iwl_trans *trans);
 
- void (*d3_suspend)(struct iwl_trans *trans);
- int (*d3_resume)(struct iwl_trans *trans, enum iwl_d3_status *status);
+ void (*d3_suspend)(struct iwl_trans *trans, bool test);
+ int (*d3_resume)(struct iwl_trans *trans, enum iwl_d3_status *status,
+    bool test);
 
  int (*send_cmd)(struct iwl_trans *trans, struct iwl_host_cmd *cmd);
 
@@ -442,11 +494,8 @@ struct iwl_trans_ops {
  void (*txq_disable)(struct iwl_trans *trans, int queue);
 
  int (*dbgfs_register)(struct iwl_trans *trans, struct dentry* dir);
- int (*wait_tx_queue_empty)(struct iwl_trans *trans);
-#ifdef CONFIG_PM_SLEEP
- int (*suspend)(struct iwl_trans *trans);
- int (*resume)(struct iwl_trans *trans);
-#endif
+ int (*wait_tx_queue_empty)(struct iwl_trans *trans, u32 txq_bm);
+
  void (*write8)(struct iwl_trans *trans, u32 ofs, u8 val);
  void (*write32)(struct iwl_trans *trans, u32 ofs, u32 val);
  u32 (*read32)(struct iwl_trans *trans, u32 ofs);
@@ -455,7 +504,7 @@ struct iwl_trans_ops {
  int (*read_mem)(struct iwl_trans *trans, u32 addr,
    void *buf, int dwords);
  int (*write_mem)(struct iwl_trans *trans, u32 addr,
-    void *buf, int dwords);
+    const void *buf, int dwords);
  void (*configure)(struct iwl_trans *trans,
      const struct iwl_trans_config *trans_cfg);
  void (*set_pmi)(struct iwl_trans *trans, bool state);
@@ -465,6 +514,12 @@ struct iwl_trans_ops {
        unsigned long *flags);
  void (*set_bits_mask)(struct iwl_trans *trans, u32 reg, u32 mask,
          u32 value);
+ void (*ref)(struct iwl_trans *trans);
+ void (*unref)(struct iwl_trans *trans);
+
+#ifdef CONFIG_IWLWIFI_DEBUGFS
+ u32 (*dump_data)(struct iwl_trans *trans, void *buf, u32 buflen);
+#endif
 };
 
 /**
@@ -484,6 +539,7 @@ enum iwl_trans_state {
  * @ops - pointer to iwl_trans_ops
  * @op_mode - pointer to the op_mode
  * @cfg - pointer to the configuration
+ * @status: a bit-mask of transport status flags
  * @dev - pointer to struct device * that represents the device
  * @hw_id: a u32 with the ID of the device / subdevice.
  * Set during transport allocation.
@@ -498,12 +554,14 @@ enum iwl_trans_state {
  * starting the firmware, used for tracing
  * @rx_mpdu_cmd_hdr_size: used for tracing, amount of data before the
  * start of the 802.11 header in the @rx_mpdu_cmd
+ * @dflt_pwr_limit: default power limit fetched from the platform (ACPI)
  */
 struct iwl_trans {
  const struct iwl_trans_ops *ops;
  struct iwl_op_mode *op_mode;
  const struct iwl_cfg *cfg;
  enum iwl_trans_state state;
+ unsigned long status;
 
  struct device *dev;
  u32 hw_rev;
@@ -525,6 +583,8 @@ struct iwl_trans {
  struct lockdep_map sync_cmd_lockdep_map;
 #endif
 
+ u64 dflt_pwr_limit;
+
  /* pointer to trans specific struct */
  /*Ensure that this pointer will always be aligned to sizeof pointer */
  char trans_specific[0] __aligned(sizeof(void *));
@@ -545,15 +605,14 @@ static inline int iwl_trans_start_hw(struct iwl_trans *trans)
  return trans->ops->start_hw(trans);
 }
 
-static inline void iwl_trans_stop_hw(struct iwl_trans *trans,
-         bool op_mode_leaving)
+static inline void iwl_trans_op_mode_leave(struct iwl_trans *trans)
 {
  might_sleep();
 
- trans->ops->stop_hw(trans, op_mode_leaving);
+ if (trans->ops->op_mode_leave)
+  trans->ops->op_mode_leave(trans);
 
- if (op_mode_leaving)
-  trans->op_mode = NULL;
+ trans->op_mode = NULL;
 
  trans->state = IWL_TRANS_NO_FW;
 }
@@ -575,9 +634,21 @@ static inline int iwl_trans_start_fw(struct iwl_trans *trans,
 
  WARN_ON_ONCE(!trans->rx_mpdu_cmd);
 
+ clear_bit(STATUS_FW_ERROR, &trans->status);
  return trans->ops->start_fw(trans, fw, run_in_rfkill);
 }
 
+static inline int iwl_trans_update_sf(struct iwl_trans *trans,
+          struct iwl_sf_region *st_fwrd_space)
+{
+ might_sleep();
+
+ if (trans->ops->update_sf)
+  return trans->ops->update_sf(trans, st_fwrd_space);
+
+ return 0;
+}
+
 static inline void iwl_trans_stop_device(struct iwl_trans *trans)
 {
  might_sleep();
@@ -587,26 +658,56 @@ static inline void iwl_trans_stop_device(struct iwl_trans *trans)
  trans->state = IWL_TRANS_NO_FW;
 }
 
-static inline void iwl_trans_d3_suspend(struct iwl_trans *trans)
+static inline void iwl_trans_d3_suspend(struct iwl_trans *trans, bool test)
 {
  might_sleep();
- trans->ops->d3_suspend(trans);
+ trans->ops->d3_suspend(trans, test);
 }
 
 static inline int iwl_trans_d3_resume(struct iwl_trans *trans,
-          enum iwl_d3_status *status)
+          enum iwl_d3_status *status,
+          bool test)
 {
  might_sleep();
- return trans->ops->d3_resume(trans, status);
+ return trans->ops->d3_resume(trans, status, test);
+}
+
+static inline void iwl_trans_ref(struct iwl_trans *trans)
+{
+ if (trans->ops->ref)
+  trans->ops->ref(trans);
+}
+
+static inline void iwl_trans_unref(struct iwl_trans *trans)
+{
+ if (trans->ops->unref)
+  trans->ops->unref(trans);
 }
 
+#ifdef CONFIG_IWLWIFI_DEBUGFS
+static inline u32 iwl_trans_dump_data(struct iwl_trans *trans,
+          void *buf, u32 buflen)
+{
+ if (!trans->ops->dump_data)
+  return 0;
+ return trans->ops->dump_data(trans, buf, buflen);
+}
+#endif
+
 static inline int iwl_trans_send_cmd(struct iwl_trans *trans,
          struct iwl_host_cmd *cmd)
 {
  int ret;
 
- if (trans->state != IWL_TRANS_FW_ALIVE) {
-  IWL_ERR(trans, "%s bad state = %d", __func__, trans->state);
+ if (unlikely(!(cmd->flags & CMD_SEND_IN_RFKILL) &&
+       test_bit(STATUS_RFKILL, &trans->status)))
+  return -ERFKILL;
+
+ if (unlikely(test_bit(STATUS_FW_ERROR, &trans->status)))
+  return -EIO;
+
+ if (unlikely(trans->state != IWL_TRANS_FW_ALIVE)) {
+  IWL_ERR(trans, "%s bad state = %d\n", __func__, trans->state);
   return -EIO;
  }
 
@@ -644,8 +745,11 @@ static inline void iwl_trans_free_tx_cmd(struct iwl_trans *trans,
 static inline int iwl_trans_tx(struct iwl_trans *trans, struct sk_buff *skb,
           struct iwl_device_cmd *dev_cmd, int queue)
 {
- WARN_ONCE(trans->state != IWL_TRANS_FW_ALIVE,
-    "%s bad state = %d", __func__, trans->state);
+ if (unlikely(test_bit(STATUS_FW_ERROR, &trans->status)))
+  return -EIO;
+
+ if (unlikely(trans->state != IWL_TRANS_FW_ALIVE))
+  IWL_ERR(trans, "%s bad state = %d\n", __func__, trans->state);
 
  return trans->ops->tx(trans, skb, dev_cmd, queue);
 }
@@ -653,17 +757,14 @@ static inline int iwl_trans_tx(struct iwl_trans *trans, struct sk_buff *skb,
 static inline void iwl_trans_reclaim(struct iwl_trans *trans, int queue,
          int ssn, struct sk_buff_head *skbs)
 {
- WARN_ONCE(trans->state != IWL_TRANS_FW_ALIVE,
-    "%s bad state = %d", __func__, trans->state);
+ if (unlikely(trans->state != IWL_TRANS_FW_ALIVE))
+  IWL_ERR(trans, "%s bad state = %d\n", __func__, trans->state);
 
  trans->ops->reclaim(trans, queue, ssn, skbs);
 }
 
 static inline void iwl_trans_txq_disable(struct iwl_trans *trans, int queue)
 {
- WARN_ONCE(trans->state != IWL_TRANS_FW_ALIVE,
-    "%s bad state = %d", __func__, trans->state);
-
  trans->ops->txq_disable(trans, queue);
 }
 
@@ -673,8 +774,8 @@ static inline void iwl_trans_txq_enable(struct iwl_trans *trans, int queue,
 {
  might_sleep();
 
- WARN_ONCE(trans->state != IWL_TRANS_FW_ALIVE,
-    "%s bad state = %d", __func__, trans->state);
+ if (unlikely((trans->state != IWL_TRANS_FW_ALIVE)))
+  IWL_ERR(trans, "%s bad state = %d\n", __func__, trans->state);
 
  trans->ops->txq_enable(trans, queue, fifo, sta_id, tid,
      frame_limit, ssn);
@@ -687,12 +788,13 @@ static inline void iwl_trans_ac_txq_enable(struct iwl_trans *trans, int queue,
         IWL_MAX_TID_COUNT, IWL_FRAME_LIMIT, 0);
 }
 
-static inline int iwl_trans_wait_tx_queue_empty(struct iwl_trans *trans)
+static inline int iwl_trans_wait_tx_queue_empty(struct iwl_trans *trans,
+      u32 txq_bm)
 {
- WARN_ONCE(trans->state != IWL_TRANS_FW_ALIVE,
-    "%s bad state = %d", __func__, trans->state);
+ if (unlikely(trans->state != IWL_TRANS_FW_ALIVE))
+  IWL_ERR(trans, "%s bad state = %d\n", __func__, trans->state);
 
- return trans->ops->wait_tx_queue_empty(trans);
+ return trans->ops->wait_tx_queue_empty(trans, txq_bm);
 }
 
 static inline int iwl_trans_dbgfs_register(struct iwl_trans *trans,
@@ -701,18 +803,6 @@ static inline int iwl_trans_dbgfs_register(struct iwl_trans *trans,
  return trans->ops->dbgfs_register(trans, dir);
 }
 
-#ifdef CONFIG_PM_SLEEP
-static inline int iwl_trans_suspend(struct iwl_trans *trans)
-{
- return trans->ops->suspend(trans);
-}
-
-static inline int iwl_trans_resume(struct iwl_trans *trans)
-{
- return trans->ops->resume(trans);
-}
-#endif
-
 static inline void iwl_trans_write8(struct iwl_trans *trans, u32 ofs, u8 val)
 {
  trans->ops->write8(trans, ofs, val);
@@ -763,7 +853,7 @@ static inline u32 iwl_trans_read_mem32(struct iwl_trans *trans, u32 addr)
 }
 
 static inline int iwl_trans_write_mem(struct iwl_trans *trans, u32 addr,
-          void *buf, int dwords)
+          const void *buf, int dwords)
 {
  return trans->ops->write_mem(trans, addr, buf, dwords);
 }
@@ -776,7 +866,8 @@ static inline u32 iwl_trans_write_mem32(struct iwl_trans *trans, u32 addr,
 
 static inline void iwl_trans_set_pmi(struct iwl_trans *trans, bool state)
 {
- trans->ops->set_pmi(trans, state);
+ if (trans->ops->set_pmi)
+  trans->ops->set_pmi(trans, state);
 }
 
 static inline void
@@ -796,6 +887,16 @@ iwl_trans_release_nic_access(struct iwl_trans *trans, unsigned long *flags)
  __release(nic_access);
 }
 
+static inline void iwl_trans_fw_error(struct iwl_trans *trans)
+{
+ if (WARN_ON_ONCE(!trans->op_mode))
+  return;
+
+ /* prevent double restarts due to the same erroneous FW */
+ if (!test_and_set_bit(STATUS_FW_ERROR, &trans->status))
+  iwl_op_mode_nic_error(trans->op_mode);
+}
+
 /*****************************************************
 * driver (transport) register/unregister functions
 ******************************************************/
diff --git a/drivers/net/wireless/iwlwifi/mvm/Makefile b/drivers/net/wireless/iwlwifi/mvm/Makefile
index 2acc44b..c30d7f6 100644
--- a/drivers/net/wireless/iwlwifi/mvm/Makefile
+++ b/drivers/net/wireless/iwlwifi/mvm/Makefile
@@ -1,10 +1,11 @@
 obj-$(CONFIG_IWLMVM)   += iwlmvm.o
 iwlmvm-y += fw.o mac80211.o nvm.o ops.o phy-ctxt.o mac-ctxt.o
-iwlmvm-y += utils.o rx.o tx.o binding.o quota.o sta.o
+iwlmvm-y += utils.o rx.o tx.o binding.o quota.o sta.o sf.o
 iwlmvm-y += scan.o time-event.o rs.o
-iwlmvm-y += power.o bt-coex.o
-iwlmvm-y += led.o
-iwlmvm-$(CONFIG_IWLWIFI_DEBUGFS) += debugfs.o
+iwlmvm-y += power.o coex.o
+iwlmvm-y += tt.o offloading.o
+iwlmvm-$(CONFIG_IWLWIFI_DEBUGFS) += debugfs.o debugfs-vif.o
+iwlmvm-$(CONFIG_IWLWIFI_LEDS) += led.o
 iwlmvm-$(CONFIG_PM_SLEEP) += d3.o
 
 ccflags-y += -D__CHECK_ENDIAN__ -I$(src)/../
diff --git a/drivers/net/wireless/iwlwifi/mvm/binding.c b/drivers/net/wireless/iwlwifi/mvm/binding.c
index 93fd145..a137653 100644
--- a/drivers/net/wireless/iwlwifi/mvm/binding.c
+++ b/drivers/net/wireless/iwlwifi/mvm/binding.c
@@ -5,7 +5,7 @@
  *
  * GPL LICENSE SUMMARY
  *
- * Copyright(c) 2012 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2012 - 2014 Intel Corporation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of version 2 of the GNU General Public License as
@@ -30,7 +30,7 @@
  *
  * BSD LICENSE
  *
- * Copyright(c) 2012 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2012 - 2014 Intel Corporation. All rights reserved.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -183,15 +183,29 @@ int iwl_mvm_binding_add_vif(struct iwl_mvm *mvm, struct ieee80211_vif *vif)
  if (WARN_ON_ONCE(!mvmvif->phy_ctxt))
   return -EINVAL;
 
+ /*
+  * Update SF - Disable if needed. if this fails, SF might still be on
+  * while many macs are bound, which is forbidden - so fail the binding.
+  */
+ if (iwl_mvm_sf_update(mvm, vif, false))
+  return -EINVAL;
+
  return iwl_mvm_binding_update(mvm, vif, mvmvif->phy_ctxt, true);
 }
 
 int iwl_mvm_binding_remove_vif(struct iwl_mvm *mvm, struct ieee80211_vif *vif)
 {
  struct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);
+ int ret;
 
  if (WARN_ON_ONCE(!mvmvif->phy_ctxt))
   return -EINVAL;
 
- return iwl_mvm_binding_update(mvm, vif, mvmvif->phy_ctxt, false);
+ ret = iwl_mvm_binding_update(mvm, vif, mvmvif->phy_ctxt, false);
+
+ if (!ret)
+  if (iwl_mvm_sf_update(mvm, vif, true))
+   IWL_ERR(mvm, "Failed to update SF state\n");
+
+ return ret;
 }
diff --git a/drivers/net/wireless/iwlwifi/mvm/coex.c b/drivers/net/wireless/iwlwifi/mvm/coex.c
new file mode 100644
index 0000000..c8c3b38
--- /dev/null
+++ b/drivers/net/wireless/iwlwifi/mvm/coex.c
@@ -0,0 +1,1322 @@
+/******************************************************************************
+ *
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ * redistributing this file, you may do so under either license.
+ *
+ * GPL LICENSE SUMMARY
+ *
+ * Copyright(c) 2013 - 2014 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110,
+ * USA
+ *
+ * The full GNU General Public License is included in this distribution
+ * in the file called COPYING.
+ *
+ * Contact Information:
+ *  Intel Linux Wireless <ilw@linux.intel.com>
+ * Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497
+ *
+ * BSD LICENSE
+ *
+ * Copyright(c) 2013 - 2014 Intel Corporation. All rights reserved.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *  * Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *  * Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *  * Neither the name Intel Corporation nor the names of its
+ *    contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *****************************************************************************/
+
+#include <linux/ieee80211.h>
+#include <linux/etherdevice.h>
+#include <net/mac80211.h>
+
+#include "fw-api-coex.h"
+#include "iwl-modparams.h"
+#include "mvm.h"
+#include "iwl-debug.h"
+
+#define EVENT_PRIO_ANT(_evt, _prio, _shrd_ant)   \
+ [(_evt)] = (((_prio) << BT_COEX_PRIO_TBL_PRIO_POS) | \
+     ((_shrd_ant) << BT_COEX_PRIO_TBL_SHRD_ANT_POS))
+
+static const u8 iwl_bt_prio_tbl[BT_COEX_PRIO_TBL_EVT_MAX] = {
+ EVENT_PRIO_ANT(BT_COEX_PRIO_TBL_EVT_INIT_CALIB1,
+         BT_COEX_PRIO_TBL_PRIO_BYPASS, 0),
+ EVENT_PRIO_ANT(BT_COEX_PRIO_TBL_EVT_INIT_CALIB2,
+         BT_COEX_PRIO_TBL_PRIO_BYPASS, 1),
+ EVENT_PRIO_ANT(BT_COEX_PRIO_TBL_EVT_PERIODIC_CALIB_LOW1,
+         BT_COEX_PRIO_TBL_PRIO_LOW, 0),
+ EVENT_PRIO_ANT(BT_COEX_PRIO_TBL_EVT_PERIODIC_CALIB_LOW2,
+         BT_COEX_PRIO_TBL_PRIO_LOW, 1),
+ EVENT_PRIO_ANT(BT_COEX_PRIO_TBL_EVT_PERIODIC_CALIB_HIGH1,
+         BT_COEX_PRIO_TBL_PRIO_HIGH, 0),
+ EVENT_PRIO_ANT(BT_COEX_PRIO_TBL_EVT_PERIODIC_CALIB_HIGH2,
+         BT_COEX_PRIO_TBL_PRIO_HIGH, 1),
+ EVENT_PRIO_ANT(BT_COEX_PRIO_TBL_EVT_DTIM,
+         BT_COEX_PRIO_TBL_DISABLED, 0),
+ EVENT_PRIO_ANT(BT_COEX_PRIO_TBL_EVT_SCAN52,
+         BT_COEX_PRIO_TBL_PRIO_COEX_OFF, 0),
+ EVENT_PRIO_ANT(BT_COEX_PRIO_TBL_EVT_SCAN24,
+         BT_COEX_PRIO_TBL_PRIO_COEX_ON, 0),
+ EVENT_PRIO_ANT(BT_COEX_PRIO_TBL_EVT_IDLE,
+         BT_COEX_PRIO_TBL_PRIO_COEX_IDLE, 0),
+ 0, 0, 0, 0, 0, 0,
+};
+
+#undef EVENT_PRIO_ANT
+
+#define BT_ENABLE_REDUCED_TXPOWER_THRESHOLD (-62)
+#define BT_DISABLE_REDUCED_TXPOWER_THRESHOLD (-65)
+#define BT_ANTENNA_COUPLING_THRESHOLD  (30)
+
+static int iwl_send_bt_prio_tbl(struct iwl_mvm *mvm)
+{
+ return iwl_mvm_send_cmd_pdu(mvm, BT_COEX_PRIO_TABLE, 0,
+        sizeof(struct iwl_bt_coex_prio_tbl_cmd),
+        &iwl_bt_prio_tbl);
+}
+
+const u32 iwl_bt_ack_kill_msk[BT_KILL_MSK_MAX] = {
+ [BT_KILL_MSK_DEFAULT] = 0xffff0000,
+ [BT_KILL_MSK_SCO_HID_A2DP] = 0xffffffff,
+ [BT_KILL_MSK_REDUCED_TXPOW] = 0,
+};
+
+const u32 iwl_bt_cts_kill_msk[BT_KILL_MSK_MAX] = {
+ [BT_KILL_MSK_DEFAULT] = 0xffff0000,
+ [BT_KILL_MSK_SCO_HID_A2DP] = 0xffffffff,
+ [BT_KILL_MSK_REDUCED_TXPOW] = 0,
+};
+
+static const __le32 iwl_bt_prio_boost[BT_COEX_BOOST_SIZE] = {
+ cpu_to_le32(0xf0f0f0f0), /* 50% */
+ cpu_to_le32(0xc0c0c0c0), /* 25% */
+ cpu_to_le32(0xfcfcfcfc), /* 75% */
+ cpu_to_le32(0xfefefefe), /* 87.5% */
+};
+
+static const __le32 iwl_single_shared_ant[BT_COEX_MAX_LUT][BT_COEX_LUT_SIZE] = {
+ {
+  cpu_to_le32(0x40000000),
+  cpu_to_le32(0x00000000),
+  cpu_to_le32(0x44000000),
+  cpu_to_le32(0x00000000),
+  cpu_to_le32(0x40000000),
+  cpu_to_le32(0x00000000),
+  cpu_to_le32(0x44000000),
+  cpu_to_le32(0x00000000),
+  cpu_to_le32(0xc0004000),
+  cpu_to_le32(0xf0005000),
+  cpu_to_le32(0xc0004000),
+  cpu_to_le32(0xf0005000),
+ },
+ {
+  cpu_to_le32(0x40000000),
+  cpu_to_le32(0x00000000),
+  cpu_to_le32(0x44000000),
+  cpu_to_le32(0x00000000),
+  cpu_to_le32(0x40000000),
+  cpu_to_le32(0x00000000),
+  cpu_to_le32(0x44000000),
+  cpu_to_le32(0x00000000),
+  cpu_to_le32(0xc0004000),
+  cpu_to_le32(0xf0005000),
+  cpu_to_le32(0xc0004000),
+  cpu_to_le32(0xf0005000),
+ },
+ {
+  cpu_to_le32(0x40000000),
+  cpu_to_le32(0x00000000),
+  cpu_to_le32(0x44000000),
+  cpu_to_le32(0x00000000),
+  cpu_to_le32(0x40000000),
+  cpu_to_le32(0x00000000),
+  cpu_to_le32(0x44000000),
+  cpu_to_le32(0x00000000),
+  cpu_to_le32(0xc0004000),
+  cpu_to_le32(0xf0005000),
+  cpu_to_le32(0xc0004000),
+  cpu_to_le32(0xf0005000),
+ },
+};
+
+static const __le32 iwl_combined_lookup[BT_COEX_MAX_LUT][BT_COEX_LUT_SIZE] = {
+ {
+  /* Tight */
+  cpu_to_le32(0xaaaaaaaa),
+  cpu_to_le32(0xaaaaaaaa),
+  cpu_to_le32(0xaeaaaaaa),
+  cpu_to_le32(0xaaaaaaaa),
+  cpu_to_le32(0xcc00ff28),
+  cpu_to_le32(0x0000aaaa),
+  cpu_to_le32(0xcc00aaaa),
+  cpu_to_le32(0x0000aaaa),
+  cpu_to_le32(0xc0004000),
+  cpu_to_le32(0x00004000),
+  cpu_to_le32(0xf0005000),
+  cpu_to_le32(0xf0005000),
+ },
+ {
+  /* Loose */
+  cpu_to_le32(0xaaaaaaaa),
+  cpu_to_le32(0xaaaaaaaa),
+  cpu_to_le32(0xaaaaaaaa),
+  cpu_to_le32(0xaaaaaaaa),
+  cpu_to_le32(0xcc00ff28),
+  cpu_to_le32(0x0000aaaa),
+  cpu_to_le32(0xcc00aaaa),
+  cpu_to_le32(0x0000aaaa),
+  cpu_to_le32(0x00000000),
+  cpu_to_le32(0x00000000),
+  cpu_to_le32(0xf0005000),
+  cpu_to_le32(0xf0005000),
+ },
+ {
+  /* Tx Tx disabled */
+  cpu_to_le32(0xaaaaaaaa),
+  cpu_to_le32(0xaaaaaaaa),
+  cpu_to_le32(0xeeaaaaaa),
+  cpu_to_le32(0xaaaaaaaa),
+  cpu_to_le32(0xcc00ff28),
+  cpu_to_le32(0x0000aaaa),
+  cpu_to_le32(0xcc00aaaa),
+  cpu_to_le32(0x0000aaaa),
+  cpu_to_le32(0xc0004000),
+  cpu_to_le32(0xc0004000),
+  cpu_to_le32(0xf0005000),
+  cpu_to_le32(0xf0005000),
+ },
+};
+
+/* 20MHz / 40MHz below / 40Mhz above*/
+static const __le64 iwl_ci_mask[][3] = {
+ /* dummy entry for channel 0 */
+ {cpu_to_le64(0), cpu_to_le64(0), cpu_to_le64(0)},
+ {
+  cpu_to_le64(0x0000001FFFULL),
+  cpu_to_le64(0x0ULL),
+  cpu_to_le64(0x00007FFFFFULL),
+ },
+ {
+  cpu_to_le64(0x000000FFFFULL),
+  cpu_to_le64(0x0ULL),
+  cpu_to_le64(0x0003FFFFFFULL),
+ },
+ {
+  cpu_to_le64(0x000003FFFCULL),
+  cpu_to_le64(0x0ULL),
+  cpu_to_le64(0x000FFFFFFCULL),
+ },
+ {
+  cpu_to_le64(0x00001FFFE0ULL),
+  cpu_to_le64(0x0ULL),
+  cpu_to_le64(0x007FFFFFE0ULL),
+ },
+ {
+  cpu_to_le64(0x00007FFF80ULL),
+  cpu_to_le64(0x00007FFFFFULL),
+  cpu_to_le64(0x01FFFFFF80ULL),
+ },
+ {
+  cpu_to_le64(0x0003FFFC00ULL),
+  cpu_to_le64(0x0003FFFFFFULL),
+  cpu_to_le64(0x0FFFFFFC00ULL),
+ },
+ {
+  cpu_to_le64(0x000FFFF000ULL),
+  cpu_to_le64(0x000FFFFFFCULL),
+  cpu_to_le64(0x3FFFFFF000ULL),
+ },
+ {
+  cpu_to_le64(0x007FFF8000ULL),
+  cpu_to_le64(0x007FFFFFE0ULL),
+  cpu_to_le64(0xFFFFFF8000ULL),
+ },
+ {
+  cpu_to_le64(0x01FFFE0000ULL),
+  cpu_to_le64(0x01FFFFFF80ULL),
+  cpu_to_le64(0xFFFFFE0000ULL),
+ },
+ {
+  cpu_to_le64(0x0FFFF00000ULL),
+  cpu_to_le64(0x0FFFFFFC00ULL),
+  cpu_to_le64(0x0ULL),
+ },
+ {
+  cpu_to_le64(0x3FFFC00000ULL),
+  cpu_to_le64(0x3FFFFFF000ULL),
+  cpu_to_le64(0x0)
+ },
+ {
+  cpu_to_le64(0xFFFE000000ULL),
+  cpu_to_le64(0xFFFFFF8000ULL),
+  cpu_to_le64(0x0)
+ },
+ {
+  cpu_to_le64(0xFFF8000000ULL),
+  cpu_to_le64(0xFFFFFE0000ULL),
+  cpu_to_le64(0x0)
+ },
+ {
+  cpu_to_le64(0xFFC0000000ULL),
+  cpu_to_le64(0x0ULL),
+  cpu_to_le64(0x0ULL)
+ },
+};
+
+static const __le32 iwl_bt_mprio_lut[BT_COEX_MULTI_PRIO_LUT_SIZE] = {
+ cpu_to_le32(0x28412201),
+ cpu_to_le32(0x11118451),
+};
+
+struct corunning_block_luts {
+ u8 range;
+ __le32 lut20[BT_COEX_CORUN_LUT_SIZE];
+};
+
+/*
+ * Ranges for the antenna coupling calibration / co-running block LUT:
+ *  LUT0: [ 0, 12[
+ *  LUT1: [12, 20[
+ *  LUT2: [20, 21[
+ *  LUT3: [21, 23[
+ *  LUT4: [23, 27[
+ *  LUT5: [27, 30[
+ *  LUT6: [30, 32[
+ *  LUT7: [32, 33[
+ *  LUT8: [33, - [
+ */
+static const struct corunning_block_luts antenna_coupling_ranges[] = {
+ {
+  .range = 0,
+  .lut20 = {
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+  },
+ },
+ {
+  .range = 12,
+  .lut20 = {
+   cpu_to_le32(0x00000001),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+  },
+ },
+ {
+  .range = 20,
+  .lut20 = {
+   cpu_to_le32(0x00000002),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+  },
+ },
+ {
+  .range = 21,
+  .lut20 = {
+   cpu_to_le32(0x00000003),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+  },
+ },
+ {
+  .range = 23,
+  .lut20 = {
+   cpu_to_le32(0x00000004),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+  },
+ },
+ {
+  .range = 27,
+  .lut20 = {
+   cpu_to_le32(0x00000005),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+  },
+ },
+ {
+  .range = 30,
+  .lut20 = {
+   cpu_to_le32(0x00000006),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+  },
+ },
+ {
+  .range = 32,
+  .lut20 = {
+   cpu_to_le32(0x00000007),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+  },
+ },
+ {
+  .range = 33,
+  .lut20 = {
+   cpu_to_le32(0x00000008),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+   cpu_to_le32(0x00000000),  cpu_to_le32(0x00000000),
+  },
+ },
+};
+
+static enum iwl_bt_coex_lut_type
+iwl_get_coex_type(struct iwl_mvm *mvm, const struct ieee80211_vif *vif)
+{
+ struct ieee80211_chanctx_conf *chanctx_conf;
+ enum iwl_bt_coex_lut_type ret;
+ u16 phy_ctx_id;
+
+ /*
+  * Checking that we hold mvm->mutex is a good idea, but the rate
+  * control can't acquire the mutex since it runs in Tx path.
+  * So this is racy in that case, but in the worst case, the AMPDU
+  * size limit will be wrong for a short time which is not a big
+  * issue.
+  */
+
+ rcu_read_lock();
+
+ chanctx_conf = rcu_dereference(vif->chanctx_conf);
+
+ if (!chanctx_conf ||
+      chanctx_conf->def.chan->band != IEEE80211_BAND_2GHZ) {
+  rcu_read_unlock();
+  return BT_COEX_LOOSE_LUT;
+ }
+
+ ret = BT_COEX_TX_DIS_LUT;
+
+ if (mvm->cfg->bt_shared_single_ant) {
+  rcu_read_unlock();
+  return ret;
+ }
+
+ phy_ctx_id = *((u16 *)chanctx_conf->drv_priv);
+
+ if (mvm->last_bt_ci_cmd.primary_ch_phy_id == phy_ctx_id)
+  ret = le32_to_cpu(mvm->last_bt_notif.primary_ch_lut);
+ else if (mvm->last_bt_ci_cmd.secondary_ch_phy_id == phy_ctx_id)
+  ret = le32_to_cpu(mvm->last_bt_notif.secondary_ch_lut);
+ /* else - default = TX TX disallowed */
+
+ rcu_read_unlock();
+
+ return ret;
+}
+
+int iwl_send_bt_init_conf(struct iwl_mvm *mvm)
+{
+ struct iwl_bt_coex_cmd *bt_cmd;
+ struct iwl_host_cmd cmd = {
+  .id = BT_CONFIG,
+  .len = { sizeof(*bt_cmd), },
+  .dataflags = { IWL_HCMD_DFL_NOCOPY, },
+ };
+ int ret;
+ u32 flags;
+
+ ret = iwl_send_bt_prio_tbl(mvm);
+ if (ret)
+  return ret;
+
+ bt_cmd = kzalloc(sizeof(*bt_cmd), GFP_KERNEL);
+ if (!bt_cmd)
+  return -ENOMEM;
+ cmd.data[0] = bt_cmd;
+
+ bt_cmd->max_kill = 5;
+ bt_cmd->bt4_antenna_isolation_thr = BT_ANTENNA_COUPLING_THRESHOLD;
+ bt_cmd->bt4_antenna_isolation = iwlwifi_mod_params.ant_coupling;
+ bt_cmd->bt4_tx_tx_delta_freq_thr = 15;
+ bt_cmd->bt4_tx_rx_max_freq0 = 15;
+ bt_cmd->override_primary_lut = BT_COEX_INVALID_LUT;
+ bt_cmd->override_secondary_lut = BT_COEX_INVALID_LUT;
+
+ flags = iwlwifi_mod_params.bt_coex_active ?
+   BT_COEX_NW : BT_COEX_DISABLE;
+ bt_cmd->flags = cpu_to_le32(flags);
+
+ bt_cmd->valid_bit_msk = cpu_to_le32(BT_VALID_ENABLE |
+         BT_VALID_BT_PRIO_BOOST |
+         BT_VALID_MAX_KILL |
+         BT_VALID_3W_TMRS |
+         BT_VALID_KILL_ACK |
+         BT_VALID_KILL_CTS |
+         BT_VALID_REDUCED_TX_POWER |
+         BT_VALID_LUT |
+         BT_VALID_WIFI_RX_SW_PRIO_BOOST |
+         BT_VALID_WIFI_TX_SW_PRIO_BOOST |
+         BT_VALID_ANT_ISOLATION |
+         BT_VALID_ANT_ISOLATION_THRS |
+         BT_VALID_TXTX_DELTA_FREQ_THRS |
+         BT_VALID_TXRX_MAX_FREQ_0 |
+         BT_VALID_SYNC_TO_SCO);
+
+ if (IWL_MVM_BT_COEX_SYNC2SCO)
+  bt_cmd->flags |= cpu_to_le32(BT_COEX_SYNC2SCO);
+
+ if (IWL_MVM_BT_COEX_CORUNNING) {
+  bt_cmd->valid_bit_msk |= cpu_to_le32(BT_VALID_CORUN_LUT_20 |
+           BT_VALID_CORUN_LUT_40);
+  bt_cmd->flags |= cpu_to_le32(BT_COEX_CORUNNING);
+ }
+
+ if (IWL_MVM_BT_COEX_MPLUT) {
+  bt_cmd->flags |= cpu_to_le32(BT_COEX_MPLUT);
+  bt_cmd->valid_bit_msk |= cpu_to_le32(BT_VALID_MULTI_PRIO_LUT);
+ }
+
+ if (mvm->cfg->bt_shared_single_ant)
+  memcpy(&bt_cmd->decision_lut, iwl_single_shared_ant,
+         sizeof(iwl_single_shared_ant));
+ else
+  memcpy(&bt_cmd->decision_lut, iwl_combined_lookup,
+         sizeof(iwl_combined_lookup));
+
+ /* Take first Co-running block LUT to get started */
+ memcpy(bt_cmd->bt4_corun_lut20, antenna_coupling_ranges[0].lut20,
+        sizeof(bt_cmd->bt4_corun_lut20));
+ memcpy(bt_cmd->bt4_corun_lut40, antenna_coupling_ranges[0].lut20,
+        sizeof(bt_cmd->bt4_corun_lut40));
+
+ memcpy(&bt_cmd->bt_prio_boost, iwl_bt_prio_boost,
+        sizeof(iwl_bt_prio_boost));
+ memcpy(&bt_cmd->bt4_multiprio_lut, iwl_bt_mprio_lut,
+        sizeof(iwl_bt_mprio_lut));
+ bt_cmd->kill_ack_msk =
+  cpu_to_le32(iwl_bt_ack_kill_msk[BT_KILL_MSK_DEFAULT]);
+ bt_cmd->kill_cts_msk =
+  cpu_to_le32(iwl_bt_cts_kill_msk[BT_KILL_MSK_DEFAULT]);
+
+ memset(&mvm->last_bt_notif, 0, sizeof(mvm->last_bt_notif));
+ memset(&mvm->last_bt_ci_cmd, 0, sizeof(mvm->last_bt_ci_cmd));
+
+ ret = iwl_mvm_send_cmd(mvm, &cmd);
+
+ kfree(bt_cmd);
+ return ret;
+}
+
+static int iwl_mvm_bt_udpate_ctrl_kill_msk(struct iwl_mvm *mvm,
+        bool reduced_tx_power)
+{
+ enum iwl_bt_kill_msk bt_kill_msk;
+ struct iwl_bt_coex_cmd *bt_cmd;
+ struct iwl_bt_coex_profile_notif *notif = &mvm->last_bt_notif;
+ struct iwl_host_cmd cmd = {
+  .id = BT_CONFIG,
+  .data[0] = &bt_cmd,
+  .len = { sizeof(*bt_cmd), },
+  .dataflags = { IWL_HCMD_DFL_NOCOPY, },
+ };
+ int ret = 0;
+
+ lockdep_assert_held(&mvm->mutex);
+
+ if (reduced_tx_power) {
+  /* Reduced Tx power has precedence on the type of the profile */
+  bt_kill_msk = BT_KILL_MSK_REDUCED_TXPOW;
+ } else {
+  /* Low latency BT profile is active: give higher prio to BT */
+  if (BT_MBOX_MSG(notif, 3, SCO_STATE)  ||
+      BT_MBOX_MSG(notif, 3, A2DP_STATE) ||
+      BT_MBOX_MSG(notif, 3, SNIFF_STATE))
+   bt_kill_msk = BT_KILL_MSK_SCO_HID_A2DP;
+  else
+   bt_kill_msk = BT_KILL_MSK_DEFAULT;
+ }
+
+ IWL_DEBUG_COEX(mvm,
+         "Update kill_msk: %d - SCO %sactive A2DP %sactive SNIFF %sactive\n",
+         bt_kill_msk,
+         BT_MBOX_MSG(notif, 3, SCO_STATE) ? "" : "in",
+         BT_MBOX_MSG(notif, 3, A2DP_STATE) ? "" : "in",
+         BT_MBOX_MSG(notif, 3, SNIFF_STATE) ? "" : "in");
+
+ /* Don't send HCMD if there is no update */
+ if (bt_kill_msk == mvm->bt_kill_msk)
+  return 0;
+
+ mvm->bt_kill_msk = bt_kill_msk;
+
+ bt_cmd = kzalloc(sizeof(*bt_cmd), GFP_KERNEL);
+ if (!bt_cmd)
+  return -ENOMEM;
+ cmd.data[0] = bt_cmd;
+ bt_cmd->flags = cpu_to_le32(BT_COEX_NW);
+
+ bt_cmd->kill_ack_msk = cpu_to_le32(iwl_bt_ack_kill_msk[bt_kill_msk]);
+ bt_cmd->kill_cts_msk = cpu_to_le32(iwl_bt_cts_kill_msk[bt_kill_msk]);
+ bt_cmd->valid_bit_msk |= cpu_to_le32(BT_VALID_ENABLE |
+          BT_VALID_KILL_ACK |
+          BT_VALID_KILL_CTS);
+
+ IWL_DEBUG_COEX(mvm, "ACK Kill msk = 0x%08x, CTS Kill msk = 0x%08x\n",
+         iwl_bt_ack_kill_msk[bt_kill_msk],
+         iwl_bt_cts_kill_msk[bt_kill_msk]);
+
+ ret = iwl_mvm_send_cmd(mvm, &cmd);
+
+ kfree(bt_cmd);
+ return ret;
+}
+
+static int iwl_mvm_bt_coex_reduced_txp(struct iwl_mvm *mvm, u8 sta_id,
+           bool enable)
+{
+ struct iwl_bt_coex_cmd *bt_cmd;
+ /* Send ASYNC since this can be sent from an atomic context */
+ struct iwl_host_cmd cmd = {
+  .id = BT_CONFIG,
+  .len = { sizeof(*bt_cmd), },
+  .dataflags = { IWL_HCMD_DFL_NOCOPY, },
+  .flags = CMD_ASYNC,
+ };
+ struct iwl_mvm_sta *mvmsta;
+ int ret;
+
+ mvmsta = iwl_mvm_sta_from_staid_protected(mvm, sta_id);
+ if (!mvmsta)
+  return 0;
+
+ /* nothing to do */
+ if (mvmsta->bt_reduced_txpower == enable)
+  return 0;
+
+ bt_cmd = kzalloc(sizeof(*bt_cmd), GFP_ATOMIC);
+ if (!bt_cmd)
+  return -ENOMEM;
+ cmd.data[0] = bt_cmd;
+ bt_cmd->flags = cpu_to_le32(BT_COEX_NW);
+
+ bt_cmd->valid_bit_msk =
+  cpu_to_le32(BT_VALID_ENABLE | BT_VALID_REDUCED_TX_POWER);
+ bt_cmd->bt_reduced_tx_power = sta_id;
+
+ if (enable)
+  bt_cmd->bt_reduced_tx_power |= BT_REDUCED_TX_POWER_BIT;
+
+ IWL_DEBUG_COEX(mvm, "%sable reduced Tx Power for sta %d\n",
+         enable ? "en" : "dis", sta_id);
+
+ mvmsta->bt_reduced_txpower = enable;
+
+ ret = iwl_mvm_send_cmd(mvm, &cmd);
+
+ kfree(bt_cmd);
+ return ret;
+}
+
+struct iwl_bt_iterator_data {
+ struct iwl_bt_coex_profile_notif *notif;
+ struct iwl_mvm *mvm;
+ u32 num_bss_ifaces;
+ bool reduced_tx_power;
+ struct ieee80211_chanctx_conf *primary;
+ struct ieee80211_chanctx_conf *secondary;
+ bool primary_ll;
+};
+
+static inline
+void iwl_mvm_bt_coex_enable_rssi_event(struct iwl_mvm *mvm,
+           struct ieee80211_vif *vif,
+           bool enable, int rssi)
+{
+ struct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);
+
+ mvmvif->bf_data.last_bt_coex_event = rssi;
+ mvmvif->bf_data.bt_coex_max_thold =
+  enable ? BT_ENABLE_REDUCED_TXPOWER_THRESHOLD : 0;
+ mvmvif->bf_data.bt_coex_min_thold =
+  enable ? BT_DISABLE_REDUCED_TXPOWER_THRESHOLD : 0;
+}
+
+/* must be called under rcu_read_lock */
+static void iwl_mvm_bt_notif_iterator(void *_data, u8 *mac,
+          struct ieee80211_vif *vif)
+{
+ struct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);
+ struct iwl_bt_iterator_data *data = _data;
+ struct iwl_mvm *mvm = data->mvm;
+ struct ieee80211_chanctx_conf *chanctx_conf;
+ enum ieee80211_smps_mode smps_mode;
+ u32 bt_activity_grading;
+ int ave_rssi;
+
+ lockdep_assert_held(&mvm->mutex);
+
+ switch (vif->type) {
+ case NL80211_IFTYPE_STATION:
+  /* Count BSSes vifs */
+  data->num_bss_ifaces++;
+  /* default smps_mode for BSS / P2P client is AUTOMATIC */
+  smps_mode = IEEE80211_SMPS_AUTOMATIC;
+  break;
+ case NL80211_IFTYPE_AP:
+  /* default smps_mode for AP / GO is OFF */
+  smps_mode = IEEE80211_SMPS_OFF;
+  if (!mvmvif->ap_ibss_active) {
+   iwl_mvm_update_smps(mvm, vif, IWL_MVM_SMPS_REQ_BT_COEX,
+         smps_mode);
+   return;
+  }
+
+  /* the Ack / Cts kill mask must be default if AP / GO */
+  data->reduced_tx_power = false;
+  break;
+ default:
+  return;
+ }
+
+ chanctx_conf = rcu_dereference(vif->chanctx_conf);
+
+ /* If channel context is invalid or not on 2.4GHz .. */
+ if ((!chanctx_conf ||
+      chanctx_conf->def.chan->band != IEEE80211_BAND_2GHZ)) {
+  /* ... relax constraints and disable rssi events */
+  iwl_mvm_update_smps(mvm, vif, IWL_MVM_SMPS_REQ_BT_COEX,
+        smps_mode);
+  data->reduced_tx_power = false;
+  if (vif->type == NL80211_IFTYPE_STATION) {
+   iwl_mvm_bt_coex_reduced_txp(mvm, mvmvif->ap_sta_id,
+          false);
+   iwl_mvm_bt_coex_enable_rssi_event(mvm, vif, false, 0);
+  }
+  return;
+ }
+
+ bt_activity_grading = le32_to_cpu(data->notif->bt_activity_grading);
+ if (bt_activity_grading >= BT_HIGH_TRAFFIC)
+  smps_mode = IEEE80211_SMPS_STATIC;
+ else if (bt_activity_grading >= BT_LOW_TRAFFIC)
+  smps_mode = vif->type == NL80211_IFTYPE_AP ?
+    IEEE80211_SMPS_OFF :
+    IEEE80211_SMPS_DYNAMIC;
+
+ /* relax SMPS contraints for next association */
+ if (!vif->bss_conf.assoc)
+  smps_mode = IEEE80211_SMPS_AUTOMATIC;
+
+ IWL_DEBUG_COEX(data->mvm,
+         "mac %d: bt_status %d bt_activity_grading %d smps_req %d\n",
+         mvmvif->id, data->notif->bt_status, bt_activity_grading,
+         smps_mode);
+
+ iwl_mvm_update_smps(mvm, vif, IWL_MVM_SMPS_REQ_BT_COEX, smps_mode);
+
+ /* low latency is always primary */
+ if (iwl_mvm_vif_low_latency(mvmvif)) {
+  data->primary_ll = true;
+
+  data->secondary = data->primary;
+  data->primary = chanctx_conf;
+ }
+
+ if (vif->type == NL80211_IFTYPE_AP) {
+  if (!mvmvif->ap_ibss_active)
+   return;
+
+  if (chanctx_conf == data->primary)
+   return;
+
+  if (!data->primary_ll) {
+   /*
+    * downgrade the current primary no matter what its
+    * type is.
+    */
+   data->secondary = data->primary;
+   data->primary = chanctx_conf;
+  } else {
+   /* there is low latency vif - we will be secondary */
+   data->secondary = chanctx_conf;
+  }
+  return;
+ }
+
+ /*
+  * STA / P2P Client, try to be primary if first vif. If we are in low
+  * latency mode, we are already in primary and just don't do much
+  */
+ if (!data->primary || data->primary == chanctx_conf)
+  data->primary = chanctx_conf;
+ else if (!data->secondary)
+  /* if secondary is not NULL, it might be a GO */
+  data->secondary = chanctx_conf;
+
+ /*
+  * don't reduce the Tx power if one of these is true:
+  *  we are in LOOSE
+  *  single share antenna product
+  *  BT is active
+  *  we are associated
+  */
+ if (iwl_get_coex_type(mvm, vif) == BT_COEX_LOOSE_LUT ||
+     mvm->cfg->bt_shared_single_ant || !vif->bss_conf.assoc ||
+     !data->notif->bt_status) {
+  data->reduced_tx_power = false;
+  iwl_mvm_bt_coex_reduced_txp(mvm, mvmvif->ap_sta_id, false);
+  iwl_mvm_bt_coex_enable_rssi_event(mvm, vif, false, 0);
+  return;
+ }
+
+ /* try to get the avg rssi from fw */
+ ave_rssi = mvmvif->bf_data.ave_beacon_signal;
+
+ /* if the RSSI isn't valid, fake it is very low */
+ if (!ave_rssi)
+  ave_rssi = -100;
+ if (ave_rssi > BT_ENABLE_REDUCED_TXPOWER_THRESHOLD) {
+  if (iwl_mvm_bt_coex_reduced_txp(mvm, mvmvif->ap_sta_id, true))
+   IWL_ERR(mvm, "Couldn't send BT_CONFIG cmd\n");
+
+  /*
+   * bt_kill_msk can be BT_KILL_MSK_REDUCED_TXPOW only if all the
+   * BSS / P2P clients have rssi above threshold.
+   * We set the bt_kill_msk to BT_KILL_MSK_REDUCED_TXPOW before
+   * the iteration, if one interface's rssi isn't good enough,
+   * bt_kill_msk will be set to default values.
+   */
+ } else if (ave_rssi < BT_DISABLE_REDUCED_TXPOWER_THRESHOLD) {
+  if (iwl_mvm_bt_coex_reduced_txp(mvm, mvmvif->ap_sta_id, false))
+   IWL_ERR(mvm, "Couldn't send BT_CONFIG cmd\n");
+
+  /*
+   * One interface hasn't rssi above threshold, bt_kill_msk must
+   * be set to default values.
+   */
+  data->reduced_tx_power = false;
+ }
+
+ /* Begin to monitor the RSSI: it may influence the reduced Tx power */
+ iwl_mvm_bt_coex_enable_rssi_event(mvm, vif, true, ave_rssi);
+}
+
+static void iwl_mvm_bt_coex_notif_handle(struct iwl_mvm *mvm)
+{
+ struct iwl_bt_iterator_data data = {
+  .mvm = mvm,
+  .notif = &mvm->last_bt_notif,
+  .reduced_tx_power = true,
+ };
+ struct iwl_bt_coex_ci_cmd cmd = {};
+ u8 ci_bw_idx;
+
+ rcu_read_lock();
+ ieee80211_iterate_active_interfaces_atomic(
+     mvm->hw, IEEE80211_IFACE_ITER_NORMAL,
+     iwl_mvm_bt_notif_iterator, &data);
+
+ if (data.primary) {
+  struct ieee80211_chanctx_conf *chan = data.primary;
+  if (WARN_ON(!chan->def.chan)) {
+   rcu_read_unlock();
+   return;
+  }
+
+  if (chan->def.width < NL80211_CHAN_WIDTH_40) {
+   ci_bw_idx = 0;
+   cmd.co_run_bw_primary = 0;
+  } else {
+   cmd.co_run_bw_primary = 1;
+   if (chan->def.center_freq1 >
+       chan->def.chan->center_freq)
+    ci_bw_idx = 2;
+   else
+    ci_bw_idx = 1;
+  }
+
+  cmd.bt_primary_ci =
+   iwl_ci_mask[chan->def.chan->hw_value][ci_bw_idx];
+  cmd.primary_ch_phy_id = *((u16 *)data.primary->drv_priv);
+ }
+
+ if (data.secondary) {
+  struct ieee80211_chanctx_conf *chan = data.secondary;
+  if (WARN_ON(!data.secondary->def.chan)) {
+   rcu_read_unlock();
+   return;
+  }
+
+  if (chan->def.width < NL80211_CHAN_WIDTH_40) {
+   ci_bw_idx = 0;
+   cmd.co_run_bw_secondary = 0;
+  } else {
+   cmd.co_run_bw_secondary = 1;
+   if (chan->def.center_freq1 >
+       chan->def.chan->center_freq)
+    ci_bw_idx = 2;
+   else
+    ci_bw_idx = 1;
+  }
+
+  cmd.bt_secondary_ci =
+   iwl_ci_mask[chan->def.chan->hw_value][ci_bw_idx];
+  cmd.secondary_ch_phy_id = *((u16 *)data.secondary->drv_priv);
+ }
+
+ rcu_read_unlock();
+
+ /* Don't spam the fw with the same command over and over */
+ if (memcmp(&cmd, &mvm->last_bt_ci_cmd, sizeof(cmd))) {
+  if (iwl_mvm_send_cmd_pdu(mvm, BT_COEX_CI, 0,
+      sizeof(cmd), &cmd))
+   IWL_ERR(mvm, "Failed to send BT_CI cmd\n");
+  memcpy(&mvm->last_bt_ci_cmd, &cmd, sizeof(cmd));
+ }
+
+ /*
+  * If there are no BSS / P2P client interfaces, reduced Tx Power is
+  * irrelevant since it is based on the RSSI coming from the beacon.
+  * Use BT_KILL_MSK_DEFAULT in that case.
+  */
+ data.reduced_tx_power = data.reduced_tx_power && data.num_bss_ifaces;
+
+ if (iwl_mvm_bt_udpate_ctrl_kill_msk(mvm, data.reduced_tx_power))
+  IWL_ERR(mvm, "Failed to update the ctrl_kill_msk\n");
+}
+
+int iwl_mvm_rx_bt_coex_notif(struct iwl_mvm *mvm,
+        struct iwl_rx_cmd_buffer *rxb,
+        struct iwl_device_cmd *dev_cmd)
+{
+ struct iwl_rx_packet *pkt = rxb_addr(rxb);
+ struct iwl_bt_coex_profile_notif *notif = (void *)pkt->data;
+
+
+ IWL_DEBUG_COEX(mvm, "BT Coex Notification received\n");
+ IWL_DEBUG_COEX(mvm, "\tBT status: %s\n",
+         notif->bt_status ? "ON" : "OFF");
+ IWL_DEBUG_COEX(mvm, "\tBT open conn %d\n", notif->bt_open_conn);
+ IWL_DEBUG_COEX(mvm, "\tBT ci compliance %d\n", notif->bt_ci_compliance);
+ IWL_DEBUG_COEX(mvm, "\tBT primary_ch_lut %d\n",
+         le32_to_cpu(notif->primary_ch_lut));
+ IWL_DEBUG_COEX(mvm, "\tBT secondary_ch_lut %d\n",
+         le32_to_cpu(notif->secondary_ch_lut));
+ IWL_DEBUG_COEX(mvm, "\tBT activity grading %d\n",
+         le32_to_cpu(notif->bt_activity_grading));
+ IWL_DEBUG_COEX(mvm, "\tBT agg traffic load %d\n",
+         notif->bt_agg_traffic_load);
+
+ /* remember this notification for future use: rssi fluctuations */
+ memcpy(&mvm->last_bt_notif, notif, sizeof(mvm->last_bt_notif));
+
+ iwl_mvm_bt_coex_notif_handle(mvm);
+
+ /*
+  * This is an async handler for a notification, returning anything other
+  * than 0 doesn't make sense even if HCMD failed.
+  */
+ return 0;
+}
+
+static void iwl_mvm_bt_rssi_iterator(void *_data, u8 *mac,
+       struct ieee80211_vif *vif)
+{
+ struct iwl_mvm_vif *mvmvif = (void *)vif->drv_priv;
+ struct iwl_bt_iterator_data *data = _data;
+ struct iwl_mvm *mvm = data->mvm;
+
+ struct ieee80211_sta *sta;
+ struct iwl_mvm_sta *mvmsta;
+
+ struct ieee80211_chanctx_conf *chanctx_conf;
+
+ rcu_read_lock();
+ chanctx_conf = rcu_dereference(vif->chanctx_conf);
+ /* If channel context is invalid or not on 2.4GHz - don't count it */
+ if (!chanctx_conf ||
+     chanctx_conf->def.chan->band != IEEE80211_BAND_2GHZ) {
+  rcu_read_unlock();
+  return;
+ }
+ rcu_read_unlock();
+
+ if (vif->type != NL80211_IFTYPE_STATION ||
+     mvmvif->ap_sta_id == IWL_MVM_STATION_COUNT)
+  return;
+
+ sta = rcu_dereference_protected(mvm->fw_id_to_mac_id[mvmvif->ap_sta_id],
+     lockdep_is_held(&mvm->mutex));
+
+ /* This can happen if the station has been removed right now */
+ if (IS_ERR_OR_NULL(sta))
+  return;
+
+ mvmsta = iwl_mvm_sta_from_mac80211(sta);
+
+ data->num_bss_ifaces++;
+
+ /*
+  * This interface doesn't support reduced Tx power (because of low
+  * RSSI probably), then set bt_kill_msk to default values.
+  */
+ if (!mvmsta->bt_reduced_txpower)
+  data->reduced_tx_power = false;
+ /* else - possibly leave it to BT_KILL_MSK_REDUCED_TXPOW */
+}
+
+void iwl_mvm_bt_rssi_event(struct iwl_mvm *mvm, struct ieee80211_vif *vif,
+      enum ieee80211_rssi_event rssi_event)
+{
+ struct iwl_mvm_vif *mvmvif = (void *)vif->drv_priv;
+ struct iwl_bt_iterator_data data = {
+  .mvm = mvm,
+  .reduced_tx_power = true,
+ };
+ int ret;
+
+ lockdep_assert_held(&mvm->mutex);
+
+ /*
+  * Rssi update while not associated - can happen since the statistics
+  * are handled asynchronously
+  */
+ if (mvmvif->ap_sta_id == IWL_MVM_STATION_COUNT)
+  return;
+
+ /* No BT - reports should be disabled */
+ if (!mvm->last_bt_notif.bt_status)
+  return;
+
+ IWL_DEBUG_COEX(mvm, "RSSI for %pM is now %s\n", vif->bss_conf.bssid,
+         rssi_event == RSSI_EVENT_HIGH ? "HIGH" : "LOW");
+
+ /*
+  * Check if rssi is good enough for reduced Tx power, but not in loose
+  * scheme.
+  */
+ if (rssi_event == RSSI_EVENT_LOW || mvm->cfg->bt_shared_single_ant ||
+     iwl_get_coex_type(mvm, vif) == BT_COEX_LOOSE_LUT)
+  ret = iwl_mvm_bt_coex_reduced_txp(mvm, mvmvif->ap_sta_id,
+        false);
+ else
+  ret = iwl_mvm_bt_coex_reduced_txp(mvm, mvmvif->ap_sta_id, true);
+
+ if (ret)
+  IWL_ERR(mvm, "couldn't send BT_CONFIG HCMD upon RSSI event\n");
+
+ ieee80211_iterate_active_interfaces_atomic(
+  mvm->hw, IEEE80211_IFACE_ITER_NORMAL,
+  iwl_mvm_bt_rssi_iterator, &data);
+
+ /*
+  * If there are no BSS / P2P client interfaces, reduced Tx Power is
+  * irrelevant since it is based on the RSSI coming from the beacon.
+  * Use BT_KILL_MSK_DEFAULT in that case.
+  */
+ data.reduced_tx_power = data.reduced_tx_power && data.num_bss_ifaces;
+
+ if (iwl_mvm_bt_udpate_ctrl_kill_msk(mvm, data.reduced_tx_power))
+  IWL_ERR(mvm, "Failed to update the ctrl_kill_msk\n");
+}
+
+#define LINK_QUAL_AGG_TIME_LIMIT_DEF (4000)
+#define LINK_QUAL_AGG_TIME_LIMIT_BT_ACT (1200)
+
+u16 iwl_mvm_coex_agg_time_limit(struct iwl_mvm *mvm,
+    struct ieee80211_sta *sta)
+{
+ struct iwl_mvm_sta *mvmsta = iwl_mvm_sta_from_mac80211(sta);
+ enum iwl_bt_coex_lut_type lut_type;
+
+ if (le32_to_cpu(mvm->last_bt_notif.bt_activity_grading) <
+     BT_HIGH_TRAFFIC)
+  return LINK_QUAL_AGG_TIME_LIMIT_DEF;
+
+ lut_type = iwl_get_coex_type(mvm, mvmsta->vif);
+
+ if (lut_type == BT_COEX_LOOSE_LUT)
+  return LINK_QUAL_AGG_TIME_LIMIT_DEF;
+
+ /* tight coex, high bt traffic, reduce AGG time limit */
+ return LINK_QUAL_AGG_TIME_LIMIT_BT_ACT;
+}
+
+bool iwl_mvm_bt_coex_is_mimo_allowed(struct iwl_mvm *mvm,
+         struct ieee80211_sta *sta)
+{
+ struct iwl_mvm_sta *mvmsta = iwl_mvm_sta_from_mac80211(sta);
+
+ if (le32_to_cpu(mvm->last_bt_notif.bt_activity_grading) <
+     BT_HIGH_TRAFFIC)
+  return true;
+
+ /*
+  * In Tight, BT can't Rx while we Tx, so use both antennas since BT is
+  * already killed.
+  * In Loose, BT can Rx while we Tx, so forbid MIMO to let BT Rx while we
+  * Tx.
+  */
+ return iwl_get_coex_type(mvm, mvmsta->vif) == BT_COEX_TIGHT_LUT;
+}
+
+bool iwl_mvm_bt_coex_is_tpc_allowed(struct iwl_mvm *mvm,
+        enum ieee80211_band band)
+{
+ u32 bt_activity = le32_to_cpu(mvm->last_bt_notif.bt_activity_grading);
+
+ if (band != IEEE80211_BAND_2GHZ)
+  return false;
+
+ return bt_activity >= BT_LOW_TRAFFIC;
+}
+
+u8 iwl_mvm_bt_coex_tx_prio(struct iwl_mvm *mvm, struct ieee80211_hdr *hdr,
+      struct ieee80211_tx_info *info, u8 ac)
+{
+ __le16 fc = hdr->frame_control;
+
+ if (info->band != IEEE80211_BAND_2GHZ)
+  return 0;
+
+ if (unlikely(mvm->bt_tx_prio))
+  return mvm->bt_tx_prio - 1;
+
+ /* High prio packet (wrt. BT coex) if it is EAPOL, MCAST or MGMT */
+ if (info->control.flags & IEEE80211_TX_CTRL_PORT_CTRL_PROTO ||
+      is_multicast_ether_addr(hdr->addr1) ||
+      ieee80211_is_ctl(fc) || ieee80211_is_mgmt(fc) ||
+      ieee80211_is_nullfunc(fc) || ieee80211_is_qos_nullfunc(fc))
+  return 3;
+
+ switch (ac) {
+ case IEEE80211_AC_BE:
+  return 1;
+ case IEEE80211_AC_VO:
+  return 3;
+ case IEEE80211_AC_VI:
+  return 2;
+ default:
+  break;
+ }
+
+ return 0;
+}
+
+void iwl_mvm_bt_coex_vif_change(struct iwl_mvm *mvm)
+{
+ iwl_mvm_bt_coex_notif_handle(mvm);
+}
+
+int iwl_mvm_rx_ant_coupling_notif(struct iwl_mvm *mvm,
+      struct iwl_rx_cmd_buffer *rxb,
+      struct iwl_device_cmd *dev_cmd)
+{
+ struct iwl_rx_packet *pkt = rxb_addr(rxb);
+ u32 ant_isolation = le32_to_cpup((void *)pkt->data);
+ u8 __maybe_unused lower_bound, upper_bound;
+ int ret;
+ u8 lut;
+
+ struct iwl_bt_coex_cmd *bt_cmd;
+ struct iwl_host_cmd cmd = {
+  .id = BT_CONFIG,
+  .len = { sizeof(*bt_cmd), },
+  .dataflags = { IWL_HCMD_DFL_NOCOPY, },
+ };
+
+ if (!IWL_MVM_BT_COEX_CORUNNING)
+  return 0;
+
+ lockdep_assert_held(&mvm->mutex);
+
+ if (ant_isolation ==  mvm->last_ant_isol)
+  return 0;
+
+ for (lut = 0; lut < ARRAY_SIZE(antenna_coupling_ranges) - 1; lut++)
+  if (ant_isolation < antenna_coupling_ranges[lut + 1].range)
+   break;
+
+ lower_bound = antenna_coupling_ranges[lut].range;
+
+ if (lut < ARRAY_SIZE(antenna_coupling_ranges) - 1)
+  upper_bound = antenna_coupling_ranges[lut + 1].range;
+ else
+  upper_bound = antenna_coupling_ranges[lut].range;
+
+ IWL_DEBUG_COEX(mvm, "Antenna isolation=%d in range [%d,%d[, lut=%d\n",
+         ant_isolation, lower_bound, upper_bound, lut);
+
+ mvm->last_ant_isol = ant_isolation;
+
+ if (mvm->last_corun_lut == lut)
+  return 0;
+
+ mvm->last_corun_lut = lut;
+
+ bt_cmd = kzalloc(sizeof(*bt_cmd), GFP_KERNEL);
+ if (!bt_cmd)
+  return 0;
+ cmd.data[0] = bt_cmd;
+
+ bt_cmd->flags = cpu_to_le32(BT_COEX_NW);
+ bt_cmd->valid_bit_msk |= cpu_to_le32(BT_VALID_ENABLE |
+          BT_VALID_CORUN_LUT_20 |
+          BT_VALID_CORUN_LUT_40);
+
+ /* For the moment, use the same LUT for 20GHz and 40GHz */
+ memcpy(bt_cmd->bt4_corun_lut20, antenna_coupling_ranges[lut].lut20,
+        sizeof(bt_cmd->bt4_corun_lut20));
+
+ memcpy(bt_cmd->bt4_corun_lut40, antenna_coupling_ranges[lut].lut20,
+        sizeof(bt_cmd->bt4_corun_lut40));
+
+ ret = iwl_mvm_send_cmd(mvm, &cmd);
+
+ kfree(bt_cmd);
+ return ret;
+}
diff --git a/drivers/net/wireless/iwlwifi/mvm/constants.h b/drivers/net/wireless/iwlwifi/mvm/constants.h
new file mode 100644
index 0000000..5168569
--- /dev/null
+++ b/drivers/net/wireless/iwlwifi/mvm/constants.h
@@ -0,0 +1,86 @@
+/******************************************************************************
+ *
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ * redistributing this file, you may do so under either license.
+ *
+ * GPL LICENSE SUMMARY
+ *
+ * Copyright(c) 2013 - 2014 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110,
+ * USA
+ *
+ * The full GNU General Public License is included in this distribution
+ * in the file called COPYING.
+ *
+ * Contact Information:
+ *  Intel Linux Wireless <ilw@linux.intel.com>
+ * Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497
+ *
+ * BSD LICENSE
+ *
+ * Copyright(c) 2013 - 2014 Intel Corporation. All rights reserved.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *  * Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *  * Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *  * Neither the name Intel Corporation nor the names of its
+ *    contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *****************************************************************************/
+#ifndef __MVM_CONSTANTS_H
+#define __MVM_CONSTANTS_H
+
+#define IWL_MVM_DEFAULT_PS_TX_DATA_TIMEOUT (100 * USEC_PER_MSEC)
+#define IWL_MVM_DEFAULT_PS_RX_DATA_TIMEOUT (100 * USEC_PER_MSEC)
+#define IWL_MVM_WOWLAN_PS_TX_DATA_TIMEOUT (10 * USEC_PER_MSEC)
+#define IWL_MVM_WOWLAN_PS_RX_DATA_TIMEOUT (10 * USEC_PER_MSEC)
+#define IWL_MVM_UAPSD_RX_DATA_TIMEOUT  (50 * USEC_PER_MSEC)
+#define IWL_MVM_UAPSD_TX_DATA_TIMEOUT  (50 * USEC_PER_MSEC)
+#define IWL_MVM_PS_HEAVY_TX_THLD_PACKETS 20
+#define IWL_MVM_PS_HEAVY_RX_THLD_PACKETS 8
+#define IWL_MVM_PS_SNOOZE_HEAVY_TX_THLD_PACKETS 30
+#define IWL_MVM_PS_SNOOZE_HEAVY_RX_THLD_PACKETS 20
+#define IWL_MVM_PS_HEAVY_TX_THLD_PERCENT 50
+#define IWL_MVM_PS_HEAVY_RX_THLD_PERCENT 50
+#define IWL_MVM_PS_SNOOZE_INTERVAL  25
+#define IWL_MVM_PS_SNOOZE_WINDOW  50
+#define IWL_MVM_WOWLAN_PS_SNOOZE_WINDOW  25
+#define IWL_MVM_LOWLAT_QUOTA_MIN_PERCENT 64
+#define IWL_MVM_BT_COEX_SYNC2SCO  1
+#define IWL_MVM_BT_COEX_CORUNNING  1
+#define IWL_MVM_BT_COEX_MPLUT   1
+
+#endif /* __MVM_CONSTANTS_H */
diff --git a/drivers/net/wireless/iwlwifi/mvm/d3.c b/drivers/net/wireless/iwlwifi/mvm/d3.c
index 16bbdcc..645b3cf 100644
--- a/drivers/net/wireless/iwlwifi/mvm/d3.c
+++ b/drivers/net/wireless/iwlwifi/mvm/d3.c
@@ -5,7 +5,7 @@
  *
  * GPL LICENSE SUMMARY
  *
- * Copyright(c) 2012 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2012 - 2014 Intel Corporation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of version 2 of the GNU General Public License as
@@ -30,7 +30,7 @@
  *
  * BSD LICENSE
  *
- * Copyright(c) 2012 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2012 - 2014 Intel Corporation. All rights reserved.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -63,9 +63,11 @@
 
 #include <linux/etherdevice.h>
 #include <linux/ip.h>
+#include <linux/fs.h>
 #include <net/cfg80211.h>
 #include <net/ipv6.h>
 #include <net/tcp.h>
+#include <net/addrconf.h>
 #include "iwl-modparams.h"
 #include "fw-api.h"
 #include "mvm.h"
@@ -104,7 +106,7 @@ void iwl_mvm_ipv6_addr_change(struct ieee80211_hw *hw,
  list_for_each_entry(ifa, &idev->addr_list, if_list) {
   mvmvif->target_ipv6_addrs[idx] = ifa->addr;
   idx++;
-  if (idx >= IWL_PROTO_OFFLOAD_NUM_IPV6_ADDRS)
+  if (idx >= IWL_PROTO_OFFLOAD_NUM_IPV6_ADDRS_MAX)
    break;
  }
  read_unlock_bh(&idev->lock);
@@ -133,7 +135,7 @@ struct wowlan_key_data {
  struct iwl_wowlan_rsc_tsc_params_cmd *rsc_tsc;
  struct iwl_wowlan_tkip_params_cmd *tkip;
  bool error, use_rsc_tsc, use_tkip;
- int gtk_key_idx;
+ int wep_key_idx;
 };
 
 static void iwl_mvm_wowlan_program_keys(struct ieee80211_hw *hw,
@@ -187,12 +189,11 @@ static void iwl_mvm_wowlan_program_keys(struct ieee80211_hw *hw,
    wkc.wep_key.key_offset = 0;
   } else {
    /* others start at 1 */
-   data->gtk_key_idx++;
-   wkc.wep_key.key_offset = data->gtk_key_idx;
+   data->wep_key_idx++;
+   wkc.wep_key.key_offset = data->wep_key_idx;
   }
 
-  ret = iwl_mvm_send_cmd_pdu(mvm, WEP_KEY, CMD_SYNC,
-        sizeof(wkc), &wkc);
+  ret = iwl_mvm_send_cmd_pdu(mvm, WEP_KEY, 0, sizeof(wkc), &wkc);
   data->error = ret != 0;
 
   mvm->ptk_ivlen = key->iv_len;
@@ -315,8 +316,13 @@ static void iwl_mvm_wowlan_program_keys(struct ieee80211_hw *hw,
   mvm->ptk_ivlen = key->iv_len;
   mvm->ptk_icvlen = key->icv_len;
  } else {
-  data->gtk_key_idx++;
-  key->hw_key_idx = data->gtk_key_idx;
+  /*
+   * firmware only supports TSC/RSC for a single key,
+   * so if there are multiple keep overwriting them
+   * with new ones -- this relies on mac80211 doing
+   * list_add_tail().
+   */
+  key->hw_key_idx = 1;
   mvm->gtk_ivlen = key->iv_len;
   mvm->gtk_icvlen = key->icv_len;
  }
@@ -334,7 +340,6 @@ static int iwl_mvm_send_patterns(struct iwl_mvm *mvm,
  struct iwl_host_cmd cmd = {
   .id = WOWLAN_PATTERNS,
   .dataflags[0] = IWL_HCMD_DFL_NOCOPY,
-  .flags = CMD_SYNC,
  };
  int i, err;
 
@@ -369,41 +374,6 @@ static int iwl_mvm_send_patterns(struct iwl_mvm *mvm,
  return err;
 }
 
-static int iwl_mvm_send_proto_offload(struct iwl_mvm *mvm,
-          struct ieee80211_vif *vif)
-{
- struct iwl_proto_offload_cmd cmd = {};
-#if IS_ENABLED(CONFIG_IPV6)
- struct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);
- int i;
-
- if (mvmvif->num_target_ipv6_addrs) {
-  cmd.enabled |= cpu_to_le32(IWL_D3_PROTO_OFFLOAD_NS);
-  memcpy(cmd.ndp_mac_addr, vif->addr, ETH_ALEN);
- }
-
- BUILD_BUG_ON(sizeof(cmd.target_ipv6_addr[i]) !=
-       sizeof(mvmvif->target_ipv6_addrs[i]));
-
- for (i = 0; i < mvmvif->num_target_ipv6_addrs; i++)
-  memcpy(cmd.target_ipv6_addr[i],
-         &mvmvif->target_ipv6_addrs[i],
-         sizeof(cmd.target_ipv6_addr[i]));
-#endif
-
- if (vif->bss_conf.arp_addr_cnt) {
-  cmd.enabled |= cpu_to_le32(IWL_D3_PROTO_OFFLOAD_ARP);
-  cmd.host_ipv4_addr = vif->bss_conf.arp_addr_list[0];
-  memcpy(cmd.arp_mac_addr, vif->addr, ETH_ALEN);
- }
-
- if (!cmd.enabled)
-  return 0;
-
- return iwl_mvm_send_cmd_pdu(mvm, PROT_OFFLOAD_CONFIG_CMD, CMD_SYNC,
-        sizeof(cmd), &cmd);
-}
-
 enum iwl_mvm_tcp_packet_type {
  MVM_TCP_TX_SYN,
  MVM_TCP_RX_SYNACK,
@@ -419,8 +389,7 @@ static __le16 pseudo_hdr_check(int len, __be32 saddr, __be32 daddr)
  return cpu_to_le16(be16_to_cpu((__force __be16)check));
 }
 
-static void iwl_mvm_build_tcp_packet(struct iwl_mvm *mvm,
-         struct ieee80211_vif *vif,
+static void iwl_mvm_build_tcp_packet(struct ieee80211_vif *vif,
          struct cfg80211_wowlan_tcp *tcp,
          void *_pkt, u8 *mask,
          __le16 *pseudo_hdr_csum,
@@ -547,7 +516,6 @@ static int iwl_mvm_send_remote_wake_cfg(struct iwl_mvm *mvm,
   .id = REMOTE_WAKE_CONFIG_CMD,
   .len = { sizeof(*cfg), },
   .dataflags = { IWL_HCMD_DFL_NOCOPY, },
-  .flags = CMD_SYNC,
  };
  int ret;
 
@@ -566,21 +534,21 @@ static int iwl_mvm_send_remote_wake_cfg(struct iwl_mvm *mvm,
 
  /* SYN (TX) */
  iwl_mvm_build_tcp_packet(
-  mvm, vif, tcp, cfg->syn_tx.data, NULL,
+  vif, tcp, cfg->syn_tx.data, NULL,
   &cfg->syn_tx.info.tcp_pseudo_header_checksum,
   MVM_TCP_TX_SYN);
  cfg->syn_tx.info.tcp_payload_length = 0;
 
  /* SYN/ACK (RX) */
  iwl_mvm_build_tcp_packet(
-  mvm, vif, tcp, cfg->synack_rx.data, cfg->synack_rx.rx_mask,
+  vif, tcp, cfg->synack_rx.data, cfg->synack_rx.rx_mask,
   &cfg->synack_rx.info.tcp_pseudo_header_checksum,
   MVM_TCP_RX_SYNACK);
  cfg->synack_rx.info.tcp_payload_length = 0;
 
  /* KEEPALIVE/ACK (TX) */
  iwl_mvm_build_tcp_packet(
-  mvm, vif, tcp, cfg->keepalive_tx.data, NULL,
+  vif, tcp, cfg->keepalive_tx.data, NULL,
   &cfg->keepalive_tx.info.tcp_pseudo_header_checksum,
   MVM_TCP_TX_DATA);
  cfg->keepalive_tx.info.tcp_payload_length =
@@ -604,7 +572,7 @@ static int iwl_mvm_send_remote_wake_cfg(struct iwl_mvm *mvm,
 
  /* ACK (RX) */
  iwl_mvm_build_tcp_packet(
-  mvm, vif, tcp, cfg->keepalive_ack_rx.data,
+  vif, tcp, cfg->keepalive_ack_rx.data,
   cfg->keepalive_ack_rx.rx_mask,
   &cfg->keepalive_ack_rx.info.tcp_pseudo_header_checksum,
   MVM_TCP_RX_ACK);
@@ -612,7 +580,7 @@ static int iwl_mvm_send_remote_wake_cfg(struct iwl_mvm *mvm,
 
  /* WAKEUP (RX) */
  iwl_mvm_build_tcp_packet(
-  mvm, vif, tcp, cfg->wake_rx.data, cfg->wake_rx.rx_mask,
+  vif, tcp, cfg->wake_rx.data, cfg->wake_rx.rx_mask,
   &cfg->wake_rx.info.tcp_pseudo_header_checksum,
   MVM_TCP_RX_WAKE);
  cfg->wake_rx.info.tcp_payload_length =
@@ -620,7 +588,7 @@ static int iwl_mvm_send_remote_wake_cfg(struct iwl_mvm *mvm,
 
  /* FIN */
  iwl_mvm_build_tcp_packet(
-  mvm, vif, tcp, cfg->fin_tx.data, NULL,
+  vif, tcp, cfg->fin_tx.data, NULL,
   &cfg->fin_tx.info.tcp_pseudo_header_checksum,
   MVM_TCP_TX_FIN);
  cfg->fin_tx.info.tcp_payload_length = 0;
@@ -695,10 +663,8 @@ static int iwl_mvm_d3_reprogram(struct iwl_mvm *mvm, struct ieee80211_vif *vif,
 
  if (WARN_ON(!vif->bss_conf.assoc))
   return -EINVAL;
- /* hack */
- vif->bss_conf.assoc = false;
+
  ret = iwl_mvm_mac_ctxt_add(mvm, vif);
- vif->bss_conf.assoc = true;
  if (ret)
   return ret;
 
@@ -734,7 +700,7 @@ static int iwl_mvm_d3_reprogram(struct iwl_mvm *mvm, struct ieee80211_vif *vif,
   return ret;
  rcu_assign_pointer(mvm->fw_id_to_mac_id[mvmvif->ap_sta_id], ap_sta);
 
- ret = iwl_mvm_mac_ctxt_changed(mvm, vif);
+ ret = iwl_mvm_mac_ctxt_changed(mvm, vif, false);
  if (ret)
   return ret;
 
@@ -742,13 +708,13 @@ static int iwl_mvm_d3_reprogram(struct iwl_mvm *mvm, struct ieee80211_vif *vif,
  quota_cmd.quotas[0].id_and_color =
   cpu_to_le32(FW_CMD_ID_AND_COLOR(mvmvif->phy_ctxt->id,
       mvmvif->phy_ctxt->color));
- quota_cmd.quotas[0].quota = cpu_to_le32(100);
- quota_cmd.quotas[0].max_duration = cpu_to_le32(1000);
+ quota_cmd.quotas[0].quota = cpu_to_le32(IWL_MVM_MAX_QUOTA);
+ quota_cmd.quotas[0].max_duration = cpu_to_le32(IWL_MVM_MAX_QUOTA);
 
  for (i = 1; i < MAX_BINDINGS; i++)
   quota_cmd.quotas[i].id_and_color = cpu_to_le32(FW_CTXT_INVALID);
 
- ret = iwl_mvm_send_cmd_pdu(mvm, TIME_QUOTA_CMD, CMD_SYNC,
+ ret = iwl_mvm_send_cmd_pdu(mvm, TIME_QUOTA_CMD, 0,
        sizeof(quota_cmd), &quota_cmd);
  if (ret)
   IWL_ERR(mvm, "Failed to send quota: %d\n", ret);
@@ -756,7 +722,82 @@ static int iwl_mvm_d3_reprogram(struct iwl_mvm *mvm, struct ieee80211_vif *vif,
  return 0;
 }
 
-int iwl_mvm_suspend(struct ieee80211_hw *hw, struct cfg80211_wowlan *wowlan)
+static int iwl_mvm_get_last_nonqos_seq(struct iwl_mvm *mvm,
+           struct ieee80211_vif *vif)
+{
+ struct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);
+ struct iwl_nonqos_seq_query_cmd query_cmd = {
+  .get_set_flag = cpu_to_le32(IWL_NONQOS_SEQ_GET),
+  .mac_id_n_color =
+   cpu_to_le32(FW_CMD_ID_AND_COLOR(mvmvif->id,
+       mvmvif->color)),
+ };
+ struct iwl_host_cmd cmd = {
+  .id = NON_QOS_TX_COUNTER_CMD,
+  .flags = CMD_WANT_SKB,
+ };
+ int err;
+ u32 size;
+
+ cmd.data[0] = &query_cmd;
+ cmd.len[0] = sizeof(query_cmd);
+
+ err = iwl_mvm_send_cmd(mvm, &cmd);
+ if (err)
+  return err;
+
+ size = iwl_rx_packet_payload_len(cmd.resp_pkt);
+ if (size < sizeof(__le16)) {
+  err = -EINVAL;
+ } else {
+  err = le16_to_cpup((__le16 *)cmd.resp_pkt->data);
+  /* firmware returns next, not last-used seqno */
+  err = (u16) (err - 0x10);
+ }
+
+ iwl_free_resp(&cmd);
+ return err;
+}
+
+void iwl_mvm_set_last_nonqos_seq(struct iwl_mvm *mvm, struct ieee80211_vif *vif)
+{
+ struct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);
+ struct iwl_nonqos_seq_query_cmd query_cmd = {
+  .get_set_flag = cpu_to_le32(IWL_NONQOS_SEQ_SET),
+  .mac_id_n_color =
+   cpu_to_le32(FW_CMD_ID_AND_COLOR(mvmvif->id,
+       mvmvif->color)),
+  .value = cpu_to_le16(mvmvif->seqno),
+ };
+
+ /* return if called during restart, not resume from D3 */
+ if (!mvmvif->seqno_valid)
+  return;
+
+ mvmvif->seqno_valid = false;
+
+ if (iwl_mvm_send_cmd_pdu(mvm, NON_QOS_TX_COUNTER_CMD, 0,
+     sizeof(query_cmd), &query_cmd))
+  IWL_ERR(mvm, "failed to set non-QoS seqno\n");
+}
+
+static int
+iwl_mvm_send_wowlan_config_cmd(struct iwl_mvm *mvm,
+          const struct iwl_wowlan_config_cmd_v3 *cmd)
+{
+ /* start only with the v2 part of the command */
+ u16 cmd_len = sizeof(cmd->common);
+
+ if (mvm->fw->ucode_capa.api[0] & IWL_UCODE_TLV_API_WOWLAN_CONFIG_TID)
+  cmd_len = sizeof(*cmd);
+
+ return iwl_mvm_send_cmd_pdu(mvm, WOWLAN_CONFIGURATION, 0,
+        cmd_len, cmd);
+}
+
+static int __iwl_mvm_suspend(struct ieee80211_hw *hw,
+        struct cfg80211_wowlan *wowlan,
+        bool test)
 {
  struct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);
  struct iwl_d3_iter_data suspend_iter_data = {
@@ -766,10 +807,10 @@ int iwl_mvm_suspend(struct ieee80211_hw *hw, struct cfg80211_wowlan *wowlan)
  struct iwl_mvm_vif *mvmvif;
  struct ieee80211_sta *ap_sta;
  struct iwl_mvm_sta *mvm_ap_sta;
- struct iwl_wowlan_config_cmd wowlan_config_cmd = {};
+ struct iwl_wowlan_config_cmd_v3 wowlan_config_cmd = {};
  struct iwl_wowlan_kek_kck_material_cmd kek_kck_cmd = {};
  struct iwl_wowlan_tkip_params_cmd tkip_cmd = {};
- struct iwl_d3_manager_config d3_cfg_cmd = {
+ struct iwl_d3_manager_config d3_cfg_cmd_data = {
   /*
    * Program the minimum sleep time to 10 seconds, as many
    * platforms have issues processing a wakeup signal while
@@ -777,17 +818,28 @@ int iwl_mvm_suspend(struct ieee80211_hw *hw, struct cfg80211_wowlan *wowlan)
    */
   .min_sleep_time = cpu_to_le32(10 * 1000 * 1000),
  };
+ struct iwl_host_cmd d3_cfg_cmd = {
+  .id = D3_CONFIG_CMD,
+  .flags = CMD_WANT_SKB,
+  .data[0] = &d3_cfg_cmd_data,
+  .len[0] = sizeof(d3_cfg_cmd_data),
+ };
  struct wowlan_key_data key_data = {
   .use_rsc_tsc = false,
   .tkip = &tkip_cmd,
   .use_tkip = false,
  };
- int ret, i;
- u16 seq;
- u8 old_aux_sta_id, old_ap_sta_id = IWL_MVM_STATION_COUNT;
+ int ret;
+ int len __maybe_unused;
 
- if (WARN_ON(!wowlan))
+ if (!wowlan) {
+  /*
+   * mac80211 shouldn't get here, but for D3 test
+   * it doesn't warrant a warning
+   */
+  WARN_ON(!test);
   return -EINVAL;
+ }
 
  key_data.rsc_tsc = kzalloc(sizeof(*key_data.rsc_tsc), GFP_KERNEL);
  if (!key_data.rsc_tsc)
@@ -795,8 +847,6 @@ int iwl_mvm_suspend(struct ieee80211_hw *hw, struct cfg80211_wowlan *wowlan)
 
  mutex_lock(&mvm->mutex);
 
- old_aux_sta_id = mvm->aux_sta.sta_id;
-
  /* see if there's only a single BSS vif and it's associated */
  ieee80211_iterate_active_interfaces_atomic(
   mvm->hw, IEEE80211_IFACE_ITER_NORMAL,
@@ -820,60 +870,41 @@ int iwl_mvm_suspend(struct ieee80211_hw *hw, struct cfg80211_wowlan *wowlan)
 
  mvm_ap_sta = (struct iwl_mvm_sta *)ap_sta->drv_priv;
 
- /*
-  * The D3 firmware still hardcodes the AP station ID for the
-  * BSS we're associated with as 0. Store the real STA ID here
-  * and assign 0. When we leave this function, we'll restore
-  * the original value for the resume code.
-  */
- old_ap_sta_id = mvm_ap_sta->sta_id;
- mvm_ap_sta->sta_id = 0;
- mvmvif->ap_sta_id = 0;
-
- /* TODO: wowlan_config_cmd.wowlan_ba_teardown_tids */
+ /* TODO: wowlan_config_cmd.common.wowlan_ba_teardown_tids */
 
- wowlan_config_cmd.is_11n_connection = ap_sta->ht_cap.ht_supported;
+ wowlan_config_cmd.common.is_11n_connection =
+     ap_sta->ht_cap.ht_supported;
 
- /*
-  * We know the last used seqno, and the uCode expects to know that
-  * one, it will increment before TX.
-  */
- seq = mvm_ap_sta->last_seq_ctl & IEEE80211_SCTL_SEQ;
- wowlan_config_cmd.non_qos_seq = cpu_to_le16(seq);
+ /* Query the last used seqno and set it */
+ ret = iwl_mvm_get_last_nonqos_seq(mvm, vif);
+ if (ret < 0)
+  goto out_noreset;
+ wowlan_config_cmd.common.non_qos_seq = cpu_to_le16(ret);
 
- /*
-  * For QoS counters, we store the one to use next, so subtract 0x10
-  * since the uCode will add 0x10 *before* using the value while we
-  * increment after using the value (i.e. store the next value to use).
-  */
- for (i = 0; i < IWL_MAX_TID_COUNT; i++) {
-  seq = mvm_ap_sta->tid_data[i].seq_number;
-  seq -= 0x10;
-  wowlan_config_cmd.qos_seq[i] = cpu_to_le16(seq);
- }
+ iwl_mvm_set_wowlan_qos_seq(mvm_ap_sta, &wowlan_config_cmd.common);
 
  if (wowlan->disconnect)
-  wowlan_config_cmd.wakeup_filter |=
+  wowlan_config_cmd.common.wakeup_filter |=
    cpu_to_le32(IWL_WOWLAN_WAKEUP_BEACON_MISS |
         IWL_WOWLAN_WAKEUP_LINK_CHANGE);
  if (wowlan->magic_pkt)
-  wowlan_config_cmd.wakeup_filter |=
+  wowlan_config_cmd.common.wakeup_filter |=
    cpu_to_le32(IWL_WOWLAN_WAKEUP_MAGIC_PACKET);
  if (wowlan->gtk_rekey_failure)
-  wowlan_config_cmd.wakeup_filter |=
+  wowlan_config_cmd.common.wakeup_filter |=
    cpu_to_le32(IWL_WOWLAN_WAKEUP_GTK_REKEY_FAIL);
  if (wowlan->eap_identity_req)
-  wowlan_config_cmd.wakeup_filter |=
+  wowlan_config_cmd.common.wakeup_filter |=
    cpu_to_le32(IWL_WOWLAN_WAKEUP_EAP_IDENT_REQ);
  if (wowlan->four_way_handshake)
-  wowlan_config_cmd.wakeup_filter |=
+  wowlan_config_cmd.common.wakeup_filter |=
    cpu_to_le32(IWL_WOWLAN_WAKEUP_4WAY_HANDSHAKE);
  if (wowlan->n_patterns)
-  wowlan_config_cmd.wakeup_filter |=
+  wowlan_config_cmd.common.wakeup_filter |=
    cpu_to_le32(IWL_WOWLAN_WAKEUP_PATTERN_MATCH);
 
  if (wowlan->rfkill_release)
-  wowlan_config_cmd.wakeup_filter |=
+  wowlan_config_cmd.common.wakeup_filter |=
    cpu_to_le32(IWL_WOWLAN_WAKEUP_RF_KILL_DEASSERT);
 
  if (wowlan->tcp) {
@@ -881,7 +912,7 @@ int iwl_mvm_suspend(struct ieee80211_hw *hw, struct cfg80211_wowlan *wowlan)
    * Set the "link change" (really "link lost") flag as well
    * since that implies losing the TCP connection.
    */
-  wowlan_config_cmd.wakeup_filter |=
+  wowlan_config_cmd.common.wakeup_filter |=
    cpu_to_le32(IWL_WOWLAN_WAKEUP_REMOTE_LINK_LOSS |
         IWL_WOWLAN_WAKEUP_REMOTE_SIGNATURE_TABLE |
         IWL_WOWLAN_WAKEUP_REMOTE_WAKEUP_PACKET |
@@ -912,16 +943,6 @@ int iwl_mvm_suspend(struct ieee80211_hw *hw, struct cfg80211_wowlan *wowlan)
  mvm->ptk_ivlen = 0;
  mvm->ptk_icvlen = 0;
 
- /*
-  * The D3 firmware still hardcodes the AP station ID for the
-  * BSS we're associated with as 0. As a result, we have to move
-  * the auxiliary station to ID 1 so the ID 0 remains free for
-  * the AP station for later.
-  * We set the sta_id to 1 here, and reset it to its previous
-  * value (that we stored above) later.
-  */
- mvm->aux_sta.sta_id = 1;
-
  ret = iwl_mvm_load_d3_fw(mvm);
  if (ret)
   goto out;
@@ -949,7 +970,6 @@ int iwl_mvm_suspend(struct ieee80211_hw *hw, struct cfg80211_wowlan *wowlan)
   if (key_data.use_rsc_tsc) {
    struct iwl_host_cmd rsc_tsc_cmd = {
     .id = WOWLAN_TSC_RSC_PARAM,
-    .flags = CMD_SYNC,
     .data[0] = key_data.rsc_tsc,
     .dataflags[0] = IWL_HCMD_DFL_NOCOPY,
     .len[0] = sizeof(*key_data.rsc_tsc),
@@ -963,7 +983,7 @@ int iwl_mvm_suspend(struct ieee80211_hw *hw, struct cfg80211_wowlan *wowlan)
   if (key_data.use_tkip) {
    ret = iwl_mvm_send_cmd_pdu(mvm,
          WOWLAN_TKIP_PARAM,
-         CMD_SYNC, sizeof(tkip_cmd),
+         0, sizeof(tkip_cmd),
          &tkip_cmd);
    if (ret)
     goto out;
@@ -980,8 +1000,7 @@ int iwl_mvm_suspend(struct ieee80211_hw *hw, struct cfg80211_wowlan *wowlan)
    kek_kck_cmd.replay_ctr = mvmvif->rekey_data.replay_ctr;
 
    ret = iwl_mvm_send_cmd_pdu(mvm,
-         WOWLAN_KEK_KCK_MATERIAL,
-         CMD_SYNC,
+         WOWLAN_KEK_KCK_MATERIAL, 0,
          sizeof(kek_kck_cmd),
          &kek_kck_cmd);
    if (ret)
@@ -989,9 +1008,7 @@ int iwl_mvm_suspend(struct ieee80211_hw *hw, struct cfg80211_wowlan *wowlan)
   }
  }
 
- ret = iwl_mvm_send_cmd_pdu(mvm, WOWLAN_CONFIGURATION,
-       CMD_SYNC, sizeof(wowlan_config_cmd),
-       &wowlan_config_cmd);
+ ret = iwl_mvm_send_wowlan_config_cmd(mvm, &wowlan_config_cmd);
  if (ret)
   goto out;
 
@@ -999,7 +1016,7 @@ int iwl_mvm_suspend(struct ieee80211_hw *hw, struct cfg80211_wowlan *wowlan)
  if (ret)
   goto out;
 
- ret = iwl_mvm_send_proto_offload(mvm, vif);
+ ret = iwl_mvm_send_proto_offload(mvm, vif, false, 0);
  if (ret)
   goto out;
 
@@ -1007,96 +1024,81 @@ int iwl_mvm_suspend(struct ieee80211_hw *hw, struct cfg80211_wowlan *wowlan)
  if (ret)
   goto out;
 
+ ret = iwl_mvm_power_update_device(mvm);
+ if (ret)
+  goto out;
+
+ ret = iwl_mvm_power_update_mac(mvm);
+ if (ret)
+  goto out;
+
+#ifdef CONFIG_IWLWIFI_DEBUGFS
+ if (mvm->d3_wake_sysassert)
+  d3_cfg_cmd_data.wakeup_flags |=
+   cpu_to_le32(IWL_WAKEUP_D3_CONFIG_FW_ERROR);
+#endif
+
  /* must be last -- this switches firmware state */
- ret = iwl_mvm_send_cmd_pdu(mvm, D3_CONFIG_CMD, CMD_SYNC,
-       sizeof(d3_cfg_cmd), &d3_cfg_cmd);
+ ret = iwl_mvm_send_cmd(mvm, &d3_cfg_cmd);
  if (ret)
   goto out;
+#ifdef CONFIG_IWLWIFI_DEBUGFS
+ len = iwl_rx_packet_payload_len(d3_cfg_cmd.resp_pkt);
+ if (len >= sizeof(u32)) {
+  mvm->d3_test_pme_ptr =
+   le32_to_cpup((__le32 *)d3_cfg_cmd.resp_pkt->data);
+ }
+#endif
+ iwl_free_resp(&d3_cfg_cmd);
 
  clear_bit(IWL_MVM_STATUS_IN_HW_RESTART, &mvm->status);
 
- iwl_trans_d3_suspend(mvm->trans);
+ iwl_trans_d3_suspend(mvm->trans, test);
  out:
- mvm->aux_sta.sta_id = old_aux_sta_id;
- mvm_ap_sta->sta_id = old_ap_sta_id;
- mvmvif->ap_sta_id = old_ap_sta_id;
- out_noreset:
- kfree(key_data.rsc_tsc);
  if (ret < 0)
   ieee80211_restart_hw(mvm->hw);
+ out_noreset:
+ kfree(key_data.rsc_tsc);
 
  mutex_unlock(&mvm->mutex);
 
  return ret;
 }
 
-static void iwl_mvm_query_wakeup_reasons(struct iwl_mvm *mvm,
-      struct ieee80211_vif *vif)
+int iwl_mvm_suspend(struct ieee80211_hw *hw, struct cfg80211_wowlan *wowlan)
 {
- u32 base = mvm->error_event_table;
- struct error_table_start {
-  /* cf. struct iwl_error_event_table */
-  u32 valid;
-  u32 error_id;
- } err_info;
- struct cfg80211_wowlan_wakeup wakeup = {
-  .pattern_idx = -1,
- };
- struct cfg80211_wowlan_wakeup *wakeup_report = &wakeup;
- struct iwl_host_cmd cmd = {
-  .id = WOWLAN_GET_STATUSES,
-  .flags = CMD_SYNC | CMD_WANT_SKB,
- };
- struct iwl_wowlan_status *status;
- u32 reasons;
- int ret, len;
- struct sk_buff *pkt = NULL;
-
- iwl_trans_read_mem_bytes(mvm->trans, base,
-     &err_info, sizeof(err_info));
-
- if (err_info.valid) {
-  IWL_INFO(mvm, "error table is valid (%d)\n",
-    err_info.valid);
-  if (err_info.error_id == RF_KILL_INDICATOR_FOR_WOWLAN) {
-   wakeup.rfkill_release = true;
-   ieee80211_report_wowlan_wakeup(vif, &wakeup,
-             GFP_KERNEL);
-  }
-  return;
- }
-
- /* only for tracing for now */
- ret = iwl_mvm_send_cmd_pdu(mvm, OFFLOADS_QUERY_CMD, CMD_SYNC, 0, NULL);
- if (ret)
-  IWL_ERR(mvm, "failed to query offload statistics (%d)\n", ret);
-
- ret = iwl_mvm_send_cmd(mvm, &cmd);
- if (ret) {
-  IWL_ERR(mvm, "failed to query status (%d)\n", ret);
-  return;
- }
-
- /* RF-kill already asserted again... */
- if (!cmd.resp_pkt)
-  return;
+ struct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);
 
- len = le32_to_cpu(cmd.resp_pkt->len_n_flags) & FH_RSCSR_FRAME_SIZE_MSK;
- if (len - sizeof(struct iwl_cmd_header) < sizeof(*status)) {
-  IWL_ERR(mvm, "Invalid WoWLAN status response!\n");
-  goto out;
+ if (iwl_mvm_is_d0i3_supported(mvm)) {
+  mutex_lock(&mvm->d0i3_suspend_mutex);
+  __set_bit(D0I3_DEFER_WAKEUP, &mvm->d0i3_suspend_flags);
+  mutex_unlock(&mvm->d0i3_suspend_mutex);
+  return 0;
  }
 
- status = (void *)cmd.resp_pkt->data;
+ return __iwl_mvm_suspend(hw, wowlan, false);
+}
 
- if (len - sizeof(struct iwl_cmd_header) !=
-     sizeof(*status) +
-     ALIGN(le32_to_cpu(status->wake_packet_bufsize), 4)) {
-  IWL_ERR(mvm, "Invalid WoWLAN status response!\n");
-  goto out;
- }
+/* converted data from the different status responses */
+struct iwl_wowlan_status_data {
+ u16 pattern_number;
+ u16 qos_seq_ctr[8];
+ u32 wakeup_reasons;
+ u32 wake_packet_length;
+ u32 wake_packet_bufsize;
+ const u8 *wake_packet;
+};
 
- reasons = le32_to_cpu(status->wakeup_reasons);
+static void iwl_mvm_report_wakeup_reasons(struct iwl_mvm *mvm,
+       struct ieee80211_vif *vif,
+       struct iwl_wowlan_status_data *status)
+{
+ struct sk_buff *pkt = NULL;
+ struct cfg80211_wowlan_wakeup wakeup = {
+  .pattern_idx = -1,
+ };
+ struct cfg80211_wowlan_wakeup *wakeup_report = &wakeup;
+ u32 reasons = status->wakeup_reasons;
 
  if (reasons == IWL_WOWLAN_WAKEUP_BY_NON_WIRELESS) {
   wakeup_report = NULL;
@@ -1108,7 +1110,7 @@ static void iwl_mvm_query_wakeup_reasons(struct iwl_mvm *mvm,
 
  if (reasons & IWL_WOWLAN_WAKEUP_BY_PATTERN)
   wakeup.pattern_idx =
-   le16_to_cpu(status->pattern_number);
+   status->pattern_number;
 
  if (reasons & (IWL_WOWLAN_WAKEUP_BY_DISCONNECTION_ON_MISSED_BEACON |
          IWL_WOWLAN_WAKEUP_BY_DISCONNECTION_ON_DEAUTH))
@@ -1136,8 +1138,8 @@ static void iwl_mvm_query_wakeup_reasons(struct iwl_mvm *mvm,
   wakeup.tcp_match = true;
 
  if (status->wake_packet_bufsize) {
-  int pktsize = le32_to_cpu(status->wake_packet_bufsize);
-  int pktlen = le32_to_cpu(status->wake_packet_length);
+  int pktsize = status->wake_packet_bufsize;
+  int pktlen = status->wake_packet_length;
   const u8 *pktdata = status->wake_packet;
   struct ieee80211_hdr *hdr = (void *)pktdata;
   int truncated = pktlen - pktsize;
@@ -1159,6 +1161,12 @@ static void iwl_mvm_query_wakeup_reasons(struct iwl_mvm *mvm,
    pktsize -= hdrlen;
 
    if (ieee80211_has_protected(hdr->frame_control)) {
+    /*
+     * This is unlocked and using gtk_i(c)vlen,
+     * but since everything is under RTNL still
+     * that's not really a problem - changing
+     * it would be difficult.
+     */
     if (is_multicast_ether_addr(hdr->addr1)) {
      ivlen = mvm->gtk_ivlen;
      icvlen += mvm->gtk_icvlen;
@@ -1209,20 +1217,386 @@ static void iwl_mvm_query_wakeup_reasons(struct iwl_mvm *mvm,
  report:
  ieee80211_report_wowlan_wakeup(vif, wakeup_report, GFP_KERNEL);
  kfree_skb(pkt);
+}
+
+static void iwl_mvm_aes_sc_to_seq(struct aes_sc *sc,
+      struct ieee80211_key_seq *seq)
+{
+ u64 pn;
+
+ pn = le64_to_cpu(sc->pn);
+ seq->ccmp.pn[0] = pn >> 40;
+ seq->ccmp.pn[1] = pn >> 32;
+ seq->ccmp.pn[2] = pn >> 24;
+ seq->ccmp.pn[3] = pn >> 16;
+ seq->ccmp.pn[4] = pn >> 8;
+ seq->ccmp.pn[5] = pn;
+}
+
+static void iwl_mvm_tkip_sc_to_seq(struct tkip_sc *sc,
+       struct ieee80211_key_seq *seq)
+{
+ seq->tkip.iv32 = le32_to_cpu(sc->iv32);
+ seq->tkip.iv16 = le16_to_cpu(sc->iv16);
+}
+
+static void iwl_mvm_set_aes_rx_seq(struct aes_sc *scs,
+       struct ieee80211_key_conf *key)
+{
+ int tid;
+
+ BUILD_BUG_ON(IWL_NUM_RSC != IEEE80211_NUM_TIDS);
+
+ for (tid = 0; tid < IWL_NUM_RSC; tid++) {
+  struct ieee80211_key_seq seq = {};
+
+  iwl_mvm_aes_sc_to_seq(&scs[tid], &seq);
+  ieee80211_set_key_rx_seq(key, tid, &seq);
+ }
+}
+
+static void iwl_mvm_set_tkip_rx_seq(struct tkip_sc *scs,
+        struct ieee80211_key_conf *key)
+{
+ int tid;
+
+ BUILD_BUG_ON(IWL_NUM_RSC != IEEE80211_NUM_TIDS);
+
+ for (tid = 0; tid < IWL_NUM_RSC; tid++) {
+  struct ieee80211_key_seq seq = {};
+
+  iwl_mvm_tkip_sc_to_seq(&scs[tid], &seq);
+  ieee80211_set_key_rx_seq(key, tid, &seq);
+ }
+}
+
+static void iwl_mvm_set_key_rx_seq(struct ieee80211_key_conf *key,
+       struct iwl_wowlan_status *status)
+{
+ union iwl_all_tsc_rsc *rsc = &status->gtk.rsc.all_tsc_rsc;
+
+ switch (key->cipher) {
+ case WLAN_CIPHER_SUITE_CCMP:
+  iwl_mvm_set_aes_rx_seq(rsc->aes.multicast_rsc, key);
+  break;
+ case WLAN_CIPHER_SUITE_TKIP:
+  iwl_mvm_set_tkip_rx_seq(rsc->tkip.multicast_rsc, key);
+  break;
+ default:
+  WARN_ON(1);
+ }
+}
+
+struct iwl_mvm_d3_gtk_iter_data {
+ struct iwl_wowlan_status *status;
+ void *last_gtk;
+ u32 cipher;
+ bool find_phase, unhandled_cipher;
+ int num_keys;
+};
+
+static void iwl_mvm_d3_update_gtks(struct ieee80211_hw *hw,
+       struct ieee80211_vif *vif,
+       struct ieee80211_sta *sta,
+       struct ieee80211_key_conf *key,
+       void *_data)
+{
+ struct iwl_mvm_d3_gtk_iter_data *data = _data;
+
+ if (data->unhandled_cipher)
+  return;
+
+ switch (key->cipher) {
+ case WLAN_CIPHER_SUITE_WEP40:
+ case WLAN_CIPHER_SUITE_WEP104:
+  /* ignore WEP completely, nothing to do */
+  return;
+ case WLAN_CIPHER_SUITE_CCMP:
+ case WLAN_CIPHER_SUITE_TKIP:
+  /* we support these */
+  break;
+ default:
+  /* everything else (even CMAC for MFP) - disconnect from AP */
+  data->unhandled_cipher = true;
+  return;
+ }
+
+ data->num_keys++;
+
+ /*
+  * pairwise key - update sequence counters only;
+  * note that this assumes no TDLS sessions are active
+  */
+ if (sta) {
+  struct ieee80211_key_seq seq = {};
+  union iwl_all_tsc_rsc *sc = &data->status->gtk.rsc.all_tsc_rsc;
+
+  if (data->find_phase)
+   return;
+
+  switch (key->cipher) {
+  case WLAN_CIPHER_SUITE_CCMP:
+   iwl_mvm_aes_sc_to_seq(&sc->aes.tsc, &seq);
+   iwl_mvm_set_aes_rx_seq(sc->aes.unicast_rsc, key);
+   break;
+  case WLAN_CIPHER_SUITE_TKIP:
+   iwl_mvm_tkip_sc_to_seq(&sc->tkip.tsc, &seq);
+   iwl_mvm_set_tkip_rx_seq(sc->tkip.unicast_rsc, key);
+   break;
+  }
+  ieee80211_set_key_tx_seq(key, &seq);
+
+  /* that's it for this key */
+  return;
+ }
+
+ if (data->find_phase) {
+  data->last_gtk = key;
+  data->cipher = key->cipher;
+  return;
+ }
+
+ if (data->status->num_of_gtk_rekeys)
+  ieee80211_remove_key(key);
+ else if (data->last_gtk == key)
+  iwl_mvm_set_key_rx_seq(key, data->status);
+}
+
+static bool iwl_mvm_setup_connection_keep(struct iwl_mvm *mvm,
+       struct ieee80211_vif *vif,
+       struct iwl_wowlan_status *status)
+{
+ struct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);
+ struct iwl_mvm_d3_gtk_iter_data gtkdata = {
+  .status = status,
+ };
+ u32 disconnection_reasons =
+  IWL_WOWLAN_WAKEUP_BY_DISCONNECTION_ON_MISSED_BEACON |
+  IWL_WOWLAN_WAKEUP_BY_DISCONNECTION_ON_DEAUTH;
+
+ if (!status || !vif->bss_conf.bssid)
+  return false;
+
+ if (le32_to_cpu(status->wakeup_reasons) & disconnection_reasons)
+  return false;
+
+ /* find last GTK that we used initially, if any */
+ gtkdata.find_phase = true;
+ ieee80211_iter_keys(mvm->hw, vif,
+       iwl_mvm_d3_update_gtks, &gtkdata);
+ /* not trying to keep connections with MFP/unhandled ciphers */
+ if (gtkdata.unhandled_cipher)
+  return false;
+ if (!gtkdata.num_keys)
+  goto out;
+ if (!gtkdata.last_gtk)
+  return false;
+
+ /*
+  * invalidate all other GTKs that might still exist and update
+  * the one that we used
+  */
+ gtkdata.find_phase = false;
+ ieee80211_iter_keys(mvm->hw, vif,
+       iwl_mvm_d3_update_gtks, &gtkdata);
+
+ if (status->num_of_gtk_rekeys) {
+  struct ieee80211_key_conf *key;
+  struct {
+   struct ieee80211_key_conf conf;
+   u8 key[32];
+  } conf = {
+   .conf.cipher = gtkdata.cipher,
+   .conf.keyidx = status->gtk.key_index,
+  };
+
+  switch (gtkdata.cipher) {
+  case WLAN_CIPHER_SUITE_CCMP:
+   conf.conf.keylen = WLAN_KEY_LEN_CCMP;
+   memcpy(conf.conf.key, status->gtk.decrypt_key,
+          WLAN_KEY_LEN_CCMP);
+   break;
+  case WLAN_CIPHER_SUITE_TKIP:
+   conf.conf.keylen = WLAN_KEY_LEN_TKIP;
+   memcpy(conf.conf.key, status->gtk.decrypt_key, 16);
+   /* leave TX MIC key zeroed, we don't use it anyway */
+   memcpy(conf.conf.key +
+          NL80211_TKIP_DATA_OFFSET_RX_MIC_KEY,
+          status->gtk.tkip_mic_key, 8);
+   break;
+  }
+
+  key = ieee80211_gtk_rekey_add(vif, &conf.conf);
+  if (IS_ERR(key))
+   return false;
+  iwl_mvm_set_key_rx_seq(key, status);
+ }
+
+ if (status->num_of_gtk_rekeys) {
+  __be64 replay_ctr =
+   cpu_to_be64(le64_to_cpu(status->replay_ctr));
+  ieee80211_gtk_rekey_notify(vif, vif->bss_conf.bssid,
+        (void *)&replay_ctr, GFP_KERNEL);
+ }
+
+out:
+ mvmvif->seqno_valid = true;
+ /* +0x10 because the set API expects next-to-use, not last-used */
+ mvmvif->seqno = le16_to_cpu(status->non_qos_seq_ctr) + 0x10;
+
+ return true;
+}
+
+/* releases the MVM mutex */
+static bool iwl_mvm_query_wakeup_reasons(struct iwl_mvm *mvm,
+      struct ieee80211_vif *vif)
+{
+ u32 base = mvm->error_event_table;
+ struct error_table_start {
+  /* cf. struct iwl_error_event_table */
+  u32 valid;
+  u32 error_id;
+ } err_info;
+ struct iwl_host_cmd cmd = {
+  .id = WOWLAN_GET_STATUSES,
+  .flags = CMD_WANT_SKB,
+ };
+ struct iwl_wowlan_status_data status;
+ struct iwl_wowlan_status *fw_status;
+ int ret, len, status_size, i;
+ bool keep;
+ struct ieee80211_sta *ap_sta;
+ struct iwl_mvm_sta *mvm_ap_sta;
+
+ iwl_trans_read_mem_bytes(mvm->trans, base,
+     &err_info, sizeof(err_info));
+
+ if (err_info.valid) {
+  IWL_INFO(mvm, "error table is valid (%d)\n",
+    err_info.valid);
+  if (err_info.error_id == RF_KILL_INDICATOR_FOR_WOWLAN) {
+   struct cfg80211_wowlan_wakeup wakeup = {
+    .rfkill_release = true,
+   };
+   ieee80211_report_wowlan_wakeup(vif, &wakeup,
+             GFP_KERNEL);
+  }
+  goto out_unlock;
+ }
+
+ /* only for tracing for now */
+ ret = iwl_mvm_send_cmd_pdu(mvm, OFFLOADS_QUERY_CMD, 0, 0, NULL);
+ if (ret)
+  IWL_ERR(mvm, "failed to query offload statistics (%d)\n", ret);
+
+ ret = iwl_mvm_send_cmd(mvm, &cmd);
+ if (ret) {
+  IWL_ERR(mvm, "failed to query status (%d)\n", ret);
+  goto out_unlock;
+ }
+
+ /* RF-kill already asserted again... */
+ if (!cmd.resp_pkt)
+  goto out_unlock;
+
+ status_size = sizeof(*fw_status);
+
+ len = iwl_rx_packet_payload_len(cmd.resp_pkt);
+ if (len < status_size) {
+  IWL_ERR(mvm, "Invalid WoWLAN status response!\n");
+  goto out_free_resp;
+ }
+
+ fw_status = (void *)cmd.resp_pkt->data;
+
+ status.pattern_number = le16_to_cpu(fw_status->pattern_number);
+ for (i = 0; i < 8; i++)
+  status.qos_seq_ctr[i] =
+   le16_to_cpu(fw_status->qos_seq_ctr[i]);
+ status.wakeup_reasons = le32_to_cpu(fw_status->wakeup_reasons);
+ status.wake_packet_length =
+  le32_to_cpu(fw_status->wake_packet_length);
+ status.wake_packet_bufsize =
+  le32_to_cpu(fw_status->wake_packet_bufsize);
+ status.wake_packet = fw_status->wake_packet;
+
+ if (len != status_size + ALIGN(status.wake_packet_bufsize, 4)) {
+  IWL_ERR(mvm, "Invalid WoWLAN status response!\n");
+  goto out_free_resp;
+ }
+
+ /* still at hard-coded place 0 for D3 image */
+ ap_sta = rcu_dereference_protected(
+   mvm->fw_id_to_mac_id[0],
+   lockdep_is_held(&mvm->mutex));
+ if (IS_ERR_OR_NULL(ap_sta))
+  goto out_free_resp;
+
+ mvm_ap_sta = (struct iwl_mvm_sta *)ap_sta->drv_priv;
+ for (i = 0; i < IWL_MAX_TID_COUNT; i++) {
+  u16 seq = status.qos_seq_ctr[i];
+  /* firmware stores last-used value, we store next value */
+  seq += 0x10;
+  mvm_ap_sta->tid_data[i].seq_number = seq;
+ }
+
+ /* now we have all the data we need, unlock to avoid mac80211 issues */
+ mutex_unlock(&mvm->mutex);
+
+ iwl_mvm_report_wakeup_reasons(mvm, vif, &status);
+
+ keep = iwl_mvm_setup_connection_keep(mvm, vif, fw_status);
 
- out:
  iwl_free_resp(&cmd);
+ return keep;
+
+ out_free_resp:
+ iwl_free_resp(&cmd);
+ out_unlock:
+ mutex_unlock(&mvm->mutex);
+ return false;
 }
 
-int iwl_mvm_resume(struct ieee80211_hw *hw)
+static void iwl_mvm_read_d3_sram(struct iwl_mvm *mvm)
+{
+#ifdef CONFIG_IWLWIFI_DEBUGFS
+ const struct fw_img *img = &mvm->fw->img[IWL_UCODE_WOWLAN];
+ u32 len = img->sec[IWL_UCODE_SECTION_DATA].len;
+ u32 offs = img->sec[IWL_UCODE_SECTION_DATA].offset;
+
+ if (!mvm->store_d3_resume_sram)
+  return;
+
+ if (!mvm->d3_resume_sram) {
+  mvm->d3_resume_sram = kzalloc(len, GFP_KERNEL);
+  if (!mvm->d3_resume_sram)
+   return;
+ }
+
+ iwl_trans_read_mem_bytes(mvm->trans, offs, mvm->d3_resume_sram, len);
+#endif
+}
+
+static void iwl_mvm_d3_disconnect_iter(void *data, u8 *mac,
+           struct ieee80211_vif *vif)
+{
+ /* skip the one we keep connection on */
+ if (data == vif)
+  return;
+
+ if (vif->type == NL80211_IFTYPE_STATION)
+  ieee80211_resume_disconnect(vif);
+}
+
+static int __iwl_mvm_resume(struct iwl_mvm *mvm, bool test)
 {
- struct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);
  struct iwl_d3_iter_data resume_iter_data = {
   .mvm = mvm,
  };
  struct ieee80211_vif *vif = NULL;
  int ret;
  enum iwl_d3_status d3_status;
+ bool keep = false;
 
  mutex_lock(&mvm->mutex);
 
@@ -1236,7 +1610,7 @@ int iwl_mvm_resume(struct ieee80211_hw *hw)
 
  vif = resume_iter_data.vif;
 
- ret = iwl_trans_d3_resume(mvm->trans, &d3_status);
+ ret = iwl_trans_d3_resume(mvm->trans, &d3_status, test);
  if (ret)
   goto out_unlock;
 
@@ -1245,22 +1619,153 @@ int iwl_mvm_resume(struct ieee80211_hw *hw)
   goto out_unlock;
  }
 
- iwl_mvm_query_wakeup_reasons(mvm, vif);
+ /* query SRAM first in case we want event logging */
+ iwl_mvm_read_d3_sram(mvm);
+
+ keep = iwl_mvm_query_wakeup_reasons(mvm, vif);
+#ifdef CONFIG_IWLWIFI_DEBUGFS
+ if (keep)
+  mvm->keep_vif = vif;
+#endif
+ /* has unlocked the mutex, so skip that */
+ goto out;
 
  out_unlock:
  mutex_unlock(&mvm->mutex);
 
- if (vif)
-  ieee80211_resume_disconnect(vif);
+ out:
+ if (!test)
+  ieee80211_iterate_active_interfaces_rtnl(mvm->hw,
+   IEEE80211_IFACE_ITER_NORMAL,
+   iwl_mvm_d3_disconnect_iter, keep ? vif : NULL);
 
  /* return 1 to reconfigure the device */
  set_bit(IWL_MVM_STATUS_IN_HW_RESTART, &mvm->status);
  return 1;
 }
 
+int iwl_mvm_resume(struct ieee80211_hw *hw)
+{
+ struct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);
+
+ if (iwl_mvm_is_d0i3_supported(mvm)) {
+  bool exit_now;
+
+  mutex_lock(&mvm->d0i3_suspend_mutex);
+  __clear_bit(D0I3_DEFER_WAKEUP, &mvm->d0i3_suspend_flags);
+  exit_now = __test_and_clear_bit(D0I3_PENDING_WAKEUP,
+      &mvm->d0i3_suspend_flags);
+  mutex_unlock(&mvm->d0i3_suspend_mutex);
+  if (exit_now)
+   _iwl_mvm_exit_d0i3(mvm);
+  return 0;
+ }
+
+ return __iwl_mvm_resume(mvm, false);
+}
+
 void iwl_mvm_set_wakeup(struct ieee80211_hw *hw, bool enabled)
 {
  struct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);
 
  device_set_wakeup_enable(mvm->trans->dev, enabled);
 }
+
+#ifdef CONFIG_IWLWIFI_DEBUGFS
+static int iwl_mvm_d3_test_open(struct inode *inode, struct file *file)
+{
+ struct iwl_mvm *mvm = inode->i_private;
+ int err;
+
+ if (mvm->d3_test_active)
+  return -EBUSY;
+
+ file->private_data = inode->i_private;
+
+ ieee80211_stop_queues(mvm->hw);
+ synchronize_net();
+
+ /* start pseudo D3 */
+ rtnl_lock();
+ err = __iwl_mvm_suspend(mvm->hw, mvm->hw->wiphy->wowlan_config, true);
+ rtnl_unlock();
+ if (err > 0)
+  err = -EINVAL;
+ if (err) {
+  ieee80211_wake_queues(mvm->hw);
+  return err;
+ }
+ mvm->d3_test_active = true;
+ mvm->keep_vif = NULL;
+ return 0;
+}
+
+static ssize_t iwl_mvm_d3_test_read(struct file *file, char __user *user_buf,
+        size_t count, loff_t *ppos)
+{
+ struct iwl_mvm *mvm = file->private_data;
+ u32 pme_asserted;
+
+ while (true) {
+  /* read pme_ptr if available */
+  if (mvm->d3_test_pme_ptr) {
+   pme_asserted = iwl_trans_read_mem32(mvm->trans,
+      mvm->d3_test_pme_ptr);
+   if (pme_asserted)
+    break;
+  }
+
+  if (msleep_interruptible(100))
+   break;
+ }
+
+ return 0;
+}
+
+static void iwl_mvm_d3_test_disconn_work_iter(void *_data, u8 *mac,
+           struct ieee80211_vif *vif)
+{
+ /* skip the one we keep connection on */
+ if (_data == vif)
+  return;
+
+ if (vif->type == NL80211_IFTYPE_STATION)
+  ieee80211_connection_loss(vif);
+}
+
+static int iwl_mvm_d3_test_release(struct inode *inode, struct file *file)
+{
+ struct iwl_mvm *mvm = inode->i_private;
+ int remaining_time = 10;
+
+ mvm->d3_test_active = false;
+ __iwl_mvm_resume(mvm, true);
+ iwl_abort_notification_waits(&mvm->notif_wait);
+ ieee80211_restart_hw(mvm->hw);
+
+ /* wait for restart and disconnect all interfaces */
+ while (test_bit(IWL_MVM_STATUS_IN_HW_RESTART, &mvm->status) &&
+        remaining_time > 0) {
+  remaining_time--;
+  msleep(1000);
+ }
+
+ if (remaining_time == 0)
+  IWL_ERR(mvm, "Timed out waiting for HW restart to finish!\n");
+
+ ieee80211_iterate_active_interfaces_atomic(
+  mvm->hw, IEEE80211_IFACE_ITER_NORMAL,
+  iwl_mvm_d3_test_disconn_work_iter, mvm->keep_vif);
+
+ ieee80211_wake_queues(mvm->hw);
+
+ return 0;
+}
+
+const struct file_operations iwl_dbgfs_d3_test_ops = {
+ .llseek = no_llseek,
+ .open = iwl_mvm_d3_test_open,
+ .read = iwl_mvm_d3_test_read,
+ .release = iwl_mvm_d3_test_release,
+};
+#endif
diff --git a/drivers/net/wireless/iwlwifi/mvm/debugfs-vif.c b/drivers/net/wireless/iwlwifi/mvm/debugfs-vif.c
new file mode 100644
index 0000000..2e90ff7
--- /dev/null
+++ b/drivers/net/wireless/iwlwifi/mvm/debugfs-vif.c
@@ -0,0 +1,596 @@
+/******************************************************************************
+ *
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ * redistributing this file, you may do so under either license.
+ *
+ * GPL LICENSE SUMMARY
+ *
+ * Copyright(c) 2012 - 2014 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110,
+ * USA
+ *
+ * The full GNU General Public License is included in this distribution
+ * in the file called COPYING.
+ *
+ * Contact Information:
+ *  Intel Linux Wireless <ilw@linux.intel.com>
+ * Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497
+ *
+ * BSD LICENSE
+ *
+ * Copyright(c) 2012 - 2014 Intel Corporation. All rights reserved.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *  * Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *  * Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *  * Neither the name Intel Corporation nor the names of its
+ *    contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *****************************************************************************/
+#include "mvm.h"
+#include "debugfs.h"
+
+static void iwl_dbgfs_update_pm(struct iwl_mvm *mvm,
+     struct ieee80211_vif *vif,
+     enum iwl_dbgfs_pm_mask param, int val)
+{
+ struct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);
+ struct iwl_dbgfs_pm *dbgfs_pm = &mvmvif->dbgfs_pm;
+
+ dbgfs_pm->mask |= param;
+
+ switch (param) {
+ case MVM_DEBUGFS_PM_KEEP_ALIVE: {
+  struct ieee80211_hw *hw = mvm->hw;
+  int dtimper = hw->conf.ps_dtim_period ?: 1;
+  int dtimper_msec = dtimper * vif->bss_conf.beacon_int;
+
+  IWL_DEBUG_POWER(mvm, "debugfs: set keep_alive= %d sec\n", val);
+  if (val * MSEC_PER_SEC < 3 * dtimper_msec)
+   IWL_WARN(mvm,
+     "debugfs: keep alive period (%ld msec) is less than minimum required (%d msec)\n",
+     val * MSEC_PER_SEC, 3 * dtimper_msec);
+  dbgfs_pm->keep_alive_seconds = val;
+  break;
+ }
+ case MVM_DEBUGFS_PM_SKIP_OVER_DTIM:
+  IWL_DEBUG_POWER(mvm, "skip_over_dtim %s\n",
+    val ? "enabled" : "disabled");
+  dbgfs_pm->skip_over_dtim = val;
+  break;
+ case MVM_DEBUGFS_PM_SKIP_DTIM_PERIODS:
+  IWL_DEBUG_POWER(mvm, "skip_dtim_periods=%d\n", val);
+  dbgfs_pm->skip_dtim_periods = val;
+  break;
+ case MVM_DEBUGFS_PM_RX_DATA_TIMEOUT:
+  IWL_DEBUG_POWER(mvm, "rx_data_timeout=%d\n", val);
+  dbgfs_pm->rx_data_timeout = val;
+  break;
+ case MVM_DEBUGFS_PM_TX_DATA_TIMEOUT:
+  IWL_DEBUG_POWER(mvm, "tx_data_timeout=%d\n", val);
+  dbgfs_pm->tx_data_timeout = val;
+  break;
+ case MVM_DEBUGFS_PM_LPRX_ENA:
+  IWL_DEBUG_POWER(mvm, "lprx %s\n", val ? "enabled" : "disabled");
+  dbgfs_pm->lprx_ena = val;
+  break;
+ case MVM_DEBUGFS_PM_LPRX_RSSI_THRESHOLD:
+  IWL_DEBUG_POWER(mvm, "lprx_rssi_threshold=%d\n", val);
+  dbgfs_pm->lprx_rssi_threshold = val;
+  break;
+ case MVM_DEBUGFS_PM_SNOOZE_ENABLE:
+  IWL_DEBUG_POWER(mvm, "snooze_enable=%d\n", val);
+  dbgfs_pm->snooze_ena = val;
+  break;
+ case MVM_DEBUGFS_PM_UAPSD_MISBEHAVING:
+  IWL_DEBUG_POWER(mvm, "uapsd_misbehaving_enable=%d\n", val);
+  dbgfs_pm->uapsd_misbehaving = val;
+  break;
+ }
+}
+
+static ssize_t iwl_dbgfs_pm_params_write(struct ieee80211_vif *vif, char *buf,
+      size_t count, loff_t *ppos)
+{
+ struct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);
+ struct iwl_mvm *mvm = mvmvif->mvm;
+ enum iwl_dbgfs_pm_mask param;
+ int val, ret;
+
+ if (!strncmp("keep_alive=", buf, 11)) {
+  if (sscanf(buf + 11, "%d", &val) != 1)
+   return -EINVAL;
+  param = MVM_DEBUGFS_PM_KEEP_ALIVE;
+ } else if (!strncmp("skip_over_dtim=", buf, 15)) {
+  if (sscanf(buf + 15, "%d", &val) != 1)
+   return -EINVAL;
+  param = MVM_DEBUGFS_PM_SKIP_OVER_DTIM;
+ } else if (!strncmp("skip_dtim_periods=", buf, 18)) {
+  if (sscanf(buf + 18, "%d", &val) != 1)
+   return -EINVAL;
+  param = MVM_DEBUGFS_PM_SKIP_DTIM_PERIODS;
+ } else if (!strncmp("rx_data_timeout=", buf, 16)) {
+  if (sscanf(buf + 16, "%d", &val) != 1)
+   return -EINVAL;
+  param = MVM_DEBUGFS_PM_RX_DATA_TIMEOUT;
+ } else if (!strncmp("tx_data_timeout=", buf, 16)) {
+  if (sscanf(buf + 16, "%d", &val) != 1)
+   return -EINVAL;
+  param = MVM_DEBUGFS_PM_TX_DATA_TIMEOUT;
+ } else if (!strncmp("lprx=", buf, 5)) {
+  if (sscanf(buf + 5, "%d", &val) != 1)
+   return -EINVAL;
+  param = MVM_DEBUGFS_PM_LPRX_ENA;
+ } else if (!strncmp("lprx_rssi_threshold=", buf, 20)) {
+  if (sscanf(buf + 20, "%d", &val) != 1)
+   return -EINVAL;
+  if (val > POWER_LPRX_RSSI_THRESHOLD_MAX || val <
+      POWER_LPRX_RSSI_THRESHOLD_MIN)
+   return -EINVAL;
+  param = MVM_DEBUGFS_PM_LPRX_RSSI_THRESHOLD;
+ } else if (!strncmp("snooze_enable=", buf, 14)) {
+  if (sscanf(buf + 14, "%d", &val) != 1)
+   return -EINVAL;
+  param = MVM_DEBUGFS_PM_SNOOZE_ENABLE;
+ } else if (!strncmp("uapsd_misbehaving=", buf, 18)) {
+  if (sscanf(buf + 18, "%d", &val) != 1)
+   return -EINVAL;
+  param = MVM_DEBUGFS_PM_UAPSD_MISBEHAVING;
+ } else {
+  return -EINVAL;
+ }
+
+ mutex_lock(&mvm->mutex);
+ iwl_dbgfs_update_pm(mvm, vif, param, val);
+ ret = iwl_mvm_power_update_mac(mvm);
+ mutex_unlock(&mvm->mutex);
+
+ return ret ?: count;
+}
+
+static ssize_t iwl_dbgfs_pm_params_read(struct file *file,
+     char __user *user_buf,
+     size_t count, loff_t *ppos)
+{
+ struct ieee80211_vif *vif = file->private_data;
+ struct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);
+ struct iwl_mvm *mvm = mvmvif->mvm;
+ char buf[512];
+ int bufsz = sizeof(buf);
+ int pos;
+
+ pos = iwl_mvm_power_mac_dbgfs_read(mvm, vif, buf, bufsz);
+
+ return simple_read_from_buffer(user_buf, count, ppos, buf, pos);
+}
+
+static ssize_t iwl_dbgfs_mac_params_read(struct file *file,
+      char __user *user_buf,
+      size_t count, loff_t *ppos)
+{
+ struct ieee80211_vif *vif = file->private_data;
+ struct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);
+ struct iwl_mvm *mvm = mvmvif->mvm;
+ u8 ap_sta_id;
+ struct ieee80211_chanctx_conf *chanctx_conf;
+ char buf[512];
+ int bufsz = sizeof(buf);
+ int pos = 0;
+ int i;
+
+ mutex_lock(&mvm->mutex);
+
+ ap_sta_id = mvmvif->ap_sta_id;
+
+ switch (ieee80211_vif_type_p2p(vif)) {
+ case NL80211_IFTYPE_ADHOC:
+  pos += scnprintf(buf+pos, bufsz-pos, "type: ibss\n");
+  break;
+ case NL80211_IFTYPE_STATION:
+  pos += scnprintf(buf+pos, bufsz-pos, "type: bss\n");
+  break;
+ case NL80211_IFTYPE_AP:
+  pos += scnprintf(buf+pos, bufsz-pos, "type: ap\n");
+  break;
+ case NL80211_IFTYPE_P2P_CLIENT:
+  pos += scnprintf(buf+pos, bufsz-pos, "type: p2p client\n");
+  break;
+ case NL80211_IFTYPE_P2P_GO:
+  pos += scnprintf(buf+pos, bufsz-pos, "type: p2p go\n");
+  break;
+ case NL80211_IFTYPE_P2P_DEVICE:
+  pos += scnprintf(buf+pos, bufsz-pos, "type: p2p dev\n");
+  break;
+ default:
+  break;
+ }
+
+ pos += scnprintf(buf+pos, bufsz-pos, "mac id/color: %d / %d\n",
+    mvmvif->id, mvmvif->color);
+ pos += scnprintf(buf+pos, bufsz-pos, "bssid: %pM\n",
+    vif->bss_conf.bssid);
+ pos += scnprintf(buf+pos, bufsz-pos, "QoS:\n");
+ for (i = 0; i < ARRAY_SIZE(mvmvif->queue_params); i++)
+  pos += scnprintf(buf+pos, bufsz-pos,
+     "\t%d: txop:%d - cw_min:%d - cw_max = %d - aifs = %d upasd = %d\n",
+     i, mvmvif->queue_params[i].txop,
+     mvmvif->queue_params[i].cw_min,
+     mvmvif->queue_params[i].cw_max,
+     mvmvif->queue_params[i].aifs,
+     mvmvif->queue_params[i].uapsd);
+
+ if (vif->type == NL80211_IFTYPE_STATION &&
+     ap_sta_id != IWL_MVM_STATION_COUNT) {
+  struct ieee80211_sta *sta;
+
+  sta = rcu_dereference_protected(mvm->fw_id_to_mac_id[ap_sta_id],
+      lockdep_is_held(&mvm->mutex));
+  if (!IS_ERR_OR_NULL(sta)) {
+   struct iwl_mvm_sta *mvm_sta = (void *)sta->drv_priv;
+
+   pos += scnprintf(buf+pos, bufsz-pos,
+      "ap_sta_id %d - reduced Tx power %d\n",
+      ap_sta_id,
+      mvm_sta->bt_reduced_txpower);
+  }
+ }
+
+ rcu_read_lock();
+ chanctx_conf = rcu_dereference(vif->chanctx_conf);
+ if (chanctx_conf)
+  pos += scnprintf(buf+pos, bufsz-pos,
+     "idle rx chains %d, active rx chains: %d\n",
+     chanctx_conf->rx_chains_static,
+     chanctx_conf->rx_chains_dynamic);
+ rcu_read_unlock();
+
+ mutex_unlock(&mvm->mutex);
+
+ return simple_read_from_buffer(user_buf, count, ppos, buf, pos);
+}
+
+static void iwl_dbgfs_update_bf(struct ieee80211_vif *vif,
+    enum iwl_dbgfs_bf_mask param, int value)
+{
+ struct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);
+ struct iwl_dbgfs_bf *dbgfs_bf = &mvmvif->dbgfs_bf;
+
+ dbgfs_bf->mask |= param;
+
+ switch (param) {
+ case MVM_DEBUGFS_BF_ENERGY_DELTA:
+  dbgfs_bf->bf_energy_delta = value;
+  break;
+ case MVM_DEBUGFS_BF_ROAMING_ENERGY_DELTA:
+  dbgfs_bf->bf_roaming_energy_delta = value;
+  break;
+ case MVM_DEBUGFS_BF_ROAMING_STATE:
+  dbgfs_bf->bf_roaming_state = value;
+  break;
+ case MVM_DEBUGFS_BF_TEMP_THRESHOLD:
+  dbgfs_bf->bf_temp_threshold = value;
+  break;
+ case MVM_DEBUGFS_BF_TEMP_FAST_FILTER:
+  dbgfs_bf->bf_temp_fast_filter = value;
+  break;
+ case MVM_DEBUGFS_BF_TEMP_SLOW_FILTER:
+  dbgfs_bf->bf_temp_slow_filter = value;
+  break;
+ case MVM_DEBUGFS_BF_ENABLE_BEACON_FILTER:
+  dbgfs_bf->bf_enable_beacon_filter = value;
+  break;
+ case MVM_DEBUGFS_BF_DEBUG_FLAG:
+  dbgfs_bf->bf_debug_flag = value;
+  break;
+ case MVM_DEBUGFS_BF_ESCAPE_TIMER:
+  dbgfs_bf->bf_escape_timer = value;
+  break;
+ case MVM_DEBUGFS_BA_ENABLE_BEACON_ABORT:
+  dbgfs_bf->ba_enable_beacon_abort = value;
+  break;
+ case MVM_DEBUGFS_BA_ESCAPE_TIMER:
+  dbgfs_bf->ba_escape_timer = value;
+  break;
+ }
+}
+
+static ssize_t iwl_dbgfs_bf_params_write(struct ieee80211_vif *vif, char *buf,
+      size_t count, loff_t *ppos)
+{
+ struct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);
+ struct iwl_mvm *mvm = mvmvif->mvm;
+ enum iwl_dbgfs_bf_mask param;
+ int value, ret = 0;
+
+ if (!strncmp("bf_energy_delta=", buf, 16)) {
+  if (sscanf(buf+16, "%d", &value) != 1)
+   return -EINVAL;
+  if (value < IWL_BF_ENERGY_DELTA_MIN ||
+      value > IWL_BF_ENERGY_DELTA_MAX)
+   return -EINVAL;
+  param = MVM_DEBUGFS_BF_ENERGY_DELTA;
+ } else if (!strncmp("bf_roaming_energy_delta=", buf, 24)) {
+  if (sscanf(buf+24, "%d", &value) != 1)
+   return -EINVAL;
+  if (value < IWL_BF_ROAMING_ENERGY_DELTA_MIN ||
+      value > IWL_BF_ROAMING_ENERGY_DELTA_MAX)
+   return -EINVAL;
+  param = MVM_DEBUGFS_BF_ROAMING_ENERGY_DELTA;
+ } else if (!strncmp("bf_roaming_state=", buf, 17)) {
+  if (sscanf(buf+17, "%d", &value) != 1)
+   return -EINVAL;
+  if (value < IWL_BF_ROAMING_STATE_MIN ||
+      value > IWL_BF_ROAMING_STATE_MAX)
+   return -EINVAL;
+  param = MVM_DEBUGFS_BF_ROAMING_STATE;
+ } else if (!strncmp("bf_temp_threshold=", buf, 18)) {
+  if (sscanf(buf+18, "%d", &value) != 1)
+   return -EINVAL;
+  if (value < IWL_BF_TEMP_THRESHOLD_MIN ||
+      value > IWL_BF_TEMP_THRESHOLD_MAX)
+   return -EINVAL;
+  param = MVM_DEBUGFS_BF_TEMP_THRESHOLD;
+ } else if (!strncmp("bf_temp_fast_filter=", buf, 20)) {
+  if (sscanf(buf+20, "%d", &value) != 1)
+   return -EINVAL;
+  if (value < IWL_BF_TEMP_FAST_FILTER_MIN ||
+      value > IWL_BF_TEMP_FAST_FILTER_MAX)
+   return -EINVAL;
+  param = MVM_DEBUGFS_BF_TEMP_FAST_FILTER;
+ } else if (!strncmp("bf_temp_slow_filter=", buf, 20)) {
+  if (sscanf(buf+20, "%d", &value) != 1)
+   return -EINVAL;
+  if (value < IWL_BF_TEMP_SLOW_FILTER_MIN ||
+      value > IWL_BF_TEMP_SLOW_FILTER_MAX)
+   return -EINVAL;
+  param = MVM_DEBUGFS_BF_TEMP_SLOW_FILTER;
+ } else if (!strncmp("bf_enable_beacon_filter=", buf, 24)) {
+  if (sscanf(buf+24, "%d", &value) != 1)
+   return -EINVAL;
+  if (value < 0 || value > 1)
+   return -EINVAL;
+  param = MVM_DEBUGFS_BF_ENABLE_BEACON_FILTER;
+ } else if (!strncmp("bf_debug_flag=", buf, 14)) {
+  if (sscanf(buf+14, "%d", &value) != 1)
+   return -EINVAL;
+  if (value < 0 || value > 1)
+   return -EINVAL;
+  param = MVM_DEBUGFS_BF_DEBUG_FLAG;
+ } else if (!strncmp("bf_escape_timer=", buf, 16)) {
+  if (sscanf(buf+16, "%d", &value) != 1)
+   return -EINVAL;
+  if (value < IWL_BF_ESCAPE_TIMER_MIN ||
+      value > IWL_BF_ESCAPE_TIMER_MAX)
+   return -EINVAL;
+  param = MVM_DEBUGFS_BF_ESCAPE_TIMER;
+ } else if (!strncmp("ba_escape_timer=", buf, 16)) {
+  if (sscanf(buf+16, "%d", &value) != 1)
+   return -EINVAL;
+  if (value < IWL_BA_ESCAPE_TIMER_MIN ||
+      value > IWL_BA_ESCAPE_TIMER_MAX)
+   return -EINVAL;
+  param = MVM_DEBUGFS_BA_ESCAPE_TIMER;
+ } else if (!strncmp("ba_enable_beacon_abort=", buf, 23)) {
+  if (sscanf(buf+23, "%d", &value) != 1)
+   return -EINVAL;
+  if (value < 0 || value > 1)
+   return -EINVAL;
+  param = MVM_DEBUGFS_BA_ENABLE_BEACON_ABORT;
+ } else {
+  return -EINVAL;
+ }
+
+ mutex_lock(&mvm->mutex);
+ iwl_dbgfs_update_bf(vif, param, value);
+ if (param == MVM_DEBUGFS_BF_ENABLE_BEACON_FILTER && !value)
+  ret = iwl_mvm_disable_beacon_filter(mvm, vif, 0);
+ else
+  ret = iwl_mvm_enable_beacon_filter(mvm, vif, 0);
+ mutex_unlock(&mvm->mutex);
+
+ return ret ?: count;
+}
+
+static ssize_t iwl_dbgfs_bf_params_read(struct file *file,
+     char __user *user_buf,
+     size_t count, loff_t *ppos)
+{
+ struct ieee80211_vif *vif = file->private_data;
+ struct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);
+ char buf[256];
+ int pos = 0;
+ const size_t bufsz = sizeof(buf);
+ struct iwl_beacon_filter_cmd cmd = {
+  IWL_BF_CMD_CONFIG_DEFAULTS,
+  .bf_enable_beacon_filter =
+   cpu_to_le32(IWL_BF_ENABLE_BEACON_FILTER_DEFAULT),
+  .ba_enable_beacon_abort =
+   cpu_to_le32(IWL_BA_ENABLE_BEACON_ABORT_DEFAULT),
+ };
+
+ iwl_mvm_beacon_filter_debugfs_parameters(vif, &cmd);
+ if (mvmvif->bf_data.bf_enabled)
+  cmd.bf_enable_beacon_filter = cpu_to_le32(1);
+ else
+  cmd.bf_enable_beacon_filter = 0;
+
+ pos += scnprintf(buf+pos, bufsz-pos, "bf_energy_delta = %d\n",
+    le32_to_cpu(cmd.bf_energy_delta));
+ pos += scnprintf(buf+pos, bufsz-pos, "bf_roaming_energy_delta = %d\n",
+    le32_to_cpu(cmd.bf_roaming_energy_delta));
+ pos += scnprintf(buf+pos, bufsz-pos, "bf_roaming_state = %d\n",
+    le32_to_cpu(cmd.bf_roaming_state));
+ pos += scnprintf(buf+pos, bufsz-pos, "bf_temp_threshold = %d\n",
+    le32_to_cpu(cmd.bf_temp_threshold));
+ pos += scnprintf(buf+pos, bufsz-pos, "bf_temp_fast_filter = %d\n",
+    le32_to_cpu(cmd.bf_temp_fast_filter));
+ pos += scnprintf(buf+pos, bufsz-pos, "bf_temp_slow_filter = %d\n",
+    le32_to_cpu(cmd.bf_temp_slow_filter));
+ pos += scnprintf(buf+pos, bufsz-pos, "bf_enable_beacon_filter = %d\n",
+    le32_to_cpu(cmd.bf_enable_beacon_filter));
+ pos += scnprintf(buf+pos, bufsz-pos, "bf_debug_flag = %d\n",
+    le32_to_cpu(cmd.bf_debug_flag));
+ pos += scnprintf(buf+pos, bufsz-pos, "bf_escape_timer = %d\n",
+    le32_to_cpu(cmd.bf_escape_timer));
+ pos += scnprintf(buf+pos, bufsz-pos, "ba_escape_timer = %d\n",
+    le32_to_cpu(cmd.ba_escape_timer));
+ pos += scnprintf(buf+pos, bufsz-pos, "ba_enable_beacon_abort = %d\n",
+    le32_to_cpu(cmd.ba_enable_beacon_abort));
+
+ return simple_read_from_buffer(user_buf, count, ppos, buf, pos);
+}
+
+static ssize_t iwl_dbgfs_low_latency_write(struct ieee80211_vif *vif, char *buf,
+        size_t count, loff_t *ppos)
+{
+ struct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);
+ struct iwl_mvm *mvm = mvmvif->mvm;
+ u8 value;
+ int ret;
+
+ ret = kstrtou8(buf, 0, &value);
+ if (ret)
+  return ret;
+ if (value > 1)
+  return -EINVAL;
+
+ mutex_lock(&mvm->mutex);
+ iwl_mvm_update_low_latency(mvm, vif, value);
+ mutex_unlock(&mvm->mutex);
+
+ return count;
+}
+
+static ssize_t iwl_dbgfs_low_latency_read(struct file *file,
+       char __user *user_buf,
+       size_t count, loff_t *ppos)
+{
+ struct ieee80211_vif *vif = file->private_data;
+ struct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);
+ char buf[3];
+
+ buf[0] = mvmvif->low_latency ? '1' : '0';
+ buf[1] = '\n';
+ buf[2] = '\0';
+ return simple_read_from_buffer(user_buf, count, ppos, buf, sizeof(buf));
+}
+
+#define MVM_DEBUGFS_WRITE_FILE_OPS(name, bufsz) \
+ _MVM_DEBUGFS_WRITE_FILE_OPS(name, bufsz, struct ieee80211_vif)
+#define MVM_DEBUGFS_READ_WRITE_FILE_OPS(name, bufsz) \
+ _MVM_DEBUGFS_READ_WRITE_FILE_OPS(name, bufsz, struct ieee80211_vif)
+#define MVM_DEBUGFS_ADD_FILE_VIF(name, parent, mode) do {  \
+  if (!debugfs_create_file(#name, mode, parent, vif, \
+      &iwl_dbgfs_##name##_ops)) \
+   goto err;     \
+ } while (0)
+
+MVM_DEBUGFS_READ_FILE_OPS(mac_params);
+MVM_DEBUGFS_READ_WRITE_FILE_OPS(pm_params, 32);
+MVM_DEBUGFS_READ_WRITE_FILE_OPS(bf_params, 256);
+MVM_DEBUGFS_READ_WRITE_FILE_OPS(low_latency, 10);
+
+void iwl_mvm_vif_dbgfs_register(struct iwl_mvm *mvm, struct ieee80211_vif *vif)
+{
+ struct dentry *dbgfs_dir = vif->debugfs_dir;
+ struct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);
+ char buf[100];
+
+ /*
+  * Check if debugfs directory already exist before creating it.
+  * This may happen when, for example, resetting hw or suspend-resume
+  */
+ if (!dbgfs_dir || mvmvif->dbgfs_dir)
+  return;
+
+ mvmvif->dbgfs_dir = debugfs_create_dir("iwlmvm", dbgfs_dir);
+ mvmvif->mvm = mvm;
+
+ if (!mvmvif->dbgfs_dir) {
+  IWL_ERR(mvm, "Failed to create debugfs directory under %s\n",
+   dbgfs_dir->d_name.name);
+  return;
+ }
+
+ if (iwlmvm_mod_params.power_scheme != IWL_POWER_SCHEME_CAM &&
+     ((vif->type == NL80211_IFTYPE_STATION && !vif->p2p) ||
+      (vif->type == NL80211_IFTYPE_STATION && vif->p2p &&
+       mvm->fw->ucode_capa.flags & IWL_UCODE_TLV_FLAGS_BSS_P2P_PS_DCM)))
+  MVM_DEBUGFS_ADD_FILE_VIF(pm_params, mvmvif->dbgfs_dir, S_IWUSR |
+      S_IRUSR);
+
+ MVM_DEBUGFS_ADD_FILE_VIF(mac_params, mvmvif->dbgfs_dir, S_IRUSR);
+ MVM_DEBUGFS_ADD_FILE_VIF(low_latency, mvmvif->dbgfs_dir,
+     S_IRUSR | S_IWUSR);
+
+ if (vif->type == NL80211_IFTYPE_STATION && !vif->p2p &&
+     mvmvif == mvm->bf_allowed_vif)
+  MVM_DEBUGFS_ADD_FILE_VIF(bf_params, mvmvif->dbgfs_dir,
+      S_IRUSR | S_IWUSR);
+
+ /*
+  * Create symlink for convenience pointing to interface specific
+  * debugfs entries for the driver. For example, under
+  * /sys/kernel/debug/iwlwifi/0000\:02\:00.0/iwlmvm/
+  * find
+  * netdev:wlan0 -> ../../../ieee80211/phy0/netdev:wlan0/iwlmvm/
+  */
+ snprintf(buf, 100, "../../../%s/%s/%s/%s",
+   dbgfs_dir->d_parent->d_parent->d_name.name,
+   dbgfs_dir->d_parent->d_name.name,
+   dbgfs_dir->d_name.name,
+   mvmvif->dbgfs_dir->d_name.name);
+
+ mvmvif->dbgfs_slink = debugfs_create_symlink(dbgfs_dir->d_name.name,
+           mvm->debugfs_dir, buf);
+ if (!mvmvif->dbgfs_slink)
+  IWL_ERR(mvm, "Can't create debugfs symbolic link under %s\n",
+   dbgfs_dir->d_name.name);
+ return;
+err:
+ IWL_ERR(mvm, "Can't create debugfs entity\n");
+}
+
+void iwl_mvm_vif_dbgfs_clean(struct iwl_mvm *mvm, struct ieee80211_vif *vif)
+{
+ struct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);
+
+ debugfs_remove(mvmvif->dbgfs_slink);
+ mvmvif->dbgfs_slink = NULL;
+
+ debugfs_remove_recursive(mvmvif->dbgfs_dir);
+ mvmvif->dbgfs_dir = NULL;
+}
diff --git a/drivers/net/wireless/iwlwifi/mvm/debugfs.c b/drivers/net/wireless/iwlwifi/mvm/debugfs.c
index 2053dcc..29ca726 100644
--- a/drivers/net/wireless/iwlwifi/mvm/debugfs.c
+++ b/drivers/net/wireless/iwlwifi/mvm/debugfs.c
@@ -5,7 +5,7 @@
  *
  * GPL LICENSE SUMMARY
  *
- * Copyright(c) 2012 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2012 - 2014 Intel Corporation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of version 2 of the GNU General Public License as
@@ -30,7 +30,7 @@
  *
  * BSD LICENSE
  *
- * Copyright(c) 2012 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2012 - 2014 Intel Corporation. All rights reserved.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -60,33 +60,23 @@
  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  *
  *****************************************************************************/
+#include <linux/vmalloc.h>
+
 #include "mvm.h"
 #include "sta.h"
 #include "iwl-io.h"
+#include "debugfs.h"
+#include "iwl-fw-error-dump.h"
 
-struct iwl_dbgfs_mvm_ctx {
- struct iwl_mvm *mvm;
- struct ieee80211_vif *vif;
-};
-
-static ssize_t iwl_dbgfs_tx_flush_write(struct file *file,
-     const char __user *user_buf,
+static ssize_t iwl_dbgfs_tx_flush_write(struct iwl_mvm *mvm, char *buf,
      size_t count, loff_t *ppos)
 {
- struct iwl_mvm *mvm = file->private_data;
-
- char buf[16];
- int buf_size, ret;
+ int ret;
  u32 scd_q_msk;
 
  if (!mvm->ucode_loaded || mvm->cur_ucode != IWL_UCODE_REGULAR)
   return -EIO;
 
- memset(buf, 0, sizeof(buf));
- buf_size = min(count, sizeof(buf) - 1);
- if (copy_from_user(buf, user_buf, buf_size))
-  return -EFAULT;
-
  if (sscanf(buf, "%x", &scd_q_msk) != 1)
   return -EINVAL;
 
@@ -99,114 +89,134 @@ static ssize_t iwl_dbgfs_tx_flush_write(struct file *file,
  return ret;
 }
 
-static ssize_t iwl_dbgfs_sta_drain_write(struct file *file,
-      const char __user *user_buf,
+static ssize_t iwl_dbgfs_sta_drain_write(struct iwl_mvm *mvm, char *buf,
       size_t count, loff_t *ppos)
 {
- struct iwl_mvm *mvm = file->private_data;
- struct ieee80211_sta *sta;
-
- char buf[8];
- int buf_size, sta_id, drain, ret;
+ struct iwl_mvm_sta *mvmsta;
+ int sta_id, drain, ret;
 
  if (!mvm->ucode_loaded || mvm->cur_ucode != IWL_UCODE_REGULAR)
   return -EIO;
 
- memset(buf, 0, sizeof(buf));
- buf_size = min(count, sizeof(buf) - 1);
- if (copy_from_user(buf, user_buf, buf_size))
-  return -EFAULT;
-
  if (sscanf(buf, "%d %d", &sta_id, &drain) != 2)
   return -EINVAL;
+ if (sta_id < 0 || sta_id >= IWL_MVM_STATION_COUNT)
+  return -EINVAL;
+ if (drain < 0 || drain > 1)
+  return -EINVAL;
 
  mutex_lock(&mvm->mutex);
 
- sta = rcu_dereference_protected(mvm->fw_id_to_mac_id[sta_id],
-     lockdep_is_held(&mvm->mutex));
- if (IS_ERR_OR_NULL(sta))
+ mvmsta = iwl_mvm_sta_from_staid_protected(mvm, sta_id);
+
+ if (!mvmsta)
   ret = -ENOENT;
  else
-  ret = iwl_mvm_drain_sta(mvm, (void *)sta->drv_priv, drain) ? :
-   count;
+  ret = iwl_mvm_drain_sta(mvm, mvmsta, drain) ? : count;
 
  mutex_unlock(&mvm->mutex);
 
  return ret;
 }
 
+static int iwl_dbgfs_fw_error_dump_open(struct inode *inode, struct file *file)
+{
+ struct iwl_mvm *mvm = inode->i_private;
+ int ret;
+
+ if (!mvm)
+  return -EINVAL;
+
+ mutex_lock(&mvm->mutex);
+ if (!mvm->fw_error_dump) {
+  ret = -ENODATA;
+  goto out;
+ }
+
+ file->private_data = mvm->fw_error_dump;
+ mvm->fw_error_dump = NULL;
+ ret = 0;
+
+out:
+ mutex_unlock(&mvm->mutex);
+ return ret;
+}
+
+static ssize_t iwl_dbgfs_fw_error_dump_read(struct file *file,
+         char __user *user_buf,
+         size_t count, loff_t *ppos)
+{
+ struct iwl_fw_error_dump_file *dump_file = file->private_data;
+
+ return simple_read_from_buffer(user_buf, count, ppos,
+           dump_file,
+           le32_to_cpu(dump_file->file_len));
+}
+
+static int iwl_dbgfs_fw_error_dump_release(struct inode *inode,
+        struct file *file)
+{
+ vfree(file->private_data);
+
+ return 0;
+}
+
 static ssize_t iwl_dbgfs_sram_read(struct file *file, char __user *user_buf,
        size_t count, loff_t *ppos)
 {
  struct iwl_mvm *mvm = file->private_data;
  const struct fw_img *img;
- int ofs, len, pos = 0;
- size_t bufsz, ret;
- char *buf;
+ unsigned int ofs, len;
+ size_t ret;
  u8 *ptr;
 
+ if (!mvm->ucode_loaded)
+  return -EINVAL;
+
  /* default is to dump the entire data segment */
- if (!mvm->dbgfs_sram_offset && !mvm->dbgfs_sram_len) {
-  mvm->dbgfs_sram_offset = 0x800000;
-  if (!mvm->ucode_loaded)
-   return -EINVAL;
-  img = &mvm->fw->img[mvm->cur_ucode];
-  mvm->dbgfs_sram_len = img->sec[IWL_UCODE_SECTION_DATA].len;
- }
- len = mvm->dbgfs_sram_len;
+ img = &mvm->fw->img[mvm->cur_ucode];
+ ofs = img->sec[IWL_UCODE_SECTION_DATA].offset;
+ len = img->sec[IWL_UCODE_SECTION_DATA].len;
 
- bufsz = len * 4 + 256;
- buf = kzalloc(bufsz, GFP_KERNEL);
- if (!buf)
-  return -ENOMEM;
+ if (mvm->dbgfs_sram_len) {
+  ofs = mvm->dbgfs_sram_offset;
+  len = mvm->dbgfs_sram_len;
+ }
 
  ptr = kzalloc(len, GFP_KERNEL);
- if (!ptr) {
-  kfree(buf);
+ if (!ptr)
   return -ENOMEM;
- }
 
- pos += scnprintf(buf + pos, bufsz - pos, "sram_len: 0x%x\n", len);
- pos += scnprintf(buf + pos, bufsz - pos, "sram_offset: 0x%x\n",
-    mvm->dbgfs_sram_offset);
-
- iwl_trans_read_mem_bytes(mvm->trans,
-     mvm->dbgfs_sram_offset,
-     ptr, len);
- for (ofs = 0; ofs < len; ofs += 16) {
-  pos += scnprintf(buf + pos, bufsz - pos, "0x%.4x ", ofs);
-  hex_dump_to_buffer(ptr + ofs, 16, 16, 1, buf + pos,
-       bufsz - pos, false);
-  pos += strlen(buf + pos);
-  if (bufsz - pos > 0)
-   buf[pos++] = '\n';
- }
+ iwl_trans_read_mem_bytes(mvm->trans, ofs, ptr, len);
 
- ret = simple_read_from_buffer(user_buf, count, ppos, buf, pos);
+ ret = simple_read_from_buffer(user_buf, count, ppos, ptr, len);
 
- kfree(buf);
  kfree(ptr);
 
  return ret;
 }
 
-static ssize_t iwl_dbgfs_sram_write(struct file *file,
-        const char __user *user_buf, size_t count,
-        loff_t *ppos)
+static ssize_t iwl_dbgfs_sram_write(struct iwl_mvm *mvm, char *buf,
+        size_t count, loff_t *ppos)
 {
- struct iwl_mvm *mvm = file->private_data;
- char buf[64];
- int buf_size;
+ const struct fw_img *img;
  u32 offset, len;
+ u32 img_offset, img_len;
 
- memset(buf, 0, sizeof(buf));
- buf_size = min(count, sizeof(buf) -  1);
- if (copy_from_user(buf, user_buf, buf_size))
-  return -EFAULT;
+ if (!mvm->ucode_loaded)
+  return -EINVAL;
+
+ img = &mvm->fw->img[mvm->cur_ucode];
+ img_offset = img->sec[IWL_UCODE_SECTION_DATA].offset;
+ img_len = img->sec[IWL_UCODE_SECTION_DATA].len;
 
  if (sscanf(buf, "%x,%x", &offset, &len) == 2) {
   if ((offset & 0x3) || (len & 0x3))
    return -EINVAL;
+
+  if (offset + len > img_offset + img_len)
+   return -EINVAL;
+
   mvm->dbgfs_sram_offset = offset;
   mvm->dbgfs_sram_len = len;
  } else {
@@ -246,119 +256,48 @@ static ssize_t iwl_dbgfs_stations_read(struct file *file, char __user *user_buf,
  return simple_read_from_buffer(user_buf, count, ppos, buf, pos);
 }
 
-static ssize_t iwl_dbgfs_power_down_allow_write(struct file *file,
-      const char __user *user_buf,
+static ssize_t iwl_dbgfs_disable_power_off_read(struct file *file,
+      char __user *user_buf,
       size_t count, loff_t *ppos)
 {
  struct iwl_mvm *mvm = file->private_data;
- char buf[8] = {};
- int allow;
-
- if (!mvm->ucode_loaded)
-  return -EIO;
-
- if (copy_from_user(buf, user_buf, sizeof(buf)))
-  return -EFAULT;
-
- if (sscanf(buf, "%d", &allow) != 1)
-  return -EINVAL;
-
- IWL_DEBUG_POWER(mvm, "%s device power down\n",
-   allow ? "allow" : "prevent");
+ char buf[64];
+ int bufsz = sizeof(buf);
+ int pos = 0;
 
- /*
-  * TODO: Send REPLY_DEBUG_CMD (0xf0) when FW support it
-  */
+ pos += scnprintf(buf+pos, bufsz-pos, "disable_power_off_d0=%d\n",
+    mvm->disable_power_off);
+ pos += scnprintf(buf+pos, bufsz-pos, "disable_power_off_d3=%d\n",
+    mvm->disable_power_off_d3);
 
- return count;
+ return simple_read_from_buffer(user_buf, count, ppos, buf, pos);
 }
 
-static ssize_t iwl_dbgfs_power_down_d3_allow_write(struct file *file,
-         const char __user *user_buf,
-         size_t count, loff_t *ppos)
+static ssize_t iwl_dbgfs_disable_power_off_write(struct iwl_mvm *mvm, char *buf,
+       size_t count, loff_t *ppos)
 {
- struct iwl_mvm *mvm = file->private_data;
- char buf[8] = {};
- int allow;
+ int ret, val;
 
- if (copy_from_user(buf, user_buf, sizeof(buf)))
-  return -EFAULT;
+ if (!mvm->ucode_loaded)
+  return -EIO;
 
- if (sscanf(buf, "%d", &allow) != 1)
+ if (!strncmp("disable_power_off_d0=", buf, 21)) {
+  if (sscanf(buf + 21, "%d", &val) != 1)
+   return -EINVAL;
+  mvm->disable_power_off = val;
+ } else if (!strncmp("disable_power_off_d3=", buf, 21)) {
+  if (sscanf(buf + 21, "%d", &val) != 1)
+   return -EINVAL;
+  mvm->disable_power_off_d3 = val;
+ } else {
   return -EINVAL;
-
- IWL_DEBUG_POWER(mvm, "%s device power down in d3\n",
-   allow ? "allow" : "prevent");
-
- /*
-  * TODO: When WoWLAN FW alive notification happens, driver will send
-  * REPLY_DEBUG_CMD setting power_down_allow flag according to
-  * mvm->prevent_power_down_d3
-  */
- mvm->prevent_power_down_d3 = !allow;
-
- return count;
-}
-
-static ssize_t iwl_dbgfs_mac_params_read(struct file *file,
-      char __user *user_buf,
-      size_t count, loff_t *ppos)
-{
- struct ieee80211_vif *vif = file->private_data;
- struct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);
- struct iwl_mvm *mvm = mvmvif->dbgfs_data;
- u8 ap_sta_id;
- struct ieee80211_chanctx_conf *chanctx_conf;
- char buf[512];
- int bufsz = sizeof(buf);
- int pos = 0;
- int i;
-
- mutex_lock(&mvm->mutex);
-
- ap_sta_id = mvmvif->ap_sta_id;
-
- pos += scnprintf(buf+pos, bufsz-pos, "mac id/color: %d / %d\n",
-    mvmvif->id, mvmvif->color);
- pos += scnprintf(buf+pos, bufsz-pos, "bssid: %pM\n",
-    vif->bss_conf.bssid);
- pos += scnprintf(buf+pos, bufsz-pos, "QoS:\n");
- for (i = 0; i < ARRAY_SIZE(mvmvif->queue_params); i++) {
-  pos += scnprintf(buf+pos, bufsz-pos,
-     "\t%d: txop:%d - cw_min:%d - cw_max = %d - aifs = %d upasd = %d\n",
-     i, mvmvif->queue_params[i].txop,
-     mvmvif->queue_params[i].cw_min,
-     mvmvif->queue_params[i].cw_max,
-     mvmvif->queue_params[i].aifs,
-     mvmvif->queue_params[i].uapsd);
- }
-
- if (vif->type == NL80211_IFTYPE_STATION &&
-     ap_sta_id != IWL_MVM_STATION_COUNT) {
-  struct ieee80211_sta *sta;
-  struct iwl_mvm_sta *mvm_sta;
-
-  sta = rcu_dereference_protected(mvm->fw_id_to_mac_id[ap_sta_id],
-      lockdep_is_held(&mvm->mutex));
-  mvm_sta = (void *)sta->drv_priv;
-  pos += scnprintf(buf+pos, bufsz-pos,
-     "ap_sta_id %d - reduced Tx power %d\n",
-     ap_sta_id, mvm_sta->bt_reduced_txpower);
- }
-
- rcu_read_lock();
- chanctx_conf = rcu_dereference(vif->chanctx_conf);
- if (chanctx_conf) {
-  pos += scnprintf(buf+pos, bufsz-pos,
-     "idle rx chains %d, active rx chains: %d\n",
-     chanctx_conf->rx_chains_static,
-     chanctx_conf->rx_chains_dynamic);
  }
- rcu_read_unlock();
 
+ mutex_lock(&mvm->mutex);
+ ret = iwl_mvm_power_update_device(mvm);
  mutex_unlock(&mvm->mutex);
 
- return simple_read_from_buffer(user_buf, count, ppos, buf, pos);
+ return ret ?: count;
 }
 
 #define BT_MBOX_MSG(_notif, _num, _field)         \
@@ -440,15 +379,24 @@ static ssize_t iwl_dbgfs_bt_notif_read(struct file *file, char __user *user_buf,
  BT_MBOX_PRINT(3, UPDATE_REQUEST, true);
 
  pos += scnprintf(buf+pos, bufsz-pos, "bt_status = %d\n",
-      notif->bt_status);
+    notif->bt_status);
  pos += scnprintf(buf+pos, bufsz-pos, "bt_open_conn = %d\n",
-      notif->bt_open_conn);
+    notif->bt_open_conn);
  pos += scnprintf(buf+pos, bufsz-pos, "bt_traffic_load = %d\n",
-      notif->bt_traffic_load);
+    notif->bt_traffic_load);
  pos += scnprintf(buf+pos, bufsz-pos, "bt_agg_traffic_load = %d\n",
-      notif->bt_agg_traffic_load);
+    notif->bt_agg_traffic_load);
  pos += scnprintf(buf+pos, bufsz-pos, "bt_ci_compliance = %d\n",
-      notif->bt_ci_compliance);
+    notif->bt_ci_compliance);
+ pos += scnprintf(buf+pos, bufsz-pos, "primary_ch_lut = %d\n",
+    le32_to_cpu(notif->primary_ch_lut));
+ pos += scnprintf(buf+pos, bufsz-pos, "secondary_ch_lut = %d\n",
+    le32_to_cpu(notif->secondary_ch_lut));
+ pos += scnprintf(buf+pos, bufsz-pos, "bt_activity_grading = %d\n",
+    le32_to_cpu(notif->bt_activity_grading));
+ pos += scnprintf(buf+pos, bufsz-pos,
+    "antenna isolation = %d CORUN LUT index = %d\n",
+    mvm->last_ant_isol, mvm->last_corun_lut);
 
  mutex_unlock(&mvm->mutex);
 
@@ -459,89 +407,785 @@ static ssize_t iwl_dbgfs_bt_notif_read(struct file *file, char __user *user_buf,
 }
 #undef BT_MBOX_PRINT
 
-static ssize_t iwl_dbgfs_fw_restart_write(struct file *file,
-       const char __user *user_buf,
-       size_t count, loff_t *ppos)
+static ssize_t iwl_dbgfs_bt_cmd_read(struct file *file, char __user *user_buf,
+         size_t count, loff_t *ppos)
 {
  struct iwl_mvm *mvm = file->private_data;
- bool restart_fw = iwlwifi_mod_params.restart_fw;
+ struct iwl_bt_coex_ci_cmd *cmd = &mvm->last_bt_ci_cmd;
+ char buf[256];
+ int bufsz = sizeof(buf);
+ int pos = 0;
+
+ mutex_lock(&mvm->mutex);
+
+ pos += scnprintf(buf+pos, bufsz-pos, "Channel inhibition CMD\n");
+ pos += scnprintf(buf+pos, bufsz-pos,
+         "\tPrimary Channel Bitmap 0x%016llx Fat: %d\n",
+         le64_to_cpu(cmd->bt_primary_ci),
+         !!cmd->co_run_bw_primary);
+ pos += scnprintf(buf+pos, bufsz-pos,
+         "\tSecondary Channel Bitmap 0x%016llx Fat: %d\n",
+         le64_to_cpu(cmd->bt_secondary_ci),
+         !!cmd->co_run_bw_secondary);
+
+ pos += scnprintf(buf+pos, bufsz-pos, "BT Configuration CMD\n");
+ pos += scnprintf(buf+pos, bufsz-pos, "\tACK Kill Mask 0x%08x\n",
+    iwl_bt_ack_kill_msk[mvm->bt_kill_msk]);
+ pos += scnprintf(buf+pos, bufsz-pos, "\tCTS Kill Mask 0x%08x\n",
+    iwl_bt_cts_kill_msk[mvm->bt_kill_msk]);
+
+ mutex_unlock(&mvm->mutex);
+
+ return simple_read_from_buffer(user_buf, count, ppos, buf, pos);
+}
+
+static ssize_t
+iwl_dbgfs_bt_tx_prio_write(struct iwl_mvm *mvm, char *buf,
+      size_t count, loff_t *ppos)
+{
+ u32 bt_tx_prio;
+
+ if (sscanf(buf, "%u", &bt_tx_prio) != 1)
+  return -EINVAL;
+ if (bt_tx_prio > 4)
+  return -EINVAL;
+
+ mvm->bt_tx_prio = bt_tx_prio;
+
+ return count;
+}
+
+#define PRINT_STATS_LE32(_str, _val)     \
+    pos += scnprintf(buf + pos, bufsz - pos, \
+       fmt_table, _str,  \
+       le32_to_cpu(_val))
+
+static ssize_t iwl_dbgfs_fw_rx_stats_read(struct file *file,
+       char __user *user_buf, size_t count,
+       loff_t *ppos)
+{
+ struct iwl_mvm *mvm = file->private_data;
+ static const char *fmt_table = "\t%-30s %10u\n";
+ static const char *fmt_header = "%-32s\n";
+ int pos = 0;
+ char *buf;
+ int ret;
+ /* 43 is the size of each data line, 33 is the size of each header */
+ size_t bufsz =
+  ((sizeof(struct mvm_statistics_rx) / sizeof(__le32)) * 43) +
+  (4 * 33) + 1;
+
+ struct mvm_statistics_rx_phy *ofdm;
+ struct mvm_statistics_rx_phy *cck;
+ struct mvm_statistics_rx_non_phy *general;
+ struct mvm_statistics_rx_ht_phy *ht;
+
+ buf = kzalloc(bufsz, GFP_KERNEL);
+ if (!buf)
+  return -ENOMEM;
+
+ mutex_lock(&mvm->mutex);
+
+ ofdm = &mvm->rx_stats.ofdm;
+ cck = &mvm->rx_stats.cck;
+ general = &mvm->rx_stats.general;
+ ht = &mvm->rx_stats.ofdm_ht;
+
+ pos += scnprintf(buf + pos, bufsz - pos, fmt_header,
+    "Statistics_Rx - OFDM");
+ PRINT_STATS_LE32("ina_cnt", ofdm->ina_cnt);
+ PRINT_STATS_LE32("fina_cnt", ofdm->fina_cnt);
+ PRINT_STATS_LE32("plcp_err", ofdm->plcp_err);
+ PRINT_STATS_LE32("crc32_err", ofdm->crc32_err);
+ PRINT_STATS_LE32("overrun_err", ofdm->overrun_err);
+ PRINT_STATS_LE32("early_overrun_err", ofdm->early_overrun_err);
+ PRINT_STATS_LE32("crc32_good", ofdm->crc32_good);
+ PRINT_STATS_LE32("false_alarm_cnt", ofdm->false_alarm_cnt);
+ PRINT_STATS_LE32("fina_sync_err_cnt", ofdm->fina_sync_err_cnt);
+ PRINT_STATS_LE32("sfd_timeout", ofdm->sfd_timeout);
+ PRINT_STATS_LE32("fina_timeout", ofdm->fina_timeout);
+ PRINT_STATS_LE32("unresponded_rts", ofdm->unresponded_rts);
+ PRINT_STATS_LE32("rxe_frame_lmt_overrun",
+    ofdm->rxe_frame_limit_overrun);
+ PRINT_STATS_LE32("sent_ack_cnt", ofdm->sent_ack_cnt);
+ PRINT_STATS_LE32("sent_cts_cnt", ofdm->sent_cts_cnt);
+ PRINT_STATS_LE32("sent_ba_rsp_cnt", ofdm->sent_ba_rsp_cnt);
+ PRINT_STATS_LE32("dsp_self_kill", ofdm->dsp_self_kill);
+ PRINT_STATS_LE32("mh_format_err", ofdm->mh_format_err);
+ PRINT_STATS_LE32("re_acq_main_rssi_sum", ofdm->re_acq_main_rssi_sum);
+ PRINT_STATS_LE32("reserved", ofdm->reserved);
+
+ pos += scnprintf(buf + pos, bufsz - pos, fmt_header,
+    "Statistics_Rx - CCK");
+ PRINT_STATS_LE32("ina_cnt", cck->ina_cnt);
+ PRINT_STATS_LE32("fina_cnt", cck->fina_cnt);
+ PRINT_STATS_LE32("plcp_err", cck->plcp_err);
+ PRINT_STATS_LE32("crc32_err", cck->crc32_err);
+ PRINT_STATS_LE32("overrun_err", cck->overrun_err);
+ PRINT_STATS_LE32("early_overrun_err", cck->early_overrun_err);
+ PRINT_STATS_LE32("crc32_good", cck->crc32_good);
+ PRINT_STATS_LE32("false_alarm_cnt", cck->false_alarm_cnt);
+ PRINT_STATS_LE32("fina_sync_err_cnt", cck->fina_sync_err_cnt);
+ PRINT_STATS_LE32("sfd_timeout", cck->sfd_timeout);
+ PRINT_STATS_LE32("fina_timeout", cck->fina_timeout);
+ PRINT_STATS_LE32("unresponded_rts", cck->unresponded_rts);
+ PRINT_STATS_LE32("rxe_frame_lmt_overrun",
+    cck->rxe_frame_limit_overrun);
+ PRINT_STATS_LE32("sent_ack_cnt", cck->sent_ack_cnt);
+ PRINT_STATS_LE32("sent_cts_cnt", cck->sent_cts_cnt);
+ PRINT_STATS_LE32("sent_ba_rsp_cnt", cck->sent_ba_rsp_cnt);
+ PRINT_STATS_LE32("dsp_self_kill", cck->dsp_self_kill);
+ PRINT_STATS_LE32("mh_format_err", cck->mh_format_err);
+ PRINT_STATS_LE32("re_acq_main_rssi_sum", cck->re_acq_main_rssi_sum);
+ PRINT_STATS_LE32("reserved", cck->reserved);
+
+ pos += scnprintf(buf + pos, bufsz - pos, fmt_header,
+    "Statistics_Rx - GENERAL");
+ PRINT_STATS_LE32("bogus_cts", general->bogus_cts);
+ PRINT_STATS_LE32("bogus_ack", general->bogus_ack);
+ PRINT_STATS_LE32("non_bssid_frames", general->non_bssid_frames);
+ PRINT_STATS_LE32("filtered_frames", general->filtered_frames);
+ PRINT_STATS_LE32("non_channel_beacons", general->non_channel_beacons);
+ PRINT_STATS_LE32("channel_beacons", general->channel_beacons);
+ PRINT_STATS_LE32("num_missed_bcon", general->num_missed_bcon);
+ PRINT_STATS_LE32("adc_rx_saturation_time",
+    general->adc_rx_saturation_time);
+ PRINT_STATS_LE32("ina_detection_search_time",
+    general->ina_detection_search_time);
+ PRINT_STATS_LE32("beacon_silence_rssi_a",
+    general->beacon_silence_rssi_a);
+ PRINT_STATS_LE32("beacon_silence_rssi_b",
+    general->beacon_silence_rssi_b);
+ PRINT_STATS_LE32("beacon_silence_rssi_c",
+    general->beacon_silence_rssi_c);
+ PRINT_STATS_LE32("interference_data_flag",
+    general->interference_data_flag);
+ PRINT_STATS_LE32("channel_load", general->channel_load);
+ PRINT_STATS_LE32("dsp_false_alarms", general->dsp_false_alarms);
+ PRINT_STATS_LE32("beacon_rssi_a", general->beacon_rssi_a);
+ PRINT_STATS_LE32("beacon_rssi_b", general->beacon_rssi_b);
+ PRINT_STATS_LE32("beacon_rssi_c", general->beacon_rssi_c);
+ PRINT_STATS_LE32("beacon_energy_a", general->beacon_energy_a);
+ PRINT_STATS_LE32("beacon_energy_b", general->beacon_energy_b);
+ PRINT_STATS_LE32("beacon_energy_c", general->beacon_energy_c);
+ PRINT_STATS_LE32("num_bt_kills", general->num_bt_kills);
+ PRINT_STATS_LE32("mac_id", general->mac_id);
+ PRINT_STATS_LE32("directed_data_mpdu", general->directed_data_mpdu);
+
+ pos += scnprintf(buf + pos, bufsz - pos, fmt_header,
+    "Statistics_Rx - HT");
+ PRINT_STATS_LE32("plcp_err", ht->plcp_err);
+ PRINT_STATS_LE32("overrun_err", ht->overrun_err);
+ PRINT_STATS_LE32("early_overrun_err", ht->early_overrun_err);
+ PRINT_STATS_LE32("crc32_good", ht->crc32_good);
+ PRINT_STATS_LE32("crc32_err", ht->crc32_err);
+ PRINT_STATS_LE32("mh_format_err", ht->mh_format_err);
+ PRINT_STATS_LE32("agg_crc32_good", ht->agg_crc32_good);
+ PRINT_STATS_LE32("agg_mpdu_cnt", ht->agg_mpdu_cnt);
+ PRINT_STATS_LE32("agg_cnt", ht->agg_cnt);
+ PRINT_STATS_LE32("unsupport_mcs", ht->unsupport_mcs);
+
+ mutex_unlock(&mvm->mutex);
+
+ ret = simple_read_from_buffer(user_buf, count, ppos, buf, pos);
+ kfree(buf);
+
+ return ret;
+}
+#undef PRINT_STAT_LE32
+
+static ssize_t iwl_dbgfs_frame_stats_read(struct iwl_mvm *mvm,
+       char __user *user_buf, size_t count,
+       loff_t *ppos,
+       struct iwl_mvm_frame_stats *stats)
+{
+ char *buff, *pos, *endpos;
+ int idx, i;
  int ret;
+ static const size_t bufsz = 1024;
+
+ buff = kmalloc(bufsz, GFP_KERNEL);
+ if (!buff)
+  return -ENOMEM;
+
+ spin_lock_bh(&mvm->drv_stats_lock);
+
+ pos = buff;
+ endpos = pos + bufsz;
+
+ pos += scnprintf(pos, endpos - pos,
+    "Legacy/HT/VHT\t:\t%d/%d/%d\n",
+    stats->legacy_frames,
+    stats->ht_frames,
+    stats->vht_frames);
+ pos += scnprintf(pos, endpos - pos, "20/40/80\t:\t%d/%d/%d\n",
+    stats->bw_20_frames,
+    stats->bw_40_frames,
+    stats->bw_80_frames);
+ pos += scnprintf(pos, endpos - pos, "NGI/SGI\t\t:\t%d/%d\n",
+    stats->ngi_frames,
+    stats->sgi_frames);
+ pos += scnprintf(pos, endpos - pos, "SISO/MIMO2\t:\t%d/%d\n",
+    stats->siso_frames,
+    stats->mimo2_frames);
+ pos += scnprintf(pos, endpos - pos, "FAIL/SCSS\t:\t%d/%d\n",
+    stats->fail_frames,
+    stats->success_frames);
+ pos += scnprintf(pos, endpos - pos, "MPDUs agg\t:\t%d\n",
+    stats->agg_frames);
+ pos += scnprintf(pos, endpos - pos, "A-MPDUs\t\t:\t%d\n",
+    stats->ampdu_count);
+ pos += scnprintf(pos, endpos - pos, "Avg MPDUs/A-MPDU:\t%d\n",
+    stats->ampdu_count > 0 ?
+    (stats->agg_frames / stats->ampdu_count) : 0);
+
+ pos += scnprintf(pos, endpos - pos, "Last Rates\n");
+
+ idx = stats->last_frame_idx - 1;
+ for (i = 0; i < ARRAY_SIZE(stats->last_rates); i++) {
+  idx = (idx + 1) % ARRAY_SIZE(stats->last_rates);
+  if (stats->last_rates[idx] == 0)
+   continue;
+  pos += scnprintf(pos, endpos - pos, "Rate[%d]: ",
+     (int)(ARRAY_SIZE(stats->last_rates) - i));
+  pos += rs_pretty_print_rate(pos, stats->last_rates[idx]);
+ }
+ spin_unlock_bh(&mvm->drv_stats_lock);
 
- iwlwifi_mod_params.restart_fw = true;
+ ret = simple_read_from_buffer(user_buf, count, ppos, buff, pos - buff);
+ kfree(buff);
+
+ return ret;
+}
+
+static ssize_t iwl_dbgfs_drv_rx_stats_read(struct file *file,
+        char __user *user_buf, size_t count,
+        loff_t *ppos)
+{
+ struct iwl_mvm *mvm = file->private_data;
+
+ return iwl_dbgfs_frame_stats_read(mvm, user_buf, count, ppos,
+       &mvm->drv_rx_stats);
+}
+
+static ssize_t iwl_dbgfs_fw_restart_write(struct iwl_mvm *mvm, char *buf,
+       size_t count, loff_t *ppos)
+{
+ int ret;
 
  mutex_lock(&mvm->mutex);
 
+ /* allow one more restart that we're provoking here */
+ if (mvm->restart_fw >= 0)
+  mvm->restart_fw++;
+
  /* take the return value to make compiler happy - it will fail anyway */
- ret = iwl_mvm_send_cmd_pdu(mvm, REPLY_ERROR, CMD_SYNC, 0, NULL);
+ ret = iwl_mvm_send_cmd_pdu(mvm, REPLY_ERROR, 0, 0, NULL);
 
  mutex_unlock(&mvm->mutex);
 
- iwlwifi_mod_params.restart_fw = restart_fw;
+ return count;
+}
+
+static ssize_t iwl_dbgfs_fw_nmi_write(struct iwl_mvm *mvm, char *buf,
+          size_t count, loff_t *ppos)
+{
+ iwl_force_nmi(mvm->trans);
 
  return count;
 }
 
-#define MVM_DEBUGFS_READ_FILE_OPS(name)     \
-static const struct file_operations iwl_dbgfs_##name##_ops = { \
- .read = iwl_dbgfs_##name##_read,    \
- .open = simple_open,      \
- .llseek = generic_file_llseek,     \
+static ssize_t
+iwl_dbgfs_scan_ant_rxchain_read(struct file *file,
+    char __user *user_buf,
+    size_t count, loff_t *ppos)
+{
+ struct iwl_mvm *mvm = file->private_data;
+ int pos = 0;
+ char buf[32];
+ const size_t bufsz = sizeof(buf);
+
+ /* print which antennas were set for the scan command by the user */
+ pos += scnprintf(buf + pos, bufsz - pos, "Antennas for scan: ");
+ if (mvm->scan_rx_ant & ANT_A)
+  pos += scnprintf(buf + pos, bufsz - pos, "A");
+ if (mvm->scan_rx_ant & ANT_B)
+  pos += scnprintf(buf + pos, bufsz - pos, "B");
+ if (mvm->scan_rx_ant & ANT_C)
+  pos += scnprintf(buf + pos, bufsz - pos, "C");
+ pos += scnprintf(buf + pos, bufsz - pos, " (%hhx)\n", mvm->scan_rx_ant);
+
+ return simple_read_from_buffer(user_buf, count, ppos, buf, pos);
 }
 
-#define MVM_DEBUGFS_READ_WRITE_FILE_OPS(name)    \
-static const struct file_operations iwl_dbgfs_##name##_ops = { \
- .write = iwl_dbgfs_##name##_write,    \
- .read = iwl_dbgfs_##name##_read,    \
- .open = simple_open,      \
- .llseek = generic_file_llseek,     \
-};
+static ssize_t
+iwl_dbgfs_scan_ant_rxchain_write(struct iwl_mvm *mvm, char *buf,
+     size_t count, loff_t *ppos)
+{
+ u8 scan_rx_ant;
 
-#define MVM_DEBUGFS_WRITE_FILE_OPS(name)    \
-static const struct file_operations iwl_dbgfs_##name##_ops = { \
- .write = iwl_dbgfs_##name##_write,    \
- .open = simple_open,      \
- .llseek = generic_file_llseek,     \
-};
+ if (sscanf(buf, "%hhx", &scan_rx_ant) != 1)
+  return -EINVAL;
+ if (scan_rx_ant > ANT_ABC)
+  return -EINVAL;
+ if (scan_rx_ant & ~mvm->fw->valid_rx_ant)
+  return -EINVAL;
 
-#define MVM_DEBUGFS_ADD_FILE(name, parent, mode) do {   \
-  if (!debugfs_create_file(#name, mode, parent, mvm, \
-      &iwl_dbgfs_##name##_ops)) \
-   goto err;     \
- } while (0)
+ mvm->scan_rx_ant = scan_rx_ant;
+
+ return count;
+}
+
+#define ADD_TEXT(...) pos += scnprintf(buf + pos, bufsz - pos, __VA_ARGS__)
+#ifdef CONFIG_IWLWIFI_BCAST_FILTERING
+static ssize_t iwl_dbgfs_bcast_filters_read(struct file *file,
+         char __user *user_buf,
+         size_t count, loff_t *ppos)
+{
+ struct iwl_mvm *mvm = file->private_data;
+ struct iwl_bcast_filter_cmd cmd;
+ const struct iwl_fw_bcast_filter *filter;
+ char *buf;
+ int bufsz = 1024;
+ int i, j, pos = 0;
+ ssize_t ret;
+
+ buf = kzalloc(bufsz, GFP_KERNEL);
+ if (!buf)
+  return -ENOMEM;
+
+ mutex_lock(&mvm->mutex);
+ if (!iwl_mvm_bcast_filter_build_cmd(mvm, &cmd)) {
+  ADD_TEXT("None\n");
+  mutex_unlock(&mvm->mutex);
+  goto out;
+ }
+ mutex_unlock(&mvm->mutex);
+
+ for (i = 0; cmd.filters[i].attrs[0].mask; i++) {
+  filter = &cmd.filters[i];
+
+  ADD_TEXT("Filter [%d]:\n", i);
+  ADD_TEXT("\tDiscard=%d\n", filter->discard);
+  ADD_TEXT("\tFrame Type: %s\n",
+    filter->frame_type ? "IPv4" : "Generic");
+
+  for (j = 0; j < ARRAY_SIZE(filter->attrs); j++) {
+   const struct iwl_fw_bcast_filter_attr *attr;
+
+   attr = &filter->attrs[j];
+   if (!attr->mask)
+    break;
+
+   ADD_TEXT("\tAttr [%d]: offset=%d (from %s), mask=0x%x, value=0x%x reserved=0x%x\n",
+     j, attr->offset,
+     attr->offset_type ? "IP End" :
+           "Payload Start",
+     be32_to_cpu(attr->mask),
+     be32_to_cpu(attr->val),
+     le16_to_cpu(attr->reserved1));
+  }
+ }
+out:
+ ret = simple_read_from_buffer(user_buf, count, ppos, buf, pos);
+ kfree(buf);
+ return ret;
+}
+
+static ssize_t iwl_dbgfs_bcast_filters_write(struct iwl_mvm *mvm, char *buf,
+          size_t count, loff_t *ppos)
+{
+ int pos, next_pos;
+ struct iwl_fw_bcast_filter filter = {};
+ struct iwl_bcast_filter_cmd cmd;
+ u32 filter_id, attr_id, mask, value;
+ int err = 0;
+
+ if (sscanf(buf, "%d %hhi %hhi %n", &filter_id, &filter.discard,
+     &filter.frame_type, &pos) != 3)
+  return -EINVAL;
+
+ if (filter_id >= ARRAY_SIZE(mvm->dbgfs_bcast_filtering.cmd.filters) ||
+     filter.frame_type > BCAST_FILTER_FRAME_TYPE_IPV4)
+  return -EINVAL;
+
+ for (attr_id = 0; attr_id < ARRAY_SIZE(filter.attrs);
+      attr_id++) {
+  struct iwl_fw_bcast_filter_attr *attr =
+    &filter.attrs[attr_id];
+
+  if (pos >= count)
+   break;
+
+  if (sscanf(&buf[pos], "%hhi %hhi %i %i %n",
+      &attr->offset, &attr->offset_type,
+      &mask, &value, &next_pos) != 4)
+   return -EINVAL;
+
+  attr->mask = cpu_to_be32(mask);
+  attr->val = cpu_to_be32(value);
+  if (mask)
+   filter.num_attrs++;
+
+  pos += next_pos;
+ }
+
+ mutex_lock(&mvm->mutex);
+ memcpy(&mvm->dbgfs_bcast_filtering.cmd.filters[filter_id],
+        &filter, sizeof(filter));
+
+ /* send updated bcast filtering configuration */
+ if (mvm->dbgfs_bcast_filtering.override &&
+     iwl_mvm_bcast_filter_build_cmd(mvm, &cmd))
+  err = iwl_mvm_send_cmd_pdu(mvm, BCAST_FILTER_CMD, 0,
+        sizeof(cmd), &cmd);
+ mutex_unlock(&mvm->mutex);
+
+ return err ?: count;
+}
+
+static ssize_t iwl_dbgfs_bcast_filters_macs_read(struct file *file,
+       char __user *user_buf,
+       size_t count, loff_t *ppos)
+{
+ struct iwl_mvm *mvm = file->private_data;
+ struct iwl_bcast_filter_cmd cmd;
+ char *buf;
+ int bufsz = 1024;
+ int i, pos = 0;
+ ssize_t ret;
+
+ buf = kzalloc(bufsz, GFP_KERNEL);
+ if (!buf)
+  return -ENOMEM;
+
+ mutex_lock(&mvm->mutex);
+ if (!iwl_mvm_bcast_filter_build_cmd(mvm, &cmd)) {
+  ADD_TEXT("None\n");
+  mutex_unlock(&mvm->mutex);
+  goto out;
+ }
+ mutex_unlock(&mvm->mutex);
+
+ for (i = 0; i < ARRAY_SIZE(cmd.macs); i++) {
+  const struct iwl_fw_bcast_mac *mac = &cmd.macs[i];
+
+  ADD_TEXT("Mac [%d]: discard=%d attached_filters=0x%x\n",
+    i, mac->default_discard, mac->attached_filters);
+ }
+out:
+ ret = simple_read_from_buffer(user_buf, count, ppos, buf, pos);
+ kfree(buf);
+ return ret;
+}
+
+static ssize_t iwl_dbgfs_bcast_filters_macs_write(struct iwl_mvm *mvm,
+        char *buf, size_t count,
+        loff_t *ppos)
+{
+ struct iwl_bcast_filter_cmd cmd;
+ struct iwl_fw_bcast_mac mac = {};
+ u32 mac_id, attached_filters;
+ int err = 0;
+
+ if (!mvm->bcast_filters)
+  return -ENOENT;
+
+ if (sscanf(buf, "%d %hhi %i", &mac_id, &mac.default_discard,
+     &attached_filters) != 3)
+  return -EINVAL;
+
+ if (mac_id >= ARRAY_SIZE(cmd.macs) ||
+     mac.default_discard > 1 ||
+     attached_filters >= BIT(ARRAY_SIZE(cmd.filters)))
+  return -EINVAL;
+
+ mac.attached_filters = cpu_to_le16(attached_filters);
+
+ mutex_lock(&mvm->mutex);
+ memcpy(&mvm->dbgfs_bcast_filtering.cmd.macs[mac_id],
+        &mac, sizeof(mac));
+
+ /* send updated bcast filtering configuration */
+ if (mvm->dbgfs_bcast_filtering.override &&
+     iwl_mvm_bcast_filter_build_cmd(mvm, &cmd))
+  err = iwl_mvm_send_cmd_pdu(mvm, BCAST_FILTER_CMD, 0,
+        sizeof(cmd), &cmd);
+ mutex_unlock(&mvm->mutex);
+
+ return err ?: count;
+}
+#endif
+
+#ifdef CONFIG_PM_SLEEP
+static ssize_t iwl_dbgfs_d3_sram_write(struct iwl_mvm *mvm, char *buf,
+           size_t count, loff_t *ppos)
+{
+ int store;
+
+ if (sscanf(buf, "%d", &store) != 1)
+  return -EINVAL;
+
+ mvm->store_d3_resume_sram = store;
+
+ return count;
+}
+
+static ssize_t iwl_dbgfs_d3_sram_read(struct file *file, char __user *user_buf,
+          size_t count, loff_t *ppos)
+{
+ struct iwl_mvm *mvm = file->private_data;
+ const struct fw_img *img;
+ int ofs, len, pos = 0;
+ size_t bufsz, ret;
+ char *buf;
+ u8 *ptr = mvm->d3_resume_sram;
 
-#define MVM_DEBUGFS_ADD_FILE_VIF(name, parent, mode) do {  \
-  if (!debugfs_create_file(#name, mode, parent, vif, \
+ img = &mvm->fw->img[IWL_UCODE_WOWLAN];
+ len = img->sec[IWL_UCODE_SECTION_DATA].len;
+
+ bufsz = len * 4 + 256;
+ buf = kzalloc(bufsz, GFP_KERNEL);
+ if (!buf)
+  return -ENOMEM;
+
+ pos += scnprintf(buf, bufsz, "D3 SRAM capture: %sabled\n",
+    mvm->store_d3_resume_sram ? "en" : "dis");
+
+ if (ptr) {
+  for (ofs = 0; ofs < len; ofs += 16) {
+   pos += scnprintf(buf + pos, bufsz - pos,
+      "0x%.4x ", ofs);
+   hex_dump_to_buffer(ptr + ofs, 16, 16, 1, buf + pos,
+        bufsz - pos, false);
+   pos += strlen(buf + pos);
+   if (bufsz - pos > 0)
+    buf[pos++] = '\n';
+  }
+ } else {
+  pos += scnprintf(buf + pos, bufsz - pos,
+     "(no data captured)\n");
+ }
+
+ ret = simple_read_from_buffer(user_buf, count, ppos, buf, pos);
+
+ kfree(buf);
+
+ return ret;
+}
+#endif
+
+#define PRINT_MVM_REF(ref) do {     \
+ if (test_bit(ref, mvm->ref_bitmap))   \
+  pos += scnprintf(buf + pos, bufsz - pos, \
+     "\t(0x%lx) %s\n",  \
+     BIT(ref), #ref);  \
+} while (0)
+
+static ssize_t iwl_dbgfs_d0i3_refs_read(struct file *file,
+     char __user *user_buf,
+     size_t count, loff_t *ppos)
+{
+ struct iwl_mvm *mvm = file->private_data;
+ int pos = 0;
+ char buf[256];
+ const size_t bufsz = sizeof(buf);
+
+ pos += scnprintf(buf + pos, bufsz - pos, "taken mvm refs: 0x%lx\n",
+    mvm->ref_bitmap[0]);
+
+ PRINT_MVM_REF(IWL_MVM_REF_UCODE_DOWN);
+ PRINT_MVM_REF(IWL_MVM_REF_SCAN);
+ PRINT_MVM_REF(IWL_MVM_REF_ROC);
+ PRINT_MVM_REF(IWL_MVM_REF_P2P_CLIENT);
+ PRINT_MVM_REF(IWL_MVM_REF_AP_IBSS);
+ PRINT_MVM_REF(IWL_MVM_REF_USER);
+ PRINT_MVM_REF(IWL_MVM_REF_EXIT_WORK);
+
+ return simple_read_from_buffer(user_buf, count, ppos, buf, pos);
+}
+
+static ssize_t iwl_dbgfs_d0i3_refs_write(struct iwl_mvm *mvm, char *buf,
+      size_t count, loff_t *ppos)
+{
+ unsigned long value;
+ int ret;
+ bool taken;
+
+ ret = kstrtoul(buf, 10, &value);
+ if (ret < 0)
+  return ret;
+
+ mutex_lock(&mvm->mutex);
+
+ taken = test_bit(IWL_MVM_REF_USER, mvm->ref_bitmap);
+ if (value == 1 && !taken)
+  iwl_mvm_ref(mvm, IWL_MVM_REF_USER);
+ else if (value == 0 && taken)
+  iwl_mvm_unref(mvm, IWL_MVM_REF_USER);
+ else
+  ret = -EINVAL;
+
+ mutex_unlock(&mvm->mutex);
+
+ if (ret < 0)
+  return ret;
+ return count;
+}
+
+#define MVM_DEBUGFS_WRITE_FILE_OPS(name, bufsz) \
+ _MVM_DEBUGFS_WRITE_FILE_OPS(name, bufsz, struct iwl_mvm)
+#define MVM_DEBUGFS_READ_WRITE_FILE_OPS(name, bufsz) \
+ _MVM_DEBUGFS_READ_WRITE_FILE_OPS(name, bufsz, struct iwl_mvm)
+#define MVM_DEBUGFS_ADD_FILE_ALIAS(alias, name, parent, mode) do { \
+  if (!debugfs_create_file(alias, mode, parent, mvm, \
       &iwl_dbgfs_##name##_ops)) \
    goto err;     \
  } while (0)
+#define MVM_DEBUGFS_ADD_FILE(name, parent, mode) \
+ MVM_DEBUGFS_ADD_FILE_ALIAS(#name, name, parent, mode)
+
+static ssize_t
+iwl_dbgfs_prph_reg_read(struct file *file,
+   char __user *user_buf,
+   size_t count, loff_t *ppos)
+{
+ struct iwl_mvm *mvm = file->private_data;
+ int pos = 0;
+ char buf[32];
+ const size_t bufsz = sizeof(buf);
+
+ if (!mvm->dbgfs_prph_reg_addr)
+  return -EINVAL;
+
+ pos += scnprintf(buf + pos, bufsz - pos, "Reg 0x%x: (0x%x)\n",
+  mvm->dbgfs_prph_reg_addr,
+  iwl_read_prph(mvm->trans, mvm->dbgfs_prph_reg_addr));
+
+ return simple_read_from_buffer(user_buf, count, ppos, buf, pos);
+}
+
+static ssize_t
+iwl_dbgfs_prph_reg_write(struct iwl_mvm *mvm, char *buf,
+    size_t count, loff_t *ppos)
+{
+ u8 args;
+ u32 value;
+
+ args = sscanf(buf, "%i %i", &mvm->dbgfs_prph_reg_addr, &value);
+ /* if we only want to set the reg address - nothing more to do */
+ if (args == 1)
+  goto out;
+
+ /* otherwise, make sure we have both address and value */
+ if (args != 2)
+  return -EINVAL;
+
+ iwl_write_prph(mvm->trans, mvm->dbgfs_prph_reg_addr, value);
+out:
+ return count;
+}
+
+MVM_DEBUGFS_READ_WRITE_FILE_OPS(prph_reg, 64);
 
 /* Device wide debugfs entries */
-MVM_DEBUGFS_WRITE_FILE_OPS(tx_flush);
-MVM_DEBUGFS_WRITE_FILE_OPS(sta_drain);
-MVM_DEBUGFS_READ_WRITE_FILE_OPS(sram);
+MVM_DEBUGFS_WRITE_FILE_OPS(tx_flush, 16);
+MVM_DEBUGFS_WRITE_FILE_OPS(sta_drain, 8);
+MVM_DEBUGFS_READ_WRITE_FILE_OPS(sram, 64);
 MVM_DEBUGFS_READ_FILE_OPS(stations);
 MVM_DEBUGFS_READ_FILE_OPS(bt_notif);
-MVM_DEBUGFS_WRITE_FILE_OPS(power_down_allow);
-MVM_DEBUGFS_WRITE_FILE_OPS(power_down_d3_allow);
-MVM_DEBUGFS_WRITE_FILE_OPS(fw_restart);
+MVM_DEBUGFS_READ_FILE_OPS(bt_cmd);
+MVM_DEBUGFS_READ_WRITE_FILE_OPS(disable_power_off, 64);
+MVM_DEBUGFS_READ_FILE_OPS(fw_rx_stats);
+MVM_DEBUGFS_READ_FILE_OPS(drv_rx_stats);
+MVM_DEBUGFS_WRITE_FILE_OPS(fw_restart, 10);
+MVM_DEBUGFS_WRITE_FILE_OPS(fw_nmi, 10);
+MVM_DEBUGFS_WRITE_FILE_OPS(bt_tx_prio, 10);
+MVM_DEBUGFS_READ_WRITE_FILE_OPS(scan_ant_rxchain, 8);
+MVM_DEBUGFS_READ_WRITE_FILE_OPS(d0i3_refs, 8);
+
+static const struct file_operations iwl_dbgfs_fw_error_dump_ops = {
+ .open = iwl_dbgfs_fw_error_dump_open,
+ .read = iwl_dbgfs_fw_error_dump_read,
+ .release = iwl_dbgfs_fw_error_dump_release,
+};
+
+#ifdef CONFIG_IWLWIFI_BCAST_FILTERING
+MVM_DEBUGFS_READ_WRITE_FILE_OPS(bcast_filters, 256);
+MVM_DEBUGFS_READ_WRITE_FILE_OPS(bcast_filters_macs, 256);
+#endif
 
-/* Interface specific debugfs entries */
-MVM_DEBUGFS_READ_FILE_OPS(mac_params);
+#ifdef CONFIG_PM_SLEEP
+MVM_DEBUGFS_READ_WRITE_FILE_OPS(d3_sram, 8);
+#endif
 
 int iwl_mvm_dbgfs_register(struct iwl_mvm *mvm, struct dentry *dbgfs_dir)
 {
+ struct dentry *bcast_dir __maybe_unused;
  char buf[100];
 
+ spin_lock_init(&mvm->drv_stats_lock);
+
  mvm->debugfs_dir = dbgfs_dir;
 
  MVM_DEBUGFS_ADD_FILE(tx_flush, mvm->debugfs_dir, S_IWUSR);
  MVM_DEBUGFS_ADD_FILE(sta_drain, mvm->debugfs_dir, S_IWUSR);
  MVM_DEBUGFS_ADD_FILE(sram, mvm->debugfs_dir, S_IWUSR | S_IRUSR);
  MVM_DEBUGFS_ADD_FILE(stations, dbgfs_dir, S_IRUSR);
+ MVM_DEBUGFS_ADD_FILE(fw_error_dump, dbgfs_dir, S_IRUSR);
  MVM_DEBUGFS_ADD_FILE(bt_notif, dbgfs_dir, S_IRUSR);
- MVM_DEBUGFS_ADD_FILE(power_down_allow, mvm->debugfs_dir, S_IWUSR);
- MVM_DEBUGFS_ADD_FILE(power_down_d3_allow, mvm->debugfs_dir, S_IWUSR);
+ MVM_DEBUGFS_ADD_FILE(bt_cmd, dbgfs_dir, S_IRUSR);
+ MVM_DEBUGFS_ADD_FILE(disable_power_off, mvm->debugfs_dir,
+        S_IRUSR | S_IWUSR);
+ MVM_DEBUGFS_ADD_FILE(fw_rx_stats, mvm->debugfs_dir, S_IRUSR);
+ MVM_DEBUGFS_ADD_FILE(drv_rx_stats, mvm->debugfs_dir, S_IRUSR);
  MVM_DEBUGFS_ADD_FILE(fw_restart, mvm->debugfs_dir, S_IWUSR);
+ MVM_DEBUGFS_ADD_FILE(fw_nmi, mvm->debugfs_dir, S_IWUSR);
+ MVM_DEBUGFS_ADD_FILE(bt_tx_prio, mvm->debugfs_dir, S_IWUSR);
+ MVM_DEBUGFS_ADD_FILE(scan_ant_rxchain, mvm->debugfs_dir,
+        S_IWUSR | S_IRUSR);
+ MVM_DEBUGFS_ADD_FILE(prph_reg, mvm->debugfs_dir, S_IWUSR | S_IRUSR);
+ MVM_DEBUGFS_ADD_FILE(d0i3_refs, mvm->debugfs_dir, S_IRUSR | S_IWUSR);
+
+#ifdef CONFIG_IWLWIFI_BCAST_FILTERING
+ if (mvm->fw->ucode_capa.flags & IWL_UCODE_TLV_FLAGS_BCAST_FILTERING) {
+  bcast_dir = debugfs_create_dir("bcast_filtering",
+            mvm->debugfs_dir);
+  if (!bcast_dir)
+   goto err;
+
+  if (!debugfs_create_bool("override", S_IRUSR | S_IWUSR,
+    bcast_dir,
+    &mvm->dbgfs_bcast_filtering.override))
+   goto err;
+
+  MVM_DEBUGFS_ADD_FILE_ALIAS("filters", bcast_filters,
+        bcast_dir, S_IWUSR | S_IRUSR);
+  MVM_DEBUGFS_ADD_FILE_ALIAS("macs", bcast_filters_macs,
+        bcast_dir, S_IWUSR | S_IRUSR);
+ }
+#endif
+
+#ifdef CONFIG_PM_SLEEP
+ MVM_DEBUGFS_ADD_FILE(d3_sram, mvm->debugfs_dir, S_IRUSR | S_IWUSR);
+ MVM_DEBUGFS_ADD_FILE(d3_test, mvm->debugfs_dir, S_IRUSR);
+ if (!debugfs_create_bool("d3_wake_sysassert", S_IRUSR | S_IWUSR,
+     mvm->debugfs_dir, &mvm->d3_wake_sysassert))
+  goto err;
+#endif
+
+ if (!debugfs_create_blob("nvm_hw", S_IRUSR,
+      mvm->debugfs_dir, &mvm->nvm_hw_blob))
+  goto err;
+ if (!debugfs_create_blob("nvm_sw", S_IRUSR,
+      mvm->debugfs_dir, &mvm->nvm_sw_blob))
+  goto err;
+ if (!debugfs_create_blob("nvm_calib", S_IRUSR,
+      mvm->debugfs_dir, &mvm->nvm_calib_blob))
+  goto err;
+ if (!debugfs_create_blob("nvm_prod", S_IRUSR,
+      mvm->debugfs_dir, &mvm->nvm_prod_blob))
+  goto err;
 
  /*
   * Create a symlink with mac80211. It will be removed when mac80211
@@ -558,58 +1202,3 @@ err:
  IWL_ERR(mvm, "Can't create the mvm debugfs directory\n");
  return -ENOMEM;
 }
-
-void iwl_mvm_vif_dbgfs_register(struct iwl_mvm *mvm, struct ieee80211_vif *vif)
-{
- struct dentry *dbgfs_dir = vif->debugfs_dir;
- struct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);
- char buf[100];
-
- if (!dbgfs_dir)
-  return;
-
- mvmvif->dbgfs_dir = debugfs_create_dir("iwlmvm", dbgfs_dir);
- mvmvif->dbgfs_data = mvm;
-
- if (!mvmvif->dbgfs_dir) {
-  IWL_ERR(mvm, "Failed to create debugfs directory under %s\n",
-   dbgfs_dir->d_name.name);
-  return;
- }
-
- MVM_DEBUGFS_ADD_FILE_VIF(mac_params, mvmvif->dbgfs_dir,
-     S_IRUSR);
-
- /*
-  * Create symlink for convenience pointing to interface specific
-  * debugfs entries for the driver. For example, under
-  * /sys/kernel/debug/iwlwifi/0000\:02\:00.0/iwlmvm/
-  * find
-  * netdev:wlan0 -> ../../../ieee80211/phy0/netdev:wlan0/iwlmvm/
-  */
- snprintf(buf, 100, "../../../%s/%s/%s/%s",
-   dbgfs_dir->d_parent->d_parent->d_name.name,
-   dbgfs_dir->d_parent->d_name.name,
-   dbgfs_dir->d_name.name,
-   mvmvif->dbgfs_dir->d_name.name);
-
- mvmvif->dbgfs_slink = debugfs_create_symlink(dbgfs_dir->d_name.name,
-           mvm->debugfs_dir, buf);
- if (!mvmvif->dbgfs_slink)
-  IWL_ERR(mvm, "Can't create debugfs symbolic link under %s\n",
-   dbgfs_dir->d_name.name);
- return;
-err:
- IWL_ERR(mvm, "Can't create debugfs entity\n");
-}
-
-void iwl_mvm_vif_dbgfs_clean(struct iwl_mvm *mvm, struct ieee80211_vif *vif)
-{
- struct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);
-
- debugfs_remove(mvmvif->dbgfs_slink);
- mvmvif->dbgfs_slink = NULL;
-
- debugfs_remove_recursive(mvmvif->dbgfs_dir);
- mvmvif->dbgfs_dir = NULL;
-}
diff --git a/drivers/net/wireless/iwlwifi/mvm/debugfs.h b/drivers/net/wireless/iwlwifi/mvm/debugfs.h
new file mode 100644
index 0000000..e3a9774
--- /dev/null
+++ b/drivers/net/wireless/iwlwifi/mvm/debugfs.h
@@ -0,0 +1,101 @@
+/******************************************************************************
+ *
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ * redistributing this file, you may do so under either license.
+ *
+ * GPL LICENSE SUMMARY
+ *
+ * Copyright(c) 2012 - 2014 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110,
+ * USA
+ *
+ * The full GNU General Public License is included in this distribution
+ * in the file called COPYING.
+ *
+ * Contact Information:
+ *  Intel Linux Wireless <ilw@linux.intel.com>
+ * Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497
+ *
+ * BSD LICENSE
+ *
+ * Copyright(c) 2012 - 2014 Intel Corporation. All rights reserved.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *  * Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *  * Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *  * Neither the name Intel Corporation nor the names of its
+ *    contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *****************************************************************************/
+
+#define MVM_DEBUGFS_READ_FILE_OPS(name)     \
+static const struct file_operations iwl_dbgfs_##name##_ops = {  \
+ .read = iwl_dbgfs_##name##_read,    \
+ .open = simple_open,      \
+ .llseek = generic_file_llseek,     \
+}
+
+#define MVM_DEBUGFS_WRITE_WRAPPER(name, buflen, argtype)  \
+static ssize_t _iwl_dbgfs_##name##_write(struct file *file,  \
+      const char __user *user_buf, \
+      size_t count, loff_t *ppos) \
+{         \
+ argtype *arg = file->private_data;    \
+ char buf[buflen] = {};      \
+ size_t buf_size = min(count, sizeof(buf) -  1);   \
+         \
+ if (copy_from_user(buf, user_buf, buf_size))   \
+  return -EFAULT;      \
+         \
+ return iwl_dbgfs_##name##_write(arg, buf, buf_size, ppos); \
+}         \
+
+#define _MVM_DEBUGFS_READ_WRITE_FILE_OPS(name, buflen, argtype)  \
+MVM_DEBUGFS_WRITE_WRAPPER(name, buflen, argtype)   \
+static const struct file_operations iwl_dbgfs_##name##_ops = {  \
+ .write = _iwl_dbgfs_##name##_write,    \
+ .read = iwl_dbgfs_##name##_read,    \
+ .open = simple_open,      \
+ .llseek = generic_file_llseek,     \
+};
+
+#define _MVM_DEBUGFS_WRITE_FILE_OPS(name, buflen, argtype)  \
+MVM_DEBUGFS_WRITE_WRAPPER(name, buflen, argtype)   \
+static const struct file_operations iwl_dbgfs_##name##_ops = {  \
+ .write = _iwl_dbgfs_##name##_write,    \
+ .open = simple_open,      \
+ .llseek = generic_file_llseek,     \
+};
diff --git a/drivers/net/wireless/iwlwifi/mvm/fw-api-coex.h b/drivers/net/wireless/iwlwifi/mvm/fw-api-coex.h
new file mode 100644
index 0000000..5fe82c2
--- /dev/null
+++ b/drivers/net/wireless/iwlwifi/mvm/fw-api-coex.h
@@ -0,0 +1,358 @@
+/******************************************************************************
+ *
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ * redistributing this file, you may do so under either license.
+ *
+ * GPL LICENSE SUMMARY
+ *
+ * Copyright(c) 2013 - 2014 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110,
+ * USA
+ *
+ * The full GNU General Public License is included in this distribution
+ * in the file called COPYING.
+ *
+ * Contact Information:
+ *  Intel Linux Wireless <ilw@linux.intel.com>
+ * Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497
+ *
+ * BSD LICENSE
+ *
+ * Copyright(c) 2013 - 2014 Intel Corporation. All rights reserved.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *  * Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *  * Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *  * Neither the name Intel Corporation nor the names of its
+ *    contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *****************************************************************************/
+
+#ifndef __fw_api_bt_coex_h__
+#define __fw_api_bt_coex_h__
+
+#include <linux/types.h>
+#include <linux/bitops.h>
+
+#define BITS(nb) (BIT(nb) - 1)
+
+/**
+ * enum iwl_bt_coex_flags - flags for BT_COEX command
+ * @BT_COEX_MODE_POS:
+ * @BT_COEX_MODE_MSK:
+ * @BT_COEX_DISABLE:
+ * @BT_COEX_2W:
+ * @BT_COEX_3W:
+ * @BT_COEX_NW:
+ * @BT_COEX_SYNC2SCO:
+ * @BT_COEX_CORUNNING:
+ * @BT_COEX_MPLUT:
+ *
+ * The COEX_MODE must be set for each command. Even if it is not changed.
+ */
+enum iwl_bt_coex_flags {
+ BT_COEX_MODE_POS  = 3,
+ BT_COEX_MODE_MSK  = BITS(3) << BT_COEX_MODE_POS,
+ BT_COEX_DISABLE   = 0x0 << BT_COEX_MODE_POS,
+ BT_COEX_2W   = 0x1 << BT_COEX_MODE_POS,
+ BT_COEX_3W   = 0x2 << BT_COEX_MODE_POS,
+ BT_COEX_NW   = 0x3 << BT_COEX_MODE_POS,
+ BT_COEX_SYNC2SCO  = BIT(7),
+ BT_COEX_CORUNNING  = BIT(8),
+ BT_COEX_MPLUT   = BIT(9),
+};
+
+/*
+ * indicates what has changed in the BT_COEX command.
+ * BT_VALID_ENABLE must be set for each command. Commands without this bit will
+ * discarded by the firmware
+ */
+enum iwl_bt_coex_valid_bit_msk {
+ BT_VALID_ENABLE   = BIT(0),
+ BT_VALID_BT_PRIO_BOOST  = BIT(1),
+ BT_VALID_MAX_KILL  = BIT(2),
+ BT_VALID_3W_TMRS  = BIT(3),
+ BT_VALID_KILL_ACK  = BIT(4),
+ BT_VALID_KILL_CTS  = BIT(5),
+ BT_VALID_REDUCED_TX_POWER = BIT(6),
+ BT_VALID_LUT   = BIT(7),
+ BT_VALID_WIFI_RX_SW_PRIO_BOOST = BIT(8),
+ BT_VALID_WIFI_TX_SW_PRIO_BOOST = BIT(9),
+ BT_VALID_MULTI_PRIO_LUT  = BIT(10),
+ BT_VALID_TRM_KICK_FILTER = BIT(11),
+ BT_VALID_CORUN_LUT_20  = BIT(12),
+ BT_VALID_CORUN_LUT_40  = BIT(13),
+ BT_VALID_ANT_ISOLATION  = BIT(14),
+ BT_VALID_ANT_ISOLATION_THRS = BIT(15),
+ BT_VALID_TXTX_DELTA_FREQ_THRS = BIT(16),
+ BT_VALID_TXRX_MAX_FREQ_0 = BIT(17),
+ BT_VALID_SYNC_TO_SCO  = BIT(18),
+};
+
+/**
+ * enum iwl_bt_reduced_tx_power - allows to reduce txpower for WiFi frames.
+ * @BT_REDUCED_TX_POWER_CTL: reduce Tx power for control frames
+ * @BT_REDUCED_TX_POWER_DATA: reduce Tx power for data frames
+ *
+ * This mechanism allows to have BT and WiFi run concurrently. Since WiFi
+ * reduces its Tx power, it can work along with BT, hence reducing the amount
+ * of WiFi frames being killed by BT.
+ */
+enum iwl_bt_reduced_tx_power {
+ BT_REDUCED_TX_POWER_CTL  = BIT(0),
+ BT_REDUCED_TX_POWER_DATA = BIT(1),
+};
+
+enum iwl_bt_coex_lut_type {
+ BT_COEX_TIGHT_LUT = 0,
+ BT_COEX_LOOSE_LUT,
+ BT_COEX_TX_DIS_LUT,
+
+ BT_COEX_MAX_LUT,
+ BT_COEX_INVALID_LUT = 0xff,
+}; /* BT_COEX_DECISION_LUT_INDEX_API_E_VER_1 */
+
+#define BT_COEX_LUT_SIZE (12)
+#define BT_COEX_CORUN_LUT_SIZE (32)
+#define BT_COEX_MULTI_PRIO_LUT_SIZE (2)
+#define BT_COEX_BOOST_SIZE (4)
+#define BT_REDUCED_TX_POWER_BIT BIT(7)
+
+/**
+ * struct iwl_bt_coex_cmd - bt coex configuration command
+ * @flags:&enum iwl_bt_coex_flags
+ * @max_kill:
+ * @bt_reduced_tx_power: enum %iwl_bt_reduced_tx_power
+ * @override_primary_lut: enum %iwl_bt_coex_lut_type: BT_COEX_INVALID_LUT
+ * should be set by default
+ * @override_secondary_lut: enum %iwl_bt_coex_lut_type: BT_COEX_INVALID_LUT
+ * should be set by default
+ * @bt4_antenna_isolation: antenna isolation
+ * @bt4_antenna_isolation_thr: antenna threshold value
+ * @bt4_tx_tx_delta_freq_thr: TxTx delta frequency
+ * @bt4_tx_rx_max_freq0: TxRx max frequency
+ * @bt_prio_boost: BT priority boost registers
+ * @wifi_tx_prio_boost: SW boost of wifi tx priority
+ * @wifi_rx_prio_boost: SW boost of wifi rx priority
+ * @kill_ack_msk: kill ACK mask. 1 - Tx ACK, 0 - kill Tx of ACK.
+ * @kill_cts_msk: kill CTS mask. 1 - Tx CTS, 0 - kill Tx of CTS.
+ * @decision_lut: PTA decision LUT, per Prio-Ch
+ * @bt4_multiprio_lut: multi priority LUT configuration
+ * @bt4_corun_lut20: co-running 20 MHz LUT configuration
+ * @bt4_corun_lut40: co-running 40 MHz LUT configuration
+ * @valid_bit_msk: enum %iwl_bt_coex_valid_bit_msk
+ *
+ * The structure is used for the BT_COEX command.
+ */
+struct iwl_bt_coex_cmd {
+ __le32 flags;
+ u8 max_kill;
+ u8 bt_reduced_tx_power;
+ u8 override_primary_lut;
+ u8 override_secondary_lut;
+
+ u8 bt4_antenna_isolation;
+ u8 bt4_antenna_isolation_thr;
+ u8 bt4_tx_tx_delta_freq_thr;
+ u8 bt4_tx_rx_max_freq0;
+
+ __le32 bt_prio_boost[BT_COEX_BOOST_SIZE];
+ __le32 wifi_tx_prio_boost;
+ __le32 wifi_rx_prio_boost;
+ __le32 kill_ack_msk;
+ __le32 kill_cts_msk;
+
+ __le32 decision_lut[BT_COEX_MAX_LUT][BT_COEX_LUT_SIZE];
+ __le32 bt4_multiprio_lut[BT_COEX_MULTI_PRIO_LUT_SIZE];
+ __le32 bt4_corun_lut20[BT_COEX_CORUN_LUT_SIZE];
+ __le32 bt4_corun_lut40[BT_COEX_CORUN_LUT_SIZE];
+
+ __le32 valid_bit_msk;
+} __packed; /* BT_COEX_CMD_API_S_VER_5 */
+
+/**
+ * struct iwl_bt_coex_ci_cmd - bt coex channel inhibition command
+ * @bt_primary_ci:
+ * @bt_secondary_ci:
+ * @co_run_bw_primary:
+ * @co_run_bw_secondary:
+ * @primary_ch_phy_id:
+ * @secondary_ch_phy_id:
+ *
+ * Used for BT_COEX_CI command
+ */
+struct iwl_bt_coex_ci_cmd {
+ __le64 bt_primary_ci;
+ __le64 bt_secondary_ci;
+
+ u8 co_run_bw_primary;
+ u8 co_run_bw_secondary;
+ u8 primary_ch_phy_id;
+ u8 secondary_ch_phy_id;
+} __packed; /* BT_CI_MSG_API_S_VER_1 */
+
+#define BT_MBOX(n_dw, _msg, _pos, _nbits) \
+ BT_MBOX##n_dw##_##_msg##_POS = (_pos), \
+ BT_MBOX##n_dw##_##_msg = BITS(_nbits) << BT_MBOX##n_dw##_##_msg##_POS
+
+enum iwl_bt_mxbox_dw0 {
+ BT_MBOX(0, LE_SLAVE_LAT, 0, 3),
+ BT_MBOX(0, LE_PROF1, 3, 1),
+ BT_MBOX(0, LE_PROF2, 4, 1),
+ BT_MBOX(0, LE_PROF_OTHER, 5, 1),
+ BT_MBOX(0, CHL_SEQ_N, 8, 4),
+ BT_MBOX(0, INBAND_S, 13, 1),
+ BT_MBOX(0, LE_MIN_RSSI, 16, 4),
+ BT_MBOX(0, LE_SCAN, 20, 1),
+ BT_MBOX(0, LE_ADV, 21, 1),
+ BT_MBOX(0, LE_MAX_TX_POWER, 24, 4),
+ BT_MBOX(0, OPEN_CON_1, 28, 2),
+};
+
+enum iwl_bt_mxbox_dw1 {
+ BT_MBOX(1, BR_MAX_TX_POWER, 0, 4),
+ BT_MBOX(1, IP_SR, 4, 1),
+ BT_MBOX(1, LE_MSTR, 5, 1),
+ BT_MBOX(1, AGGR_TRFC_LD, 8, 6),
+ BT_MBOX(1, MSG_TYPE, 16, 3),
+ BT_MBOX(1, SSN, 19, 2),
+};
+
+enum iwl_bt_mxbox_dw2 {
+ BT_MBOX(2, SNIFF_ACT, 0, 3),
+ BT_MBOX(2, PAG, 3, 1),
+ BT_MBOX(2, INQUIRY, 4, 1),
+ BT_MBOX(2, CONN, 5, 1),
+ BT_MBOX(2, SNIFF_INTERVAL, 8, 5),
+ BT_MBOX(2, DISC, 13, 1),
+ BT_MBOX(2, SCO_TX_ACT, 16, 2),
+ BT_MBOX(2, SCO_RX_ACT, 18, 2),
+ BT_MBOX(2, ESCO_RE_TX, 20, 2),
+ BT_MBOX(2, SCO_DURATION, 24, 6),
+};
+
+enum iwl_bt_mxbox_dw3 {
+ BT_MBOX(3, SCO_STATE, 0, 1),
+ BT_MBOX(3, SNIFF_STATE, 1, 1),
+ BT_MBOX(3, A2DP_STATE, 2, 1),
+ BT_MBOX(3, ACL_STATE, 3, 1),
+ BT_MBOX(3, MSTR_STATE, 4, 1),
+ BT_MBOX(3, OBX_STATE, 5, 1),
+ BT_MBOX(3, OPEN_CON_2, 8, 2),
+ BT_MBOX(3, TRAFFIC_LOAD, 10, 2),
+ BT_MBOX(3, CHL_SEQN_LSB, 12, 1),
+ BT_MBOX(3, INBAND_P, 13, 1),
+ BT_MBOX(3, MSG_TYPE_2, 16, 3),
+ BT_MBOX(3, SSN_2, 19, 2),
+ BT_MBOX(3, UPDATE_REQUEST, 21, 1),
+};
+
+#define BT_MBOX_MSG(_notif, _num, _field)         \
+ ((le32_to_cpu((_notif)->mbox_msg[(_num)]) & BT_MBOX##_num##_##_field)\
+ >> BT_MBOX##_num##_##_field##_POS)
+
+enum iwl_bt_activity_grading {
+ BT_OFF   = 0,
+ BT_ON_NO_CONNECTION = 1,
+ BT_LOW_TRAFFIC  = 2,
+ BT_HIGH_TRAFFIC  = 3,
+}; /* BT_COEX_BT_ACTIVITY_GRADING_API_E_VER_1 */
+
+/**
+ * struct iwl_bt_coex_profile_notif - notification about BT coex
+ * @mbox_msg: message from BT to WiFi
+ * @msg_idx: the index of the message
+ * @bt_status: 0 - off, 1 - on
+ * @bt_open_conn: number of BT connections open
+ * @bt_traffic_load: load of BT traffic
+ * @bt_agg_traffic_load: aggregated load of BT traffic
+ * @bt_ci_compliance: 0 - no CI compliance, 1 - CI compliant
+ * @primary_ch_lut: LUT used for primary channel
+ * @secondary_ch_lut: LUT used for secondary channel
+ * @bt_activity_grading: the activity of BT enum %iwl_bt_activity_grading
+ */
+struct iwl_bt_coex_profile_notif {
+ __le32 mbox_msg[4];
+ __le32 msg_idx;
+ u8 bt_status;
+ u8 bt_open_conn;
+ u8 bt_traffic_load;
+ u8 bt_agg_traffic_load;
+ u8 bt_ci_compliance;
+ u8 reserved[3];
+
+ __le32 primary_ch_lut;
+ __le32 secondary_ch_lut;
+ __le32 bt_activity_grading;
+} __packed; /* BT_COEX_PROFILE_NTFY_API_S_VER_3 */
+
+enum iwl_bt_coex_prio_table_event {
+ BT_COEX_PRIO_TBL_EVT_INIT_CALIB1  = 0,
+ BT_COEX_PRIO_TBL_EVT_INIT_CALIB2  = 1,
+ BT_COEX_PRIO_TBL_EVT_PERIODIC_CALIB_LOW1 = 2,
+ BT_COEX_PRIO_TBL_EVT_PERIODIC_CALIB_LOW2 = 3,
+ BT_COEX_PRIO_TBL_EVT_PERIODIC_CALIB_HIGH1 = 4,
+ BT_COEX_PRIO_TBL_EVT_PERIODIC_CALIB_HIGH2 = 5,
+ BT_COEX_PRIO_TBL_EVT_DTIM   = 6,
+ BT_COEX_PRIO_TBL_EVT_SCAN52   = 7,
+ BT_COEX_PRIO_TBL_EVT_SCAN24   = 8,
+ BT_COEX_PRIO_TBL_EVT_IDLE   = 9,
+ BT_COEX_PRIO_TBL_EVT_MAX   = 16,
+}; /* BT_COEX_PRIO_TABLE_EVENTS_API_E_VER_1 */
+
+enum iwl_bt_coex_prio_table_prio {
+ BT_COEX_PRIO_TBL_DISABLED = 0,
+ BT_COEX_PRIO_TBL_PRIO_LOW = 1,
+ BT_COEX_PRIO_TBL_PRIO_HIGH = 2,
+ BT_COEX_PRIO_TBL_PRIO_BYPASS = 3,
+ BT_COEX_PRIO_TBL_PRIO_COEX_OFF = 4,
+ BT_COEX_PRIO_TBL_PRIO_COEX_ON = 5,
+ BT_COEX_PRIO_TBL_PRIO_COEX_IDLE = 6,
+ BT_COEX_PRIO_TBL_MAX  = 8,
+}; /* BT_COEX_PRIO_TABLE_PRIORITIES_API_E_VER_1 */
+
+#define BT_COEX_PRIO_TBL_SHRD_ANT_POS     (0)
+#define BT_COEX_PRIO_TBL_PRIO_POS         (1)
+#define BT_COEX_PRIO_TBL_RESERVED_POS     (4)
+
+/**
+ * struct iwl_bt_coex_prio_tbl_cmd - priority table for BT coex
+ * @prio_tbl:
+ */
+struct iwl_bt_coex_prio_tbl_cmd {
+ u8 prio_tbl[BT_COEX_PRIO_TBL_EVT_MAX];
+} __packed;
+
+#endif /* __fw_api_bt_coex_h__ */
diff --git a/drivers/net/wireless/iwlwifi/mvm/fw-api-d3.h b/drivers/net/wireless/iwlwifi/mvm/fw-api-d3.h
index 6f8b2c1..13696fe 100644
--- a/drivers/net/wireless/iwlwifi/mvm/fw-api-d3.h
+++ b/drivers/net/wireless/iwlwifi/mvm/fw-api-d3.h
@@ -5,7 +5,7 @@
  *
  * GPL LICENSE SUMMARY
  *
- * Copyright(c) 2012 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2012 - 2014 Intel Corporation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of version 2 of the GNU General Public License as
@@ -30,7 +30,7 @@
  *
  * BSD LICENSE
  *
- * Copyright(c) 2012 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2012 - 2014 Intel Corporation. All rights reserved.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -98,34 +98,105 @@ enum iwl_proto_offloads {
  IWL_D3_PROTO_OFFLOAD_NS = BIT(1),
 };
 
-#define IWL_PROTO_OFFLOAD_NUM_IPV6_ADDRS 2
+#define IWL_PROTO_OFFLOAD_NUM_IPV6_ADDRS_V1 2
+#define IWL_PROTO_OFFLOAD_NUM_IPV6_ADDRS_V2 6
+#define IWL_PROTO_OFFLOAD_NUM_IPV6_ADDRS_V3L 12
+#define IWL_PROTO_OFFLOAD_NUM_IPV6_ADDRS_V3S 4
+#define IWL_PROTO_OFFLOAD_NUM_IPV6_ADDRS_MAX 12
+
+#define IWL_PROTO_OFFLOAD_NUM_NS_CONFIG_V3L 4
+#define IWL_PROTO_OFFLOAD_NUM_NS_CONFIG_V3S 2
 
 /**
- * struct iwl_proto_offload_cmd - ARP/NS offload configuration
+ * struct iwl_proto_offload_cmd_common - ARP/NS offload common part
  * @enabled: enable flags
  * @remote_ipv4_addr: remote address to answer to (or zero if all)
  * @host_ipv4_addr: our IPv4 address to respond to queries for
  * @arp_mac_addr: our MAC address for ARP responses
- * @remote_ipv6_addr: remote address to answer to (or zero if all)
- * @solicited_node_ipv6_addr: broken -- solicited node address exists
- * for each target address
- * @target_ipv6_addr: our target addresses
- * @ndp_mac_addr: neighbor soliciation response MAC address
+ * @reserved: unused
  */
-struct iwl_proto_offload_cmd {
+struct iwl_proto_offload_cmd_common {
  __le32 enabled;
  __be32 remote_ipv4_addr;
  __be32 host_ipv4_addr;
  u8 arp_mac_addr[ETH_ALEN];
- __le16 reserved1;
+ __le16 reserved;
+} __packed;
 
+/**
+ * struct iwl_proto_offload_cmd_v1 - ARP/NS offload configuration
+ * @common: common/IPv4 configuration
+ * @remote_ipv6_addr: remote address to answer to (or zero if all)
+ * @solicited_node_ipv6_addr: broken -- solicited node address exists
+ * for each target address
+ * @target_ipv6_addr: our target addresses
+ * @ndp_mac_addr: neighbor soliciation response MAC address
+ */
+struct iwl_proto_offload_cmd_v1 {
+ struct iwl_proto_offload_cmd_common common;
  u8 remote_ipv6_addr[16];
  u8 solicited_node_ipv6_addr[16];
- u8 target_ipv6_addr[IWL_PROTO_OFFLOAD_NUM_IPV6_ADDRS][16];
+ u8 target_ipv6_addr[IWL_PROTO_OFFLOAD_NUM_IPV6_ADDRS_V1][16];
  u8 ndp_mac_addr[ETH_ALEN];
  __le16 reserved2;
 } __packed; /* PROT_OFFLOAD_CONFIG_CMD_DB_S_VER_1 */
 
+/**
+ * struct iwl_proto_offload_cmd_v2 - ARP/NS offload configuration
+ * @common: common/IPv4 configuration
+ * @remote_ipv6_addr: remote address to answer to (or zero if all)
+ * @solicited_node_ipv6_addr: broken -- solicited node address exists
+ * for each target address
+ * @target_ipv6_addr: our target addresses
+ * @ndp_mac_addr: neighbor soliciation response MAC address
+ */
+struct iwl_proto_offload_cmd_v2 {
+ struct iwl_proto_offload_cmd_common common;
+ u8 remote_ipv6_addr[16];
+ u8 solicited_node_ipv6_addr[16];
+ u8 target_ipv6_addr[IWL_PROTO_OFFLOAD_NUM_IPV6_ADDRS_V2][16];
+ u8 ndp_mac_addr[ETH_ALEN];
+ u8 numValidIPv6Addresses;
+ u8 reserved2[3];
+} __packed; /* PROT_OFFLOAD_CONFIG_CMD_DB_S_VER_2 */
+
+struct iwl_ns_config {
+ struct in6_addr source_ipv6_addr;
+ struct in6_addr dest_ipv6_addr;
+ u8 target_mac_addr[ETH_ALEN];
+ __le16 reserved;
+} __packed; /* NS_OFFLOAD_CONFIG */
+
+struct iwl_targ_addr {
+ struct in6_addr addr;
+ __le32 config_num;
+} __packed; /* TARGET_IPV6_ADDRESS */
+
+/**
+ * struct iwl_proto_offload_cmd_v3_small - ARP/NS offload configuration
+ * @common: common/IPv4 configuration
+ * @target_ipv6_addr: target IPv6 addresses
+ * @ns_config: NS offload configurations
+ */
+struct iwl_proto_offload_cmd_v3_small {
+ struct iwl_proto_offload_cmd_common common;
+ __le32 num_valid_ipv6_addrs;
+ struct iwl_targ_addr targ_addrs[IWL_PROTO_OFFLOAD_NUM_IPV6_ADDRS_V3S];
+ struct iwl_ns_config ns_config[IWL_PROTO_OFFLOAD_NUM_NS_CONFIG_V3S];
+} __packed; /* PROT_OFFLOAD_CONFIG_CMD_DB_S_VER_3 */
+
+/**
+ * struct iwl_proto_offload_cmd_v3_large - ARP/NS offload configuration
+ * @common: common/IPv4 configuration
+ * @target_ipv6_addr: target IPv6 addresses
+ * @ns_config: NS offload configurations
+ */
+struct iwl_proto_offload_cmd_v3_large {
+ struct iwl_proto_offload_cmd_common common;
+ __le32 num_valid_ipv6_addrs;
+ struct iwl_targ_addr targ_addrs[IWL_PROTO_OFFLOAD_NUM_IPV6_ADDRS_V3L];
+ struct iwl_ns_config ns_config[IWL_PROTO_OFFLOAD_NUM_NS_CONFIG_V3L];
+} __packed; /* PROT_OFFLOAD_CONFIG_CMD_DB_S_VER_3 */
 
 /*
  * WOWLAN_PATTERNS
@@ -160,11 +231,15 @@ enum iwl_wowlan_wakeup_filters {
  IWL_WOWLAN_WAKEUP_RF_KILL_DEASSERT  = BIT(8),
  IWL_WOWLAN_WAKEUP_REMOTE_LINK_LOSS  = BIT(9),
  IWL_WOWLAN_WAKEUP_REMOTE_SIGNATURE_TABLE = BIT(10),
- /* BIT(11) reserved */
+ IWL_WOWLAN_WAKEUP_REMOTE_TCP_EXTERNAL  = BIT(11),
  IWL_WOWLAN_WAKEUP_REMOTE_WAKEUP_PACKET  = BIT(12),
+ IWL_WOWLAN_WAKEUP_IOAC_MAGIC_PACKET  = BIT(13),
+ IWL_WOWLAN_WAKEUP_HOST_TIMER   = BIT(14),
+ IWL_WOWLAN_WAKEUP_RX_FRAME   = BIT(15),
+ IWL_WOWLAN_WAKEUP_BCN_FILTERING   = BIT(16),
 }; /* WOWLAN_WAKEUP_FILTER_API_E_VER_4 */
 
-struct iwl_wowlan_config_cmd {
+struct iwl_wowlan_config_cmd_v2 {
  __le32 wakeup_filter;
  __le16 non_qos_seq;
  __le16 qos_seq[8];
@@ -172,6 +247,12 @@ struct iwl_wowlan_config_cmd {
  u8 is_11n_connection;
 } __packed; /* WOWLAN_CONFIG_API_S_VER_2 */
 
+struct iwl_wowlan_config_cmd_v3 {
+ struct iwl_wowlan_config_cmd_v2 common;
+ u8 offloading_tid;
+ u8 reserved[3];
+} __packed; /* WOWLAN_CONFIG_API_S_VER_3 */
+
 /*
  * WOWLAN_TSC_RSC_PARAMS
  */
@@ -264,20 +345,28 @@ enum iwl_wowlan_wakeup_reason {
  IWL_WOWLAN_WAKEUP_BY_REM_WAKE_WAKEUP_PACKET  = BIT(12),
 }; /* WOWLAN_WAKE_UP_REASON_API_E_VER_2 */
 
+struct iwl_wowlan_gtk_status {
+ u8 key_index;
+ u8 reserved[3];
+ u8 decrypt_key[16];
+ u8 tkip_mic_key[8];
+ struct iwl_wowlan_rsc_tsc_params_cmd rsc;
+} __packed;
+
 struct iwl_wowlan_status {
+ struct iwl_wowlan_gtk_status gtk;
  __le64 replay_ctr;
  __le16 pattern_number;
  __le16 non_qos_seq_ctr;
  __le16 qos_seq_ctr[8];
  __le32 wakeup_reasons;
- __le32 rekey_status;
  __le32 num_of_gtk_rekeys;
  __le32 transmitted_ndps;
  __le32 received_beacons;
  __le32 wake_packet_length;
  __le32 wake_packet_bufsize;
  u8 wake_packet[]; /* can be truncated from _length to _bufsize */
-} __packed; /* WOWLAN_STATUSES_API_S_VER_4 */
+} __packed; /* WOWLAN_STATUSES_API_S_VER_6 */
 
 #define IWL_WOWLAN_TCP_MAX_PACKET_LEN  64
 #define IWL_WOWLAN_REMOTE_WAKE_MAX_PACKET_LEN 128
diff --git a/drivers/net/wireless/iwlwifi/mvm/fw-api-mac.h b/drivers/net/wireless/iwlwifi/mvm/fw-api-mac.h
index 98b1feb..c405cda 100644
--- a/drivers/net/wireless/iwlwifi/mvm/fw-api-mac.h
+++ b/drivers/net/wireless/iwlwifi/mvm/fw-api-mac.h
@@ -5,7 +5,7 @@
  *
  * GPL LICENSE SUMMARY
  *
- * Copyright(c) 2012 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2012 - 2014 Intel Corporation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of version 2 of the GNU General Public License as
@@ -30,7 +30,7 @@
  *
  * BSD LICENSE
  *
- * Copyright(c) 2012 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2012 - 2014 Intel Corporation. All rights reserved.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -170,12 +170,14 @@ struct iwl_mac_data_ap {
  * @beacon_tsf: beacon transmit time in TSF
  * @bi: beacon interval in TU
  * @bi_reciprocal: 2^32 / bi
+ * @beacon_template: beacon template ID
  */
 struct iwl_mac_data_ibss {
  __le32 beacon_time;
  __le64 beacon_tsf;
  __le32 bi;
  __le32 bi_reciprocal;
+ __le32 beacon_template;
 } __packed; /* IBSS_MAC_DATA_API_S_VER_1 */
 
 /**
@@ -372,4 +374,13 @@ static inline u32 iwl_mvm_reciprocal(u32 v)
  return 0xFFFFFFFF / v;
 }
 
+#define IWL_NONQOS_SEQ_GET 0x1
+#define IWL_NONQOS_SEQ_SET 0x2
+struct iwl_nonqos_seq_query_cmd {
+ __le32 get_set_flag;
+ __le32 mac_id_n_color;
+ __le16 value;
+ __le16 reserved;
+} __packed; /* NON_QOS_TX_COUNTER_GET_SET_API_S_VER_1 */
+
 #endif /* __fw_api_mac_h__ */
diff --git a/drivers/net/wireless/iwlwifi/mvm/fw-api-power.h b/drivers/net/wireless/iwlwifi/mvm/fw-api-power.h
index 81fe45f..cbbcd8e 100644
--- a/drivers/net/wireless/iwlwifi/mvm/fw-api-power.h
+++ b/drivers/net/wireless/iwlwifi/mvm/fw-api-power.h
@@ -5,7 +5,7 @@
  *
  * GPL LICENSE SUMMARY
  *
- * Copyright(c) 2012 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2012 - 2014 Intel Corporation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of version 2 of the GNU General Public License as
@@ -30,7 +30,7 @@
  *
  * BSD LICENSE
  *
- * Copyright(c) 2012 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2012 - 2014 Intel Corporation. All rights reserved.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -66,6 +66,11 @@
 
 /* Power Management Commands, Responses, Notifications */
 
+/* Radio LP RX Energy Threshold measured in dBm */
+#define POWER_LPRX_RSSI_THRESHOLD 75
+#define POWER_LPRX_RSSI_THRESHOLD_MAX 94
+#define POWER_LPRX_RSSI_THRESHOLD_MIN 30
+
 /**
  * enum iwl_scan_flags - masks for power table command flags
  * @POWER_FLAGS_POWER_SAVE_ENA_MSK: '1' Allow to save power by turning off
@@ -74,21 +79,31 @@
  *  '1' Driver enables PM (use rest of parameters)
  * @POWER_FLAGS_SKIP_OVER_DTIM_MSK: '0' PM have to walk up every DTIM,
  *  '1' PM could sleep over DTIM till listen Interval.
+ * @POWER_FLAGS_SNOOZE_ENA_MSK: Enable snoozing only if uAPSD is enabled and all
+ *  access categories are both delivery and trigger enabled.
+ * @POWER_FLAGS_BT_SCO_ENA: Enable BT SCO coex only if uAPSD and
+ *  PBW Snoozing enabled
  * @POWER_FLAGS_ADVANCE_PM_ENA_MSK: Advanced PM (uAPSD) enable mask
  * @POWER_FLAGS_LPRX_ENA_MSK: Low Power RX enable.
+ * @POWER_FLAGS_AP_UAPSD_MISBEHAVING_ENA_MSK: AP/GO's uAPSD misbehaving
+ *  detection enablement
 */
 enum iwl_power_flags {
  POWER_FLAGS_POWER_SAVE_ENA_MSK  = BIT(0),
  POWER_FLAGS_POWER_MANAGEMENT_ENA_MSK = BIT(1),
  POWER_FLAGS_SKIP_OVER_DTIM_MSK  = BIT(2),
+ POWER_FLAGS_SNOOZE_ENA_MSK  = BIT(5),
+ POWER_FLAGS_BT_SCO_ENA   = BIT(8),
  POWER_FLAGS_ADVANCE_PM_ENA_MSK  = BIT(9),
  POWER_FLAGS_LPRX_ENA_MSK  = BIT(11),
+ POWER_FLAGS_UAPSD_MISBEHAVING_ENA_MSK = BIT(12),
 };
 
 #define IWL_POWER_VEC_SIZE 5
 
 /**
- * struct iwl_powertable_cmd - Power Table Command
+ * struct iwl_powertable_cmd - legacy power command. Beside old API support this
+ * is used also with a new power API for device wide power settings.
  * POWER_TABLE_CMD = 0x77 (command, has simple generic response)
  *
  * @flags:  Power table command flags from POWER_FLAGS_*
@@ -101,20 +116,250 @@ enum iwl_power_flags {
  * @tx_data_timeout:    Minimum time (usec) from last Tx packet for AM to
  *   PSM transition - legacy PM
  * @sleep_interval: not in use
- * @keep_alive_beacons: not in use
+ * @skip_dtim_periods: Number of DTIM periods to skip if Skip over DTIM flag
+ *   is set. For example, if it is required to skip over
+ *   one DTIM, this value need to be set to 2 (DTIM periods).
  * @lprx_rssi_threshold: Signal strength up to which LP RX can be enabled.
  *   Default: 80dbm
  */
 struct iwl_powertable_cmd {
- /* PM_POWER_TABLE_CMD_API_S_VER_5 */
+ /* PM_POWER_TABLE_CMD_API_S_VER_6 */
  __le16 flags;
  u8 keep_alive_seconds;
  u8 debug_flags;
  __le32 rx_data_timeout;
  __le32 tx_data_timeout;
  __le32 sleep_interval[IWL_POWER_VEC_SIZE];
- __le32 keep_alive_beacons;
+ __le32 skip_dtim_periods;
  __le32 lprx_rssi_threshold;
 } __packed;
 
+/**
+ * enum iwl_device_power_flags - masks for device power command flags
+ * @DEVIC_POWER_FLAGS_POWER_SAVE_ENA_MSK: '1' Allow to save power by turning off
+ * receiver and transmitter. '0' - does not allow. This flag should be
+ * always set to '1' unless one need to disable actual power down for debug
+ * purposes.
+ * @DEVICE_POWER_FLAGS_CAM_MSK: '1' CAM (Continuous Active Mode) is set, meaning
+ * that power management is disabled. '0' Power management is enabled, one
+ * of power schemes is applied.
+*/
+enum iwl_device_power_flags {
+ DEVICE_POWER_FLAGS_POWER_SAVE_ENA_MSK = BIT(0),
+ DEVICE_POWER_FLAGS_CAM_MSK  = BIT(13),
+};
+
+/**
+ * struct iwl_device_power_cmd - device wide power command.
+ * DEVICE_POWER_CMD = 0x77 (command, has simple generic response)
+ *
+ * @flags: Power table command flags from DEVICE_POWER_FLAGS_*
+ */
+struct iwl_device_power_cmd {
+ /* PM_POWER_TABLE_CMD_API_S_VER_6 */
+ __le16 flags;
+ __le16 reserved;
+} __packed;
+
+/**
+ * struct iwl_mac_power_cmd - New power command containing uAPSD support
+ * MAC_PM_POWER_TABLE = 0xA9 (command, has simple generic response)
+ * @id_and_color: MAC contex identifier
+ * @flags:  Power table command flags from POWER_FLAGS_*
+ * @keep_alive_seconds: Keep alive period in seconds. Default - 25 sec.
+ *   Minimum allowed:- 3 * DTIM. Keep alive period must be
+ *   set regardless of power scheme or current power state.
+ *   FW use this value also when PM is disabled.
+ * @rx_data_timeout:    Minimum time (usec) from last Rx packet for AM to
+ *   PSM transition - legacy PM
+ * @tx_data_timeout:    Minimum time (usec) from last Tx packet for AM to
+ *   PSM transition - legacy PM
+ * @sleep_interval: not in use
+ * @skip_dtim_periods: Number of DTIM periods to skip if Skip over DTIM flag
+ *   is set. For example, if it is required to skip over
+ *   one DTIM, this value need to be set to 2 (DTIM periods).
+ * @rx_data_timeout_uapsd: Minimum time (usec) from last Rx packet for AM to
+ *   PSM transition - uAPSD
+ * @tx_data_timeout_uapsd: Minimum time (usec) from last Tx packet for AM to
+ *   PSM transition - uAPSD
+ * @lprx_rssi_threshold: Signal strength up to which LP RX can be enabled.
+ *   Default: 80dbm
+ * @num_skip_dtim: Number of DTIMs to skip if Skip over DTIM flag is set
+ * @snooze_interval: Maximum time between attempts to retrieve buffered data
+ *   from the AP [msec]
+ * @snooze_window: A window of time in which PBW snoozing insures that all
+ *   packets received. It is also the minimum time from last
+ *   received unicast RX packet, before client stops snoozing
+ *   for data. [msec]
+ * @snooze_step: TBD
+ * @qndp_tid:  TID client shall use for uAPSD QNDP triggers
+ * @uapsd_ac_flags: Set trigger-enabled and delivery-enabled indication for
+ *   each corresponding AC.
+ *   Use IEEE80211_WMM_IE_STA_QOSINFO_AC* for correct values.
+ * @uapsd_max_sp: Use IEEE80211_WMM_IE_STA_QOSINFO_SP_* for correct
+ *   values.
+ * @heavy_tx_thld_packets: TX threshold measured in number of packets
+ * @heavy_rx_thld_packets: RX threshold measured in number of packets
+ * @heavy_tx_thld_percentage: TX threshold measured in load's percentage
+ * @heavy_rx_thld_percentage: RX threshold measured in load's percentage
+ * @limited_ps_threshold:
+*/
+struct iwl_mac_power_cmd {
+ /* CONTEXT_DESC_API_T_VER_1 */
+ __le32 id_and_color;
+
+ /* CLIENT_PM_POWER_TABLE_S_VER_1 */
+ __le16 flags;
+ __le16 keep_alive_seconds;
+ __le32 rx_data_timeout;
+ __le32 tx_data_timeout;
+ __le32 rx_data_timeout_uapsd;
+ __le32 tx_data_timeout_uapsd;
+ u8 lprx_rssi_threshold;
+ u8 skip_dtim_periods;
+ __le16 snooze_interval;
+ __le16 snooze_window;
+ u8 snooze_step;
+ u8 qndp_tid;
+ u8 uapsd_ac_flags;
+ u8 uapsd_max_sp;
+ u8 heavy_tx_thld_packets;
+ u8 heavy_rx_thld_packets;
+ u8 heavy_tx_thld_percentage;
+ u8 heavy_rx_thld_percentage;
+ u8 limited_ps_threshold;
+ u8 reserved;
+} __packed;
+
+/*
+ * struct iwl_uapsd_misbehaving_ap_notif - FW sends this notification when
+ * associated AP is identified as improperly implementing uAPSD protocol.
+ * PSM_UAPSD_AP_MISBEHAVING_NOTIFICATION = 0x78
+ * @sta_id: index of station in uCode's station table - associated AP ID in
+ *     this context.
+ */
+struct iwl_uapsd_misbehaving_ap_notif {
+ __le32 sta_id;
+ u8 mac_id;
+ u8 reserved[3];
+} __packed;
+
+/**
+ * struct iwl_beacon_filter_cmd
+ * REPLY_BEACON_FILTERING_CMD = 0xd2 (command)
+ * @id_and_color: MAC contex identifier
+ * @bf_energy_delta: Used for RSSI filtering, if in 'normal' state. Send beacon
+ *      to driver if delta in Energy values calculated for this and last
+ *      passed beacon is greater than this threshold. Zero value means that
+ *      the Energy change is ignored for beacon filtering, and beacon will
+ *      not be forced to be sent to driver regardless of this delta. Typical
+ *      energy delta 5dB.
+ * @bf_roaming_energy_delta: Used for RSSI filtering, if in 'roaming' state.
+ *      Send beacon to driver if delta in Energy values calculated for this
+ *      and last passed beacon is greater than this threshold. Zero value
+ *      means that the Energy change is ignored for beacon filtering while in
+ *      Roaming state, typical energy delta 1dB.
+ * @bf_roaming_state: Used for RSSI filtering. If absolute Energy values
+ *      calculated for current beacon is less than the threshold, use
+ *      Roaming Energy Delta Threshold, otherwise use normal Energy Delta
+ *      Threshold. Typical energy threshold is -72dBm.
+ * @bf_temp_threshold: This threshold determines the type of temperature
+ * filtering (Slow or Fast) that is selected (Units are in Celsuis):
+ *      If the current temperature is above this threshold - Fast filter
+ * will be used, If the current temperature is below this threshold -
+ * Slow filter will be used.
+ * @bf_temp_fast_filter: Send Beacon to driver if delta in temperature values
+ *      calculated for this and the last passed beacon is greater than this
+ *      threshold. Zero value means that the temperature change is ignored for
+ *      beacon filtering; beacons will not be  forced to be sent to driver
+ *      regardless of whether its temerature has been changed.
+ * @bf_temp_slow_filter: Send Beacon to driver if delta in temperature values
+ *      calculated for this and the last passed beacon is greater than this
+ *      threshold. Zero value means that the temperature change is ignored for
+ *      beacon filtering; beacons will not be forced to be sent to driver
+ *      regardless of whether its temerature has been changed.
+ * @bf_enable_beacon_filter: 1, beacon filtering is enabled; 0, disabled.
+ * @bf_filter_escape_timer: Send beacons to to driver if no beacons were passed
+ *      for a specific period of time. Units: Beacons.
+ * @ba_escape_timer: Fully receive and parse beacon if no beacons were passed
+ *      for a longer period of time then this escape-timeout. Units: Beacons.
+ * @ba_enable_beacon_abort: 1, beacon abort is enabled; 0, disabled.
+ */
+struct iwl_beacon_filter_cmd {
+ __le32 bf_energy_delta;
+ __le32 bf_roaming_energy_delta;
+ __le32 bf_roaming_state;
+ __le32 bf_temp_threshold;
+ __le32 bf_temp_fast_filter;
+ __le32 bf_temp_slow_filter;
+ __le32 bf_enable_beacon_filter;
+ __le32 bf_debug_flag;
+ __le32 bf_escape_timer;
+ __le32 ba_escape_timer;
+ __le32 ba_enable_beacon_abort;
+} __packed;
+
+/* Beacon filtering and beacon abort */
+#define IWL_BF_ENERGY_DELTA_DEFAULT 5
+#define IWL_BF_ENERGY_DELTA_D0I3 20
+#define IWL_BF_ENERGY_DELTA_MAX 255
+#define IWL_BF_ENERGY_DELTA_MIN 0
+
+#define IWL_BF_ROAMING_ENERGY_DELTA_DEFAULT 1
+#define IWL_BF_ROAMING_ENERGY_DELTA_D0I3 20
+#define IWL_BF_ROAMING_ENERGY_DELTA_MAX 255
+#define IWL_BF_ROAMING_ENERGY_DELTA_MIN 0
+
+#define IWL_BF_ROAMING_STATE_DEFAULT 72
+#define IWL_BF_ROAMING_STATE_D0I3 72
+#define IWL_BF_ROAMING_STATE_MAX 255
+#define IWL_BF_ROAMING_STATE_MIN 0
+
+#define IWL_BF_TEMP_THRESHOLD_DEFAULT 112
+#define IWL_BF_TEMP_THRESHOLD_D0I3 112
+#define IWL_BF_TEMP_THRESHOLD_MAX 255
+#define IWL_BF_TEMP_THRESHOLD_MIN 0
+
+#define IWL_BF_TEMP_FAST_FILTER_DEFAULT 1
+#define IWL_BF_TEMP_FAST_FILTER_D0I3 1
+#define IWL_BF_TEMP_FAST_FILTER_MAX 255
+#define IWL_BF_TEMP_FAST_FILTER_MIN 0
+
+#define IWL_BF_TEMP_SLOW_FILTER_DEFAULT 5
+#define IWL_BF_TEMP_SLOW_FILTER_D0I3 5
+#define IWL_BF_TEMP_SLOW_FILTER_MAX 255
+#define IWL_BF_TEMP_SLOW_FILTER_MIN 0
+
+#define IWL_BF_ENABLE_BEACON_FILTER_DEFAULT 1
+
+#define IWL_BF_DEBUG_FLAG_DEFAULT 0
+#define IWL_BF_DEBUG_FLAG_D0I3 0
+
+#define IWL_BF_ESCAPE_TIMER_DEFAULT 50
+#define IWL_BF_ESCAPE_TIMER_D0I3 1024
+#define IWL_BF_ESCAPE_TIMER_MAX 1024
+#define IWL_BF_ESCAPE_TIMER_MIN 0
+
+#define IWL_BA_ESCAPE_TIMER_DEFAULT 6
+#define IWL_BA_ESCAPE_TIMER_D0I3 6
+#define IWL_BA_ESCAPE_TIMER_D3 9
+#define IWL_BA_ESCAPE_TIMER_MAX 1024
+#define IWL_BA_ESCAPE_TIMER_MIN 0
+
+#define IWL_BA_ENABLE_BEACON_ABORT_DEFAULT 1
+
+#define IWL_BF_CMD_CONFIG(mode)          \
+ .bf_energy_delta = cpu_to_le32(IWL_BF_ENERGY_DELTA ## mode),       \
+ .bf_roaming_energy_delta =           \
+  cpu_to_le32(IWL_BF_ROAMING_ENERGY_DELTA ## mode),       \
+ .bf_roaming_state = cpu_to_le32(IWL_BF_ROAMING_STATE ## mode),       \
+ .bf_temp_threshold = cpu_to_le32(IWL_BF_TEMP_THRESHOLD ## mode),      \
+ .bf_temp_fast_filter = cpu_to_le32(IWL_BF_TEMP_FAST_FILTER ## mode),  \
+ .bf_temp_slow_filter = cpu_to_le32(IWL_BF_TEMP_SLOW_FILTER ## mode),  \
+ .bf_debug_flag = cpu_to_le32(IWL_BF_DEBUG_FLAG ## mode),       \
+ .bf_escape_timer = cpu_to_le32(IWL_BF_ESCAPE_TIMER ## mode),       \
+ .ba_escape_timer = cpu_to_le32(IWL_BA_ESCAPE_TIMER ## mode)
+
+#define IWL_BF_CMD_CONFIG_DEFAULTS IWL_BF_CMD_CONFIG(_DEFAULT)
+#define IWL_BF_CMD_CONFIG_D0I3 IWL_BF_CMD_CONFIG(_D0I3)
 #endif
diff --git a/drivers/net/wireless/iwlwifi/mvm/fw-api-rs.h b/drivers/net/wireless/iwlwifi/mvm/fw-api-rs.h
index fdd33bc..8bb5b94 100644
--- a/drivers/net/wireless/iwlwifi/mvm/fw-api-rs.h
+++ b/drivers/net/wireless/iwlwifi/mvm/fw-api-rs.h
@@ -5,7 +5,7 @@
  *
  * GPL LICENSE SUMMARY
  *
- * Copyright(c) 2012 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2012 - 2014 Intel Corporation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of version 2 of the GNU General Public License as
@@ -30,7 +30,7 @@
  *
  * BSD LICENSE
  *
- * Copyright(c) 2012 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2012 - 2014 Intel Corporation. All rights reserved.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -68,6 +68,7 @@
 /*
  * These serve as indexes into
  * struct iwl_rate_info fw_rate_idx_to_plcp[IWL_RATE_COUNT];
+ * TODO: avoid overlap between legacy and HT rates
  */
 enum {
  IWL_RATE_1M_INDEX = 0,
@@ -78,18 +79,31 @@ enum {
  IWL_LAST_CCK_RATE = IWL_RATE_11M_INDEX,
  IWL_RATE_6M_INDEX,
  IWL_FIRST_OFDM_RATE = IWL_RATE_6M_INDEX,
+ IWL_RATE_MCS_0_INDEX = IWL_RATE_6M_INDEX,
+ IWL_FIRST_HT_RATE = IWL_RATE_MCS_0_INDEX,
+ IWL_FIRST_VHT_RATE = IWL_RATE_MCS_0_INDEX,
  IWL_RATE_9M_INDEX,
  IWL_RATE_12M_INDEX,
+ IWL_RATE_MCS_1_INDEX = IWL_RATE_12M_INDEX,
  IWL_RATE_18M_INDEX,
+ IWL_RATE_MCS_2_INDEX = IWL_RATE_18M_INDEX,
  IWL_RATE_24M_INDEX,
+ IWL_RATE_MCS_3_INDEX = IWL_RATE_24M_INDEX,
  IWL_RATE_36M_INDEX,
+ IWL_RATE_MCS_4_INDEX = IWL_RATE_36M_INDEX,
  IWL_RATE_48M_INDEX,
+ IWL_RATE_MCS_5_INDEX = IWL_RATE_48M_INDEX,
  IWL_RATE_54M_INDEX,
+ IWL_RATE_MCS_6_INDEX = IWL_RATE_54M_INDEX,
  IWL_LAST_NON_HT_RATE = IWL_RATE_54M_INDEX,
  IWL_RATE_60M_INDEX,
- IWL_LAST_OFDM_RATE = IWL_RATE_60M_INDEX,
+ IWL_RATE_MCS_7_INDEX = IWL_RATE_60M_INDEX,
+ IWL_LAST_HT_RATE = IWL_RATE_MCS_7_INDEX,
+ IWL_RATE_MCS_8_INDEX,
+ IWL_RATE_MCS_9_INDEX,
+ IWL_LAST_VHT_RATE = IWL_RATE_MCS_9_INDEX,
  IWL_RATE_COUNT_LEGACY = IWL_LAST_NON_HT_RATE + 1,
- IWL_RATE_COUNT,
+ IWL_RATE_COUNT = IWL_LAST_VHT_RATE + 1,
 };
 
 #define IWL_RATE_BIT_MSK(r) BIT(IWL_RATE_##r##M_INDEX)
@@ -108,6 +122,7 @@ enum {
  IWL_RATE_2M_PLCP  = 20,
  IWL_RATE_5M_PLCP  = 55,
  IWL_RATE_11M_PLCP = 110,
+ IWL_RATE_INVM_PLCP = -1,
 };
 
 /*
@@ -164,6 +179,8 @@ enum {
  * which is the duplicate 20 MHz MCS (bit 5 set, all others zero.)
  */
 #define RATE_HT_MCS_RATE_CODE_MSK 0x7
+#define RATE_HT_MCS_NSS_POS             3
+#define RATE_HT_MCS_NSS_MSK             (3 << RATE_HT_MCS_NSS_POS)
 
 /* Bit 10: (1) Use Green Field preamble */
 #define RATE_HT_MCS_GF_POS  10
@@ -240,7 +257,8 @@ enum {
 
 /* Bit 17-18: (0) SS, (1) SS*2 */
 #define RATE_MCS_STBC_POS  17
-#define RATE_MCS_STBC_MSK  (1 << RATE_MCS_STBC_POS)
+#define RATE_MCS_HT_STBC_MSK  (3 << RATE_MCS_STBC_POS)
+#define RATE_MCS_VHT_STBC_MSK  (1 << RATE_MCS_STBC_POS)
 
 /* Bit 19: (0) Beamforming is off, (1) Beamforming is on */
 #define RATE_MCS_BF_POS   19
@@ -264,8 +282,31 @@ enum {
 /* # entries in rate scale table to support Tx retries */
 #define  LQ_MAX_RETRY_NUM 16
 
-/* Link quality command flags, only this one is available */
-#define  LQ_FLAG_SET_STA_TLC_RTS_MSK BIT(0)
+/* Link quality command flags bit fields */
+
+/* Bit 0: (0) Don't use RTS (1) Use RTS */
+#define LQ_FLAG_USE_RTS_POS             0
+#define LQ_FLAG_USE_RTS_MSK         (1 << LQ_FLAG_USE_RTS_POS)
+
+/* Bit 1-3: LQ command color. Used to match responses to LQ commands */
+#define LQ_FLAG_COLOR_POS               1
+#define LQ_FLAG_COLOR_MSK               (7 << LQ_FLAG_COLOR_POS)
+
+/* Bit 4-5: Tx RTS BW Signalling
+ * (0) No RTS BW signalling
+ * (1) Static BW signalling
+ * (2) Dynamic BW signalling
+ */
+#define LQ_FLAG_RTS_BW_SIG_POS          4
+#define LQ_FLAG_RTS_BW_SIG_NONE         (0 << LQ_FLAG_RTS_BW_SIG_POS)
+#define LQ_FLAG_RTS_BW_SIG_STATIC       (1 << LQ_FLAG_RTS_BW_SIG_POS)
+#define LQ_FLAG_RTS_BW_SIG_DYNAMIC      (2 << LQ_FLAG_RTS_BW_SIG_POS)
+
+/* Bit 6: (0) No dynamic BW selection (1) Allow dynamic BW selection
+ * Dyanmic BW selection allows Tx with narrower BW then requested in rates
+ */
+#define LQ_FLAG_DYNAMIC_BW_POS          6
+#define LQ_FLAG_DYNAMIC_BW_MSK          (1 << LQ_FLAG_DYNAMIC_BW_POS)
 
 /**
  * struct iwl_lq_cmd - link quality command
@@ -293,7 +334,7 @@ enum {
  */
 struct iwl_lq_cmd {
  u8 sta_id;
- u8 reserved1;
+ u8 reduced_tpc;
  u16 control;
  /* LINK_QUAL_GENERAL_PARAMS_API_S_VER_1 */
  u8 flags;
diff --git a/drivers/net/wireless/iwlwifi/mvm/fw-api-scan.h b/drivers/net/wireless/iwlwifi/mvm/fw-api-scan.h
index 365095a..6959fda 100644
--- a/drivers/net/wireless/iwlwifi/mvm/fw-api-scan.h
+++ b/drivers/net/wireless/iwlwifi/mvm/fw-api-scan.h
@@ -5,7 +5,7 @@
  *
  * GPL LICENSE SUMMARY
  *
- * Copyright(c) 2012 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2012 - 2014 Intel Corporation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of version 2 of the GNU General Public License as
@@ -30,7 +30,7 @@
  *
  * BSD LICENSE
  *
- * Copyright(c) 2012 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2012 - 2014 Intel Corporation. All rights reserved.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -137,6 +137,8 @@ struct iwl_ssid_ie {
  *@SCAN_FLAGS_DELAYED_SCAN_LOWBAND:
  *@SCAN_FLAGS_DELAYED_SCAN_HIGHBAND:
  *@SCAN_FLAGS_FRAGMENTED_SCAN:
+ *@SCAN_FLAGS_PASSIVE2ACTIVE: use active scan on channels that was active
+ * in the past hour, even if they are marked as passive.
  */
 enum iwl_scan_flags {
  SCAN_FLAGS_PERIODIC_SCAN  = BIT(0),
@@ -144,6 +146,7 @@ enum iwl_scan_flags {
  SCAN_FLAGS_DELAYED_SCAN_LOWBAND  = BIT(2),
  SCAN_FLAGS_DELAYED_SCAN_HIGHBAND = BIT(3),
  SCAN_FLAGS_FRAGMENTED_SCAN  = BIT(4),
+ SCAN_FLAGS_PASSIVE2ACTIVE  = BIT(5),
 };
 
 /**
@@ -166,8 +169,12 @@ enum iwl_scan_type {
  SCAN_TYPE_DISCOVERY_FORCED = 6,
 }; /* SCAN_ACTIVITY_TYPE_E_VER_1 */
 
-/* Maximal number of channels to scan */
-#define MAX_NUM_SCAN_CHANNELS 0x24
+/**
+ * Maximal number of channels to scan
+ * it should be equal to:
+ * max(IWL_NUM_CHANNELS, IWL_NUM_CHANNELS_FAMILY_8000)
+ */
+#define MAX_NUM_SCAN_CHANNELS 50
 
 /**
  * struct iwl_scan_cmd - scan request command
@@ -178,11 +185,11 @@ enum iwl_scan_type {
  * @quiet_time: in msecs, dwell this time for active scan on quiet channels
  * @quiet_plcp_th: quiet PLCP threshold (channel is quiet if less than
  * this number of packets were received (typically 1)
- * @passive2active: is auto switching from passive to active allowed (0 or 1)
+ * @passive2active: is auto switching from passive to active during scan allowed
  * @rxchain_sel_flags: RXON_RX_CHAIN_*
- * @max_out_time: in usecs, max out of serving channel time
+ * @max_out_time: in TUs, max out of serving channel time
  * @suspend_time: how long to pause scan when returning to service channel:
- * bits 0-19: beacon interal in usecs (suspend before executing)
+ * bits 0-19: beacon interal in TUs (suspend before executing)
  * bits 20-23: reserved
  * bits 24-31: number of beacons (suspend between channels)
  * @rxon_flags: RXON_FLG_*
@@ -353,6 +360,7 @@ struct iwl_scan_complete_notif {
 /* scan offload */
 #define IWL_MAX_SCAN_CHANNELS  40
 #define IWL_SCAN_MAX_BLACKLIST_LEN 64
+#define IWL_SCAN_SHORT_BLACKLIST_LEN 16
 #define IWL_SCAN_MAX_PROFILES  11
 #define SCAN_OFFLOAD_PROBE_REQ_SIZE 512
 
@@ -365,6 +373,12 @@ struct iwl_scan_complete_notif {
 #define IWL_FULL_SCAN_MULTIPLIER 5
 #define IWL_FAST_SCHED_SCAN_ITERATIONS 3
 
+enum scan_framework_client {
+ SCAN_CLIENT_SCHED_SCAN  = BIT(0),
+ SCAN_CLIENT_NETDETECT  = BIT(1),
+ SCAN_CLIENT_ASSET_TRACKING = BIT(2),
+};
+
 /**
  * struct iwl_scan_offload_cmd - SCAN_REQUEST_FIXED_PART_API_S_VER_6
  * @scan_flags:  see enum iwl_scan_flags
@@ -373,8 +387,8 @@ struct iwl_scan_complete_notif {
  * @quiet_plcp_th: quiet channel num of packets threshold
  * @good_CRC_th: passive to active promotion threshold
  * @rx_chain:  RXON rx chain.
- * @max_out_time: max uSec to be out of assoceated channel
- * @suspend_time: pause scan this long when returning to service channel
+ * @max_out_time: max TUs to be out of assoceated channel
+ * @suspend_time: pause scan this TUs when returning to service channel
  * @flags:  RXON flags
  * @filter_flags: RXONfilter
  * @tx_cmd:  tx command for active scan; for 2GHz and for 5GHz.
@@ -446,11 +460,12 @@ struct iwl_scan_offload_cfg {
  * iwl_scan_offload_blacklist - SCAN_OFFLOAD_BLACKLIST_S
  * @ssid:  MAC address to filter out
  * @reported_rssi: AP rssi reported to the host
+ * @client_bitmap: clients ignore this entry  - enum scan_framework_client
  */
 struct iwl_scan_offload_blacklist {
  u8 ssid[ETH_ALEN];
  u8 reported_rssi;
- u8 reserved;
+ u8 client_bitmap;
 } __packed;
 
 enum iwl_scan_offload_network_type {
@@ -472,6 +487,7 @@ enum iwl_scan_offload_band_selection {
  * @aut_alg:  authentication olgorithm to match - bitmap
  * @network_type: enum iwl_scan_offload_network_type
  * @band_selection: enum iwl_scan_offload_band_selection
+ * @client_bitmap: clients waiting for match - enum scan_framework_client
  */
 struct iwl_scan_offload_profile {
  u8 ssid_index;
@@ -479,7 +495,8 @@ struct iwl_scan_offload_profile {
  u8 auth_alg;
  u8 network_type;
  u8 band_selection;
- u8 reserved[3];
+ u8 client_bitmap;
+ u8 reserved[2];
 } __packed;
 
 /**
@@ -488,12 +505,19 @@ struct iwl_scan_offload_profile {
  * @profiles:  profiles to search for match
  * @blacklist_len: length of blacklist
  * @num_profiles: num of profiles in the list
+ * @match_notify: clients waiting for match found notification
+ * @pass_match:  clients waiting for the results
+ * @active_clients: active clients bitmap - enum scan_framework_client
+ * @any_beacon_notify: clients waiting for match notification without match
  */
 struct iwl_scan_offload_profile_cfg {
- struct iwl_scan_offload_blacklist blacklist[IWL_SCAN_MAX_BLACKLIST_LEN];
  struct iwl_scan_offload_profile profiles[IWL_SCAN_MAX_PROFILES];
  u8 blacklist_len;
  u8 num_profiles;
+ u8 match_notify;
+ u8 pass_match;
+ u8 active_clients;
+ u8 any_beacon_notify;
  u8 reserved[2];
 } __packed;
 
@@ -512,16 +536,18 @@ struct iwl_scan_offload_schedule {
 /*
  * iwl_scan_offload_flags
  *
- * IWL_SCAN_OFFLOAD_FLAG_FILTER_SSID: filter mode - upload every beacon or match
- * ssid list.
+ * IWL_SCAN_OFFLOAD_FLAG_PASS_ALL: pass all results - no filtering.
  * IWL_SCAN_OFFLOAD_FLAG_CACHED_CHANNEL: add cached channels to partial scan.
- * IWL_SCAN_OFFLOAD_FLAG_ENERGY_SCAN: use energy based scan before partial scan
- * on A band.
+ * IWL_SCAN_OFFLOAD_FLAG_EBS_QUICK_MODE: EBS duration is 100mSec - typical
+ * beacon period. Finding channel activity in this mode is not guaranteed.
+ * IWL_SCAN_OFFLOAD_FLAG_EBS_ACCURATE_MODE: EBS duration is 200mSec.
+ * Assuming beacon period is 100ms finding channel activity is guaranteed.
  */
 enum iwl_scan_offload_flags {
- IWL_SCAN_OFFLOAD_FLAG_FILTER_SSID = BIT(0),
+ IWL_SCAN_OFFLOAD_FLAG_PASS_ALL  = BIT(0),
  IWL_SCAN_OFFLOAD_FLAG_CACHED_CHANNEL = BIT(2),
- IWL_SCAN_OFFLOAD_FLAG_ENERGY_SCAN = BIT(3),
+ IWL_SCAN_OFFLOAD_FLAG_EBS_QUICK_MODE = BIT(5),
+ IWL_SCAN_OFFLOAD_FLAG_EBS_ACCURATE_MODE = BIT(6),
 };
 
 /**
@@ -544,17 +570,35 @@ enum iwl_scan_offload_compleate_status {
  IWL_SCAN_OFFLOAD_ABORTED = 2,
 };
 
+enum iwl_scan_ebs_status {
+ IWL_SCAN_EBS_SUCCESS,
+ IWL_SCAN_EBS_FAILED,
+ IWL_SCAN_EBS_CHAN_NOT_FOUND,
+};
+
 /**
  * iwl_scan_offload_complete - SCAN_OFFLOAD_COMPLETE_NTF_API_S_VER_1
  * @last_schedule_line:  last schedule line executed (fast or regular)
  * @last_schedule_iteration: last scan iteration executed before scan abort
  * @status:   enum iwl_scan_offload_compleate_status
+ * @ebs_status: last EBS status, see IWL_SCAN_EBS_*
  */
 struct iwl_scan_offload_complete {
  u8 last_schedule_line;
  u8 last_schedule_iteration;
  u8 status;
- u8 reserved;
+ u8 ebs_status;
 } __packed;
 
+/**
+ * iwl_sched_scan_results - SCAN_OFFLOAD_MATCH_FOUND_NTF_API_S_VER_1
+ * @ssid_bitmap: SSIDs indexes found in this iteration
+ * @client_bitmap: clients that are active and wait for this notification
+ */
+struct iwl_sched_scan_results {
+ __le16 ssid_bitmap;
+ u8 client_bitmap;
+ u8 reserved;
+};
+
 #endif
diff --git a/drivers/net/wireless/iwlwifi/mvm/fw-api-sta.h b/drivers/net/wireless/iwlwifi/mvm/fw-api-sta.h
index a30691a..39cebee 100644
--- a/drivers/net/wireless/iwlwifi/mvm/fw-api-sta.h
+++ b/drivers/net/wireless/iwlwifi/mvm/fw-api-sta.h
@@ -5,7 +5,7 @@
  *
  * GPL LICENSE SUMMARY
  *
- * Copyright(c) 2012 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2012 - 2014 Intel Corporation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of version 2 of the GNU General Public License as
@@ -30,7 +30,7 @@
  *
  * BSD LICENSE
  *
- * Copyright(c) 2012 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2012 - 2014 Intel Corporation. All rights reserved.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -97,9 +97,6 @@ enum iwl_sta_flags {
         STA_FLG_FLG_ANT_B),
 
  STA_FLG_PS   = BIT(8),
- STA_FLG_INVALID   = BIT(9),
- STA_FLG_DLP_EN   = BIT(10),
- STA_FLG_SET_ALL_KEYS  = BIT(11),
  STA_FLG_DRAIN_FLOW  = BIT(12),
  STA_FLG_PAN   = BIT(13),
  STA_FLG_CLASS_AUTH  = BIT(14),
@@ -138,7 +135,14 @@ enum iwl_sta_flags {
 
 /**
  * enum iwl_sta_key_flag - key flags for the ADD_STA host command
- * @STA_KEY_FLG_EN_MSK: mask for encryption algorithm
+ * @STA_KEY_FLG_NO_ENC: no encryption
+ * @STA_KEY_FLG_WEP: WEP encryption algorithm
+ * @STA_KEY_FLG_CCM: CCMP encryption algorithm
+ * @STA_KEY_FLG_TKIP: TKIP encryption algorithm
+ * @STA_KEY_FLG_EXT: extended cipher algorithm (depends on the FW support)
+ * @STA_KEY_FLG_CMAC: CMAC encryption algorithm
+ * @STA_KEY_FLG_ENC_UNKNOWN: unknown encryption algorithm
+ * @STA_KEY_FLG_EN_MSK: mask for encryption algorithmi value
  * @STA_KEY_FLG_WEP_KEY_MAP: wep is either a group key (0 - legacy WEP) or from
  * station info array (1 - n 1X mode)
  * @STA_KEY_FLG_KEYID_MSK: the index of the key
@@ -152,6 +156,7 @@ enum iwl_sta_key_flag {
  STA_KEY_FLG_WEP   = (1 << 0),
  STA_KEY_FLG_CCM   = (2 << 0),
  STA_KEY_FLG_TKIP  = (3 << 0),
+ STA_KEY_FLG_EXT   = (4 << 0),
  STA_KEY_FLG_CMAC  = (6 << 0),
  STA_KEY_FLG_ENC_UNKNOWN  = (7 << 0),
  STA_KEY_FLG_EN_MSK  = (7 << 0),
@@ -194,11 +199,14 @@ enum iwl_sta_modify_flag {
  * @STA_SLEEP_STATE_AWAKE:
  * @STA_SLEEP_STATE_PS_POLL:
  * @STA_SLEEP_STATE_UAPSD:
+ * @STA_SLEEP_STATE_MOREDATA: set more-data bit on
+ * (last) released frame
  */
 enum iwl_sta_sleep_flag {
- STA_SLEEP_STATE_AWAKE = 0,
- STA_SLEEP_STATE_PS_POLL = BIT(0),
- STA_SLEEP_STATE_UAPSD = BIT(1),
+ STA_SLEEP_STATE_AWAKE  = 0,
+ STA_SLEEP_STATE_PS_POLL  = BIT(0),
+ STA_SLEEP_STATE_UAPSD  = BIT(1),
+ STA_SLEEP_STATE_MOREDATA = BIT(2),
 };
 
 /* STA ID and color bits definitions */
@@ -247,22 +255,19 @@ struct iwl_mvm_keyinfo {
 } __packed;
 
 /**
- * struct iwl_mvm_add_sta_cmd - Add / modify a station in the fw's station table
+ * struct iwl_mvm_add_sta_cmd - Add/modify a station in the fw's sta table.
  * ( REPLY_ADD_STA = 0x18 )
  * @add_modify: 1: modify existing, 0: add new station
- * @unicast_tx_key_id: unicast tx key id. Relevant only when unicast key sent
- * @multicast_tx_key_id: multicast tx key id. Relevant only when multicast key
- * sent
+ * @awake_acs:
+ * @tid_disable_tx: is tid BIT(tid) enabled for Tx. Clear BIT(x) to enable
+ * AMPDU for tid x. Set %STA_MODIFY_TID_DISABLE_TX to change this field.
  * @mac_id_n_color: the Mac context this station belongs to
  * @addr[ETH_ALEN]: station's MAC address
  * @sta_id: index of station in uCode's station table
  * @modify_mask: STA_MODIFY_*, selects which parameters to modify vs. leave
  * alone. 1 - modify, 0 - don't change.
- * @key: look at %iwl_mvm_keyinfo
  * @station_flags: look at %iwl_sta_flags
  * @station_flags_msk: what of %station_flags have changed
- * @tid_disable_tx: is tid BIT(tid) enabled for Tx. Clear BIT(x) to enable
- * AMPDU for tid x. Set %STA_MODIFY_TID_DISABLE_TX to change this field.
  * @add_immediate_ba_tid: tid for which to add block-ack support (Rx)
  * Set %STA_MODIFY_ADD_BA_TID to use this field, and also set
  * add_immediate_ba_ssn.
@@ -288,20 +293,16 @@ struct iwl_mvm_keyinfo {
  */
 struct iwl_mvm_add_sta_cmd {
  u8 add_modify;
- u8 unicast_tx_key_id;
- u8 multicast_tx_key_id;
- u8 reserved1;
+ u8 awake_acs;
+ __le16 tid_disable_tx;
  __le32 mac_id_n_color;
- u8 addr[ETH_ALEN];
+ u8 addr[ETH_ALEN]; /* _STA_ID_MODIFY_INFO_API_S_VER_1 */
  __le16 reserved2;
  u8 sta_id;
  u8 modify_mask;
  __le16 reserved3;
- struct iwl_mvm_keyinfo key;
  __le32 station_flags;
  __le32 station_flags_msk;
- __le16 tid_disable_tx;
- __le16 reserved4;
  u8 add_immediate_ba_tid;
  u8 remove_immediate_ba_tid;
  __le16 add_immediate_ba_ssn;
@@ -310,7 +311,31 @@ struct iwl_mvm_add_sta_cmd {
  __le16 assoc_id;
  __le16 beamform_flags;
  __le32 tfd_queue_msk;
-} __packed; /* ADD_STA_CMD_API_S_VER_5 */
+} __packed; /* ADD_STA_CMD_API_S_VER_7 */
+
+/**
+ * struct iwl_mvm_add_sta_key_cmd - add/modify sta key
+ * ( REPLY_ADD_STA_KEY = 0x17 )
+ * @sta_id: index of station in uCode's station table
+ * @key_offset: key offset in key storage
+ * @key_flags: type %iwl_sta_key_flag
+ * @key: key material data
+ * @key2: key material data
+ * @rx_secur_seq_cnt: RX security sequence counter for the key
+ * @tkip_rx_tsc_byte2: TSC[2] for key mix ph1 detection
+ * @tkip_rx_ttak: 10-byte unicast TKIP TTAK for Rx
+ */
+struct iwl_mvm_add_sta_key_cmd {
+ u8 sta_id;
+ u8 key_offset;
+ __le16 key_flags;
+ u8 key[16];
+ u8 key2[16];
+ u8 rx_secur_seq_cnt[16];
+ u8 tkip_rx_tsc_byte2;
+ u8 reserved;
+ __le16 tkip_rx_ttak[5];
+} __packed; /* ADD_MODIFY_STA_KEY_API_S_VER_1 */
 
 /**
  * enum iwl_mvm_add_sta_rsp_status - status in the response to ADD_STA command
@@ -376,5 +401,15 @@ struct iwl_mvm_wep_key_cmd {
  struct iwl_mvm_wep_key wep_key[0];
 } __packed; /* SEC_CURR_WEP_KEY_CMD_API_S_VER_2 */
 
+/**
+ * struct iwl_mvm_eosp_notification - EOSP notification from firmware
+ * @remain_frame_count: # of frames remaining, non-zero if SP was cut
+ * short by GO absence
+ * @sta_id: station ID
+ */
+struct iwl_mvm_eosp_notification {
+ __le32 remain_frame_count;
+ __le32 sta_id;
+} __packed; /* UAPSD_EOSP_NTFY_API_S_VER_1 */
 
 #endif /* __fw_api_sta_h__ */
diff --git a/drivers/net/wireless/iwlwifi/mvm/fw-api-tx.h b/drivers/net/wireless/iwlwifi/mvm/fw-api-tx.h
index 007a93b..6cc5f52 100644
--- a/drivers/net/wireless/iwlwifi/mvm/fw-api-tx.h
+++ b/drivers/net/wireless/iwlwifi/mvm/fw-api-tx.h
@@ -5,7 +5,7 @@
  *
  * GPL LICENSE SUMMARY
  *
- * Copyright(c) 2012 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2012 - 2014 Intel Corporation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of version 2 of the GNU General Public License as
@@ -30,7 +30,7 @@
  *
  * BSD LICENSE
  *
- * Copyright(c) 2012 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2012 - 2014 Intel Corporation. All rights reserved.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -76,6 +76,8 @@
  * @TX_CMD_FLG_VHT_NDPA: mark frame is NDPA for VHT beamformer sequence
  * @TX_CMD_FLG_HT_NDPA: mark frame is NDPA for HT beamformer sequence
  * @TX_CMD_FLG_CSI_FDBK2HOST: mark to send feedback to host (only if good CRC)
+ * @TX_CMD_FLG_BT_PRIO_POS: the position of the BT priority (bit 11 is ignored
+ * on old firmwares).
  * @TX_CMD_FLG_BT_DIS: disable BT priority for this frame
  * @TX_CMD_FLG_SEQ_CTL: set if FW should override the sequence control.
  * Should be set for mgmt, non-QOS data, mcast, bcast and in scan command
@@ -91,7 +93,6 @@
  * @TX_CMD_FLG_RESP_TO_DRV: zero this if the response should go only to FW
  * @TX_CMD_FLG_CCMP_AGG: this frame uses CCMP for aggregation acceleration
  * @TX_CMD_FLG_TKIP_MIC_DONE: FW already performed TKIP MIC calculation
- * @TX_CMD_FLG_CTS_ONLY: send CTS only, no data after that
  * @TX_CMD_FLG_DUR: disable duration overwriting used in PS-Poll Assoc-id
  * @TX_CMD_FLG_FW_DROP: FW should mark frame to be dropped
  * @TX_CMD_FLG_EXEC_PAPD: execute PAPD
@@ -108,6 +109,7 @@ enum iwl_tx_flags {
  TX_CMD_FLG_VHT_NDPA  = BIT(8),
  TX_CMD_FLG_HT_NDPA  = BIT(9),
  TX_CMD_FLG_CSI_FDBK2HOST = BIT(10),
+ TX_CMD_FLG_BT_PRIO_POS  = 11,
  TX_CMD_FLG_BT_DIS  = BIT(12),
  TX_CMD_FLG_SEQ_CTL  = BIT(13),
  TX_CMD_FLG_MORE_FRAG  = BIT(14),
@@ -120,7 +122,6 @@ enum iwl_tx_flags {
  TX_CMD_FLG_RESP_TO_DRV  = BIT(21),
  TX_CMD_FLG_CCMP_AGG  = BIT(22),
  TX_CMD_FLG_TKIP_MIC_DONE = BIT(23),
- TX_CMD_FLG_CTS_ONLY  = BIT(24),
  TX_CMD_FLG_DUR   = BIT(25),
  TX_CMD_FLG_FW_DROP  = BIT(26),
  TX_CMD_FLG_EXEC_PAPD  = BIT(27),
@@ -134,6 +135,8 @@ enum iwl_tx_flags {
 #define TX_CMD_SEC_WEP   0x01
 #define TX_CMD_SEC_CCM   0x02
 #define TX_CMD_SEC_TKIP   0x03
+#define TX_CMD_SEC_EXT   0x04
+#define TX_CMD_SEC_MSK   0x07
 #define TX_CMD_SEC_WEP_KEY_IDX_POS 6
 #define TX_CMD_SEC_WEP_KEY_IDX_MSK 0xc0
 #define TX_CMD_SEC_KEY128  0x08
@@ -227,10 +230,11 @@ struct iwl_tx_cmd {
  __le16 len;
  __le16 next_frame_len;
  __le32 tx_flags;
- /* DRAM_SCRATCH_API_U_VER_1 */
- u8 try_cnt;
- u8 btkill_cnt;
- __le16 reserved;
+ struct {
+  u8 try_cnt;
+  u8 btkill_cnt;
+  __le16 reserved;
+ } scratch; /* DRAM_SCRATCH_API_U_VER_1 */
  __le32 rate_n_flags;
  u8 sta_id;
  u8 sec_ctl;
@@ -478,7 +482,8 @@ struct iwl_mvm_tx_resp {
  u8 pa_integ_res_b[3];
  u8 pa_integ_res_c[3];
  __le16 measurement_req_id;
- __le16 reserved;
+ u8 reduced_tpc;
+ u8 reserved;
 
  __le32 tfd_info;
  __le16 seq_ctl;
diff --git a/drivers/net/wireless/iwlwifi/mvm/fw-api.h b/drivers/net/wireless/iwlwifi/mvm/fw-api.h
index c638455..309a9b9 100644
--- a/drivers/net/wireless/iwlwifi/mvm/fw-api.h
+++ b/drivers/net/wireless/iwlwifi/mvm/fw-api.h
@@ -5,7 +5,7 @@
  *
  * GPL LICENSE SUMMARY
  *
- * Copyright(c) 2012 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2012 - 2014 Intel Corporation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of version 2 of the GNU General Public License as
@@ -30,7 +30,7 @@
  *
  * BSD LICENSE
  *
- * Copyright(c) 2012 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2012 - 2014 Intel Corporation. All rights reserved.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -70,19 +70,20 @@
 #include "fw-api-mac.h"
 #include "fw-api-power.h"
 #include "fw-api-d3.h"
-#include "fw-api-bt-coex.h"
+#include "fw-api-coex.h"
+#include "fw-api-scan.h"
 
-/* queue and FIFO numbers by usage */
+/* maximal number of Tx queues in any platform */
+#define IWL_MVM_MAX_QUEUES 20
+
+/* Tx queue numbers */
 enum {
  IWL_MVM_OFFCHANNEL_QUEUE = 8,
  IWL_MVM_CMD_QUEUE = 9,
- IWL_MVM_AUX_QUEUE = 15,
- IWL_MVM_FIRST_AGG_QUEUE = 16,
- IWL_MVM_NUM_QUEUES = 20,
- IWL_MVM_LAST_AGG_QUEUE = IWL_MVM_NUM_QUEUES - 1,
- IWL_MVM_CMD_FIFO = 7
 };
 
+#define IWL_MVM_CMD_FIFO 7
+
 #define IWL_MVM_STATION_COUNT 16
 
 /* commands */
@@ -95,8 +96,10 @@ enum {
  /* PHY context commands */
  PHY_CONTEXT_CMD = 0x8,
  DBG_CFG = 0x9,
+ ANTENNA_COUPLING_NOTIFICATION = 0xa,
 
  /* station table */
+ ADD_STA_KEY = 0x17,
  ADD_STA = 0x18,
  REMOVE_STA = 0x19,
 
@@ -114,6 +117,7 @@ enum {
  TIME_EVENT_NOTIFICATION = 0x2a,
  BINDING_CONTEXT_CMD = 0x2b,
  TIME_QUOTA_CMD = 0x2c,
+ NON_QOS_TX_COUNTER_CMD = 0x2d,
 
  LQ_CMD = 0x4e,
 
@@ -130,14 +134,19 @@ enum {
  SCAN_OFFLOAD_COMPLETE = 0x6D,
  SCAN_OFFLOAD_UPDATE_PROFILES_CMD = 0x6E,
  SCAN_OFFLOAD_CONFIG_CMD = 0x6f,
+ MATCH_FOUND_NOTIFICATION = 0xd9,
 
  /* Phy */
  PHY_CONFIGURATION_CMD = 0x6a,
  CALIB_RES_NOTIF_PHY_DB = 0x6b,
  /* PHY_DB_CMD = 0x6c, */
 
- /* Power */
+ /* Power - legacy power table command */
  POWER_TABLE_CMD = 0x77,
+ PSM_UAPSD_AP_MISBEHAVING_NOTIFICATION = 0x78,
+
+ /* Thermal Throttling*/
+ REPLY_THERMAL_MNG_BACKOFF = 0x7e,
 
  /* Scanning */
  SCAN_REQUEST_CMD = 0x80,
@@ -156,11 +165,18 @@ enum {
  TX_ANT_CONFIGURATION_CMD = 0x98,
  BT_CONFIG = 0x9b,
  STATISTICS_NOTIFICATION = 0x9d,
+ EOSP_NOTIFICATION = 0x9e,
+ REDUCE_TX_POWER_CMD = 0x9f,
 
  /* RF-KILL commands and notifications */
  CARD_STATE_CMD = 0xa0,
  CARD_STATE_NOTIFICATION = 0xa1,
 
+ MISSED_BEACONS_NOTIFICATION = 0xa2,
+
+ /* Power - new power table command */
+ MAC_PM_POWER_TABLE = 0xa9,
+
  REPLY_RX_PHY_CMD = 0xc0,
  REPLY_RX_MPDU_CMD = 0xc1,
  BA_NOTIF = 0xc5,
@@ -169,10 +185,15 @@ enum {
  BT_COEX_PRIO_TABLE = 0xcc,
  BT_COEX_PROT_ENV = 0xcd,
  BT_PROFILE_NOTIFICATION = 0xce,
+ BT_COEX_CI = 0x5d,
+
+ REPLY_SF_CFG_CMD = 0xd1,
+ REPLY_BEACON_FILTERING_CMD = 0xd2,
 
  REPLY_DEBUG_CMD = 0xf0,
  DEBUG_LOG_MSG = 0xf7,
 
+ BCAST_FILTER_CMD = 0xcf,
  MCAST_FILTER_CMD = 0xd0,
 
  /* D3 commands/notifications */
@@ -180,6 +201,7 @@ enum {
  PROT_OFFLOAD_CONFIG_CMD = 0xd4,
  OFFLOADS_QUERY_CMD = 0xd5,
  REMOTE_WAKE_CONFIG_CMD = 0xd6,
+ D0I3_END_CMD = 0xed,
 
  /* for WoWLAN in particular */
  WOWLAN_PATTERNS = 0xe0,
@@ -216,6 +238,19 @@ struct iwl_tx_ant_cfg_cmd {
  __le32 valid;
 } __packed;
 
+/**
+ * struct iwl_reduce_tx_power_cmd - TX power reduction command
+ * REDUCE_TX_POWER_CMD = 0x9f
+ * @flags: (reserved for future implementation)
+ * @mac_context_id: id of the mac ctx for which we are reducing TX power.
+ * @pwr_restriction: TX power restriction in dBms.
+ */
+struct iwl_reduce_tx_power_cmd {
+ u8 flags;
+ u8 mac_context_id;
+ __le16 pwr_restriction;
+} __packed; /* TX_REDUCED_POWER_API_S_VER_1 */
+
 /*
  * Calibration control struct.
  * Sent as part of the phy configuration command.
@@ -283,14 +318,12 @@ enum {
 
 /* Section types for NVM_ACCESS_CMD */
 enum {
- NVM_SECTION_TYPE_HW = 0,
- NVM_SECTION_TYPE_SW,
- NVM_SECTION_TYPE_PAPD,
- NVM_SECTION_TYPE_BT,
- NVM_SECTION_TYPE_CALIBRATION,
- NVM_SECTION_TYPE_PRODUCTION,
- NVM_SECTION_TYPE_POST_FCS_CALIB,
- NVM_NUM_OF_SECTIONS,
+ NVM_SECTION_TYPE_SW = 1,
+ NVM_SECTION_TYPE_REGULATORY = 3,
+ NVM_SECTION_TYPE_CALIBRATION = 4,
+ NVM_SECTION_TYPE_PRODUCTION = 5,
+ NVM_SECTION_TYPE_MAC_OVERRIDE = 11,
+ NVM_MAX_NUM_SECTIONS = 12,
 };
 
 /**
@@ -382,6 +415,35 @@ struct mvm_alive_resp {
  __le32 scd_base_ptr;  /* SRAM address for SCD */
 } __packed; /* ALIVE_RES_API_S_VER_1 */
 
+struct mvm_alive_resp_ver2 {
+ __le16 status;
+ __le16 flags;
+ u8 ucode_minor;
+ u8 ucode_major;
+ __le16 id;
+ u8 api_minor;
+ u8 api_major;
+ u8 ver_subtype;
+ u8 ver_type;
+ u8 mac;
+ u8 opt;
+ __le16 reserved2;
+ __le32 timestamp;
+ __le32 error_event_table_ptr; /* SRAM address for error log */
+ __le32 log_event_table_ptr; /* SRAM address for LMAC event log */
+ __le32 cpu_register_ptr;
+ __le32 dbgm_config_ptr;
+ __le32 alive_counter_ptr;
+ __le32 scd_base_ptr;  /* SRAM address for SCD */
+ __le32 st_fwrd_addr;  /* pointer to Store and forward */
+ __le32 st_fwrd_size;
+ u8 umac_minor;   /* UMAC version: minor */
+ u8 umac_major;   /* UMAC version: major */
+ __le16 umac_id;   /* UMAC version: id */
+ __le32 error_info_addr;  /* SRAM address for UMAC error log */
+ __le32 dbg_print_buff_addr;
+} __packed; /* ALIVE_RES_API_S_VER_2 */
+
 /* Error response/notification */
 enum {
  FW_ERR_UNKNOWN_CMD = 0x0,
@@ -475,71 +537,155 @@ enum iwl_time_event_type {
  TE_MAX
 }; /* MAC_EVENT_TYPE_API_E_VER_1 */
 
+
+
+/* Time event - defines for command API v1 */
+
+/*
+ * @TE_V1_FRAG_NONE: fragmentation of the time event is NOT allowed.
+ * @TE_V1_FRAG_SINGLE: fragmentation of the time event is allowed, but only
+ * the first fragment is scheduled.
+ * @TE_V1_FRAG_DUAL: fragmentation of the time event is allowed, but only
+ * the first 2 fragments are scheduled.
+ * @TE_V1_FRAG_ENDLESS: fragmentation of the time event is allowed, and any
+ * number of fragments are valid.
+ *
+ * Other than the constant defined above, specifying a fragmentation value 'x'
+ * means that the event can be fragmented but only the first 'x' will be
+ * scheduled.
+ */
+enum {
+ TE_V1_FRAG_NONE = 0,
+ TE_V1_FRAG_SINGLE = 1,
+ TE_V1_FRAG_DUAL = 2,
+ TE_V1_FRAG_ENDLESS = 0xffffffff
+};
+
+/* If a Time Event can be fragmented, this is the max number of fragments */
+#define TE_V1_FRAG_MAX_MSK 0x0fffffff
+/* Repeat the time event endlessly (until removed) */
+#define TE_V1_REPEAT_ENDLESS 0xffffffff
+/* If a Time Event has bounded repetitions, this is the maximal value */
+#define TE_V1_REPEAT_MAX_MSK_V1 0x0fffffff
+
 /* Time Event dependencies: none, on another TE, or in a specific time */
 enum {
- TE_INDEPENDENT  = 0,
- TE_DEP_OTHER  = 1,
- TE_DEP_TSF  = 2,
- TE_EVENT_SOCIOPATHIC = 4,
+ TE_V1_INDEPENDENT  = 0,
+ TE_V1_DEP_OTHER   = BIT(0),
+ TE_V1_DEP_TSF   = BIT(1),
+ TE_V1_EVENT_SOCIOPATHIC  = BIT(2),
 }; /* MAC_EVENT_DEPENDENCY_POLICY_API_E_VER_2 */
+
 /*
+ * @TE_V1_NOTIF_NONE: no notifications
+ * @TE_V1_NOTIF_HOST_EVENT_START: request/receive notification on event start
+ * @TE_V1_NOTIF_HOST_EVENT_END:request/receive notification on event end
+ * @TE_V1_NOTIF_INTERNAL_EVENT_START: internal FW use
+ * @TE_V1_NOTIF_INTERNAL_EVENT_END: internal FW use.
+ * @TE_V1_NOTIF_HOST_FRAG_START: request/receive notification on frag start
+ * @TE_V1_NOTIF_HOST_FRAG_END:request/receive notification on frag end
+ * @TE_V1_NOTIF_INTERNAL_FRAG_START: internal FW use.
+ * @TE_V1_NOTIF_INTERNAL_FRAG_END: internal FW use.
+ *
  * Supported Time event notifications configuration.
  * A notification (both event and fragment) includes a status indicating weather
  * the FW was able to schedule the event or not. For fragment start/end
  * notification the status is always success. There is no start/end fragment
  * notification for monolithic events.
- *
- * @TE_NOTIF_NONE: no notifications
- * @TE_NOTIF_HOST_EVENT_START: request/receive notification on event start
- * @TE_NOTIF_HOST_EVENT_END:request/receive notification on event end
- * @TE_NOTIF_INTERNAL_EVENT_START: internal FW use
- * @TE_NOTIF_INTERNAL_EVENT_END: internal FW use.
- * @TE_NOTIF_HOST_FRAG_START: request/receive notification on frag start
- * @TE_NOTIF_HOST_FRAG_END:request/receive notification on frag end
- * @TE_NOTIF_INTERNAL_FRAG_START: internal FW use.
- * @TE_NOTIF_INTERNAL_FRAG_END: internal FW use.
  */
 enum {
- TE_NOTIF_NONE = 0,
- TE_NOTIF_HOST_EVENT_START = 0x1,
- TE_NOTIF_HOST_EVENT_END = 0x2,
- TE_NOTIF_INTERNAL_EVENT_START = 0x4,
- TE_NOTIF_INTERNAL_EVENT_END = 0x8,
- TE_NOTIF_HOST_FRAG_START = 0x10,
- TE_NOTIF_HOST_FRAG_END = 0x20,
- TE_NOTIF_INTERNAL_FRAG_START = 0x40,
- TE_NOTIF_INTERNAL_FRAG_END = 0x80
+ TE_V1_NOTIF_NONE = 0,
+ TE_V1_NOTIF_HOST_EVENT_START = BIT(0),
+ TE_V1_NOTIF_HOST_EVENT_END = BIT(1),
+ TE_V1_NOTIF_INTERNAL_EVENT_START = BIT(2),
+ TE_V1_NOTIF_INTERNAL_EVENT_END = BIT(3),
+ TE_V1_NOTIF_HOST_FRAG_START = BIT(4),
+ TE_V1_NOTIF_HOST_FRAG_END = BIT(5),
+ TE_V1_NOTIF_INTERNAL_FRAG_START = BIT(6),
+ TE_V1_NOTIF_INTERNAL_FRAG_END = BIT(7),
 }; /* MAC_EVENT_ACTION_API_E_VER_2 */
 
+/* Time event - defines for command API */
+
 /*
- * @TE_FRAG_NONE: fragmentation of the time event is NOT allowed.
- * @TE_FRAG_SINGLE: fragmentation of the time event is allowed, but only
+ * @TE_V2_FRAG_NONE: fragmentation of the time event is NOT allowed.
+ * @TE_V2_FRAG_SINGLE: fragmentation of the time event is allowed, but only
  *  the first fragment is scheduled.
- * @TE_FRAG_DUAL: fragmentation of the time event is allowed, but only
+ * @TE_V2_FRAG_DUAL: fragmentation of the time event is allowed, but only
  *  the first 2 fragments are scheduled.
- * @TE_FRAG_ENDLESS: fragmentation of the time event is allowed, and any number
- *  of fragments are valid.
+ * @TE_V2_FRAG_ENDLESS: fragmentation of the time event is allowed, and any
+ *  number of fragments are valid.
  *
  * Other than the constant defined above, specifying a fragmentation value 'x'
  * means that the event can be fragmented but only the first 'x' will be
  * scheduled.
  */
 enum {
- TE_FRAG_NONE = 0,
- TE_FRAG_SINGLE = 1,
- TE_FRAG_DUAL = 2,
- TE_FRAG_ENDLESS = 0xffffffff
+ TE_V2_FRAG_NONE = 0,
+ TE_V2_FRAG_SINGLE = 1,
+ TE_V2_FRAG_DUAL = 2,
+ TE_V2_FRAG_MAX = 0xfe,
+ TE_V2_FRAG_ENDLESS = 0xff
 };
 
 /* Repeat the time event endlessly (until removed) */
-#define TE_REPEAT_ENDLESS (0xffffffff)
+#define TE_V2_REPEAT_ENDLESS 0xff
 /* If a Time Event has bounded repetitions, this is the maximal value */
-#define TE_REPEAT_MAX_MSK (0x0fffffff)
-/* If a Time Event can be fragmented, this is the max number of fragments */
-#define TE_FRAG_MAX_MSK  (0x0fffffff)
+#define TE_V2_REPEAT_MAX 0xfe
+
+#define TE_V2_PLACEMENT_POS 12
+#define TE_V2_ABSENCE_POS 15
+
+/* Time event policy values
+ * A notification (both event and fragment) includes a status indicating weather
+ * the FW was able to schedule the event or not. For fragment start/end
+ * notification the status is always success. There is no start/end fragment
+ * notification for monolithic events.
+ *
+ * @TE_V2_DEFAULT_POLICY: independent, social, present, unoticable
+ * @TE_V2_NOTIF_HOST_EVENT_START: request/receive notification on event start
+ * @TE_V2_NOTIF_HOST_EVENT_END:request/receive notification on event end
+ * @TE_V2_NOTIF_INTERNAL_EVENT_START: internal FW use
+ * @TE_V2_NOTIF_INTERNAL_EVENT_END: internal FW use.
+ * @TE_V2_NOTIF_HOST_FRAG_START: request/receive notification on frag start
+ * @TE_V2_NOTIF_HOST_FRAG_END:request/receive notification on frag end
+ * @TE_V2_NOTIF_INTERNAL_FRAG_START: internal FW use.
+ * @TE_V2_NOTIF_INTERNAL_FRAG_END: internal FW use.
+ * @TE_V2_DEP_OTHER: depends on another time event
+ * @TE_V2_DEP_TSF: depends on a specific time
+ * @TE_V2_EVENT_SOCIOPATHIC: can't co-exist with other events of tha same MAC
+ * @TE_V2_ABSENCE: are we present or absent during the Time Event.
+ */
+enum {
+ TE_V2_DEFAULT_POLICY = 0x0,
+
+ /* notifications (event start/stop, fragment start/stop) */
+ TE_V2_NOTIF_HOST_EVENT_START = BIT(0),
+ TE_V2_NOTIF_HOST_EVENT_END = BIT(1),
+ TE_V2_NOTIF_INTERNAL_EVENT_START = BIT(2),
+ TE_V2_NOTIF_INTERNAL_EVENT_END = BIT(3),
+
+ TE_V2_NOTIF_HOST_FRAG_START = BIT(4),
+ TE_V2_NOTIF_HOST_FRAG_END = BIT(5),
+ TE_V2_NOTIF_INTERNAL_FRAG_START = BIT(6),
+ TE_V2_NOTIF_INTERNAL_FRAG_END = BIT(7),
+ T2_V2_START_IMMEDIATELY = BIT(11),
+
+ TE_V2_NOTIF_MSK = 0xff,
+
+ /* placement characteristics */
+ TE_V2_DEP_OTHER = BIT(TE_V2_PLACEMENT_POS),
+ TE_V2_DEP_TSF = BIT(TE_V2_PLACEMENT_POS + 1),
+ TE_V2_EVENT_SOCIOPATHIC = BIT(TE_V2_PLACEMENT_POS + 2),
+
+ /* are we present or absent during the Time Event. */
+ TE_V2_ABSENCE = BIT(TE_V2_ABSENCE_POS),
+};
 
 /**
- * struct iwl_time_event_cmd - configuring Time Events
+ * struct iwl_time_event_cmd_api - configuring Time Events
+ * with struct MAC_TIME_EVENT_DATA_API_S_VER_2 (see also
+ * with version 1. determined by IWL_UCODE_TLV_FLAGS)
  * ( TIME_EVENT_CMD = 0x29 )
  * @id_and_color: ID and color of the relevant MAC
  * @action: action to perform, one of FW_CTXT_ACTION_*
@@ -551,32 +697,30 @@ enum {
  * @max_delay: maximum delay to event's start (apply time), in TU
  * @depends_on: the unique ID of the event we depend on (if any)
  * @interval: interval between repetitions, in TU
- * @interval_reciprocal: 2^32 / interval
  * @duration: duration of event in TU
  * @repeat: how many repetitions to do, can be TE_REPEAT_ENDLESS
- * @dep_policy: one of TE_INDEPENDENT, TE_DEP_OTHER, TE_DEP_TSF
- * @is_present: 0 or 1, are we present or absent during the Time Event
  * @max_frags: maximal number of fragments the Time Event can be divided to
- * @notify: notifications using TE_NOTIF_* (whom to notify when)
+ * @policy: defines whether uCode shall notify the host or other uCode modules
+ * on event and/or fragment start and/or end
+ * using one of TE_INDEPENDENT, TE_DEP_OTHER, TE_DEP_TSF
+ * TE_EVENT_SOCIOPATHIC
+ * using TE_ABSENCE and using TE_NOTIF_*
  */
 struct iwl_time_event_cmd {
  /* COMMON_INDEX_HDR_API_S_VER_1 */
  __le32 id_and_color;
  __le32 action;
  __le32 id;
- /* MAC_TIME_EVENT_DATA_API_S_VER_1 */
+ /* MAC_TIME_EVENT_DATA_API_S_VER_2 */
  __le32 apply_time;
  __le32 max_delay;
- __le32 dep_policy;
  __le32 depends_on;
- __le32 is_present;
- __le32 max_frags;
  __le32 interval;
- __le32 interval_reciprocal;
  __le32 duration;
- __le32 repeat;
- __le32 notify;
-} __packed; /* MAC_TIME_EVENT_CMD_API_S_VER_1 */
+ u8 repeat;
+ u8 max_frags;
+ __le16 policy;
+} __packed; /* MAC_TIME_EVENT_CMD_API_S_VER_2 */
 
 /**
  * struct iwl_time_event_resp - response structure to iwl_time_event_cmd
@@ -758,6 +902,14 @@ struct iwl_phy_context_cmd {
 } __packed; /* PHY_CONTEXT_CMD_API_VER_1 */
 
 #define IWL_RX_INFO_PHY_CNT 8
+#define IWL_RX_INFO_ENERGY_ANT_ABC_IDX 1
+#define IWL_RX_INFO_ENERGY_ANT_A_MSK 0x000000ff
+#define IWL_RX_INFO_ENERGY_ANT_B_MSK 0x0000ff00
+#define IWL_RX_INFO_ENERGY_ANT_C_MSK 0x00ff0000
+#define IWL_RX_INFO_ENERGY_ANT_A_POS 0
+#define IWL_RX_INFO_ENERGY_ANT_B_POS 8
+#define IWL_RX_INFO_ENERGY_ANT_C_POS 16
+
 #define IWL_RX_INFO_AGC_IDX 1
 #define IWL_RX_INFO_RSSI_AB_IDX 2
 #define IWL_OFDM_AGC_A_MSK 0x0000007f
@@ -890,6 +1042,7 @@ enum iwl_mvm_rx_status {
  RX_MPDU_RES_STATUS_SEC_WEP_ENC   = (1 << 8),
  RX_MPDU_RES_STATUS_SEC_CCM_ENC   = (2 << 8),
  RX_MPDU_RES_STATUS_SEC_TKIP_ENC   = (3 << 8),
+ RX_MPDU_RES_STATUS_SEC_EXT_ENC   = (4 << 8),
  RX_MPDU_RES_STATUS_SEC_CCM_CMAC_ENC  = (6 << 8),
  RX_MPDU_RES_STATUS_SEC_ENC_ERR   = (7 << 8),
  RX_MPDU_RES_STATUS_SEC_ENC_MSK   = (7 << 8),
@@ -938,6 +1091,24 @@ struct iwl_card_state_notif {
 } __packed; /* CARD_STATE_NTFY_API_S_VER_1 */
 
 /**
+ * struct iwl_missed_beacons_notif - information on missed beacons
+ * ( MISSED_BEACONS_NOTIFICATION = 0xa2 )
+ * @mac_id: interface ID
+ * @consec_missed_beacons_since_last_rx: number of consecutive missed
+ * beacons since last RX.
+ * @consec_missed_beacons: number of consecutive missed beacons
+ * @num_expected_beacons:
+ * @num_recvd_beacons:
+ */
+struct iwl_missed_beacons_notif {
+ __le32 mac_id;
+ __le32 consec_missed_beacons_since_last_rx;
+ __le32 consec_missed_beacons;
+ __le32 num_expected_beacons;
+ __le32 num_recvd_beacons;
+} __packed; /* MISSED_BEACON_NTFY_API_S_VER_3 */
+
+/**
  * struct iwl_set_calib_default_cmd - set default value for calibration.
  * ( SET_CALIB_DEFAULT_CMD = 0x8e )
  * @calib_index: the calibration to set value for
@@ -951,6 +1122,7 @@ struct iwl_set_calib_default_cmd {
 } __packed; /* PHY_CALIB_OVERRIDE_VALUES_S */
 
 #define MAX_PORT_ID_NUM 2
+#define MAX_MCAST_FILTERING_ADDRESSES 256
 
 /**
  * struct iwl_mcast_filter_cmd - configure multicast filter.
@@ -975,4 +1147,357 @@ struct iwl_mcast_filter_cmd {
  u8 addr_list[0];
 } __packed; /* MCAST_FILTERING_CMD_API_S_VER_1 */
 
+#define MAX_BCAST_FILTERS 8
+#define MAX_BCAST_FILTER_ATTRS 2
+
+/**
+ * enum iwl_mvm_bcast_filter_attr_offset - written by fw for each Rx packet
+ * @BCAST_FILTER_OFFSET_PAYLOAD_START: offset is from payload start.
+ * @BCAST_FILTER_OFFSET_IP_END: offset is from ip header end (i.e.
+ * start of ip payload).
+ */
+enum iwl_mvm_bcast_filter_attr_offset {
+ BCAST_FILTER_OFFSET_PAYLOAD_START = 0,
+ BCAST_FILTER_OFFSET_IP_END = 1,
+};
+
+/**
+ * struct iwl_fw_bcast_filter_attr - broadcast filter attribute
+ * @offset_type: &enum iwl_mvm_bcast_filter_attr_offset.
+ * @offset: starting offset of this pattern.
+ * @val:  value to match - big endian (MSB is the first
+ *  byte to match from offset pos).
+ * @mask: mask to match (big endian).
+ */
+struct iwl_fw_bcast_filter_attr {
+ u8 offset_type;
+ u8 offset;
+ __le16 reserved1;
+ __be32 val;
+ __be32 mask;
+} __packed; /* BCAST_FILTER_ATT_S_VER_1 */
+
+/**
+ * enum iwl_mvm_bcast_filter_frame_type - filter frame type
+ * @BCAST_FILTER_FRAME_TYPE_ALL: consider all frames.
+ * @BCAST_FILTER_FRAME_TYPE_IPV4: consider only ipv4 frames
+ */
+enum iwl_mvm_bcast_filter_frame_type {
+ BCAST_FILTER_FRAME_TYPE_ALL = 0,
+ BCAST_FILTER_FRAME_TYPE_IPV4 = 1,
+};
+
+/**
+ * struct iwl_fw_bcast_filter - broadcast filter
+ * @discard: discard frame (1) or let it pass (0).
+ * @frame_type: &enum iwl_mvm_bcast_filter_frame_type.
+ * @num_attrs: number of valid attributes in this filter.
+ * @attrs: attributes of this filter. a filter is considered matched
+ * only when all its attributes are matched (i.e. AND relationship)
+ */
+struct iwl_fw_bcast_filter {
+ u8 discard;
+ u8 frame_type;
+ u8 num_attrs;
+ u8 reserved1;
+ struct iwl_fw_bcast_filter_attr attrs[MAX_BCAST_FILTER_ATTRS];
+} __packed; /* BCAST_FILTER_S_VER_1 */
+
+/**
+ * struct iwl_fw_bcast_mac - per-mac broadcast filtering configuration.
+ * @default_discard: default action for this mac (discard (1) / pass (0)).
+ * @attached_filters: bitmap of relevant filters for this mac.
+ */
+struct iwl_fw_bcast_mac {
+ u8 default_discard;
+ u8 reserved1;
+ __le16 attached_filters;
+} __packed; /* BCAST_MAC_CONTEXT_S_VER_1 */
+
+/**
+ * struct iwl_bcast_filter_cmd - broadcast filtering configuration
+ * @disable: enable (0) / disable (1)
+ * @max_bcast_filters: max number of filters (MAX_BCAST_FILTERS)
+ * @max_macs: max number of macs (NUM_MAC_INDEX_DRIVER)
+ * @filters: broadcast filters
+ * @macs: broadcast filtering configuration per-mac
+ */
+struct iwl_bcast_filter_cmd {
+ u8 disable;
+ u8 max_bcast_filters;
+ u8 max_macs;
+ u8 reserved1;
+ struct iwl_fw_bcast_filter filters[MAX_BCAST_FILTERS];
+ struct iwl_fw_bcast_mac macs[NUM_MAC_INDEX_DRIVER];
+} __packed; /* BCAST_FILTERING_HCMD_API_S_VER_1 */
+
+struct mvm_statistics_dbg {
+ __le32 burst_check;
+ __le32 burst_count;
+ __le32 wait_for_silence_timeout_cnt;
+ __le32 reserved[3];
+} __packed; /* STATISTICS_DEBUG_API_S_VER_2 */
+
+struct mvm_statistics_div {
+ __le32 tx_on_a;
+ __le32 tx_on_b;
+ __le32 exec_time;
+ __le32 probe_time;
+ __le32 rssi_ant;
+ __le32 reserved2;
+} __packed; /* STATISTICS_SLOW_DIV_API_S_VER_2 */
+
+struct mvm_statistics_general_common {
+ __le32 temperature;   /* radio temperature */
+ __le32 temperature_m; /* radio voltage */
+ struct mvm_statistics_dbg dbg;
+ __le32 sleep_time;
+ __le32 slots_out;
+ __le32 slots_idle;
+ __le32 ttl_timestamp;
+ struct mvm_statistics_div div;
+ __le32 rx_enable_counter;
+ /*
+  * num_of_sos_states:
+  *  count the number of times we have to re-tune
+  *  in order to get out of bad PHY status
+  */
+ __le32 num_of_sos_states;
+} __packed; /* STATISTICS_GENERAL_API_S_VER_5 */
+
+struct mvm_statistics_rx_non_phy {
+ __le32 bogus_cts; /* CTS received when not expecting CTS */
+ __le32 bogus_ack; /* ACK received when not expecting ACK */
+ __le32 non_bssid_frames; /* number of frames with BSSID that
+      * doesn't belong to the STA BSSID */
+ __le32 filtered_frames; /* count frames that were dumped in the
+     * filtering process */
+ __le32 non_channel_beacons; /* beacons with our bss id but not on
+      * our serving channel */
+ __le32 channel_beacons; /* beacons with our bss id and in our
+     * serving channel */
+ __le32 num_missed_bcon; /* number of missed beacons */
+ __le32 adc_rx_saturation_time; /* count in 0.8us units the time the
+      * ADC was in saturation */
+ __le32 ina_detection_search_time;/* total time (in 0.8us) searched
+       * for INA */
+ __le32 beacon_silence_rssi_a; /* RSSI silence after beacon frame */
+ __le32 beacon_silence_rssi_b; /* RSSI silence after beacon frame */
+ __le32 beacon_silence_rssi_c; /* RSSI silence after beacon frame */
+ __le32 interference_data_flag; /* flag for interference data
+      * availability. 1 when data is
+      * available. */
+ __le32 channel_load;  /* counts RX Enable time in uSec */
+ __le32 dsp_false_alarms; /* DSP false alarm (both OFDM
+      * and CCK) counter */
+ __le32 beacon_rssi_a;
+ __le32 beacon_rssi_b;
+ __le32 beacon_rssi_c;
+ __le32 beacon_energy_a;
+ __le32 beacon_energy_b;
+ __le32 beacon_energy_c;
+ __le32 num_bt_kills;
+ __le32 mac_id;
+ __le32 directed_data_mpdu;
+} __packed; /* STATISTICS_RX_NON_PHY_API_S_VER_3 */
+
+struct mvm_statistics_rx_phy {
+ __le32 ina_cnt;
+ __le32 fina_cnt;
+ __le32 plcp_err;
+ __le32 crc32_err;
+ __le32 overrun_err;
+ __le32 early_overrun_err;
+ __le32 crc32_good;
+ __le32 false_alarm_cnt;
+ __le32 fina_sync_err_cnt;
+ __le32 sfd_timeout;
+ __le32 fina_timeout;
+ __le32 unresponded_rts;
+ __le32 rxe_frame_limit_overrun;
+ __le32 sent_ack_cnt;
+ __le32 sent_cts_cnt;
+ __le32 sent_ba_rsp_cnt;
+ __le32 dsp_self_kill;
+ __le32 mh_format_err;
+ __le32 re_acq_main_rssi_sum;
+ __le32 reserved;
+} __packed; /* STATISTICS_RX_PHY_API_S_VER_2 */
+
+struct mvm_statistics_rx_ht_phy {
+ __le32 plcp_err;
+ __le32 overrun_err;
+ __le32 early_overrun_err;
+ __le32 crc32_good;
+ __le32 crc32_err;
+ __le32 mh_format_err;
+ __le32 agg_crc32_good;
+ __le32 agg_mpdu_cnt;
+ __le32 agg_cnt;
+ __le32 unsupport_mcs;
+} __packed;  /* STATISTICS_HT_RX_PHY_API_S_VER_1 */
+
+#define MAX_CHAINS 3
+
+struct mvm_statistics_tx_non_phy_agg {
+ __le32 ba_timeout;
+ __le32 ba_reschedule_frames;
+ __le32 scd_query_agg_frame_cnt;
+ __le32 scd_query_no_agg;
+ __le32 scd_query_agg;
+ __le32 scd_query_mismatch;
+ __le32 frame_not_ready;
+ __le32 underrun;
+ __le32 bt_prio_kill;
+ __le32 rx_ba_rsp_cnt;
+ __s8 txpower[MAX_CHAINS];
+ __s8 reserved;
+ __le32 reserved2;
+} __packed; /* STATISTICS_TX_NON_PHY_AGG_API_S_VER_1 */
+
+struct mvm_statistics_tx_channel_width {
+ __le32 ext_cca_narrow_ch20[1];
+ __le32 ext_cca_narrow_ch40[2];
+ __le32 ext_cca_narrow_ch80[3];
+ __le32 ext_cca_narrow_ch160[4];
+ __le32 last_tx_ch_width_indx;
+ __le32 rx_detected_per_ch_width[4];
+ __le32 success_per_ch_width[4];
+ __le32 fail_per_ch_width[4];
+}; /* STATISTICS_TX_CHANNEL_WIDTH_API_S_VER_1 */
+
+struct mvm_statistics_tx {
+ __le32 preamble_cnt;
+ __le32 rx_detected_cnt;
+ __le32 bt_prio_defer_cnt;
+ __le32 bt_prio_kill_cnt;
+ __le32 few_bytes_cnt;
+ __le32 cts_timeout;
+ __le32 ack_timeout;
+ __le32 expected_ack_cnt;
+ __le32 actual_ack_cnt;
+ __le32 dump_msdu_cnt;
+ __le32 burst_abort_next_frame_mismatch_cnt;
+ __le32 burst_abort_missing_next_frame_cnt;
+ __le32 cts_timeout_collision;
+ __le32 ack_or_ba_timeout_collision;
+ struct mvm_statistics_tx_non_phy_agg agg;
+ struct mvm_statistics_tx_channel_width channel_width;
+} __packed; /* STATISTICS_TX_API_S_VER_4 */
+
+
+struct mvm_statistics_bt_activity {
+ __le32 hi_priority_tx_req_cnt;
+ __le32 hi_priority_tx_denied_cnt;
+ __le32 lo_priority_tx_req_cnt;
+ __le32 lo_priority_tx_denied_cnt;
+ __le32 hi_priority_rx_req_cnt;
+ __le32 hi_priority_rx_denied_cnt;
+ __le32 lo_priority_rx_req_cnt;
+ __le32 lo_priority_rx_denied_cnt;
+} __packed;  /* STATISTICS_BT_ACTIVITY_API_S_VER_1 */
+
+struct mvm_statistics_general {
+ struct mvm_statistics_general_common common;
+ __le32 beacon_filtered;
+ __le32 missed_beacons;
+ __s8 beacon_filter_average_energy;
+ __s8 beacon_filter_reason;
+ __s8 beacon_filter_current_energy;
+ __s8 beacon_filter_reserved;
+ __le32 beacon_filter_delta_time;
+ struct mvm_statistics_bt_activity bt_activity;
+} __packed; /* STATISTICS_GENERAL_API_S_VER_5 */
+
+struct mvm_statistics_rx {
+ struct mvm_statistics_rx_phy ofdm;
+ struct mvm_statistics_rx_phy cck;
+ struct mvm_statistics_rx_non_phy general;
+ struct mvm_statistics_rx_ht_phy ofdm_ht;
+} __packed; /* STATISTICS_RX_API_S_VER_3 */
+
+/*
+ * STATISTICS_NOTIFICATION = 0x9d (notification only, not a command)
+ *
+ * By default, uCode issues this notification after receiving a beacon
+ * while associated.  To disable this behavior, set DISABLE_NOTIF flag in the
+ * REPLY_STATISTICS_CMD 0x9c, above.
+ *
+ * Statistics counters continue to increment beacon after beacon, but are
+ * cleared when changing channels or when driver issues REPLY_STATISTICS_CMD
+ * 0x9c with CLEAR_STATS bit set (see above).
+ *
+ * uCode also issues this notification during scans.  uCode clears statistics
+ * appropriately so that each notification contains statistics for only the
+ * one channel that has just been scanned.
+ */
+
+struct iwl_notif_statistics { /* STATISTICS_NTFY_API_S_VER_8 */
+ __le32 flag;
+ struct mvm_statistics_rx rx;
+ struct mvm_statistics_tx tx;
+ struct mvm_statistics_general general;
+} __packed;
+
+/***********************************
+ * Smart Fifo API
+ ***********************************/
+/* Smart Fifo state */
+enum iwl_sf_state {
+ SF_LONG_DELAY_ON = 0, /* should never be called by driver */
+ SF_FULL_ON,
+ SF_UNINIT,
+ SF_INIT_OFF,
+ SF_HW_NUM_STATES
+};
+
+/* Smart Fifo possible scenario */
+enum iwl_sf_scenario {
+ SF_SCENARIO_SINGLE_UNICAST,
+ SF_SCENARIO_AGG_UNICAST,
+ SF_SCENARIO_MULTICAST,
+ SF_SCENARIO_BA_RESP,
+ SF_SCENARIO_TX_RESP,
+ SF_NUM_SCENARIO
+};
+
+#define SF_TRANSIENT_STATES_NUMBER 2 /* SF_LONG_DELAY_ON and SF_FULL_ON */
+#define SF_NUM_TIMEOUT_TYPES 2  /* Aging timer and Idle timer */
+
+/* smart FIFO default values */
+#define SF_W_MARK_SISO 4096
+#define SF_W_MARK_MIMO2 8192
+#define SF_W_MARK_MIMO3 6144
+#define SF_W_MARK_LEGACY 4096
+#define SF_W_MARK_SCAN 4096
+
+/* SF Scenarios timers for FULL_ON state (aligned to 32 uSec) */
+#define SF_SINGLE_UNICAST_IDLE_TIMER 320 /* 300 uSec  */
+#define SF_SINGLE_UNICAST_AGING_TIMER 2016 /* 2 mSec */
+#define SF_AGG_UNICAST_IDLE_TIMER 320  /* 300 uSec */
+#define SF_AGG_UNICAST_AGING_TIMER 2016  /* 2 mSec */
+#define SF_MCAST_IDLE_TIMER 2016  /* 2 mSec */
+#define SF_MCAST_AGING_TIMER 10016  /* 10 mSec */
+#define SF_BA_IDLE_TIMER 320   /* 300 uSec */
+#define SF_BA_AGING_TIMER 2016   /* 2 mSec */
+#define SF_TX_RE_IDLE_TIMER 320   /* 300 uSec */
+#define SF_TX_RE_AGING_TIMER 2016  /* 2 mSec */
+
+#define SF_LONG_DELAY_AGING_TIMER 1000000 /* 1 Sec */
+
+/**
+ * Smart Fifo configuration command.
+ * @state: smart fifo state, types listed in iwl_sf_sate.
+ * @watermark: Minimum allowed availabe free space in RXF for transient state.
+ * @long_delay_timeouts: aging and idle timer values for each scenario
+ * in long delay state.
+ * @full_on_timeouts: timer values for each scenario in full on state.
+ */
+struct iwl_sf_cfg_cmd {
+ enum iwl_sf_state state;
+ __le32 watermark[SF_TRANSIENT_STATES_NUMBER];
+ __le32 long_delay_timeouts[SF_NUM_SCENARIO][SF_NUM_TIMEOUT_TYPES];
+ __le32 full_on_timeouts[SF_NUM_SCENARIO][SF_NUM_TIMEOUT_TYPES];
+} __packed; /* SF_CFG_API_S_VER_2 */
+
 #endif /* __fw_api_h__ */
diff --git a/drivers/net/wireless/iwlwifi/mvm/fw.c b/drivers/net/wireless/iwlwifi/mvm/fw.c
index e18c92d..883e702 100644
--- a/drivers/net/wireless/iwlwifi/mvm/fw.c
+++ b/drivers/net/wireless/iwlwifi/mvm/fw.c
@@ -5,7 +5,7 @@
  *
  * GPL LICENSE SUMMARY
  *
- * Copyright(c) 2012 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2012 - 2014 Intel Corporation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of version 2 of the GNU General Public License as
@@ -30,7 +30,7 @@
  *
  * BSD LICENSE
  *
- * Copyright(c) 2012 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2012 - 2014 Intel Corporation. All rights reserved.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -78,22 +78,6 @@
 
 #define UCODE_VALID_OK cpu_to_le32(0x1)
 
-/* Default calibration values for WkP - set to INIT image w/o running */
-static const u8 wkp_calib_values_rx_iq_skew[] = { 0x00, 0x00, 0x01, 0x00 };
-static const u8 wkp_calib_values_tx_iq_skew[] = { 0x01, 0x00, 0x00, 0x00 };
-
-struct iwl_calib_default_data {
- u16 size;
- void *data;
-};
-
-#define CALIB_SIZE_N_DATA(_buf) {.size = sizeof(_buf), .data = &_buf}
-
-static const struct iwl_calib_default_data wkp_calib_default_data[12] = {
- [9] = CALIB_SIZE_N_DATA(wkp_calib_values_tx_iq_skew),
- [11] = CALIB_SIZE_N_DATA(wkp_calib_values_rx_iq_skew),
-};
-
 struct iwl_mvm_alive_data {
  bool valid;
  u32 scd_base_addr;
@@ -115,7 +99,7 @@ static int iwl_send_tx_ant_cfg(struct iwl_mvm *mvm, u8 valid_tx_ant)
  };
 
  IWL_DEBUG_FW(mvm, "select valid tx ant: %u\n", valid_tx_ant);
- return iwl_mvm_send_cmd_pdu(mvm, TX_ANT_CONFIGURATION_CMD, CMD_SYNC,
+ return iwl_mvm_send_cmd_pdu(mvm, TX_ANT_CONFIGURATION_CMD, 0,
         sizeof(tx_ant_cmd), &tx_ant_cmd);
 }
 
@@ -126,18 +110,50 @@ static bool iwl_alive_fn(struct iwl_notif_wait_data *notif_wait,
   container_of(notif_wait, struct iwl_mvm, notif_wait);
  struct iwl_mvm_alive_data *alive_data = data;
  struct mvm_alive_resp *palive;
-
- palive = (void *)pkt->data;
-
- mvm->error_event_table = le32_to_cpu(palive->error_event_table_ptr);
- mvm->log_event_table = le32_to_cpu(palive->log_event_table_ptr);
- alive_data->scd_base_addr = le32_to_cpu(palive->scd_base_ptr);
-
- alive_data->valid = le16_to_cpu(palive->status) == IWL_ALIVE_STATUS_OK;
- IWL_DEBUG_FW(mvm,
-       "Alive ucode status 0x%04x revision 0x%01X 0x%01X flags 0x%01X\n",
-       le16_to_cpu(palive->status), palive->ver_type,
-       palive->ver_subtype, palive->flags);
+ struct mvm_alive_resp_ver2 *palive2;
+
+ if (iwl_rx_packet_payload_len(pkt) == sizeof(*palive)) {
+  palive = (void *)pkt->data;
+
+  mvm->support_umac_log = false;
+  mvm->error_event_table =
+   le32_to_cpu(palive->error_event_table_ptr);
+  mvm->log_event_table = le32_to_cpu(palive->log_event_table_ptr);
+  alive_data->scd_base_addr = le32_to_cpu(palive->scd_base_ptr);
+
+  alive_data->valid = le16_to_cpu(palive->status) ==
+        IWL_ALIVE_STATUS_OK;
+  IWL_DEBUG_FW(mvm,
+        "Alive VER1 ucode status 0x%04x revision 0x%01X 0x%01X flags 0x%01X\n",
+        le16_to_cpu(palive->status), palive->ver_type,
+        palive->ver_subtype, palive->flags);
+ } else {
+  palive2 = (void *)pkt->data;
+
+  mvm->error_event_table =
+   le32_to_cpu(palive2->error_event_table_ptr);
+  mvm->log_event_table =
+   le32_to_cpu(palive2->log_event_table_ptr);
+  alive_data->scd_base_addr = le32_to_cpu(palive2->scd_base_ptr);
+  mvm->umac_error_event_table =
+   le32_to_cpu(palive2->error_info_addr);
+  mvm->sf_space.addr = le32_to_cpu(palive2->st_fwrd_addr);
+  mvm->sf_space.size = le32_to_cpu(palive2->st_fwrd_size);
+
+  alive_data->valid = le16_to_cpu(palive2->status) ==
+        IWL_ALIVE_STATUS_OK;
+  if (mvm->umac_error_event_table)
+   mvm->support_umac_log = true;
+
+  IWL_DEBUG_FW(mvm,
+        "Alive VER2 ucode status 0x%04x revision 0x%01X 0x%01X flags 0x%01X\n",
+        le16_to_cpu(palive2->status), palive2->ver_type,
+        palive2->ver_subtype, palive2->flags);
+
+  IWL_DEBUG_FW(mvm,
+        "UMAC version: Major - 0x%x, Minor - 0x%x\n",
+        palive2->umac_major, palive2->umac_minor);
+ }
 
  return true;
 }
@@ -166,14 +182,13 @@ static int iwl_mvm_load_ucode_wait_alive(struct iwl_mvm *mvm,
  int ret, i;
  enum iwl_ucode_type old_type = mvm->cur_ucode;
  static const u8 alive_cmd[] = { MVM_ALIVE };
+ struct iwl_sf_region st_fwrd_space;
 
- mvm->cur_ucode = ucode_type;
  fw = iwl_get_ucode_image(mvm, ucode_type);
-
- mvm->ucode_loaded = false;
-
- if (!fw)
+ if (WARN_ON(!fw))
   return -EINVAL;
+ mvm->cur_ucode = ucode_type;
+ mvm->ucode_loaded = false;
 
  iwl_init_notification_wait(&mvm->notif_wait, &alive_wait,
        alive_cmd, ARRAY_SIZE(alive_cmd),
@@ -203,6 +218,14 @@ static int iwl_mvm_load_ucode_wait_alive(struct iwl_mvm *mvm,
   return -EIO;
  }
 
+ /*
+  * update the sdio allocation according to the pointer we get in the
+  * alive notification.
+  */
+ st_fwrd_space.addr = mvm->sf_space.addr;
+ st_fwrd_space.size = mvm->sf_space.size;
+ ret = iwl_trans_update_sf(mvm->trans, &st_fwrd_space);
+
  iwl_trans_fw_alive(mvm->trans, alive_data.scd_base_addr);
 
  /*
@@ -215,7 +238,7 @@ static int iwl_mvm_load_ucode_wait_alive(struct iwl_mvm *mvm,
   */
 
  for (i = 0; i < IWL_MAX_HW_QUEUES; i++) {
-  if (i < IWL_MVM_FIRST_AGG_QUEUE && i != IWL_MVM_CMD_QUEUE)
+  if (i < mvm->first_agg_queue && i != IWL_MVM_CMD_QUEUE)
    mvm->queue_to_mac80211[i] = i;
   else
    mvm->queue_to_mac80211[i] = IWL_INVALID_MAC80211_QUEUE;
@@ -244,44 +267,10 @@ static int iwl_send_phy_cfg_cmd(struct iwl_mvm *mvm)
  IWL_DEBUG_INFO(mvm, "Sending Phy CFG command: 0x%x\n",
          phy_cfg_cmd.phy_cfg);
 
- return iwl_mvm_send_cmd_pdu(mvm, PHY_CONFIGURATION_CMD, CMD_SYNC,
+ return iwl_mvm_send_cmd_pdu(mvm, PHY_CONFIGURATION_CMD, 0,
         sizeof(phy_cfg_cmd), &phy_cfg_cmd);
 }
 
-static int iwl_set_default_calibrations(struct iwl_mvm *mvm)
-{
- u8 cmd_raw[16]; /* holds the variable size commands */
- struct iwl_set_calib_default_cmd *cmd =
-  (struct iwl_set_calib_default_cmd *)cmd_raw;
- int ret, i;
-
- /* Setting default values for calibrations we don't run */
- for (i = 0; i < ARRAY_SIZE(wkp_calib_default_data); i++) {
-  u16 cmd_len;
-
-  if (wkp_calib_default_data[i].size == 0)
-   continue;
-
-  memset(cmd_raw, 0, sizeof(cmd_raw));
-  cmd_len = wkp_calib_default_data[i].size + sizeof(cmd);
-  cmd->calib_index = cpu_to_le16(i);
-  cmd->length = cpu_to_le16(wkp_calib_default_data[i].size);
-  if (WARN_ONCE(cmd_len > sizeof(cmd_raw),
-         "Need to enlarge cmd_raw to %d\n", cmd_len))
-   break;
-  memcpy(cmd->data, wkp_calib_default_data[i].data,
-         wkp_calib_default_data[i].size);
-  ret = iwl_mvm_send_cmd_pdu(mvm, SET_CALIB_DEFAULT_CMD, 0,
-        sizeof(*cmd) +
-        wkp_calib_default_data[i].size,
-        cmd);
-  if (ret)
-   return ret;
- }
-
- return 0;
-}
-
 int iwl_run_init_mvm_ucode(struct iwl_mvm *mvm, bool read_nvm)
 {
  struct iwl_notification_wait calib_wait;
@@ -293,7 +282,7 @@ int iwl_run_init_mvm_ucode(struct iwl_mvm *mvm, bool read_nvm)
 
  lockdep_assert_held(&mvm->mutex);
 
- if (mvm->init_ucode_run)
+ if (WARN_ON_ONCE(mvm->init_ucode_complete))
   return 0;
 
  iwl_init_notification_wait(&mvm->notif_wait,
@@ -310,29 +299,41 @@ int iwl_run_init_mvm_ucode(struct iwl_mvm *mvm, bool read_nvm)
   goto error;
  }
 
- ret = iwl_send_bt_prio_tbl(mvm);
+ ret = iwl_send_bt_init_conf(mvm);
  if (ret)
   goto error;
 
+ /* Read the NVM only at driver load time, no need to do this twice */
  if (read_nvm) {
   /* Read nvm */
-  ret = iwl_nvm_init(mvm);
+  ret = iwl_nvm_init(mvm, true);
   if (ret) {
    IWL_ERR(mvm, "Failed to read NVM: %d\n", ret);
    goto error;
   }
  }
 
+ /* In case we read the NVM from external file, load it to the NIC */
+ if (mvm->nvm_file_name)
+  iwl_mvm_load_nvm_to_nic(mvm);
+
  ret = iwl_nvm_check_version(mvm->nvm_data, mvm->trans);
  WARN_ON(ret);
 
- /* Send TX valid antennas before triggering calibrations */
- ret = iwl_send_tx_ant_cfg(mvm, iwl_fw_valid_tx_ant(mvm->fw));
- if (ret)
-  goto error;
+ /*
+  * abort after reading the nvm in case RF Kill is on, we will complete
+  * the init seq later when RF kill will switch to off
+  */
+ if (iwl_mvm_is_radio_killed(mvm)) {
+  IWL_DEBUG_RF_KILL(mvm,
+      "jump over all phy activities due to RF kill\n");
+  iwl_remove_notification(&mvm->notif_wait, &calib_wait);
+  ret = 1;
+  goto out;
+ }
 
- /* need to set default values */
- ret = iwl_set_default_calibrations(mvm);
+ /* Send TX valid antennas before triggering calibrations */
+ ret = iwl_send_tx_ant_cfg(mvm, mvm->fw->valid_tx_ant);
  if (ret)
   goto error;
 
@@ -354,15 +355,13 @@ int iwl_run_init_mvm_ucode(struct iwl_mvm *mvm, bool read_nvm)
  ret = iwl_wait_notification(&mvm->notif_wait, &calib_wait,
    MVM_UCODE_CALIB_TIMEOUT);
  if (!ret)
-  mvm->init_ucode_run = true;
+  mvm->init_ucode_complete = true;
  goto out;
 
 error:
  iwl_remove_notification(&mvm->notif_wait, &calib_wait);
 out:
- if (!iwlmvm_mod_params.init_dbg) {
-  iwl_trans_stop_device(mvm->trans);
- } else if (!mvm->nvm_data) {
+ if (iwlmvm_mod_params.init_dbg && !mvm->nvm_data) {
   /* we want to debug INIT and we have no NVM - fake */
   mvm->nvm_data = kzalloc(sizeof(struct iwl_nvm_data) +
      sizeof(struct ieee80211_channel) +
@@ -370,8 +369,6 @@ out:
      GFP_KERNEL);
   if (!mvm->nvm_data)
    return -ENOMEM;
-  mvm->nvm_data->valid_rx_ant = 1;
-  mvm->nvm_data->valid_tx_ant = 1;
   mvm->nvm_data->bands[0].channels = mvm->nvm_data->channels;
   mvm->nvm_data->bands[0].n_channels = 1;
   mvm->nvm_data->bands[0].n_bitrates = 1;
@@ -383,11 +380,11 @@ out:
  return ret;
 }
 
-#define UCODE_CALIB_TIMEOUT (2*HZ)
-
 int iwl_mvm_up(struct iwl_mvm *mvm)
 {
  int ret, i;
+ struct ieee80211_channel *chan;
+ struct cfg80211_chan_def chandef;
 
  lockdep_assert_held(&mvm->mutex);
 
@@ -395,13 +392,30 @@ int iwl_mvm_up(struct iwl_mvm *mvm)
  if (ret)
   return ret;
 
- /* If we were in RFKILL during module loading, load init ucode now */
- if (!mvm->init_ucode_run) {
+ /*
+  * If we haven't completed the run of the init ucode during
+  * module loading, load init ucode now
+  * (for example, if we were in RFKILL)
+  */
+ if (!mvm->init_ucode_complete) {
   ret = iwl_run_init_mvm_ucode(mvm, false);
   if (ret && !iwlmvm_mod_params.init_dbg) {
    IWL_ERR(mvm, "Failed to run INIT ucode: %d\n", ret);
+   /* this can't happen */
+   if (WARN_ON(ret > 0))
+    ret = -ERFKILL;
    goto error;
   }
+  if (!iwlmvm_mod_params.init_dbg) {
+   /*
+    * should stop and start HW since that INIT
+    * image just loaded
+    */
+   iwl_trans_stop_device(mvm->trans);
+   ret = iwl_trans_start_hw(mvm->trans);
+   if (ret)
+    return ret;
+  }
  }
 
  if (iwlmvm_mod_params.init_dbg)
@@ -413,11 +427,11 @@ int iwl_mvm_up(struct iwl_mvm *mvm)
   goto error;
  }
 
- ret = iwl_send_tx_ant_cfg(mvm, iwl_fw_valid_tx_ant(mvm->fw));
+ ret = iwl_mvm_sf_update(mvm, NULL, false);
  if (ret)
-  goto error;
+  IWL_ERR(mvm, "Failed to initialize Smart Fifo\n");
 
- ret = iwl_send_bt_prio_tbl(mvm);
+ ret = iwl_send_tx_ant_cfg(mvm, mvm->fw->valid_tx_ant);
  if (ret)
   goto error;
 
@@ -443,8 +457,33 @@ int iwl_mvm_up(struct iwl_mvm *mvm)
  if (ret)
   goto error;
 
- IWL_DEBUG_INFO(mvm, "RT uCode started.\n");
+ /* Add all the PHY contexts */
+ chan = &mvm->hw->wiphy->bands[IEEE80211_BAND_2GHZ]->channels[0];
+ cfg80211_chandef_create(&chandef, chan, NL80211_CHAN_NO_HT);
+ for (i = 0; i < NUM_PHY_CTX; i++) {
+  /*
+   * The channel used here isn't relevant as it's
+   * going to be overwritten in the other flows.
+   * For now use the first channel we have.
+   */
+  ret = iwl_mvm_phy_ctxt_add(mvm, &mvm->phy_ctxts[i],
+        &chandef, 1, 1);
+  if (ret)
+   goto error;
+ }
 
+ /* Initialize tx backoffs to the minimal possible */
+ iwl_mvm_tt_tx_backoff(mvm, 0);
+
+ ret = iwl_mvm_power_update_device(mvm);
+ if (ret)
+  goto error;
+
+ /* allow FW/transport low power modes if not during restart */
+ if (!test_bit(IWL_MVM_STATUS_IN_HW_RESTART, &mvm->status))
+  iwl_mvm_unref(mvm, IWL_MVM_REF_UCODE_DOWN);
+
+ IWL_DEBUG_INFO(mvm, "RT uCode started.\n");
  return 0;
  error:
  iwl_trans_stop_device(mvm->trans);
@@ -467,7 +506,7 @@ int iwl_mvm_load_d3_fw(struct iwl_mvm *mvm)
   goto error;
  }
 
- ret = iwl_send_tx_ant_cfg(mvm, iwl_fw_valid_tx_ant(mvm->fw));
+ ret = iwl_send_tx_ant_cfg(mvm, mvm->fw->valid_tx_ant);
  if (ret)
   goto error;
 
diff --git a/drivers/net/wireless/iwlwifi/mvm/led.c b/drivers/net/wireless/iwlwifi/mvm/led.c
index 2269a9e..e3b3cf4 100644
--- a/drivers/net/wireless/iwlwifi/mvm/led.c
+++ b/drivers/net/wireless/iwlwifi/mvm/led.c
@@ -5,7 +5,7 @@
  *
  * GPL LICENSE SUMMARY
  *
- * Copyright(c) 2012 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2012 - 2014 Intel Corporation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of version 2 of the GNU General Public License as
@@ -30,7 +30,7 @@
  *
  * BSD LICENSE
  *
- * Copyright(c) 2012 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2012 - 2014 Intel Corporation. All rights reserved.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -94,6 +94,8 @@ int iwl_mvm_leds_init(struct iwl_mvm *mvm)
  int ret;
 
  switch (mode) {
+ case IWL_LED_BLINK:
+  IWL_ERR(mvm, "Blink led mode not supported, used default\n");
  case IWL_LED_DEFAULT:
  case IWL_LED_RF_STATE:
   mode = IWL_LED_RF_STATE;
@@ -103,7 +105,7 @@ int iwl_mvm_leds_init(struct iwl_mvm *mvm)
   return 0;
  default:
   return -EINVAL;
- };
+ }
 
  mvm->led.name = kasprintf(GFP_KERNEL, "%s-led",
        wiphy_name(mvm->hw->wiphy));
diff --git a/drivers/net/wireless/iwlwifi/mvm/mac-ctxt.c b/drivers/net/wireless/iwlwifi/mvm/mac-ctxt.c
index d8e858c..8b79081 100644
--- a/drivers/net/wireless/iwlwifi/mvm/mac-ctxt.c
+++ b/drivers/net/wireless/iwlwifi/mvm/mac-ctxt.c
@@ -5,7 +5,7 @@
  *
  * GPL LICENSE SUMMARY
  *
- * Copyright(c) 2012 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2012 - 2014 Intel Corporation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of version 2 of the GNU General Public License as
@@ -30,7 +30,7 @@
  *
  * BSD LICENSE
  *
- * Copyright(c) 2012 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2012 - 2014 Intel Corporation. All rights reserved.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -69,10 +69,10 @@
 #include "mvm.h"
 
 const u8 iwl_mvm_ac_to_tx_fifo[] = {
- IWL_MVM_TX_FIFO_BK,
- IWL_MVM_TX_FIFO_BE,
- IWL_MVM_TX_FIFO_VI,
  IWL_MVM_TX_FIFO_VO,
+ IWL_MVM_TX_FIFO_VI,
+ IWL_MVM_TX_FIFO_BE,
+ IWL_MVM_TX_FIFO_BK,
 };
 
 struct iwl_mvm_mac_iface_iterator_data {
@@ -80,40 +80,21 @@ struct iwl_mvm_mac_iface_iterator_data {
  struct ieee80211_vif *vif;
  unsigned long available_mac_ids[BITS_TO_LONGS(NUM_MAC_INDEX_DRIVER)];
  unsigned long available_tsf_ids[BITS_TO_LONGS(NUM_TSF_IDS)];
- unsigned long used_hw_queues[BITS_TO_LONGS(IWL_MVM_FIRST_AGG_QUEUE)];
+ unsigned long used_hw_queues[BITS_TO_LONGS(IWL_MVM_MAX_QUEUES)];
  enum iwl_tsf_id preferred_tsf;
  bool found_vif;
 };
 
-static void iwl_mvm_mac_iface_iterator(void *_data, u8 *mac,
-           struct ieee80211_vif *vif)
+static void iwl_mvm_mac_tsf_id_iter(void *_data, u8 *mac,
+        struct ieee80211_vif *vif)
 {
  struct iwl_mvm_mac_iface_iterator_data *data = _data;
  struct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);
- u32 ac;
+ u16 min_bi;
 
- /* Iterator may already find the interface being added -- skip it */
- if (vif == data->vif) {
-  data->found_vif = true;
+ /* Skip the interface for which we are trying to assign a tsf_id  */
+ if (vif == data->vif)
   return;
- }
-
- /* Mark the queues used by the vif */
- for (ac = 0; ac < IEEE80211_NUM_ACS; ac++)
-  if (vif->hw_queue[ac] != IEEE80211_INVAL_HW_QUEUE)
-   __set_bit(vif->hw_queue[ac], data->used_hw_queues);
-
- if (vif->cab_queue != IEEE80211_INVAL_HW_QUEUE)
-  __set_bit(vif->cab_queue, data->used_hw_queues);
-
- /*
-  * Mark MAC IDs as used by clearing the available bit, and
-  * (below) mark TSFs as used if their existing use is not
-  * compatible with the new interface type.
-  * No locking or atomic bit operations are needed since the
-  * data is on the stack of the caller function.
-  */
- __clear_bit(mvmvif->id, data->available_mac_ids);
 
  /*
   * The TSF is a hardware/firmware resource, there are 4 and
@@ -134,33 +115,56 @@ static void iwl_mvm_mac_iface_iterator(void *_data, u8 *mac,
  switch (data->vif->type) {
  case NL80211_IFTYPE_STATION:
   /*
-   * The new interface is client, so if the existing one
-   * we're iterating is an AP, the TSF should be used to
-   * avoid drift between the new client and existing AP,
-   * the existing AP will get drift updates from the new
-   * client context in this case
+   * The new interface is a client, so if the one we're iterating
+   * is an AP, and the beacon interval of the AP is a multiple or
+   * divisor of the beacon interval of the client, the same TSF
+   * should be used to avoid drift between the new client and
+   * existing AP. The existing AP will get drift updates from the
+   * new client context in this case.
    */
-  if (vif->type == NL80211_IFTYPE_AP) {
-   if (data->preferred_tsf == NUM_TSF_IDS &&
-       test_bit(mvmvif->tsf_id, data->available_tsf_ids))
-    data->preferred_tsf = mvmvif->tsf_id;
+  if (vif->type != NL80211_IFTYPE_AP ||
+      data->preferred_tsf != NUM_TSF_IDS ||
+      !test_bit(mvmvif->tsf_id, data->available_tsf_ids))
+   break;
+
+  min_bi = min(data->vif->bss_conf.beacon_int,
+        vif->bss_conf.beacon_int);
+
+  if (!min_bi)
+   break;
+
+  if ((data->vif->bss_conf.beacon_int -
+       vif->bss_conf.beacon_int) % min_bi == 0) {
+   data->preferred_tsf = mvmvif->tsf_id;
    return;
   }
   break;
+
  case NL80211_IFTYPE_AP:
   /*
-   * The new interface is AP/GO, so should get drift
-   * updates from an existing client or use the same
-   * TSF as an existing GO. There's no drift between
-   * TSFs internally but if they used different TSFs
-   * then a new client MAC could update one of them
-   * and cause drift that way.
+   * The new interface is AP/GO, so if its beacon interval is a
+   * multiple or a divisor of the beacon interval of an existing
+   * interface, it should get drift updates from an existing
+   * client or use the same TSF as an existing GO. There's no
+   * drift between TSFs internally but if they used different
+   * TSFs then a new client MAC could update one of them and
+   * cause drift that way.
    */
-  if (vif->type == NL80211_IFTYPE_STATION ||
-      vif->type == NL80211_IFTYPE_AP) {
-   if (data->preferred_tsf == NUM_TSF_IDS &&
-       test_bit(mvmvif->tsf_id, data->available_tsf_ids))
-    data->preferred_tsf = mvmvif->tsf_id;
+  if ((vif->type != NL80211_IFTYPE_AP &&
+       vif->type != NL80211_IFTYPE_STATION) ||
+      data->preferred_tsf != NUM_TSF_IDS ||
+      !test_bit(mvmvif->tsf_id, data->available_tsf_ids))
+   break;
+
+  min_bi = min(data->vif->bss_conf.beacon_int,
+        vif->bss_conf.beacon_int);
+
+  if (!min_bi)
+   break;
+
+  if ((data->vif->bss_conf.beacon_int -
+       vif->bss_conf.beacon_int) % min_bi == 0) {
+   data->preferred_tsf = mvmvif->tsf_id;
    return;
   }
   break;
@@ -187,6 +191,39 @@ static void iwl_mvm_mac_iface_iterator(void *_data, u8 *mac,
   data->preferred_tsf = NUM_TSF_IDS;
 }
 
+static void iwl_mvm_mac_iface_iterator(void *_data, u8 *mac,
+           struct ieee80211_vif *vif)
+{
+ struct iwl_mvm_mac_iface_iterator_data *data = _data;
+ struct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);
+ u32 ac;
+
+ /* Iterator may already find the interface being added -- skip it */
+ if (vif == data->vif) {
+  data->found_vif = true;
+  return;
+ }
+
+ /* Mark the queues used by the vif */
+ for (ac = 0; ac < IEEE80211_NUM_ACS; ac++)
+  if (vif->hw_queue[ac] != IEEE80211_INVAL_HW_QUEUE)
+   __set_bit(vif->hw_queue[ac], data->used_hw_queues);
+
+ if (vif->cab_queue != IEEE80211_INVAL_HW_QUEUE)
+  __set_bit(vif->cab_queue, data->used_hw_queues);
+
+ /* Mark MAC IDs as used by clearing the available bit, and
+  * (below) mark TSFs as used if their existing use is not
+  * compatible with the new interface type.
+  * No locking or atomic bit operations are needed since the
+  * data is on the stack of the caller function.
+  */
+ __clear_bit(mvmvif->id, data->available_mac_ids);
+
+ /* find a suitable tsf_id */
+ iwl_mvm_mac_tsf_id_iter(_data, mac, vif);
+}
+
 /*
  * Get the mask of the queus used by the vif
  */
@@ -205,6 +242,29 @@ u32 iwl_mvm_mac_get_queues_mask(struct iwl_mvm *mvm,
  return qmask;
 }
 
+void iwl_mvm_mac_ctxt_recalc_tsf_id(struct iwl_mvm *mvm,
+        struct ieee80211_vif *vif)
+{
+ struct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);
+ struct iwl_mvm_mac_iface_iterator_data data = {
+  .mvm = mvm,
+  .vif = vif,
+  .available_tsf_ids = { (1 << NUM_TSF_IDS) - 1 },
+  /* no preference yet */
+  .preferred_tsf = NUM_TSF_IDS,
+ };
+
+ ieee80211_iterate_active_interfaces_atomic(
+  mvm->hw, IEEE80211_IFACE_ITER_RESUME_ALL,
+  iwl_mvm_mac_tsf_id_iter, &data);
+
+ if (data.preferred_tsf != NUM_TSF_IDS)
+  mvmvif->tsf_id = data.preferred_tsf;
+ else if (!test_bit(mvmvif->tsf_id, data.available_tsf_ids))
+  mvmvif->tsf_id = find_first_bit(data.available_tsf_ids,
+      NUM_TSF_IDS);
+}
+
 static int iwl_mvm_mac_ctxt_allocate_resources(struct iwl_mvm *mvm,
             struct ieee80211_vif *vif)
 {
@@ -218,13 +278,13 @@ static int iwl_mvm_mac_ctxt_allocate_resources(struct iwl_mvm *mvm,
   .preferred_tsf = NUM_TSF_IDS,
   .used_hw_queues = {
    BIT(IWL_MVM_OFFCHANNEL_QUEUE) |
-   BIT(IWL_MVM_AUX_QUEUE) |
+   BIT(mvm->aux_queue) |
    BIT(IWL_MVM_CMD_QUEUE)
   },
   .found_vif = false,
  };
  u32 ac;
- int ret;
+ int ret, i;
 
  /*
   * Allocate a MAC ID and a TSF for this MAC, along with the queues
@@ -242,9 +302,17 @@ static int iwl_mvm_mac_ctxt_allocate_resources(struct iwl_mvm *mvm,
   * that we should share it with another interface.
   */
 
- /* Currently, MAC ID 0 should be used only for the managed vif */
- if (vif->type != NL80211_IFTYPE_STATION || vif->p2p)
+ /* Currently, MAC ID 0 should be used only for the managed/IBSS vif */
+ switch (vif->type) {
+ case NL80211_IFTYPE_ADHOC:
+  break;
+ case NL80211_IFTYPE_STATION:
+  if (!vif->p2p)
+   break;
+  /* fall through */
+ default:
   __clear_bit(0, data.available_mac_ids);
+ }
 
  ieee80211_iterate_active_interfaces_atomic(
   mvm->hw, IEEE80211_IFACE_ITER_RESUME_ALL,
@@ -264,7 +332,8 @@ static int iwl_mvm_mac_ctxt_allocate_resources(struct iwl_mvm *mvm,
   return 0;
 
  /* Therefore, in recovery, we can't get here */
- WARN_ON_ONCE(test_bit(IWL_MVM_STATUS_IN_HW_RESTART, &mvm->status));
+ if (WARN_ON_ONCE(test_bit(IWL_MVM_STATUS_IN_HW_RESTART, &mvm->status)))
+  return -EBUSY;
 
  mvmvif->id = find_first_bit(data.available_mac_ids,
         NUM_MAC_INDEX_DRIVER);
@@ -301,9 +370,9 @@ static int iwl_mvm_mac_ctxt_allocate_resources(struct iwl_mvm *mvm,
  /* Find available queues, and allocate them to the ACs */
  for (ac = 0; ac < IEEE80211_NUM_ACS; ac++) {
   u8 queue = find_first_zero_bit(data.used_hw_queues,
-            IWL_MVM_FIRST_AGG_QUEUE);
+            mvm->first_agg_queue);
 
-  if (queue >= IWL_MVM_FIRST_AGG_QUEUE) {
+  if (queue >= mvm->first_agg_queue) {
    IWL_ERR(mvm, "Failed to allocate queue\n");
    ret = -EIO;
    goto exit_fail;
@@ -316,9 +385,9 @@ static int iwl_mvm_mac_ctxt_allocate_resources(struct iwl_mvm *mvm,
  /* Allocate the CAB queue for softAP and GO interfaces */
  if (vif->type == NL80211_IFTYPE_AP) {
   u8 queue = find_first_zero_bit(data.used_hw_queues,
-            IWL_MVM_FIRST_AGG_QUEUE);
+            mvm->first_agg_queue);
 
-  if (queue >= IWL_MVM_FIRST_AGG_QUEUE) {
+  if (queue >= mvm->first_agg_queue) {
    IWL_ERR(mvm, "Failed to allocate cab queue\n");
    ret = -EIO;
    goto exit_fail;
@@ -332,6 +401,9 @@ static int iwl_mvm_mac_ctxt_allocate_resources(struct iwl_mvm *mvm,
  mvmvif->bcast_sta.sta_id = IWL_MVM_STATION_COUNT;
  mvmvif->ap_sta_id = IWL_MVM_STATION_COUNT;
 
+ for (i = 0; i < NUM_IWL_MVM_SMPS_REQ; i++)
+  mvmvif->smps_requests[i] = IEEE80211_SMPS_AUTOMATIC;
+
  return 0;
 
 exit_fail:
@@ -476,6 +548,40 @@ static void iwl_mvm_ack_rates(struct iwl_mvm *mvm,
  *ofdm_rates = ofdm;
 }
 
+static void iwl_mvm_mac_ctxt_set_ht_flags(struct iwl_mvm *mvm,
+      struct ieee80211_vif *vif,
+      struct iwl_mac_ctx_cmd *cmd)
+{
+ /* for both sta and ap, ht_operation_mode hold the protection_mode */
+ u8 protection_mode = vif->bss_conf.ht_operation_mode &
+     IEEE80211_HT_OP_MODE_PROTECTION;
+ /* The fw does not distinguish between ht and fat */
+ u32 ht_flag = MAC_PROT_FLG_HT_PROT | MAC_PROT_FLG_FAT_PROT;
+
+ IWL_DEBUG_RATE(mvm, "protection mode set to %d\n", protection_mode);
+ /*
+  * See section 9.23.3.1 of IEEE 80211-2012.
+  * Nongreenfield HT STAs Present is not supported.
+  */
+ switch (protection_mode) {
+ case IEEE80211_HT_OP_MODE_PROTECTION_NONE:
+  break;
+ case IEEE80211_HT_OP_MODE_PROTECTION_NONMEMBER:
+ case IEEE80211_HT_OP_MODE_PROTECTION_NONHT_MIXED:
+  cmd->protection_flags |= cpu_to_le32(ht_flag);
+  break;
+ case IEEE80211_HT_OP_MODE_PROTECTION_20MHZ:
+  /* Protect when channel wider than 20MHz */
+  if (vif->bss_conf.chandef.width > NL80211_CHAN_WIDTH_20)
+   cmd->protection_flags |= cpu_to_le32(ht_flag);
+  break;
+ default:
+  IWL_ERR(mvm, "Illegal protection mode %d\n",
+   protection_mode);
+  break;
+ }
+}
+
 static void iwl_mvm_mac_ctxt_cmd_common(struct iwl_mvm *mvm,
      struct ieee80211_vif *vif,
      struct iwl_mac_ctx_cmd *cmd,
@@ -483,6 +589,8 @@ static void iwl_mvm_mac_ctxt_cmd_common(struct iwl_mvm *mvm,
 {
  struct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);
  struct ieee80211_chanctx_conf *chanctx;
+ bool ht_enabled = !!(vif->bss_conf.ht_operation_mode &
+        IEEE80211_HT_OP_MODE_PROTECTION);
  u8 cck_ack_rates, ofdm_ack_rates;
  int i;
 
@@ -538,35 +646,37 @@ static void iwl_mvm_mac_ctxt_cmd_common(struct iwl_mvm *mvm,
   cpu_to_le32(vif->bss_conf.use_short_slot ?
        MAC_FLG_SHORT_SLOT : 0);
 
- for (i = 0; i < AC_NUM; i++) {
-  cmd->ac[i].cw_min = cpu_to_le16(mvmvif->queue_params[i].cw_min);
-  cmd->ac[i].cw_max = cpu_to_le16(mvmvif->queue_params[i].cw_max);
-  cmd->ac[i].aifsn = mvmvif->queue_params[i].aifs;
-  cmd->ac[i].edca_txop =
+ for (i = 0; i < IEEE80211_NUM_ACS; i++) {
+  u8 txf = iwl_mvm_ac_to_tx_fifo[i];
+
+  cmd->ac[txf].cw_min =
+   cpu_to_le16(mvmvif->queue_params[i].cw_min);
+  cmd->ac[txf].cw_max =
+   cpu_to_le16(mvmvif->queue_params[i].cw_max);
+  cmd->ac[txf].edca_txop =
    cpu_to_le16(mvmvif->queue_params[i].txop * 32);
-  cmd->ac[i].fifos_mask = BIT(iwl_mvm_ac_to_tx_fifo[i]);
+  cmd->ac[txf].aifsn = mvmvif->queue_params[i].aifs;
+  cmd->ac[txf].fifos_mask = BIT(txf);
  }
 
  /* in AP mode, the MCAST FIFO takes the EDCA params from VO */
  if (vif->type == NL80211_IFTYPE_AP)
-  cmd->ac[AC_VO].fifos_mask |= BIT(IWL_MVM_TX_FIFO_MCAST);
+  cmd->ac[IWL_MVM_TX_FIFO_VO].fifos_mask |=
+   BIT(IWL_MVM_TX_FIFO_MCAST);
 
  if (vif->bss_conf.qos)
   cmd->qos_flags |= cpu_to_le32(MAC_QOS_FLG_UPDATE_EDCA);
 
- /* Don't use cts to self as the fw doesn't support it currently. */
  if (vif->bss_conf.use_cts_prot)
   cmd->protection_flags |= cpu_to_le32(MAC_PROT_FLG_TGG_PROTECT);
 
- /*
-  * I think that we should enable these 2 flags regardless the HT PROT
-  * fields in the HT IE, but I am not sure. Someone knows whom to ask?...
-  */
- if (vif->bss_conf.chandef.width != NL80211_CHAN_WIDTH_20_NOHT) {
+ IWL_DEBUG_RATE(mvm, "use_cts_prot %d, ht_operation_mode %d\n",
+         vif->bss_conf.use_cts_prot,
+         vif->bss_conf.ht_operation_mode);
+ if (vif->bss_conf.chandef.width != NL80211_CHAN_WIDTH_20_NOHT)
   cmd->qos_flags |= cpu_to_le32(MAC_QOS_FLG_TGN);
-  cmd->protection_flags |= cpu_to_le32(MAC_PROT_FLG_HT_PROT |
-           MAC_PROT_FLG_FAT_PROT);
- }
+ if (ht_enabled)
+  iwl_mvm_mac_ctxt_set_ht_flags(mvm, vif, cmd);
 
  cmd->filter_flags = cpu_to_le32(MAC_FILTER_ACCEPT_GRP);
 }
@@ -574,7 +684,7 @@ static void iwl_mvm_mac_ctxt_cmd_common(struct iwl_mvm *mvm,
 static int iwl_mvm_mac_ctxt_send_cmd(struct iwl_mvm *mvm,
          struct iwl_mac_ctx_cmd *cmd)
 {
- int ret = iwl_mvm_send_cmd_pdu(mvm, MAC_CONTEXT_CMD, CMD_SYNC,
+ int ret = iwl_mvm_send_cmd_pdu(mvm, MAC_CONTEXT_CMD, 0,
            sizeof(*cmd), cmd);
  if (ret)
   IWL_ERR(mvm, "Failed to send MAC context (action:%d): %d\n",
@@ -582,19 +692,39 @@ static int iwl_mvm_mac_ctxt_send_cmd(struct iwl_mvm *mvm,
  return ret;
 }
 
-/*
- * Fill the specific data for mac context of type station or p2p client
- */
-static void iwl_mvm_mac_ctxt_cmd_fill_sta(struct iwl_mvm *mvm,
-       struct ieee80211_vif *vif,
-       struct iwl_mac_data_sta *ctxt_sta,
-       bool force_assoc_off)
+static int iwl_mvm_mac_ctxt_cmd_sta(struct iwl_mvm *mvm,
+        struct ieee80211_vif *vif,
+        u32 action, bool force_assoc_off)
 {
+ struct iwl_mac_ctx_cmd cmd = {};
+ struct iwl_mac_data_sta *ctxt_sta;
+
+ WARN_ON(vif->type != NL80211_IFTYPE_STATION);
+
+ /* Fill the common data for all mac context types */
+ iwl_mvm_mac_ctxt_cmd_common(mvm, vif, &cmd, action);
+
+ if (vif->p2p) {
+  struct ieee80211_p2p_noa_attr *noa =
+   &vif->bss_conf.p2p_noa_attr;
+
+  cmd.p2p_sta.ctwin = cpu_to_le32(noa->oppps_ctwindow &
+     IEEE80211_P2P_OPPPS_CTWINDOW_MASK);
+  ctxt_sta = &cmd.p2p_sta.sta;
+ } else {
+  ctxt_sta = &cmd.sta;
+ }
+
  /* We need the dtim_period to set the MAC as associated */
  if (vif->bss_conf.assoc && vif->bss_conf.dtim_period &&
      !force_assoc_off) {
   u32 dtim_offs;
 
+  /* Allow beacons to pass through as long as we are not
+   * associated, or we do not have dtim period information.
+   */
+  cmd.filter_flags |= cpu_to_le32(MAC_FILTER_IN_BEACON);
+
   /*
    * The DTIM count counts down, so when it is N that means N
    * more beacon intervals happen until the DTIM TBTT. Therefore
@@ -641,70 +771,52 @@ static void iwl_mvm_mac_ctxt_cmd_fill_sta(struct iwl_mvm *mvm,
 
  ctxt_sta->listen_interval = cpu_to_le32(mvm->hw->conf.listen_interval);
  ctxt_sta->assoc_id = cpu_to_le32(vif->bss_conf.aid);
-}
-
-static int iwl_mvm_mac_ctxt_cmd_station(struct iwl_mvm *mvm,
-     struct ieee80211_vif *vif,
-     u32 action)
-{
- struct iwl_mac_ctx_cmd cmd = {};
-
- WARN_ON(vif->type != NL80211_IFTYPE_STATION || vif->p2p);
-
- /* Fill the common data for all mac context types */
- iwl_mvm_mac_ctxt_cmd_common(mvm, vif, &cmd, action);
-
- /* Allow beacons to pass through as long as we are not associated,or we
-  * do not have dtim period information */
- if (!vif->bss_conf.assoc || !vif->bss_conf.dtim_period)
-  cmd.filter_flags |= cpu_to_le32(MAC_FILTER_IN_BEACON);
- else
-  cmd.filter_flags &= ~cpu_to_le32(MAC_FILTER_IN_BEACON);
-
- /* Fill the data specific for station mode */
- iwl_mvm_mac_ctxt_cmd_fill_sta(mvm, vif, &cmd.sta,
-          action == FW_CTXT_ACTION_ADD);
 
  return iwl_mvm_mac_ctxt_send_cmd(mvm, &cmd);
 }
 
-static int iwl_mvm_mac_ctxt_cmd_p2p_client(struct iwl_mvm *mvm,
-        struct ieee80211_vif *vif,
-        u32 action)
+static int iwl_mvm_mac_ctxt_cmd_listener(struct iwl_mvm *mvm,
+      struct ieee80211_vif *vif,
+      u32 action)
 {
  struct iwl_mac_ctx_cmd cmd = {};
- struct ieee80211_p2p_noa_attr *noa = &vif->bss_conf.p2p_noa_attr;
 
- WARN_ON(vif->type != NL80211_IFTYPE_STATION || !vif->p2p);
+ WARN_ON(vif->type != NL80211_IFTYPE_MONITOR);
 
- /* Fill the common data for all mac context types */
  iwl_mvm_mac_ctxt_cmd_common(mvm, vif, &cmd, action);
 
- /* Fill the data specific for station mode */
- iwl_mvm_mac_ctxt_cmd_fill_sta(mvm, vif, &cmd.p2p_sta.sta,
-          action == FW_CTXT_ACTION_ADD);
-
- cmd.p2p_sta.ctwin = cpu_to_le32(noa->oppps_ctwindow &
-     IEEE80211_P2P_OPPPS_CTWINDOW_MASK);
+ cmd.filter_flags = cpu_to_le32(MAC_FILTER_IN_PROMISC |
+           MAC_FILTER_IN_CONTROL_AND_MGMT |
+           MAC_FILTER_IN_BEACON |
+           MAC_FILTER_IN_PROBE_REQUEST |
+           MAC_FILTER_IN_CRC32);
+ mvm->hw->flags |= IEEE80211_HW_RX_INCLUDES_FCS;
 
  return iwl_mvm_mac_ctxt_send_cmd(mvm, &cmd);
 }
 
-static int iwl_mvm_mac_ctxt_cmd_listener(struct iwl_mvm *mvm,
-      struct ieee80211_vif *vif,
-      u32 action)
+static int iwl_mvm_mac_ctxt_cmd_ibss(struct iwl_mvm *mvm,
+         struct ieee80211_vif *vif,
+         u32 action)
 {
+ struct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);
  struct iwl_mac_ctx_cmd cmd = {};
 
- WARN_ON(vif->type != NL80211_IFTYPE_MONITOR);
+ WARN_ON(vif->type != NL80211_IFTYPE_ADHOC);
 
  iwl_mvm_mac_ctxt_cmd_common(mvm, vif, &cmd, action);
 
- cmd.filter_flags = cpu_to_le32(MAC_FILTER_IN_PROMISC |
-           MAC_FILTER_IN_CONTROL_AND_MGMT |
-           MAC_FILTER_IN_BEACON |
+ cmd.filter_flags = cpu_to_le32(MAC_FILTER_IN_BEACON |
            MAC_FILTER_IN_PROBE_REQUEST);
 
+ /* cmd.ibss.beacon_time/cmd.ibss.beacon_tsf are curently ignored */
+ cmd.ibss.bi = cpu_to_le32(vif->bss_conf.beacon_int);
+ cmd.ibss.bi_reciprocal =
+  cpu_to_le32(iwl_mvm_reciprocal(vif->bss_conf.beacon_int));
+
+ /* TODO: Assumes that the beacon id == mac context id */
+ cmd.ibss.beacon_template = cpu_to_le32(mvmvif->id);
+
  return iwl_mvm_mac_ctxt_send_cmd(mvm, &cmd);
 }
 
@@ -717,7 +829,8 @@ static void iwl_mvm_go_iterator(void *_data, u8 *mac, struct ieee80211_vif *vif)
  struct iwl_mvm_go_iterator_data *data = _data;
  struct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);
 
- if (vif->type == NL80211_IFTYPE_AP && vif->p2p && mvmvif->ap_active)
+ if (vif->type == NL80211_IFTYPE_AP && vif->p2p &&
+     mvmvif->ap_ibss_active)
   data->go_active = true;
 }
 
@@ -810,7 +923,7 @@ static int iwl_mvm_mac_ctxt_send_beacon(struct iwl_mvm *mvm,
           TX_CMD_FLG_TSF);
 
  mvm->mgmt_last_antenna_idx =
-  iwl_mvm_next_antenna(mvm, iwl_fw_valid_tx_ant(mvm->fw),
+  iwl_mvm_next_antenna(mvm, mvm->fw->valid_tx_ant,
          mvm->mgmt_last_antenna_idx);
 
  beacon_cmd.tx.rate_n_flags =
@@ -829,9 +942,10 @@ static int iwl_mvm_mac_ctxt_send_beacon(struct iwl_mvm *mvm,
   cpu_to_le32(iwl_mvm_mac80211_idx_to_hwrate(rate));
 
  /* Set up TX beacon command fields */
- iwl_mvm_mac_ctxt_set_tim(mvm, &beacon_cmd,
-     beacon->data,
-     beacon_skb_len);
+ if (vif->type == NL80211_IFTYPE_AP)
+  iwl_mvm_mac_ctxt_set_tim(mvm, &beacon_cmd,
+      beacon->data,
+      beacon_skb_len);
 
  /* Submit command */
  cmd.len[0] = sizeof(beacon_cmd);
@@ -844,14 +958,15 @@ static int iwl_mvm_mac_ctxt_send_beacon(struct iwl_mvm *mvm,
  return iwl_mvm_send_cmd(mvm, &cmd);
 }
 
-/* The beacon template for the AP/GO context has changed and needs update */
+/* The beacon template for the AP/GO/IBSS has changed and needs update */
 int iwl_mvm_mac_ctxt_beacon_changed(struct iwl_mvm *mvm,
         struct ieee80211_vif *vif)
 {
  struct sk_buff *beacon;
  int ret;
 
- WARN_ON(vif->type != NL80211_IFTYPE_AP);
+ WARN_ON(vif->type != NL80211_IFTYPE_AP &&
+  vif->type != NL80211_IFTYPE_ADHOC);
 
  beacon = ieee80211_beacon_get(mvm->hw, vif);
  if (!beacon)
@@ -862,6 +977,30 @@ int iwl_mvm_mac_ctxt_beacon_changed(struct iwl_mvm *mvm,
  return ret;
 }
 
+struct iwl_mvm_mac_ap_iterator_data {
+ struct iwl_mvm *mvm;
+ struct ieee80211_vif *vif;
+ u32 beacon_device_ts;
+ u16 beacon_int;
+};
+
+/* Find the beacon_device_ts and beacon_int for a managed interface */
+static void iwl_mvm_mac_ap_iterator(void *_data, u8 *mac,
+        struct ieee80211_vif *vif)
+{
+ struct iwl_mvm_mac_ap_iterator_data *data = _data;
+
+ if (vif->type != NL80211_IFTYPE_STATION || !vif->bss_conf.assoc)
+  return;
+
+ /* Station client has higher priority over P2P client*/
+ if (vif->p2p && data->beacon_device_ts)
+  return;
+
+ data->beacon_device_ts = vif->bss_conf.sync_device_ts;
+ data->beacon_int = vif->bss_conf.beacon_int;
+}
+
 /*
  * Fill the specific data for mac context of type AP of P2P GO
  */
@@ -871,6 +1010,11 @@ static void iwl_mvm_mac_ctxt_cmd_fill_ap(struct iwl_mvm *mvm,
       bool add)
 {
  struct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);
+ struct iwl_mvm_mac_ap_iterator_data data = {
+  .mvm = mvm,
+  .vif = vif,
+  .beacon_device_ts = 0
+ };
 
  ctxt_ap->bi = cpu_to_le32(vif->bss_conf.beacon_int);
  ctxt_ap->bi_reciprocal =
@@ -884,16 +1028,33 @@ static void iwl_mvm_mac_ctxt_cmd_fill_ap(struct iwl_mvm *mvm,
  ctxt_ap->mcast_qid = cpu_to_le32(vif->cab_queue);
 
  /*
-  * Only read the system time when the MAC is being added, when we
+  * Only set the beacon time when the MAC is being added, when we
   * just modify the MAC then we should keep the time -- the firmware
   * can otherwise have a "jumping" TBTT.
   */
- if (add)
-  mvmvif->ap_beacon_time =
-   iwl_read_prph(mvm->trans, DEVICE_SYSTEM_TIME_REG);
+ if (add) {
+  /*
+   * If there is a station/P2P client interface which is
+   * associated, set the AP's TBTT far enough from the station's
+   * TBTT. Otherwise, set it to the current system time
+   */
+  ieee80211_iterate_active_interfaces_atomic(
+   mvm->hw, IEEE80211_IFACE_ITER_RESUME_ALL,
+   iwl_mvm_mac_ap_iterator, &data);
+
+  if (data.beacon_device_ts) {
+   u32 rand = (prandom_u32() % (64 - 36)) + 36;
+   mvmvif->ap_beacon_time = data.beacon_device_ts +
+    ieee80211_tu_to_usec(data.beacon_int * rand /
+           100);
+  } else {
+   mvmvif->ap_beacon_time =
+    iwl_read_prph(mvm->trans,
+           DEVICE_SYSTEM_TIME_REG);
+  }
+ }
 
  ctxt_ap->beacon_time = cpu_to_le32(mvmvif->ap_beacon_time);
-
  ctxt_ap->beacon_tsf = 0; /* unused */
 
  /* TODO: Assume that the beacon id == mac context id */
@@ -911,8 +1072,12 @@ static int iwl_mvm_mac_ctxt_cmd_ap(struct iwl_mvm *mvm,
  /* Fill the common data for all mac context types */
  iwl_mvm_mac_ctxt_cmd_common(mvm, vif, &cmd, action);
 
- /* Also enable probe requests to pass */
- cmd.filter_flags |= cpu_to_le32(MAC_FILTER_IN_PROBE_REQUEST);
+ /*
+  * pass probe requests and beacons from other APs (needed
+  * for ht protection)
+  */
+ cmd.filter_flags |= cpu_to_le32(MAC_FILTER_IN_PROBE_REQUEST |
+     MAC_FILTER_IN_BEACON);
 
  /* Fill the data specific for ap mode */
  iwl_mvm_mac_ctxt_cmd_fill_ap(mvm, vif, &cmd.ap,
@@ -933,6 +1098,13 @@ static int iwl_mvm_mac_ctxt_cmd_go(struct iwl_mvm *mvm,
  /* Fill the common data for all mac context types */
  iwl_mvm_mac_ctxt_cmd_common(mvm, vif, &cmd, action);
 
+ /*
+  * pass probe requests and beacons from other APs (needed
+  * for ht protection)
+  */
+ cmd.filter_flags |= cpu_to_le32(MAC_FILTER_IN_PROBE_REQUEST |
+     MAC_FILTER_IN_BEACON);
+
  /* Fill the data specific for GO mode */
  iwl_mvm_mac_ctxt_cmd_fill_ap(mvm, vif, &cmd.go.ap,
          action == FW_CTXT_ACTION_ADD);
@@ -947,16 +1119,12 @@ static int iwl_mvm_mac_ctxt_cmd_go(struct iwl_mvm *mvm,
 }
 
 static int iwl_mvm_mac_ctx_send(struct iwl_mvm *mvm, struct ieee80211_vif *vif,
-    u32 action)
+    u32 action, bool force_assoc_off)
 {
  switch (vif->type) {
  case NL80211_IFTYPE_STATION:
-  if (!vif->p2p)
-   return iwl_mvm_mac_ctxt_cmd_station(mvm, vif,
-           action);
-  else
-   return iwl_mvm_mac_ctxt_cmd_p2p_client(mvm, vif,
-              action);
+  return iwl_mvm_mac_ctxt_cmd_sta(mvm, vif, action,
+      force_assoc_off);
   break;
  case NL80211_IFTYPE_AP:
   if (!vif->p2p)
@@ -968,6 +1136,8 @@ static int iwl_mvm_mac_ctx_send(struct iwl_mvm *mvm, struct ieee80211_vif *vif,
   return iwl_mvm_mac_ctxt_cmd_listener(mvm, vif, action);
  case NL80211_IFTYPE_P2P_DEVICE:
   return iwl_mvm_mac_ctxt_cmd_p2p_device(mvm, vif, action);
+ case NL80211_IFTYPE_ADHOC:
+  return iwl_mvm_mac_ctxt_cmd_ibss(mvm, vif, action);
  default:
   break;
  }
@@ -984,15 +1154,20 @@ int iwl_mvm_mac_ctxt_add(struct iwl_mvm *mvm, struct ieee80211_vif *vif)
         vif->addr, ieee80211_vif_type_p2p(vif)))
   return -EIO;
 
- ret = iwl_mvm_mac_ctx_send(mvm, vif, FW_CTXT_ACTION_ADD);
+ ret = iwl_mvm_mac_ctx_send(mvm, vif, FW_CTXT_ACTION_ADD,
+       true);
  if (ret)
   return ret;
 
+ /* will only do anything at resume from D3 time */
+ iwl_mvm_set_last_nonqos_seq(mvm, vif);
+
  mvmvif->uploaded = true;
  return 0;
 }
 
-int iwl_mvm_mac_ctxt_changed(struct iwl_mvm *mvm, struct ieee80211_vif *vif)
+int iwl_mvm_mac_ctxt_changed(struct iwl_mvm *mvm, struct ieee80211_vif *vif,
+        bool force_assoc_off)
 {
  struct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);
 
@@ -1000,7 +1175,8 @@ int iwl_mvm_mac_ctxt_changed(struct iwl_mvm *mvm, struct ieee80211_vif *vif)
         vif->addr, ieee80211_vif_type_p2p(vif)))
   return -EIO;
 
- return iwl_mvm_mac_ctx_send(mvm, vif, FW_CTXT_ACTION_MODIFY);
+ return iwl_mvm_mac_ctx_send(mvm, vif, FW_CTXT_ACTION_MODIFY,
+        force_assoc_off);
 }
 
 int iwl_mvm_mac_ctxt_remove(struct iwl_mvm *mvm, struct ieee80211_vif *vif)
@@ -1019,7 +1195,7 @@ int iwl_mvm_mac_ctxt_remove(struct iwl_mvm *mvm, struct ieee80211_vif *vif)
           mvmvif->color));
  cmd.action = cpu_to_le32(FW_CTXT_ACTION_REMOVE);
 
- ret = iwl_mvm_send_cmd_pdu(mvm, MAC_CONTEXT_CMD, CMD_SYNC,
+ ret = iwl_mvm_send_cmd_pdu(mvm, MAC_CONTEXT_CMD, 0,
        sizeof(cmd), &cmd);
  if (ret) {
   IWL_ERR(mvm, "Failed to remove MAC context: %d\n", ret);
@@ -1027,6 +1203,10 @@ int iwl_mvm_mac_ctxt_remove(struct iwl_mvm *mvm, struct ieee80211_vif *vif)
  }
 
  mvmvif->uploaded = false;
+
+ if (vif->type == NL80211_IFTYPE_MONITOR)
+  mvm->hw->flags &= ~IEEE80211_HW_RX_INCLUDES_FCS;
+
  return 0;
 }
 
@@ -1041,10 +1221,62 @@ int iwl_mvm_rx_beacon_notif(struct iwl_mvm *mvm,
  u32 rate __maybe_unused =
   le32_to_cpu(beacon->beacon_notify_hdr.initial_rate);
 
+ lockdep_assert_held(&mvm->mutex);
+
  IWL_DEBUG_RX(mvm, "beacon status %#x retries:%d tsf:0x%16llX rate:%d\n",
        status & TX_STATUS_MSK,
        beacon->beacon_notify_hdr.failure_frame,
        le64_to_cpu(beacon->tsf),
        rate);
+
+ if (unlikely(mvm->csa_vif && mvm->csa_vif->csa_active)) {
+  if (!ieee80211_csa_is_complete(mvm->csa_vif)) {
+   iwl_mvm_mac_ctxt_beacon_changed(mvm, mvm->csa_vif);
+  } else {
+   ieee80211_csa_finish(mvm->csa_vif);
+   mvm->csa_vif = NULL;
+  }
+ }
+
+ return 0;
+}
+
+static void iwl_mvm_beacon_loss_iterator(void *_data, u8 *mac,
+      struct ieee80211_vif *vif)
+{
+ struct iwl_missed_beacons_notif *missed_beacons = _data;
+ struct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);
+
+ if (mvmvif->id != (u16)le32_to_cpu(missed_beacons->mac_id))
+  return;
+
+ /*
+  * TODO: the threshold should be adjusted based on latency conditions,
+  * and/or in case of a CS flow on one of the other AP vifs.
+  */
+ if (le32_to_cpu(missed_beacons->consec_missed_beacons_since_last_rx) >
+      IWL_MVM_MISSED_BEACONS_THRESHOLD)
+  ieee80211_beacon_loss(vif);
+}
+
+int iwl_mvm_rx_missed_beacons_notif(struct iwl_mvm *mvm,
+        struct iwl_rx_cmd_buffer *rxb,
+        struct iwl_device_cmd *cmd)
+{
+ struct iwl_rx_packet *pkt = rxb_addr(rxb);
+ struct iwl_missed_beacons_notif *mb = (void *)pkt->data;
+
+ IWL_DEBUG_INFO(mvm,
+         "missed bcn mac_id=%u, consecutive=%u (%u, %u, %u)\n",
+         le32_to_cpu(mb->mac_id),
+         le32_to_cpu(mb->consec_missed_beacons),
+         le32_to_cpu(mb->consec_missed_beacons_since_last_rx),
+         le32_to_cpu(mb->num_recvd_beacons),
+         le32_to_cpu(mb->num_expected_beacons));
+
+ ieee80211_iterate_active_interfaces_atomic(mvm->hw,
+         IEEE80211_IFACE_ITER_NORMAL,
+         iwl_mvm_beacon_loss_iterator,
+         mb);
  return 0;
 }
diff --git a/drivers/net/wireless/iwlwifi/mvm/mac80211.c b/drivers/net/wireless/iwlwifi/mvm/mac80211.c
index a7b2d80..98556d0 100644
--- a/drivers/net/wireless/iwlwifi/mvm/mac80211.c
+++ b/drivers/net/wireless/iwlwifi/mvm/mac80211.c
@@ -5,7 +5,7 @@
  *
  * GPL LICENSE SUMMARY
  *
- * Copyright(c) 2012 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2012 - 2014 Intel Corporation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of version 2 of the GNU General Public License as
@@ -30,7 +30,7 @@
  *
  * BSD LICENSE
  *
- * Copyright(c) 2012 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2012 - 2014 Intel Corporation. All rights reserved.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -66,7 +66,9 @@
 #include <linux/netdevice.h>
 #include <linux/etherdevice.h>
 #include <linux/ip.h>
+#include <linux/if_arp.h>
 #include <net/mac80211.h>
+#include <net/ieee80211_radiotap.h>
 #include <net/tcp.h>
 
 #include "iwl-op-mode.h"
@@ -77,6 +79,33 @@
 #include "iwl-eeprom-parse.h"
 #include "fw-api-scan.h"
 #include "iwl-phy-db.h"
+#include "testmode.h"
+
+static const struct ieee80211_iface_limit iwl_mvm_limits[] = {
+ {
+  .max = 1,
+  .types = BIT(NL80211_IFTYPE_STATION),
+ },
+ {
+  .max = 1,
+  .types = BIT(NL80211_IFTYPE_AP) |
+   BIT(NL80211_IFTYPE_P2P_CLIENT) |
+   BIT(NL80211_IFTYPE_P2P_GO),
+ },
+ {
+  .max = 1,
+  .types = BIT(NL80211_IFTYPE_P2P_DEVICE),
+ },
+};
+
+static const struct ieee80211_iface_combination iwl_mvm_iface_combinations[] = {
+ {
+  .num_different_channels = 1,
+  .max_interfaces = 3,
+  .limits = iwl_mvm_limits,
+  .n_limits = ARRAY_SIZE(iwl_mvm_limits),
+ },
+};
 
 #ifdef CONFIG_PM_SLEEP
 static const struct nl80211_wowlan_tcp_data_token_feature
@@ -101,6 +130,136 @@ static const struct wiphy_wowlan_tcp_support iwl_mvm_wowlan_tcp_support = {
 };
 #endif
 
+#ifdef CONFIG_IWLWIFI_BCAST_FILTERING
+/*
+ * Use the reserved field to indicate magic values.
+ * these values will only be used internally by the driver,
+ * and won't make it to the fw (reserved will be 0).
+ * BC_FILTER_MAGIC_IP - configure the val of this attribute to
+ * be the vif's ip address. in case there is not a single
+ * ip address (0, or more than 1), this attribute will
+ * be skipped.
+ * BC_FILTER_MAGIC_MAC - set the val of this attribute to
+ * the LSB bytes of the vif's mac address
+ */
+enum {
+ BC_FILTER_MAGIC_NONE = 0,
+ BC_FILTER_MAGIC_IP,
+ BC_FILTER_MAGIC_MAC,
+};
+
+static const struct iwl_fw_bcast_filter iwl_mvm_default_bcast_filters[] = {
+ {
+  /* arp */
+  .discard = 0,
+  .frame_type = BCAST_FILTER_FRAME_TYPE_ALL,
+  .attrs = {
+   {
+    /* frame type - arp, hw type - ethernet */
+    .offset_type =
+     BCAST_FILTER_OFFSET_PAYLOAD_START,
+    .offset = sizeof(rfc1042_header),
+    .val = cpu_to_be32(0x08060001),
+    .mask = cpu_to_be32(0xffffffff),
+   },
+   {
+    /* arp dest ip */
+    .offset_type =
+     BCAST_FILTER_OFFSET_PAYLOAD_START,
+    .offset = sizeof(rfc1042_header) + 2 +
+       sizeof(struct arphdr) +
+       ETH_ALEN + sizeof(__be32) +
+       ETH_ALEN,
+    .mask = cpu_to_be32(0xffffffff),
+    /* mark it as special field */
+    .reserved1 = cpu_to_le16(BC_FILTER_MAGIC_IP),
+   },
+  },
+ },
+ {
+  /* dhcp offer bcast */
+  .discard = 0,
+  .frame_type = BCAST_FILTER_FRAME_TYPE_IPV4,
+  .attrs = {
+   {
+    /* udp dest port - 68 (bootp client)*/
+    .offset_type = BCAST_FILTER_OFFSET_IP_END,
+    .offset = offsetof(struct udphdr, dest),
+    .val = cpu_to_be32(0x00440000),
+    .mask = cpu_to_be32(0xffff0000),
+   },
+   {
+    /* dhcp - lsb bytes of client hw address */
+    .offset_type = BCAST_FILTER_OFFSET_IP_END,
+    .offset = 38,
+    .mask = cpu_to_be32(0xffffffff),
+    /* mark it as special field */
+    .reserved1 = cpu_to_le16(BC_FILTER_MAGIC_MAC),
+   },
+  },
+ },
+ /* last filter must be empty */
+ {},
+};
+#endif
+
+void iwl_mvm_ref(struct iwl_mvm *mvm, enum iwl_mvm_ref_type ref_type)
+{
+ if (!iwl_mvm_is_d0i3_supported(mvm))
+  return;
+
+ IWL_DEBUG_RPM(mvm, "Take mvm reference - type %d\n", ref_type);
+ WARN_ON(test_and_set_bit(ref_type, mvm->ref_bitmap));
+ iwl_trans_ref(mvm->trans);
+}
+
+void iwl_mvm_unref(struct iwl_mvm *mvm, enum iwl_mvm_ref_type ref_type)
+{
+ if (!iwl_mvm_is_d0i3_supported(mvm))
+  return;
+
+ IWL_DEBUG_RPM(mvm, "Leave mvm reference - type %d\n", ref_type);
+ WARN_ON(!test_and_clear_bit(ref_type, mvm->ref_bitmap));
+ iwl_trans_unref(mvm->trans);
+}
+
+static void
+iwl_mvm_unref_all_except(struct iwl_mvm *mvm, enum iwl_mvm_ref_type ref)
+{
+ int i;
+
+ if (!iwl_mvm_is_d0i3_supported(mvm))
+  return;
+
+ for_each_set_bit(i, mvm->ref_bitmap, IWL_MVM_REF_COUNT) {
+  if (ref == i)
+   continue;
+
+  IWL_DEBUG_RPM(mvm, "Cleanup: remove mvm ref type %d\n", i);
+  clear_bit(i, mvm->ref_bitmap);
+  iwl_trans_unref(mvm->trans);
+ }
+}
+
+static void iwl_mvm_reset_phy_ctxts(struct iwl_mvm *mvm)
+{
+ int i;
+
+ memset(mvm->phy_ctxts, 0, sizeof(mvm->phy_ctxts));
+ for (i = 0; i < NUM_PHY_CTX; i++) {
+  mvm->phy_ctxts[i].id = i;
+  mvm->phy_ctxts[i].ref = 0;
+ }
+}
+
+static int iwl_mvm_max_scan_ie_len(struct iwl_mvm *mvm)
+{
+ /* we create the 802.11 header and SSID element */
+ if (mvm->fw->ucode_capa.flags & IWL_UCODE_TLV_FLAGS_NO_BASIC_SSID)
+  return mvm->fw->ucode_capa.max_probe_length - 24 - 2;
+ return mvm->fw->ucode_capa.max_probe_length - 24 - 34;
+}
+
 int iwl_mvm_mac_setup_register(struct iwl_mvm *mvm)
 {
  struct ieee80211_hw *hw = mvm->hw;
@@ -115,10 +274,16 @@ int iwl_mvm_mac_setup_register(struct iwl_mvm *mvm)
       IEEE80211_HW_SUPPORTS_PS |
       IEEE80211_HW_SUPPORTS_DYNAMIC_PS |
       IEEE80211_HW_AMPDU_AGGREGATION |
-      IEEE80211_HW_TIMING_BEACON_ONLY;
+      IEEE80211_HW_TIMING_BEACON_ONLY |
+      IEEE80211_HW_CONNECTION_MONITOR |
+      IEEE80211_HW_SUPPORTS_DYNAMIC_SMPS |
+      IEEE80211_HW_SUPPORTS_STATIC_SMPS;
 
- hw->queues = IWL_MVM_FIRST_AGG_QUEUE;
+ hw->queues = mvm->first_agg_queue;
  hw->offchannel_tx_hw_queue = IWL_MVM_OFFCHANNEL_QUEUE;
+ hw->radiotap_mcs_details |= IEEE80211_RADIOTAP_MCS_HAVE_FEC |
+        IEEE80211_RADIOTAP_MCS_HAVE_STBC;
+ hw->radiotap_vht_details |= IEEE80211_RADIOTAP_VHT_KNOWN_STBC;
  hw->rate_control_algorithm = "iwl-mvm-rs";
 
  /*
@@ -130,15 +295,38 @@ int iwl_mvm_mac_setup_register(struct iwl_mvm *mvm)
      !iwlwifi_mod_params.sw_crypto)
   hw->flags |= IEEE80211_HW_MFP_CAPABLE;
 
+ if (mvm->fw->ucode_capa.flags & IWL_UCODE_TLV_FLAGS_UAPSD_SUPPORT &&
+     IWL_UCODE_API(mvm->fw->ucode_ver) >= 9 &&
+     !iwlwifi_mod_params.uapsd_disable) {
+  hw->flags |= IEEE80211_HW_SUPPORTS_UAPSD;
+  hw->uapsd_queues = IWL_UAPSD_AC_INFO;
+  hw->uapsd_max_sp_len = IWL_UAPSD_MAX_SP;
+ }
+
  hw->sta_data_size = sizeof(struct iwl_mvm_sta);
  hw->vif_data_size = sizeof(struct iwl_mvm_vif);
- hw->chanctx_data_size = sizeof(struct iwl_mvm_phy_ctxt);
+ hw->chanctx_data_size = sizeof(u16);
+
+ hw->wiphy->interface_modes = BIT(NL80211_IFTYPE_STATION) |
+  BIT(NL80211_IFTYPE_P2P_CLIENT) |
+  BIT(NL80211_IFTYPE_AP) |
+  BIT(NL80211_IFTYPE_P2P_GO) |
+  BIT(NL80211_IFTYPE_P2P_DEVICE) |
+  BIT(NL80211_IFTYPE_ADHOC);
+
+ hw->wiphy->flags |= WIPHY_FLAG_IBSS_RSN;
+ hw->wiphy->regulatory_flags |= REGULATORY_CUSTOM_REG |
+           REGULATORY_DISABLE_BEACON_HINTS;
 
- hw->wiphy->interface_modes = BIT(NL80211_IFTYPE_STATION);
+ if (mvm->fw->ucode_capa.flags & IWL_UCODE_TLV_FLAGS_GO_UAPSD)
+  hw->wiphy->flags |= WIPHY_FLAG_AP_UAPSD;
 
- hw->wiphy->flags |= WIPHY_FLAG_CUSTOM_REGULATORY |
-       WIPHY_FLAG_DISABLE_BEACON_HINTS |
-       WIPHY_FLAG_IBSS_RSN;
+ if (mvm->fw->ucode_capa.api[0] & IWL_UCODE_TLV_API_CSA_FLOW)
+  hw->wiphy->flags |= WIPHY_FLAG_HAS_CHANNEL_SWITCH;
+
+ hw->wiphy->iface_combinations = iwl_mvm_iface_combinations;
+ hw->wiphy->n_iface_combinations =
+  ARRAY_SIZE(iwl_mvm_iface_combinations);
 
  hw->wiphy->max_remain_on_channel_duration = 10000;
  hw->max_listen_interval = IWL_CONN_MAX_LISTEN_INTERVAL;
@@ -159,9 +347,10 @@ int iwl_mvm_mac_setup_register(struct iwl_mvm *mvm)
   hw->wiphy->n_addresses++;
  }
 
- /* we create the 802.11 header and a max-length SSID element */
- hw->wiphy->max_scan_ie_len =
-  mvm->fw->ucode_capa.max_probe_length - 24 - 34;
+ iwl_mvm_reset_phy_ctxts(mvm);
+
+ hw->wiphy->max_scan_ie_len = iwl_mvm_max_scan_ie_len(mvm);
+
  hw->wiphy->max_scan_ssids = PROBE_OPTION_MAX;
 
  if (mvm->nvm_data->bands[IEEE80211_BAND_2GHZ].n_channels)
@@ -178,33 +367,54 @@ int iwl_mvm_mac_setup_register(struct iwl_mvm *mvm)
  else
   hw->wiphy->flags &= ~WIPHY_FLAG_PS_ON_BY_DEFAULT;
 
+ hw->wiphy->flags |= WIPHY_FLAG_SUPPORTS_SCHED_SCAN;
+ hw->wiphy->max_sched_scan_ssids = PROBE_OPTION_MAX;
+ hw->wiphy->max_match_sets = IWL_SCAN_MAX_PROFILES;
+ /* we create the 802.11 header and zero length SSID IE. */
+ hw->wiphy->max_sched_scan_ie_len = SCAN_OFFLOAD_PROBE_REQ_SIZE - 24 - 2;
+
  hw->wiphy->features |= NL80211_FEATURE_P2P_GO_CTWIN |
           NL80211_FEATURE_P2P_GO_OPPPS;
 
  mvm->rts_threshold = IEEE80211_MAX_RTS_THRESHOLD;
 
+ /* currently FW API supports only one optional cipher scheme */
+ if (mvm->fw->cs[0].cipher) {
+  mvm->hw->n_cipher_schemes = 1;
+  mvm->hw->cipher_schemes = &mvm->fw->cs[0];
+ }
+
 #ifdef CONFIG_PM_SLEEP
- if (mvm->fw->img[IWL_UCODE_WOWLAN].sec[0].len &&
+ if (iwl_mvm_is_d0i3_supported(mvm) &&
+     device_can_wakeup(mvm->trans->dev)) {
+  mvm->wowlan.flags = WIPHY_WOWLAN_ANY;
+  hw->wiphy->wowlan = &mvm->wowlan;
+ } else if (mvm->fw->img[IWL_UCODE_WOWLAN].sec[0].len &&
      mvm->trans->ops->d3_suspend &&
      mvm->trans->ops->d3_resume &&
      device_can_wakeup(mvm->trans->dev)) {
-  hw->wiphy->wowlan.flags = WIPHY_WOWLAN_MAGIC_PKT |
-       WIPHY_WOWLAN_DISCONNECT |
-       WIPHY_WOWLAN_EAP_IDENTITY_REQ |
-       WIPHY_WOWLAN_RFKILL_RELEASE;
+  mvm->wowlan.flags = WIPHY_WOWLAN_MAGIC_PKT |
+        WIPHY_WOWLAN_DISCONNECT |
+        WIPHY_WOWLAN_EAP_IDENTITY_REQ |
+        WIPHY_WOWLAN_RFKILL_RELEASE;
   if (!iwlwifi_mod_params.sw_crypto)
-   hw->wiphy->wowlan.flags |=
-    WIPHY_WOWLAN_SUPPORTS_GTK_REKEY |
-    WIPHY_WOWLAN_GTK_REKEY_FAILURE |
-    WIPHY_WOWLAN_4WAY_HANDSHAKE;
-
-  hw->wiphy->wowlan.n_patterns = IWL_WOWLAN_MAX_PATTERNS;
-  hw->wiphy->wowlan.pattern_min_len = IWL_WOWLAN_MIN_PATTERN_LEN;
-  hw->wiphy->wowlan.pattern_max_len = IWL_WOWLAN_MAX_PATTERN_LEN;
-  hw->wiphy->wowlan.tcp = &iwl_mvm_wowlan_tcp_support;
+   mvm->wowlan.flags |= WIPHY_WOWLAN_SUPPORTS_GTK_REKEY |
+          WIPHY_WOWLAN_GTK_REKEY_FAILURE |
+          WIPHY_WOWLAN_4WAY_HANDSHAKE;
+
+  mvm->wowlan.n_patterns = IWL_WOWLAN_MAX_PATTERNS;
+  mvm->wowlan.pattern_min_len = IWL_WOWLAN_MIN_PATTERN_LEN;
+  mvm->wowlan.pattern_max_len = IWL_WOWLAN_MAX_PATTERN_LEN;
+  mvm->wowlan.tcp = &iwl_mvm_wowlan_tcp_support;
+  hw->wiphy->wowlan = &mvm->wowlan;
  }
 #endif
 
+#ifdef CONFIG_IWLWIFI_BCAST_FILTERING
+ /* assign default bcast filtering configuration */
+ mvm->bcast_filters = iwl_mvm_default_bcast_filters;
+#endif
+
  ret = iwl_mvm_leds_init(mvm);
  if (ret)
   return ret;
@@ -216,14 +426,58 @@ int iwl_mvm_mac_setup_register(struct iwl_mvm *mvm)
  return ret;
 }
 
+static bool iwl_mvm_defer_tx(struct iwl_mvm *mvm,
+        struct ieee80211_sta *sta,
+        struct sk_buff *skb)
+{
+ struct iwl_mvm_sta *mvmsta;
+ bool defer = false;
+
+ /*
+  * double check the IN_D0I3 flag both before and after
+  * taking the spinlock, in order to prevent taking
+  * the spinlock when not needed.
+  */
+ if (likely(!test_bit(IWL_MVM_STATUS_IN_D0I3, &mvm->status)))
+  return false;
+
+ spin_lock(&mvm->d0i3_tx_lock);
+ /*
+  * testing the flag again ensures the skb dequeue
+  * loop (on d0i3 exit) hasn't run yet.
+  */
+ if (!test_bit(IWL_MVM_STATUS_IN_D0I3, &mvm->status))
+  goto out;
+
+ mvmsta = iwl_mvm_sta_from_mac80211(sta);
+ if (mvmsta->sta_id == IWL_MVM_STATION_COUNT ||
+     mvmsta->sta_id != mvm->d0i3_ap_sta_id)
+  goto out;
+
+ __skb_queue_tail(&mvm->d0i3_tx, skb);
+ ieee80211_stop_queues(mvm->hw);
+
+ /* trigger wakeup */
+ iwl_mvm_ref(mvm, IWL_MVM_REF_TX);
+ iwl_mvm_unref(mvm, IWL_MVM_REF_TX);
+
+ defer = true;
+out:
+ spin_unlock(&mvm->d0i3_tx_lock);
+ return defer;
+}
+
 static void iwl_mvm_mac_tx(struct ieee80211_hw *hw,
       struct ieee80211_tx_control *control,
       struct sk_buff *skb)
 {
  struct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);
+ struct ieee80211_sta *sta = control->sta;
+ struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
+ struct ieee80211_hdr *hdr = (void *)skb->data;
 
- if (test_bit(IWL_MVM_STATUS_HW_RFKILL, &mvm->status)) {
-  IWL_DEBUG_DROP(mvm, "Dropping - RF KILL\n");
+ if (iwl_mvm_is_radio_killed(mvm)) {
+  IWL_DEBUG_DROP(mvm, "Dropping - RF/CT KILL\n");
   goto drop;
  }
 
@@ -231,8 +485,18 @@ static void iwl_mvm_mac_tx(struct ieee80211_hw *hw,
      !test_bit(IWL_MVM_STATUS_ROC_RUNNING, &mvm->status))
   goto drop;
 
- if (control->sta) {
-  if (iwl_mvm_tx_skb(mvm, skb, control->sta))
+ /* treat non-bufferable MMPDUs as broadcast if sta is sleeping */
+ if (unlikely(info->flags & IEEE80211_TX_CTL_NO_PS_BUFFER &&
+       ieee80211_is_mgmt(hdr->frame_control) &&
+       !ieee80211_is_deauth(hdr->frame_control) &&
+       !ieee80211_is_disassoc(hdr->frame_control) &&
+       !ieee80211_is_action(hdr->frame_control)))
+  sta = NULL;
+
+ if (sta) {
+  if (iwl_mvm_defer_tx(mvm, sta, skb))
+   return;
+  if (iwl_mvm_tx_skb(mvm, skb, sta))
    goto drop;
   return;
  }
@@ -244,6 +508,24 @@ static void iwl_mvm_mac_tx(struct ieee80211_hw *hw,
  ieee80211_free_txskb(hw, skb);
 }
 
+static inline bool iwl_enable_rx_ampdu(const struct iwl_cfg *cfg)
+{
+ if (iwlwifi_mod_params.disable_11n & IWL_DISABLE_HT_RXAGG)
+  return false;
+ return true;
+}
+
+static inline bool iwl_enable_tx_ampdu(const struct iwl_cfg *cfg)
+{
+ if (iwlwifi_mod_params.disable_11n & IWL_DISABLE_HT_TXAGG)
+  return false;
+ if (iwlwifi_mod_params.disable_11n & IWL_ENABLE_HT_TXAGG)
+  return true;
+
+ /* enabled by default */
+ return true;
+}
+
 static int iwl_mvm_mac_ampdu_action(struct ieee80211_hw *hw,
         struct ieee80211_vif *vif,
         enum ieee80211_ampdu_mlme_action action,
@@ -252,6 +534,7 @@ static int iwl_mvm_mac_ampdu_action(struct ieee80211_hw *hw,
 {
  struct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);
  int ret;
+ bool tx_agg_ref = false;
 
  IWL_DEBUG_HT(mvm, "A-MPDU action on addr %pM tid %d: action %d\n",
        sta->addr, tid, action);
@@ -259,11 +542,40 @@ static int iwl_mvm_mac_ampdu_action(struct ieee80211_hw *hw,
  if (!(mvm->nvm_data->sku_cap_11n_enable))
   return -EACCES;
 
+ /* return from D0i3 before starting a new Tx aggregation */
+ switch (action) {
+ case IEEE80211_AMPDU_TX_START:
+ case IEEE80211_AMPDU_TX_STOP_CONT:
+ case IEEE80211_AMPDU_TX_STOP_FLUSH:
+ case IEEE80211_AMPDU_TX_STOP_FLUSH_CONT:
+ case IEEE80211_AMPDU_TX_OPERATIONAL:
+  iwl_mvm_ref(mvm, IWL_MVM_REF_TX_AGG);
+  tx_agg_ref = true;
+
+  /*
+   * for tx start, wait synchronously until D0i3 exit to
+   * get the correct sequence number for the tid.
+   * additionally, some other ampdu actions use direct
+   * target access, which is not handled automatically
+   * by the trans layer (unlike commands), so wait for
+   * d0i3 exit in these cases as well.
+   */
+  if (!wait_event_timeout(mvm->d0i3_exit_waitq,
+     !test_bit(IWL_MVM_STATUS_IN_D0I3, &mvm->status), HZ)) {
+   WARN_ON_ONCE(1);
+   iwl_mvm_unref(mvm, IWL_MVM_REF_TX_AGG);
+   return -EIO;
+  }
+  break;
+ default:
+  break;
+ }
+
  mutex_lock(&mvm->mutex);
 
  switch (action) {
  case IEEE80211_AMPDU_RX_START:
-  if (iwlwifi_mod_params.disable_11n & IWL_DISABLE_HT_RXAGG) {
+  if (!iwl_enable_rx_ampdu(mvm->cfg)) {
    ret = -EINVAL;
    break;
   }
@@ -273,7 +585,7 @@ static int iwl_mvm_mac_ampdu_action(struct ieee80211_hw *hw,
   ret = iwl_mvm_sta_rx_agg(mvm, sta, tid, 0, false);
   break;
  case IEEE80211_AMPDU_TX_START:
-  if (iwlwifi_mod_params.disable_11n & IWL_DISABLE_HT_TXAGG) {
+  if (!iwl_enable_tx_ampdu(mvm->cfg)) {
    ret = -EINVAL;
    break;
   }
@@ -296,6 +608,13 @@ static int iwl_mvm_mac_ampdu_action(struct ieee80211_hw *hw,
  }
  mutex_unlock(&mvm->mutex);
 
+ /*
+  * If the tid is marked as started, we won't use it for offloaded
+  * traffic on the next D0i3 entry. It's safe to unref.
+  */
+ if (tx_agg_ref)
+  iwl_mvm_unref(mvm, IWL_MVM_REF_TX_AGG);
+
  return ret;
 }
 
@@ -315,14 +634,21 @@ static void iwl_mvm_cleanup_iterator(void *data, u8 *mac,
  iwl_mvm_te_clear_data(mvm, &mvmvif->time_event_data);
  spin_unlock_bh(&mvm->time_event_lock);
 
- if (vif->type != NL80211_IFTYPE_P2P_DEVICE)
-  mvmvif->phy_ctxt = NULL;
+ mvmvif->phy_ctxt = NULL;
 }
 
 static void iwl_mvm_restart_cleanup(struct iwl_mvm *mvm)
 {
+#ifdef CONFIG_IWLWIFI_DEBUGFS
+ static char *env[] = { "DRIVER=iwlwifi", "EVENT=error_dump", NULL };
+
+ iwl_mvm_fw_error_dump(mvm);
+
+ /* notify the userspace about the error we had */
+ kobject_uevent_env(&mvm->hw->wiphy->dev.kobj, KOBJ_CHANGE, env);
+#endif
+
  iwl_trans_stop_device(mvm->trans);
- iwl_trans_stop_hw(mvm->trans, false);
 
  mvm->scan_status = IWL_MVM_SCAN_NONE;
 
@@ -333,12 +659,21 @@ static void iwl_mvm_restart_cleanup(struct iwl_mvm *mvm)
   mvm->hw, IEEE80211_IFACE_ITER_RESUME_ALL,
   iwl_mvm_cleanup_iterator, mvm);
 
+ mvm->p2p_device_vif = NULL;
+ mvm->d0i3_ap_sta_id = IWL_MVM_STATION_COUNT;
+
+ iwl_mvm_reset_phy_ctxts(mvm);
  memset(mvm->fw_key_table, 0, sizeof(mvm->fw_key_table));
  memset(mvm->sta_drained, 0, sizeof(mvm->sta_drained));
 
  ieee80211_wake_queues(mvm->hw);
 
+ /* cleanup all stale references (scan, roc), but keep the
+  * ucode_down ref until reconfig is complete */
+ iwl_mvm_unref_all_except(mvm, IWL_MVM_REF_UCODE_DOWN);
+
  mvm->vif_count = 0;
+ mvm->rx_ba_sessions = 0;
 }
 
 static int iwl_mvm_mac_start(struct ieee80211_hw *hw)
@@ -366,11 +701,15 @@ static void iwl_mvm_mac_restart_complete(struct ieee80211_hw *hw)
  mutex_lock(&mvm->mutex);
 
  clear_bit(IWL_MVM_STATUS_IN_HW_RESTART, &mvm->status);
+ iwl_mvm_d0i3_enable_tx(mvm, NULL);
  ret = iwl_mvm_update_quotas(mvm, NULL);
  if (ret)
   IWL_ERR(mvm, "Failed to update quotas after restart (%d)\n",
    ret);
 
+ /* allow transport/FW low power modes */
+ iwl_mvm_unref(mvm, IWL_MVM_REF_UCODE_DOWN);
+
  mutex_unlock(&mvm->mutex);
 }
 
@@ -378,9 +717,14 @@ static void iwl_mvm_mac_stop(struct ieee80211_hw *hw)
 {
  struct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);
 
+ flush_work(&mvm->d0i3_exit_work);
  flush_work(&mvm->async_handlers_wk);
 
  mutex_lock(&mvm->mutex);
+
+ /* disallow low power states when the FW is down */
+ iwl_mvm_ref(mvm, IWL_MVM_REF_UCODE_DOWN);
+
  /* async_handlers_wk is now blocked */
 
  /*
@@ -390,7 +734,6 @@ static void iwl_mvm_mac_stop(struct ieee80211_hw *hw)
  cancel_work_sync(&mvm->roc_done_wk);
 
  iwl_trans_stop_device(mvm->trans);
- iwl_trans_stop_hw(mvm->trans, false);
 
  iwl_mvm_async_handlers_purge(mvm);
  /* async_handlers_list is empty and will stay empty: HW is stopped */
@@ -407,23 +750,32 @@ static void iwl_mvm_mac_stop(struct ieee80211_hw *hw)
  cancel_work_sync(&mvm->async_handlers_wk);
 }
 
-static void iwl_mvm_pm_disable_iterator(void *data, u8 *mac,
-     struct ieee80211_vif *vif)
+static struct iwl_mvm_phy_ctxt *iwl_mvm_get_free_phy_ctxt(struct iwl_mvm *mvm)
 {
- struct iwl_mvm *mvm = data;
- int ret;
+ u16 i;
 
- ret = iwl_mvm_power_disable(mvm, vif);
- if (ret)
-  IWL_ERR(mvm, "failed to disable power management\n");
+ lockdep_assert_held(&mvm->mutex);
+
+ for (i = 0; i < NUM_PHY_CTX; i++)
+  if (!mvm->phy_ctxts[i].ref)
+   return &mvm->phy_ctxts[i];
+
+ IWL_ERR(mvm, "No available PHY context\n");
+ return NULL;
 }
 
-static void iwl_mvm_power_update_iterator(void *data, u8 *mac,
-       struct ieee80211_vif *vif)
+static int iwl_mvm_set_tx_power(struct iwl_mvm *mvm, struct ieee80211_vif *vif,
+    s8 tx_power)
 {
- struct iwl_mvm *mvm = data;
+ /* FW is in charge of regulatory enforcement */
+ struct iwl_reduce_tx_power_cmd reduce_txpwr_cmd = {
+  .mac_context_id = iwl_mvm_vif_from_mac80211(vif)->id,
+  .pwr_restriction = cpu_to_le16(tx_power),
+ };
 
- iwl_mvm_power_update_mode(mvm, vif);
+ return iwl_mvm_send_cmd_pdu(mvm, REDUCE_TX_POWER_CMD, 0,
+        sizeof(reduce_txpwr_cmd),
+        &reduce_txpwr_cmd);
 }
 
 static int iwl_mvm_mac_add_interface(struct ieee80211_hw *hw,
@@ -441,11 +793,15 @@ static int iwl_mvm_mac_add_interface(struct ieee80211_hw *hw,
 
  mutex_lock(&mvm->mutex);
 
- /* Allocate resources for the MAC context, and add it the the fw  */
+ /* Allocate resources for the MAC context, and add it to the fw  */
  ret = iwl_mvm_mac_ctxt_init(mvm, vif);
  if (ret)
   goto out_unlock;
 
+ /* Counting number of interfaces is needed for legacy PM */
+ if (vif->type != NL80211_IFTYPE_P2P_DEVICE)
+  mvm->vif_count++;
+
  /*
   * The AP binding flow can be done only after the beacon
   * template is configured (which happens only in the mac80211
@@ -457,48 +813,40 @@ static int iwl_mvm_mac_add_interface(struct ieee80211_hw *hw,
   * In short: there's not much we can do at this point, other than
   * allocating resources :)
   */
- if (vif->type == NL80211_IFTYPE_AP) {
+ if (vif->type == NL80211_IFTYPE_AP ||
+     vif->type == NL80211_IFTYPE_ADHOC) {
   u32 qmask = iwl_mvm_mac_get_queues_mask(mvm, vif);
   ret = iwl_mvm_allocate_int_sta(mvm, &mvmvif->bcast_sta,
-            qmask);
+            qmask,
+            ieee80211_vif_type_p2p(vif));
   if (ret) {
    IWL_ERR(mvm, "Failed to allocate bcast sta\n");
    goto out_release;
   }
 
+  iwl_mvm_vif_dbgfs_register(mvm, vif);
   goto out_unlock;
  }
 
- /*
-  * TODO: remove this temporary code.
-  * Currently MVM FW supports power management only on single MAC.
-  * If new interface added, disable PM on existing interface.
-  * P2P device is a special case, since it is handled by FW similary to
-  * scan. If P2P deviced is added, PM remains enabled on existing
-  * interface.
-  * Note: the method below does not count the new interface being added
-  * at this moment.
-  */
- if (vif->type != NL80211_IFTYPE_P2P_DEVICE)
-  mvm->vif_count++;
- if (mvm->vif_count > 1) {
-  IWL_DEBUG_MAC80211(mvm,
-       "Disable power on existing interfaces\n");
-  ieee80211_iterate_active_interfaces_atomic(
-         mvm->hw,
-         IEEE80211_IFACE_ITER_NORMAL,
-         iwl_mvm_pm_disable_iterator, mvm);
- }
-
  ret = iwl_mvm_mac_ctxt_add(mvm, vif);
  if (ret)
   goto out_release;
 
- /*
-  * Update power state on the new interface. Admittedly, based on
-  * mac80211 logics this power update will disable power management
-  */
- iwl_mvm_power_update_mode(mvm, vif);
+ ret = iwl_mvm_power_update_mac(mvm);
+ if (ret)
+  goto out_release;
+
+ /* beacon filtering */
+ ret = iwl_mvm_disable_beacon_filter(mvm, vif, 0);
+ if (ret)
+  goto out_remove_mac;
+
+ if (!mvm->bf_allowed_vif &&
+     vif->type == NL80211_IFTYPE_STATION && !vif->p2p) {
+  mvm->bf_allowed_vif = mvmvif;
+  vif->driver_flags |= IEEE80211_VIF_BEACON_FILTER |
+         IEEE80211_VIF_SUPPORTS_CQM_RSSI;
+ }
 
  /*
   * P2P_DEVICE interface does not have a channel context assigned to it,
@@ -506,26 +854,17 @@ static int iwl_mvm_mac_add_interface(struct ieee80211_hw *hw,
   * MAC context is bound to it at this stage.
   */
  if (vif->type == NL80211_IFTYPE_P2P_DEVICE) {
-  struct ieee80211_channel *chan;
-  struct cfg80211_chan_def chandef;
 
-  mvmvif->phy_ctxt = &mvm->phy_ctxt_roc;
-
-  /*
-   * The channel used here isn't relevant as it's
-   * going to be overwritten as part of the ROC flow.
-   * For now use the first channel we have.
-   */
-  chan = &mvm->hw->wiphy->bands[IEEE80211_BAND_2GHZ]->channels[0];
-  cfg80211_chandef_create(&chandef, chan, NL80211_CHAN_NO_HT);
-  ret = iwl_mvm_phy_ctxt_add(mvm, mvmvif->phy_ctxt,
-        &chandef, 1, 1);
-  if (ret)
-   goto out_remove_mac;
+  mvmvif->phy_ctxt = iwl_mvm_get_free_phy_ctxt(mvm);
+  if (!mvmvif->phy_ctxt) {
+   ret = -ENOSPC;
+   goto out_free_bf;
+  }
 
+  iwl_mvm_phy_ctxt_ref(mvm, mvmvif->phy_ctxt);
   ret = iwl_mvm_binding_add_vif(mvm, vif);
   if (ret)
-   goto out_remove_phy;
+   goto out_unref_phy;
 
   ret = iwl_mvm_add_bcast_sta(mvm, vif, &mvmvif->bcast_sta);
   if (ret)
@@ -541,27 +880,21 @@ static int iwl_mvm_mac_add_interface(struct ieee80211_hw *hw,
 
  out_unbind:
  iwl_mvm_binding_remove_vif(mvm, vif);
- out_remove_phy:
- iwl_mvm_phy_ctxt_remove(mvm, mvmvif->phy_ctxt);
+ out_unref_phy:
+ iwl_mvm_phy_ctxt_unref(mvm, mvmvif->phy_ctxt);
+ out_free_bf:
+ if (mvm->bf_allowed_vif == mvmvif) {
+  mvm->bf_allowed_vif = NULL;
+  vif->driver_flags &= ~(IEEE80211_VIF_BEACON_FILTER |
+           IEEE80211_VIF_SUPPORTS_CQM_RSSI);
+ }
  out_remove_mac:
  mvmvif->phy_ctxt = NULL;
  iwl_mvm_mac_ctxt_remove(mvm, vif);
  out_release:
- /*
-  * TODO: remove this temporary code.
-  * Currently MVM FW supports power management only on single MAC.
-  * Check if only one additional interface remains after releasing
-  * current one. Update power mode on the remaining interface.
-  */
  if (vif->type != NL80211_IFTYPE_P2P_DEVICE)
   mvm->vif_count--;
- IWL_DEBUG_MAC80211(mvm, "Currently %d interfaces active\n",
-      mvm->vif_count);
- if (mvm->vif_count == 1) {
-  ieee80211_iterate_active_interfaces(
-     mvm->hw, IEEE80211_IFACE_ITER_NORMAL,
-     iwl_mvm_power_update_iterator, mvm);
- }
+
  iwl_mvm_mac_ctxt_release(mvm, vif);
  out_unlock:
  mutex_unlock(&mvm->mutex);
@@ -599,8 +932,7 @@ static void iwl_mvm_prepare_mac_removal(struct iwl_mvm *mvm,
    * By now, all the AC queues are empty. The AGG queues are
    * empty too. We already got all the Tx responses for all the
    * packets in the queues. The drain work can have been
-   * triggered. Flush it. This work item takes the mutex, so kill
-   * it before we take it.
+   * triggered. Flush it.
    */
   flush_work(&mvm->sta_drained_wk);
  }
@@ -616,13 +948,26 @@ static void iwl_mvm_mac_remove_interface(struct ieee80211_hw *hw,
 
  mutex_lock(&mvm->mutex);
 
+ if (mvm->bf_allowed_vif == mvmvif) {
+  mvm->bf_allowed_vif = NULL;
+  vif->driver_flags &= ~(IEEE80211_VIF_BEACON_FILTER |
+           IEEE80211_VIF_SUPPORTS_CQM_RSSI);
+ }
+
  iwl_mvm_vif_dbgfs_clean(mvm, vif);
 
  /*
   * For AP/GO interface, the tear down of the resources allocated to the
   * interface is be handled as part of the stop_ap flow.
   */
- if (vif->type == NL80211_IFTYPE_AP) {
+ if (vif->type == NL80211_IFTYPE_AP ||
+     vif->type == NL80211_IFTYPE_ADHOC) {
+#ifdef CONFIG_NL80211_TESTMODE
+  if (vif == mvm->noa_vif) {
+   mvm->noa_vif = NULL;
+   mvm->noa_duration = 0;
+  }
+#endif
   iwl_mvm_dealloc_int_sta(mvm, &mvmvif->bcast_sta);
   goto out_release;
  }
@@ -631,26 +976,14 @@ static void iwl_mvm_mac_remove_interface(struct ieee80211_hw *hw,
   mvm->p2p_device_vif = NULL;
   iwl_mvm_rm_bcast_sta(mvm, &mvmvif->bcast_sta);
   iwl_mvm_binding_remove_vif(mvm, vif);
-  iwl_mvm_phy_ctxt_remove(mvm, mvmvif->phy_ctxt);
+  iwl_mvm_phy_ctxt_unref(mvm, mvmvif->phy_ctxt);
   mvmvif->phy_ctxt = NULL;
  }
 
- /*
-  * TODO: remove this temporary code.
-  * Currently MVM FW supports power management only on single MAC.
-  * Check if only one additional interface remains after removing
-  * current one. Update power mode on the remaining interface.
-  */
  if (mvm->vif_count && vif->type != NL80211_IFTYPE_P2P_DEVICE)
   mvm->vif_count--;
- IWL_DEBUG_MAC80211(mvm, "Currently %d interfaces active\n",
-      mvm->vif_count);
- if (mvm->vif_count == 1) {
-  ieee80211_iterate_active_interfaces(
-     mvm->hw, IEEE80211_IFACE_ITER_NORMAL,
-     iwl_mvm_power_update_iterator, mvm);
- }
 
+ iwl_mvm_power_update_mac(mvm);
  iwl_mvm_mac_ctxt_remove(mvm, vif);
 
 out_release:
@@ -663,27 +996,264 @@ static int iwl_mvm_mac_config(struct ieee80211_hw *hw, u32 changed)
  return 0;
 }
 
+struct iwl_mvm_mc_iter_data {
+ struct iwl_mvm *mvm;
+ int port_id;
+};
+
+static void iwl_mvm_mc_iface_iterator(void *_data, u8 *mac,
+          struct ieee80211_vif *vif)
+{
+ struct iwl_mvm_mc_iter_data *data = _data;
+ struct iwl_mvm *mvm = data->mvm;
+ struct iwl_mcast_filter_cmd *cmd = mvm->mcast_filter_cmd;
+ int ret, len;
+
+ /* if we don't have free ports, mcast frames will be dropped */
+ if (WARN_ON_ONCE(data->port_id >= MAX_PORT_ID_NUM))
+  return;
+
+ if (vif->type != NL80211_IFTYPE_STATION ||
+     !vif->bss_conf.assoc)
+  return;
+
+ cmd->port_id = data->port_id++;
+ memcpy(cmd->bssid, vif->bss_conf.bssid, ETH_ALEN);
+ len = roundup(sizeof(*cmd) + cmd->count * ETH_ALEN, 4);
+
+ ret = iwl_mvm_send_cmd_pdu(mvm, MCAST_FILTER_CMD, CMD_ASYNC, len, cmd);
+ if (ret)
+  IWL_ERR(mvm, "mcast filter cmd error. ret=%d\n", ret);
+}
+
+static void iwl_mvm_recalc_multicast(struct iwl_mvm *mvm)
+{
+ struct iwl_mvm_mc_iter_data iter_data = {
+  .mvm = mvm,
+ };
+
+ lockdep_assert_held(&mvm->mutex);
+
+ if (WARN_ON_ONCE(!mvm->mcast_filter_cmd))
+  return;
+
+ ieee80211_iterate_active_interfaces_atomic(
+  mvm->hw, IEEE80211_IFACE_ITER_NORMAL,
+  iwl_mvm_mc_iface_iterator, &iter_data);
+}
+
+static u64 iwl_mvm_prepare_multicast(struct ieee80211_hw *hw,
+         struct netdev_hw_addr_list *mc_list)
+{
+ struct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);
+ struct iwl_mcast_filter_cmd *cmd;
+ struct netdev_hw_addr *addr;
+ int addr_count = netdev_hw_addr_list_count(mc_list);
+ bool pass_all = false;
+ int len;
+
+ if (addr_count > MAX_MCAST_FILTERING_ADDRESSES) {
+  pass_all = true;
+  addr_count = 0;
+ }
+
+ len = roundup(sizeof(*cmd) + addr_count * ETH_ALEN, 4);
+ cmd = kzalloc(len, GFP_ATOMIC);
+ if (!cmd)
+  return 0;
+
+ if (pass_all) {
+  cmd->pass_all = 1;
+  return (u64)(unsigned long)cmd;
+ }
+
+ netdev_hw_addr_list_for_each(addr, mc_list) {
+  IWL_DEBUG_MAC80211(mvm, "mcast addr (%d): %pM\n",
+       cmd->count, addr->addr);
+  memcpy(&cmd->addr_list[cmd->count * ETH_ALEN],
+         addr->addr, ETH_ALEN);
+  cmd->count++;
+ }
+
+ return (u64)(unsigned long)cmd;
+}
+
 static void iwl_mvm_configure_filter(struct ieee80211_hw *hw,
          unsigned int changed_flags,
          unsigned int *total_flags,
          u64 multicast)
 {
+ struct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);
+ struct iwl_mcast_filter_cmd *cmd = (void *)(unsigned long)multicast;
+
+ mutex_lock(&mvm->mutex);
+
+ /* replace previous configuration */
+ kfree(mvm->mcast_filter_cmd);
+ mvm->mcast_filter_cmd = cmd;
+
+ if (!cmd)
+  goto out;
+
+ iwl_mvm_recalc_multicast(mvm);
+out:
+ mutex_unlock(&mvm->mutex);
  *total_flags = 0;
 }
 
-static int iwl_mvm_configure_mcast_filter(struct iwl_mvm *mvm,
+#ifdef CONFIG_IWLWIFI_BCAST_FILTERING
+struct iwl_bcast_iter_data {
+ struct iwl_mvm *mvm;
+ struct iwl_bcast_filter_cmd *cmd;
+ u8 current_filter;
+};
+
+static void
+iwl_mvm_set_bcast_filter(struct ieee80211_vif *vif,
+    const struct iwl_fw_bcast_filter *in_filter,
+    struct iwl_fw_bcast_filter *out_filter)
+{
+ struct iwl_fw_bcast_filter_attr *attr;
+ int i;
+
+ memcpy(out_filter, in_filter, sizeof(*out_filter));
+
+ for (i = 0; i < ARRAY_SIZE(out_filter->attrs); i++) {
+  attr = &out_filter->attrs[i];
+
+  if (!attr->mask)
+   break;
+
+  switch (attr->reserved1) {
+  case cpu_to_le16(BC_FILTER_MAGIC_IP):
+   if (vif->bss_conf.arp_addr_cnt != 1) {
+    attr->mask = 0;
+    continue;
+   }
+
+   attr->val = vif->bss_conf.arp_addr_list[0];
+   break;
+  case cpu_to_le16(BC_FILTER_MAGIC_MAC):
+   attr->val = *(__be32 *)&vif->addr[2];
+   break;
+  default:
+   break;
+  }
+  attr->reserved1 = 0;
+  out_filter->num_attrs++;
+ }
+}
+
+static void iwl_mvm_bcast_filter_iterator(void *_data, u8 *mac,
        struct ieee80211_vif *vif)
 {
- struct iwl_mcast_filter_cmd mcast_filter_cmd = {
-  .pass_all = 1,
+ struct iwl_bcast_iter_data *data = _data;
+ struct iwl_mvm *mvm = data->mvm;
+ struct iwl_bcast_filter_cmd *cmd = data->cmd;
+ struct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);
+ struct iwl_fw_bcast_mac *bcast_mac;
+ int i;
+
+ if (WARN_ON(mvmvif->id >= ARRAY_SIZE(cmd->macs)))
+  return;
+
+ bcast_mac = &cmd->macs[mvmvif->id];
+
+ /*
+  * enable filtering only for associated stations, but not for P2P
+  * Clients
+  */
+ if (vif->type != NL80211_IFTYPE_STATION || vif->p2p ||
+     !vif->bss_conf.assoc)
+  return;
+
+ bcast_mac->default_discard = 1;
+
+ /* copy all configured filters */
+ for (i = 0; mvm->bcast_filters[i].attrs[0].mask; i++) {
+  /*
+   * Make sure we don't exceed our filters limit.
+   * if there is still a valid filter to be configured,
+   * be on the safe side and just allow bcast for this mac.
+   */
+  if (WARN_ON_ONCE(data->current_filter >=
+     ARRAY_SIZE(cmd->filters))) {
+   bcast_mac->default_discard = 0;
+   bcast_mac->attached_filters = 0;
+   break;
+  }
+
+  iwl_mvm_set_bcast_filter(vif,
+      &mvm->bcast_filters[i],
+      &cmd->filters[data->current_filter]);
+
+  /* skip current filter if it contains no attributes */
+  if (!cmd->filters[data->current_filter].num_attrs)
+   continue;
+
+  /* attach the filter to current mac */
+  bcast_mac->attached_filters |=
+    cpu_to_le16(BIT(data->current_filter));
+
+  data->current_filter++;
+ }
+}
+
+bool iwl_mvm_bcast_filter_build_cmd(struct iwl_mvm *mvm,
+        struct iwl_bcast_filter_cmd *cmd)
+{
+ struct iwl_bcast_iter_data iter_data = {
+  .mvm = mvm,
+  .cmd = cmd,
  };
 
- memcpy(mcast_filter_cmd.bssid, vif->bss_conf.bssid, ETH_ALEN);
+ memset(cmd, 0, sizeof(*cmd));
+ cmd->max_bcast_filters = ARRAY_SIZE(cmd->filters);
+ cmd->max_macs = ARRAY_SIZE(cmd->macs);
+
+#ifdef CONFIG_IWLWIFI_DEBUGFS
+ /* use debugfs filters/macs if override is configured */
+ if (mvm->dbgfs_bcast_filtering.override) {
+  memcpy(cmd->filters, &mvm->dbgfs_bcast_filtering.cmd.filters,
+         sizeof(cmd->filters));
+  memcpy(cmd->macs, &mvm->dbgfs_bcast_filtering.cmd.macs,
+         sizeof(cmd->macs));
+  return true;
+ }
+#endif
+
+ /* if no filters are configured, do nothing */
+ if (!mvm->bcast_filters)
+  return false;
+
+ /* configure and attach these filters for each associated sta vif */
+ ieee80211_iterate_active_interfaces(
+  mvm->hw, IEEE80211_IFACE_ITER_NORMAL,
+  iwl_mvm_bcast_filter_iterator, &iter_data);
 
- return iwl_mvm_send_cmd_pdu(mvm, MCAST_FILTER_CMD, CMD_SYNC,
-        sizeof(mcast_filter_cmd),
-        &mcast_filter_cmd);
+ return true;
 }
+static int iwl_mvm_configure_bcast_filter(struct iwl_mvm *mvm,
+       struct ieee80211_vif *vif)
+{
+ struct iwl_bcast_filter_cmd cmd;
+
+ if (!(mvm->fw->ucode_capa.flags & IWL_UCODE_TLV_FLAGS_BCAST_FILTERING))
+  return 0;
+
+ if (!iwl_mvm_bcast_filter_build_cmd(mvm, &cmd))
+  return 0;
+
+ return iwl_mvm_send_cmd_pdu(mvm, BCAST_FILTER_CMD, 0,
+        sizeof(cmd), &cmd);
+}
+#else
+static inline int iwl_mvm_configure_bcast_filter(struct iwl_mvm *mvm,
+       struct ieee80211_vif *vif)
+{
+ return 0;
+}
+#endif
 
 static void iwl_mvm_bss_info_changed_station(struct iwl_mvm *mvm,
           struct ieee80211_vif *vif,
@@ -693,7 +1263,15 @@ static void iwl_mvm_bss_info_changed_station(struct iwl_mvm *mvm,
  struct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);
  int ret;
 
- ret = iwl_mvm_mac_ctxt_changed(mvm, vif);
+ /*
+  * Re-calculate the tsf id, as the master-slave relations depend on the
+  * beacon interval, which was not known when the station interface was
+  * added.
+  */
+ if (changes & BSS_CHANGED_ASSOC && bss_conf->assoc)
+  iwl_mvm_mac_ctxt_recalc_tsf_id(mvm, vif);
+
+ ret = iwl_mvm_mac_ctxt_changed(mvm, vif, false);
  if (ret)
   IWL_ERR(mvm, "failed to update MAC %pM\n", vif->addr);
 
@@ -705,44 +1283,107 @@ static void iwl_mvm_bss_info_changed_station(struct iwl_mvm *mvm,
     IWL_ERR(mvm, "failed to update quotas\n");
     return;
    }
-   iwl_mvm_bt_coex_vif_assoc(mvm, vif);
-   iwl_mvm_configure_mcast_filter(mvm, vif);
+
+   if (test_bit(IWL_MVM_STATUS_IN_HW_RESTART,
+         &mvm->status)) {
+    /*
+     * If we're restarting then the firmware will
+     * obviously have lost synchronisation with
+     * the AP. It will attempt to synchronise by
+     * itself, but we can make it more reliable by
+     * scheduling a session protection time event.
+     *
+     * The firmware needs to receive a beacon to
+     * catch up with synchronisation, use 110% of
+     * the beacon interval.
+     *
+     * Set a large maximum delay to allow for more
+     * than a single interface.
+     */
+    u32 dur = (11 * vif->bss_conf.beacon_int) / 10;
+    iwl_mvm_protect_session(mvm, vif, dur, dur,
+       5 * dur);
+   }
+
+   iwl_mvm_sf_update(mvm, vif, false);
+   iwl_mvm_power_vif_assoc(mvm, vif);
+   if (vif->p2p)
+    iwl_mvm_ref(mvm, IWL_MVM_REF_P2P_CLIENT);
   } else if (mvmvif->ap_sta_id != IWL_MVM_STATION_COUNT) {
+   /*
+    * If update fails - SF might be running in associated
+    * mode while disassociated - which is forbidden.
+    */
+   WARN_ONCE(iwl_mvm_sf_update(mvm, vif, false),
+      "Failed to update SF upon disassociation\n");
+
    /* remove AP station now that the MAC is unassoc */
    ret = iwl_mvm_rm_sta_id(mvm, vif, mvmvif->ap_sta_id);
    if (ret)
     IWL_ERR(mvm, "failed to remove AP station\n");
+
+   if (mvm->d0i3_ap_sta_id == mvmvif->ap_sta_id)
+    mvm->d0i3_ap_sta_id = IWL_MVM_STATION_COUNT;
    mvmvif->ap_sta_id = IWL_MVM_STATION_COUNT;
    /* remove quota for this interface */
    ret = iwl_mvm_update_quotas(mvm, NULL);
    if (ret)
     IWL_ERR(mvm, "failed to update quotas\n");
+
+   if (vif->p2p)
+    iwl_mvm_unref(mvm, IWL_MVM_REF_P2P_CLIENT);
   }
- } else if (changes & BSS_CHANGED_DTIM_PERIOD) {
+
+  iwl_mvm_recalc_multicast(mvm);
+  iwl_mvm_configure_bcast_filter(mvm, vif);
+
+  /* reset rssi values */
+  mvmvif->bf_data.ave_beacon_signal = 0;
+
+  iwl_mvm_bt_coex_vif_change(mvm);
+  iwl_mvm_update_smps(mvm, vif, IWL_MVM_SMPS_REQ_TT,
+        IEEE80211_SMPS_AUTOMATIC);
+ } else if (changes & BSS_CHANGED_BEACON_INFO) {
   /*
    * We received a beacon _after_ association so
    * remove the session protection.
    */
   iwl_mvm_remove_time_event(mvm, mvmvif,
        &mvmvif->time_event_data);
- } else if (changes & BSS_CHANGED_PS) {
-  /*
-   * TODO: remove this temporary code.
-   * Currently MVM FW supports power management only on single
-   * MAC. Avoid power mode update if more than one interface
-   * is active.
-   */
-  IWL_DEBUG_MAC80211(mvm, "Currently %d interfaces active\n",
-       mvm->vif_count);
-  if (mvm->vif_count == 1) {
-   ret = iwl_mvm_power_update_mode(mvm, vif);
+  iwl_mvm_sf_update(mvm, vif, false);
+  WARN_ON(iwl_mvm_enable_beacon_filter(mvm, vif, 0));
+ } else if (changes & (BSS_CHANGED_PS | BSS_CHANGED_P2P_PS |
+         BSS_CHANGED_QOS)) {
+  ret = iwl_mvm_power_update_mac(mvm);
+  if (ret)
+   IWL_ERR(mvm, "failed to update power mode\n");
+ }
+ if (changes & BSS_CHANGED_TXPOWER) {
+  IWL_DEBUG_CALIB(mvm, "Changing TX Power to %d\n",
+    bss_conf->txpower);
+  iwl_mvm_set_tx_power(mvm, vif, bss_conf->txpower);
+ }
+
+ if (changes & BSS_CHANGED_CQM) {
+  IWL_DEBUG_MAC80211(mvm, "cqm info_changed\n");
+  /* reset cqm events tracking */
+  mvmvif->bf_data.last_cqm_event = 0;
+  if (mvmvif->bf_data.bf_enabled) {
+   ret = iwl_mvm_enable_beacon_filter(mvm, vif, 0);
    if (ret)
-    IWL_ERR(mvm, "failed to update power mode\n");
+    IWL_ERR(mvm,
+     "failed to update CQM thresholds\n");
   }
  }
+
+ if (changes & BSS_CHANGED_ARP_FILTER) {
+  IWL_DEBUG_MAC80211(mvm, "arp filter changed\n");
+  iwl_mvm_configure_bcast_filter(mvm, vif);
+ }
 }
 
-static int iwl_mvm_start_ap(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
+static int iwl_mvm_start_ap_ibss(struct ieee80211_hw *hw,
+     struct ieee80211_vif *vif)
 {
  struct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);
  struct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);
@@ -755,6 +1396,13 @@ static int iwl_mvm_start_ap(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
  if (ret)
   goto out_unlock;
 
+ /*
+  * Re-calculate the tsf id, as the master-slave relations depend on the
+  * beacon interval, which was not known when the AP interface was added.
+  */
+ if (vif->type == NL80211_IFTYPE_AP)
+  iwl_mvm_mac_ctxt_recalc_tsf_id(mvm, vif);
+
  /* Add the mac context */
  ret = iwl_mvm_mac_ctxt_add(mvm, vif);
  if (ret)
@@ -765,26 +1413,36 @@ static int iwl_mvm_start_ap(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
  if (ret)
   goto out_remove;
 
- mvmvif->ap_active = true;
-
  /* Send the bcast station. At this stage the TBTT and DTIM time events
   * are added and applied to the scheduler */
  ret = iwl_mvm_send_bcast_sta(mvm, vif, &mvmvif->bcast_sta);
  if (ret)
   goto out_unbind;
 
+ /* must be set before quota calculations */
+ mvmvif->ap_ibss_active = true;
+
+ /* power updated needs to be done before quotas */
+ iwl_mvm_power_update_mac(mvm);
+
  ret = iwl_mvm_update_quotas(mvm, vif);
  if (ret)
-  goto out_rm_bcast;
+  goto out_quota_failed;
 
- /* Need to update the P2P Device MAC */
+ /* Need to update the P2P Device MAC (only GO, IBSS is single vif) */
  if (vif->p2p && mvm->p2p_device_vif)
-  iwl_mvm_mac_ctxt_changed(mvm, mvm->p2p_device_vif);
+  iwl_mvm_mac_ctxt_changed(mvm, mvm->p2p_device_vif, false);
+
+ iwl_mvm_ref(mvm, IWL_MVM_REF_AP_IBSS);
+
+ iwl_mvm_bt_coex_vif_change(mvm);
 
  mutex_unlock(&mvm->mutex);
  return 0;
 
-out_rm_bcast:
+out_quota_failed:
+ iwl_mvm_power_update_mac(mvm);
+ mvmvif->ap_ibss_active = false;
  iwl_mvm_send_rm_bcast_sta(mvm, &mvmvif->bcast_sta);
 out_unbind:
  iwl_mvm_binding_remove_vif(mvm, vif);
@@ -795,7 +1453,8 @@ out_unlock:
  return ret;
 }
 
-static void iwl_mvm_stop_ap(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
+static void iwl_mvm_stop_ap_ibss(struct ieee80211_hw *hw,
+     struct ieee80211_vif *vif)
 {
  struct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);
  struct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);
@@ -804,30 +1463,48 @@ static void iwl_mvm_stop_ap(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
 
  mutex_lock(&mvm->mutex);
 
- mvmvif->ap_active = false;
+ mvmvif->ap_ibss_active = false;
+
+ iwl_mvm_bt_coex_vif_change(mvm);
 
- /* Need to update the P2P Device MAC */
+ iwl_mvm_unref(mvm, IWL_MVM_REF_AP_IBSS);
+
+ /* Need to update the P2P Device MAC (only GO, IBSS is single vif) */
  if (vif->p2p && mvm->p2p_device_vif)
-  iwl_mvm_mac_ctxt_changed(mvm, mvm->p2p_device_vif);
+  iwl_mvm_mac_ctxt_changed(mvm, mvm->p2p_device_vif, false);
 
  iwl_mvm_update_quotas(mvm, NULL);
  iwl_mvm_send_rm_bcast_sta(mvm, &mvmvif->bcast_sta);
  iwl_mvm_binding_remove_vif(mvm, vif);
+
+ iwl_mvm_power_update_mac(mvm);
+
  iwl_mvm_mac_ctxt_remove(mvm, vif);
 
  mutex_unlock(&mvm->mutex);
 }
 
-static void iwl_mvm_bss_info_changed_ap(struct iwl_mvm *mvm,
-     struct ieee80211_vif *vif,
-     struct ieee80211_bss_conf *bss_conf,
-     u32 changes)
+static void
+iwl_mvm_bss_info_changed_ap_ibss(struct iwl_mvm *mvm,
+     struct ieee80211_vif *vif,
+     struct ieee80211_bss_conf *bss_conf,
+     u32 changes)
 {
+ struct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);
+
+ /* Changes will be applied when the AP/IBSS is started */
+ if (!mvmvif->ap_ibss_active)
+  return;
+
+ if (changes & (BSS_CHANGED_ERP_CTS_PROT | BSS_CHANGED_HT |
+         BSS_CHANGED_BANDWIDTH) &&
+     iwl_mvm_mac_ctxt_changed(mvm, vif, false))
+  IWL_ERR(mvm, "failed to update MAC %pM\n", vif->addr);
+
  /* Need to send a new beacon template to the FW */
- if (changes & BSS_CHANGED_BEACON) {
-  if (iwl_mvm_mac_ctxt_beacon_changed(mvm, vif))
-   IWL_WARN(mvm, "Failed updating beacon data\n");
- }
+ if (changes & BSS_CHANGED_BEACON &&
+     iwl_mvm_mac_ctxt_beacon_changed(mvm, vif))
+  IWL_WARN(mvm, "Failed updating beacon data\n");
 }
 
 static void iwl_mvm_bss_info_changed(struct ieee80211_hw *hw,
@@ -839,12 +1516,16 @@ static void iwl_mvm_bss_info_changed(struct ieee80211_hw *hw,
 
  mutex_lock(&mvm->mutex);
 
+ if (changes & BSS_CHANGED_IDLE && !bss_conf->idle)
+  iwl_mvm_sched_scan_stop(mvm, true);
+
  switch (vif->type) {
  case NL80211_IFTYPE_STATION:
   iwl_mvm_bss_info_changed_station(mvm, vif, bss_conf, changes);
   break;
  case NL80211_IFTYPE_AP:
-  iwl_mvm_bss_info_changed_ap(mvm, vif, bss_conf, changes);
+ case NL80211_IFTYPE_ADHOC:
+  iwl_mvm_bss_info_changed_ap_ibss(mvm, vif, bss_conf, changes);
   break;
  default:
   /* shouldn't happen */
@@ -866,13 +1547,30 @@ static int iwl_mvm_mac_hw_scan(struct ieee80211_hw *hw,
 
  mutex_lock(&mvm->mutex);
 
- if (mvm->scan_status == IWL_MVM_SCAN_NONE)
-  ret = iwl_mvm_scan_request(mvm, vif, req);
- else
+ switch (mvm->scan_status) {
+ case IWL_MVM_SCAN_SCHED:
+  ret = iwl_mvm_sched_scan_stop(mvm, true);
+  if (ret) {
+   ret = -EBUSY;
+   goto out;
+  }
+  break;
+ case IWL_MVM_SCAN_NONE:
+  break;
+ default:
   ret = -EBUSY;
+  goto out;
+ }
 
- mutex_unlock(&mvm->mutex);
+ iwl_mvm_ref(mvm, IWL_MVM_REF_SCAN);
 
+ ret = iwl_mvm_scan_request(mvm, vif, req);
+ if (ret)
+  iwl_mvm_unref(mvm, IWL_MVM_REF_SCAN);
+out:
+ mutex_unlock(&mvm->mutex);
+ /* make sure to flush the Rx handler before the next scan arrives */
+ iwl_mvm_wait_for_async_handlers(mvm);
  return ret;
 }
 
@@ -890,20 +1588,32 @@ static void iwl_mvm_mac_cancel_hw_scan(struct ieee80211_hw *hw,
 
 static void
 iwl_mvm_mac_allow_buffered_frames(struct ieee80211_hw *hw,
-      struct ieee80211_sta *sta, u16 tid,
+      struct ieee80211_sta *sta, u16 tids,
       int num_frames,
       enum ieee80211_frame_release_type reason,
       bool more_data)
 {
  struct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);
 
- /* TODO: how do we tell the fw to send frames for a specific TID */
+ /* Called when we need to transmit (a) frame(s) from mac80211 */
 
- /*
-  * The fw will send EOSP notification when the last frame will be
-  * transmitted.
-  */
- iwl_mvm_sta_modify_sleep_tx_count(mvm, sta, reason, num_frames);
+ iwl_mvm_sta_modify_sleep_tx_count(mvm, sta, reason, num_frames,
+       tids, more_data, false);
+}
+
+static void
+iwl_mvm_mac_release_buffered_frames(struct ieee80211_hw *hw,
+        struct ieee80211_sta *sta, u16 tids,
+        int num_frames,
+        enum ieee80211_frame_release_type reason,
+        bool more_data)
+{
+ struct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);
+
+ /* Called when we need to transmit (a) frame(s) from agg queue */
+
+ iwl_mvm_sta_modify_sleep_tx_count(mvm, sta, reason, num_frames,
+       tids, more_data, true);
 }
 
 static void iwl_mvm_mac_sta_notify(struct ieee80211_hw *hw,
@@ -912,12 +1622,26 @@ static void iwl_mvm_mac_sta_notify(struct ieee80211_hw *hw,
        struct ieee80211_sta *sta)
 {
  struct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);
- struct iwl_mvm_sta *mvmsta = (void *)sta->drv_priv;
+ struct iwl_mvm_sta *mvmsta = iwl_mvm_sta_from_mac80211(sta);
+ int tid;
 
  switch (cmd) {
  case STA_NOTIFY_SLEEP:
   if (atomic_read(&mvm->pending_frames[mvmsta->sta_id]) > 0)
    ieee80211_sta_block_awake(hw, sta, true);
+  spin_lock_bh(&mvmsta->lock);
+  for (tid = 0; tid < IWL_MAX_TID_COUNT; tid++) {
+   struct iwl_mvm_tid_data *tid_data;
+
+   tid_data = &mvmsta->tid_data[tid];
+   if (tid_data->state != IWL_AGG_ON &&
+       tid_data->state != IWL_EMPTYING_HW_QUEUE_DELBA)
+    continue;
+   if (iwl_mvm_tid_queued(tid_data) == 0)
+    continue;
+   ieee80211_sta_set_buffered(sta, tid, true);
+  }
+  spin_unlock_bh(&mvmsta->lock);
   /*
    * The fw updates the STA to be asleep. Tx packets on the Tx
    * queues to this station will not be transmitted. The fw will
@@ -934,6 +1658,28 @@ static void iwl_mvm_mac_sta_notify(struct ieee80211_hw *hw,
  }
 }
 
+static void iwl_mvm_sta_pre_rcu_remove(struct ieee80211_hw *hw,
+           struct ieee80211_vif *vif,
+           struct ieee80211_sta *sta)
+{
+ struct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);
+ struct iwl_mvm_sta *mvm_sta = (void *)sta->drv_priv;
+
+ /*
+  * This is called before mac80211 does RCU synchronisation,
+  * so here we already invalidate our internal RCU-protected
+  * station pointer. The rest of the code will thus no longer
+  * be able to find the station this way, and we don't rely
+  * on further RCU synchronisation after the sta_state()
+  * callback deleted the station.
+  */
+ mutex_lock(&mvm->mutex);
+ if (sta == rcu_access_pointer(mvm->fw_id_to_mac_id[mvm_sta->sta_id]))
+  rcu_assign_pointer(mvm->fw_id_to_mac_id[mvm_sta->sta_id],
+       ERR_PTR(-ENOENT));
+ mutex_unlock(&mvm->mutex);
+}
+
 static int iwl_mvm_mac_sta_state(struct ieee80211_hw *hw,
      struct ieee80211_vif *vif,
      struct ieee80211_sta *sta,
@@ -975,18 +1721,28 @@ static int iwl_mvm_mac_sta_state(struct ieee80211_hw *hw,
   ret = iwl_mvm_add_sta(mvm, vif, sta);
  } else if (old_state == IEEE80211_STA_NONE &&
      new_state == IEEE80211_STA_AUTH) {
+  /*
+   * EBS may be disabled due to previous failures reported by FW.
+   * Reset EBS status here assuming environment has been changed.
+   */
+  mvm->last_ebs_successful = true;
   ret = 0;
  } else if (old_state == IEEE80211_STA_AUTH &&
      new_state == IEEE80211_STA_ASSOC) {
   ret = iwl_mvm_update_sta(mvm, vif, sta);
   if (ret == 0)
    iwl_mvm_rs_rate_init(mvm, sta,
-          mvmvif->phy_ctxt->channel->band);
+          mvmvif->phy_ctxt->channel->band,
+          true);
  } else if (old_state == IEEE80211_STA_ASSOC &&
      new_state == IEEE80211_STA_AUTHORIZED) {
+  /* enable beacon filtering */
+  WARN_ON(iwl_mvm_enable_beacon_filter(mvm, vif, 0));
   ret = 0;
  } else if (old_state == IEEE80211_STA_AUTHORIZED &&
      new_state == IEEE80211_STA_ASSOC) {
+  /* disable beacon filtering */
+  WARN_ON(iwl_mvm_disable_beacon_filter(mvm, vif, 0));
   ret = 0;
  } else if (old_state == IEEE80211_STA_ASSOC &&
      new_state == IEEE80211_STA_AUTH) {
@@ -1015,6 +1771,17 @@ static int iwl_mvm_mac_set_rts_threshold(struct ieee80211_hw *hw, u32 value)
  return 0;
 }
 
+static void iwl_mvm_sta_rc_update(struct ieee80211_hw *hw,
+      struct ieee80211_vif *vif,
+      struct ieee80211_sta *sta, u32 changed)
+{
+ struct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);
+
+ if (vif->type == NL80211_IFTYPE_STATION &&
+     changed & IEEE80211_RC_NSS_CHANGED)
+  iwl_mvm_sf_update(mvm, vif, false);
+}
+
 static int iwl_mvm_mac_conf_tx(struct ieee80211_hw *hw,
           struct ieee80211_vif *vif, u16 ac,
           const struct ieee80211_tx_queue_params *params)
@@ -1032,7 +1799,7 @@ static int iwl_mvm_mac_conf_tx(struct ieee80211_hw *hw,
   int ret;
 
   mutex_lock(&mvm->mutex);
-  ret = iwl_mvm_mac_ctxt_changed(mvm, vif);
+  ret = iwl_mvm_mac_ctxt_changed(mvm, vif, false);
   mutex_unlock(&mvm->mutex);
   return ret;
  }
@@ -1053,8 +1820,83 @@ static void iwl_mvm_mac_mgd_prepare_tx(struct ieee80211_hw *hw,
 
  mutex_lock(&mvm->mutex);
  /* Try really hard to protect the session and hear a beacon */
- iwl_mvm_protect_session(mvm, vif, duration, min_duration);
+ iwl_mvm_protect_session(mvm, vif, duration, min_duration, 500);
+ mutex_unlock(&mvm->mutex);
+}
+
+static int iwl_mvm_mac_sched_scan_start(struct ieee80211_hw *hw,
+     struct ieee80211_vif *vif,
+     struct cfg80211_sched_scan_request *req,
+     struct ieee80211_sched_scan_ies *ies)
+{
+ struct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);
+ int ret;
+
+ mutex_lock(&mvm->mutex);
+
+ if (!iwl_mvm_is_idle(mvm)) {
+  ret = -EBUSY;
+  goto out;
+ }
+
+ switch (mvm->scan_status) {
+ case IWL_MVM_SCAN_OS:
+  IWL_DEBUG_SCAN(mvm, "Stopping previous scan for sched_scan\n");
+  ret = iwl_mvm_cancel_scan(mvm);
+  if (ret) {
+   ret = -EBUSY;
+   goto out;
+  }
+
+  /*
+   * iwl_mvm_rx_scan_complete() will be called soon but will
+   * not reset the scan status as it won't be IWL_MVM_SCAN_OS
+   * any more since we queue the next scan immediately (below).
+   * We make sure it is called before the next scan starts by
+   * flushing the async-handlers work.
+   */
+  break;
+ case IWL_MVM_SCAN_NONE:
+  break;
+ default:
+  ret = -EBUSY;
+  goto out;
+ }
+
+ mvm->scan_status = IWL_MVM_SCAN_SCHED;
+
+ ret = iwl_mvm_config_sched_scan(mvm, vif, req, ies);
+ if (ret)
+  goto err;
+
+ ret = iwl_mvm_config_sched_scan_profiles(mvm, req);
+ if (ret)
+  goto err;
+
+ ret = iwl_mvm_sched_scan_start(mvm, req);
+ if (!ret)
+  goto out;
+err:
+ mvm->scan_status = IWL_MVM_SCAN_NONE;
+out:
  mutex_unlock(&mvm->mutex);
+ /* make sure to flush the Rx handler before the next scan arrives */
+ iwl_mvm_wait_for_async_handlers(mvm);
+ return ret;
+}
+
+static int iwl_mvm_mac_sched_scan_stop(struct ieee80211_hw *hw,
+           struct ieee80211_vif *vif)
+{
+ struct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);
+ int ret;
+
+ mutex_lock(&mvm->mutex);
+ ret = iwl_mvm_sched_scan_stop(mvm, false);
+ mutex_unlock(&mvm->mutex);
+ iwl_mvm_wait_for_async_handlers(mvm);
+
+ return ret;
 }
 
 static int iwl_mvm_mac_set_key(struct ieee80211_hw *hw,
@@ -1090,15 +1932,25 @@ static int iwl_mvm_mac_set_key(struct ieee80211_hw *hw,
    */
   return 0;
  default:
-  return -EOPNOTSUPP;
+  /* currently FW supports only one optional cipher scheme */
+  if (hw->n_cipher_schemes &&
+      hw->cipher_schemes->cipher == key->cipher)
+   key->flags |= IEEE80211_KEY_FLAG_PUT_IV_SPACE;
+  else
+   return -EOPNOTSUPP;
  }
 
  mutex_lock(&mvm->mutex);
 
  switch (cmd) {
  case SET_KEY:
-  if (vif->type == NL80211_IFTYPE_AP && !sta) {
-   /* GTK on AP interface is a TX-only key, return 0 */
+  if ((vif->type == NL80211_IFTYPE_ADHOC ||
+       vif->type == NL80211_IFTYPE_AP) && !sta) {
+   /*
+    * GTK on AP interface is a TX-only key, return 0;
+    * on IBSS they're per-station and because we're lazy
+    * we don't support them for RX, so do the same.
+    */
    ret = 0;
    key->hw_key_idx = STA_KEY_IDX_INVALID;
    break;
@@ -1142,6 +1994,9 @@ static void iwl_mvm_mac_update_tkip_key(struct ieee80211_hw *hw,
 {
  struct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);
 
+ if (keyconf->hw_key_idx == STA_KEY_IDX_INVALID)
+  return;
+
  iwl_mvm_update_tkip_key(mvm, vif, keyconf, sta, iv32, phase1key);
 }
 
@@ -1153,29 +2008,107 @@ static int iwl_mvm_roc(struct ieee80211_hw *hw,
          enum ieee80211_roc_type type)
 {
  struct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);
+ struct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);
  struct cfg80211_chan_def chandef;
- int ret;
+ struct iwl_mvm_phy_ctxt *phy_ctxt;
+ int ret, i;
+
+ IWL_DEBUG_MAC80211(mvm, "enter (%d, %d, %d)\n", channel->hw_value,
+      duration, type);
 
  if (vif->type != NL80211_IFTYPE_P2P_DEVICE) {
   IWL_ERR(mvm, "vif isn't a P2P_DEVICE: %d\n", vif->type);
   return -EINVAL;
  }
 
- IWL_DEBUG_MAC80211(mvm, "enter (%d, %d, %d)\n", channel->hw_value,
-      duration, type);
-
  mutex_lock(&mvm->mutex);
 
+ for (i = 0; i < NUM_PHY_CTX; i++) {
+  phy_ctxt = &mvm->phy_ctxts[i];
+  if (phy_ctxt->ref == 0 || mvmvif->phy_ctxt == phy_ctxt)
+   continue;
+
+  if (phy_ctxt->ref && channel == phy_ctxt->channel) {
+   /*
+    * Unbind the P2P_DEVICE from the current PHY context,
+    * and if the PHY context is not used remove it.
+    */
+   ret = iwl_mvm_binding_remove_vif(mvm, vif);
+   if (WARN(ret, "Failed unbinding P2P_DEVICE\n"))
+    goto out_unlock;
+
+   iwl_mvm_phy_ctxt_unref(mvm, mvmvif->phy_ctxt);
+
+   /* Bind the P2P_DEVICE to the current PHY Context */
+   mvmvif->phy_ctxt = phy_ctxt;
+
+   ret = iwl_mvm_binding_add_vif(mvm, vif);
+   if (WARN(ret, "Failed binding P2P_DEVICE\n"))
+    goto out_unlock;
+
+   iwl_mvm_phy_ctxt_ref(mvm, mvmvif->phy_ctxt);
+   goto schedule_time_event;
+  }
+ }
+
+ /* Need to update the PHY context only if the ROC channel changed */
+ if (channel == mvmvif->phy_ctxt->channel)
+  goto schedule_time_event;
+
  cfg80211_chandef_create(&chandef, channel, NL80211_CHAN_NO_HT);
- ret = iwl_mvm_phy_ctxt_changed(mvm, &mvm->phy_ctxt_roc,
-           &chandef, 1, 1);
 
+ /*
+  * Change the PHY context configuration as it is currently referenced
+  * only by the P2P Device MAC
+  */
+ if (mvmvif->phy_ctxt->ref == 1) {
+  ret = iwl_mvm_phy_ctxt_changed(mvm, mvmvif->phy_ctxt,
+            &chandef, 1, 1);
+  if (ret)
+   goto out_unlock;
+ } else {
+  /*
+   * The PHY context is shared with other MACs. Need to remove the
+   * P2P Device from the binding, allocate an new PHY context and
+   * create a new binding
+   */
+  phy_ctxt = iwl_mvm_get_free_phy_ctxt(mvm);
+  if (!phy_ctxt) {
+   ret = -ENOSPC;
+   goto out_unlock;
+  }
+
+  ret = iwl_mvm_phy_ctxt_changed(mvm, phy_ctxt, &chandef,
+            1, 1);
+  if (ret) {
+   IWL_ERR(mvm, "Failed to change PHY context\n");
+   goto out_unlock;
+  }
+
+  /* Unbind the P2P_DEVICE from the current PHY context */
+  ret = iwl_mvm_binding_remove_vif(mvm, vif);
+  if (WARN(ret, "Failed unbinding P2P_DEVICE\n"))
+   goto out_unlock;
+
+  iwl_mvm_phy_ctxt_unref(mvm, mvmvif->phy_ctxt);
+
+  /* Bind the P2P_DEVICE to the new allocated PHY context */
+  mvmvif->phy_ctxt = phy_ctxt;
+
+  ret = iwl_mvm_binding_add_vif(mvm, vif);
+  if (WARN(ret, "Failed binding P2P_DEVICE\n"))
+   goto out_unlock;
+
+  iwl_mvm_phy_ctxt_ref(mvm, mvmvif->phy_ctxt);
+ }
+
+schedule_time_event:
  /* Schedule the time events */
  ret = iwl_mvm_start_p2p_roc(mvm, vif, duration, type);
 
+out_unlock:
  mutex_unlock(&mvm->mutex);
  IWL_DEBUG_MAC80211(mvm, "leave\n");
-
  return ret;
 }
 
@@ -1197,15 +2130,30 @@ static int iwl_mvm_add_chanctx(struct ieee80211_hw *hw,
           struct ieee80211_chanctx_conf *ctx)
 {
  struct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);
- struct iwl_mvm_phy_ctxt *phy_ctxt = (void *)ctx->drv_priv;
+ u16 *phy_ctxt_id = (u16 *)ctx->drv_priv;
+ struct iwl_mvm_phy_ctxt *phy_ctxt;
  int ret;
 
+ IWL_DEBUG_MAC80211(mvm, "Add channel context\n");
+
  mutex_lock(&mvm->mutex);
+ phy_ctxt = iwl_mvm_get_free_phy_ctxt(mvm);
+ if (!phy_ctxt) {
+  ret = -ENOSPC;
+  goto out;
+ }
+
+ ret = iwl_mvm_phy_ctxt_changed(mvm, phy_ctxt, &ctx->min_def,
+           ctx->rx_chains_static,
+           ctx->rx_chains_dynamic);
+ if (ret) {
+  IWL_ERR(mvm, "Failed to add PHY context\n");
+  goto out;
+ }
 
- IWL_DEBUG_MAC80211(mvm, "Add PHY context\n");
- ret = iwl_mvm_phy_ctxt_add(mvm, phy_ctxt, &ctx->def,
-       ctx->rx_chains_static,
-       ctx->rx_chains_dynamic);
+ iwl_mvm_phy_ctxt_ref(mvm, phy_ctxt);
+ *phy_ctxt_id = phy_ctxt->id;
+out:
  mutex_unlock(&mvm->mutex);
  return ret;
 }
@@ -1214,10 +2162,11 @@ static void iwl_mvm_remove_chanctx(struct ieee80211_hw *hw,
        struct ieee80211_chanctx_conf *ctx)
 {
  struct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);
- struct iwl_mvm_phy_ctxt *phy_ctxt = (void *)ctx->drv_priv;
+ u16 *phy_ctxt_id = (u16 *)ctx->drv_priv;
+ struct iwl_mvm_phy_ctxt *phy_ctxt = &mvm->phy_ctxts[*phy_ctxt_id];
 
  mutex_lock(&mvm->mutex);
- iwl_mvm_phy_ctxt_remove(mvm, phy_ctxt);
+ iwl_mvm_phy_ctxt_unref(mvm, phy_ctxt);
  mutex_unlock(&mvm->mutex);
 }
 
@@ -1226,10 +2175,21 @@ static void iwl_mvm_change_chanctx(struct ieee80211_hw *hw,
        u32 changed)
 {
  struct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);
- struct iwl_mvm_phy_ctxt *phy_ctxt = (void *)ctx->drv_priv;
+ u16 *phy_ctxt_id = (u16 *)ctx->drv_priv;
+ struct iwl_mvm_phy_ctxt *phy_ctxt = &mvm->phy_ctxts[*phy_ctxt_id];
+
+ if (WARN_ONCE((phy_ctxt->ref > 1) &&
+        (changed & ~(IEEE80211_CHANCTX_CHANGE_WIDTH |
+       IEEE80211_CHANCTX_CHANGE_RX_CHAINS |
+       IEEE80211_CHANCTX_CHANGE_RADAR |
+       IEEE80211_CHANCTX_CHANGE_MIN_WIDTH)),
+        "Cannot change PHY. Ref=%d, changed=0x%X\n",
+        phy_ctxt->ref, changed))
+  return;
 
  mutex_lock(&mvm->mutex);
- iwl_mvm_phy_ctxt_changed(mvm, phy_ctxt, &ctx->def,
+ iwl_mvm_bt_coex_vif_change(mvm);
+ iwl_mvm_phy_ctxt_changed(mvm, phy_ctxt, &ctx->min_def,
      ctx->rx_chains_static,
      ctx->rx_chains_dynamic);
  mutex_unlock(&mvm->mutex);
@@ -1240,24 +2200,30 @@ static int iwl_mvm_assign_vif_chanctx(struct ieee80211_hw *hw,
           struct ieee80211_chanctx_conf *ctx)
 {
  struct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);
- struct iwl_mvm_phy_ctxt *phyctx = (void *)ctx->drv_priv;
+ u16 *phy_ctxt_id = (u16 *)ctx->drv_priv;
+ struct iwl_mvm_phy_ctxt *phy_ctxt = &mvm->phy_ctxts[*phy_ctxt_id];
  struct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);
  int ret;
 
  mutex_lock(&mvm->mutex);
 
- mvmvif->phy_ctxt = phyctx;
+ mvmvif->phy_ctxt = phy_ctxt;
 
  switch (vif->type) {
  case NL80211_IFTYPE_AP:
+  /* Unless it's a CSA flow we have nothing to do here */
+  if (vif->csa_active) {
+   mvmvif->ap_ibss_active = true;
+   break;
+  }
+ case NL80211_IFTYPE_ADHOC:
   /*
    * The AP binding flow is handled as part of the start_ap flow
-   * (in bss_info_changed).
+   * (in bss_info_changed), similarly for IBSS.
    */
   ret = 0;
   goto out_unlock;
  case NL80211_IFTYPE_STATION:
- case NL80211_IFTYPE_ADHOC:
  case NL80211_IFTYPE_MONITOR:
   break;
  default:
@@ -1270,7 +2236,12 @@ static int iwl_mvm_assign_vif_chanctx(struct ieee80211_hw *hw,
   goto out_unlock;
 
  /*
-  * Setting the quota at this stage is only required for monitor
+  * Power state must be updated before quotas,
+  * otherwise fw will complain.
+  */
+ iwl_mvm_power_update_mac(mvm);
+
+ /* Setting the quota at this stage is only required for monitor
   * interfaces. For the other types, the bss_info changed flow
   * will handle quota settings.
   */
@@ -1281,10 +2252,17 @@ static int iwl_mvm_assign_vif_chanctx(struct ieee80211_hw *hw,
    goto out_remove_binding;
  }
 
+ /* Handle binding during CSA */
+ if (vif->type == NL80211_IFTYPE_AP) {
+  iwl_mvm_update_quotas(mvm, vif);
+  iwl_mvm_mac_ctxt_changed(mvm, vif, false);
+ }
+
  goto out_unlock;
 
  out_remove_binding:
  iwl_mvm_binding_remove_vif(mvm, vif);
+ iwl_mvm_power_update_mac(mvm);
  out_unlock:
  mutex_unlock(&mvm->mutex);
  if (ret)
@@ -1303,21 +2281,30 @@ static void iwl_mvm_unassign_vif_chanctx(struct ieee80211_hw *hw,
 
  iwl_mvm_remove_time_event(mvm, mvmvif, &mvmvif->time_event_data);
 
- if (vif->type == NL80211_IFTYPE_AP)
-  goto out_unlock;
-
  switch (vif->type) {
+ case NL80211_IFTYPE_ADHOC:
+  goto out_unlock;
  case NL80211_IFTYPE_MONITOR:
   mvmvif->monitor_active = false;
   iwl_mvm_update_quotas(mvm, NULL);
   break;
+ case NL80211_IFTYPE_AP:
+  /* This part is triggered only during CSA */
+  if (!vif->csa_active || !mvmvif->ap_ibss_active)
+   goto out_unlock;
+
+  mvmvif->ap_ibss_active = false;
+  iwl_mvm_update_quotas(mvm, NULL);
+  /*TODO: bt_coex notification here? */
  default:
   break;
  }
 
  iwl_mvm_binding_remove_vif(mvm, vif);
+
 out_unlock:
  mvmvif->phy_ctxt = NULL;
+ iwl_mvm_power_update_mac(mvm);
  mutex_unlock(&mvm->mutex);
 }
 
@@ -1336,16 +2323,121 @@ static int iwl_mvm_set_tim(struct ieee80211_hw *hw,
  return iwl_mvm_mac_ctxt_beacon_changed(mvm, mvm_sta->vif);
 }
 
-static void iwl_mvm_mac_rssi_callback(struct ieee80211_hw *hw,
+#ifdef CONFIG_NL80211_TESTMODE
+static const struct nla_policy iwl_mvm_tm_policy[IWL_MVM_TM_ATTR_MAX + 1] = {
+ [IWL_MVM_TM_ATTR_CMD] = { .type = NLA_U32 },
+ [IWL_MVM_TM_ATTR_NOA_DURATION] = { .type = NLA_U32 },
+ [IWL_MVM_TM_ATTR_BEACON_FILTER_STATE] = { .type = NLA_U32 },
+};
+
+static int __iwl_mvm_mac_testmode_cmd(struct iwl_mvm *mvm,
           struct ieee80211_vif *vif,
-          enum ieee80211_rssi_event rssi_event)
+          void *data, int len)
+{
+ struct nlattr *tb[IWL_MVM_TM_ATTR_MAX + 1];
+ int err;
+ u32 noa_duration;
+
+ err = nla_parse(tb, IWL_MVM_TM_ATTR_MAX, data, len, iwl_mvm_tm_policy);
+ if (err)
+  return err;
+
+ if (!tb[IWL_MVM_TM_ATTR_CMD])
+  return -EINVAL;
+
+ switch (nla_get_u32(tb[IWL_MVM_TM_ATTR_CMD])) {
+ case IWL_MVM_TM_CMD_SET_NOA:
+  if (!vif || vif->type != NL80211_IFTYPE_AP || !vif->p2p ||
+      !vif->bss_conf.enable_beacon ||
+      !tb[IWL_MVM_TM_ATTR_NOA_DURATION])
+   return -EINVAL;
+
+  noa_duration = nla_get_u32(tb[IWL_MVM_TM_ATTR_NOA_DURATION]);
+  if (noa_duration >= vif->bss_conf.beacon_int)
+   return -EINVAL;
+
+  mvm->noa_duration = noa_duration;
+  mvm->noa_vif = vif;
+
+  return iwl_mvm_update_quotas(mvm, NULL);
+ case IWL_MVM_TM_CMD_SET_BEACON_FILTER:
+  /* must be associated client vif - ignore authorized */
+  if (!vif || vif->type != NL80211_IFTYPE_STATION ||
+      !vif->bss_conf.assoc || !vif->bss_conf.dtim_period ||
+      !tb[IWL_MVM_TM_ATTR_BEACON_FILTER_STATE])
+   return -EINVAL;
+
+  if (nla_get_u32(tb[IWL_MVM_TM_ATTR_BEACON_FILTER_STATE]))
+   return iwl_mvm_enable_beacon_filter(mvm, vif, 0);
+  return iwl_mvm_disable_beacon_filter(mvm, vif, 0);
+ }
+
+ return -EOPNOTSUPP;
+}
+
+static int iwl_mvm_mac_testmode_cmd(struct ieee80211_hw *hw,
+        struct ieee80211_vif *vif,
+        void *data, int len)
+{
+ struct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);
+ int err;
+
+ mutex_lock(&mvm->mutex);
+ err = __iwl_mvm_mac_testmode_cmd(mvm, vif, data, len);
+ mutex_unlock(&mvm->mutex);
+
+ return err;
+}
+#endif
+
+static void iwl_mvm_channel_switch_beacon(struct ieee80211_hw *hw,
+       struct ieee80211_vif *vif,
+       struct cfg80211_chan_def *chandef)
+{
+ struct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);
+
+ mutex_lock(&mvm->mutex);
+ if (WARN(mvm->csa_vif && mvm->csa_vif->csa_active,
+   "Another CSA is already in progress"))
+  goto out_unlock;
+
+ IWL_DEBUG_MAC80211(mvm, "CSA started to freq %d\n",
+      chandef->center_freq1);
+ mvm->csa_vif = vif;
+
+out_unlock:
+ mutex_unlock(&mvm->mutex);
+}
+
+static void iwl_mvm_mac_flush(struct ieee80211_hw *hw,
+         struct ieee80211_vif *vif, u32 queues, bool drop)
 {
  struct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);
+ struct iwl_mvm_vif *mvmvif;
+ struct iwl_mvm_sta *mvmsta;
+
+ if (!vif || vif->type != NL80211_IFTYPE_STATION)
+  return;
+
+ mutex_lock(&mvm->mutex);
+ mvmvif = iwl_mvm_vif_from_mac80211(vif);
+ mvmsta = iwl_mvm_sta_from_staid_protected(mvm, mvmvif->ap_sta_id);
 
- iwl_mvm_bt_rssi_event(mvm, vif, rssi_event);
+ if (WARN_ON_ONCE(!mvmsta))
+  goto done;
+
+ if (drop) {
+  if (iwl_mvm_flush_tx_path(mvm, mvmsta->tfd_queue_msk, true))
+   IWL_ERR(mvm, "flush request fail\n");
+ } else {
+  iwl_trans_wait_tx_queue_empty(mvm->trans,
+           mvmsta->tfd_queue_msk);
+ }
+done:
+ mutex_unlock(&mvm->mutex);
 }
 
-struct ieee80211_ops iwl_mvm_hw_ops = {
+const struct ieee80211_ops iwl_mvm_hw_ops = {
  .tx = iwl_mvm_mac_tx,
  .ampdu_action = iwl_mvm_mac_ampdu_action,
  .start = iwl_mvm_mac_start,
@@ -1354,33 +2446,44 @@ struct ieee80211_ops iwl_mvm_hw_ops = {
  .add_interface = iwl_mvm_mac_add_interface,
  .remove_interface = iwl_mvm_mac_remove_interface,
  .config = iwl_mvm_mac_config,
+ .prepare_multicast = iwl_mvm_prepare_multicast,
  .configure_filter = iwl_mvm_configure_filter,
  .bss_info_changed = iwl_mvm_bss_info_changed,
  .hw_scan = iwl_mvm_mac_hw_scan,
  .cancel_hw_scan = iwl_mvm_mac_cancel_hw_scan,
+ .sta_pre_rcu_remove = iwl_mvm_sta_pre_rcu_remove,
  .sta_state = iwl_mvm_mac_sta_state,
  .sta_notify = iwl_mvm_mac_sta_notify,
  .allow_buffered_frames = iwl_mvm_mac_allow_buffered_frames,
+ .release_buffered_frames = iwl_mvm_mac_release_buffered_frames,
  .set_rts_threshold = iwl_mvm_mac_set_rts_threshold,
+ .sta_rc_update = iwl_mvm_sta_rc_update,
  .conf_tx = iwl_mvm_mac_conf_tx,
  .mgd_prepare_tx = iwl_mvm_mac_mgd_prepare_tx,
+ .flush = iwl_mvm_mac_flush,
+ .sched_scan_start = iwl_mvm_mac_sched_scan_start,
+ .sched_scan_stop = iwl_mvm_mac_sched_scan_stop,
  .set_key = iwl_mvm_mac_set_key,
  .update_tkip_key = iwl_mvm_mac_update_tkip_key,
  .remain_on_channel = iwl_mvm_roc,
  .cancel_remain_on_channel = iwl_mvm_cancel_roc,
- .rssi_callback = iwl_mvm_mac_rssi_callback,
-
  .add_chanctx = iwl_mvm_add_chanctx,
  .remove_chanctx = iwl_mvm_remove_chanctx,
  .change_chanctx = iwl_mvm_change_chanctx,
  .assign_vif_chanctx = iwl_mvm_assign_vif_chanctx,
  .unassign_vif_chanctx = iwl_mvm_unassign_vif_chanctx,
 
- .start_ap = iwl_mvm_start_ap,
- .stop_ap = iwl_mvm_stop_ap,
+ .start_ap = iwl_mvm_start_ap_ibss,
+ .stop_ap = iwl_mvm_stop_ap_ibss,
+ .join_ibss = iwl_mvm_start_ap_ibss,
+ .leave_ibss = iwl_mvm_stop_ap_ibss,
 
  .set_tim = iwl_mvm_set_tim,
 
+ .channel_switch_beacon = iwl_mvm_channel_switch_beacon,
+
+ CFG80211_TESTMODE_CMD(iwl_mvm_mac_testmode_cmd)
+
 #ifdef CONFIG_PM_SLEEP
  /* look at d3.c */
  .suspend = iwl_mvm_suspend,
diff --git a/drivers/net/wireless/iwlwifi/mvm/mvm.h b/drivers/net/wireless/iwlwifi/mvm/mvm.h
index 8086231..fcc6c29 100644
--- a/drivers/net/wireless/iwlwifi/mvm/mvm.h
+++ b/drivers/net/wireless/iwlwifi/mvm/mvm.h
@@ -5,7 +5,7 @@
  *
  * GPL LICENSE SUMMARY
  *
- * Copyright(c) 2012 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2012 - 2014 Intel Corporation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of version 2 of the GNU General Public License as
@@ -30,7 +30,7 @@
  *
  * BSD LICENSE
  *
- * Copyright(c) 2012 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2012 - 2014 Intel Corporation. All rights reserved.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -73,15 +73,15 @@
 #include "iwl-trans.h"
 #include "iwl-notif-wait.h"
 #include "iwl-eeprom-parse.h"
-#include "iwl-test.h"
-#include "iwl-trans.h"
 #include "sta.h"
 #include "fw-api.h"
+#include "constants.h"
 
 #define IWL_INVALID_MAC80211_QUEUE 0xff
 #define IWL_MVM_MAX_ADDRESSES  5
 /* RSSI offset for WkP */
 #define IWL_RSSI_OFFSET 50
+#define IWL_MVM_MISSED_BEACONS_THRESHOLD 8
 
 enum iwl_mvm_tx_fifo {
  IWL_MVM_TX_FIFO_BK = 0,
@@ -91,7 +91,8 @@ enum iwl_mvm_tx_fifo {
  IWL_MVM_TX_FIFO_MCAST = 5,
 };
 
-extern struct ieee80211_ops iwl_mvm_hw_ops;
+extern const struct ieee80211_ops iwl_mvm_hw_ops;
+
 /**
  * struct iwl_mvm_mod_params - module parameters for iwlmvm
  * @init_dbg: if true, then the NIC won't be stopped if the INIT fw asserted.
@@ -110,6 +111,7 @@ extern struct iwl_mvm_mod_params iwlmvm_mod_params;
 struct iwl_mvm_phy_ctxt {
  u16 id;
  u16 color;
+ u32 ref;
 
  /*
   * TODO: This should probably be removed. Currently here only for rate
@@ -148,7 +150,111 @@ enum iwl_power_scheme {
  IWL_POWER_SCHEME_LP
 };
 
-#define IWL_CONN_MAX_LISTEN_INTERVAL 70
+#define IWL_CONN_MAX_LISTEN_INTERVAL 10
+#define IWL_UAPSD_AC_INFO  (IEEE80211_WMM_IE_STA_QOSINFO_AC_VO |\
+      IEEE80211_WMM_IE_STA_QOSINFO_AC_VI |\
+      IEEE80211_WMM_IE_STA_QOSINFO_AC_BK |\
+      IEEE80211_WMM_IE_STA_QOSINFO_AC_BE)
+#define IWL_UAPSD_MAX_SP  IEEE80211_WMM_IE_STA_QOSINFO_SP_2
+
+#ifdef CONFIG_IWLWIFI_DEBUGFS
+enum iwl_dbgfs_pm_mask {
+ MVM_DEBUGFS_PM_KEEP_ALIVE = BIT(0),
+ MVM_DEBUGFS_PM_SKIP_OVER_DTIM = BIT(1),
+ MVM_DEBUGFS_PM_SKIP_DTIM_PERIODS = BIT(2),
+ MVM_DEBUGFS_PM_RX_DATA_TIMEOUT = BIT(3),
+ MVM_DEBUGFS_PM_TX_DATA_TIMEOUT = BIT(4),
+ MVM_DEBUGFS_PM_LPRX_ENA = BIT(6),
+ MVM_DEBUGFS_PM_LPRX_RSSI_THRESHOLD = BIT(7),
+ MVM_DEBUGFS_PM_SNOOZE_ENABLE = BIT(8),
+ MVM_DEBUGFS_PM_UAPSD_MISBEHAVING = BIT(9),
+};
+
+struct iwl_dbgfs_pm {
+ u16 keep_alive_seconds;
+ u32 rx_data_timeout;
+ u32 tx_data_timeout;
+ bool skip_over_dtim;
+ u8 skip_dtim_periods;
+ bool lprx_ena;
+ u32 lprx_rssi_threshold;
+ bool snooze_ena;
+ bool uapsd_misbehaving;
+ int mask;
+};
+
+/* beacon filtering */
+
+enum iwl_dbgfs_bf_mask {
+ MVM_DEBUGFS_BF_ENERGY_DELTA = BIT(0),
+ MVM_DEBUGFS_BF_ROAMING_ENERGY_DELTA = BIT(1),
+ MVM_DEBUGFS_BF_ROAMING_STATE = BIT(2),
+ MVM_DEBUGFS_BF_TEMP_THRESHOLD = BIT(3),
+ MVM_DEBUGFS_BF_TEMP_FAST_FILTER = BIT(4),
+ MVM_DEBUGFS_BF_TEMP_SLOW_FILTER = BIT(5),
+ MVM_DEBUGFS_BF_ENABLE_BEACON_FILTER = BIT(6),
+ MVM_DEBUGFS_BF_DEBUG_FLAG = BIT(7),
+ MVM_DEBUGFS_BF_ESCAPE_TIMER = BIT(8),
+ MVM_DEBUGFS_BA_ESCAPE_TIMER = BIT(9),
+ MVM_DEBUGFS_BA_ENABLE_BEACON_ABORT = BIT(10),
+};
+
+struct iwl_dbgfs_bf {
+ u32 bf_energy_delta;
+ u32 bf_roaming_energy_delta;
+ u32 bf_roaming_state;
+ u32 bf_temp_threshold;
+ u32 bf_temp_fast_filter;
+ u32 bf_temp_slow_filter;
+ u32 bf_enable_beacon_filter;
+ u32 bf_debug_flag;
+ u32 bf_escape_timer;
+ u32 ba_escape_timer;
+ u32 ba_enable_beacon_abort;
+ int mask;
+};
+#endif
+
+enum iwl_mvm_smps_type_request {
+ IWL_MVM_SMPS_REQ_BT_COEX,
+ IWL_MVM_SMPS_REQ_TT,
+ NUM_IWL_MVM_SMPS_REQ,
+};
+
+enum iwl_mvm_ref_type {
+ IWL_MVM_REF_UCODE_DOWN,
+ IWL_MVM_REF_SCAN,
+ IWL_MVM_REF_ROC,
+ IWL_MVM_REF_P2P_CLIENT,
+ IWL_MVM_REF_AP_IBSS,
+ IWL_MVM_REF_USER,
+ IWL_MVM_REF_TX,
+ IWL_MVM_REF_TX_AGG,
+ IWL_MVM_REF_EXIT_WORK,
+
+ IWL_MVM_REF_COUNT,
+};
+
+/**
+* struct iwl_mvm_vif_bf_data - beacon filtering related data
+* @bf_enabled: indicates if beacon filtering is enabled
+* @ba_enabled: indicated if beacon abort is enabled
+* @last_beacon_signal: last beacon rssi signal in dbm
+* @ave_beacon_signal: average beacon signal
+* @last_cqm_event: rssi of the last cqm event
+* @bt_coex_min_thold: minimum threshold for BT coex
+* @bt_coex_max_thold: maximum threshold for BT coex
+* @last_bt_coex_event: rssi of the last BT coex event
+*/
+struct iwl_mvm_vif_bf_data {
+ bool bf_enabled;
+ bool ba_enabled;
+ s8 ave_beacon_signal;
+ s8 last_cqm_event;
+ s8 bt_coex_min_thold;
+ s8 bt_coex_max_thold;
+ s8 last_bt_coex_event;
+};
 
 /**
  * struct iwl_mvm_vif - data per Virtual Interface, it is a MAC context
@@ -156,14 +262,19 @@ enum iwl_power_scheme {
  * @color: to solve races upon MAC addition and removal
  * @ap_sta_id: the sta_id of the AP - valid only if VIF type is STA
  * @uploaded: indicates the MAC context has been added to the device
- * @ap_active: indicates that ap context is configured, and that the interface
- *  should get quota etc.
+ * @ap_ibss_active: indicates that AP/IBSS is configured and that the interface
+ * should get quota etc.
+ * @pm_enabled - Indicate if MAC power management is allowed
  * @monitor_active: indicates that monitor context is configured, and that the
- * interface should get quota etc.
+ * interface should get quota etc.
+ * @low_latency: indicates that this interface is in low-latency mode
+ * (VMACLowLatencyMode)
  * @queue_params: QoS params for this MAC
  * @bcast_sta: station used for broadcast packets. Used by the following
  *  vifs: P2P_DEVICE, GO and AP.
  * @beacon_skb: the skb used to hold the AP/GO beacon template
+ * @smps_requests: the SMPS requests of differents parts of the driver,
+ * combined on update to yield the overall request to mac80211.
  */
 struct iwl_mvm_vif {
  u16 id;
@@ -171,8 +282,11 @@ struct iwl_mvm_vif {
  u8 ap_sta_id;
 
  bool uploaded;
- bool ap_active;
+ bool ap_ibss_active;
+ bool pm_enabled;
  bool monitor_active;
+ bool low_latency;
+ struct iwl_mvm_vif_bf_data bf_data;
 
  u32 ap_beacon_time;
 
@@ -204,18 +318,29 @@ struct iwl_mvm_vif {
 
  int tx_key_idx;
 
+ bool seqno_valid;
+ u16 seqno;
+#endif
+
 #if IS_ENABLED(CONFIG_IPV6)
  /* IPv6 addresses for WoWLAN */
- struct in6_addr target_ipv6_addrs[IWL_PROTO_OFFLOAD_NUM_IPV6_ADDRS];
+ struct in6_addr target_ipv6_addrs[IWL_PROTO_OFFLOAD_NUM_IPV6_ADDRS_MAX];
  int num_target_ipv6_addrs;
 #endif
-#endif
 
 #ifdef CONFIG_IWLWIFI_DEBUGFS
+ struct iwl_mvm *mvm;
  struct dentry *dbgfs_dir;
  struct dentry *dbgfs_slink;
- void *dbgfs_data;
+ struct iwl_dbgfs_pm dbgfs_pm;
+ struct iwl_dbgfs_bf dbgfs_bf;
+ struct iwl_mac_power_cmd mac_pwr_cmd;
 #endif
+
+ enum ieee80211_smps_mode smps_requests[NUM_IWL_MVM_SMPS_REQ];
+
+ /* FW identified misbehaving AP */
+ u8 uapsd_misbehaving_bssid[ETH_ALEN];
 };
 
 static inline struct iwl_mvm_vif *
@@ -224,15 +349,12 @@ iwl_mvm_vif_from_mac80211(struct ieee80211_vif *vif)
  return (void *)vif->drv_priv;
 }
 
-enum iwl_mvm_status {
- IWL_MVM_STATUS_HW_RFKILL,
- IWL_MVM_STATUS_ROC_RUNNING,
- IWL_MVM_STATUS_IN_HW_RESTART,
-};
+extern const u8 tid_to_mac80211_ac[];
 
 enum iwl_scan_status {
  IWL_MVM_SCAN_NONE,
  IWL_MVM_SCAN_OS,
+ IWL_MVM_SCAN_SCHED,
 };
 
 /**
@@ -247,6 +369,94 @@ struct iwl_nvm_section {
  const u8 *data;
 };
 
+/*
+ * Tx-backoff threshold
+ * @temperature: The threshold in Celsius
+ * @backoff: The tx-backoff in uSec
+ */
+struct iwl_tt_tx_backoff {
+ s32 temperature;
+ u32 backoff;
+};
+
+#define TT_TX_BACKOFF_SIZE 6
+
+/**
+ * struct iwl_tt_params - thermal throttling parameters
+ * @ct_kill_entry: CT Kill entry threshold
+ * @ct_kill_exit: CT Kill exit threshold
+ * @ct_kill_duration: The time  intervals (in uSec) in which the driver needs
+ * to checks whether to exit CT Kill.
+ * @dynamic_smps_entry: Dynamic SMPS entry threshold
+ * @dynamic_smps_exit: Dynamic SMPS exit threshold
+ * @tx_protection_entry: TX protection entry threshold
+ * @tx_protection_exit: TX protection exit threshold
+ * @tx_backoff: Array of thresholds for tx-backoff , in ascending order.
+ * @support_ct_kill: Support CT Kill?
+ * @support_dynamic_smps: Support dynamic SMPS?
+ * @support_tx_protection: Support tx protection?
+ * @support_tx_backoff: Support tx-backoff?
+ */
+struct iwl_tt_params {
+ s32 ct_kill_entry;
+ s32 ct_kill_exit;
+ u32 ct_kill_duration;
+ s32 dynamic_smps_entry;
+ s32 dynamic_smps_exit;
+ s32 tx_protection_entry;
+ s32 tx_protection_exit;
+ struct iwl_tt_tx_backoff tx_backoff[TT_TX_BACKOFF_SIZE];
+ bool support_ct_kill;
+ bool support_dynamic_smps;
+ bool support_tx_protection;
+ bool support_tx_backoff;
+};
+
+/**
+ * struct iwl_mvm_tt_mgnt - Thermal Throttling Management structure
+ * @ct_kill_exit: worker to exit thermal kill
+ * @dynamic_smps: Is thermal throttling enabled dynamic_smps?
+ * @tx_backoff: The current thremal throttling tx backoff in uSec.
+ * @min_backoff: The minimal tx backoff due to power restrictions
+ * @params: Parameters to configure the thermal throttling algorithm.
+ * @throttle: Is thermal throttling is active?
+ */
+struct iwl_mvm_tt_mgmt {
+ struct delayed_work ct_kill_exit;
+ bool dynamic_smps;
+ u32 tx_backoff;
+ u32 min_backoff;
+ const struct iwl_tt_params *params;
+ bool throttle;
+};
+
+#define IWL_MVM_NUM_LAST_FRAMES_UCODE_RATES 8
+
+struct iwl_mvm_frame_stats {
+ u32 legacy_frames;
+ u32 ht_frames;
+ u32 vht_frames;
+ u32 bw_20_frames;
+ u32 bw_40_frames;
+ u32 bw_80_frames;
+ u32 bw_160_frames;
+ u32 sgi_frames;
+ u32 ngi_frames;
+ u32 siso_frames;
+ u32 mimo2_frames;
+ u32 agg_frames;
+ u32 ampdu_count;
+ u32 success_frames;
+ u32 fail_frames;
+ u32 last_rates[IWL_MVM_NUM_LAST_FRAMES_UCODE_RATES];
+ int last_frame_idx;
+};
+
+enum {
+ D0I3_DEFER_WAKEUP,
+ D0I3_PENDING_WAKEUP,
+};
+
 struct iwl_mvm {
  /* for logger access */
  struct device *dev;
@@ -267,23 +477,35 @@ struct iwl_mvm {
 
  unsigned long status;
 
+ /*
+  * for beacon filtering -
+  * currently only one interface can be supported
+  */
+ struct iwl_mvm_vif *bf_allowed_vif;
+
  enum iwl_ucode_type cur_ucode;
  bool ucode_loaded;
- bool init_ucode_run;
+ bool init_ucode_complete;
  u32 error_event_table;
  u32 log_event_table;
+ u32 umac_error_event_table;
+ bool support_umac_log;
+ struct iwl_sf_region sf_space;
 
  u32 ampdu_ref;
 
  struct iwl_notif_wait_data notif_wait;
 
+ struct mvm_statistics_rx rx_stats;
+
  unsigned long transport_queue_stop;
  u8 queue_to_mac80211[IWL_MAX_HW_QUEUES];
  atomic_t queue_stop_count[IWL_MAX_HW_QUEUES];
 
+ const char *nvm_file_name;
  struct iwl_nvm_data *nvm_data;
  /* NVM sections */
- struct iwl_nvm_section nvm_sections[NVM_NUM_OF_SECTIONS];
+ struct iwl_nvm_section nvm_sections[NVM_MAX_NUM_SECTIONS];
 
  /* EEPROM MAC addresses */
  struct mac_address addresses[IWL_MVM_MAX_ADDRESSES];
@@ -294,6 +516,7 @@ struct iwl_mvm {
  struct work_struct sta_drained_wk;
  unsigned long sta_drained[BITS_TO_LONGS(IWL_MVM_STATION_COUNT)];
  atomic_t pending_frames[IWL_MVM_STATION_COUNT];
+ u8 rx_ba_sessions;
 
  /* configured by mac80211 */
  u32 rts_threshold;
@@ -301,20 +524,50 @@ struct iwl_mvm {
  /* Scan status, cmd (pre-allocated) and auxiliary station */
  enum iwl_scan_status scan_status;
  struct iwl_scan_cmd *scan_cmd;
+ struct iwl_mcast_filter_cmd *mcast_filter_cmd;
+
+ /* rx chain antennas set through debugfs for the scan command */
+ u8 scan_rx_ant;
+
+#ifdef CONFIG_IWLWIFI_BCAST_FILTERING
+ /* broadcast filters to configure for each associated station */
+ const struct iwl_fw_bcast_filter *bcast_filters;
+#ifdef CONFIG_IWLWIFI_DEBUGFS
+ struct {
+  u32 override; /* u32 for debugfs_create_bool */
+  struct iwl_bcast_filter_cmd cmd;
+ } dbgfs_bcast_filtering;
+#endif
+#endif
 
  /* Internal station */
  struct iwl_mvm_int_sta aux_sta;
 
+ bool last_ebs_successful;
+
  u8 scan_last_antenna_idx; /* to toggle TX between antennas */
  u8 mgmt_last_antenna_idx;
 
+ /* last smart fifo state that was successfully sent to firmware */
+ enum iwl_sf_state sf_state;
+
 #ifdef CONFIG_IWLWIFI_DEBUGFS
  struct dentry *debugfs_dir;
  u32 dbgfs_sram_offset, dbgfs_sram_len;
- bool prevent_power_down_d3;
+ u32 dbgfs_prph_reg_addr;
+ bool disable_power_off;
+ bool disable_power_off_d3;
+
+ struct debugfs_blob_wrapper nvm_hw_blob;
+ struct debugfs_blob_wrapper nvm_sw_blob;
+ struct debugfs_blob_wrapper nvm_calib_blob;
+ struct debugfs_blob_wrapper nvm_prod_blob;
+
+ struct iwl_mvm_frame_stats drv_rx_stats;
+ spinlock_t drv_stats_lock;
 #endif
 
- struct iwl_mvm_phy_ctxt phy_ctxt_roc;
+ struct iwl_mvm_phy_ctxt phy_ctxts[NUM_PHY_CTX];
 
  struct list_head time_event_list;
  spinlock_t time_event_lock;
@@ -325,25 +578,76 @@ struct iwl_mvm {
   */
  unsigned long fw_key_table[BITS_TO_LONGS(STA_KEY_MAX_NUM)];
 
- /*
-  * This counter of created interfaces is referenced only in conjunction
-  * with FW limitation related to power management. Currently PM is
-  * supported only on a single interface.
-  * IMPORTANT: this variable counts all interfaces except P2P device.
-  */
+ /* A bitmap of reference types taken by the driver. */
+ unsigned long ref_bitmap[BITS_TO_LONGS(IWL_MVM_REF_COUNT)];
+
  u8 vif_count;
 
+ /* -1 for always, 0 for never, >0 for that many times */
+ s8 restart_fw;
+ void *fw_error_dump;
+ void *fw_error_sram;
+ u32 fw_error_sram_len;
+ u32 *fw_error_rxf;
+ u32 fw_error_rxf_len;
+
+#ifdef CONFIG_IWLWIFI_LEDS
  struct led_classdev led;
+#endif
 
  struct ieee80211_vif *p2p_device_vif;
 
 #ifdef CONFIG_PM_SLEEP
+ struct wiphy_wowlan_support wowlan;
  int gtk_ivlen, gtk_icvlen, ptk_ivlen, ptk_icvlen;
+#ifdef CONFIG_IWLWIFI_DEBUGFS
+ u32 d3_wake_sysassert; /* must be u32 for debugfs_create_bool */
+ bool d3_test_active;
+ bool store_d3_resume_sram;
+ void *d3_resume_sram;
+ u32 d3_test_pme_ptr;
+ struct ieee80211_vif *keep_vif;
 #endif
+#endif
+
+ /* d0i3 */
+ u8 d0i3_ap_sta_id;
+ bool d0i3_offloading;
+ struct work_struct d0i3_exit_work;
+ struct sk_buff_head d0i3_tx;
+ /* protect d0i3_suspend_flags */
+ struct mutex d0i3_suspend_mutex;
+ unsigned long d0i3_suspend_flags;
+ /* sync d0i3_tx queue and IWL_MVM_STATUS_IN_D0I3 status flag */
+ spinlock_t d0i3_tx_lock;
+ wait_queue_head_t d0i3_exit_waitq;
 
  /* BT-Coex */
  u8 bt_kill_msk;
  struct iwl_bt_coex_profile_notif last_bt_notif;
+ struct iwl_bt_coex_ci_cmd last_bt_ci_cmd;
+ u32 last_ant_isol;
+ u8 last_corun_lut;
+ u8 bt_tx_prio;
+
+ /* Thermal Throttling and CTkill */
+ struct iwl_mvm_tt_mgmt thermal_throttle;
+ s32 temperature; /* Celsius */
+
+#ifdef CONFIG_NL80211_TESTMODE
+ u32 noa_duration;
+ struct ieee80211_vif *noa_vif;
+#endif
+
+ /* Tx queues */
+ u8 aux_queue;
+ u8 first_agg_queue;
+ u8 last_agg_queue;
+
+ /* Indicate if device power save is allowed */
+ bool ps_disabled;
+
+ struct ieee80211_vif *csa_vif;
 };
 
 /* Extract MVM priv from op_mode and _hw */
@@ -353,6 +657,44 @@ struct iwl_mvm {
 #define IWL_MAC80211_GET_MVM(_hw)   \
  IWL_OP_MODE_GET_MVM((struct iwl_op_mode *)((_hw)->priv))
 
+enum iwl_mvm_status {
+ IWL_MVM_STATUS_HW_RFKILL,
+ IWL_MVM_STATUS_HW_CTKILL,
+ IWL_MVM_STATUS_ROC_RUNNING,
+ IWL_MVM_STATUS_IN_HW_RESTART,
+ IWL_MVM_STATUS_IN_D0I3,
+};
+
+static inline bool iwl_mvm_is_radio_killed(struct iwl_mvm *mvm)
+{
+ return test_bit(IWL_MVM_STATUS_HW_RFKILL, &mvm->status) ||
+        test_bit(IWL_MVM_STATUS_HW_CTKILL, &mvm->status);
+}
+
+static inline struct iwl_mvm_sta *
+iwl_mvm_sta_from_staid_protected(struct iwl_mvm *mvm, u8 sta_id)
+{
+ struct ieee80211_sta *sta;
+
+ if (sta_id >= ARRAY_SIZE(mvm->fw_id_to_mac_id))
+  return NULL;
+
+ sta = rcu_dereference_protected(mvm->fw_id_to_mac_id[sta_id],
+     lockdep_is_held(&mvm->mutex));
+
+ /* This can happen if the station has been removed right now */
+ if (IS_ERR_OR_NULL(sta))
+  return NULL;
+
+ return iwl_mvm_sta_from_mac80211(sta);
+}
+
+static inline bool iwl_mvm_is_d0i3_supported(struct iwl_mvm *mvm)
+{
+ return mvm->trans->cfg->d0i3 &&
+        (mvm->fw->ucode_capa.capa[0] & IWL_UCODE_TLV_CAPA_D0I3_SUPPORT);
+}
+
 extern const u8 iwl_mvm_ac_to_tx_fifo[];
 
 struct iwl_rate_info {
@@ -372,8 +714,16 @@ int iwl_run_init_mvm_ucode(struct iwl_mvm *mvm, bool read_nvm);
 /* Utils */
 int iwl_mvm_legacy_rate_to_mac80211_idx(u32 rate_n_flags,
      enum ieee80211_band band);
+void iwl_mvm_hwrate_to_tx_rate(u32 rate_n_flags,
+          enum ieee80211_band band,
+          struct ieee80211_tx_rate *r);
 u8 iwl_mvm_mac80211_idx_to_hwrate(int rate_idx);
 void iwl_mvm_dump_nic_error_log(struct iwl_mvm *mvm);
+#ifdef CONFIG_IWLWIFI_DEBUGFS
+void iwl_mvm_fw_error_dump(struct iwl_mvm *mvm);
+void iwl_mvm_fw_error_sram_dump(struct iwl_mvm *mvm);
+void iwl_mvm_fw_error_rxf_dump(struct iwl_mvm *mvm);
+#endif
 u8 first_antenna(u8 mask);
 u8 iwl_mvm_next_antenna(struct iwl_mvm *mvm, u8 valid, u8 last_idx);
 
@@ -399,6 +749,11 @@ static inline const char *iwl_mvm_get_tx_fail_reason(u32 status) { return ""; }
 int iwl_mvm_flush_tx_path(struct iwl_mvm *mvm, u32 tfd_msk, bool sync);
 void iwl_mvm_async_handlers_purge(struct iwl_mvm *mvm);
 
+static inline void iwl_mvm_wait_for_async_handlers(struct iwl_mvm *mvm)
+{
+ flush_work(&mvm->async_handlers_wk);
+}
+
 /* Statistics */
 int iwl_mvm_rx_reply_statistics(struct iwl_mvm *mvm,
     struct iwl_rx_cmd_buffer *rxb,
@@ -408,12 +763,15 @@ int iwl_mvm_rx_statistics(struct iwl_mvm *mvm,
      struct iwl_device_cmd *cmd);
 
 /* NVM */
-int iwl_nvm_init(struct iwl_mvm *mvm);
+int iwl_nvm_init(struct iwl_mvm *mvm, bool read_nvm_from_nic);
+int iwl_mvm_load_nvm_to_nic(struct iwl_mvm *mvm);
 
 int iwl_mvm_up(struct iwl_mvm *mvm);
 int iwl_mvm_load_d3_fw(struct iwl_mvm *mvm);
 
 int iwl_mvm_mac_setup_register(struct iwl_mvm *mvm);
+bool iwl_mvm_bcast_filter_build_cmd(struct iwl_mvm *mvm,
+        struct iwl_bcast_filter_cmd *cmd);
 
 /*
  * FW notifications / CMD responses handlers
@@ -429,6 +787,9 @@ int iwl_mvm_rx_ba_notif(struct iwl_mvm *mvm, struct iwl_rx_cmd_buffer *rxb,
    struct iwl_device_cmd *cmd);
 int iwl_mvm_rx_radio_ver(struct iwl_mvm *mvm, struct iwl_rx_cmd_buffer *rxb,
     struct iwl_device_cmd *cmd);
+int iwl_mvm_rx_ant_coupling_notif(struct iwl_mvm *mvm,
+      struct iwl_rx_cmd_buffer *rxb,
+      struct iwl_device_cmd *cmd);
 int iwl_mvm_rx_fw_error(struct iwl_mvm *mvm, struct iwl_rx_cmd_buffer *rxb,
      struct iwl_device_cmd *cmd);
 int iwl_mvm_rx_card_state_notif(struct iwl_mvm *mvm,
@@ -444,14 +805,17 @@ int iwl_mvm_phy_ctxt_add(struct iwl_mvm *mvm, struct iwl_mvm_phy_ctxt *ctxt,
 int iwl_mvm_phy_ctxt_changed(struct iwl_mvm *mvm, struct iwl_mvm_phy_ctxt *ctxt,
         struct cfg80211_chan_def *chandef,
         u8 chains_static, u8 chains_dynamic);
-void iwl_mvm_phy_ctxt_remove(struct iwl_mvm *mvm,
-        struct iwl_mvm_phy_ctxt *ctxt);
+void iwl_mvm_phy_ctxt_ref(struct iwl_mvm *mvm,
+     struct iwl_mvm_phy_ctxt *ctxt);
+void iwl_mvm_phy_ctxt_unref(struct iwl_mvm *mvm,
+       struct iwl_mvm_phy_ctxt *ctxt);
 
 /* MAC (virtual interface) programming */
 int iwl_mvm_mac_ctxt_init(struct iwl_mvm *mvm, struct ieee80211_vif *vif);
 void iwl_mvm_mac_ctxt_release(struct iwl_mvm *mvm, struct ieee80211_vif *vif);
 int iwl_mvm_mac_ctxt_add(struct iwl_mvm *mvm, struct ieee80211_vif *vif);
-int iwl_mvm_mac_ctxt_changed(struct iwl_mvm *mvm, struct ieee80211_vif *vif);
+int iwl_mvm_mac_ctxt_changed(struct iwl_mvm *mvm, struct ieee80211_vif *vif,
+        bool force_assoc_off);
 int iwl_mvm_mac_ctxt_remove(struct iwl_mvm *mvm, struct ieee80211_vif *vif);
 u32 iwl_mvm_mac_get_queues_mask(struct iwl_mvm *mvm,
     struct ieee80211_vif *vif);
@@ -460,6 +824,11 @@ int iwl_mvm_mac_ctxt_beacon_changed(struct iwl_mvm *mvm,
 int iwl_mvm_rx_beacon_notif(struct iwl_mvm *mvm,
        struct iwl_rx_cmd_buffer *rxb,
        struct iwl_device_cmd *cmd);
+int iwl_mvm_rx_missed_beacons_notif(struct iwl_mvm *mvm,
+        struct iwl_rx_cmd_buffer *rxb,
+        struct iwl_device_cmd *cmd);
+void iwl_mvm_mac_ctxt_recalc_tsf_id(struct iwl_mvm *mvm,
+        struct ieee80211_vif *vif);
 
 /* Bindings */
 int iwl_mvm_binding_add_vif(struct iwl_mvm *mvm, struct ieee80211_vif *vif);
@@ -476,7 +845,24 @@ int iwl_mvm_rx_scan_response(struct iwl_mvm *mvm, struct iwl_rx_cmd_buffer *rxb,
         struct iwl_device_cmd *cmd);
 int iwl_mvm_rx_scan_complete(struct iwl_mvm *mvm, struct iwl_rx_cmd_buffer *rxb,
         struct iwl_device_cmd *cmd);
-void iwl_mvm_cancel_scan(struct iwl_mvm *mvm);
+int iwl_mvm_cancel_scan(struct iwl_mvm *mvm);
+
+/* Scheduled scan */
+int iwl_mvm_rx_scan_offload_complete_notif(struct iwl_mvm *mvm,
+        struct iwl_rx_cmd_buffer *rxb,
+        struct iwl_device_cmd *cmd);
+int iwl_mvm_config_sched_scan(struct iwl_mvm *mvm,
+         struct ieee80211_vif *vif,
+         struct cfg80211_sched_scan_request *req,
+         struct ieee80211_sched_scan_ies *ies);
+int iwl_mvm_config_sched_scan_profiles(struct iwl_mvm *mvm,
+           struct cfg80211_sched_scan_request *req);
+int iwl_mvm_sched_scan_start(struct iwl_mvm *mvm,
+        struct cfg80211_sched_scan_request *req);
+int iwl_mvm_sched_scan_stop(struct iwl_mvm *mvm, bool notify);
+int iwl_mvm_rx_sched_scan_results(struct iwl_mvm *mvm,
+      struct iwl_rx_cmd_buffer *rxb,
+      struct iwl_device_cmd *cmd);
 
 /* MVM debugfs */
 #ifdef CONFIG_IWLWIFI_DEBUGFS
@@ -500,17 +886,35 @@ iwl_mvm_vif_dbgfs_clean(struct iwl_mvm *mvm, struct ieee80211_vif *vif)
 #endif /* CONFIG_IWLWIFI_DEBUGFS */
 
 /* rate scaling */
-int iwl_mvm_send_lq_cmd(struct iwl_mvm *mvm, struct iwl_lq_cmd *lq,
-   u8 flags, bool init);
-
-/* power managment */
-int iwl_mvm_power_update_mode(struct iwl_mvm *mvm, struct ieee80211_vif *vif);
-int iwl_mvm_power_disable(struct iwl_mvm *mvm, struct ieee80211_vif *vif);
-void iwl_mvm_power_build_cmd(struct iwl_mvm *mvm, struct ieee80211_vif *vif,
-        struct iwl_powertable_cmd *cmd);
-
+int iwl_mvm_send_lq_cmd(struct iwl_mvm *mvm, struct iwl_lq_cmd *lq, bool init);
+void iwl_mvm_update_frame_stats(struct iwl_mvm *mvm,
+    struct iwl_mvm_frame_stats *stats,
+    u32 rate, bool agg);
+int rs_pretty_print_rate(char *buf, const u32 rate);
+
+/* power management */
+int iwl_mvm_power_update_device(struct iwl_mvm *mvm);
+int iwl_mvm_power_update_mac(struct iwl_mvm *mvm);
+int iwl_mvm_power_mac_dbgfs_read(struct iwl_mvm *mvm, struct ieee80211_vif *vif,
+     char *buf, int bufsz);
+
+void iwl_mvm_power_vif_assoc(struct iwl_mvm *mvm, struct ieee80211_vif *vif);
+int iwl_mvm_power_uapsd_misbehaving_ap_notif(struct iwl_mvm *mvm,
+          struct iwl_rx_cmd_buffer *rxb,
+          struct iwl_device_cmd *cmd);
+
+#ifdef CONFIG_IWLWIFI_LEDS
 int iwl_mvm_leds_init(struct iwl_mvm *mvm);
 void iwl_mvm_leds_exit(struct iwl_mvm *mvm);
+#else
+static inline int iwl_mvm_leds_init(struct iwl_mvm *mvm)
+{
+ return 0;
+}
+static inline void iwl_mvm_leds_exit(struct iwl_mvm *mvm)
+{
+}
+#endif
 
 /* D3 (WoWLAN, NetDetect) */
 int iwl_mvm_suspend(struct ieee80211_hw *hw, struct cfg80211_wowlan *wowlan);
@@ -524,15 +928,115 @@ void iwl_mvm_ipv6_addr_change(struct ieee80211_hw *hw,
          struct inet6_dev *idev);
 void iwl_mvm_set_default_unicast_key(struct ieee80211_hw *hw,
          struct ieee80211_vif *vif, int idx);
+extern const struct file_operations iwl_dbgfs_d3_test_ops;
+#ifdef CONFIG_PM_SLEEP
+void iwl_mvm_set_last_nonqos_seq(struct iwl_mvm *mvm,
+     struct ieee80211_vif *vif);
+#else
+static inline void
+iwl_mvm_set_last_nonqos_seq(struct iwl_mvm *mvm, struct ieee80211_vif *vif)
+{
+}
+#endif
+void iwl_mvm_set_wowlan_qos_seq(struct iwl_mvm_sta *mvm_ap_sta,
+    struct iwl_wowlan_config_cmd_v2 *cmd);
+int iwl_mvm_send_proto_offload(struct iwl_mvm *mvm,
+          struct ieee80211_vif *vif,
+          bool disable_offloading,
+          u32 cmd_flags);
+
+/* D0i3 */
+void iwl_mvm_ref(struct iwl_mvm *mvm, enum iwl_mvm_ref_type ref_type);
+void iwl_mvm_unref(struct iwl_mvm *mvm, enum iwl_mvm_ref_type ref_type);
+void iwl_mvm_d0i3_enable_tx(struct iwl_mvm *mvm, __le16 *qos_seq);
+int _iwl_mvm_exit_d0i3(struct iwl_mvm *mvm);
 
 /* BT Coex */
-int iwl_send_bt_prio_tbl(struct iwl_mvm *mvm);
 int iwl_send_bt_init_conf(struct iwl_mvm *mvm);
 int iwl_mvm_rx_bt_coex_notif(struct iwl_mvm *mvm,
         struct iwl_rx_cmd_buffer *rxb,
         struct iwl_device_cmd *cmd);
 void iwl_mvm_bt_rssi_event(struct iwl_mvm *mvm, struct ieee80211_vif *vif,
       enum ieee80211_rssi_event rssi_event);
-void iwl_mvm_bt_coex_vif_assoc(struct iwl_mvm *mvm, struct ieee80211_vif *vif);
+void iwl_mvm_bt_coex_vif_change(struct iwl_mvm *mvm);
+u16 iwl_mvm_coex_agg_time_limit(struct iwl_mvm *mvm,
+    struct ieee80211_sta *sta);
+bool iwl_mvm_bt_coex_is_mimo_allowed(struct iwl_mvm *mvm,
+         struct ieee80211_sta *sta);
+bool iwl_mvm_bt_coex_is_tpc_allowed(struct iwl_mvm *mvm,
+        enum ieee80211_band band);
+u8 iwl_mvm_bt_coex_tx_prio(struct iwl_mvm *mvm, struct ieee80211_hdr *hdr,
+      struct ieee80211_tx_info *info, u8 ac);
+
+enum iwl_bt_kill_msk {
+ BT_KILL_MSK_DEFAULT,
+ BT_KILL_MSK_SCO_HID_A2DP,
+ BT_KILL_MSK_REDUCED_TXPOW,
+ BT_KILL_MSK_MAX,
+};
+extern const u32 iwl_bt_ack_kill_msk[BT_KILL_MSK_MAX];
+extern const u32 iwl_bt_cts_kill_msk[BT_KILL_MSK_MAX];
+
+/* beacon filtering */
+#ifdef CONFIG_IWLWIFI_DEBUGFS
+void
+iwl_mvm_beacon_filter_debugfs_parameters(struct ieee80211_vif *vif,
+      struct iwl_beacon_filter_cmd *cmd);
+#else
+static inline void
+iwl_mvm_beacon_filter_debugfs_parameters(struct ieee80211_vif *vif,
+      struct iwl_beacon_filter_cmd *cmd)
+{}
+#endif
+int iwl_mvm_update_d0i3_power_mode(struct iwl_mvm *mvm,
+       struct ieee80211_vif *vif,
+       bool enable, u32 flags);
+int iwl_mvm_enable_beacon_filter(struct iwl_mvm *mvm,
+     struct ieee80211_vif *vif,
+     u32 flags);
+int iwl_mvm_disable_beacon_filter(struct iwl_mvm *mvm,
+      struct ieee80211_vif *vif,
+      u32 flags);
+/* SMPS */
+void iwl_mvm_update_smps(struct iwl_mvm *mvm, struct ieee80211_vif *vif,
+    enum iwl_mvm_smps_type_request req_type,
+    enum ieee80211_smps_mode smps_request);
+bool iwl_mvm_rx_diversity_allowed(struct iwl_mvm *mvm);
+
+/* Low latency */
+int iwl_mvm_update_low_latency(struct iwl_mvm *mvm, struct ieee80211_vif *vif,
+          bool value);
+/* get SystemLowLatencyMode - only needed for beacon threshold? */
+bool iwl_mvm_low_latency(struct iwl_mvm *mvm);
+/* get VMACLowLatencyMode */
+static inline bool iwl_mvm_vif_low_latency(struct iwl_mvm_vif *mvmvif)
+{
+ /*
+  * should this consider associated/active/... state?
+  *
+  * Normally low-latency should only be active on interfaces
+  * that are active, but at least with debugfs it can also be
+  * enabled on interfaces that aren't active. However, when
+  * interface aren't active then they aren't added into the
+  * binding, so this has no real impact. For now, just return
+  * the current desired low-latency state.
+  */
+
+ return mvmvif->low_latency;
+}
+
+/* Assoc status */
+bool iwl_mvm_is_idle(struct iwl_mvm *mvm);
+
+/* Thermal management and CT-kill */
+void iwl_mvm_tt_tx_backoff(struct iwl_mvm *mvm, u32 backoff);
+void iwl_mvm_tt_handler(struct iwl_mvm *mvm);
+void iwl_mvm_tt_initialize(struct iwl_mvm *mvm, u32 min_backoff);
+void iwl_mvm_tt_exit(struct iwl_mvm *mvm);
+void iwl_mvm_set_hw_ctkill_state(struct iwl_mvm *mvm, bool state);
+
+/* smart fifo */
+int iwl_mvm_sf_update(struct iwl_mvm *mvm, struct ieee80211_vif *vif,
+        bool added_vif);
 
 #endif /* __IWL_MVM_H__ */
diff --git a/drivers/net/wireless/iwlwifi/mvm/nvm.c b/drivers/net/wireless/iwlwifi/mvm/nvm.c
index b8ec02f..808f78f 100644
--- a/drivers/net/wireless/iwlwifi/mvm/nvm.c
+++ b/drivers/net/wireless/iwlwifi/mvm/nvm.c
@@ -5,7 +5,7 @@
  *
  * GPL LICENSE SUMMARY
  *
- * Copyright(c) 2012 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2012 - 2014 Intel Corporation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of version 2 of the GNU General Public License as
@@ -30,7 +30,7 @@
  *
  * BSD LICENSE
  *
- * Copyright(c) 2012 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2012 - 2014 Intel Corporation. All rights reserved.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -60,46 +60,70 @@
  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  *
  *****************************************************************************/
+#include <linux/firmware.h>
 #include "iwl-trans.h"
 #include "mvm.h"
 #include "iwl-eeprom-parse.h"
 #include "iwl-eeprom-read.h"
 #include "iwl-nvm-parse.h"
 
-/* list of NVM sections we are allowed/need to read */
-static const int nvm_to_read[] = {
- NVM_SECTION_TYPE_HW,
- NVM_SECTION_TYPE_SW,
- NVM_SECTION_TYPE_CALIBRATION,
- NVM_SECTION_TYPE_PRODUCTION,
-};
-
 /* Default NVM size to read */
-#define IWL_NVM_DEFAULT_CHUNK_SIZE (2*1024);
+#define IWL_NVM_DEFAULT_CHUNK_SIZE (2*1024)
+#define IWL_MAX_NVM_SECTION_SIZE 7000
 
-static inline void iwl_nvm_fill_read(struct iwl_nvm_access_cmd *cmd,
-         u16 offset, u16 length, u16 section)
+#define NVM_WRITE_OPCODE 1
+#define NVM_READ_OPCODE 0
+
+/* load nvm chunk response */
+enum {
+ READ_NVM_CHUNK_SUCCEED = 0,
+ READ_NVM_CHUNK_NOT_VALID_ADDRESS = 1
+};
+
+/*
+ * prepare the NVM host command w/ the pointers to the nvm buffer
+ * and send it to fw
+ */
+static int iwl_nvm_write_chunk(struct iwl_mvm *mvm, u16 section,
+          u16 offset, u16 length, const u8 *data)
 {
- cmd->offset = cpu_to_le16(offset);
- cmd->length = cpu_to_le16(length);
- cmd->type = cpu_to_le16(section);
+ struct iwl_nvm_access_cmd nvm_access_cmd = {
+  .offset = cpu_to_le16(offset),
+  .length = cpu_to_le16(length),
+  .type = cpu_to_le16(section),
+  .op_code = NVM_WRITE_OPCODE,
+ };
+ struct iwl_host_cmd cmd = {
+  .id = NVM_ACCESS_CMD,
+  .len = { sizeof(struct iwl_nvm_access_cmd), length },
+  .flags = CMD_SEND_IN_RFKILL,
+  .data = { &nvm_access_cmd, data },
+  /* data may come from vmalloc, so use _DUP */
+  .dataflags = { 0, IWL_HCMD_DFL_DUP },
+ };
+
+ return iwl_mvm_send_cmd(mvm, &cmd);
 }
 
 static int iwl_nvm_read_chunk(struct iwl_mvm *mvm, u16 section,
          u16 offset, u16 length, u8 *data)
 {
- struct iwl_nvm_access_cmd nvm_access_cmd = {};
+ struct iwl_nvm_access_cmd nvm_access_cmd = {
+  .offset = cpu_to_le16(offset),
+  .length = cpu_to_le16(length),
+  .type = cpu_to_le16(section),
+  .op_code = NVM_READ_OPCODE,
+ };
  struct iwl_nvm_access_resp *nvm_resp;
  struct iwl_rx_packet *pkt;
  struct iwl_host_cmd cmd = {
   .id = NVM_ACCESS_CMD,
-  .flags = CMD_SYNC | CMD_WANT_SKB,
+  .flags = CMD_WANT_SKB | CMD_SEND_IN_RFKILL,
   .data = { &nvm_access_cmd, },
  };
  int ret, bytes_read, offset_read;
  u8 *resp_data;
 
- iwl_nvm_fill_read(&nvm_access_cmd, offset, length, section);
  cmd.len[0] = sizeof(struct iwl_nvm_access_cmd);
 
  ret = iwl_mvm_send_cmd(mvm, &cmd);
@@ -121,10 +145,26 @@ static int iwl_nvm_read_chunk(struct iwl_mvm *mvm, u16 section,
  offset_read = le16_to_cpu(nvm_resp->offset);
  resp_data = nvm_resp->data;
  if (ret) {
-  IWL_ERR(mvm,
-   "NVM access command failed with status %d (device: %s)\n",
-   ret, mvm->cfg->name);
-  ret = -EINVAL;
+  if ((offset != 0) &&
+      (ret == READ_NVM_CHUNK_NOT_VALID_ADDRESS)) {
+   /*
+    * meaning of NOT_VALID_ADDRESS:
+    * driver try to read chunk from address that is
+    * multiple of 2K and got an error since addr is empty.
+    * meaning of (offset != 0): driver already
+    * read valid data from another chunk so this case
+    * is not an error.
+    */
+   IWL_DEBUG_EEPROM(mvm->trans->dev,
+      "NVM access command failed on offset 0x%x since that section size is multiple 2K\n",
+      offset);
+   ret = 0;
+  } else {
+   IWL_DEBUG_EEPROM(mvm->trans->dev,
+      "NVM access command failed with status %d (device: %s)\n",
+      ret, mvm->cfg->name);
+   ret = -EIO;
+  }
   goto exit;
  }
 
@@ -144,6 +184,30 @@ exit:
  return ret;
 }
 
+static int iwl_nvm_write_section(struct iwl_mvm *mvm, u16 section,
+     const u8 *data, u16 length)
+{
+ int offset = 0;
+
+ /* copy data in chunks of 2k (and remainder if any) */
+
+ while (offset < length) {
+  int chunk_size, ret;
+
+  chunk_size = min(IWL_NVM_DEFAULT_CHUNK_SIZE,
+     length - offset);
+
+  ret = iwl_nvm_write_chunk(mvm, section, offset,
+       chunk_size, data + offset);
+  if (ret < 0)
+   return ret;
+
+  offset += chunk_size;
+ }
+
+ return 0;
+}
+
 /*
  * Reads an NVM section completely.
  * NICs prior to 7000 family doesn't have a real NVM, but just read
@@ -169,15 +233,16 @@ static int iwl_nvm_read_section(struct iwl_mvm *mvm, u16 section,
  while (ret == length) {
   ret = iwl_nvm_read_chunk(mvm, section, offset, length, data);
   if (ret < 0) {
-   IWL_ERR(mvm,
-    "Cannot read NVM from section %d offset %d, length %d\n",
-    section, offset, length);
+   IWL_DEBUG_EEPROM(mvm->trans->dev,
+      "Cannot read NVM from section %d offset %d, length %d\n",
+      section, offset, length);
    return ret;
   }
   offset += ret;
  }
 
- IWL_INFO(mvm, "NVM section %d read completed\n", section);
+ IWL_DEBUG_EEPROM(mvm->trans->dev,
+    "NVM section %d read completed\n", section);
  return offset;
 }
 
@@ -185,54 +250,280 @@ static struct iwl_nvm_data *
 iwl_parse_nvm_sections(struct iwl_mvm *mvm)
 {
  struct iwl_nvm_section *sections = mvm->nvm_sections;
- const __le16 *hw, *sw, *calib;
+ const __le16 *hw, *sw, *calib, *regulatory, *mac_override;
 
  /* Checking for required sections */
- if (!mvm->nvm_sections[NVM_SECTION_TYPE_SW].data ||
-     !mvm->nvm_sections[NVM_SECTION_TYPE_HW].data) {
-  IWL_ERR(mvm, "Can't parse empty NVM sections\n");
-  return NULL;
+ if (mvm->trans->cfg->device_family != IWL_DEVICE_FAMILY_8000) {
+  if (!mvm->nvm_sections[NVM_SECTION_TYPE_SW].data ||
+      !mvm->nvm_sections[mvm->cfg->nvm_hw_section_num].data) {
+   IWL_ERR(mvm, "Can't parse empty NVM sections\n");
+   return NULL;
+  }
+ } else {
+  /* SW and REGULATORY sections are mandatory */
+  if (!mvm->nvm_sections[NVM_SECTION_TYPE_SW].data ||
+      !mvm->nvm_sections[NVM_SECTION_TYPE_REGULATORY].data) {
+   IWL_ERR(mvm,
+    "Can't parse empty family 8000 NVM sections\n");
+   return NULL;
+  }
+  /* MAC_OVERRIDE or at least HW section must exist */
+  if (!mvm->nvm_sections[mvm->cfg->nvm_hw_section_num].data &&
+      !mvm->nvm_sections[NVM_SECTION_TYPE_MAC_OVERRIDE].data) {
+   IWL_ERR(mvm,
+    "Can't parse mac_address, empty sections\n");
+   return NULL;
+  }
  }
 
  if (WARN_ON(!mvm->cfg))
   return NULL;
 
- hw = (const __le16 *)sections[NVM_SECTION_TYPE_HW].data;
+ hw = (const __le16 *)sections[mvm->cfg->nvm_hw_section_num].data;
  sw = (const __le16 *)sections[NVM_SECTION_TYPE_SW].data;
  calib = (const __le16 *)sections[NVM_SECTION_TYPE_CALIBRATION].data;
- return iwl_parse_nvm_data(mvm->trans->dev, mvm->cfg, hw, sw, calib);
+ regulatory = (const __le16 *)sections[NVM_SECTION_TYPE_REGULATORY].data;
+ mac_override =
+  (const __le16 *)sections[NVM_SECTION_TYPE_MAC_OVERRIDE].data;
+
+ return iwl_parse_nvm_data(mvm->trans->dev, mvm->cfg, hw, sw, calib,
+      regulatory, mac_override,
+      mvm->fw->valid_tx_ant,
+      mvm->fw->valid_rx_ant);
 }
 
-int iwl_nvm_init(struct iwl_mvm *mvm)
+#define MAX_NVM_FILE_LEN 16384
+
+/*
+ * Reads external NVM from a file into mvm->nvm_sections
+ *
+ * HOW TO CREATE THE NVM FILE FORMAT:
+ * ------------------------------
+ * 1. create hex file, format:
+ *      3800 -> header
+ *      0000 -> header
+ *      5a40 -> data
+ *
+ *   rev - 6 bit (word1)
+ *   len - 10 bit (word1)
+ *   id - 4 bit (word2)
+ *   rsv - 12 bit (word2)
+ *
+ * 2. flip 8bits with 8 bits per line to get the right NVM file format
+ *
+ * 3. create binary file from the hex file
+ *
+ * 4. save as "iNVM_xxx.bin" under /lib/firmware
+ */
+static int iwl_mvm_read_external_nvm(struct iwl_mvm *mvm)
 {
- int ret, i, section;
- u8 *nvm_buffer, *temp;
+ int ret, section_size;
+ u16 section_id;
+ const struct firmware *fw_entry;
+ const struct {
+  __le16 word1;
+  __le16 word2;
+  u8 data[];
+ } *file_sec;
+ const u8 *eof, *temp;
 
- /* TODO: find correct NVM max size for a section */
- nvm_buffer = kmalloc(mvm->cfg->base_params->eeprom_size,
-        GFP_KERNEL);
- if (!nvm_buffer)
-  return -ENOMEM;
- for (i = 0; i < ARRAY_SIZE(nvm_to_read); i++) {
-  section = nvm_to_read[i];
-  /* we override the constness for initial read */
-  ret = iwl_nvm_read_section(mvm, section, nvm_buffer);
-  if (ret < 0)
+#define NVM_WORD1_LEN(x) (8 * (x & 0x03FF))
+#define NVM_WORD2_ID(x) (x >> 12)
+#define NVM_WORD2_LEN_FAMILY_8000(x) (2 * ((x & 0xFF) << 8 | x >> 8))
+#define NVM_WORD1_ID_FAMILY_8000(x) (x >> 4)
+
+ IWL_DEBUG_EEPROM(mvm->trans->dev, "Read from external NVM\n");
+
+ /*
+  * Obtain NVM image via request_firmware. Since we already used
+  * request_firmware_nowait() for the firmware binary load and only
+  * get here after that we assume the NVM request can be satisfied
+  * synchronously.
+  */
+ ret = request_firmware(&fw_entry, mvm->nvm_file_name,
+          mvm->trans->dev);
+ if (ret) {
+  IWL_ERR(mvm, "ERROR: %s isn't available %d\n",
+   mvm->nvm_file_name, ret);
+  return ret;
+ }
+
+ IWL_INFO(mvm, "Loaded NVM file %s (%zu bytes)\n",
+   mvm->nvm_file_name, fw_entry->size);
+
+ if (fw_entry->size < sizeof(*file_sec)) {
+  IWL_ERR(mvm, "NVM file too small\n");
+  ret = -EINVAL;
+  goto out;
+ }
+
+ if (fw_entry->size > MAX_NVM_FILE_LEN) {
+  IWL_ERR(mvm, "NVM file too large\n");
+  ret = -EINVAL;
+  goto out;
+ }
+
+ eof = fw_entry->data + fw_entry->size;
+
+ file_sec = (void *)fw_entry->data;
+
+ while (true) {
+  if (file_sec->data > eof) {
+   IWL_ERR(mvm,
+    "ERROR - NVM file too short for section header\n");
+   ret = -EINVAL;
+   break;
+  }
+
+  /* check for EOF marker */
+  if (!file_sec->word1 && !file_sec->word2) {
+   ret = 0;
+   break;
+  }
+
+  if (mvm->trans->cfg->device_family != IWL_DEVICE_FAMILY_8000) {
+   section_size =
+    2 * NVM_WORD1_LEN(le16_to_cpu(file_sec->word1));
+   section_id = NVM_WORD2_ID(le16_to_cpu(file_sec->word2));
+  } else {
+   section_size = 2 * NVM_WORD2_LEN_FAMILY_8000(
+      le16_to_cpu(file_sec->word2));
+   section_id = NVM_WORD1_ID_FAMILY_8000(
+      le16_to_cpu(file_sec->word1));
+  }
+
+  if (section_size > IWL_MAX_NVM_SECTION_SIZE) {
+   IWL_ERR(mvm, "ERROR - section too large (%d)\n",
+    section_size);
+   ret = -EINVAL;
    break;
-  temp = kmemdup(nvm_buffer, ret, GFP_KERNEL);
+  }
+
+  if (!section_size) {
+   IWL_ERR(mvm, "ERROR - section empty\n");
+   ret = -EINVAL;
+   break;
+  }
+
+  if (file_sec->data + section_size > eof) {
+   IWL_ERR(mvm,
+    "ERROR - NVM file too short for section (%d bytes)\n",
+    section_size);
+   ret = -EINVAL;
+   break;
+  }
+
+  if (WARN(section_id >= NVM_MAX_NUM_SECTIONS,
+    "Invalid NVM section ID %d\n", section_id)) {
+   ret = -EINVAL;
+   break;
+  }
+
+  temp = kmemdup(file_sec->data, section_size, GFP_KERNEL);
   if (!temp) {
    ret = -ENOMEM;
    break;
   }
-  mvm->nvm_sections[section].data = temp;
-  mvm->nvm_sections[section].length = ret;
+  mvm->nvm_sections[section_id].data = temp;
+  mvm->nvm_sections[section_id].length = section_size;
+
+  /* advance to the next section */
+  file_sec = (void *)(file_sec->data + section_size);
+ }
+out:
+ release_firmware(fw_entry);
+ return ret;
+}
+
+/* Loads the NVM data stored in mvm->nvm_sections into the NIC */
+int iwl_mvm_load_nvm_to_nic(struct iwl_mvm *mvm)
+{
+ int i, ret = 0;
+ struct iwl_nvm_section *sections = mvm->nvm_sections;
+
+ IWL_DEBUG_EEPROM(mvm->trans->dev, "'Write to NVM\n");
+
+ for (i = 0; i < ARRAY_SIZE(mvm->nvm_sections); i++) {
+  if (!mvm->nvm_sections[i].data || !mvm->nvm_sections[i].length)
+   continue;
+  ret = iwl_nvm_write_section(mvm, i, sections[i].data,
+         sections[i].length);
+  if (ret < 0) {
+   IWL_ERR(mvm, "iwl_mvm_send_cmd failed: %d\n", ret);
+   break;
+  }
  }
- kfree(nvm_buffer);
- if (ret < 0)
-  return ret;
+ return ret;
+}
 
- ret = 0;
+int iwl_nvm_init(struct iwl_mvm *mvm, bool read_nvm_from_nic)
+{
+ int ret, section;
+ u8 *nvm_buffer, *temp;
+
+ if (WARN_ON_ONCE(mvm->cfg->nvm_hw_section_num >= NVM_MAX_NUM_SECTIONS))
+  return -EINVAL;
+
+ /* load NVM values from nic */
+ if (read_nvm_from_nic) {
+  /* Read From FW NVM */
+  IWL_DEBUG_EEPROM(mvm->trans->dev, "Read from NVM\n");
+
+  nvm_buffer = kmalloc(mvm->cfg->base_params->eeprom_size,
+         GFP_KERNEL);
+  if (!nvm_buffer)
+   return -ENOMEM;
+  for (section = 0; section < NVM_MAX_NUM_SECTIONS; section++) {
+   /* we override the constness for initial read */
+   ret = iwl_nvm_read_section(mvm, section, nvm_buffer);
+   if (ret < 0)
+    continue;
+   temp = kmemdup(nvm_buffer, ret, GFP_KERNEL);
+   if (!temp) {
+    ret = -ENOMEM;
+    break;
+   }
+   mvm->nvm_sections[section].data = temp;
+   mvm->nvm_sections[section].length = ret;
+
+#ifdef CONFIG_IWLWIFI_DEBUGFS
+   switch (section) {
+   case NVM_SECTION_TYPE_SW:
+    mvm->nvm_sw_blob.data = temp;
+    mvm->nvm_sw_blob.size  = ret;
+    break;
+   case NVM_SECTION_TYPE_CALIBRATION:
+    mvm->nvm_calib_blob.data = temp;
+    mvm->nvm_calib_blob.size  = ret;
+    break;
+   case NVM_SECTION_TYPE_PRODUCTION:
+    mvm->nvm_prod_blob.data = temp;
+    mvm->nvm_prod_blob.size  = ret;
+    break;
+   default:
+    if (section == mvm->cfg->nvm_hw_section_num) {
+     mvm->nvm_hw_blob.data = temp;
+     mvm->nvm_hw_blob.size = ret;
+     break;
+    }
+   }
+#endif
+  }
+  kfree(nvm_buffer);
+ }
+
+ /* load external NVM if configured */
+ if (mvm->nvm_file_name) {
+  /* move to External NVM flow */
+  ret = iwl_mvm_read_external_nvm(mvm);
+  if (ret)
+   return ret;
+ }
+
+ /* parse the relevant nvm sections */
  mvm->nvm_data = iwl_parse_nvm_sections(mvm);
+ if (!mvm->nvm_data)
+  return -ENODATA;
 
- return ret;
+ return 0;
 }
diff --git a/drivers/net/wireless/iwlwifi/mvm/offloading.c b/drivers/net/wireless/iwlwifi/mvm/offloading.c
new file mode 100644
index 0000000..9bfb95e
--- /dev/null
+++ b/drivers/net/wireless/iwlwifi/mvm/offloading.c
@@ -0,0 +1,215 @@
+/******************************************************************************
+ *
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ * redistributing this file, you may do so under either license.
+ *
+ * GPL LICENSE SUMMARY
+ *
+ * Copyright(c) 2012 - 2014 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110,
+ * USA
+ *
+ * The full GNU General Public License is included in this distribution
+ * in the file called COPYING.
+ *
+ * Contact Information:
+ *  Intel Linux Wireless <ilw@linux.intel.com>
+ * Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497
+ *
+ * BSD LICENSE
+ *
+ * Copyright(c) 2012 - 2014 Intel Corporation. All rights reserved.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *  * Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *  * Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *  * Neither the name Intel Corporation nor the names of its
+ *    contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *****************************************************************************/
+#include <net/ipv6.h>
+#include <net/addrconf.h>
+#include "mvm.h"
+
+void iwl_mvm_set_wowlan_qos_seq(struct iwl_mvm_sta *mvm_ap_sta,
+    struct iwl_wowlan_config_cmd_v2 *cmd)
+{
+ int i;
+
+ /*
+  * For QoS counters, we store the one to use next, so subtract 0x10
+  * since the uCode will add 0x10 *before* using the value while we
+  * increment after using the value (i.e. store the next value to use).
+  */
+ for (i = 0; i < IWL_MAX_TID_COUNT; i++) {
+  u16 seq = mvm_ap_sta->tid_data[i].seq_number;
+  seq -= 0x10;
+  cmd->qos_seq[i] = cpu_to_le16(seq);
+ }
+}
+
+int iwl_mvm_send_proto_offload(struct iwl_mvm *mvm,
+          struct ieee80211_vif *vif,
+          bool disable_offloading,
+          u32 cmd_flags)
+{
+ union {
+  struct iwl_proto_offload_cmd_v1 v1;
+  struct iwl_proto_offload_cmd_v2 v2;
+  struct iwl_proto_offload_cmd_v3_small v3s;
+  struct iwl_proto_offload_cmd_v3_large v3l;
+ } cmd = {};
+ struct iwl_host_cmd hcmd = {
+  .id = PROT_OFFLOAD_CONFIG_CMD,
+  .flags = cmd_flags,
+  .data[0] = &cmd,
+  .dataflags[0] = IWL_HCMD_DFL_DUP,
+ };
+ struct iwl_proto_offload_cmd_common *common;
+ u32 enabled = 0, size;
+ u32 capa_flags = mvm->fw->ucode_capa.flags;
+#if IS_ENABLED(CONFIG_IPV6)
+ struct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);
+ int i;
+
+ if (capa_flags & IWL_UCODE_TLV_FLAGS_NEW_NSOFFL_SMALL ||
+     capa_flags & IWL_UCODE_TLV_FLAGS_NEW_NSOFFL_LARGE) {
+  struct iwl_ns_config *nsc;
+  struct iwl_targ_addr *addrs;
+  int n_nsc, n_addrs;
+  int c;
+
+  if (capa_flags & IWL_UCODE_TLV_FLAGS_NEW_NSOFFL_SMALL) {
+   nsc = cmd.v3s.ns_config;
+   n_nsc = IWL_PROTO_OFFLOAD_NUM_NS_CONFIG_V3S;
+   addrs = cmd.v3s.targ_addrs;
+   n_addrs = IWL_PROTO_OFFLOAD_NUM_IPV6_ADDRS_V3S;
+  } else {
+   nsc = cmd.v3l.ns_config;
+   n_nsc = IWL_PROTO_OFFLOAD_NUM_NS_CONFIG_V3L;
+   addrs = cmd.v3l.targ_addrs;
+   n_addrs = IWL_PROTO_OFFLOAD_NUM_IPV6_ADDRS_V3L;
+  }
+
+  if (mvmvif->num_target_ipv6_addrs)
+   enabled |= IWL_D3_PROTO_OFFLOAD_NS;
+
+  /*
+   * For each address we have (and that will fit) fill a target
+   * address struct and combine for NS offload structs with the
+   * solicited node addresses.
+   */
+  for (i = 0, c = 0;
+       i < mvmvif->num_target_ipv6_addrs &&
+       i < n_addrs && c < n_nsc; i++) {
+   struct in6_addr solicited_addr;
+   int j;
+
+   addrconf_addr_solict_mult(&mvmvif->target_ipv6_addrs[i],
+        &solicited_addr);
+   for (j = 0; j < c; j++)
+    if (ipv6_addr_cmp(&nsc[j].dest_ipv6_addr,
+        &solicited_addr) == 0)
+     break;
+   if (j == c)
+    c++;
+   addrs[i].addr = mvmvif->target_ipv6_addrs[i];
+   addrs[i].config_num = cpu_to_le32(j);
+   nsc[j].dest_ipv6_addr = solicited_addr;
+   memcpy(nsc[j].target_mac_addr, vif->addr, ETH_ALEN);
+  }
+
+  if (capa_flags & IWL_UCODE_TLV_FLAGS_NEW_NSOFFL_SMALL)
+   cmd.v3s.num_valid_ipv6_addrs = cpu_to_le32(i);
+  else
+   cmd.v3l.num_valid_ipv6_addrs = cpu_to_le32(i);
+ } else if (capa_flags & IWL_UCODE_TLV_FLAGS_D3_6_IPV6_ADDRS) {
+  if (mvmvif->num_target_ipv6_addrs) {
+   enabled |= IWL_D3_PROTO_OFFLOAD_NS;
+   memcpy(cmd.v2.ndp_mac_addr, vif->addr, ETH_ALEN);
+  }
+
+  BUILD_BUG_ON(sizeof(cmd.v2.target_ipv6_addr[0]) !=
+        sizeof(mvmvif->target_ipv6_addrs[0]));
+
+  for (i = 0; i < min(mvmvif->num_target_ipv6_addrs,
+        IWL_PROTO_OFFLOAD_NUM_IPV6_ADDRS_V2); i++)
+   memcpy(cmd.v2.target_ipv6_addr[i],
+          &mvmvif->target_ipv6_addrs[i],
+          sizeof(cmd.v2.target_ipv6_addr[i]));
+ } else {
+  if (mvmvif->num_target_ipv6_addrs) {
+   enabled |= IWL_D3_PROTO_OFFLOAD_NS;
+   memcpy(cmd.v1.ndp_mac_addr, vif->addr, ETH_ALEN);
+  }
+
+  BUILD_BUG_ON(sizeof(cmd.v1.target_ipv6_addr[0]) !=
+        sizeof(mvmvif->target_ipv6_addrs[0]));
+
+  for (i = 0; i < min(mvmvif->num_target_ipv6_addrs,
+        IWL_PROTO_OFFLOAD_NUM_IPV6_ADDRS_V1); i++)
+   memcpy(cmd.v1.target_ipv6_addr[i],
+          &mvmvif->target_ipv6_addrs[i],
+          sizeof(cmd.v1.target_ipv6_addr[i]));
+ }
+#endif
+
+ if (capa_flags & IWL_UCODE_TLV_FLAGS_NEW_NSOFFL_SMALL) {
+  common = &cmd.v3s.common;
+  size = sizeof(cmd.v3s);
+ } else if (capa_flags & IWL_UCODE_TLV_FLAGS_NEW_NSOFFL_LARGE) {
+  common = &cmd.v3l.common;
+  size = sizeof(cmd.v3l);
+ } else if (capa_flags & IWL_UCODE_TLV_FLAGS_D3_6_IPV6_ADDRS) {
+  common = &cmd.v2.common;
+  size = sizeof(cmd.v2);
+ } else {
+  common = &cmd.v1.common;
+  size = sizeof(cmd.v1);
+ }
+
+ if (vif->bss_conf.arp_addr_cnt) {
+  enabled |= IWL_D3_PROTO_OFFLOAD_ARP;
+  common->host_ipv4_addr = vif->bss_conf.arp_addr_list[0];
+  memcpy(common->arp_mac_addr, vif->addr, ETH_ALEN);
+ }
+
+ if (!disable_offloading)
+  common->enabled = cpu_to_le32(enabled);
+
+ hcmd.len[0] = size;
+ return iwl_mvm_send_cmd(mvm, &hcmd);
+}
diff --git a/drivers/net/wireless/iwlwifi/mvm/ops.c b/drivers/net/wireless/iwlwifi/mvm/ops.c
index b29c31a..cc2f7de 100644
--- a/drivers/net/wireless/iwlwifi/mvm/ops.c
+++ b/drivers/net/wireless/iwlwifi/mvm/ops.c
@@ -5,7 +5,7 @@
  *
  * GPL LICENSE SUMMARY
  *
- * Copyright(c) 2012 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2012 - 2014 Intel Corporation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of version 2 of the GNU General Public License as
@@ -30,7 +30,7 @@
  *
  * BSD LICENSE
  *
- * Copyright(c) 2012 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2012 - 2014 Intel Corporation. All rights reserved.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -61,6 +61,7 @@
  *
  *****************************************************************************/
 #include <linux/module.h>
+#include <linux/vmalloc.h>
 #include <net/mac80211.h>
 
 #include "iwl-notif-wait.h"
@@ -79,6 +80,7 @@
 #include "rs.h"
 #include "fw-api-scan.h"
 #include "time-event.h"
+#include "iwl-fw-error-dump.h"
 
 /*
  * module name, copyright, version, etc.
@@ -185,9 +187,10 @@ static void iwl_mvm_nic_config(struct iwl_op_mode *op_mode)
   * (PCIe power is lost before PERST# is asserted), causing ME FW
   * to lose ownership and not being able to obtain it back.
   */
- iwl_set_bits_mask_prph(mvm->trans, APMG_PS_CTRL_REG,
-          APMG_PS_CTRL_EARLY_PWR_OFF_RESET_DIS,
-          ~APMG_PS_CTRL_EARLY_PWR_OFF_RESET_DIS);
+ if (mvm->trans->cfg->device_family != IWL_DEVICE_FAMILY_8000)
+  iwl_set_bits_mask_prph(mvm->trans, APMG_PS_CTRL_REG,
+           APMG_PS_CTRL_EARLY_PWR_OFF_RESET_DIS,
+           ~APMG_PS_CTRL_EARLY_PWR_OFF_RESET_DIS);
 }
 
 struct iwl_rx_handlers {
@@ -215,23 +218,38 @@ static const struct iwl_rx_handlers iwl_mvm_rx_handlers[] = {
  RX_HANDLER(REPLY_RX_PHY_CMD, iwl_mvm_rx_rx_phy_cmd, false),
  RX_HANDLER(TX_CMD, iwl_mvm_rx_tx_cmd, false),
  RX_HANDLER(BA_NOTIF, iwl_mvm_rx_ba_notif, false),
+
+ RX_HANDLER(BT_PROFILE_NOTIFICATION, iwl_mvm_rx_bt_coex_notif, true),
+ RX_HANDLER(BEACON_NOTIFICATION, iwl_mvm_rx_beacon_notif, true),
+ RX_HANDLER(STATISTICS_NOTIFICATION, iwl_mvm_rx_statistics, true),
+ RX_HANDLER(ANTENNA_COUPLING_NOTIFICATION,
+     iwl_mvm_rx_ant_coupling_notif, true),
+
  RX_HANDLER(TIME_EVENT_NOTIFICATION, iwl_mvm_rx_time_event_notif, false),
 
- RX_HANDLER(SCAN_REQUEST_CMD, iwl_mvm_rx_scan_response, false),
- RX_HANDLER(SCAN_COMPLETE_NOTIFICATION, iwl_mvm_rx_scan_complete, false),
+ RX_HANDLER(EOSP_NOTIFICATION, iwl_mvm_rx_eosp_notif, false),
 
- RX_HANDLER(BT_PROFILE_NOTIFICATION, iwl_mvm_rx_bt_coex_notif, true),
- RX_HANDLER(BEACON_NOTIFICATION, iwl_mvm_rx_beacon_notif, false),
+ RX_HANDLER(SCAN_REQUEST_CMD, iwl_mvm_rx_scan_response, false),
+ RX_HANDLER(SCAN_COMPLETE_NOTIFICATION, iwl_mvm_rx_scan_complete, true),
+ RX_HANDLER(SCAN_OFFLOAD_COMPLETE,
+     iwl_mvm_rx_scan_offload_complete_notif, true),
+ RX_HANDLER(MATCH_FOUND_NOTIFICATION, iwl_mvm_rx_sched_scan_results,
+     false),
 
  RX_HANDLER(RADIO_VERSION_NOTIFICATION, iwl_mvm_rx_radio_ver, false),
  RX_HANDLER(CARD_STATE_NOTIFICATION, iwl_mvm_rx_card_state_notif, false),
 
+ RX_HANDLER(MISSED_BEACONS_NOTIFICATION, iwl_mvm_rx_missed_beacons_notif,
+     false),
+
  RX_HANDLER(REPLY_ERROR, iwl_mvm_rx_fw_error, false),
+ RX_HANDLER(PSM_UAPSD_AP_MISBEHAVING_NOTIFICATION,
+     iwl_mvm_power_uapsd_misbehaving_ap_notif, false),
 };
 #undef RX_HANDLER
 #define CMD(x) [x] = #x
 
-static const char *iwl_mvm_cmd_strings[REPLY_MAX] = {
+static const char *const iwl_mvm_cmd_strings[REPLY_MAX] = {
  CMD(MVM_ALIVE),
  CMD(REPLY_ERROR),
  CMD(INIT_COMPLETE_NOTIF),
@@ -244,6 +262,7 @@ static const char *iwl_mvm_cmd_strings[REPLY_MAX] = {
  CMD(TIME_EVENT_NOTIFICATION),
  CMD(BINDING_CONTEXT_CMD),
  CMD(TIME_QUOTA_CMD),
+ CMD(NON_QOS_TX_COUNTER_CMD),
  CMD(RADIO_VERSION_NOTIFICATION),
  CMD(SCAN_REQUEST_CMD),
  CMD(SCAN_ABORT_CMD),
@@ -255,10 +274,12 @@ static const char *iwl_mvm_cmd_strings[REPLY_MAX] = {
  CMD(CALIB_RES_NOTIF_PHY_DB),
  CMD(SET_CALIB_DEFAULT_CMD),
  CMD(CALIBRATION_COMPLETE_NOTIFICATION),
+ CMD(ADD_STA_KEY),
  CMD(ADD_STA),
  CMD(REMOVE_STA),
  CMD(LQ_CMD),
  CMD(SCAN_OFFLOAD_CONFIG_CMD),
+ CMD(MATCH_FOUND_NOTIFICATION),
  CMD(SCAN_OFFLOAD_REQUEST_CMD),
  CMD(SCAN_OFFLOAD_ABORT_CMD),
  CMD(SCAN_OFFLOAD_COMPLETE),
@@ -270,8 +291,11 @@ static const char *iwl_mvm_cmd_strings[REPLY_MAX] = {
  CMD(BEACON_NOTIFICATION),
  CMD(BEACON_TEMPLATE_CMD),
  CMD(STATISTICS_NOTIFICATION),
+ CMD(EOSP_NOTIFICATION),
+ CMD(REDUCE_TX_POWER_CMD),
  CMD(TX_ANT_CONFIGURATION_CMD),
  CMD(D3_CONFIG_CMD),
+ CMD(D0I3_END_CMD),
  CMD(PROT_OFFLOAD_CONFIG_CMD),
  CMD(OFFLOADS_QUERY_CMD),
  CMD(REMOTE_WAKE_CONFIG_CMD),
@@ -288,16 +312,43 @@ static const char *iwl_mvm_cmd_strings[REPLY_MAX] = {
  CMD(NET_DETECT_HOTSPOTS_CMD),
  CMD(NET_DETECT_HOTSPOTS_QUERY_CMD),
  CMD(CARD_STATE_NOTIFICATION),
+ CMD(MISSED_BEACONS_NOTIFICATION),
  CMD(BT_COEX_PRIO_TABLE),
  CMD(BT_COEX_PROT_ENV),
  CMD(BT_PROFILE_NOTIFICATION),
  CMD(BT_CONFIG),
  CMD(MCAST_FILTER_CMD),
+ CMD(BCAST_FILTER_CMD),
+ CMD(REPLY_SF_CFG_CMD),
+ CMD(REPLY_BEACON_FILTERING_CMD),
+ CMD(REPLY_THERMAL_MNG_BACKOFF),
+ CMD(MAC_PM_POWER_TABLE),
+ CMD(BT_COEX_CI),
+ CMD(PSM_UAPSD_AP_MISBEHAVING_NOTIFICATION),
+ CMD(ANTENNA_COUPLING_NOTIFICATION),
 };
 #undef CMD
 
 /* this forward declaration can avoid to export the function */
 static void iwl_mvm_async_handlers_wk(struct work_struct *wk);
+static void iwl_mvm_d0i3_exit_work(struct work_struct *wk);
+
+static u32 calc_min_backoff(struct iwl_trans *trans, const struct iwl_cfg *cfg)
+{
+ const struct iwl_pwr_tx_backoff *pwr_tx_backoff = cfg->pwr_tx_backoffs;
+
+ if (!pwr_tx_backoff)
+  return 0;
+
+ while (pwr_tx_backoff->pwr) {
+  if (trans->dflt_pwr_limit >= pwr_tx_backoff->pwr)
+   return pwr_tx_backoff->backoff;
+
+  pwr_tx_backoff++;
+ }
+
+ return 0;
+}
 
 static struct iwl_op_mode *
 iwl_op_mode_mvm_start(struct iwl_trans *trans, const struct iwl_cfg *cfg,
@@ -311,6 +362,14 @@ iwl_op_mode_mvm_start(struct iwl_trans *trans, const struct iwl_cfg *cfg,
   TX_CMD,
  };
  int err, scan_size;
+ u32 min_backoff;
+
+ /*
+  * We use IWL_MVM_STATION_COUNT to check the validity of the station
+  * index all over the driver - check that its value corresponds to the
+  * array size.
+  */
+ BUILD_BUG_ON(ARRAY_SIZE(mvm->fw_id_to_mac_id) != IWL_MVM_STATION_COUNT);
 
  /********************************
   * 1. Allocating and configuring HW data
@@ -323,7 +382,6 @@ iwl_op_mode_mvm_start(struct iwl_trans *trans, const struct iwl_cfg *cfg,
 
  op_mode = hw->priv;
  op_mode->ops = &iwl_mvm_ops;
- op_mode->trans = trans;
 
  mvm = IWL_OP_MODE_GET_MVM(op_mode);
  mvm->dev = trans->dev;
@@ -332,7 +390,19 @@ iwl_op_mode_mvm_start(struct iwl_trans *trans, const struct iwl_cfg *cfg,
  mvm->fw = fw;
  mvm->hw = hw;
 
+ mvm->restart_fw = iwlwifi_mod_params.restart_fw ? -1 : 0;
+
+ mvm->aux_queue = 15;
+ mvm->first_agg_queue = 16;
+ mvm->last_agg_queue = mvm->cfg->base_params->num_of_queues - 1;
+ if (mvm->cfg->base_params->num_of_queues == 16) {
+  mvm->aux_queue = 11;
+  mvm->first_agg_queue = 12;
+ }
+ mvm->sf_state = SF_UNINIT;
+
  mutex_init(&mvm->mutex);
+ mutex_init(&mvm->d0i3_suspend_mutex);
  spin_lock_init(&mvm->async_handlers_lock);
  INIT_LIST_HEAD(&mvm->time_event_list);
  INIT_LIST_HEAD(&mvm->async_handlers_list);
@@ -341,6 +411,11 @@ iwl_op_mode_mvm_start(struct iwl_trans *trans, const struct iwl_cfg *cfg,
  INIT_WORK(&mvm->async_handlers_wk, iwl_mvm_async_handlers_wk);
  INIT_WORK(&mvm->roc_done_wk, iwl_mvm_roc_done_wk);
  INIT_WORK(&mvm->sta_drained_wk, iwl_mvm_sta_drained_wk);
+ INIT_WORK(&mvm->d0i3_exit_work, iwl_mvm_d0i3_exit_work);
+
+ spin_lock_init(&mvm->d0i3_tx_lock);
+ skb_queue_head_init(&mvm->d0i3_tx);
+ init_waitqueue_head(&mvm->d0i3_exit_waitq);
 
  SET_IEEE80211_DEV(mvm->hw, mvm->trans->dev);
 
@@ -389,21 +464,43 @@ iwl_op_mode_mvm_start(struct iwl_trans *trans, const struct iwl_cfg *cfg,
  IWL_INFO(mvm, "Detected %s, REV=0x%X\n",
    mvm->cfg->name, mvm->trans->hw_rev);
 
- err = iwl_trans_start_hw(mvm->trans);
- if (err)
-  goto out_free;
+ min_backoff = calc_min_backoff(trans, cfg);
+ iwl_mvm_tt_initialize(mvm, min_backoff);
+ /* set the nvm_file_name according to priority */
+ if (iwlwifi_mod_params.nvm_file)
+  mvm->nvm_file_name = iwlwifi_mod_params.nvm_file;
+ else
+  mvm->nvm_file_name = mvm->cfg->default_nvm_file;
 
- mutex_lock(&mvm->mutex);
- err = iwl_run_init_mvm_ucode(mvm, true);
- mutex_unlock(&mvm->mutex);
- if (err && !iwlmvm_mod_params.init_dbg) {
-  IWL_ERR(mvm, "Failed to run INIT ucode: %d\n", err);
+ if (WARN(cfg->no_power_up_nic_in_init && !mvm->nvm_file_name,
+   "not allowing power-up and not having nvm_file\n"))
   goto out_free;
- }
 
- /* Stop the hw after the ALIVE and NVM has been read */
- if (!iwlmvm_mod_params.init_dbg)
-  iwl_trans_stop_hw(mvm->trans, false);
+ /*
+  * Even if nvm exists in the nvm_file driver should read agin the nvm
+  * from the nic because there might be entries that exist in the OTP
+  * and not in the file.
+  * for nics with no_power_up_nic_in_init: rely completley on nvm_file
+  */
+ if (cfg->no_power_up_nic_in_init && mvm->nvm_file_name) {
+  err = iwl_nvm_init(mvm, false);
+  if (err)
+   goto out_free;
+ } else {
+  err = iwl_trans_start_hw(mvm->trans);
+  if (err)
+   goto out_free;
+
+  mutex_lock(&mvm->mutex);
+  err = iwl_run_init_mvm_ucode(mvm, true);
+  iwl_trans_stop_device(trans);
+  mutex_unlock(&mvm->mutex);
+  /* returns 0 if successful, 1 if success but in rfkill */
+  if (err < 0 && !iwlmvm_mod_params.init_dbg) {
+   IWL_ERR(mvm, "Failed to run INIT ucode: %d\n", err);
+   goto out_free;
+  }
+ }
 
  scan_size = sizeof(struct iwl_scan_cmd) +
   mvm->fw->ucode_capa.max_probe_length +
@@ -420,14 +517,21 @@ iwl_op_mode_mvm_start(struct iwl_trans *trans, const struct iwl_cfg *cfg,
  if (err)
   goto out_unregister;
 
+ memset(&mvm->rx_stats, 0, sizeof(struct mvm_statistics_rx));
+
+ /* rpm starts with a taken ref. only set the appropriate bit here. */
+ set_bit(IWL_MVM_REF_UCODE_DOWN, mvm->ref_bitmap);
+
  return op_mode;
 
  out_unregister:
  ieee80211_unregister_hw(mvm->hw);
+ iwl_mvm_leds_exit(mvm);
  out_free:
  iwl_phy_db_free(mvm->phy_db);
  kfree(mvm->scan_cmd);
- iwl_trans_stop_hw(trans, true);
+ if (!cfg->no_power_up_nic_in_init || !mvm->nvm_file_name)
+  iwl_trans_op_mode_leave(trans);
  ieee80211_free_hw(mvm->hw);
  return NULL;
 }
@@ -439,17 +543,28 @@ static void iwl_op_mode_mvm_stop(struct iwl_op_mode *op_mode)
 
  iwl_mvm_leds_exit(mvm);
 
+ iwl_mvm_tt_exit(mvm);
+
  ieee80211_unregister_hw(mvm->hw);
 
  kfree(mvm->scan_cmd);
+ vfree(mvm->fw_error_dump);
+ kfree(mvm->fw_error_sram);
+ kfree(mvm->fw_error_rxf);
+ kfree(mvm->mcast_filter_cmd);
+ mvm->mcast_filter_cmd = NULL;
+
+#if defined(CONFIG_PM_SLEEP) && defined(CONFIG_IWLWIFI_DEBUGFS)
+ kfree(mvm->d3_resume_sram);
+#endif
 
- iwl_trans_stop_hw(mvm->trans, true);
+ iwl_trans_op_mode_leave(mvm->trans);
 
  iwl_phy_db_free(mvm->phy_db);
  mvm->phy_db = NULL;
 
  iwl_free_nvm_data(mvm->nvm_data);
- for (i = 0; i < NVM_NUM_OF_SECTIONS; i++)
+ for (i = 0; i < NVM_MAX_NUM_SECTIONS; i++)
   kfree(mvm->nvm_sections[i].data);
 
  ieee80211_free_hw(mvm->hw);
@@ -589,7 +704,17 @@ static void iwl_mvm_wake_sw_queue(struct iwl_op_mode *op_mode, int queue)
  ieee80211_wake_queue(mvm->hw, mq);
 }
 
-static void iwl_mvm_set_hw_rfkill_state(struct iwl_op_mode *op_mode, bool state)
+void iwl_mvm_set_hw_ctkill_state(struct iwl_mvm *mvm, bool state)
+{
+ if (state)
+  set_bit(IWL_MVM_STATUS_HW_CTKILL, &mvm->status);
+ else
+  clear_bit(IWL_MVM_STATUS_HW_CTKILL, &mvm->status);
+
+ wiphy_rfkill_set_hw_state(mvm->hw->wiphy, iwl_mvm_is_radio_killed(mvm));
+}
+
+static bool iwl_mvm_set_hw_rfkill_state(struct iwl_op_mode *op_mode, bool state)
 {
  struct iwl_mvm *mvm = IWL_OP_MODE_GET_MVM(op_mode);
 
@@ -598,7 +723,9 @@ static void iwl_mvm_set_hw_rfkill_state(struct iwl_op_mode *op_mode, bool state)
  else
   clear_bit(IWL_MVM_STATUS_HW_RFKILL, &mvm->status);
 
- wiphy_rfkill_set_hw_state(mvm->hw->wiphy, state);
+ wiphy_rfkill_set_hw_state(mvm->hw->wiphy, iwl_mvm_is_radio_killed(mvm));
+
+ return state && mvm->cur_ucode != IWL_UCODE_INIT;
 }
 
 static void iwl_mvm_free_skb(struct iwl_op_mode *op_mode, struct sk_buff *skb)
@@ -611,47 +738,165 @@ static void iwl_mvm_free_skb(struct iwl_op_mode *op_mode, struct sk_buff *skb)
  ieee80211_free_txskb(mvm->hw, skb);
 }
 
+struct iwl_mvm_reprobe {
+ struct device *dev;
+ struct work_struct work;
+};
+
+static void iwl_mvm_reprobe_wk(struct work_struct *wk)
+{
+ struct iwl_mvm_reprobe *reprobe;
+
+ reprobe = container_of(wk, struct iwl_mvm_reprobe, work);
+ if (device_reprobe(reprobe->dev))
+  dev_err(reprobe->dev, "reprobe failed!\n");
+ kfree(reprobe);
+ module_put(THIS_MODULE);
+}
+
 static void iwl_mvm_nic_restart(struct iwl_mvm *mvm)
 {
  iwl_abort_notification_waits(&mvm->notif_wait);
 
  /*
+  * This is a bit racy, but worst case we tell mac80211 about
+  * a stopped/aborted scan when that was already done which
+  * is not a problem. It is necessary to abort any os scan
+  * here because mac80211 requires having the scan cleared
+  * before restarting.
+  * We'll reset the scan_status to NONE in restart cleanup in
+  * the next start() call from mac80211. If restart isn't called
+  * (no fw restart) scan status will stay busy.
+  */
+ switch (mvm->scan_status) {
+ case IWL_MVM_SCAN_NONE:
+  break;
+ case IWL_MVM_SCAN_OS:
+  ieee80211_scan_completed(mvm->hw, true);
+  break;
+ case IWL_MVM_SCAN_SCHED:
+  /* Sched scan will be restarted by mac80211 in restart_hw. */
+  if (!mvm->restart_fw)
+   ieee80211_sched_scan_stopped(mvm->hw);
+  break;
+ }
+
+ /*
   * If we're restarting already, don't cycle restarts.
   * If INIT fw asserted, it will likely fail again.
   * If WoWLAN fw asserted, don't restart either, mac80211
   * can't recover this since we're already half suspended.
   */
  if (test_and_set_bit(IWL_MVM_STATUS_IN_HW_RESTART, &mvm->status)) {
-  IWL_ERR(mvm, "Firmware error during reconfiguration! Abort.\n");
- } else if (mvm->cur_ucode == IWL_UCODE_REGULAR &&
-     iwlwifi_mod_params.restart_fw) {
+  struct iwl_mvm_reprobe *reprobe;
+
+  IWL_ERR(mvm,
+   "Firmware error during reconfiguration - reprobe!\n");
+
   /*
-   * This is a bit racy, but worst case we tell mac80211 about
-   * a stopped/aborted (sched) scan when that was already done
-   * which is not a problem. It is necessary to abort any scan
-   * here because mac80211 requires having the scan cleared
-   * before restarting.
-   * We'll reset the scan_status to NONE in restart cleanup in
-   * the next start() call from mac80211.
+   * get a module reference to avoid doing this while unloading
+   * anyway and to avoid scheduling a work with code that's
+   * being removed.
    */
-  switch (mvm->scan_status) {
-  case IWL_MVM_SCAN_NONE:
-   break;
-  case IWL_MVM_SCAN_OS:
-   ieee80211_scan_completed(mvm->hw, true);
-   break;
+  if (!try_module_get(THIS_MODULE)) {
+   IWL_ERR(mvm, "Module is being unloaded - abort\n");
+   return;
   }
 
+  reprobe = kzalloc(sizeof(*reprobe), GFP_ATOMIC);
+  if (!reprobe) {
+   module_put(THIS_MODULE);
+   return;
+  }
+  reprobe->dev = mvm->trans->dev;
+  INIT_WORK(&reprobe->work, iwl_mvm_reprobe_wk);
+  schedule_work(&reprobe->work);
+ } else if (mvm->cur_ucode == IWL_UCODE_REGULAR && mvm->restart_fw) {
+  /* don't let the transport/FW power down */
+  iwl_mvm_ref(mvm, IWL_MVM_REF_UCODE_DOWN);
+
+  if (mvm->restart_fw > 0)
+   mvm->restart_fw--;
   ieee80211_restart_hw(mvm->hw);
  }
 }
 
+#ifdef CONFIG_IWLWIFI_DEBUGFS
+void iwl_mvm_fw_error_dump(struct iwl_mvm *mvm)
+{
+ struct iwl_fw_error_dump_file *dump_file;
+ struct iwl_fw_error_dump_data *dump_data;
+ u32 file_len;
+ u32 trans_len;
+
+ lockdep_assert_held(&mvm->mutex);
+
+ if (mvm->fw_error_dump)
+  return;
+
+ file_len = mvm->fw_error_sram_len +
+     mvm->fw_error_rxf_len +
+     sizeof(*dump_file) +
+     sizeof(*dump_data) * 2;
+
+ trans_len = iwl_trans_dump_data(mvm->trans, NULL, 0);
+ if (trans_len)
+  file_len += trans_len;
+
+ dump_file = vmalloc(file_len);
+ if (!dump_file)
+  return;
+
+ mvm->fw_error_dump = dump_file;
+
+ dump_file->barker = cpu_to_le32(IWL_FW_ERROR_DUMP_BARKER);
+ dump_file->file_len = cpu_to_le32(file_len);
+ dump_data = (void *)dump_file->data;
+ dump_data->type = cpu_to_le32(IWL_FW_ERROR_DUMP_RXF);
+ dump_data->len = cpu_to_le32(mvm->fw_error_rxf_len);
+ memcpy(dump_data->data, mvm->fw_error_rxf, mvm->fw_error_rxf_len);
+
+ dump_data = iwl_mvm_fw_error_next_data(dump_data);
+ dump_data->type = cpu_to_le32(IWL_FW_ERROR_DUMP_SRAM);
+ dump_data->len = cpu_to_le32(mvm->fw_error_sram_len);
+
+ /*
+  * No need for lock since at the stage the FW isn't loaded. So it
+  * can't assert - we are the only one who can possibly be accessing
+  * mvm->fw_error_sram right now.
+  */
+ memcpy(dump_data->data, mvm->fw_error_sram, mvm->fw_error_sram_len);
+
+ kfree(mvm->fw_error_rxf);
+ mvm->fw_error_rxf = NULL;
+ mvm->fw_error_rxf_len = 0;
+
+ kfree(mvm->fw_error_sram);
+ mvm->fw_error_sram = NULL;
+ mvm->fw_error_sram_len = 0;
+
+ if (trans_len) {
+  void *buf = iwl_mvm_fw_error_next_data(dump_data);
+  u32 real_trans_len = iwl_trans_dump_data(mvm->trans, buf,
+        trans_len);
+  dump_data = (void *)((u8 *)buf + real_trans_len);
+  dump_file->file_len =
+   cpu_to_le32(file_len - trans_len + real_trans_len);
+ }
+}
+#endif
+
 static void iwl_mvm_nic_error(struct iwl_op_mode *op_mode)
 {
  struct iwl_mvm *mvm = IWL_OP_MODE_GET_MVM(op_mode);
 
  iwl_mvm_dump_nic_error_log(mvm);
 
+#ifdef CONFIG_IWLWIFI_DEBUGFS
+ iwl_mvm_fw_error_sram_dump(mvm);
+ iwl_mvm_fw_error_rxf_dump(mvm);
+#endif
+
  iwl_mvm_nic_restart(mvm);
 }
 
@@ -663,6 +908,351 @@ static void iwl_mvm_cmd_queue_full(struct iwl_op_mode *op_mode)
  iwl_mvm_nic_restart(mvm);
 }
 
+struct iwl_d0i3_iter_data {
+ struct iwl_mvm *mvm;
+ u8 ap_sta_id;
+ u8 vif_count;
+ u8 offloading_tid;
+ bool disable_offloading;
+};
+
+static bool iwl_mvm_disallow_offloading(struct iwl_mvm *mvm,
+     struct ieee80211_vif *vif,
+     struct iwl_d0i3_iter_data *iter_data)
+{
+ struct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);
+ struct ieee80211_sta *ap_sta;
+ struct iwl_mvm_sta *mvmsta;
+ u32 available_tids = 0;
+ u8 tid;
+
+ if (WARN_ON(vif->type != NL80211_IFTYPE_STATION ||
+      mvmvif->ap_sta_id == IWL_MVM_STATION_COUNT))
+  return false;
+
+ ap_sta = rcu_dereference(mvm->fw_id_to_mac_id[mvmvif->ap_sta_id]);
+ if (IS_ERR_OR_NULL(ap_sta))
+  return false;
+
+ mvmsta = iwl_mvm_sta_from_mac80211(ap_sta);
+ spin_lock_bh(&mvmsta->lock);
+ for (tid = 0; tid < IWL_MAX_TID_COUNT; tid++) {
+  struct iwl_mvm_tid_data *tid_data = &mvmsta->tid_data[tid];
+
+  /*
+   * in case of pending tx packets, don't use this tid
+   * for offloading in order to prevent reuse of the same
+   * qos seq counters.
+   */
+  if (iwl_mvm_tid_queued(tid_data))
+   continue;
+
+  if (tid_data->state != IWL_AGG_OFF)
+   continue;
+
+  available_tids |= BIT(tid);
+ }
+ spin_unlock_bh(&mvmsta->lock);
+
+ /*
+  * disallow protocol offloading if we have no available tid
+  * (with no pending frames and no active aggregation,
+  * as we don't handle "holes" properly - the scheduler needs the
+  * frame's seq number and TFD index to match)
+  */
+ if (!available_tids)
+  return true;
+
+ /* for simplicity, just use the first available tid */
+ iter_data->offloading_tid = ffs(available_tids) - 1;
+ return false;
+}
+
+static void iwl_mvm_enter_d0i3_iterator(void *_data, u8 *mac,
+     struct ieee80211_vif *vif)
+{
+ struct iwl_d0i3_iter_data *data = _data;
+ struct iwl_mvm *mvm = data->mvm;
+ struct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);
+ u32 flags = CMD_ASYNC | CMD_HIGH_PRIO | CMD_SEND_IN_IDLE;
+
+ IWL_DEBUG_RPM(mvm, "entering D0i3 - vif %pM\n", vif->addr);
+ if (vif->type != NL80211_IFTYPE_STATION ||
+     !vif->bss_conf.assoc)
+  return;
+
+ /*
+  * in case of pending tx packets or active aggregations,
+  * avoid offloading features in order to prevent reuse of
+  * the same qos seq counters.
+  */
+ if (iwl_mvm_disallow_offloading(mvm, vif, data))
+  data->disable_offloading = true;
+
+ iwl_mvm_update_d0i3_power_mode(mvm, vif, true, flags);
+ iwl_mvm_send_proto_offload(mvm, vif, data->disable_offloading, flags);
+
+ /*
+  * on init/association, mvm already configures POWER_TABLE_CMD
+  * and REPLY_MCAST_FILTER_CMD, so currently don't
+  * reconfigure them (we might want to use different
+  * params later on, though).
+  */
+ data->ap_sta_id = mvmvif->ap_sta_id;
+ data->vif_count++;
+}
+
+static void iwl_mvm_set_wowlan_data(struct iwl_mvm *mvm,
+        struct iwl_wowlan_config_cmd_v3 *cmd,
+        struct iwl_d0i3_iter_data *iter_data)
+{
+ struct ieee80211_sta *ap_sta;
+ struct iwl_mvm_sta *mvm_ap_sta;
+
+ if (iter_data->ap_sta_id == IWL_MVM_STATION_COUNT)
+  return;
+
+ rcu_read_lock();
+
+ ap_sta = rcu_dereference(mvm->fw_id_to_mac_id[iter_data->ap_sta_id]);
+ if (IS_ERR_OR_NULL(ap_sta))
+  goto out;
+
+ mvm_ap_sta = iwl_mvm_sta_from_mac80211(ap_sta);
+ cmd->common.is_11n_connection = ap_sta->ht_cap.ht_supported;
+ cmd->offloading_tid = iter_data->offloading_tid;
+
+ /*
+  * The d0i3 uCode takes care of the nonqos counters,
+  * so configure only the qos seq ones.
+  */
+ iwl_mvm_set_wowlan_qos_seq(mvm_ap_sta, &cmd->common);
+out:
+ rcu_read_unlock();
+}
+static int iwl_mvm_enter_d0i3(struct iwl_op_mode *op_mode)
+{
+ struct iwl_mvm *mvm = IWL_OP_MODE_GET_MVM(op_mode);
+ u32 flags = CMD_ASYNC | CMD_HIGH_PRIO | CMD_SEND_IN_IDLE;
+ int ret;
+ struct iwl_d0i3_iter_data d0i3_iter_data = {
+  .mvm = mvm,
+ };
+ struct iwl_wowlan_config_cmd_v3 wowlan_config_cmd = {
+  .common = {
+   .wakeup_filter =
+    cpu_to_le32(IWL_WOWLAN_WAKEUP_RX_FRAME |
+         IWL_WOWLAN_WAKEUP_BEACON_MISS |
+         IWL_WOWLAN_WAKEUP_LINK_CHANGE |
+         IWL_WOWLAN_WAKEUP_BCN_FILTERING),
+  },
+ };
+ struct iwl_d3_manager_config d3_cfg_cmd = {
+  .min_sleep_time = cpu_to_le32(1000),
+ };
+
+ IWL_DEBUG_RPM(mvm, "MVM entering D0i3\n");
+
+ /* make sure we have no running tx while configuring the qos */
+ set_bit(IWL_MVM_STATUS_IN_D0I3, &mvm->status);
+ synchronize_net();
+
+ ieee80211_iterate_active_interfaces_atomic(mvm->hw,
+         IEEE80211_IFACE_ITER_NORMAL,
+         iwl_mvm_enter_d0i3_iterator,
+         &d0i3_iter_data);
+ if (d0i3_iter_data.vif_count == 1) {
+  mvm->d0i3_ap_sta_id = d0i3_iter_data.ap_sta_id;
+  mvm->d0i3_offloading = !d0i3_iter_data.disable_offloading;
+ } else {
+  WARN_ON_ONCE(d0i3_iter_data.vif_count > 1);
+  mvm->d0i3_ap_sta_id = IWL_MVM_STATION_COUNT;
+  mvm->d0i3_offloading = false;
+ }
+
+ iwl_mvm_set_wowlan_data(mvm, &wowlan_config_cmd, &d0i3_iter_data);
+ ret = iwl_mvm_send_cmd_pdu(mvm, WOWLAN_CONFIGURATION, flags,
+       sizeof(wowlan_config_cmd),
+       &wowlan_config_cmd);
+ if (ret)
+  return ret;
+
+ return iwl_mvm_send_cmd_pdu(mvm, D3_CONFIG_CMD,
+        flags | CMD_MAKE_TRANS_IDLE,
+        sizeof(d3_cfg_cmd), &d3_cfg_cmd);
+}
+
+static void iwl_mvm_exit_d0i3_iterator(void *_data, u8 *mac,
+           struct ieee80211_vif *vif)
+{
+ struct iwl_mvm *mvm = _data;
+ u32 flags = CMD_ASYNC | CMD_HIGH_PRIO;
+
+ IWL_DEBUG_RPM(mvm, "exiting D0i3 - vif %pM\n", vif->addr);
+ if (vif->type != NL80211_IFTYPE_STATION ||
+     !vif->bss_conf.assoc)
+  return;
+
+ iwl_mvm_update_d0i3_power_mode(mvm, vif, false, flags);
+}
+
+static void iwl_mvm_d0i3_disconnect_iter(void *data, u8 *mac,
+      struct ieee80211_vif *vif)
+{
+ struct iwl_mvm *mvm = data;
+ struct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);
+
+ if (vif->type == NL80211_IFTYPE_STATION && vif->bss_conf.assoc &&
+     mvm->d0i3_ap_sta_id == mvmvif->ap_sta_id)
+  ieee80211_connection_loss(vif);
+}
+
+void iwl_mvm_d0i3_enable_tx(struct iwl_mvm *mvm, __le16 *qos_seq)
+{
+ struct ieee80211_sta *sta = NULL;
+ struct iwl_mvm_sta *mvm_ap_sta;
+ int i;
+ bool wake_queues = false;
+
+ lockdep_assert_held(&mvm->mutex);
+
+ spin_lock_bh(&mvm->d0i3_tx_lock);
+
+ if (mvm->d0i3_ap_sta_id == IWL_MVM_STATION_COUNT)
+  goto out;
+
+ IWL_DEBUG_RPM(mvm, "re-enqueue packets\n");
+
+ /* get the sta in order to update seq numbers and re-enqueue skbs */
+ sta = rcu_dereference_protected(
+   mvm->fw_id_to_mac_id[mvm->d0i3_ap_sta_id],
+   lockdep_is_held(&mvm->mutex));
+
+ if (IS_ERR_OR_NULL(sta)) {
+  sta = NULL;
+  goto out;
+ }
+
+ if (mvm->d0i3_offloading && qos_seq) {
+  /* update qos seq numbers if offloading was enabled */
+  mvm_ap_sta = (struct iwl_mvm_sta *)sta->drv_priv;
+  for (i = 0; i < IWL_MAX_TID_COUNT; i++) {
+   u16 seq = le16_to_cpu(qos_seq[i]);
+   /* firmware stores last-used one, we store next one */
+   seq += 0x10;
+   mvm_ap_sta->tid_data[i].seq_number = seq;
+  }
+ }
+out:
+ /* re-enqueue (or drop) all packets */
+ while (!skb_queue_empty(&mvm->d0i3_tx)) {
+  struct sk_buff *skb = __skb_dequeue(&mvm->d0i3_tx);
+
+  if (!sta || iwl_mvm_tx_skb(mvm, skb, sta))
+   ieee80211_free_txskb(mvm->hw, skb);
+
+  /* if the skb_queue is not empty, we need to wake queues */
+  wake_queues = true;
+ }
+ clear_bit(IWL_MVM_STATUS_IN_D0I3, &mvm->status);
+ wake_up(&mvm->d0i3_exit_waitq);
+ mvm->d0i3_ap_sta_id = IWL_MVM_STATION_COUNT;
+ if (wake_queues)
+  ieee80211_wake_queues(mvm->hw);
+
+ spin_unlock_bh(&mvm->d0i3_tx_lock);
+}
+
+static void iwl_mvm_d0i3_exit_work(struct work_struct *wk)
+{
+ struct iwl_mvm *mvm = container_of(wk, struct iwl_mvm, d0i3_exit_work);
+ struct iwl_host_cmd get_status_cmd = {
+  .id = WOWLAN_GET_STATUSES,
+  .flags = CMD_HIGH_PRIO | CMD_WANT_SKB,
+ };
+ struct iwl_wowlan_status *status;
+ int ret;
+ u32 disconnection_reasons, wakeup_reasons;
+ __le16 *qos_seq = NULL;
+
+ mutex_lock(&mvm->mutex);
+ ret = iwl_mvm_send_cmd(mvm, &get_status_cmd);
+ if (ret)
+  goto out;
+
+ if (!get_status_cmd.resp_pkt)
+  goto out;
+
+ status = (void *)get_status_cmd.resp_pkt->data;
+ wakeup_reasons = le32_to_cpu(status->wakeup_reasons);
+ qos_seq = status->qos_seq_ctr;
+
+ IWL_DEBUG_RPM(mvm, "wakeup reasons: 0x%x\n", wakeup_reasons);
+
+ disconnection_reasons =
+  IWL_WOWLAN_WAKEUP_BY_DISCONNECTION_ON_MISSED_BEACON |
+  IWL_WOWLAN_WAKEUP_BY_DISCONNECTION_ON_DEAUTH;
+ if (wakeup_reasons & disconnection_reasons)
+  ieee80211_iterate_active_interfaces(
+   mvm->hw, IEEE80211_IFACE_ITER_NORMAL,
+   iwl_mvm_d0i3_disconnect_iter, mvm);
+
+ iwl_free_resp(&get_status_cmd);
+out:
+ iwl_mvm_d0i3_enable_tx(mvm, qos_seq);
+ iwl_mvm_unref(mvm, IWL_MVM_REF_EXIT_WORK);
+ mutex_unlock(&mvm->mutex);
+}
+
+int _iwl_mvm_exit_d0i3(struct iwl_mvm *mvm)
+{
+ u32 flags = CMD_ASYNC | CMD_HIGH_PRIO | CMD_SEND_IN_IDLE |
+      CMD_WAKE_UP_TRANS;
+ int ret;
+
+ IWL_DEBUG_RPM(mvm, "MVM exiting D0i3\n");
+
+ mutex_lock(&mvm->d0i3_suspend_mutex);
+ if (test_bit(D0I3_DEFER_WAKEUP, &mvm->d0i3_suspend_flags)) {
+  IWL_DEBUG_RPM(mvm, "Deferring d0i3 exit until resume\n");
+  __set_bit(D0I3_PENDING_WAKEUP, &mvm->d0i3_suspend_flags);
+  mutex_unlock(&mvm->d0i3_suspend_mutex);
+  return 0;
+ }
+ mutex_unlock(&mvm->d0i3_suspend_mutex);
+
+ ret = iwl_mvm_send_cmd_pdu(mvm, D0I3_END_CMD, flags, 0, NULL);
+ if (ret)
+  goto out;
+
+ ieee80211_iterate_active_interfaces_atomic(mvm->hw,
+         IEEE80211_IFACE_ITER_NORMAL,
+         iwl_mvm_exit_d0i3_iterator,
+         mvm);
+out:
+ schedule_work(&mvm->d0i3_exit_work);
+ return ret;
+}
+
+static int iwl_mvm_exit_d0i3(struct iwl_op_mode *op_mode)
+{
+ struct iwl_mvm *mvm = IWL_OP_MODE_GET_MVM(op_mode);
+
+ iwl_mvm_ref(mvm, IWL_MVM_REF_EXIT_WORK);
+ return _iwl_mvm_exit_d0i3(mvm);
+}
+
+static void iwl_mvm_napi_add(struct iwl_op_mode *op_mode,
+        struct napi_struct *napi,
+        struct net_device *napi_dev,
+        int (*poll)(struct napi_struct *, int),
+        int weight)
+{
+ struct iwl_mvm *mvm = IWL_OP_MODE_GET_MVM(op_mode);
+
+ ieee80211_napi_add(mvm->hw, napi, napi_dev, poll, weight);
+}
+
 static const struct iwl_op_mode_ops iwl_mvm_ops = {
  .start = iwl_op_mode_mvm_start,
  .stop = iwl_op_mode_mvm_stop,
@@ -674,4 +1264,7 @@ static const struct iwl_op_mode_ops iwl_mvm_ops = {
  .nic_error = iwl_mvm_nic_error,
  .cmd_queue_full = iwl_mvm_cmd_queue_full,
  .nic_config = iwl_mvm_nic_config,
+ .enter_d0i3 = iwl_mvm_enter_d0i3,
+ .exit_d0i3 = iwl_mvm_exit_d0i3,
+ .napi_add = iwl_mvm_napi_add,
 };
diff --git a/drivers/net/wireless/iwlwifi/mvm/phy-ctxt.c b/drivers/net/wireless/iwlwifi/mvm/phy-ctxt.c
index a28a1d1..539f3a9 100644
--- a/drivers/net/wireless/iwlwifi/mvm/phy-ctxt.c
+++ b/drivers/net/wireless/iwlwifi/mvm/phy-ctxt.c
@@ -5,7 +5,7 @@
  *
  * GPL LICENSE SUMMARY
  *
- * Copyright(c) 2012 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2012 - 2014 Intel Corporation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of version 2 of the GNU General Public License as
@@ -30,7 +30,7 @@
  *
  * BSD LICENSE
  *
- * Copyright(c) 2012 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2012 - 2014 Intel Corporation. All rights reserved.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -156,13 +156,25 @@ static void iwl_mvm_phy_ctxt_cmd_data(struct iwl_mvm *mvm,
  idle_cnt = chains_static;
  active_cnt = chains_dynamic;
 
- cmd->rxchain_info = cpu_to_le32(iwl_fw_valid_rx_ant(mvm->fw) <<
+ /* In scenarios where we only ever use a single-stream rates,
+  * i.e. legacy 11b/g/a associations, single-stream APs or even
+  * static SMPS, enable both chains to get diversity, improving
+  * the case where we're far enough from the AP that attenuation
+  * between the two antennas is sufficiently different to impact
+  * performance.
+  */
+ if (active_cnt == 1 && iwl_mvm_rx_diversity_allowed(mvm)) {
+  idle_cnt = 2;
+  active_cnt = 2;
+ }
+
+ cmd->rxchain_info = cpu_to_le32(mvm->fw->valid_rx_ant <<
      PHY_RX_CHAIN_VALID_POS);
  cmd->rxchain_info |= cpu_to_le32(idle_cnt << PHY_RX_CHAIN_CNT_POS);
  cmd->rxchain_info |= cpu_to_le32(active_cnt <<
       PHY_RX_CHAIN_MIMO_CNT_POS);
 
- cmd->txchain_info = cpu_to_le32(iwl_fw_valid_tx_ant(mvm->fw));
+ cmd->txchain_info = cpu_to_le32(mvm->fw->valid_tx_ant);
 }
 
 /*
@@ -187,7 +199,7 @@ static int iwl_mvm_phy_ctxt_apply(struct iwl_mvm *mvm,
  iwl_mvm_phy_ctxt_cmd_data(mvm, &cmd, chandef,
       chains_static, chains_dynamic);
 
- ret = iwl_mvm_send_cmd_pdu(mvm, PHY_CONTEXT_CMD, CMD_SYNC,
+ ret = iwl_mvm_send_cmd_pdu(mvm, PHY_CONTEXT_CMD, 0,
        sizeof(struct iwl_phy_context_cmd),
        &cmd);
  if (ret)
@@ -195,21 +207,6 @@ static int iwl_mvm_phy_ctxt_apply(struct iwl_mvm *mvm,
  return ret;
 }
 
-
-struct phy_ctx_used_data {
- unsigned long used[BITS_TO_LONGS(NUM_PHY_CTX)];
-};
-
-static void iwl_mvm_phy_ctx_used_iter(struct ieee80211_hw *hw,
-          struct ieee80211_chanctx_conf *ctx,
-          void *_data)
-{
- struct phy_ctx_used_data *data = _data;
- struct iwl_mvm_phy_ctxt *phy_ctxt = (void *)ctx->drv_priv;
-
- __set_bit(phy_ctxt->id, data->used);
-}
-
 /*
  * Send a command to add a PHY context based on the current HW configuration.
  */
@@ -217,37 +214,28 @@ int iwl_mvm_phy_ctxt_add(struct iwl_mvm *mvm, struct iwl_mvm_phy_ctxt *ctxt,
     struct cfg80211_chan_def *chandef,
     u8 chains_static, u8 chains_dynamic)
 {
- struct phy_ctx_used_data data = {
-  .used = { },
- };
-
- /*
-  * If this is a regular PHY context (not the ROC one)
-  * skip the ROC PHY context's ID.
-  */
- if (ctxt != &mvm->phy_ctxt_roc)
-  __set_bit(mvm->phy_ctxt_roc.id, data.used);
-
+ WARN_ON(!test_bit(IWL_MVM_STATUS_IN_HW_RESTART, &mvm->status) &&
+  ctxt->ref);
  lockdep_assert_held(&mvm->mutex);
- ctxt->color++;
-
- if (!test_bit(IWL_MVM_STATUS_IN_HW_RESTART, &mvm->status)) {
-  ieee80211_iter_chan_contexts_atomic(
-   mvm->hw, iwl_mvm_phy_ctx_used_iter, &data);
-
-  ctxt->id = find_first_zero_bit(data.used, NUM_PHY_CTX);
-  if (WARN_ONCE(ctxt->id == NUM_PHY_CTX,
-         "Failed to init PHY context - no free ID!\n"))
-   return -EIO;
- }
 
  ctxt->channel = chandef->chan;
+
  return iwl_mvm_phy_ctxt_apply(mvm, ctxt, chandef,
           chains_static, chains_dynamic,
           FW_CTXT_ACTION_ADD, 0);
 }
 
 /*
+ * Update the number of references to the given PHY context. This is valid only
+ * in case the PHY context was already created, i.e., its reference count > 0.
+ */
+void iwl_mvm_phy_ctxt_ref(struct iwl_mvm *mvm, struct iwl_mvm_phy_ctxt *ctxt)
+{
+ lockdep_assert_held(&mvm->mutex);
+ ctxt->ref++;
+}
+
+/*
  * Send a command to modify the PHY context based on the current HW
  * configuration. Note that the function does not check that the configuration
  * changed.
@@ -264,23 +252,12 @@ int iwl_mvm_phy_ctxt_changed(struct iwl_mvm *mvm, struct iwl_mvm_phy_ctxt *ctxt,
           FW_CTXT_ACTION_MODIFY, 0);
 }
 
-/*
- * Send a command to the FW to remove the given phy context.
- * Once the command is sent, regardless of success or failure, the context is
- * marked as invalid
- */
-void iwl_mvm_phy_ctxt_remove(struct iwl_mvm *mvm, struct iwl_mvm_phy_ctxt *ctxt)
+void iwl_mvm_phy_ctxt_unref(struct iwl_mvm *mvm, struct iwl_mvm_phy_ctxt *ctxt)
 {
- struct iwl_phy_context_cmd cmd;
- int ret;
-
  lockdep_assert_held(&mvm->mutex);
 
- iwl_mvm_phy_ctxt_cmd_hdr(ctxt, &cmd, FW_CTXT_ACTION_REMOVE, 0);
- ret = iwl_mvm_send_cmd_pdu(mvm, PHY_CONTEXT_CMD, CMD_SYNC,
-       sizeof(struct iwl_phy_context_cmd),
-       &cmd);
- if (ret)
-  IWL_ERR(mvm, "Failed to send PHY remove: ctxt id=%d\n",
-   ctxt->id);
+ if (WARN_ON_ONCE(!ctxt))
+  return;
+
+ ctxt->ref--;
 }
diff --git a/drivers/net/wireless/iwlwifi/mvm/power.c b/drivers/net/wireless/iwlwifi/mvm/power.c
index ed77e43..c182a8b 100644
--- a/drivers/net/wireless/iwlwifi/mvm/power.c
+++ b/drivers/net/wireless/iwlwifi/mvm/power.c
@@ -5,7 +5,7 @@
  *
  * GPL LICENSE SUMMARY
  *
- * Copyright(c) 2012 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2012 - 2014 Intel Corporation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of version 2 of the GNU General Public License as
@@ -30,7 +30,7 @@
  *
  * BSD LICENSE
  *
- * Copyright(c) 2012 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2012 - 2014 Intel Corporation. All rights reserved.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -64,7 +64,6 @@
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/slab.h>
-#include <linux/init.h>
 
 #include <net/mac80211.h>
 
@@ -75,27 +74,232 @@
 
 #define POWER_KEEP_ALIVE_PERIOD_SEC    25
 
+static
+int iwl_mvm_beacon_filter_send_cmd(struct iwl_mvm *mvm,
+       struct iwl_beacon_filter_cmd *cmd,
+       u32 flags)
+{
+ IWL_DEBUG_POWER(mvm, "ba_enable_beacon_abort is: %d\n",
+   le32_to_cpu(cmd->ba_enable_beacon_abort));
+ IWL_DEBUG_POWER(mvm, "ba_escape_timer is: %d\n",
+   le32_to_cpu(cmd->ba_escape_timer));
+ IWL_DEBUG_POWER(mvm, "bf_debug_flag is: %d\n",
+   le32_to_cpu(cmd->bf_debug_flag));
+ IWL_DEBUG_POWER(mvm, "bf_enable_beacon_filter is: %d\n",
+   le32_to_cpu(cmd->bf_enable_beacon_filter));
+ IWL_DEBUG_POWER(mvm, "bf_energy_delta is: %d\n",
+   le32_to_cpu(cmd->bf_energy_delta));
+ IWL_DEBUG_POWER(mvm, "bf_escape_timer is: %d\n",
+   le32_to_cpu(cmd->bf_escape_timer));
+ IWL_DEBUG_POWER(mvm, "bf_roaming_energy_delta is: %d\n",
+   le32_to_cpu(cmd->bf_roaming_energy_delta));
+ IWL_DEBUG_POWER(mvm, "bf_roaming_state is: %d\n",
+   le32_to_cpu(cmd->bf_roaming_state));
+ IWL_DEBUG_POWER(mvm, "bf_temp_threshold is: %d\n",
+   le32_to_cpu(cmd->bf_temp_threshold));
+ IWL_DEBUG_POWER(mvm, "bf_temp_fast_filter is: %d\n",
+   le32_to_cpu(cmd->bf_temp_fast_filter));
+ IWL_DEBUG_POWER(mvm, "bf_temp_slow_filter is: %d\n",
+   le32_to_cpu(cmd->bf_temp_slow_filter));
+
+ return iwl_mvm_send_cmd_pdu(mvm, REPLY_BEACON_FILTERING_CMD, flags,
+        sizeof(struct iwl_beacon_filter_cmd), cmd);
+}
+
+static
+void iwl_mvm_beacon_filter_set_cqm_params(struct iwl_mvm *mvm,
+       struct ieee80211_vif *vif,
+       struct iwl_beacon_filter_cmd *cmd)
+{
+ struct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);
+
+ if (vif->bss_conf.cqm_rssi_thold) {
+  cmd->bf_energy_delta =
+   cpu_to_le32(vif->bss_conf.cqm_rssi_hyst);
+  /* fw uses an absolute value for this */
+  cmd->bf_roaming_state =
+   cpu_to_le32(-vif->bss_conf.cqm_rssi_thold);
+ }
+ cmd->ba_enable_beacon_abort = cpu_to_le32(mvmvif->bf_data.ba_enabled);
+}
+
 static void iwl_mvm_power_log(struct iwl_mvm *mvm,
-         struct iwl_powertable_cmd *cmd)
+         struct iwl_mac_power_cmd *cmd)
 {
  IWL_DEBUG_POWER(mvm,
-   "Sending power table command for power level %d, flags = 0x%X\n",
-   iwlmvm_mod_params.power_scheme,
+   "Sending power table command on mac id 0x%X for power level %d, flags = 0x%X\n",
+   cmd->id_and_color, iwlmvm_mod_params.power_scheme,
    le16_to_cpu(cmd->flags));
- IWL_DEBUG_POWER(mvm, "Keep alive = %u sec\n", cmd->keep_alive_seconds);
+ IWL_DEBUG_POWER(mvm, "Keep alive = %u sec\n",
+   le16_to_cpu(cmd->keep_alive_seconds));
+
+ if (!(cmd->flags & cpu_to_le16(POWER_FLAGS_POWER_MANAGEMENT_ENA_MSK))) {
+  IWL_DEBUG_POWER(mvm, "Disable power management\n");
+  return;
+ }
 
- if (cmd->flags & cpu_to_le16(POWER_FLAGS_POWER_MANAGEMENT_ENA_MSK)) {
-  IWL_DEBUG_POWER(mvm, "Rx timeout = %u usec\n",
-    le32_to_cpu(cmd->rx_data_timeout));
-  IWL_DEBUG_POWER(mvm, "Tx timeout = %u usec\n",
-    le32_to_cpu(cmd->tx_data_timeout));
+ IWL_DEBUG_POWER(mvm, "Rx timeout = %u usec\n",
+   le32_to_cpu(cmd->rx_data_timeout));
+ IWL_DEBUG_POWER(mvm, "Tx timeout = %u usec\n",
+   le32_to_cpu(cmd->tx_data_timeout));
+ if (cmd->flags & cpu_to_le16(POWER_FLAGS_SKIP_OVER_DTIM_MSK))
+  IWL_DEBUG_POWER(mvm, "DTIM periods to skip = %u\n",
+    cmd->skip_dtim_periods);
+ if (cmd->flags & cpu_to_le16(POWER_FLAGS_LPRX_ENA_MSK))
   IWL_DEBUG_POWER(mvm, "LP RX RSSI threshold = %u\n",
     cmd->lprx_rssi_threshold);
+ if (cmd->flags & cpu_to_le16(POWER_FLAGS_ADVANCE_PM_ENA_MSK)) {
+  IWL_DEBUG_POWER(mvm, "uAPSD enabled\n");
+  IWL_DEBUG_POWER(mvm, "Rx timeout (uAPSD) = %u usec\n",
+    le32_to_cpu(cmd->rx_data_timeout_uapsd));
+  IWL_DEBUG_POWER(mvm, "Tx timeout (uAPSD) = %u usec\n",
+    le32_to_cpu(cmd->tx_data_timeout_uapsd));
+  IWL_DEBUG_POWER(mvm, "QNDP TID = %d\n", cmd->qndp_tid);
+  IWL_DEBUG_POWER(mvm, "ACs flags = 0x%x\n", cmd->uapsd_ac_flags);
+  IWL_DEBUG_POWER(mvm, "Max SP = %d\n", cmd->uapsd_max_sp);
+ }
+}
+
+static void iwl_mvm_power_configure_uapsd(struct iwl_mvm *mvm,
+       struct ieee80211_vif *vif,
+       struct iwl_mac_power_cmd *cmd)
+{
+ struct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);
+ enum ieee80211_ac_numbers ac;
+ bool tid_found = false;
+
+ for (ac = IEEE80211_AC_VO; ac <= IEEE80211_AC_BK; ac++) {
+  if (!mvmvif->queue_params[ac].uapsd)
+   continue;
+
+  if (mvm->cur_ucode != IWL_UCODE_WOWLAN)
+   cmd->flags |=
+    cpu_to_le16(POWER_FLAGS_ADVANCE_PM_ENA_MSK);
+
+  cmd->uapsd_ac_flags |= BIT(ac);
+
+  /* QNDP TID - the highest TID with no admission control */
+  if (!tid_found && !mvmvif->queue_params[ac].acm) {
+   tid_found = true;
+   switch (ac) {
+   case IEEE80211_AC_VO:
+    cmd->qndp_tid = 6;
+    break;
+   case IEEE80211_AC_VI:
+    cmd->qndp_tid = 5;
+    break;
+   case IEEE80211_AC_BE:
+    cmd->qndp_tid = 0;
+    break;
+   case IEEE80211_AC_BK:
+    cmd->qndp_tid = 1;
+    break;
+   }
+  }
+ }
+
+ if (!(cmd->flags & cpu_to_le16(POWER_FLAGS_ADVANCE_PM_ENA_MSK)))
+  return;
+
+ cmd->flags |= cpu_to_le16(POWER_FLAGS_UAPSD_MISBEHAVING_ENA_MSK);
+
+ if (cmd->uapsd_ac_flags == (BIT(IEEE80211_AC_VO) |
+        BIT(IEEE80211_AC_VI) |
+        BIT(IEEE80211_AC_BE) |
+        BIT(IEEE80211_AC_BK))) {
+  cmd->flags |= cpu_to_le16(POWER_FLAGS_SNOOZE_ENA_MSK);
+  cmd->snooze_interval = cpu_to_le16(IWL_MVM_PS_SNOOZE_INTERVAL);
+  cmd->snooze_window = (mvm->cur_ucode == IWL_UCODE_WOWLAN) ?
+   cpu_to_le16(IWL_MVM_WOWLAN_PS_SNOOZE_WINDOW) :
+   cpu_to_le16(IWL_MVM_PS_SNOOZE_WINDOW);
  }
+
+ cmd->uapsd_max_sp = IWL_UAPSD_MAX_SP;
+
+ if (mvm->cur_ucode == IWL_UCODE_WOWLAN || cmd->flags &
+     cpu_to_le16(POWER_FLAGS_SNOOZE_ENA_MSK)) {
+  cmd->rx_data_timeout_uapsd =
+   cpu_to_le32(IWL_MVM_WOWLAN_PS_RX_DATA_TIMEOUT);
+  cmd->tx_data_timeout_uapsd =
+   cpu_to_le32(IWL_MVM_WOWLAN_PS_TX_DATA_TIMEOUT);
+ } else {
+  cmd->rx_data_timeout_uapsd =
+   cpu_to_le32(IWL_MVM_UAPSD_RX_DATA_TIMEOUT);
+  cmd->tx_data_timeout_uapsd =
+   cpu_to_le32(IWL_MVM_UAPSD_TX_DATA_TIMEOUT);
+ }
+
+ if (cmd->flags & cpu_to_le16(POWER_FLAGS_SNOOZE_ENA_MSK)) {
+  cmd->heavy_tx_thld_packets =
+   IWL_MVM_PS_SNOOZE_HEAVY_TX_THLD_PACKETS;
+  cmd->heavy_rx_thld_packets =
+   IWL_MVM_PS_SNOOZE_HEAVY_RX_THLD_PACKETS;
+ } else {
+  cmd->heavy_tx_thld_packets =
+   IWL_MVM_PS_HEAVY_TX_THLD_PACKETS;
+  cmd->heavy_rx_thld_packets =
+   IWL_MVM_PS_HEAVY_RX_THLD_PACKETS;
+ }
+ cmd->heavy_tx_thld_percentage =
+  IWL_MVM_PS_HEAVY_TX_THLD_PERCENT;
+ cmd->heavy_rx_thld_percentage =
+  IWL_MVM_PS_HEAVY_RX_THLD_PERCENT;
 }
 
-void iwl_mvm_power_build_cmd(struct iwl_mvm *mvm, struct ieee80211_vif *vif,
-        struct iwl_powertable_cmd *cmd)
+static void iwl_mvm_binding_iterator(void *_data, u8 *mac,
+          struct ieee80211_vif *vif)
+{
+ unsigned long *data = _data;
+ struct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);
+
+ if (!mvmvif->phy_ctxt)
+  return;
+
+ if (vif->type == NL80211_IFTYPE_STATION ||
+     vif->type == NL80211_IFTYPE_AP)
+  __set_bit(mvmvif->phy_ctxt->id, data);
+}
+
+static bool iwl_mvm_power_allow_uapsd(struct iwl_mvm *mvm,
+           struct ieee80211_vif *vif)
+{
+ struct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);
+ unsigned long phy_ctxt_counter = 0;
+
+ ieee80211_iterate_active_interfaces_atomic(mvm->hw,
+         IEEE80211_IFACE_ITER_NORMAL,
+         iwl_mvm_binding_iterator,
+         &phy_ctxt_counter);
+
+ if (!memcmp(mvmvif->uapsd_misbehaving_bssid, vif->bss_conf.bssid,
+      ETH_ALEN))
+  return false;
+
+ if (vif->p2p &&
+     !(mvm->fw->ucode_capa.flags & IWL_UCODE_TLV_FLAGS_P2P_PS_UAPSD))
+  return false;
+ /*
+  * Avoid using uAPSD if P2P client is associated to GO that uses
+  * opportunistic power save. This is due to current FW limitation.
+  */
+ if (vif->p2p &&
+     (vif->bss_conf.p2p_noa_attr.oppps_ctwindow &
+     IEEE80211_P2P_OPPPS_ENABLE_BIT))
+  return false;
+
+ /*
+  * Avoid using uAPSD if client is in DCM -
+  * low latency issue in Miracast
+  */
+ if (hweight8(phy_ctxt_counter) >= 2)
+  return false;
+
+ return true;
+}
+
+static void iwl_mvm_power_build_cmd(struct iwl_mvm *mvm,
+        struct ieee80211_vif *vif,
+        struct iwl_mac_power_cmd *cmd)
 {
  struct ieee80211_hw *hw = mvm->hw;
  struct ieee80211_chanctx_conf *chanctx_conf;
@@ -103,25 +307,42 @@ void iwl_mvm_power_build_cmd(struct iwl_mvm *mvm, struct ieee80211_vif *vif,
  int dtimper, dtimper_msec;
  int keep_alive;
  bool radar_detect = false;
+ struct iwl_mvm_vif *mvmvif __maybe_unused =
+  iwl_mvm_vif_from_mac80211(vif);
+
+ cmd->id_and_color = cpu_to_le32(FW_CMD_ID_AND_COLOR(mvmvif->id,
+           mvmvif->color));
+ dtimper = hw->conf.ps_dtim_period ?: 1;
 
  /*
   * Regardless of power management state the driver must set
   * keep alive period. FW will use it for sending keep alive NDPs
-  * immediately after association.
+  * immediately after association. Check that keep alive period
+  * is at least 3 * DTIM
   */
- cmd->keep_alive_seconds = POWER_KEEP_ALIVE_PERIOD_SEC;
+ dtimper_msec = dtimper * vif->bss_conf.beacon_int;
+ keep_alive = max_t(int, 3 * dtimper_msec,
+      MSEC_PER_SEC * POWER_KEEP_ALIVE_PERIOD_SEC);
+ keep_alive = DIV_ROUND_UP(keep_alive, MSEC_PER_SEC);
+ cmd->keep_alive_seconds = cpu_to_le16(keep_alive);
 
- if (iwlmvm_mod_params.power_scheme == IWL_POWER_SCHEME_CAM)
+ if (mvm->ps_disabled)
   return;
 
  cmd->flags |= cpu_to_le16(POWER_FLAGS_POWER_SAVE_ENA_MSK);
 
- if (!vif->bss_conf.ps)
+ if (!vif->bss_conf.ps || iwl_mvm_vif_low_latency(mvmvif) ||
+     !mvmvif->pm_enabled)
   return;
 
  cmd->flags |= cpu_to_le16(POWER_FLAGS_POWER_MANAGEMENT_ENA_MSK);
 
- dtimper = hw->conf.ps_dtim_period ?: 1;
+ if (vif->bss_conf.beacon_rate &&
+     (vif->bss_conf.beacon_rate->bitrate == 10 ||
+      vif->bss_conf.beacon_rate->bitrate == 60)) {
+  cmd->flags |= cpu_to_le16(POWER_FLAGS_LPRX_ENA_MSK);
+  cmd->lprx_rssi_threshold = POWER_LPRX_RSSI_THRESHOLD;
+ }
 
  /* Check if radar detection is required on current channel */
  rcu_read_lock();
@@ -135,46 +356,581 @@ void iwl_mvm_power_build_cmd(struct iwl_mvm *mvm, struct ieee80211_vif *vif,
 
  /* Check skip over DTIM conditions */
  if (!radar_detect && (dtimper <= 10) &&
-     (iwlmvm_mod_params.power_scheme == IWL_POWER_SCHEME_LP))
+     (iwlmvm_mod_params.power_scheme == IWL_POWER_SCHEME_LP ||
+      mvm->cur_ucode == IWL_UCODE_WOWLAN)) {
   cmd->flags |= cpu_to_le16(POWER_FLAGS_SKIP_OVER_DTIM_MSK);
+  cmd->skip_dtim_periods = 3;
+ }
 
- /* Check that keep alive period is at least 3 * DTIM */
- dtimper_msec = dtimper * vif->bss_conf.beacon_int;
- keep_alive = max_t(int, 3 * dtimper_msec,
-      MSEC_PER_SEC * cmd->keep_alive_seconds);
- keep_alive = DIV_ROUND_UP(keep_alive, MSEC_PER_SEC);
- cmd->keep_alive_seconds = keep_alive;
+ if (mvm->cur_ucode != IWL_UCODE_WOWLAN) {
+  cmd->rx_data_timeout =
+   cpu_to_le32(IWL_MVM_DEFAULT_PS_RX_DATA_TIMEOUT);
+  cmd->tx_data_timeout =
+   cpu_to_le32(IWL_MVM_DEFAULT_PS_TX_DATA_TIMEOUT);
+ } else {
+  cmd->rx_data_timeout =
+   cpu_to_le32(IWL_MVM_WOWLAN_PS_RX_DATA_TIMEOUT);
+  cmd->tx_data_timeout =
+   cpu_to_le32(IWL_MVM_WOWLAN_PS_TX_DATA_TIMEOUT);
+ }
+
+ if (iwl_mvm_power_allow_uapsd(mvm, vif))
+  iwl_mvm_power_configure_uapsd(mvm, vif, cmd);
 
- cmd->rx_data_timeout = cpu_to_le32(100 * USEC_PER_MSEC);
- cmd->tx_data_timeout = cpu_to_le32(100 * USEC_PER_MSEC);
+#ifdef CONFIG_IWLWIFI_DEBUGFS
+ if (mvmvif->dbgfs_pm.mask & MVM_DEBUGFS_PM_KEEP_ALIVE)
+  cmd->keep_alive_seconds =
+   cpu_to_le16(mvmvif->dbgfs_pm.keep_alive_seconds);
+ if (mvmvif->dbgfs_pm.mask & MVM_DEBUGFS_PM_SKIP_OVER_DTIM) {
+  if (mvmvif->dbgfs_pm.skip_over_dtim)
+   cmd->flags |=
+    cpu_to_le16(POWER_FLAGS_SKIP_OVER_DTIM_MSK);
+  else
+   cmd->flags &=
+    cpu_to_le16(~POWER_FLAGS_SKIP_OVER_DTIM_MSK);
+ }
+ if (mvmvif->dbgfs_pm.mask & MVM_DEBUGFS_PM_RX_DATA_TIMEOUT)
+  cmd->rx_data_timeout =
+   cpu_to_le32(mvmvif->dbgfs_pm.rx_data_timeout);
+ if (mvmvif->dbgfs_pm.mask & MVM_DEBUGFS_PM_TX_DATA_TIMEOUT)
+  cmd->tx_data_timeout =
+   cpu_to_le32(mvmvif->dbgfs_pm.tx_data_timeout);
+ if (mvmvif->dbgfs_pm.mask & MVM_DEBUGFS_PM_SKIP_DTIM_PERIODS)
+  cmd->skip_dtim_periods = mvmvif->dbgfs_pm.skip_dtim_periods;
+ if (mvmvif->dbgfs_pm.mask & MVM_DEBUGFS_PM_LPRX_ENA) {
+  if (mvmvif->dbgfs_pm.lprx_ena)
+   cmd->flags |= cpu_to_le16(POWER_FLAGS_LPRX_ENA_MSK);
+  else
+   cmd->flags &= cpu_to_le16(~POWER_FLAGS_LPRX_ENA_MSK);
+ }
+ if (mvmvif->dbgfs_pm.mask & MVM_DEBUGFS_PM_LPRX_RSSI_THRESHOLD)
+  cmd->lprx_rssi_threshold = mvmvif->dbgfs_pm.lprx_rssi_threshold;
+ if (mvmvif->dbgfs_pm.mask & MVM_DEBUGFS_PM_SNOOZE_ENABLE) {
+  if (mvmvif->dbgfs_pm.snooze_ena)
+   cmd->flags |=
+    cpu_to_le16(POWER_FLAGS_SNOOZE_ENA_MSK);
+  else
+   cmd->flags &=
+    cpu_to_le16(~POWER_FLAGS_SNOOZE_ENA_MSK);
+ }
+ if (mvmvif->dbgfs_pm.mask & MVM_DEBUGFS_PM_UAPSD_MISBEHAVING) {
+  u16 flag = POWER_FLAGS_UAPSD_MISBEHAVING_ENA_MSK;
+  if (mvmvif->dbgfs_pm.uapsd_misbehaving)
+   cmd->flags |= cpu_to_le16(flag);
+  else
+   cmd->flags &= cpu_to_le16(flag);
+ }
+#endif /* CONFIG_IWLWIFI_DEBUGFS */
 }
 
-int iwl_mvm_power_update_mode(struct iwl_mvm *mvm, struct ieee80211_vif *vif)
+static int iwl_mvm_power_send_cmd(struct iwl_mvm *mvm,
+      struct ieee80211_vif *vif)
 {
- struct iwl_powertable_cmd cmd = {};
-
- if (vif->type != NL80211_IFTYPE_STATION || vif->p2p)
-  return 0;
+ struct iwl_mac_power_cmd cmd = {};
 
  iwl_mvm_power_build_cmd(mvm, vif, &cmd);
  iwl_mvm_power_log(mvm, &cmd);
+#ifdef CONFIG_IWLWIFI_DEBUGFS
+ memcpy(&iwl_mvm_vif_from_mac80211(vif)->mac_pwr_cmd, &cmd, sizeof(cmd));
+#endif
 
- return iwl_mvm_send_cmd_pdu(mvm, POWER_TABLE_CMD, CMD_SYNC,
+ return iwl_mvm_send_cmd_pdu(mvm, MAC_PM_POWER_TABLE, 0,
         sizeof(cmd), &cmd);
 }
 
-int iwl_mvm_power_disable(struct iwl_mvm *mvm, struct ieee80211_vif *vif)
+int iwl_mvm_power_update_device(struct iwl_mvm *mvm)
+{
+ struct iwl_device_power_cmd cmd = {
+  .flags = cpu_to_le16(DEVICE_POWER_FLAGS_POWER_SAVE_ENA_MSK),
+ };
+
+ if (iwlmvm_mod_params.power_scheme == IWL_POWER_SCHEME_CAM)
+  mvm->ps_disabled = true;
+
+ if (mvm->ps_disabled)
+  cmd.flags |= cpu_to_le16(DEVICE_POWER_FLAGS_CAM_MSK);
+
+#ifdef CONFIG_IWLWIFI_DEBUGFS
+ if ((mvm->cur_ucode == IWL_UCODE_WOWLAN) ? mvm->disable_power_off_d3 :
+     mvm->disable_power_off)
+  cmd.flags &=
+   cpu_to_le16(~DEVICE_POWER_FLAGS_POWER_SAVE_ENA_MSK);
+#endif
+ IWL_DEBUG_POWER(mvm,
+   "Sending device power command with flags = 0x%X\n",
+   cmd.flags);
+
+ return iwl_mvm_send_cmd_pdu(mvm, POWER_TABLE_CMD, 0, sizeof(cmd),
+        &cmd);
+}
+
+void iwl_mvm_power_vif_assoc(struct iwl_mvm *mvm, struct ieee80211_vif *vif)
+{
+ struct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);
+
+ if (memcmp(vif->bss_conf.bssid, mvmvif->uapsd_misbehaving_bssid,
+     ETH_ALEN))
+  memset(mvmvif->uapsd_misbehaving_bssid, 0, ETH_ALEN);
+}
+
+static void iwl_mvm_power_uapsd_misbehav_ap_iterator(void *_data, u8 *mac,
+           struct ieee80211_vif *vif)
+{
+ u8 *ap_sta_id = _data;
+ struct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);
+
+ /* The ap_sta_id is not expected to change during current association
+  * so no explicit protection is needed
+  */
+ if (mvmvif->ap_sta_id == *ap_sta_id)
+  memcpy(mvmvif->uapsd_misbehaving_bssid, vif->bss_conf.bssid,
+         ETH_ALEN);
+}
+
+int iwl_mvm_power_uapsd_misbehaving_ap_notif(struct iwl_mvm *mvm,
+          struct iwl_rx_cmd_buffer *rxb,
+          struct iwl_device_cmd *cmd)
+{
+ struct iwl_rx_packet *pkt = rxb_addr(rxb);
+ struct iwl_uapsd_misbehaving_ap_notif *notif = (void *)pkt->data;
+ u8 ap_sta_id = le32_to_cpu(notif->sta_id);
+
+ ieee80211_iterate_active_interfaces_atomic(
+  mvm->hw, IEEE80211_IFACE_ITER_NORMAL,
+  iwl_mvm_power_uapsd_misbehav_ap_iterator, &ap_sta_id);
+
+ return 0;
+}
+
+struct iwl_power_vifs {
+ struct ieee80211_vif *bf_vif;
+ struct ieee80211_vif *bss_vif;
+ struct ieee80211_vif *p2p_vif;
+ struct ieee80211_vif *ap_vif;
+ struct ieee80211_vif *monitor_vif;
+ bool p2p_active;
+ bool bss_active;
+ bool ap_active;
+ bool monitor_active;
+};
+
+static void iwl_mvm_power_iterator(void *_data, u8 *mac,
+       struct ieee80211_vif *vif)
+{
+ struct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);
+ struct iwl_power_vifs *power_iterator = _data;
+
+ mvmvif->pm_enabled = false;
+ switch (ieee80211_vif_type_p2p(vif)) {
+ case NL80211_IFTYPE_P2P_DEVICE:
+  break;
+
+ case NL80211_IFTYPE_P2P_GO:
+ case NL80211_IFTYPE_AP:
+  /* only a single MAC of the same type */
+  WARN_ON(power_iterator->ap_vif);
+  power_iterator->ap_vif = vif;
+  if (mvmvif->phy_ctxt)
+   if (mvmvif->phy_ctxt->id < MAX_PHYS)
+    power_iterator->ap_active = true;
+  break;
+
+ case NL80211_IFTYPE_MONITOR:
+  /* only a single MAC of the same type */
+  WARN_ON(power_iterator->monitor_vif);
+  power_iterator->monitor_vif = vif;
+  if (mvmvif->phy_ctxt)
+   if (mvmvif->phy_ctxt->id < MAX_PHYS)
+    power_iterator->monitor_active = true;
+  break;
+
+ case NL80211_IFTYPE_P2P_CLIENT:
+  /* only a single MAC of the same type */
+  WARN_ON(power_iterator->p2p_vif);
+  power_iterator->p2p_vif = vif;
+  if (mvmvif->phy_ctxt)
+   if (mvmvif->phy_ctxt->id < MAX_PHYS)
+    power_iterator->p2p_active = true;
+  break;
+
+ case NL80211_IFTYPE_STATION:
+  /* only a single MAC of the same type */
+  WARN_ON(power_iterator->bss_vif);
+  power_iterator->bss_vif = vif;
+  if (mvmvif->phy_ctxt)
+   if (mvmvif->phy_ctxt->id < MAX_PHYS)
+    power_iterator->bss_active = true;
+
+  if (mvmvif->bf_data.bf_enabled &&
+      !WARN_ON(power_iterator->bf_vif))
+   power_iterator->bf_vif = vif;
+
+  break;
+
+ default:
+  break;
+ }
+}
+
+static void
+iwl_mvm_power_set_pm(struct iwl_mvm *mvm,
+        struct iwl_power_vifs *vifs)
+{
+ struct iwl_mvm_vif *bss_mvmvif = NULL;
+ struct iwl_mvm_vif *p2p_mvmvif = NULL;
+ struct iwl_mvm_vif *ap_mvmvif = NULL;
+ bool client_same_channel = false;
+ bool ap_same_channel = false;
+
+ lockdep_assert_held(&mvm->mutex);
+
+ /* get vifs info + set pm_enable to false */
+ ieee80211_iterate_active_interfaces_atomic(mvm->hw,
+         IEEE80211_IFACE_ITER_NORMAL,
+         iwl_mvm_power_iterator, vifs);
+
+ if (vifs->bss_vif)
+  bss_mvmvif = iwl_mvm_vif_from_mac80211(vifs->bss_vif);
+
+ if (vifs->p2p_vif)
+  p2p_mvmvif = iwl_mvm_vif_from_mac80211(vifs->p2p_vif);
+
+ if (vifs->ap_vif)
+  ap_mvmvif = iwl_mvm_vif_from_mac80211(vifs->ap_vif);
+
+ /* enable PM on bss if bss stand alone */
+ if (vifs->bss_active && !vifs->p2p_active && !vifs->ap_active) {
+  bss_mvmvif->pm_enabled = true;
+  return;
+ }
+
+ /* enable PM on p2p if p2p stand alone */
+ if (vifs->p2p_active && !vifs->bss_active && !vifs->ap_active) {
+  if (mvm->fw->ucode_capa.flags & IWL_UCODE_TLV_FLAGS_P2P_PM)
+   p2p_mvmvif->pm_enabled = true;
+  return;
+ }
+
+ if (vifs->bss_active && vifs->p2p_active)
+  client_same_channel = (bss_mvmvif->phy_ctxt->id ==
+           p2p_mvmvif->phy_ctxt->id);
+ if (vifs->bss_active && vifs->ap_active)
+  ap_same_channel = (bss_mvmvif->phy_ctxt->id ==
+       ap_mvmvif->phy_ctxt->id);
+
+ /* clients are not stand alone: enable PM if DCM */
+ if (!(client_same_channel || ap_same_channel) &&
+     (mvm->fw->ucode_capa.flags & IWL_UCODE_TLV_FLAGS_BSS_P2P_PS_DCM)) {
+  if (vifs->bss_active)
+   bss_mvmvif->pm_enabled = true;
+  if (vifs->p2p_active &&
+      (mvm->fw->ucode_capa.flags & IWL_UCODE_TLV_FLAGS_P2P_PM))
+   p2p_mvmvif->pm_enabled = true;
+  return;
+ }
+
+ /*
+  * There is only one channel in the system and there are only
+  * bss and p2p clients that share it
+  */
+ if (client_same_channel && !vifs->ap_active &&
+     (mvm->fw->ucode_capa.flags & IWL_UCODE_TLV_FLAGS_BSS_P2P_PS_SCM)) {
+  /* share same channel*/
+  bss_mvmvif->pm_enabled = true;
+  if (mvm->fw->ucode_capa.flags & IWL_UCODE_TLV_FLAGS_P2P_PM)
+   p2p_mvmvif->pm_enabled = true;
+ }
+}
+
+#ifdef CONFIG_IWLWIFI_DEBUGFS
+int iwl_mvm_power_mac_dbgfs_read(struct iwl_mvm *mvm,
+     struct ieee80211_vif *vif, char *buf,
+     int bufsz)
 {
- struct iwl_powertable_cmd cmd = {};
+ struct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);
+ struct iwl_mac_power_cmd cmd = {};
+ int pos = 0;
+
+ mutex_lock(&mvm->mutex);
+ memcpy(&cmd, &mvmvif->mac_pwr_cmd, sizeof(cmd));
+ mutex_unlock(&mvm->mutex);
+
+ pos += scnprintf(buf+pos, bufsz-pos, "power_scheme = %d\n",
+    iwlmvm_mod_params.power_scheme);
+ pos += scnprintf(buf+pos, bufsz-pos, "flags = 0x%x\n",
+    le16_to_cpu(cmd.flags));
+ pos += scnprintf(buf+pos, bufsz-pos, "keep_alive = %d\n",
+    le16_to_cpu(cmd.keep_alive_seconds));
+
+ if (!(cmd.flags & cpu_to_le16(POWER_FLAGS_POWER_MANAGEMENT_ENA_MSK)))
+  return pos;
+
+ pos += scnprintf(buf+pos, bufsz-pos, "skip_over_dtim = %d\n",
+    (cmd.flags &
+    cpu_to_le16(POWER_FLAGS_SKIP_OVER_DTIM_MSK)) ? 1 : 0);
+ pos += scnprintf(buf+pos, bufsz-pos, "skip_dtim_periods = %d\n",
+    cmd.skip_dtim_periods);
+ if (!(cmd.flags & cpu_to_le16(POWER_FLAGS_ADVANCE_PM_ENA_MSK))) {
+  pos += scnprintf(buf+pos, bufsz-pos, "rx_data_timeout = %d\n",
+     le32_to_cpu(cmd.rx_data_timeout));
+  pos += scnprintf(buf+pos, bufsz-pos, "tx_data_timeout = %d\n",
+     le32_to_cpu(cmd.tx_data_timeout));
+ }
+ if (cmd.flags & cpu_to_le16(POWER_FLAGS_LPRX_ENA_MSK))
+  pos += scnprintf(buf+pos, bufsz-pos,
+     "lprx_rssi_threshold = %d\n",
+     cmd.lprx_rssi_threshold);
+
+ if (!(cmd.flags & cpu_to_le16(POWER_FLAGS_ADVANCE_PM_ENA_MSK)))
+  return pos;
+
+ pos += scnprintf(buf+pos, bufsz-pos, "rx_data_timeout_uapsd = %d\n",
+    le32_to_cpu(cmd.rx_data_timeout_uapsd));
+ pos += scnprintf(buf+pos, bufsz-pos, "tx_data_timeout_uapsd = %d\n",
+    le32_to_cpu(cmd.tx_data_timeout_uapsd));
+ pos += scnprintf(buf+pos, bufsz-pos, "qndp_tid = %d\n", cmd.qndp_tid);
+ pos += scnprintf(buf+pos, bufsz-pos, "uapsd_ac_flags = 0x%x\n",
+    cmd.uapsd_ac_flags);
+ pos += scnprintf(buf+pos, bufsz-pos, "uapsd_max_sp = %d\n",
+    cmd.uapsd_max_sp);
+ pos += scnprintf(buf+pos, bufsz-pos, "heavy_tx_thld_packets = %d\n",
+    cmd.heavy_tx_thld_packets);
+ pos += scnprintf(buf+pos, bufsz-pos, "heavy_rx_thld_packets = %d\n",
+    cmd.heavy_rx_thld_packets);
+ pos += scnprintf(buf+pos, bufsz-pos, "heavy_tx_thld_percentage = %d\n",
+    cmd.heavy_tx_thld_percentage);
+ pos += scnprintf(buf+pos, bufsz-pos, "heavy_rx_thld_percentage = %d\n",
+    cmd.heavy_rx_thld_percentage);
+ pos += scnprintf(buf+pos, bufsz-pos, "uapsd_misbehaving_enable = %d\n",
+    (cmd.flags &
+     cpu_to_le16(POWER_FLAGS_UAPSD_MISBEHAVING_ENA_MSK)) ?
+    1 : 0);
+
+ if (!(cmd.flags & cpu_to_le16(POWER_FLAGS_SNOOZE_ENA_MSK)))
+  return pos;
+
+ pos += scnprintf(buf+pos, bufsz-pos, "snooze_interval = %d\n",
+    cmd.snooze_interval);
+ pos += scnprintf(buf+pos, bufsz-pos, "snooze_window = %d\n",
+    cmd.snooze_window);
+
+ return pos;
+}
+
+void
+iwl_mvm_beacon_filter_debugfs_parameters(struct ieee80211_vif *vif,
+      struct iwl_beacon_filter_cmd *cmd)
+{
+ struct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);
+ struct iwl_dbgfs_bf *dbgfs_bf = &mvmvif->dbgfs_bf;
+
+ if (dbgfs_bf->mask & MVM_DEBUGFS_BF_ENERGY_DELTA)
+  cmd->bf_energy_delta = cpu_to_le32(dbgfs_bf->bf_energy_delta);
+ if (dbgfs_bf->mask & MVM_DEBUGFS_BF_ROAMING_ENERGY_DELTA)
+  cmd->bf_roaming_energy_delta =
+    cpu_to_le32(dbgfs_bf->bf_roaming_energy_delta);
+ if (dbgfs_bf->mask & MVM_DEBUGFS_BF_ROAMING_STATE)
+  cmd->bf_roaming_state = cpu_to_le32(dbgfs_bf->bf_roaming_state);
+ if (dbgfs_bf->mask & MVM_DEBUGFS_BF_TEMP_THRESHOLD)
+  cmd->bf_temp_threshold =
+    cpu_to_le32(dbgfs_bf->bf_temp_threshold);
+ if (dbgfs_bf->mask & MVM_DEBUGFS_BF_TEMP_FAST_FILTER)
+  cmd->bf_temp_fast_filter =
+    cpu_to_le32(dbgfs_bf->bf_temp_fast_filter);
+ if (dbgfs_bf->mask & MVM_DEBUGFS_BF_TEMP_SLOW_FILTER)
+  cmd->bf_temp_slow_filter =
+    cpu_to_le32(dbgfs_bf->bf_temp_slow_filter);
+ if (dbgfs_bf->mask & MVM_DEBUGFS_BF_DEBUG_FLAG)
+  cmd->bf_debug_flag = cpu_to_le32(dbgfs_bf->bf_debug_flag);
+ if (dbgfs_bf->mask & MVM_DEBUGFS_BF_ESCAPE_TIMER)
+  cmd->bf_escape_timer = cpu_to_le32(dbgfs_bf->bf_escape_timer);
+ if (dbgfs_bf->mask & MVM_DEBUGFS_BA_ESCAPE_TIMER)
+  cmd->ba_escape_timer = cpu_to_le32(dbgfs_bf->ba_escape_timer);
+ if (dbgfs_bf->mask & MVM_DEBUGFS_BA_ENABLE_BEACON_ABORT)
+  cmd->ba_enable_beacon_abort =
+    cpu_to_le32(dbgfs_bf->ba_enable_beacon_abort);
+}
+#endif
+
+static int _iwl_mvm_enable_beacon_filter(struct iwl_mvm *mvm,
+      struct ieee80211_vif *vif,
+      struct iwl_beacon_filter_cmd *cmd,
+      u32 cmd_flags,
+      bool d0i3)
+{
+ struct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);
+ int ret;
+
+ if (mvmvif != mvm->bf_allowed_vif || !vif->bss_conf.dtim_period ||
+     vif->type != NL80211_IFTYPE_STATION || vif->p2p)
+  return 0;
+
+ iwl_mvm_beacon_filter_set_cqm_params(mvm, vif, cmd);
+ if (!d0i3)
+  iwl_mvm_beacon_filter_debugfs_parameters(vif, cmd);
+ ret = iwl_mvm_beacon_filter_send_cmd(mvm, cmd, cmd_flags);
+
+ /* don't change bf_enabled in case of temporary d0i3 configuration */
+ if (!ret && !d0i3)
+  mvmvif->bf_data.bf_enabled = true;
+
+ return ret;
+}
+
+int iwl_mvm_enable_beacon_filter(struct iwl_mvm *mvm,
+     struct ieee80211_vif *vif,
+     u32 flags)
+{
+ struct iwl_beacon_filter_cmd cmd = {
+  IWL_BF_CMD_CONFIG_DEFAULTS,
+  .bf_enable_beacon_filter = cpu_to_le32(1),
+ };
+
+ return _iwl_mvm_enable_beacon_filter(mvm, vif, &cmd, flags, false);
+}
+
+static int iwl_mvm_update_beacon_abort(struct iwl_mvm *mvm,
+           struct ieee80211_vif *vif,
+           bool enable)
+{
+ struct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);
+ struct iwl_beacon_filter_cmd cmd = {
+  IWL_BF_CMD_CONFIG_DEFAULTS,
+  .bf_enable_beacon_filter = cpu_to_le32(1),
+ };
+
+ if (!mvmvif->bf_data.bf_enabled)
+  return 0;
+
+ if (mvm->cur_ucode == IWL_UCODE_WOWLAN)
+  cmd.ba_escape_timer = cpu_to_le32(IWL_BA_ESCAPE_TIMER_D3);
+
+ mvmvif->bf_data.ba_enabled = enable;
+ return _iwl_mvm_enable_beacon_filter(mvm, vif, &cmd, 0, false);
+}
+
+int iwl_mvm_disable_beacon_filter(struct iwl_mvm *mvm,
+      struct ieee80211_vif *vif,
+      u32 flags)
+{
+ struct iwl_beacon_filter_cmd cmd = {};
+ struct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);
+ int ret;
 
  if (vif->type != NL80211_IFTYPE_STATION || vif->p2p)
   return 0;
 
- if (iwlmvm_mod_params.power_scheme != IWL_POWER_SCHEME_CAM)
-  cmd.flags |= cpu_to_le16(POWER_FLAGS_POWER_SAVE_ENA_MSK);
+ ret = iwl_mvm_beacon_filter_send_cmd(mvm, &cmd, flags);
+
+ if (!ret)
+  mvmvif->bf_data.bf_enabled = false;
+
+ return ret;
+}
+
+int iwl_mvm_power_update_mac(struct iwl_mvm *mvm)
+{
+ struct iwl_mvm_vif *mvmvif;
+ struct iwl_power_vifs vifs = {};
+ bool ba_enable;
+ int ret;
+
+ lockdep_assert_held(&mvm->mutex);
+
+ iwl_mvm_power_set_pm(mvm, &vifs);
+
+ /* disable PS if CAM */
+ if (iwlmvm_mod_params.power_scheme == IWL_POWER_SCHEME_CAM) {
+  mvm->ps_disabled = true;
+ } else {
+ /* don't update device power state unless we add / remove monitor */
+  if (vifs.monitor_vif) {
+   if (vifs.monitor_active)
+    mvm->ps_disabled = true;
+   ret = iwl_mvm_power_update_device(mvm);
+   if (ret)
+    return ret;
+  }
+ }
+
+ if (vifs.bss_vif) {
+  ret = iwl_mvm_power_send_cmd(mvm, vifs.bss_vif);
+  if (ret)
+   return ret;
+ }
 
+ if (vifs.p2p_vif) {
+  ret = iwl_mvm_power_send_cmd(mvm, vifs.p2p_vif);
+  if (ret)
+   return ret;
+ }
+
+ if (!vifs.bf_vif)
+  return 0;
+
+ mvmvif = iwl_mvm_vif_from_mac80211(vifs.bf_vif);
+
+ ba_enable = !(!mvmvif->pm_enabled || mvm->ps_disabled ||
+        !vifs.bf_vif->bss_conf.ps ||
+        iwl_mvm_vif_low_latency(mvmvif));
+
+ return iwl_mvm_update_beacon_abort(mvm, vifs.bf_vif, ba_enable);
+}
+
+int iwl_mvm_update_d0i3_power_mode(struct iwl_mvm *mvm,
+       struct ieee80211_vif *vif,
+       bool enable, u32 flags)
+{
+ int ret;
+ struct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);
+ struct iwl_mac_power_cmd cmd = {};
+
+ if (vif->type != NL80211_IFTYPE_STATION || vif->p2p)
+  return 0;
+
+ if (!vif->bss_conf.assoc)
+  return 0;
+
+ iwl_mvm_power_build_cmd(mvm, vif, &cmd);
+ if (enable) {
+  /* configure skip over dtim up to 300 msec */
+  int dtimper = mvm->hw->conf.ps_dtim_period ?: 1;
+  int dtimper_msec = dtimper * vif->bss_conf.beacon_int;
+
+  if (WARN_ON(!dtimper_msec))
+   return 0;
+
+  cmd.skip_dtim_periods = 300 / dtimper_msec;
+  if (cmd.skip_dtim_periods)
+   cmd.flags |=
+    cpu_to_le16(POWER_FLAGS_SKIP_OVER_DTIM_MSK);
+ }
  iwl_mvm_power_log(mvm, &cmd);
+#ifdef CONFIG_IWLWIFI_DEBUGFS
+ memcpy(&mvmvif->mac_pwr_cmd, &cmd, sizeof(cmd));
+#endif
+ ret = iwl_mvm_send_cmd_pdu(mvm, MAC_PM_POWER_TABLE, flags,
+       sizeof(cmd), &cmd);
+ if (ret)
+  return ret;
 
- return iwl_mvm_send_cmd_pdu(mvm, POWER_TABLE_CMD, CMD_ASYNC,
-        sizeof(cmd), &cmd);
+ /* configure beacon filtering */
+ if (mvmvif != mvm->bf_allowed_vif)
+  return 0;
+
+ if (enable) {
+  struct iwl_beacon_filter_cmd cmd_bf = {
+   IWL_BF_CMD_CONFIG_D0I3,
+   .bf_enable_beacon_filter = cpu_to_le32(1),
+  };
+  ret = _iwl_mvm_enable_beacon_filter(mvm, vif, &cmd_bf,
+          flags, true);
+ } else {
+  if (mvmvif->bf_data.bf_enabled)
+   ret = iwl_mvm_enable_beacon_filter(mvm, vif, flags);
+  else
+   ret = iwl_mvm_disable_beacon_filter(mvm, vif, flags);
+ }
+
+ return ret;
 }
diff --git a/drivers/net/wireless/iwlwifi/mvm/quota.c b/drivers/net/wireless/iwlwifi/mvm/quota.c
index a1e3e92..ba68d7b 100644
--- a/drivers/net/wireless/iwlwifi/mvm/quota.c
+++ b/drivers/net/wireless/iwlwifi/mvm/quota.c
@@ -5,7 +5,7 @@
  *
  * GPL LICENSE SUMMARY
  *
- * Copyright(c) 2012 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2012 - 2014 Intel Corporation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of version 2 of the GNU General Public License as
@@ -30,7 +30,7 @@
  *
  * BSD LICENSE
  *
- * Copyright(c) 2012 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2012 - 2014 Intel Corporation. All rights reserved.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -65,9 +65,14 @@
 #include "fw-api.h"
 #include "mvm.h"
 
+#define QUOTA_100 IWL_MVM_MAX_QUOTA
+#define QUOTA_LOWLAT_MIN ((QUOTA_100 * IWL_MVM_LOWLAT_QUOTA_MIN_PERCENT) / 100)
+
 struct iwl_mvm_quota_iterator_data {
  int n_interfaces[MAX_BINDINGS];
  int colors[MAX_BINDINGS];
+ int low_latency[MAX_BINDINGS];
+ int n_low_latency_bindings;
  struct ieee80211_vif *new_vif;
 };
 
@@ -107,47 +112,83 @@ static void iwl_mvm_quota_iterator(void *_data, u8 *mac,
  switch (vif->type) {
  case NL80211_IFTYPE_STATION:
   if (vif->bss_conf.assoc)
-   data->n_interfaces[id]++;
-  break;
+   break;
+  return;
  case NL80211_IFTYPE_AP:
-  if (mvmvif->ap_active)
-   data->n_interfaces[id]++;
-  break;
+ case NL80211_IFTYPE_ADHOC:
+  if (mvmvif->ap_ibss_active)
+   break;
+  return;
  case NL80211_IFTYPE_MONITOR:
   if (mvmvif->monitor_active)
-   data->n_interfaces[id]++;
-  break;
+   break;
+  return;
  case NL80211_IFTYPE_P2P_DEVICE:
-  break;
- case NL80211_IFTYPE_ADHOC:
-  if (vif->bss_conf.ibss_joined)
-   data->n_interfaces[id]++;
-  break;
+  return;
  default:
   WARN_ON_ONCE(1);
-  break;
+  return;
+ }
+
+ data->n_interfaces[id]++;
+
+ if (iwl_mvm_vif_low_latency(mvmvif) && !data->low_latency[id]) {
+  data->n_low_latency_bindings++;
+  data->low_latency[id] = true;
  }
 }
 
+static void iwl_mvm_adjust_quota_for_noa(struct iwl_mvm *mvm,
+      struct iwl_time_quota_cmd *cmd)
+{
+#ifdef CONFIG_NL80211_TESTMODE
+ struct iwl_mvm_vif *mvmvif;
+ int i, phy_id = -1, beacon_int = 0;
+
+ if (!mvm->noa_duration || !mvm->noa_vif)
+  return;
+
+ mvmvif = iwl_mvm_vif_from_mac80211(mvm->noa_vif);
+ if (!mvmvif->ap_ibss_active)
+  return;
+
+ phy_id = mvmvif->phy_ctxt->id;
+ beacon_int = mvm->noa_vif->bss_conf.beacon_int;
+
+ for (i = 0; i < MAX_BINDINGS; i++) {
+  u32 id_n_c = le32_to_cpu(cmd->quotas[i].id_and_color);
+  u32 id = (id_n_c & FW_CTXT_ID_MSK) >> FW_CTXT_ID_POS;
+  u32 quota = le32_to_cpu(cmd->quotas[i].quota);
+
+  if (id != phy_id)
+   continue;
+
+  quota *= (beacon_int - mvm->noa_duration);
+  quota /= beacon_int;
+
+  cmd->quotas[i].quota = cpu_to_le32(quota);
+ }
+#endif
+}
+
 int iwl_mvm_update_quotas(struct iwl_mvm *mvm, struct ieee80211_vif *newvif)
 {
- struct iwl_time_quota_cmd cmd;
- int i, idx, ret, num_active_bindings, quota, quota_rem;
+ struct iwl_time_quota_cmd cmd = {};
+ int i, idx, ret, num_active_macs, quota, quota_rem, n_non_lowlat;
  struct iwl_mvm_quota_iterator_data data = {
   .n_interfaces = {},
   .colors = { -1, -1, -1, -1 },
   .new_vif = newvif,
  };
 
+ lockdep_assert_held(&mvm->mutex);
+
  /* update all upon completion */
  if (test_bit(IWL_MVM_STATUS_IN_HW_RESTART, &mvm->status))
   return 0;
 
- BUILD_BUG_ON(data.colors[MAX_BINDINGS - 1] != -1);
-
- lockdep_assert_held(&mvm->mutex);
-
- memset(&cmd, 0, sizeof(cmd));
+ /* iterator data above must match */
+ BUILD_BUG_ON(MAX_BINDINGS != 4);
 
  ieee80211_iterate_active_interfaces_atomic(
   mvm->hw, IEEE80211_IFACE_ITER_NORMAL,
@@ -162,35 +203,89 @@ int iwl_mvm_update_quotas(struct iwl_mvm *mvm, struct ieee80211_vif *newvif)
   * IWL_MVM_MAX_QUOTA fragments. Divide these fragments
   * equally between all the bindings that require quota
   */
- num_active_bindings = 0;
+ num_active_macs = 0;
  for (i = 0; i < MAX_BINDINGS; i++) {
   cmd.quotas[i].id_and_color = cpu_to_le32(FW_CTXT_INVALID);
-  if (data.n_interfaces[i] > 0)
-   num_active_bindings++;
+  num_active_macs += data.n_interfaces[i];
  }
 
- if (!num_active_bindings)
-  goto send_cmd;
+ n_non_lowlat = num_active_macs;
 
- quota = IWL_MVM_MAX_QUOTA / num_active_bindings;
- quota_rem = IWL_MVM_MAX_QUOTA % num_active_bindings;
+ if (data.n_low_latency_bindings == 1) {
+  for (i = 0; i < MAX_BINDINGS; i++) {
+   if (data.low_latency[i]) {
+    n_non_lowlat -= data.n_interfaces[i];
+    break;
+   }
+  }
+ }
+
+ if (data.n_low_latency_bindings == 1 && n_non_lowlat) {
+  /*
+   * Reserve quota for the low latency binding in case that
+   * there are several data bindings but only a single
+   * low latency one. Split the rest of the quota equally
+   * between the other data interfaces.
+   */
+  quota = (QUOTA_100 - QUOTA_LOWLAT_MIN) / n_non_lowlat;
+  quota_rem = QUOTA_100 - n_non_lowlat * quota -
+       QUOTA_LOWLAT_MIN;
+ } else if (num_active_macs) {
+  /*
+   * There are 0 or more than 1 low latency bindings, or all the
+   * data interfaces belong to the single low latency binding.
+   * Split the quota equally between the data interfaces.
+   */
+  quota = QUOTA_100 / num_active_macs;
+  quota_rem = QUOTA_100 % num_active_macs;
+ } else {
+  /* values don't really matter - won't be used */
+  quota = 0;
+  quota_rem = 0;
+ }
 
  for (idx = 0, i = 0; i < MAX_BINDINGS; i++) {
-  if (data.n_interfaces[i] <= 0)
+  if (data.colors[i] < 0)
    continue;
 
   cmd.quotas[idx].id_and_color =
    cpu_to_le32(FW_CMD_ID_AND_COLOR(i, data.colors[i]));
-  cmd.quotas[idx].quota = cpu_to_le32(quota);
-  cmd.quotas[idx].max_duration = cpu_to_le32(IWL_MVM_MAX_QUOTA);
+
+  if (data.n_interfaces[i] <= 0)
+   cmd.quotas[idx].quota = cpu_to_le32(0);
+  else if (data.n_low_latency_bindings == 1 && n_non_lowlat &&
+    data.low_latency[i])
+   /*
+    * There is more than one binding, but only one of the
+    * bindings is in low latency. For this case, allocate
+    * the minimal required quota for the low latency
+    * binding.
+    */
+   cmd.quotas[idx].quota = cpu_to_le32(QUOTA_LOWLAT_MIN);
+  else
+   cmd.quotas[idx].quota =
+    cpu_to_le32(quota * data.n_interfaces[i]);
+
+  WARN_ONCE(le32_to_cpu(cmd.quotas[idx].quota) > QUOTA_100,
+     "Binding=%d, quota=%u > max=%u\n",
+     idx, le32_to_cpu(cmd.quotas[idx].quota), QUOTA_100);
+
+  cmd.quotas[idx].max_duration = cpu_to_le32(0);
+
   idx++;
  }
 
- /* Give the remainder of the session to the first binding */
- le32_add_cpu(&cmd.quotas[0].quota, quota_rem);
+ /* Give the remainder of the session to the first data binding */
+ for (i = 0; i < MAX_BINDINGS; i++) {
+  if (le32_to_cpu(cmd.quotas[i].quota) != 0) {
+   le32_add_cpu(&cmd.quotas[i].quota, quota_rem);
+   break;
+  }
+ }
+
+ iwl_mvm_adjust_quota_for_noa(mvm, &cmd);
 
-send_cmd:
- ret = iwl_mvm_send_cmd_pdu(mvm, TIME_QUOTA_CMD, CMD_SYNC,
+ ret = iwl_mvm_send_cmd_pdu(mvm, TIME_QUOTA_CMD, 0,
        sizeof(cmd), &cmd);
  if (ret)
   IWL_ERR(mvm, "Failed to send quota: %d\n", ret);
diff --git a/drivers/net/wireless/iwlwifi/mvm/rs.c b/drivers/net/wireless/iwlwifi/mvm/rs.c
index b99fe31..306a6ca 100644
--- a/drivers/net/wireless/iwlwifi/mvm/rs.c
+++ b/drivers/net/wireless/iwlwifi/mvm/rs.c
@@ -1,6 +1,6 @@
 /******************************************************************************
  *
- * Copyright(c) 2005 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2005 - 2014 Intel Corporation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
@@ -24,7 +24,6 @@
  *
  *****************************************************************************/
 #include <linux/kernel.h>
-#include <linux/init.h>
 #include <linux/skbuff.h>
 #include <linux/slab.h>
 #include <net/mac80211.h>
@@ -42,76 +41,298 @@
 
 #define RS_NAME "iwl-mvm-rs"
 
-#define NUM_TRY_BEFORE_ANT_TOGGLE 1
-#define IWL_NUMBER_TRY      1
-#define IWL_HT_NUMBER_TRY   3
+#define NUM_TRY_BEFORE_ANT_TOGGLE       1
+#define RS_LEGACY_RETRIES_PER_RATE      1
+#define RS_HT_VHT_RETRIES_PER_RATE      2
+#define RS_HT_VHT_RETRIES_PER_RATE_TW   1
+#define RS_INITIAL_MIMO_NUM_RATES       3
+#define RS_INITIAL_SISO_NUM_RATES       3
+#define RS_INITIAL_LEGACY_NUM_RATES     LINK_QUAL_MAX_RETRY_NUM
+#define RS_SECONDARY_LEGACY_NUM_RATES   LINK_QUAL_MAX_RETRY_NUM
+#define RS_SECONDARY_SISO_NUM_RATES     3
+#define RS_SECONDARY_SISO_RETRIES       1
 
 #define IWL_RATE_MAX_WINDOW  62 /* # tx in history window */
-#define IWL_RATE_MIN_FAILURE_TH  6 /* min failures to calc tpt */
+#define IWL_RATE_MIN_FAILURE_TH  3 /* min failures to calc tpt */
 #define IWL_RATE_MIN_SUCCESS_TH  8 /* min successes to calc tpt */
 
 /* max allowed rate miss before sync LQ cmd */
 #define IWL_MISSED_RATE_MAX  15
-/* max time to accum history 2 seconds */
-#define IWL_RATE_SCALE_FLUSH_INTVL   (3*HZ)
+#define RS_STAY_IN_COLUMN_TIMEOUT       (5*HZ)
+#define RS_IDLE_TIMEOUT                 (5*HZ)
 
 static u8 rs_ht_to_legacy[] = {
- IWL_RATE_6M_INDEX, IWL_RATE_6M_INDEX,
- IWL_RATE_6M_INDEX, IWL_RATE_6M_INDEX,
- IWL_RATE_6M_INDEX,
- IWL_RATE_6M_INDEX, IWL_RATE_9M_INDEX,
- IWL_RATE_12M_INDEX, IWL_RATE_18M_INDEX,
- IWL_RATE_24M_INDEX, IWL_RATE_36M_INDEX,
- IWL_RATE_48M_INDEX, IWL_RATE_54M_INDEX
+ [IWL_RATE_MCS_0_INDEX] = IWL_RATE_6M_INDEX,
+ [IWL_RATE_MCS_1_INDEX] = IWL_RATE_9M_INDEX,
+ [IWL_RATE_MCS_2_INDEX] = IWL_RATE_12M_INDEX,
+ [IWL_RATE_MCS_3_INDEX] = IWL_RATE_18M_INDEX,
+ [IWL_RATE_MCS_4_INDEX] = IWL_RATE_24M_INDEX,
+ [IWL_RATE_MCS_5_INDEX] = IWL_RATE_36M_INDEX,
+ [IWL_RATE_MCS_6_INDEX] = IWL_RATE_48M_INDEX,
+ [IWL_RATE_MCS_7_INDEX] = IWL_RATE_54M_INDEX,
+ [IWL_RATE_MCS_8_INDEX] = IWL_RATE_54M_INDEX,
+ [IWL_RATE_MCS_9_INDEX] = IWL_RATE_54M_INDEX,
 };
 
 static const u8 ant_toggle_lookup[] = {
- /*ANT_NONE -> */ ANT_NONE,
- /*ANT_A    -> */ ANT_B,
- /*ANT_B    -> */ ANT_C,
- /*ANT_AB   -> */ ANT_BC,
- /*ANT_C    -> */ ANT_A,
- /*ANT_AC   -> */ ANT_AB,
- /*ANT_BC   -> */ ANT_AC,
- /*ANT_ABC  -> */ ANT_ABC,
+ [ANT_NONE] = ANT_NONE,
+ [ANT_A] = ANT_B,
+ [ANT_B] = ANT_C,
+ [ANT_AB] = ANT_BC,
+ [ANT_C] = ANT_A,
+ [ANT_AC] = ANT_AB,
+ [ANT_BC] = ANT_AC,
+ [ANT_ABC] = ANT_ABC,
 };
 
-#define IWL_DECLARE_RATE_INFO(r, s, ip, in, rp, rn, pp, np)    \
- [IWL_RATE_##r##M_INDEX] = { IWL_RATE_##r##M_PLCP,      \
-        IWL_RATE_SISO_##s##M_PLCP, \
-        IWL_RATE_MIMO2_##s##M_PLCP,\
-        IWL_RATE_MIMO3_##s##M_PLCP,\
-        IWL_RATE_##r##M_IEEE,      \
-        IWL_RATE_##ip##M_INDEX,    \
-        IWL_RATE_##in##M_INDEX,    \
-        IWL_RATE_##rp##M_INDEX,    \
-        IWL_RATE_##rn##M_INDEX,    \
-        IWL_RATE_##pp##M_INDEX,    \
-        IWL_RATE_##np##M_INDEX }
+#define IWL_DECLARE_RATE_INFO(r, s, rp, rn)         \
+ [IWL_RATE_##r##M_INDEX] = { IWL_RATE_##r##M_PLCP,       \
+        IWL_RATE_HT_SISO_MCS_##s##_PLCP,  \
+        IWL_RATE_HT_MIMO2_MCS_##s##_PLCP, \
+        IWL_RATE_VHT_SISO_MCS_##s##_PLCP, \
+        IWL_RATE_VHT_MIMO2_MCS_##s##_PLCP,\
+        IWL_RATE_##rp##M_INDEX,       \
+        IWL_RATE_##rn##M_INDEX }
+
+#define IWL_DECLARE_MCS_RATE(s)        \
+ [IWL_RATE_MCS_##s##_INDEX] = { IWL_RATE_INVM_PLCP,    \
+           IWL_RATE_HT_SISO_MCS_##s##_PLCP,   \
+           IWL_RATE_HT_MIMO2_MCS_##s##_PLCP,  \
+           IWL_RATE_VHT_SISO_MCS_##s##_PLCP,  \
+           IWL_RATE_VHT_MIMO2_MCS_##s##_PLCP, \
+           IWL_RATE_INVM_INDEX,           \
+           IWL_RATE_INVM_INDEX }
 
 /*
  * Parameter order:
- *   rate, ht rate, prev rate, next rate, prev tgg rate, next tgg rate
+ *   rate, ht rate, prev rate, next rate
  *
  * If there isn't a valid next or previous rate then INV is used which
  * maps to IWL_RATE_INVALID
  *
  */
 static const struct iwl_rs_rate_info iwl_rates[IWL_RATE_COUNT] = {
- IWL_DECLARE_RATE_INFO(1, INV, INV, 2, INV, 2, INV, 2),    /*  1mbps */
- IWL_DECLARE_RATE_INFO(2, INV, 1, 5, 1, 5, 1, 5),          /*  2mbps */
- IWL_DECLARE_RATE_INFO(5, INV, 2, 6, 2, 11, 2, 11),        /*5.5mbps */
- IWL_DECLARE_RATE_INFO(11, INV, 9, 12, 9, 12, 5, 18),      /* 11mbps */
- IWL_DECLARE_RATE_INFO(6, 6, 5, 9, 5, 11, 5, 11),        /*  6mbps */
- IWL_DECLARE_RATE_INFO(9, 6, 6, 11, 6, 11, 5, 11),       /*  9mbps */
- IWL_DECLARE_RATE_INFO(12, 12, 11, 18, 11, 18, 11, 18),   /* 12mbps */
- IWL_DECLARE_RATE_INFO(18, 18, 12, 24, 12, 24, 11, 24),   /* 18mbps */
- IWL_DECLARE_RATE_INFO(24, 24, 18, 36, 18, 36, 18, 36),   /* 24mbps */
- IWL_DECLARE_RATE_INFO(36, 36, 24, 48, 24, 48, 24, 48),   /* 36mbps */
- IWL_DECLARE_RATE_INFO(48, 48, 36, 54, 36, 54, 36, 54),   /* 48mbps */
- IWL_DECLARE_RATE_INFO(54, 54, 48, INV, 48, INV, 48, INV),/* 54mbps */
- IWL_DECLARE_RATE_INFO(60, 60, 48, INV, 48, INV, 48, INV),/* 60mbps */
- /* FIXME:RS:          ^^    should be INV (legacy) */
+ IWL_DECLARE_RATE_INFO(1, INV, INV, 2),   /*  1mbps */
+ IWL_DECLARE_RATE_INFO(2, INV, 1, 5),     /*  2mbps */
+ IWL_DECLARE_RATE_INFO(5, INV, 2, 11),    /*5.5mbps */
+ IWL_DECLARE_RATE_INFO(11, INV, 9, 12),   /* 11mbps */
+ IWL_DECLARE_RATE_INFO(6, 0, 5, 11),      /*  6mbps ; MCS 0 */
+ IWL_DECLARE_RATE_INFO(9, INV, 6, 11),    /*  9mbps */
+ IWL_DECLARE_RATE_INFO(12, 1, 11, 18),    /* 12mbps ; MCS 1 */
+ IWL_DECLARE_RATE_INFO(18, 2, 12, 24),    /* 18mbps ; MCS 2 */
+ IWL_DECLARE_RATE_INFO(24, 3, 18, 36),    /* 24mbps ; MCS 3 */
+ IWL_DECLARE_RATE_INFO(36, 4, 24, 48),    /* 36mbps ; MCS 4 */
+ IWL_DECLARE_RATE_INFO(48, 5, 36, 54),    /* 48mbps ; MCS 5 */
+ IWL_DECLARE_RATE_INFO(54, 6, 48, INV),   /* 54mbps ; MCS 6 */
+ IWL_DECLARE_MCS_RATE(7),                 /* MCS 7 */
+ IWL_DECLARE_MCS_RATE(8),                 /* MCS 8 */
+ IWL_DECLARE_MCS_RATE(9),                 /* MCS 9 */
+};
+
+enum rs_action {
+ RS_ACTION_STAY = 0,
+ RS_ACTION_DOWNSCALE = -1,
+ RS_ACTION_UPSCALE = 1,
+};
+
+enum rs_column_mode {
+ RS_INVALID = 0,
+ RS_LEGACY,
+ RS_SISO,
+ RS_MIMO2,
+};
+
+#define MAX_NEXT_COLUMNS 7
+#define MAX_COLUMN_CHECKS 3
+
+typedef bool (*allow_column_func_t) (struct iwl_mvm *mvm,
+         struct ieee80211_sta *sta,
+         struct iwl_scale_tbl_info *tbl);
+
+struct rs_tx_column {
+ enum rs_column_mode mode;
+ u8 ant;
+ bool sgi;
+ enum rs_column next_columns[MAX_NEXT_COLUMNS];
+ allow_column_func_t checks[MAX_COLUMN_CHECKS];
+};
+
+static bool rs_mimo_allow(struct iwl_mvm *mvm, struct ieee80211_sta *sta,
+     struct iwl_scale_tbl_info *tbl)
+{
+ if (!sta->ht_cap.ht_supported)
+  return false;
+
+ if (sta->smps_mode == IEEE80211_SMPS_STATIC)
+  return false;
+
+ if (num_of_ant(mvm->fw->valid_tx_ant) < 2)
+  return false;
+
+ if (!iwl_mvm_bt_coex_is_mimo_allowed(mvm, sta))
+  return false;
+
+ return true;
+}
+
+static bool rs_siso_allow(struct iwl_mvm *mvm, struct ieee80211_sta *sta,
+     struct iwl_scale_tbl_info *tbl)
+{
+ if (!sta->ht_cap.ht_supported)
+  return false;
+
+ return true;
+}
+
+static bool rs_sgi_allow(struct iwl_mvm *mvm, struct ieee80211_sta *sta,
+    struct iwl_scale_tbl_info *tbl)
+{
+ struct rs_rate *rate = &tbl->rate;
+ struct ieee80211_sta_ht_cap *ht_cap = &sta->ht_cap;
+ struct ieee80211_sta_vht_cap *vht_cap = &sta->vht_cap;
+
+ if (is_ht20(rate) && (ht_cap->cap &
+        IEEE80211_HT_CAP_SGI_20))
+  return true;
+ if (is_ht40(rate) && (ht_cap->cap &
+        IEEE80211_HT_CAP_SGI_40))
+  return true;
+ if (is_ht80(rate) && (vht_cap->cap &
+        IEEE80211_VHT_CAP_SHORT_GI_80))
+  return true;
+
+ return false;
+}
+
+static const struct rs_tx_column rs_tx_columns[] = {
+ [RS_COLUMN_LEGACY_ANT_A] = {
+  .mode = RS_LEGACY,
+  .ant = ANT_A,
+  .next_columns = {
+   RS_COLUMN_LEGACY_ANT_B,
+   RS_COLUMN_SISO_ANT_A,
+   RS_COLUMN_MIMO2,
+   RS_COLUMN_INVALID,
+   RS_COLUMN_INVALID,
+   RS_COLUMN_INVALID,
+   RS_COLUMN_INVALID,
+  },
+ },
+ [RS_COLUMN_LEGACY_ANT_B] = {
+  .mode = RS_LEGACY,
+  .ant = ANT_B,
+  .next_columns = {
+   RS_COLUMN_LEGACY_ANT_A,
+   RS_COLUMN_SISO_ANT_B,
+   RS_COLUMN_MIMO2,
+   RS_COLUMN_INVALID,
+   RS_COLUMN_INVALID,
+   RS_COLUMN_INVALID,
+   RS_COLUMN_INVALID,
+  },
+ },
+ [RS_COLUMN_SISO_ANT_A] = {
+  .mode = RS_SISO,
+  .ant = ANT_A,
+  .next_columns = {
+   RS_COLUMN_SISO_ANT_B,
+   RS_COLUMN_MIMO2,
+   RS_COLUMN_SISO_ANT_A_SGI,
+   RS_COLUMN_LEGACY_ANT_A,
+   RS_COLUMN_LEGACY_ANT_B,
+   RS_COLUMN_INVALID,
+   RS_COLUMN_INVALID,
+  },
+  .checks = {
+   rs_siso_allow,
+  },
+ },
+ [RS_COLUMN_SISO_ANT_B] = {
+  .mode = RS_SISO,
+  .ant = ANT_B,
+  .next_columns = {
+   RS_COLUMN_SISO_ANT_A,
+   RS_COLUMN_MIMO2,
+   RS_COLUMN_SISO_ANT_B_SGI,
+   RS_COLUMN_LEGACY_ANT_A,
+   RS_COLUMN_LEGACY_ANT_B,
+   RS_COLUMN_INVALID,
+   RS_COLUMN_INVALID,
+  },
+  .checks = {
+   rs_siso_allow,
+  },
+ },
+ [RS_COLUMN_SISO_ANT_A_SGI] = {
+  .mode = RS_SISO,
+  .ant = ANT_A,
+  .sgi = true,
+  .next_columns = {
+   RS_COLUMN_SISO_ANT_B_SGI,
+   RS_COLUMN_MIMO2_SGI,
+   RS_COLUMN_SISO_ANT_A,
+   RS_COLUMN_LEGACY_ANT_A,
+   RS_COLUMN_LEGACY_ANT_B,
+   RS_COLUMN_INVALID,
+   RS_COLUMN_INVALID,
+  },
+  .checks = {
+   rs_siso_allow,
+   rs_sgi_allow,
+  },
+ },
+ [RS_COLUMN_SISO_ANT_B_SGI] = {
+  .mode = RS_SISO,
+  .ant = ANT_B,
+  .sgi = true,
+  .next_columns = {
+   RS_COLUMN_SISO_ANT_A_SGI,
+   RS_COLUMN_MIMO2_SGI,
+   RS_COLUMN_SISO_ANT_B,
+   RS_COLUMN_LEGACY_ANT_A,
+   RS_COLUMN_LEGACY_ANT_B,
+   RS_COLUMN_INVALID,
+   RS_COLUMN_INVALID,
+  },
+  .checks = {
+   rs_siso_allow,
+   rs_sgi_allow,
+  },
+ },
+ [RS_COLUMN_MIMO2] = {
+  .mode = RS_MIMO2,
+  .ant = ANT_AB,
+  .next_columns = {
+   RS_COLUMN_SISO_ANT_A,
+   RS_COLUMN_MIMO2_SGI,
+   RS_COLUMN_LEGACY_ANT_A,
+   RS_COLUMN_LEGACY_ANT_B,
+   RS_COLUMN_INVALID,
+   RS_COLUMN_INVALID,
+   RS_COLUMN_INVALID,
+  },
+  .checks = {
+   rs_mimo_allow,
+  },
+ },
+ [RS_COLUMN_MIMO2_SGI] = {
+  .mode = RS_MIMO2,
+  .ant = ANT_AB,
+  .sgi = true,
+  .next_columns = {
+   RS_COLUMN_SISO_ANT_A_SGI,
+   RS_COLUMN_MIMO2,
+   RS_COLUMN_LEGACY_ANT_A,
+   RS_COLUMN_LEGACY_ANT_B,
+   RS_COLUMN_INVALID,
+   RS_COLUMN_INVALID,
+   RS_COLUMN_INVALID,
+  },
+  .checks = {
+   rs_mimo_allow,
+   rs_sgi_allow,
+  },
+ },
 };
 
 static inline u8 rs_extract_rate(u32 rate_n_flags)
@@ -124,51 +345,46 @@ static int iwl_hwrate_to_plcp_idx(u32 rate_n_flags)
 {
  int idx = 0;
 
- /* HT rate format */
  if (rate_n_flags & RATE_MCS_HT_MSK) {
-  idx = rs_extract_rate(rate_n_flags);
-
-  if (idx >= IWL_RATE_MIMO3_6M_PLCP)
-   idx = idx - IWL_RATE_MIMO3_6M_PLCP;
-  else if (idx >= IWL_RATE_MIMO2_6M_PLCP)
-   idx = idx - IWL_RATE_MIMO2_6M_PLCP;
+  idx = rate_n_flags & RATE_HT_MCS_RATE_CODE_MSK;
+  idx += IWL_RATE_MCS_0_INDEX;
 
-  idx += IWL_FIRST_OFDM_RATE;
-  /* skip 9M not supported in ht*/
+  /* skip 9M not supported in HT*/
   if (idx >= IWL_RATE_9M_INDEX)
    idx += 1;
-  if ((idx >= IWL_FIRST_OFDM_RATE) && (idx <= IWL_LAST_OFDM_RATE))
+  if ((idx >= IWL_FIRST_HT_RATE) && (idx <= IWL_LAST_HT_RATE))
    return idx;
+ } else if (rate_n_flags & RATE_MCS_VHT_MSK) {
+  idx = rate_n_flags & RATE_VHT_MCS_RATE_CODE_MSK;
+  idx += IWL_RATE_MCS_0_INDEX;
 
- /* legacy rate format, search for match in table */
+  /* skip 9M not supported in VHT*/
+  if (idx >= IWL_RATE_9M_INDEX)
+   idx++;
+  if ((idx >= IWL_FIRST_VHT_RATE) && (idx <= IWL_LAST_VHT_RATE))
+   return idx;
  } else {
+  /* legacy rate format, search for match in table */
+
+  u8 legacy_rate = rs_extract_rate(rate_n_flags);
   for (idx = 0; idx < ARRAY_SIZE(iwl_rates); idx++)
-   if (iwl_rates[idx].plcp ==
-     rs_extract_rate(rate_n_flags))
+   if (iwl_rates[idx].plcp == legacy_rate)
     return idx;
  }
 
- return -1;
+ return IWL_RATE_INVALID;
 }
 
 static void rs_rate_scale_perform(struct iwl_mvm *mvm,
        struct sk_buff *skb,
        struct ieee80211_sta *sta,
        struct iwl_lq_sta *lq_sta);
-static void rs_fill_link_cmd(struct iwl_mvm *mvm,
-        struct iwl_lq_sta *lq_sta, u32 rate_n_flags);
+static void rs_fill_lq_cmd(struct iwl_mvm *mvm,
+      struct ieee80211_sta *sta,
+      struct iwl_lq_sta *lq_sta,
+      const struct rs_rate *initial_rate);
 static void rs_stay_in_table(struct iwl_lq_sta *lq_sta, bool force_search);
 
-
-#ifdef CONFIG_MAC80211_DEBUGFS
-static void rs_dbgfs_set_mcs(struct iwl_lq_sta *lq_sta,
-        u32 *rate_n_flags, int index);
-#else
-static void rs_dbgfs_set_mcs(struct iwl_lq_sta *lq_sta,
-        u32 *rate_n_flags, int index)
-{}
-#endif
-
 /**
  * The following tables contain the expected throughput metrics for all rates
  *
@@ -180,50 +396,53 @@ static void rs_dbgfs_set_mcs(struct iwl_lq_sta *lq_sta,
  * (2.4 GHz) band.
  */
 
-static s32 expected_tpt_legacy[IWL_RATE_COUNT] = {
- 7, 13, 35, 58, 40, 57, 72, 98, 121, 154, 177, 186, 0
+static const u16 expected_tpt_legacy[IWL_RATE_COUNT] = {
+ 7, 13, 35, 58, 40, 57, 72, 98, 121, 154, 177, 186, 0, 0, 0
 };
 
-static s32 expected_tpt_siso20MHz[4][IWL_RATE_COUNT] = {
- {0, 0, 0, 0, 42, 0,  76, 102, 124, 159, 183, 193, 202}, /* Norm */
- {0, 0, 0, 0, 46, 0,  82, 110, 132, 168, 192, 202, 210}, /* SGI */
- {0, 0, 0, 0, 47, 0,  91, 133, 171, 242, 305, 334, 362}, /* AGG */
- {0, 0, 0, 0, 52, 0, 101, 145, 187, 264, 330, 361, 390}, /* AGG+SGI */
+/* Expected TpT tables. 4 indexes:
+ * 0 - NGI, 1 - SGI, 2 - AGG+NGI, 3 - AGG+SGI
+ */
+static const u16 expected_tpt_siso_20MHz[4][IWL_RATE_COUNT] = {
+ {0, 0, 0, 0, 42, 0,  76, 102, 124, 159, 183, 193, 202, 216, 0},
+ {0, 0, 0, 0, 46, 0,  82, 110, 132, 168, 192, 202, 210, 225, 0},
+ {0, 0, 0, 0, 49, 0,  97, 145, 192, 285, 375, 420, 464, 551, 0},
+ {0, 0, 0, 0, 54, 0, 108, 160, 213, 315, 415, 465, 513, 608, 0},
 };
 
-static s32 expected_tpt_siso40MHz[4][IWL_RATE_COUNT] = {
- {0, 0, 0, 0,  77, 0, 127, 160, 184, 220, 242, 250, 257}, /* Norm */
- {0, 0, 0, 0,  83, 0, 135, 169, 193, 229, 250, 257, 264}, /* SGI */
- {0, 0, 0, 0,  94, 0, 177, 249, 313, 423, 512, 550, 586}, /* AGG */
- {0, 0, 0, 0, 104, 0, 193, 270, 338, 454, 545, 584, 620}, /* AGG+SGI */
+static const u16 expected_tpt_siso_40MHz[4][IWL_RATE_COUNT] = {
+ {0, 0, 0, 0,  77, 0, 127, 160, 184, 220, 242, 250,  257,  269,  275},
+ {0, 0, 0, 0,  83, 0, 135, 169, 193, 229, 250, 257,  264,  275,  280},
+ {0, 0, 0, 0, 101, 0, 199, 295, 389, 570, 744, 828,  911, 1070, 1173},
+ {0, 0, 0, 0, 112, 0, 220, 326, 429, 629, 819, 912, 1000, 1173, 1284},
 };
 
-static s32 expected_tpt_mimo2_20MHz[4][IWL_RATE_COUNT] = {
- {0, 0, 0, 0,  74, 0, 123, 155, 179, 214, 236, 244, 251}, /* Norm */
- {0, 0, 0, 0,  81, 0, 131, 164, 188, 223, 243, 251, 257}, /* SGI */
- {0, 0, 0, 0,  89, 0, 167, 235, 296, 402, 488, 526, 560}, /* AGG */
- {0, 0, 0, 0,  97, 0, 182, 255, 320, 431, 520, 558, 593}, /* AGG+SGI*/
+static const u16 expected_tpt_siso_80MHz[4][IWL_RATE_COUNT] = {
+ {0, 0, 0, 0, 130, 0, 191, 223, 244,  273,  288,  294,  298,  305,  308},
+ {0, 0, 0, 0, 138, 0, 200, 231, 251,  279,  293,  298,  302,  308,  312},
+ {0, 0, 0, 0, 217, 0, 429, 634, 834, 1220, 1585, 1760, 1931, 2258, 2466},
+ {0, 0, 0, 0, 241, 0, 475, 701, 921, 1343, 1741, 1931, 2117, 2468, 2691},
 };
 
-static s32 expected_tpt_mimo2_40MHz[4][IWL_RATE_COUNT] = {
- {0, 0, 0, 0, 123, 0, 182, 214, 235, 264, 279, 285, 289}, /* Norm */
- {0, 0, 0, 0, 131, 0, 191, 222, 242, 270, 284, 289, 293}, /* SGI */
- {0, 0, 0, 0, 171, 0, 305, 410, 496, 634, 731, 771, 805}, /* AGG */
- {0, 0, 0, 0, 186, 0, 329, 439, 527, 667, 764, 803, 838}, /* AGG+SGI */
+static const u16 expected_tpt_mimo2_20MHz[4][IWL_RATE_COUNT] = {
+ {0, 0, 0, 0,  74, 0, 123, 155, 179, 213, 235, 243, 250,  261, 0},
+ {0, 0, 0, 0,  81, 0, 131, 164, 187, 221, 242, 250, 256,  267, 0},
+ {0, 0, 0, 0,  98, 0, 193, 286, 375, 550, 718, 799, 878, 1032, 0},
+ {0, 0, 0, 0, 109, 0, 214, 316, 414, 607, 790, 879, 965, 1132, 0},
 };
 
-static s32 expected_tpt_mimo3_20MHz[4][IWL_RATE_COUNT] = {
- {0, 0, 0, 0,  99, 0, 153, 186, 208, 239, 256, 263, 268}, /* Norm */
- {0, 0, 0, 0, 106, 0, 162, 194, 215, 246, 262, 268, 273}, /* SGI */
- {0, 0, 0, 0, 134, 0, 249, 346, 431, 574, 685, 732, 775}, /* AGG */
- {0, 0, 0, 0, 148, 0, 272, 376, 465, 614, 727, 775, 818}, /* AGG+SGI */
+static const u16 expected_tpt_mimo2_40MHz[4][IWL_RATE_COUNT] = {
+ {0, 0, 0, 0, 123, 0, 182, 214, 235,  264,  279,  285,  289,  296,  300},
+ {0, 0, 0, 0, 131, 0, 191, 222, 242,  270,  284,  289,  293,  300,  303},
+ {0, 0, 0, 0, 200, 0, 390, 571, 741, 1067, 1365, 1505, 1640, 1894, 2053},
+ {0, 0, 0, 0, 221, 0, 430, 630, 816, 1169, 1490, 1641, 1784, 2053, 2221},
 };
 
-static s32 expected_tpt_mimo3_40MHz[4][IWL_RATE_COUNT] = {
- {0, 0, 0, 0, 152, 0, 211, 239, 255, 279,  290,  294,  297}, /* Norm */
- {0, 0, 0, 0, 160, 0, 219, 245, 261, 284,  294,  297,  300}, /* SGI */
- {0, 0, 0, 0, 254, 0, 443, 584, 695, 868,  984, 1030, 1070}, /* AGG */
- {0, 0, 0, 0, 277, 0, 478, 624, 737, 911, 1026, 1070, 1109}, /* AGG+SGI */
+static const u16 expected_tpt_mimo2_80MHz[4][IWL_RATE_COUNT] = {
+ {0, 0, 0, 0, 182, 0, 240,  264,  278,  299,  308,  311,  313,  317,  319},
+ {0, 0, 0, 0, 190, 0, 247,  269,  282,  302,  310,  313,  315,  319,  320},
+ {0, 0, 0, 0, 428, 0, 833, 1215, 1577, 2254, 2863, 3147, 3418, 3913, 4219},
+ {0, 0, 0, 0, 474, 0, 920, 1338, 1732, 2464, 3116, 3418, 3705, 4225, 4545},
 };
 
 /* mbps, mcs */
@@ -245,151 +464,77 @@ static const struct iwl_rate_mcs_info iwl_rate_mcs[IWL_RATE_COUNT] = {
 
 #define MCS_INDEX_PER_STREAM (8)
 
-static void rs_rate_scale_clear_window(struct iwl_rate_scale_data *window)
+static const char *rs_pretty_ant(u8 ant)
 {
- window->data = 0;
- window->success_counter = 0;
- window->success_ratio = IWL_INVALID_VALUE;
- window->counter = 0;
- window->average_tpt = IWL_INVALID_VALUE;
- window->stamp = 0;
+ static const char * const ant_name[] = {
+  [ANT_NONE] = "None",
+  [ANT_A]    = "A",
+  [ANT_B]    = "B",
+  [ANT_AB]   = "AB",
+  [ANT_C]    = "C",
+  [ANT_AC]   = "AC",
+  [ANT_BC]   = "BC",
+  [ANT_ABC]  = "ABC",
+ };
+
+ if (ant > ANT_ABC)
+  return "UNKNOWN";
+
+ return ant_name[ant];
 }
 
-static inline u8 rs_is_valid_ant(u8 valid_antenna, u8 ant_type)
+static const char *rs_pretty_lq_type(enum iwl_table_type type)
 {
- return (ant_type & valid_antenna) == ant_type;
+ static const char * const lq_types[] = {
+  [LQ_NONE] = "NONE",
+  [LQ_LEGACY_A] = "LEGACY_A",
+  [LQ_LEGACY_G] = "LEGACY_G",
+  [LQ_HT_SISO] = "HT SISO",
+  [LQ_HT_MIMO2] = "HT MIMO",
+  [LQ_VHT_SISO] = "VHT SISO",
+  [LQ_VHT_MIMO2] = "VHT MIMO",
+ };
+
+ if (type < LQ_NONE || type >= LQ_MAX)
+  return "UNKNOWN";
+
+ return lq_types[type];
 }
 
-/*
- * removes the old data from the statistics. All data that is older than
- * TID_MAX_TIME_DIFF, will be deleted.
- */
-static void rs_tl_rm_old_stats(struct iwl_traffic_load *tl, u32 curr_time)
+static inline void rs_dump_rate(struct iwl_mvm *mvm, const struct rs_rate *rate,
+    const char *prefix)
 {
- /* The oldest age we want to keep */
- u32 oldest_time = curr_time - TID_MAX_TIME_DIFF;
-
- while (tl->queue_count &&
-        (tl->time_stamp < oldest_time)) {
-  tl->total -= tl->packet_count[tl->head];
-  tl->packet_count[tl->head] = 0;
-  tl->time_stamp += TID_QUEUE_CELL_SPACING;
-  tl->queue_count--;
-  tl->head++;
-  if (tl->head >= TID_QUEUE_MAX_SIZE)
-   tl->head = 0;
- }
+ IWL_DEBUG_RATE(mvm, "%s: (%s: %d) ANT: %s BW: %d SGI: %d\n",
+         prefix, rs_pretty_lq_type(rate->type),
+         rate->index, rs_pretty_ant(rate->ant),
+         rate->bw, rate->sgi);
 }
 
-/*
- * increment traffic load value for tid and also remove
- * any old values if passed the certain time period
- */
-static u8 rs_tl_add_packet(struct iwl_lq_sta *lq_data,
-      struct ieee80211_hdr *hdr)
+static void rs_rate_scale_clear_window(struct iwl_rate_scale_data *window)
 {
- u32 curr_time = jiffies_to_msecs(jiffies);
- u32 time_diff;
- s32 index;
- struct iwl_traffic_load *tl = NULL;
- u8 tid;
-
- if (ieee80211_is_data_qos(hdr->frame_control)) {
-  u8 *qc = ieee80211_get_qos_ctl(hdr);
-  tid = qc[0] & 0xf;
- } else {
-  return IWL_MAX_TID_COUNT;
- }
-
- if (unlikely(tid >= IWL_MAX_TID_COUNT))
-  return IWL_MAX_TID_COUNT;
-
- tl = &lq_data->load[tid];
-
- curr_time -= curr_time % TID_ROUND_VALUE;
-
- /* Happens only for the first packet. Initialize the data */
- if (!(tl->queue_count)) {
-  tl->total = 1;
-  tl->time_stamp = curr_time;
-  tl->queue_count = 1;
-  tl->head = 0;
-  tl->packet_count[0] = 1;
-  return IWL_MAX_TID_COUNT;
- }
-
- time_diff = TIME_WRAP_AROUND(tl->time_stamp, curr_time);
- index = time_diff / TID_QUEUE_CELL_SPACING;
-
- /* The history is too long: remove data that is older than */
- /* TID_MAX_TIME_DIFF */
- if (index >= TID_QUEUE_MAX_SIZE)
-  rs_tl_rm_old_stats(tl, curr_time);
-
- index = (tl->head + index) % TID_QUEUE_MAX_SIZE;
- tl->packet_count[index] = tl->packet_count[index] + 1;
- tl->total = tl->total + 1;
-
- if ((index + 1) > tl->queue_count)
-  tl->queue_count = index + 1;
-
- return tid;
+ window->data = 0;
+ window->success_counter = 0;
+ window->success_ratio = IWL_INVALID_VALUE;
+ window->counter = 0;
+ window->average_tpt = IWL_INVALID_VALUE;
 }
 
-#ifdef CONFIG_MAC80211_DEBUGFS
-/**
- * Program the device to use fixed rate for frame transmit
- * This is for debugging/testing only
- * once the device start use fixed rate, we need to reload the module
- * to being back the normal operation.
- */
-static void rs_program_fix_rate(struct iwl_mvm *mvm,
-    struct iwl_lq_sta *lq_sta)
+static void rs_rate_scale_clear_tbl_windows(struct iwl_mvm *mvm,
+         struct iwl_scale_tbl_info *tbl)
 {
- lq_sta->active_legacy_rate = 0x0FFF; /* 1 - 54 MBits, includes CCK */
- lq_sta->active_siso_rate   = 0x1FD0; /* 6 - 60 MBits, no 9, no CCK */
- lq_sta->active_mimo2_rate  = 0x1FD0; /* 6 - 60 MBits, no 9, no CCK */
- lq_sta->active_mimo3_rate  = 0x1FD0; /* 6 - 60 MBits, no 9, no CCK */
+ int i;
 
- IWL_DEBUG_RATE(mvm, "sta_id %d rate 0x%X\n",
-         lq_sta->lq.sta_id, lq_sta->dbg_fixed_rate);
+ IWL_DEBUG_RATE(mvm, "Clearing up window stats\n");
+ for (i = 0; i < IWL_RATE_COUNT; i++)
+  rs_rate_scale_clear_window(&tbl->win[i]);
 
- if (lq_sta->dbg_fixed_rate) {
-  rs_fill_link_cmd(NULL, lq_sta, lq_sta->dbg_fixed_rate);
-  iwl_mvm_send_lq_cmd(lq_sta->drv, &lq_sta->lq, CMD_ASYNC, false);
- }
+ for (i = 0; i < ARRAY_SIZE(tbl->tpc_win); i++)
+  rs_rate_scale_clear_window(&tbl->tpc_win[i]);
 }
-#endif
 
-/*
- get the traffic load value for tid
-*/
-static u32 rs_tl_get_load(struct iwl_lq_sta *lq_data, u8 tid)
+static inline u8 rs_is_valid_ant(u8 valid_antenna, u8 ant_type)
 {
- u32 curr_time = jiffies_to_msecs(jiffies);
- u32 time_diff;
- s32 index;
- struct iwl_traffic_load *tl = NULL;
-
- if (tid >= IWL_MAX_TID_COUNT)
-  return 0;
-
- tl = &(lq_data->load[tid]);
-
- curr_time -= curr_time % TID_ROUND_VALUE;
-
- if (!(tl->queue_count))
-  return 0;
-
- time_diff = TIME_WRAP_AROUND(tl->time_stamp, curr_time);
- index = time_diff / TID_QUEUE_CELL_SPACING;
-
- /* The history is too long: remove data that is older than */
- /* TID_MAX_TIME_DIFF */
- if (index >= TID_QUEUE_MAX_SIZE)
-  rs_tl_rm_old_stats(tl, curr_time);
-
- return tl->total;
+ return (ant_type & valid_antenna) == ant_type;
 }
 
 static int rs_tl_turn_on_agg_for_tid(struct iwl_mvm *mvm,
@@ -397,28 +542,19 @@ static int rs_tl_turn_on_agg_for_tid(struct iwl_mvm *mvm,
           struct ieee80211_sta *sta)
 {
  int ret = -EAGAIN;
- u32 load;
-
- load = rs_tl_get_load(lq_data, tid);
 
- if ((iwlwifi_mod_params.auto_agg) || (load > IWL_AGG_LOAD_THRESHOLD)) {
-  IWL_DEBUG_HT(mvm, "Starting Tx agg: STA: %pM tid: %d\n",
-        sta->addr, tid);
-  ret = ieee80211_start_tx_ba_session(sta, tid, 5000);
-  if (ret == -EAGAIN) {
-   /*
-    * driver and mac80211 is out of sync
-    * this might be cause by reloading firmware
-    * stop the tx ba session here
-    */
-   IWL_ERR(mvm, "Fail start Tx agg on tid: %d\n",
-    tid);
-   ieee80211_stop_tx_ba_session(sta, tid);
-  }
- } else {
-  IWL_DEBUG_HT(mvm,
-        "Aggregation not enabled for tid %d because load = %u\n",
-        tid, load);
+ IWL_DEBUG_HT(mvm, "Starting Tx agg: STA: %pM tid: %d\n",
+       sta->addr, tid);
+ ret = ieee80211_start_tx_ba_session(sta, tid, 5000);
+ if (ret == -EAGAIN) {
+  /*
+   * driver and mac80211 is out of sync
+   * this might be cause by reloading firmware
+   * stop the tx ba session here
+   */
+  IWL_ERR(mvm, "Fail start Tx agg on tid: %d\n",
+   tid);
+  ieee80211_stop_tx_ba_session(sta, tid);
  }
  return ret;
 }
@@ -459,19 +595,13 @@ static s32 get_expected_tpt(struct iwl_scale_tbl_info *tbl, int rs_index)
  * at this rate.  window->data contains the bitmask of successful
  * packets.
  */
-static int rs_collect_tx_data(struct iwl_scale_tbl_info *tbl,
-         int scale_index, int attempts, int successes)
+static int _rs_collect_tx_data(struct iwl_scale_tbl_info *tbl,
+          int scale_index, int attempts, int successes,
+          struct iwl_rate_scale_data *window)
 {
- struct iwl_rate_scale_data *window = NULL;
  static const u64 mask = (((u64)1) << (IWL_RATE_MAX_WINDOW - 1));
  s32 fail_count, tpt;
 
- if (scale_index < 0 || scale_index >= IWL_RATE_COUNT)
-  return -EINVAL;
-
- /* Select window for current tx bit rate */
- window = &(tbl->win[scale_index]);
-
  /* Get expected throughput */
  tpt = get_expected_tpt(tbl, scale_index);
 
@@ -526,191 +656,204 @@ static int rs_collect_tx_data(struct iwl_scale_tbl_info *tbl,
  else
   window->average_tpt = IWL_INVALID_VALUE;
 
- /* Tag this window as having been updated */
- window->stamp = jiffies;
-
  return 0;
 }
 
-/*
- * Fill uCode API rate_n_flags field, based on "search" or "active" table.
- */
-/* FIXME:RS:remove this function and put the flags statically in the table */
-static u32 rate_n_flags_from_tbl(struct iwl_mvm *mvm,
-     struct iwl_scale_tbl_info *tbl,
-     int index, u8 use_green)
+static int rs_collect_tx_data(struct iwl_lq_sta *lq_sta,
+         struct iwl_scale_tbl_info *tbl,
+         int scale_index, int attempts, int successes,
+         u8 reduced_txp)
+{
+ struct iwl_rate_scale_data *window = NULL;
+ int ret;
+
+ if (scale_index < 0 || scale_index >= IWL_RATE_COUNT)
+  return -EINVAL;
+
+ if (tbl->column != RS_COLUMN_INVALID) {
+  lq_sta->tx_stats[tbl->column][scale_index].total += attempts;
+  lq_sta->tx_stats[tbl->column][scale_index].success += successes;
+ }
+
+ /* Select window for current tx bit rate */
+ window = &(tbl->win[scale_index]);
+
+ ret = _rs_collect_tx_data(tbl, scale_index, attempts, successes,
+      window);
+ if (ret)
+  return ret;
+
+ if (WARN_ON_ONCE(reduced_txp > TPC_MAX_REDUCTION))
+  return -EINVAL;
+
+ window = &tbl->tpc_win[reduced_txp];
+ return _rs_collect_tx_data(tbl, scale_index, attempts, successes,
+       window);
+}
+
+/* Convert rs_rate object into ucode rate bitmask */
+static u32 ucode_rate_from_rs_rate(struct iwl_mvm *mvm,
+      struct rs_rate *rate)
 {
- u32 rate_n_flags = 0;
+ u32 ucode_rate = 0;
+ int index = rate->index;
 
- if (is_legacy(tbl->lq_type)) {
-  rate_n_flags = iwl_rates[index].plcp;
+ ucode_rate |= ((rate->ant << RATE_MCS_ANT_POS) &
+    RATE_MCS_ANT_ABC_MSK);
+
+ if (is_legacy(rate)) {
+  ucode_rate |= iwl_rates[index].plcp;
   if (index >= IWL_FIRST_CCK_RATE && index <= IWL_LAST_CCK_RATE)
-   rate_n_flags |= RATE_MCS_CCK_MSK;
- } else if (is_Ht(tbl->lq_type)) {
-  if (index > IWL_LAST_OFDM_RATE) {
+   ucode_rate |= RATE_MCS_CCK_MSK;
+  return ucode_rate;
+ }
+
+ if (is_ht(rate)) {
+  if (index < IWL_FIRST_HT_RATE || index > IWL_LAST_HT_RATE) {
    IWL_ERR(mvm, "Invalid HT rate index %d\n", index);
-   index = IWL_LAST_OFDM_RATE;
+   index = IWL_LAST_HT_RATE;
   }
-  rate_n_flags = RATE_MCS_HT_MSK;
+  ucode_rate |= RATE_MCS_HT_MSK;
 
-  if (is_siso(tbl->lq_type))
-   rate_n_flags |= iwl_rates[index].plcp_siso;
-  else if (is_mimo2(tbl->lq_type))
-   rate_n_flags |= iwl_rates[index].plcp_mimo2;
+  if (is_ht_siso(rate))
+   ucode_rate |= iwl_rates[index].plcp_ht_siso;
+  else if (is_ht_mimo2(rate))
+   ucode_rate |= iwl_rates[index].plcp_ht_mimo2;
   else
-   rate_n_flags |= iwl_rates[index].plcp_mimo3;
+   WARN_ON_ONCE(1);
+ } else if (is_vht(rate)) {
+  if (index < IWL_FIRST_VHT_RATE || index > IWL_LAST_VHT_RATE) {
+   IWL_ERR(mvm, "Invalid VHT rate index %d\n", index);
+   index = IWL_LAST_VHT_RATE;
+  }
+  ucode_rate |= RATE_MCS_VHT_MSK;
+  if (is_vht_siso(rate))
+   ucode_rate |= iwl_rates[index].plcp_vht_siso;
+  else if (is_vht_mimo2(rate))
+   ucode_rate |= iwl_rates[index].plcp_vht_mimo2;
+  else
+   WARN_ON_ONCE(1);
+
  } else {
-  IWL_ERR(mvm, "Invalid tbl->lq_type %d\n", tbl->lq_type);
+  IWL_ERR(mvm, "Invalid rate->type %d\n", rate->type);
  }
 
- rate_n_flags |= ((tbl->ant_type << RATE_MCS_ANT_POS) &
-           RATE_MCS_ANT_ABC_MSK);
-
- if (is_Ht(tbl->lq_type)) {
-  if (tbl->is_ht40)
-   rate_n_flags |= RATE_MCS_CHAN_WIDTH_40;
-  if (tbl->is_SGI)
-   rate_n_flags |= RATE_MCS_SGI_MSK;
+ ucode_rate |= rate->bw;
+ if (rate->sgi)
+  ucode_rate |= RATE_MCS_SGI_MSK;
 
-  if (use_green) {
-   rate_n_flags |= RATE_HT_MCS_GF_MSK;
-   if (is_siso(tbl->lq_type) && tbl->is_SGI) {
-    rate_n_flags &= ~RATE_MCS_SGI_MSK;
-    IWL_ERR(mvm, "GF was set with SGI:SISO\n");
-   }
-  }
- }
- return rate_n_flags;
+ return ucode_rate;
 }
 
-/*
- * Interpret uCode API's rate_n_flags format,
- * fill "search" or "active" tx mode table.
- */
-static int rs_get_tbl_info_from_mcs(const u32 rate_n_flags,
-        enum ieee80211_band band,
-        struct iwl_scale_tbl_info *tbl,
-        int *rate_idx)
+/* Convert a ucode rate into an rs_rate object */
+static int rs_rate_from_ucode_rate(const u32 ucode_rate,
+       enum ieee80211_band band,
+       struct rs_rate *rate)
 {
- u32 ant_msk = (rate_n_flags & RATE_MCS_ANT_ABC_MSK);
- u8 num_of_ant = get_num_of_ant_from_rate(rate_n_flags);
- u8 mcs;
+ u32 ant_msk = ucode_rate & RATE_MCS_ANT_ABC_MSK;
+ u8 num_of_ant = get_num_of_ant_from_rate(ucode_rate);
+ u8 nss;
 
- memset(tbl, 0, sizeof(struct iwl_scale_tbl_info));
- *rate_idx = iwl_hwrate_to_plcp_idx(rate_n_flags);
+ memset(rate, 0, sizeof(*rate));
+ rate->index = iwl_hwrate_to_plcp_idx(ucode_rate);
 
- if (*rate_idx  == IWL_RATE_INVALID) {
-  *rate_idx = -1;
+ if (rate->index == IWL_RATE_INVALID)
   return -EINVAL;
- }
- tbl->is_SGI = 0; /* default legacy setup */
- tbl->is_ht40 = 0;
- tbl->ant_type = (ant_msk >> RATE_MCS_ANT_POS);
- tbl->lq_type = LQ_NONE;
- tbl->max_search = IWL_MAX_SEARCH;
 
- /* legacy rate format */
- if (!(rate_n_flags & RATE_MCS_HT_MSK)) {
+ rate->ant = (ant_msk >> RATE_MCS_ANT_POS);
+
+ /* Legacy */
+ if (!(ucode_rate & RATE_MCS_HT_MSK) &&
+     !(ucode_rate & RATE_MCS_VHT_MSK)) {
   if (num_of_ant == 1) {
    if (band == IEEE80211_BAND_5GHZ)
-    tbl->lq_type = LQ_A;
+    rate->type = LQ_LEGACY_A;
    else
-    tbl->lq_type = LQ_G;
+    rate->type = LQ_LEGACY_G;
   }
- /* HT rate format */
- } else {
-  if (rate_n_flags & RATE_MCS_SGI_MSK)
-   tbl->is_SGI = 1;
-
-  if (rate_n_flags & RATE_MCS_CHAN_WIDTH_40) /* TODO */
-   tbl->is_ht40 = 1;
-
-  mcs = rs_extract_rate(rate_n_flags);
-
-  /* SISO */
-  if (mcs <= IWL_RATE_SISO_60M_PLCP) {
-   if (num_of_ant == 1)
-    tbl->lq_type = LQ_SISO; /*else NONE*/
-  /* MIMO2 */
-  } else if (mcs <= IWL_RATE_MIMO2_60M_PLCP) {
-   if (num_of_ant == 2)
-    tbl->lq_type = LQ_MIMO2;
-  /* MIMO3 */
+
+  return 0;
+ }
+
+ /* HT or VHT */
+ if (ucode_rate & RATE_MCS_SGI_MSK)
+  rate->sgi = true;
+
+ rate->bw = ucode_rate & RATE_MCS_CHAN_WIDTH_MSK;
+
+ if (ucode_rate & RATE_MCS_HT_MSK) {
+  nss = ((ucode_rate & RATE_HT_MCS_NSS_MSK) >>
+         RATE_HT_MCS_NSS_POS) + 1;
+
+  if (nss == 1) {
+   rate->type = LQ_HT_SISO;
+   WARN_ON_ONCE(num_of_ant != 1);
+  } else if (nss == 2) {
+   rate->type = LQ_HT_MIMO2;
+   WARN_ON_ONCE(num_of_ant != 2);
   } else {
-   if (num_of_ant == 3) {
-    tbl->max_search = IWL_MAX_11N_MIMO3_SEARCH;
-    tbl->lq_type = LQ_MIMO3;
-   }
+   WARN_ON_ONCE(1);
+  }
+ } else if (ucode_rate & RATE_MCS_VHT_MSK) {
+  nss = ((ucode_rate & RATE_VHT_MCS_NSS_MSK) >>
+         RATE_VHT_MCS_NSS_POS) + 1;
+
+  if (nss == 1) {
+   rate->type = LQ_VHT_SISO;
+   WARN_ON_ONCE(num_of_ant != 1);
+  } else if (nss == 2) {
+   rate->type = LQ_VHT_MIMO2;
+   WARN_ON_ONCE(num_of_ant != 2);
+  } else {
+   WARN_ON_ONCE(1);
   }
  }
+
+ WARN_ON_ONCE(rate->bw == RATE_MCS_CHAN_WIDTH_160);
+ WARN_ON_ONCE(rate->bw == RATE_MCS_CHAN_WIDTH_80 &&
+       !is_vht(rate));
+
  return 0;
 }
 
 /* switch to another antenna/antennas and return 1 */
 /* if no other valid antenna found, return 0 */
-static int rs_toggle_antenna(u32 valid_ant, u32 *rate_n_flags,
-        struct iwl_scale_tbl_info *tbl)
+static int rs_toggle_antenna(u32 valid_ant, struct rs_rate *rate)
 {
  u8 new_ant_type;
 
- if (!tbl->ant_type || tbl->ant_type > ANT_ABC)
+ if (!rate->ant || rate->ant > ANT_ABC)
   return 0;
 
- if (!rs_is_valid_ant(valid_ant, tbl->ant_type))
+ if (!rs_is_valid_ant(valid_ant, rate->ant))
   return 0;
 
- new_ant_type = ant_toggle_lookup[tbl->ant_type];
+ new_ant_type = ant_toggle_lookup[rate->ant];
 
- while ((new_ant_type != tbl->ant_type) &&
+ while ((new_ant_type != rate->ant) &&
         !rs_is_valid_ant(valid_ant, new_ant_type))
   new_ant_type = ant_toggle_lookup[new_ant_type];
 
- if (new_ant_type == tbl->ant_type)
+ if (new_ant_type == rate->ant)
   return 0;
 
- tbl->ant_type = new_ant_type;
- *rate_n_flags &= ~RATE_MCS_ANT_ABC_MSK;
- *rate_n_flags |= new_ant_type << RATE_MCS_ANT_POS;
- return 1;
-}
+ rate->ant = new_ant_type;
 
-/**
- * Green-field mode is valid if the station supports it and
- * there are no non-GF stations present in the BSS.
- */
-static bool rs_use_green(struct ieee80211_sta *sta)
-{
- /*
-  * There's a bug somewhere in this code that causes the
-  * scaling to get stuck because GF+SGI can't be combined
-  * in SISO rates. Until we find that bug, disable GF, it
-  * has only limited benefit and we still interoperate with
-  * GF APs since we can always receive GF transmissions.
-  */
- return false;
+ return 1;
 }
 
-/**
- * rs_get_supported_rates - get the available rates
- *
- * if management frame or broadcast frame only return
- * basic available rates.
- *
- */
 static u16 rs_get_supported_rates(struct iwl_lq_sta *lq_sta,
-      struct ieee80211_hdr *hdr,
-      enum iwl_table_type rate_type)
+      struct rs_rate *rate)
 {
- if (is_legacy(rate_type)) {
+ if (is_legacy(rate))
   return lq_sta->active_legacy_rate;
- } else {
-  if (is_siso(rate_type))
-   return lq_sta->active_siso_rate;
-  else if (is_mimo2(rate_type))
-   return lq_sta->active_mimo2_rate;
-  else
-   return lq_sta->active_mimo3_rate;
- }
+ else if (is_siso(rate))
+  return lq_sta->active_siso_rate;
+ else if (is_mimo2(rate))
+  return lq_sta->active_mimo2_rate;
+
+ WARN_ON_ONCE(1);
+ return 0;
 }
 
 static u16 rs_get_adjacent_rate(struct iwl_mvm *mvm, u8 index, u16 rate_mask,
@@ -721,7 +864,7 @@ static u16 rs_get_adjacent_rate(struct iwl_mvm *mvm, u8 index, u16 rate_mask,
 
  /* 802.11A or ht walks to the next literal adjacent rate in
   * the rate table */
- if (is_a_band(rate_type) || !is_legacy(rate_type)) {
+ if (is_type_a_band(rate_type) || !is_type_legacy(rate_type)) {
   int i;
   u32 mask;
 
@@ -769,74 +912,92 @@ static u16 rs_get_adjacent_rate(struct iwl_mvm *mvm, u8 index, u16 rate_mask,
  return (high << 8) | low;
 }
 
-static u32 rs_get_lower_rate(struct iwl_lq_sta *lq_sta,
-        struct iwl_scale_tbl_info *tbl,
-        u8 scale_index, u8 ht_possible)
+static inline bool rs_rate_supported(struct iwl_lq_sta *lq_sta,
+         struct rs_rate *rate)
 {
- s32 low;
- u16 rate_mask;
+ return BIT(rate->index) & rs_get_supported_rates(lq_sta, rate);
+}
+
+/* Get the next supported lower rate in the current column.
+ * Return true if bottom rate in the current column was reached
+ */
+static bool rs_get_lower_rate_in_column(struct iwl_lq_sta *lq_sta,
+     struct rs_rate *rate)
+{
+ u8 low;
  u16 high_low;
- u8 switch_to_legacy = 0;
- u8 is_green = lq_sta->is_green;
+ u16 rate_mask;
  struct iwl_mvm *mvm = lq_sta->drv;
 
- /* check if we need to switch from HT to legacy rates.
-  * assumption is that mandatory rates (1Mbps or 6Mbps)
-  * are always supported (spec demand) */
- if (!is_legacy(tbl->lq_type) && (!ht_possible || !scale_index)) {
-  switch_to_legacy = 1;
-  scale_index = rs_ht_to_legacy[scale_index];
-  if (lq_sta->band == IEEE80211_BAND_5GHZ)
-   tbl->lq_type = LQ_A;
-  else
-   tbl->lq_type = LQ_G;
+ rate_mask = rs_get_supported_rates(lq_sta, rate);
+ high_low = rs_get_adjacent_rate(mvm, rate->index, rate_mask,
+     rate->type);
+ low = high_low & 0xff;
 
-  if (num_of_ant(tbl->ant_type) > 1)
-   tbl->ant_type =
-       first_antenna(iwl_fw_valid_tx_ant(mvm->fw));
+ /* Bottom rate of column reached */
+ if (low == IWL_RATE_INVALID)
+  return true;
 
-  tbl->is_ht40 = 0;
-  tbl->is_SGI = 0;
-  tbl->max_search = IWL_MAX_SEARCH;
- }
+ rate->index = low;
+ return false;
+}
 
- rate_mask = rs_get_supported_rates(lq_sta, NULL, tbl->lq_type);
+/* Get the next rate to use following a column downgrade */
+static void rs_get_lower_rate_down_column(struct iwl_lq_sta *lq_sta,
+       struct rs_rate *rate)
+{
+ struct iwl_mvm *mvm = lq_sta->drv;
 
- /* Mask with station rate restriction */
- if (is_legacy(tbl->lq_type)) {
-  /* supp_rates has no CCK bits in A mode */
+ if (is_legacy(rate)) {
+  /* No column to downgrade from Legacy */
+  return;
+ } else if (is_siso(rate)) {
+  /* Downgrade to Legacy if we were in SISO */
   if (lq_sta->band == IEEE80211_BAND_5GHZ)
-   rate_mask  = (u16)(rate_mask &
-      (lq_sta->supp_rates << IWL_FIRST_OFDM_RATE));
+   rate->type = LQ_LEGACY_A;
   else
-   rate_mask = (u16)(rate_mask & lq_sta->supp_rates);
- }
+   rate->type = LQ_LEGACY_G;
 
- /* If we switched from HT to legacy, check current rate */
- if (switch_to_legacy && (rate_mask & (1 << scale_index))) {
-  low = scale_index;
-  goto out;
+  rate->bw = RATE_MCS_CHAN_WIDTH_20;
+
+  WARN_ON_ONCE(rate->index < IWL_RATE_MCS_0_INDEX ||
+        rate->index > IWL_RATE_MCS_9_INDEX);
+
+  rate->index = rs_ht_to_legacy[rate->index];
+ } else {
+  /* Downgrade to SISO with same MCS if in MIMO  */
+  rate->type = is_vht_mimo2(rate) ?
+   LQ_VHT_SISO : LQ_HT_SISO;
  }
 
- high_low = rs_get_adjacent_rate(lq_sta->drv, scale_index, rate_mask,
-     tbl->lq_type);
- low = high_low & 0xff;
 
- if (low == IWL_RATE_INVALID)
-  low = scale_index;
+ if (num_of_ant(rate->ant) > 1)
+  rate->ant = first_antenna(mvm->fw->valid_tx_ant);
 
-out:
- return rate_n_flags_from_tbl(lq_sta->drv, tbl, low, is_green);
+ /* Relevant in both switching to SISO or Legacy */
+ rate->sgi = false;
+
+ if (!rs_rate_supported(lq_sta, rate))
+  rs_get_lower_rate_in_column(lq_sta, rate);
 }
 
-/*
- * Simple function to compare two rate scale table types
- */
-static bool table_type_matches(struct iwl_scale_tbl_info *a,
-          struct iwl_scale_tbl_info *b)
+/* Simple function to compare two rate scale table types */
+static inline bool rs_rate_match(struct rs_rate *a,
+     struct rs_rate *b)
+{
+ return (a->type == b->type) && (a->ant == b->ant) && (a->sgi == b->sgi);
+}
+
+static u32 rs_ch_width_from_mac_flags(enum mac80211_rate_control_flags flags)
 {
- return (a->lq_type == b->lq_type) && (a->ant_type == b->ant_type) &&
-  (a->is_SGI == b->is_SGI);
+ if (flags & IEEE80211_TX_RC_40_MHZ_WIDTH)
+  return RATE_MCS_CHAN_WIDTH_40;
+ else if (flags & IEEE80211_TX_RC_80_MHZ_WIDTH)
+  return RATE_MCS_CHAN_WIDTH_80;
+ else if (flags & IEEE80211_TX_RC_160_MHZ_WIDTH)
+  return RATE_MCS_CHAN_WIDTH_160;
+
+ return RATE_MCS_CHAN_WIDTH_20;
 }
 
 /*
@@ -848,7 +1009,7 @@ static void rs_tx_status(void *mvm_r, struct ieee80211_supported_band *sband,
 {
  int legacy_success;
  int retries;
- int rs_index, mac_index, i;
+ int mac_index, i;
  struct iwl_lq_sta *lq_sta = priv_sta;
  struct iwl_lq_cmd *table;
  struct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;
@@ -856,12 +1017,10 @@ static void rs_tx_status(void *mvm_r, struct ieee80211_supported_band *sband,
  struct iwl_mvm *mvm = IWL_OP_MODE_GET_MVM(op_mode);
  struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
  enum mac80211_rate_control_flags mac_flags;
- u32 tx_rate;
- struct iwl_scale_tbl_info tbl_type;
+ u32 ucode_rate;
+ struct rs_rate rate;
  struct iwl_scale_tbl_info *curr_tbl, *other_tbl, *tmp_tbl;
-
- IWL_DEBUG_RATE_LIMIT(mvm,
-        "get frame ack response, update rate scale window\n");
+ u8 reduced_txp = (uintptr_t)info->status.status_driver_data[0];
 
  /* Treat uninitialized rate scaling data same as non-existing. */
  if (!lq_sta) {
@@ -872,6 +1031,13 @@ static void rs_tx_status(void *mvm_r, struct ieee80211_supported_band *sband,
   return;
  }
 
+#ifdef CONFIG_MAC80211_DEBUGFS
+ /* Disable last tx check if we are debugging with fixed rate */
+ if (lq_sta->dbg_fixed_rate) {
+  IWL_DEBUG_RATE(mvm, "Fixed rate. avoid rate scaling\n");
+  return;
+ }
+#endif
  if (!ieee80211_is_data(hdr->frame_control) ||
      info->flags & IEEE80211_TX_CTL_NO_ACK)
   return;
@@ -890,10 +1056,10 @@ static void rs_tx_status(void *mvm_r, struct ieee80211_supported_band *sband,
   * to a new "search" mode (which might become the new "active" mode).
   */
  table = &lq_sta->lq;
- tx_rate = le32_to_cpu(table->rs_table[0]);
- rs_get_tbl_info_from_mcs(tx_rate, info->band, &tbl_type, &rs_index);
+ ucode_rate = le32_to_cpu(table->rs_table[0]);
+ rs_rate_from_ucode_rate(ucode_rate, info->band, &rate);
  if (info->band == IEEE80211_BAND_5GHZ)
-  rs_index -= IWL_FIRST_OFDM_RATE;
+  rate.index -= IWL_FIRST_OFDM_RATE;
  mac_flags = info->status.rates[0].flags;
  mac_index = info->status.rates[0].idx;
  /* For HT packets, map MCS to PLCP */
@@ -908,20 +1074,39 @@ static void rs_tx_status(void *mvm_r, struct ieee80211_supported_band *sband,
    */
   if (info->band == IEEE80211_BAND_2GHZ)
    mac_index += IWL_FIRST_OFDM_RATE;
+ } else if (mac_flags & IEEE80211_TX_RC_VHT_MCS) {
+  mac_index &= RATE_VHT_MCS_RATE_CODE_MSK;
+  if (mac_index >= (IWL_RATE_9M_INDEX - IWL_FIRST_OFDM_RATE))
+   mac_index++;
  }
+
+ if (time_after(jiffies,
+         (unsigned long)(lq_sta->last_tx + RS_IDLE_TIMEOUT))) {
+  int tid;
+  IWL_DEBUG_RATE(mvm, "Tx idle for too long. reinit rs\n");
+  for (tid = 0; tid < IWL_MAX_TID_COUNT; tid++)
+   ieee80211_stop_tx_ba_session(sta, tid);
+
+  iwl_mvm_rs_rate_init(mvm, sta, sband->band, false);
+  return;
+ }
+ lq_sta->last_tx = jiffies;
+
  /* Here we actually compare this rate to the latest LQ command */
  if ((mac_index < 0) ||
-     (tbl_type.is_SGI != !!(mac_flags & IEEE80211_TX_RC_SHORT_GI)) ||
-     (tbl_type.is_ht40 != !!(mac_flags & IEEE80211_TX_RC_40_MHZ_WIDTH)) ||
-     (tbl_type.ant_type != info->status.antenna) ||
-     (!!(tx_rate & RATE_MCS_HT_MSK) !=
-    !!(mac_flags & IEEE80211_TX_RC_MCS)) ||
-     (!!(tx_rate & RATE_HT_MCS_GF_MSK) !=
-    !!(mac_flags & IEEE80211_TX_RC_GREEN_FIELD)) ||
-     (rs_index != mac_index)) {
+     (rate.sgi != !!(mac_flags & IEEE80211_TX_RC_SHORT_GI)) ||
+     (rate.bw != rs_ch_width_from_mac_flags(mac_flags)) ||
+     (rate.ant != info->status.antenna) ||
+     (!!(ucode_rate & RATE_MCS_HT_MSK) !=
+      !!(mac_flags & IEEE80211_TX_RC_MCS)) ||
+     (!!(ucode_rate & RATE_MCS_VHT_MSK) !=
+      !!(mac_flags & IEEE80211_TX_RC_VHT_MCS)) ||
+     (!!(ucode_rate & RATE_HT_MCS_GF_MSK) !=
+      !!(mac_flags & IEEE80211_TX_RC_GREEN_FIELD)) ||
+     (rate.index != mac_index)) {
   IWL_DEBUG_RATE(mvm,
           "initial rate %d does not match %d (0x%x)\n",
-          mac_index, rs_index, tx_rate);
+          mac_index, rate.index, ucode_rate);
   /*
    * Since rates mis-match, the last LQ command may have failed.
    * After IWL_MISSED_RATE_MAX mis-matches, resync the uCode with
@@ -930,7 +1115,10 @@ static void rs_tx_status(void *mvm_r, struct ieee80211_supported_band *sband,
   lq_sta->missed_rate_counter++;
   if (lq_sta->missed_rate_counter > IWL_MISSED_RATE_MAX) {
    lq_sta->missed_rate_counter = 0;
-   iwl_mvm_send_lq_cmd(mvm, &lq_sta->lq, CMD_ASYNC, false);
+   IWL_DEBUG_RATE(mvm,
+           "Too many rates mismatch. Send sync LQ. rs_state %d\n",
+           lq_sta->rs_state);
+   iwl_mvm_send_lq_cmd(mvm, &lq_sta->lq, false);
   }
   /* Regardless, ignore this status info for outdated rate */
   return;
@@ -939,28 +1127,23 @@ static void rs_tx_status(void *mvm_r, struct ieee80211_supported_band *sband,
   lq_sta->missed_rate_counter = 0;
 
  /* Figure out if rate scale algorithm is in active or search table */
- if (table_type_matches(&tbl_type,
-          &(lq_sta->lq_info[lq_sta->active_tbl]))) {
+ if (rs_rate_match(&rate,
+     &(lq_sta->lq_info[lq_sta->active_tbl].rate))) {
   curr_tbl = &(lq_sta->lq_info[lq_sta->active_tbl]);
   other_tbl = &(lq_sta->lq_info[1 - lq_sta->active_tbl]);
- } else if (table_type_matches(
-   &tbl_type, &lq_sta->lq_info[1 - lq_sta->active_tbl])) {
+ } else if (rs_rate_match(&rate,
+    &lq_sta->lq_info[1 - lq_sta->active_tbl].rate)) {
   curr_tbl = &(lq_sta->lq_info[1 - lq_sta->active_tbl]);
   other_tbl = &(lq_sta->lq_info[lq_sta->active_tbl]);
  } else {
   IWL_DEBUG_RATE(mvm,
           "Neither active nor search matches tx rate\n");
   tmp_tbl = &(lq_sta->lq_info[lq_sta->active_tbl]);
-  IWL_DEBUG_RATE(mvm, "active- lq:%x, ant:%x, SGI:%d\n",
-          tmp_tbl->lq_type, tmp_tbl->ant_type,
-          tmp_tbl->is_SGI);
+  rs_dump_rate(mvm, &tmp_tbl->rate, "ACTIVE");
   tmp_tbl = &(lq_sta->lq_info[1 - lq_sta->active_tbl]);
-  IWL_DEBUG_RATE(mvm, "search- lq:%x, ant:%x, SGI:%d\n",
-          tmp_tbl->lq_type, tmp_tbl->ant_type,
-          tmp_tbl->is_SGI);
-  IWL_DEBUG_RATE(mvm, "actual- lq:%x, ant:%x, SGI:%d\n",
-          tbl_type.lq_type, tbl_type.ant_type,
-          tbl_type.is_SGI);
+  rs_dump_rate(mvm, &tmp_tbl->rate, "SEARCH");
+  rs_dump_rate(mvm, &rate, "ACTUAL");
+
   /*
    * no matching table found, let's by-pass the data collection
    * and continue to perform rate scale to find the rate table
@@ -977,15 +1160,15 @@ static void rs_tx_status(void *mvm_r, struct ieee80211_supported_band *sband,
   * first index into rate scale table.
   */
  if (info->flags & IEEE80211_TX_STAT_AMPDU) {
-  tx_rate = le32_to_cpu(table->rs_table[0]);
-  rs_get_tbl_info_from_mcs(tx_rate, info->band, &tbl_type,
-      &rs_index);
-  rs_collect_tx_data(curr_tbl, rs_index,
+  ucode_rate = le32_to_cpu(table->rs_table[0]);
+  rs_rate_from_ucode_rate(ucode_rate, info->band, &rate);
+  rs_collect_tx_data(lq_sta, curr_tbl, rate.index,
        info->status.ampdu_len,
-       info->status.ampdu_ack_len);
+       info->status.ampdu_ack_len,
+       reduced_txp);
 
   /* Update success/fail counts if not searching for new mode */
-  if (lq_sta->stay_in_tbl) {
+  if (lq_sta->rs_state == RS_STATE_STAY_IN_COLUMN) {
    lq_sta->total_success += info->status.ampdu_ack_len;
    lq_sta->total_failed += (info->status.ampdu_len -
      info->status.ampdu_ack_len);
@@ -1002,31 +1185,33 @@ static void rs_tx_status(void *mvm_r, struct ieee80211_supported_band *sband,
   legacy_success = !!(info->flags & IEEE80211_TX_STAT_ACK);
   /* Collect data for each rate used during failed TX attempts */
   for (i = 0; i <= retries; ++i) {
-   tx_rate = le32_to_cpu(table->rs_table[i]);
-   rs_get_tbl_info_from_mcs(tx_rate, info->band,
-       &tbl_type, &rs_index);
+   ucode_rate = le32_to_cpu(table->rs_table[i]);
+   rs_rate_from_ucode_rate(ucode_rate, info->band, &rate);
    /*
     * Only collect stats if retried rate is in the same RS
     * table as active/search.
     */
-   if (table_type_matches(&tbl_type, curr_tbl))
+   if (rs_rate_match(&rate, &curr_tbl->rate))
     tmp_tbl = curr_tbl;
-   else if (table_type_matches(&tbl_type, other_tbl))
+   else if (rs_rate_match(&rate, &other_tbl->rate))
     tmp_tbl = other_tbl;
    else
     continue;
-   rs_collect_tx_data(tmp_tbl, rs_index, 1,
-        i < retries ? 0 : legacy_success);
+
+   rs_collect_tx_data(lq_sta, tmp_tbl, rate.index, 1,
+        i < retries ? 0 : legacy_success,
+        reduced_txp);
   }
 
   /* Update success/fail counts if not searching for new mode */
-  if (lq_sta->stay_in_tbl) {
+  if (lq_sta->rs_state == RS_STATE_STAY_IN_COLUMN) {
    lq_sta->total_success += legacy_success;
    lq_sta->total_failed += retries + (1 - legacy_success);
   }
  }
  /* The last TX rate is cached in lq_sta; it's set in if/else above */
- lq_sta->last_rate_n_flags = tx_rate;
+ lq_sta->last_rate_n_flags = ucode_rate;
+ IWL_DEBUG_RATE(mvm, "reduced txpower: %d\n", reduced_txp);
 done:
  /* See if there's a better rate or modulation mode to try. */
  if (sta && sta->supp_rates[sband->band])
@@ -1044,8 +1229,8 @@ done:
 static void rs_set_stay_in_table(struct iwl_mvm *mvm, u8 is_legacy,
      struct iwl_lq_sta *lq_sta)
 {
- IWL_DEBUG_RATE(mvm, "we are staying in the same table\n");
- lq_sta->stay_in_tbl = 1; /* only place this gets set */
+ IWL_DEBUG_RATE(mvm, "Moving to RS_STATE_STAY_IN_COLUMN\n");
+ lq_sta->rs_state = RS_STATE_STAY_IN_COLUMN;
  if (is_legacy) {
   lq_sta->table_count_limit = IWL_LEGACY_TABLE_COUNT;
   lq_sta->max_failure_limit = IWL_LEGACY_FAILURE_LIMIT;
@@ -1059,957 +1244,695 @@ static void rs_set_stay_in_table(struct iwl_mvm *mvm, u8 is_legacy,
  lq_sta->total_failed = 0;
  lq_sta->total_success = 0;
  lq_sta->flush_timer = jiffies;
- lq_sta->action_counter = 0;
+ lq_sta->visited_columns = 0;
 }
 
-/*
- * Find correct throughput table for given mode of modulation
- */
-static void rs_set_expected_tpt_table(struct iwl_lq_sta *lq_sta,
-          struct iwl_scale_tbl_info *tbl)
+static int rs_get_max_allowed_rate(struct iwl_lq_sta *lq_sta,
+       const struct rs_tx_column *column)
+{
+ switch (column->mode) {
+ case RS_LEGACY:
+  return lq_sta->max_legacy_rate_idx;
+ case RS_SISO:
+  return lq_sta->max_siso_rate_idx;
+ case RS_MIMO2:
+  return lq_sta->max_mimo2_rate_idx;
+ default:
+  WARN_ON_ONCE(1);
+ }
+
+ return lq_sta->max_legacy_rate_idx;
+}
+
+static const u16 *rs_get_expected_tpt_table(struct iwl_lq_sta *lq_sta,
+         const struct rs_tx_column *column,
+         u32 bw)
 {
  /* Used to choose among HT tables */
- s32 (*ht_tbl_pointer)[IWL_RATE_COUNT];
+ const u16 (*ht_tbl_pointer)[IWL_RATE_COUNT];
 
- /* Check for invalid LQ type */
- if (WARN_ON_ONCE(!is_legacy(tbl->lq_type) && !is_Ht(tbl->lq_type))) {
-  tbl->expected_tpt = expected_tpt_legacy;
-  return;
- }
+ if (WARN_ON_ONCE(column->mode != RS_LEGACY &&
+    column->mode != RS_SISO &&
+    column->mode != RS_MIMO2))
+  return expected_tpt_legacy;
 
  /* Legacy rates have only one table */
- if (is_legacy(tbl->lq_type)) {
-  tbl->expected_tpt = expected_tpt_legacy;
-  return;
- }
+ if (column->mode == RS_LEGACY)
+  return expected_tpt_legacy;
 
+ ht_tbl_pointer = expected_tpt_mimo2_20MHz;
  /* Choose among many HT tables depending on number of streams
-  * (SISO/MIMO2/MIMO3), channel width (20/40), SGI, and aggregation
+  * (SISO/MIMO2), channel width (20/40/80), SGI, and aggregation
   * status */
- if (is_siso(tbl->lq_type) && !tbl->is_ht40)
-  ht_tbl_pointer = expected_tpt_siso20MHz;
- else if (is_siso(tbl->lq_type))
-  ht_tbl_pointer = expected_tpt_siso40MHz;
- else if (is_mimo2(tbl->lq_type) && !tbl->is_ht40)
-  ht_tbl_pointer = expected_tpt_mimo2_20MHz;
- else if (is_mimo2(tbl->lq_type))
-  ht_tbl_pointer = expected_tpt_mimo2_40MHz;
- else if (is_mimo3(tbl->lq_type) && !tbl->is_ht40)
-  ht_tbl_pointer = expected_tpt_mimo3_20MHz;
- else /* if (is_mimo3(tbl->lq_type)) <-- must be true */
-  ht_tbl_pointer = expected_tpt_mimo3_40MHz;
-
- if (!tbl->is_SGI && !lq_sta->is_agg)  /* Normal */
-  tbl->expected_tpt = ht_tbl_pointer[0];
- else if (tbl->is_SGI && !lq_sta->is_agg) /* SGI */
-  tbl->expected_tpt = ht_tbl_pointer[1];
- else if (!tbl->is_SGI && lq_sta->is_agg) /* AGG */
-  tbl->expected_tpt = ht_tbl_pointer[2];
+ if (column->mode == RS_SISO) {
+  switch (bw) {
+  case RATE_MCS_CHAN_WIDTH_20:
+   ht_tbl_pointer = expected_tpt_siso_20MHz;
+   break;
+  case RATE_MCS_CHAN_WIDTH_40:
+   ht_tbl_pointer = expected_tpt_siso_40MHz;
+   break;
+  case RATE_MCS_CHAN_WIDTH_80:
+   ht_tbl_pointer = expected_tpt_siso_80MHz;
+   break;
+  default:
+   WARN_ON_ONCE(1);
+  }
+ } else if (column->mode == RS_MIMO2) {
+  switch (bw) {
+  case RATE_MCS_CHAN_WIDTH_20:
+   ht_tbl_pointer = expected_tpt_mimo2_20MHz;
+   break;
+  case RATE_MCS_CHAN_WIDTH_40:
+   ht_tbl_pointer = expected_tpt_mimo2_40MHz;
+   break;
+  case RATE_MCS_CHAN_WIDTH_80:
+   ht_tbl_pointer = expected_tpt_mimo2_80MHz;
+   break;
+  default:
+   WARN_ON_ONCE(1);
+  }
+ } else {
+  WARN_ON_ONCE(1);
+ }
+
+ if (!column->sgi && !lq_sta->is_agg)  /* Normal */
+  return ht_tbl_pointer[0];
+ else if (column->sgi && !lq_sta->is_agg)        /* SGI */
+  return ht_tbl_pointer[1];
+ else if (!column->sgi && lq_sta->is_agg)        /* AGG */
+  return ht_tbl_pointer[2];
  else      /* AGG+SGI */
-  tbl->expected_tpt = ht_tbl_pointer[3];
+  return ht_tbl_pointer[3];
+}
+
+static void rs_set_expected_tpt_table(struct iwl_lq_sta *lq_sta,
+          struct iwl_scale_tbl_info *tbl)
+{
+ struct rs_rate *rate = &tbl->rate;
+ const struct rs_tx_column *column = &rs_tx_columns[tbl->column];
+
+ tbl->expected_tpt = rs_get_expected_tpt_table(lq_sta, column, rate->bw);
 }
 
-/*
- * Find starting rate for new "search" high-throughput mode of modulation.
- * Goal is to find lowest expected rate (under perfect conditions) that is
- * above the current measured throughput of "active" mode, to give new mode
- * a fair chance to prove itself without too many challenges.
- *
- * This gets called when transitioning to more aggressive modulation
- * (i.e. legacy to SISO or MIMO, or SISO to MIMO), as well as less aggressive
- * (i.e. MIMO to SISO).  When moving to MIMO, bit rate will typically need
- * to decrease to match "active" throughput.  When moving from MIMO to SISO,
- * bit rate will typically need to increase, but not if performance was bad.
- */
 static s32 rs_get_best_rate(struct iwl_mvm *mvm,
        struct iwl_lq_sta *lq_sta,
        struct iwl_scale_tbl_info *tbl, /* "search" */
-       u16 rate_mask, s8 index)
+       unsigned long rate_mask, s8 index)
 {
- /* "active" values */
  struct iwl_scale_tbl_info *active_tbl =
      &(lq_sta->lq_info[lq_sta->active_tbl]);
- s32 active_sr = active_tbl->win[index].success_ratio;
- s32 active_tpt = active_tbl->expected_tpt[index];
-
- /* expected "search" throughput */
- s32 *tpt_tbl = tbl->expected_tpt;
-
- s32 new_rate, high, low, start_hi;
+ s32 success_ratio = active_tbl->win[index].success_ratio;
+ u16 expected_current_tpt = active_tbl->expected_tpt[index];
+ const u16 *tpt_tbl = tbl->expected_tpt;
  u16 high_low;
- s8 rate = index;
-
- new_rate = high = low = start_hi = IWL_RATE_INVALID;
-
- while (1) {
-  high_low = rs_get_adjacent_rate(mvm, rate, rate_mask,
-      tbl->lq_type);
-
-  low = high_low & 0xff;
-  high = (high_low >> 8) & 0xff;
-
-  /*
-   * Lower the "search" bit rate, to give new "search" mode
-   * approximately the same throughput as "active" if:
-   *
-   * 1) "Active" mode has been working modestly well (but not
-   *    great), and expected "search" throughput (under perfect
-   *    conditions) at candidate rate is above the actual
-   *    measured "active" throughput (but less than expected
-   *    "active" throughput under perfect conditions).
-   * OR
-   * 2) "Active" mode has been working perfectly or very well
-   *    and expected "search" throughput (under perfect
-   *    conditions) at candidate rate is above expected
-   *    "active" throughput (under perfect conditions).
-   */
-  if ((((100 * tpt_tbl[rate]) > lq_sta->last_tpt) &&
-       ((active_sr > IWL_RATE_DECREASE_TH) &&
-        (active_sr <= IWL_RATE_HIGH_TH) &&
-        (tpt_tbl[rate] <= active_tpt))) ||
-      ((active_sr >= IWL_RATE_SCALE_SWITCH) &&
-       (tpt_tbl[rate] > active_tpt))) {
-   /* (2nd or later pass)
-    * If we've already tried to raise the rate, and are
-    * now trying to lower it, use the higher rate. */
-   if (start_hi != IWL_RATE_INVALID) {
-    new_rate = start_hi;
-    break;
-   }
-
-   new_rate = rate;
+ u32 target_tpt;
+ int rate_idx;
 
-   /* Loop again with lower rate */
-   if (low != IWL_RATE_INVALID)
-    rate = low;
+ if (success_ratio > RS_SR_NO_DECREASE) {
+  target_tpt = 100 * expected_current_tpt;
+  IWL_DEBUG_RATE(mvm,
+          "SR %d high. Find rate exceeding EXPECTED_CURRENT %d\n",
+          success_ratio, target_tpt);
+ } else {
+  target_tpt = lq_sta->last_tpt;
+  IWL_DEBUG_RATE(mvm,
+          "SR %d not thag good. Find rate exceeding ACTUAL_TPT %d\n",
+          success_ratio, target_tpt);
+ }
 
-   /* Lower rate not available, use the original */
-   else
-    break;
+ rate_idx = find_first_bit(&rate_mask, BITS_PER_LONG);
 
-  /* Else try to raise the "search" rate to match "active" */
-  } else {
-   /* (2nd or later pass)
-    * If we've already tried to lower the rate, and are
-    * now trying to raise it, use the lower rate. */
-   if (new_rate != IWL_RATE_INVALID)
-    break;
+ while (rate_idx != IWL_RATE_INVALID) {
+  if (target_tpt < (100 * tpt_tbl[rate_idx]))
+   break;
 
-   /* Loop again with higher rate */
-   else if (high != IWL_RATE_INVALID) {
-    start_hi = high;
-    rate = high;
+  high_low = rs_get_adjacent_rate(mvm, rate_idx, rate_mask,
+      tbl->rate.type);
 
-   /* Higher rate not available, use the original */
-   } else {
-    new_rate = rate;
-    break;
-   }
-  }
+  rate_idx = (high_low >> 8) & 0xff;
  }
 
- return new_rate;
-}
+ IWL_DEBUG_RATE(mvm, "Best rate found %d target_tp %d expected_new %d\n",
+         rate_idx, target_tpt,
+         rate_idx != IWL_RATE_INVALID ?
+         100 * tpt_tbl[rate_idx] : IWL_INVALID_VALUE);
 
-static bool iwl_is_ht40_tx_allowed(struct ieee80211_sta *sta)
-{
- return sta->bandwidth >= IEEE80211_STA_RX_BW_40;
+ return rate_idx;
 }
 
-/*
- * Set up search table for MIMO2
- */
-static int rs_switch_to_mimo2(struct iwl_mvm *mvm,
-        struct iwl_lq_sta *lq_sta,
-        struct ieee80211_sta *sta,
-        struct iwl_scale_tbl_info *tbl, int index)
+static u32 rs_bw_from_sta_bw(struct ieee80211_sta *sta)
 {
- u16 rate_mask;
- s32 rate;
- s8 is_green = lq_sta->is_green;
-
- if (!sta->ht_cap.ht_supported)
-  return -1;
-
- if (sta->smps_mode == IEEE80211_SMPS_STATIC)
-  return -1;
-
- /* Need both Tx chains/antennas to support MIMO */
- if (num_of_ant(iwl_fw_valid_tx_ant(mvm->fw)) < 2)
-  return -1;
-
- IWL_DEBUG_RATE(mvm, "LQ: try to switch to MIMO2\n");
-
- tbl->lq_type = LQ_MIMO2;
- tbl->action = 0;
- tbl->max_search = IWL_MAX_SEARCH;
- rate_mask = lq_sta->active_mimo2_rate;
-
- if (iwl_is_ht40_tx_allowed(sta))
-  tbl->is_ht40 = 1;
- else
-  tbl->is_ht40 = 0;
-
- rs_set_expected_tpt_table(lq_sta, tbl);
-
- rate = rs_get_best_rate(mvm, lq_sta, tbl, rate_mask, index);
-
- IWL_DEBUG_RATE(mvm, "LQ: MIMO2 best rate %d mask %X\n",
-         rate, rate_mask);
- if ((rate == IWL_RATE_INVALID) || !((1 << rate) & rate_mask)) {
-  IWL_DEBUG_RATE(mvm, "Can't switch with index %d rate mask %x\n",
-          rate, rate_mask);
-  return -1;
- }
- tbl->current_rate = rate_n_flags_from_tbl(mvm, tbl, rate, is_green);
+ if (sta->bandwidth >= IEEE80211_STA_RX_BW_80)
+  return RATE_MCS_CHAN_WIDTH_80;
+ else if (sta->bandwidth >= IEEE80211_STA_RX_BW_40)
+  return RATE_MCS_CHAN_WIDTH_40;
 
- IWL_DEBUG_RATE(mvm, "LQ: Switch to new mcs %X index is green %X\n",
-         tbl->current_rate, is_green);
- return 0;
+ return RATE_MCS_CHAN_WIDTH_20;
 }
 
 /*
- * Set up search table for MIMO3
+ * Check whether we should continue using same modulation mode, or
+ * begin search for a new mode, based on:
+ * 1) # tx successes or failures while using this mode
+ * 2) # times calling this function
+ * 3) elapsed time in this mode (not used, for now)
  */
-static int rs_switch_to_mimo3(struct iwl_mvm *mvm,
-        struct iwl_lq_sta *lq_sta,
-        struct ieee80211_sta *sta,
-        struct iwl_scale_tbl_info *tbl, int index)
+static void rs_stay_in_table(struct iwl_lq_sta *lq_sta, bool force_search)
 {
- u16 rate_mask;
- s32 rate;
- s8 is_green = lq_sta->is_green;
-
- if (!sta->ht_cap.ht_supported)
-  return -1;
-
- if (sta->smps_mode == IEEE80211_SMPS_STATIC)
-  return -1;
+ struct iwl_scale_tbl_info *tbl;
+ int active_tbl;
+ int flush_interval_passed = 0;
+ struct iwl_mvm *mvm;
 
- /* Need both Tx chains/antennas to support MIMO */
- if (num_of_ant(iwl_fw_valid_tx_ant(mvm->fw)) < 3)
-  return -1;
+ mvm = lq_sta->drv;
+ active_tbl = lq_sta->active_tbl;
 
- IWL_DEBUG_RATE(mvm, "LQ: try to switch to MIMO3\n");
+ tbl = &(lq_sta->lq_info[active_tbl]);
 
- tbl->lq_type = LQ_MIMO3;
- tbl->action = 0;
- tbl->max_search = IWL_MAX_11N_MIMO3_SEARCH;
- rate_mask = lq_sta->active_mimo3_rate;
+ /* If we've been disallowing search, see if we should now allow it */
+ if (lq_sta->rs_state == RS_STATE_STAY_IN_COLUMN) {
+  /* Elapsed time using current modulation mode */
+  if (lq_sta->flush_timer)
+   flush_interval_passed =
+    time_after(jiffies,
+        (unsigned long)(lq_sta->flush_timer +
+      RS_STAY_IN_COLUMN_TIMEOUT));
 
- if (iwl_is_ht40_tx_allowed(sta))
-  tbl->is_ht40 = 1;
- else
-  tbl->is_ht40 = 0;
+  /*
+   * Check if we should allow search for new modulation mode.
+   * If many frames have failed or succeeded, or we've used
+   * this same modulation for a long time, allow search, and
+   * reset history stats that keep track of whether we should
+   * allow a new search.  Also (below) reset all bitmaps and
+   * stats in active history.
+   */
+  if (force_search ||
+      (lq_sta->total_failed > lq_sta->max_failure_limit) ||
+      (lq_sta->total_success > lq_sta->max_success_limit) ||
+      ((!lq_sta->search_better_tbl) &&
+       (lq_sta->flush_timer) && (flush_interval_passed))) {
+   IWL_DEBUG_RATE(mvm,
+           "LQ: stay is expired %d %d %d\n",
+         lq_sta->total_failed,
+         lq_sta->total_success,
+         flush_interval_passed);
 
- rs_set_expected_tpt_table(lq_sta, tbl);
+   /* Allow search for new mode */
+   lq_sta->rs_state = RS_STATE_SEARCH_CYCLE_STARTED;
+   IWL_DEBUG_RATE(mvm,
+           "Moving to RS_STATE_SEARCH_CYCLE_STARTED\n");
+   lq_sta->total_failed = 0;
+   lq_sta->total_success = 0;
+   lq_sta->flush_timer = 0;
+   /* mark the current column as visited */
+   lq_sta->visited_columns = BIT(tbl->column);
+  /*
+   * Else if we've used this modulation mode enough repetitions
+   * (regardless of elapsed time or success/failure), reset
+   * history bitmaps and rate-specific stats for all rates in
+   * active table.
+   */
+  } else {
+   lq_sta->table_count++;
+   if (lq_sta->table_count >=
+       lq_sta->table_count_limit) {
+    lq_sta->table_count = 0;
 
- rate = rs_get_best_rate(mvm, lq_sta, tbl, rate_mask, index);
+    IWL_DEBUG_RATE(mvm,
+            "LQ: stay in table clear win\n");
+    rs_rate_scale_clear_tbl_windows(mvm, tbl);
+   }
+  }
 
- IWL_DEBUG_RATE(mvm, "LQ: MIMO3 best rate %d mask %X\n",
-         rate, rate_mask);
- if ((rate == IWL_RATE_INVALID) || !((1 << rate) & rate_mask)) {
-  IWL_DEBUG_RATE(mvm, "Can't switch with index %d rate mask %x\n",
-          rate, rate_mask);
-  return -1;
+  /* If transitioning to allow "search", reset all history
+   * bitmaps and stats in active table (this will become the new
+   * "search" table). */
+  if (lq_sta->rs_state == RS_STATE_SEARCH_CYCLE_STARTED) {
+   rs_rate_scale_clear_tbl_windows(mvm, tbl);
+  }
  }
- tbl->current_rate = rate_n_flags_from_tbl(mvm, tbl, rate, is_green);
-
- IWL_DEBUG_RATE(mvm, "LQ: Switch to new mcs %X index is green %X\n",
-         tbl->current_rate, is_green);
- return 0;
 }
 
 /*
- * Set up search table for SISO
+ * setup rate table in uCode
  */
-static int rs_switch_to_siso(struct iwl_mvm *mvm,
-        struct iwl_lq_sta *lq_sta,
-        struct ieee80211_sta *sta,
-        struct iwl_scale_tbl_info *tbl, int index)
+static void rs_update_rate_tbl(struct iwl_mvm *mvm,
+          struct ieee80211_sta *sta,
+          struct iwl_lq_sta *lq_sta,
+          struct rs_rate *rate)
 {
- u16 rate_mask;
- u8 is_green = lq_sta->is_green;
- s32 rate;
-
- if (!sta->ht_cap.ht_supported)
-  return -1;
-
- IWL_DEBUG_RATE(mvm, "LQ: try to switch to SISO\n");
-
- tbl->lq_type = LQ_SISO;
- tbl->action = 0;
- tbl->max_search = IWL_MAX_SEARCH;
- rate_mask = lq_sta->active_siso_rate;
+ rs_fill_lq_cmd(mvm, sta, lq_sta, rate);
+ iwl_mvm_send_lq_cmd(mvm, &lq_sta->lq, false);
+}
 
- if (iwl_is_ht40_tx_allowed(sta))
-  tbl->is_ht40 = 1;
- else
-  tbl->is_ht40 = 0;
+static u8 rs_get_tid(struct iwl_lq_sta *lq_data,
+       struct ieee80211_hdr *hdr)
+{
+ u8 tid = IWL_MAX_TID_COUNT;
 
- if (is_green)
-  tbl->is_SGI = 0; /*11n spec: no SGI in SISO+Greenfield*/
+ if (ieee80211_is_data_qos(hdr->frame_control)) {
+  u8 *qc = ieee80211_get_qos_ctl(hdr);
+  tid = qc[0] & 0xf;
+ }
 
- rs_set_expected_tpt_table(lq_sta, tbl);
- rate = rs_get_best_rate(mvm, lq_sta, tbl, rate_mask, index);
+ if (unlikely(tid > IWL_MAX_TID_COUNT))
+  tid = IWL_MAX_TID_COUNT;
 
- IWL_DEBUG_RATE(mvm, "LQ: get best rate %d mask %X\n", rate, rate_mask);
- if ((rate == IWL_RATE_INVALID) || !((1 << rate) & rate_mask)) {
-  IWL_DEBUG_RATE(mvm,
-          "can not switch with index %d rate mask %x\n",
-          rate, rate_mask);
-  return -1;
- }
- tbl->current_rate = rate_n_flags_from_tbl(mvm, tbl, rate, is_green);
- IWL_DEBUG_RATE(mvm, "LQ: Switch to new mcs %X index is green %X\n",
-         tbl->current_rate, is_green);
- return 0;
+ return tid;
 }
 
-/*
- * Try to switch to new modulation mode from legacy
- */
-static int rs_move_legacy_other(struct iwl_mvm *mvm,
-    struct iwl_lq_sta *lq_sta,
-    struct ieee80211_sta *sta,
-    int index)
+static enum rs_column rs_get_next_column(struct iwl_mvm *mvm,
+      struct iwl_lq_sta *lq_sta,
+      struct ieee80211_sta *sta,
+      struct iwl_scale_tbl_info *tbl)
 {
- struct iwl_scale_tbl_info *tbl = &(lq_sta->lq_info[lq_sta->active_tbl]);
- struct iwl_scale_tbl_info *search_tbl =
-    &(lq_sta->lq_info[(1 - lq_sta->active_tbl)]);
- struct iwl_rate_scale_data *window = &(tbl->win[index]);
- u32 sz = (sizeof(struct iwl_scale_tbl_info) -
-    (sizeof(struct iwl_rate_scale_data) * IWL_RATE_COUNT));
- u8 start_action;
- u8 valid_tx_ant = iwl_fw_valid_tx_ant(mvm->fw);
- u8 tx_chains_num = num_of_ant(valid_tx_ant);
- int ret;
- u8 update_search_tbl_counter = 0;
-
- start_action = tbl->action;
- while (1) {
-  lq_sta->action_counter++;
-  switch (tbl->action) {
-  case IWL_LEGACY_SWITCH_ANTENNA1:
-  case IWL_LEGACY_SWITCH_ANTENNA2:
-   IWL_DEBUG_RATE(mvm, "LQ: Legacy toggle Antenna\n");
-
-   if ((tbl->action == IWL_LEGACY_SWITCH_ANTENNA1 &&
-        tx_chains_num <= 1) ||
-       (tbl->action == IWL_LEGACY_SWITCH_ANTENNA2 &&
-        tx_chains_num <= 2))
-    break;
-
-   /* Don't change antenna if success has been great */
-   if (window->success_ratio >= IWL_RS_GOOD_RATIO)
-    break;
+ int i, j, max_rate;
+ enum rs_column next_col_id;
+ const struct rs_tx_column *curr_col = &rs_tx_columns[tbl->column];
+ const struct rs_tx_column *next_col;
+ allow_column_func_t allow_func;
+ u8 valid_ants = mvm->fw->valid_tx_ant;
+ const u16 *expected_tpt_tbl;
+ u16 tpt, max_expected_tpt;
+
+ for (i = 0; i < MAX_NEXT_COLUMNS; i++) {
+  next_col_id = curr_col->next_columns[i];
+
+  if (next_col_id == RS_COLUMN_INVALID)
+   continue;
+
+  if (lq_sta->visited_columns & BIT(next_col_id)) {
+   IWL_DEBUG_RATE(mvm, "Skip already visited column %d\n",
+           next_col_id);
+   continue;
+  }
 
-   /* Set up search table to try other antenna */
-   memcpy(search_tbl, tbl, sz);
+  next_col = &rs_tx_columns[next_col_id];
 
-   if (rs_toggle_antenna(valid_tx_ant,
-           &search_tbl->current_rate,
-           search_tbl)) {
-    update_search_tbl_counter = 1;
-    rs_set_expected_tpt_table(lq_sta, search_tbl);
-    goto out;
-   }
-   break;
-  case IWL_LEGACY_SWITCH_SISO:
-   IWL_DEBUG_RATE(mvm, "LQ: Legacy switch to SISO\n");
-
-   /* Set up search table to try SISO */
-   memcpy(search_tbl, tbl, sz);
-   search_tbl->is_SGI = 0;
-   ret = rs_switch_to_siso(mvm, lq_sta, sta,
-       search_tbl, index);
-   if (!ret) {
-    lq_sta->action_counter = 0;
-    goto out;
-   }
-
-   break;
-  case IWL_LEGACY_SWITCH_MIMO2_AB:
-  case IWL_LEGACY_SWITCH_MIMO2_AC:
-  case IWL_LEGACY_SWITCH_MIMO2_BC:
-   IWL_DEBUG_RATE(mvm, "LQ: Legacy switch to MIMO2\n");
-
-   /* Set up search table to try MIMO */
-   memcpy(search_tbl, tbl, sz);
-   search_tbl->is_SGI = 0;
-
-   if (tbl->action == IWL_LEGACY_SWITCH_MIMO2_AB)
-    search_tbl->ant_type = ANT_AB;
-   else if (tbl->action == IWL_LEGACY_SWITCH_MIMO2_AC)
-    search_tbl->ant_type = ANT_AC;
-   else
-    search_tbl->ant_type = ANT_BC;
+  if (!rs_is_valid_ant(valid_ants, next_col->ant)) {
+   IWL_DEBUG_RATE(mvm,
+           "Skip column %d as ANT config isn't supported by chip. valid_ants 0x%x column ant 0x%x\n",
+           next_col_id, valid_ants, next_col->ant);
+   continue;
+  }
 
-   if (!rs_is_valid_ant(valid_tx_ant,
-          search_tbl->ant_type))
+  for (j = 0; j < MAX_COLUMN_CHECKS; j++) {
+   allow_func = next_col->checks[j];
+   if (allow_func && !allow_func(mvm, sta, tbl))
     break;
+  }
 
-   ret = rs_switch_to_mimo2(mvm, lq_sta, sta,
-       search_tbl, index);
-   if (!ret) {
-    lq_sta->action_counter = 0;
-    goto out;
-   }
-   break;
-
-  case IWL_LEGACY_SWITCH_MIMO3_ABC:
-   IWL_DEBUG_RATE(mvm, "LQ: Legacy switch to MIMO3\n");
+  if (j != MAX_COLUMN_CHECKS) {
+   IWL_DEBUG_RATE(mvm,
+           "Skip column %d: not allowed (check %d failed)\n",
+           next_col_id, j);
 
-   /* Set up search table to try MIMO3 */
-   memcpy(search_tbl, tbl, sz);
-   search_tbl->is_SGI = 0;
+   continue;
+  }
 
-   search_tbl->ant_type = ANT_ABC;
+  tpt = lq_sta->last_tpt / 100;
+  expected_tpt_tbl = rs_get_expected_tpt_table(lq_sta, next_col,
+           rs_bw_from_sta_bw(sta));
+  if (WARN_ON_ONCE(!expected_tpt_tbl))
+   continue;
 
-   if (!rs_is_valid_ant(valid_tx_ant,
-          search_tbl->ant_type))
-    break;
+  max_rate = rs_get_max_allowed_rate(lq_sta, next_col);
+  if (WARN_ON_ONCE(max_rate == IWL_RATE_INVALID))
+   continue;
 
-   ret = rs_switch_to_mimo3(mvm, lq_sta, sta,
-       search_tbl, index);
-   if (!ret) {
-    lq_sta->action_counter = 0;
-    goto out;
-   }
-   break;
+  max_expected_tpt = expected_tpt_tbl[max_rate];
+  if (tpt >= max_expected_tpt) {
+   IWL_DEBUG_RATE(mvm,
+           "Skip column %d: can't beat current TPT. Max expected %d current %d\n",
+           next_col_id, max_expected_tpt, tpt);
+   continue;
   }
-  tbl->action++;
-  if (tbl->action > IWL_LEGACY_SWITCH_MIMO3_ABC)
-   tbl->action = IWL_LEGACY_SWITCH_ANTENNA1;
 
-  if (tbl->action == start_action)
-   break;
+  IWL_DEBUG_RATE(mvm,
+          "Found potential column %d. Max expected %d current %d\n",
+          next_col_id, max_expected_tpt, tpt);
+  break;
  }
- search_tbl->lq_type = LQ_NONE;
- return 0;
 
-out:
- lq_sta->search_better_tbl = 1;
- tbl->action++;
- if (tbl->action > IWL_LEGACY_SWITCH_MIMO3_ABC)
-  tbl->action = IWL_LEGACY_SWITCH_ANTENNA1;
- if (update_search_tbl_counter)
-  search_tbl->action = tbl->action;
- return 0;
+ if (i == MAX_NEXT_COLUMNS)
+  return RS_COLUMN_INVALID;
+
+ return next_col_id;
 }
 
-/*
- * Try to switch to new modulation mode from SISO
- */
-static int rs_move_siso_to_other(struct iwl_mvm *mvm,
-     struct iwl_lq_sta *lq_sta,
-     struct ieee80211_sta *sta, int index)
+static int rs_switch_to_column(struct iwl_mvm *mvm,
+          struct iwl_lq_sta *lq_sta,
+          struct ieee80211_sta *sta,
+          enum rs_column col_id)
 {
- u8 is_green = lq_sta->is_green;
  struct iwl_scale_tbl_info *tbl = &(lq_sta->lq_info[lq_sta->active_tbl]);
  struct iwl_scale_tbl_info *search_tbl =
     &(lq_sta->lq_info[(1 - lq_sta->active_tbl)]);
- struct iwl_rate_scale_data *window = &(tbl->win[index]);
- struct ieee80211_sta_ht_cap *ht_cap = &sta->ht_cap;
+ struct rs_rate *rate = &search_tbl->rate;
+ const struct rs_tx_column *column = &rs_tx_columns[col_id];
+ const struct rs_tx_column *curr_column = &rs_tx_columns[tbl->column];
  u32 sz = (sizeof(struct iwl_scale_tbl_info) -
     (sizeof(struct iwl_rate_scale_data) * IWL_RATE_COUNT));
- u8 start_action;
- u8 valid_tx_ant = iwl_fw_valid_tx_ant(mvm->fw);
- u8 tx_chains_num = num_of_ant(valid_tx_ant);
- u8 update_search_tbl_counter = 0;
- int ret;
+ unsigned long rate_mask = 0;
+ u32 rate_idx = 0;
 
- start_action = tbl->action;
- while (1) {
-  lq_sta->action_counter++;
-  switch (tbl->action) {
-  case IWL_SISO_SWITCH_ANTENNA1:
-  case IWL_SISO_SWITCH_ANTENNA2:
-   IWL_DEBUG_RATE(mvm, "LQ: SISO toggle Antenna\n");
-   if ((tbl->action == IWL_SISO_SWITCH_ANTENNA1 &&
-        tx_chains_num <= 1) ||
-       (tbl->action == IWL_SISO_SWITCH_ANTENNA2 &&
-        tx_chains_num <= 2))
-    break;
+ memcpy(search_tbl, tbl, sz);
 
-   if (window->success_ratio >= IWL_RS_GOOD_RATIO)
-    break;
+ rate->sgi = column->sgi;
+ rate->ant = column->ant;
 
-   memcpy(search_tbl, tbl, sz);
-   if (rs_toggle_antenna(valid_tx_ant,
-           &search_tbl->current_rate,
-           search_tbl)) {
-    update_search_tbl_counter = 1;
-    goto out;
-   }
-   break;
-  case IWL_SISO_SWITCH_MIMO2_AB:
-  case IWL_SISO_SWITCH_MIMO2_AC:
-  case IWL_SISO_SWITCH_MIMO2_BC:
-   IWL_DEBUG_RATE(mvm, "LQ: SISO switch to MIMO2\n");
-   memcpy(search_tbl, tbl, sz);
-   search_tbl->is_SGI = 0;
-
-   if (tbl->action == IWL_SISO_SWITCH_MIMO2_AB)
-    search_tbl->ant_type = ANT_AB;
-   else if (tbl->action == IWL_SISO_SWITCH_MIMO2_AC)
-    search_tbl->ant_type = ANT_AC;
-   else
-    search_tbl->ant_type = ANT_BC;
+ if (column->mode == RS_LEGACY) {
+  if (lq_sta->band == IEEE80211_BAND_5GHZ)
+   rate->type = LQ_LEGACY_A;
+  else
+   rate->type = LQ_LEGACY_G;
+
+  rate_mask = lq_sta->active_legacy_rate;
+ } else if (column->mode == RS_SISO) {
+  rate->type = lq_sta->is_vht ? LQ_VHT_SISO : LQ_HT_SISO;
+  rate_mask = lq_sta->active_siso_rate;
+ } else if (column->mode == RS_MIMO2) {
+  rate->type = lq_sta->is_vht ? LQ_VHT_MIMO2 : LQ_HT_MIMO2;
+  rate_mask = lq_sta->active_mimo2_rate;
+ } else {
+  WARN_ON_ONCE("Bad column mode");
+ }
 
-   if (!rs_is_valid_ant(valid_tx_ant,
-          search_tbl->ant_type))
-    break;
+ rate->bw = rs_bw_from_sta_bw(sta);
+ search_tbl->column = col_id;
+ rs_set_expected_tpt_table(lq_sta, search_tbl);
 
-   ret = rs_switch_to_mimo2(mvm, lq_sta, sta,
-       search_tbl, index);
-   if (!ret)
-    goto out;
-   break;
-  case IWL_SISO_SWITCH_GI:
-   if (!tbl->is_ht40 && !(ht_cap->cap &
-      IEEE80211_HT_CAP_SGI_20))
-    break;
-   if (tbl->is_ht40 && !(ht_cap->cap &
-      IEEE80211_HT_CAP_SGI_40))
-    break;
+ lq_sta->visited_columns |= BIT(col_id);
 
-   IWL_DEBUG_RATE(mvm, "LQ: SISO toggle SGI/NGI\n");
+ /* Get the best matching rate if we're changing modes. e.g.
+  * SISO->MIMO, LEGACY->SISO, MIMO->SISO
+  */
+ if (curr_column->mode != column->mode) {
+  rate_idx = rs_get_best_rate(mvm, lq_sta, search_tbl,
+         rate_mask, rate->index);
 
-   memcpy(search_tbl, tbl, sz);
-   if (is_green) {
-    if (!tbl->is_SGI)
-     break;
-    else
-     IWL_ERR(mvm,
-      "SGI was set in GF+SISO\n");
-   }
-   search_tbl->is_SGI = !tbl->is_SGI;
-   rs_set_expected_tpt_table(lq_sta, search_tbl);
-   if (tbl->is_SGI) {
-    s32 tpt = lq_sta->last_tpt / 100;
-    if (tpt >= search_tbl->expected_tpt[index])
-     break;
-   }
-   search_tbl->current_rate =
-    rate_n_flags_from_tbl(mvm, search_tbl,
-            index, is_green);
-   update_search_tbl_counter = 1;
-   goto out;
-  case IWL_SISO_SWITCH_MIMO3_ABC:
-   IWL_DEBUG_RATE(mvm, "LQ: SISO switch to MIMO3\n");
-   memcpy(search_tbl, tbl, sz);
-   search_tbl->is_SGI = 0;
-   search_tbl->ant_type = ANT_ABC;
-
-   if (!rs_is_valid_ant(valid_tx_ant,
-          search_tbl->ant_type))
-    break;
+  if ((rate_idx == IWL_RATE_INVALID) ||
+      !(BIT(rate_idx) & rate_mask)) {
+   IWL_DEBUG_RATE(mvm,
+           "can not switch with index %d"
+           " rate mask %lx\n",
+           rate_idx, rate_mask);
 
-   ret = rs_switch_to_mimo3(mvm, lq_sta, sta,
-       search_tbl, index);
-   if (!ret)
-    goto out;
-   break;
+   goto err;
   }
-  tbl->action++;
-  if (tbl->action > IWL_LEGACY_SWITCH_MIMO3_ABC)
-   tbl->action = IWL_SISO_SWITCH_ANTENNA1;
 
-  if (tbl->action == start_action)
-   break;
+  rate->index = rate_idx;
  }
- search_tbl->lq_type = LQ_NONE;
- return 0;
 
- out:
- lq_sta->search_better_tbl = 1;
- tbl->action++;
- if (tbl->action > IWL_SISO_SWITCH_MIMO3_ABC)
-  tbl->action = IWL_SISO_SWITCH_ANTENNA1;
- if (update_search_tbl_counter)
-  search_tbl->action = tbl->action;
+ IWL_DEBUG_RATE(mvm, "Switched to column %d: Index %d\n",
+         col_id, rate->index);
 
  return 0;
+
+err:
+ rate->type = LQ_NONE;
+ return -1;
 }
 
-/*
- * Try to switch to new modulation mode from MIMO2
- */
-static int rs_move_mimo2_to_other(struct iwl_mvm *mvm,
-     struct iwl_lq_sta *lq_sta,
-     struct ieee80211_sta *sta, int index)
+static enum rs_action rs_get_rate_action(struct iwl_mvm *mvm,
+      struct iwl_scale_tbl_info *tbl,
+      s32 sr, int low, int high,
+      int current_tpt,
+      int low_tpt, int high_tpt)
 {
- s8 is_green = lq_sta->is_green;
- struct iwl_scale_tbl_info *tbl = &(lq_sta->lq_info[lq_sta->active_tbl]);
- struct iwl_scale_tbl_info *search_tbl =
-    &(lq_sta->lq_info[(1 - lq_sta->active_tbl)]);
- struct iwl_rate_scale_data *window = &(tbl->win[index]);
- struct ieee80211_sta_ht_cap *ht_cap = &sta->ht_cap;
- u32 sz = (sizeof(struct iwl_scale_tbl_info) -
-    (sizeof(struct iwl_rate_scale_data) * IWL_RATE_COUNT));
- u8 start_action;
- u8 valid_tx_ant = iwl_fw_valid_tx_ant(mvm->fw);
- u8 tx_chains_num = num_of_ant(valid_tx_ant);
- u8 update_search_tbl_counter = 0;
- int ret;
-
- start_action = tbl->action;
- while (1) {
-  lq_sta->action_counter++;
-  switch (tbl->action) {
-  case IWL_MIMO2_SWITCH_ANTENNA1:
-  case IWL_MIMO2_SWITCH_ANTENNA2:
-   IWL_DEBUG_RATE(mvm, "LQ: MIMO2 toggle Antennas\n");
-
-   if (tx_chains_num <= 2)
-    break;
+ enum rs_action action = RS_ACTION_STAY;
 
-   if (window->success_ratio >= IWL_RS_GOOD_RATIO)
-    break;
-
-   memcpy(search_tbl, tbl, sz);
-   if (rs_toggle_antenna(valid_tx_ant,
-           &search_tbl->current_rate,
-           search_tbl)) {
-    update_search_tbl_counter = 1;
-    goto out;
-   }
-   break;
-  case IWL_MIMO2_SWITCH_SISO_A:
-  case IWL_MIMO2_SWITCH_SISO_B:
-  case IWL_MIMO2_SWITCH_SISO_C:
-   IWL_DEBUG_RATE(mvm, "LQ: MIMO2 switch to SISO\n");
-
-   /* Set up new search table for SISO */
-   memcpy(search_tbl, tbl, sz);
-
-   if (tbl->action == IWL_MIMO2_SWITCH_SISO_A)
-    search_tbl->ant_type = ANT_A;
-   else if (tbl->action == IWL_MIMO2_SWITCH_SISO_B)
-    search_tbl->ant_type = ANT_B;
-   else
-    search_tbl->ant_type = ANT_C;
+ if ((sr <= RS_SR_FORCE_DECREASE) || (current_tpt == 0)) {
+  IWL_DEBUG_RATE(mvm,
+          "Decrease rate because of low SR\n");
+  return RS_ACTION_DOWNSCALE;
+ }
 
-   if (!rs_is_valid_ant(valid_tx_ant,
-          search_tbl->ant_type))
-    break;
+ if ((low_tpt == IWL_INVALID_VALUE) &&
+     (high_tpt == IWL_INVALID_VALUE) &&
+     (high != IWL_RATE_INVALID)) {
+  IWL_DEBUG_RATE(mvm,
+          "No data about high/low rates. Increase rate\n");
+  return RS_ACTION_UPSCALE;
+ }
 
-   ret = rs_switch_to_siso(mvm, lq_sta, sta,
-       search_tbl, index);
-   if (!ret)
-    goto out;
+ if ((high_tpt == IWL_INVALID_VALUE) &&
+     (high != IWL_RATE_INVALID) &&
+     (low_tpt != IWL_INVALID_VALUE) &&
+     (low_tpt < current_tpt)) {
+  IWL_DEBUG_RATE(mvm,
+          "No data about high rate and low rate is worse. Increase rate\n");
+  return RS_ACTION_UPSCALE;
+ }
 
-   break;
+ if ((high_tpt != IWL_INVALID_VALUE) &&
+     (high_tpt > current_tpt)) {
+  IWL_DEBUG_RATE(mvm,
+          "Higher rate is better. Increate rate\n");
+  return RS_ACTION_UPSCALE;
+ }
 
-  case IWL_MIMO2_SWITCH_GI:
-   if (!tbl->is_ht40 && !(ht_cap->cap &
-      IEEE80211_HT_CAP_SGI_20))
-    break;
-   if (tbl->is_ht40 && !(ht_cap->cap &
-      IEEE80211_HT_CAP_SGI_40))
-    break;
+ if ((low_tpt != IWL_INVALID_VALUE) &&
+     (high_tpt != IWL_INVALID_VALUE) &&
+     (low_tpt < current_tpt) &&
+     (high_tpt < current_tpt)) {
+  IWL_DEBUG_RATE(mvm,
+          "Both high and low are worse. Maintain rate\n");
+  return RS_ACTION_STAY;
+ }
 
-   IWL_DEBUG_RATE(mvm, "LQ: MIMO2 toggle SGI/NGI\n");
+ if ((low_tpt != IWL_INVALID_VALUE) &&
+     (low_tpt > current_tpt)) {
+  IWL_DEBUG_RATE(mvm,
+          "Lower rate is better\n");
+  action = RS_ACTION_DOWNSCALE;
+  goto out;
+ }
 
-   /* Set up new search table for MIMO2 */
-   memcpy(search_tbl, tbl, sz);
-   search_tbl->is_SGI = !tbl->is_SGI;
-   rs_set_expected_tpt_table(lq_sta, search_tbl);
-   /*
-    * If active table already uses the fastest possible
-    * modulation (dual stream with short guard interval),
-    * and it's working well, there's no need to look
-    * for a better type of modulation!
-    */
-   if (tbl->is_SGI) {
-    s32 tpt = lq_sta->last_tpt / 100;
-    if (tpt >= search_tbl->expected_tpt[index])
-     break;
-   }
-   search_tbl->current_rate =
-    rate_n_flags_from_tbl(mvm, search_tbl,
-            index, is_green);
-   update_search_tbl_counter = 1;
-   goto out;
-
-  case IWL_MIMO2_SWITCH_MIMO3_ABC:
-   IWL_DEBUG_RATE(mvm, "LQ: MIMO2 switch to MIMO3\n");
-   memcpy(search_tbl, tbl, sz);
-   search_tbl->is_SGI = 0;
-   search_tbl->ant_type = ANT_ABC;
-
-   if (!rs_is_valid_ant(valid_tx_ant,
-          search_tbl->ant_type))
-    break;
+ if ((low_tpt == IWL_INVALID_VALUE) &&
+     (low != IWL_RATE_INVALID)) {
+  IWL_DEBUG_RATE(mvm,
+          "No data about lower rate\n");
+  action = RS_ACTION_DOWNSCALE;
+  goto out;
+ }
 
-   ret = rs_switch_to_mimo3(mvm, lq_sta, sta,
-       search_tbl, index);
-   if (!ret)
-    goto out;
+ IWL_DEBUG_RATE(mvm, "Maintain rate\n");
 
-   break;
+out:
+ if ((action == RS_ACTION_DOWNSCALE) && (low != IWL_RATE_INVALID)) {
+  if (sr >= RS_SR_NO_DECREASE) {
+   IWL_DEBUG_RATE(mvm,
+           "SR is above NO DECREASE. Avoid downscale\n");
+   action = RS_ACTION_STAY;
+  } else if (current_tpt > (100 * tbl->expected_tpt[low])) {
+   IWL_DEBUG_RATE(mvm,
+           "Current TPT is higher than max expected in low rate. Avoid downscale\n");
+   action = RS_ACTION_STAY;
+  } else {
+   IWL_DEBUG_RATE(mvm, "Decrease rate\n");
   }
-  tbl->action++;
-  if (tbl->action > IWL_MIMO2_SWITCH_MIMO3_ABC)
-   tbl->action = IWL_MIMO2_SWITCH_ANTENNA1;
-
-  if (tbl->action == start_action)
-   break;
  }
- search_tbl->lq_type = LQ_NONE;
- return 0;
- out:
- lq_sta->search_better_tbl = 1;
- tbl->action++;
- if (tbl->action > IWL_MIMO2_SWITCH_MIMO3_ABC)
-  tbl->action = IWL_MIMO2_SWITCH_ANTENNA1;
- if (update_search_tbl_counter)
-  search_tbl->action = tbl->action;
 
- return 0;
+ return action;
 }
 
-/*
- * Try to switch to new modulation mode from MIMO3
- */
-static int rs_move_mimo3_to_other(struct iwl_mvm *mvm,
-     struct iwl_lq_sta *lq_sta,
-     struct ieee80211_sta *sta, int index)
+static void rs_get_adjacent_txp(struct iwl_mvm *mvm, int index,
+    int *weaker, int *stronger)
 {
- s8 is_green = lq_sta->is_green;
- struct iwl_scale_tbl_info *tbl = &(lq_sta->lq_info[lq_sta->active_tbl]);
- struct iwl_scale_tbl_info *search_tbl =
-    &(lq_sta->lq_info[(1 - lq_sta->active_tbl)]);
- struct iwl_rate_scale_data *window = &(tbl->win[index]);
- struct ieee80211_sta_ht_cap *ht_cap = &sta->ht_cap;
- u32 sz = (sizeof(struct iwl_scale_tbl_info) -
-    (sizeof(struct iwl_rate_scale_data) * IWL_RATE_COUNT));
- u8 start_action;
- u8 valid_tx_ant = iwl_fw_valid_tx_ant(mvm->fw);
- u8 tx_chains_num = num_of_ant(valid_tx_ant);
- int ret;
- u8 update_search_tbl_counter = 0;
+ *weaker = index + TPC_TX_POWER_STEP;
+ if (*weaker > TPC_MAX_REDUCTION)
+  *weaker = TPC_INVALID;
 
- start_action = tbl->action;
- while (1) {
-  lq_sta->action_counter++;
-  switch (tbl->action) {
-  case IWL_MIMO3_SWITCH_ANTENNA1:
-  case IWL_MIMO3_SWITCH_ANTENNA2:
-   IWL_DEBUG_RATE(mvm, "LQ: MIMO3 toggle Antennas\n");
-
-   if (tx_chains_num <= 3)
-    break;
-
-   if (window->success_ratio >= IWL_RS_GOOD_RATIO)
-    break;
-
-   memcpy(search_tbl, tbl, sz);
-   if (rs_toggle_antenna(valid_tx_ant,
-           &search_tbl->current_rate,
-           search_tbl))
-    goto out;
-   break;
-  case IWL_MIMO3_SWITCH_SISO_A:
-  case IWL_MIMO3_SWITCH_SISO_B:
-  case IWL_MIMO3_SWITCH_SISO_C:
-   IWL_DEBUG_RATE(mvm, "LQ: MIMO3 switch to SISO\n");
-
-   /* Set up new search table for SISO */
-   memcpy(search_tbl, tbl, sz);
-
-   if (tbl->action == IWL_MIMO3_SWITCH_SISO_A)
-    search_tbl->ant_type = ANT_A;
-   else if (tbl->action == IWL_MIMO3_SWITCH_SISO_B)
-    search_tbl->ant_type = ANT_B;
-   else
-    search_tbl->ant_type = ANT_C;
-
-   if (!rs_is_valid_ant(valid_tx_ant,
-          search_tbl->ant_type))
-    break;
-
-   ret = rs_switch_to_siso(mvm, lq_sta, sta,
-      search_tbl, index);
-   if (!ret)
-    goto out;
+ *stronger = index - TPC_TX_POWER_STEP;
+ if (*stronger < 0)
+  *stronger = TPC_INVALID;
+}
 
-   break;
+static bool rs_tpc_allowed(struct iwl_mvm *mvm, struct ieee80211_vif *vif,
+      struct rs_rate *rate, enum ieee80211_band band)
+{
+ int index = rate->index;
+ bool cam = (iwlmvm_mod_params.power_scheme == IWL_POWER_SCHEME_CAM);
+ bool sta_ps_disabled = (vif->type == NL80211_IFTYPE_STATION &&
+    !vif->bss_conf.ps);
 
-  case IWL_MIMO3_SWITCH_MIMO2_AB:
-  case IWL_MIMO3_SWITCH_MIMO2_AC:
-  case IWL_MIMO3_SWITCH_MIMO2_BC:
-   IWL_DEBUG_RATE(mvm, "LQ: MIMO3 switch to MIMO2\n");
-
-   memcpy(search_tbl, tbl, sz);
-   search_tbl->is_SGI = 0;
-   if (tbl->action == IWL_MIMO3_SWITCH_MIMO2_AB)
-    search_tbl->ant_type = ANT_AB;
-   else if (tbl->action == IWL_MIMO3_SWITCH_MIMO2_AC)
-    search_tbl->ant_type = ANT_AC;
-   else
-    search_tbl->ant_type = ANT_BC;
+ IWL_DEBUG_RATE(mvm, "cam: %d sta_ps_disabled %d\n",
+         cam, sta_ps_disabled);
+ /*
+  * allow tpc only if power management is enabled, or bt coex
+  * activity grade allows it and we are on 2.4Ghz.
+  */
+ if ((cam || sta_ps_disabled) &&
+     !iwl_mvm_bt_coex_is_tpc_allowed(mvm, band))
+  return false;
+
+ IWL_DEBUG_RATE(mvm, "check rate, table type: %d\n", rate->type);
+ if (is_legacy(rate))
+  return index == IWL_RATE_54M_INDEX;
+ if (is_ht(rate))
+  return index == IWL_RATE_MCS_7_INDEX;
+ if (is_vht(rate))
+  return index == IWL_RATE_MCS_7_INDEX ||
+         index == IWL_RATE_MCS_8_INDEX ||
+         index == IWL_RATE_MCS_9_INDEX;
+
+ WARN_ON_ONCE(1);
+ return false;
+}
 
-   if (!rs_is_valid_ant(valid_tx_ant,
-          search_tbl->ant_type))
-    break;
+enum tpc_action {
+ TPC_ACTION_STAY,
+ TPC_ACTION_DECREASE,
+ TPC_ACTION_INCREASE,
+ TPC_ACTION_NO_RESTIRCTION,
+};
 
-   ret = rs_switch_to_mimo2(mvm, lq_sta, sta,
-       search_tbl, index);
-   if (!ret)
-    goto out;
+static enum tpc_action rs_get_tpc_action(struct iwl_mvm *mvm,
+      s32 sr, int weak, int strong,
+      int current_tpt,
+      int weak_tpt, int strong_tpt)
+{
+ /* stay until we have valid tpt */
+ if (current_tpt == IWL_INVALID_VALUE) {
+  IWL_DEBUG_RATE(mvm, "no current tpt. stay.\n");
+  return TPC_ACTION_STAY;
+ }
 
-   break;
+ /* Too many failures, increase txp */
+ if (sr <= TPC_SR_FORCE_INCREASE || current_tpt == 0) {
+  IWL_DEBUG_RATE(mvm, "increase txp because of weak SR\n");
+  return TPC_ACTION_NO_RESTIRCTION;
+ }
 
-  case IWL_MIMO3_SWITCH_GI:
-   if (!tbl->is_ht40 && !(ht_cap->cap &
-      IEEE80211_HT_CAP_SGI_20))
-    break;
-   if (tbl->is_ht40 && !(ht_cap->cap &
-      IEEE80211_HT_CAP_SGI_40))
-    break;
+ /* try decreasing first if applicable */
+ if (weak != TPC_INVALID) {
+  if (weak_tpt == IWL_INVALID_VALUE &&
+      (strong_tpt == IWL_INVALID_VALUE ||
+       current_tpt >= strong_tpt)) {
+   IWL_DEBUG_RATE(mvm,
+           "no weak txp measurement. decrease txp\n");
+   return TPC_ACTION_DECREASE;
+  }
 
-   IWL_DEBUG_RATE(mvm, "LQ: MIMO3 toggle SGI/NGI\n");
+  if (weak_tpt > current_tpt) {
+   IWL_DEBUG_RATE(mvm,
+           "lower txp has better tpt. decrease txp\n");
+   return TPC_ACTION_DECREASE;
+  }
+ }
 
-   /* Set up new search table for MIMO */
-   memcpy(search_tbl, tbl, sz);
-   search_tbl->is_SGI = !tbl->is_SGI;
-   rs_set_expected_tpt_table(lq_sta, search_tbl);
-   /*
-    * If active table already uses the fastest possible
-    * modulation (dual stream with short guard interval),
-    * and it's working well, there's no need to look
-    * for a better type of modulation!
-    */
-   if (tbl->is_SGI) {
-    s32 tpt = lq_sta->last_tpt / 100;
-    if (tpt >= search_tbl->expected_tpt[index])
-     break;
-   }
-   search_tbl->current_rate =
-    rate_n_flags_from_tbl(mvm, search_tbl,
-            index, is_green);
-   update_search_tbl_counter = 1;
-   goto out;
+ /* next, increase if needed */
+ if (sr < TPC_SR_NO_INCREASE && strong != TPC_INVALID) {
+  if (weak_tpt == IWL_INVALID_VALUE &&
+      strong_tpt != IWL_INVALID_VALUE &&
+      current_tpt < strong_tpt) {
+   IWL_DEBUG_RATE(mvm,
+           "higher txp has better tpt. increase txp\n");
+   return TPC_ACTION_INCREASE;
   }
-  tbl->action++;
-  if (tbl->action > IWL_MIMO3_SWITCH_GI)
-   tbl->action = IWL_MIMO3_SWITCH_ANTENNA1;
 
-  if (tbl->action == start_action)
-   break;
+  if (weak_tpt < current_tpt &&
+      (strong_tpt == IWL_INVALID_VALUE ||
+       strong_tpt > current_tpt)) {
+   IWL_DEBUG_RATE(mvm,
+           "lower txp has worse tpt. increase txp\n");
+   return TPC_ACTION_INCREASE;
+  }
  }
- search_tbl->lq_type = LQ_NONE;
- return 0;
- out:
- lq_sta->search_better_tbl = 1;
- tbl->action++;
- if (tbl->action > IWL_MIMO3_SWITCH_GI)
-  tbl->action = IWL_MIMO3_SWITCH_ANTENNA1;
- if (update_search_tbl_counter)
-  search_tbl->action = tbl->action;
 
- return 0;
+ IWL_DEBUG_RATE(mvm, "no need to increase or decrease txp - stay\n");
+ return TPC_ACTION_STAY;
 }
 
-/*
- * Check whether we should continue using same modulation mode, or
- * begin search for a new mode, based on:
- * 1) # tx successes or failures while using this mode
- * 2) # times calling this function
- * 3) elapsed time in this mode (not used, for now)
- */
-static void rs_stay_in_table(struct iwl_lq_sta *lq_sta, bool force_search)
+static bool rs_tpc_perform(struct iwl_mvm *mvm,
+      struct ieee80211_sta *sta,
+      struct iwl_lq_sta *lq_sta,
+      struct iwl_scale_tbl_info *tbl)
 {
- struct iwl_scale_tbl_info *tbl;
- int i;
- int active_tbl;
- int flush_interval_passed = 0;
- struct iwl_mvm *mvm;
-
- mvm = lq_sta->drv;
- active_tbl = lq_sta->active_tbl;
+ struct iwl_mvm_sta *mvm_sta = (void *)sta->drv_priv;
+ struct ieee80211_vif *vif = mvm_sta->vif;
+ struct ieee80211_chanctx_conf *chanctx_conf;
+ enum ieee80211_band band;
+ struct iwl_rate_scale_data *window;
+ struct rs_rate *rate = &tbl->rate;
+ enum tpc_action action;
+ s32 sr;
+ u8 cur = lq_sta->lq.reduced_tpc;
+ int current_tpt;
+ int weak, strong;
+ int weak_tpt = IWL_INVALID_VALUE, strong_tpt = IWL_INVALID_VALUE;
 
- tbl = &(lq_sta->lq_info[active_tbl]);
+#ifdef CONFIG_MAC80211_DEBUGFS
+ if (lq_sta->dbg_fixed_txp_reduction <= TPC_MAX_REDUCTION) {
+  IWL_DEBUG_RATE(mvm, "fixed tpc: %d\n",
+          lq_sta->dbg_fixed_txp_reduction);
+  lq_sta->lq.reduced_tpc = lq_sta->dbg_fixed_txp_reduction;
+  return cur != lq_sta->dbg_fixed_txp_reduction;
+ }
+#endif
 
- /* If we've been disallowing search, see if we should now allow it */
- if (lq_sta->stay_in_tbl) {
-  /* Elapsed time using current modulation mode */
-  if (lq_sta->flush_timer)
-   flush_interval_passed =
-    time_after(jiffies,
-        (unsigned long)(lq_sta->flush_timer +
-      IWL_RATE_SCALE_FLUSH_INTVL));
+ rcu_read_lock();
+ chanctx_conf = rcu_dereference(vif->chanctx_conf);
+ if (WARN_ON(!chanctx_conf))
+  band = IEEE80211_NUM_BANDS;
+ else
+  band = chanctx_conf->def.chan->band;
+ rcu_read_unlock();
 
-  /*
-   * Check if we should allow search for new modulation mode.
-   * If many frames have failed or succeeded, or we've used
-   * this same modulation for a long time, allow search, and
-   * reset history stats that keep track of whether we should
-   * allow a new search.  Also (below) reset all bitmaps and
-   * stats in active history.
-   */
-  if (force_search ||
-      (lq_sta->total_failed > lq_sta->max_failure_limit) ||
-      (lq_sta->total_success > lq_sta->max_success_limit) ||
-      ((!lq_sta->search_better_tbl) &&
-       (lq_sta->flush_timer) && (flush_interval_passed))) {
-   IWL_DEBUG_RATE(mvm,
-           "LQ: stay is expired %d %d %d\n",
-         lq_sta->total_failed,
-         lq_sta->total_success,
-         flush_interval_passed);
+ if (!rs_tpc_allowed(mvm, vif, rate, band)) {
+  IWL_DEBUG_RATE(mvm,
+          "tpc is not allowed. remove txp restrictions\n");
+  lq_sta->lq.reduced_tpc = TPC_NO_REDUCTION;
+  return cur != TPC_NO_REDUCTION;
+ }
 
-   /* Allow search for new mode */
-   lq_sta->stay_in_tbl = 0; /* only place reset */
-   lq_sta->total_failed = 0;
-   lq_sta->total_success = 0;
-   lq_sta->flush_timer = 0;
-  /*
-   * Else if we've used this modulation mode enough repetitions
-   * (regardless of elapsed time or success/failure), reset
-   * history bitmaps and rate-specific stats for all rates in
-   * active table.
-   */
-  } else {
-   lq_sta->table_count++;
-   if (lq_sta->table_count >=
-       lq_sta->table_count_limit) {
-    lq_sta->table_count = 0;
+ rs_get_adjacent_txp(mvm, cur, &weak, &strong);
 
-    IWL_DEBUG_RATE(mvm,
-            "LQ: stay in table clear win\n");
-    for (i = 0; i < IWL_RATE_COUNT; i++)
-     rs_rate_scale_clear_window(
-      &(tbl->win[i]));
-   }
-  }
+ /* Collect measured throughputs for current and adjacent rates */
+ window = tbl->tpc_win;
+ sr = window[cur].success_ratio;
+ current_tpt = window[cur].average_tpt;
+ if (weak != TPC_INVALID)
+  weak_tpt = window[weak].average_tpt;
+ if (strong != TPC_INVALID)
+  strong_tpt = window[strong].average_tpt;
 
-  /* If transitioning to allow "search", reset all history
-   * bitmaps and stats in active table (this will become the new
-   * "search" table). */
-  if (!lq_sta->stay_in_tbl) {
-   for (i = 0; i < IWL_RATE_COUNT; i++)
-    rs_rate_scale_clear_window(&(tbl->win[i]));
-  }
+ IWL_DEBUG_RATE(mvm,
+         "(TPC: %d): cur_tpt %d SR %d weak %d strong %d weak_tpt %d strong_tpt %d\n",
+         cur, current_tpt, sr, weak, strong,
+         weak_tpt, strong_tpt);
+
+ action = rs_get_tpc_action(mvm, sr, weak, strong,
+       current_tpt, weak_tpt, strong_tpt);
+
+ /* override actions if we are on the edge */
+ if (weak == TPC_INVALID && action == TPC_ACTION_DECREASE) {
+  IWL_DEBUG_RATE(mvm, "already in lowest txp, stay\n");
+  action = TPC_ACTION_STAY;
+ } else if (strong == TPC_INVALID &&
+     (action == TPC_ACTION_INCREASE ||
+      action == TPC_ACTION_NO_RESTIRCTION)) {
+  IWL_DEBUG_RATE(mvm, "already in highest txp, stay\n");
+  action = TPC_ACTION_STAY;
  }
-}
-
-/*
- * setup rate table in uCode
- */
-static void rs_update_rate_tbl(struct iwl_mvm *mvm,
-          struct iwl_lq_sta *lq_sta,
-          struct iwl_scale_tbl_info *tbl,
-          int index, u8 is_green)
-{
- u32 rate;
 
- /* Update uCode's rate table. */
- rate = rate_n_flags_from_tbl(mvm, tbl, index, is_green);
- rs_fill_link_cmd(mvm, lq_sta, rate);
- iwl_mvm_send_lq_cmd(mvm, &lq_sta->lq, CMD_ASYNC, false);
+ switch (action) {
+ case TPC_ACTION_DECREASE:
+  lq_sta->lq.reduced_tpc = weak;
+  return true;
+ case TPC_ACTION_INCREASE:
+  lq_sta->lq.reduced_tpc = strong;
+  return true;
+ case TPC_ACTION_NO_RESTIRCTION:
+  lq_sta->lq.reduced_tpc = TPC_NO_REDUCTION;
+  return true;
+ case TPC_ACTION_STAY:
+  /* do nothing */
+  break;
+ }
+ return false;
 }
 
 /*
@@ -2025,27 +1948,24 @@ static void rs_rate_scale_perform(struct iwl_mvm *mvm,
  int low = IWL_RATE_INVALID;
  int high = IWL_RATE_INVALID;
  int index;
- int i;
  struct iwl_rate_scale_data *window = NULL;
  int current_tpt = IWL_INVALID_VALUE;
  int low_tpt = IWL_INVALID_VALUE;
  int high_tpt = IWL_INVALID_VALUE;
  u32 fail_count;
- s8 scale_action = 0;
+ enum rs_action scale_action = RS_ACTION_STAY;
  u16 rate_mask;
  u8 update_lq = 0;
  struct iwl_scale_tbl_info *tbl, *tbl1;
- u16 rate_scale_index_msk = 0;
- u8 is_green = 0;
  u8 active_tbl = 0;
  u8 done_search = 0;
  u16 high_low;
  s32 sr;
  u8 tid = IWL_MAX_TID_COUNT;
+ u8 prev_agg = lq_sta->is_agg;
  struct iwl_mvm_sta *sta_priv = (void *)sta->drv_priv;
  struct iwl_mvm_tid_data *tid_data;
-
- IWL_DEBUG_RATE(mvm, "rate scale calculate new rate for skb\n");
+ struct rs_rate *rate;
 
  /* Send management frames and NO_ACK data using lowest rate. */
  /* TODO: this could probably be improved.. */
@@ -2053,9 +1973,7 @@ static void rs_rate_scale_perform(struct iwl_mvm *mvm,
      info->flags & IEEE80211_TX_CTL_NO_ACK)
   return;
 
- lq_sta->supp_rates = sta->supp_rates[lq_sta->band];
-
- tid = rs_tl_add_packet(lq_sta, hdr);
+ tid = rs_get_tid(lq_sta, hdr);
  if ((tid != IWL_MAX_TID_COUNT) &&
      (lq_sta->tx_agg_tid_en & (1 << tid))) {
   tid_data = &sta_priv->tid_data[tid];
@@ -2078,50 +1996,30 @@ static void rs_rate_scale_perform(struct iwl_mvm *mvm,
   active_tbl = 1 - lq_sta->active_tbl;
 
  tbl = &(lq_sta->lq_info[active_tbl]);
- if (is_legacy(tbl->lq_type))
-  lq_sta->is_green = 0;
- else
-  lq_sta->is_green = rs_use_green(sta);
- is_green = lq_sta->is_green;
+ rate = &tbl->rate;
+
+ if (prev_agg != lq_sta->is_agg) {
+  IWL_DEBUG_RATE(mvm,
+          "Aggregation changed: prev %d current %d. Update expected TPT table\n",
+          prev_agg, lq_sta->is_agg);
+  rs_set_expected_tpt_table(lq_sta, tbl);
+  rs_rate_scale_clear_tbl_windows(mvm, tbl);
+ }
 
  /* current tx rate */
  index = lq_sta->last_txrate_idx;
 
- IWL_DEBUG_RATE(mvm, "Rate scale index %d for type %d\n", index,
-         tbl->lq_type);
-
  /* rates available for this association, and for modulation mode */
- rate_mask = rs_get_supported_rates(lq_sta, hdr, tbl->lq_type);
-
- IWL_DEBUG_RATE(mvm, "mask 0x%04X\n", rate_mask);
-
- /* mask with station rate restriction */
- if (is_legacy(tbl->lq_type)) {
-  if (lq_sta->band == IEEE80211_BAND_5GHZ)
-   /* supp_rates has no CCK bits in A mode */
-   rate_scale_index_msk = (u16) (rate_mask &
-    (lq_sta->supp_rates << IWL_FIRST_OFDM_RATE));
-  else
-   rate_scale_index_msk = (u16) (rate_mask &
-            lq_sta->supp_rates);
-
- } else {
-  rate_scale_index_msk = rate_mask;
- }
-
- if (!rate_scale_index_msk)
-  rate_scale_index_msk = rate_mask;
+ rate_mask = rs_get_supported_rates(lq_sta, rate);
 
- if (!((1 << index) & rate_scale_index_msk)) {
+ if (!(BIT(index) & rate_mask)) {
   IWL_ERR(mvm, "Current Rate is not valid\n");
   if (lq_sta->search_better_tbl) {
    /* revert to active table if search table is not valid*/
-   tbl->lq_type = LQ_NONE;
+   rate->type = LQ_NONE;
    lq_sta->search_better_tbl = 0;
    tbl = &(lq_sta->lq_info[lq_sta->active_tbl]);
-   /* get "active" rate info */
-   index = iwl_hwrate_to_plcp_idx(tbl->current_rate);
-   rs_update_rate_tbl(mvm, lq_sta, tbl, index, is_green);
+   rs_update_rate_tbl(mvm, sta, lq_sta, &tbl->rate);
   }
   return;
  }
@@ -2138,6 +2036,9 @@ static void rs_rate_scale_perform(struct iwl_mvm *mvm,
   index = lq_sta->max_rate_idx;
   update_lq = 1;
   window = &(tbl->win[index]);
+  IWL_DEBUG_RATE(mvm,
+          "Forcing user max rate %d\n",
+          index);
   goto lq_update;
  }
 
@@ -2154,8 +2055,9 @@ static void rs_rate_scale_perform(struct iwl_mvm *mvm,
  if ((fail_count < IWL_RATE_MIN_FAILURE_TH) &&
      (window->success_counter < IWL_RATE_MIN_SUCCESS_TH)) {
   IWL_DEBUG_RATE(mvm,
-          "LQ: still below TH. succ=%d total=%d for index %d\n",
-          window->success_counter, window->counter, index);
+          "(%s: %d): Test Window: succ %d total %d\n",
+          rs_pretty_lq_type(rate->type),
+          index, window->success_counter, window->counter);
 
   /* Can't calculate this yet; not enough history */
   window->average_tpt = IWL_INVALID_VALUE;
@@ -2170,8 +2072,6 @@ static void rs_rate_scale_perform(struct iwl_mvm *mvm,
   * actual average throughput */
  if (window->average_tpt != ((window->success_ratio *
    tbl->expected_tpt[index] + 64) / 128)) {
-  IWL_ERR(mvm,
-   "expected_tpt should have been calculated by now\n");
   window->average_tpt = ((window->success_ratio *
      tbl->expected_tpt[index] + 64) / 128);
  }
@@ -2183,34 +2083,33 @@ static void rs_rate_scale_perform(struct iwl_mvm *mvm,
    * continuing to use the setup that we've been trying. */
   if (window->average_tpt > lq_sta->last_tpt) {
    IWL_DEBUG_RATE(mvm,
-           "LQ: SWITCHING TO NEW TABLE suc=%d cur-tpt=%d old-tpt=%d\n",
+           "SWITCHING TO NEW TABLE SR: %d "
+           "cur-tpt %d old-tpt %d\n",
            window->success_ratio,
            window->average_tpt,
            lq_sta->last_tpt);
 
-   if (!is_legacy(tbl->lq_type))
-    lq_sta->enable_counter = 1;
-
    /* Swap tables; "search" becomes "active" */
    lq_sta->active_tbl = active_tbl;
    current_tpt = window->average_tpt;
   /* Else poor success; go back to mode in "active" table */
   } else {
    IWL_DEBUG_RATE(mvm,
-           "LQ: GOING BACK TO THE OLD TABLE suc=%d cur-tpt=%d old-tpt=%d\n",
+           "GOING BACK TO THE OLD TABLE: SR %d "
+           "cur-tpt %d old-tpt %d\n",
            window->success_ratio,
            window->average_tpt,
            lq_sta->last_tpt);
 
    /* Nullify "search" table */
-   tbl->lq_type = LQ_NONE;
+   rate->type = LQ_NONE;
 
    /* Revert to "active" table */
    active_tbl = lq_sta->active_tbl;
    tbl = &(lq_sta->lq_info[active_tbl]);
 
    /* Revert to "active" rate and throughput info */
-   index = iwl_hwrate_to_plcp_idx(tbl->current_rate);
+   index = tbl->rate.index;
    current_tpt = lq_sta->last_tpt;
 
    /* Need to set up a new rate table in uCode */
@@ -2226,8 +2125,7 @@ static void rs_rate_scale_perform(struct iwl_mvm *mvm,
 
  /* (Else) not in search of better modulation mode, try for better
   * starting rate, while staying in this mode. */
- high_low = rs_get_adjacent_rate(mvm, index, rate_scale_index_msk,
-     tbl->lq_type);
+ high_low = rs_get_adjacent_rate(mvm, index, rate_mask, rate->type);
  low = high_low & 0xff;
  high = (high_low >> 8) & 0xff;
 
@@ -2245,94 +2143,61 @@ static void rs_rate_scale_perform(struct iwl_mvm *mvm,
  if (high != IWL_RATE_INVALID)
   high_tpt = tbl->win[high].average_tpt;
 
- scale_action = 0;
+ IWL_DEBUG_RATE(mvm,
+         "(%s: %d): cur_tpt %d SR %d low %d high %d low_tpt %d high_tpt %d\n",
+         rs_pretty_lq_type(rate->type), index, current_tpt, sr,
+         low, high, low_tpt, high_tpt);
 
- /* Too many failures, decrease rate */
- if ((sr <= IWL_RATE_DECREASE_TH) || (current_tpt == 0)) {
-  IWL_DEBUG_RATE(mvm,
-          "decrease rate because of low success_ratio\n");
-  scale_action = -1;
- /* No throughput measured yet for adjacent rates; try increase. */
- } else if ((low_tpt == IWL_INVALID_VALUE) &&
-     (high_tpt == IWL_INVALID_VALUE)) {
-  if (high != IWL_RATE_INVALID && sr >= IWL_RATE_INCREASE_TH)
-   scale_action = 1;
-  else if (low != IWL_RATE_INVALID)
-   scale_action = 0;
- }
-
- /* Both adjacent throughputs are measured, but neither one has better
-  * throughput; we're using the best rate, don't change it! */
- else if ((low_tpt != IWL_INVALID_VALUE) &&
-   (high_tpt != IWL_INVALID_VALUE) &&
-   (low_tpt < current_tpt) &&
-   (high_tpt < current_tpt))
-  scale_action = 0;
-
- /* At least one adjacent rate's throughput is measured,
-  * and may have better performance. */
- else {
-  /* Higher adjacent rate's throughput is measured */
-  if (high_tpt != IWL_INVALID_VALUE) {
-   /* Higher rate has better throughput */
-   if (high_tpt > current_tpt &&
-       sr >= IWL_RATE_INCREASE_TH) {
-    scale_action = 1;
-   } else {
-    scale_action = 0;
-   }
+ scale_action = rs_get_rate_action(mvm, tbl, sr, low, high,
+       current_tpt, low_tpt, high_tpt);
 
-  /* Lower adjacent rate's throughput is measured */
-  } else if (low_tpt != IWL_INVALID_VALUE) {
-   /* Lower rate has better throughput */
-   if (low_tpt > current_tpt) {
-    IWL_DEBUG_RATE(mvm,
-            "decrease rate because of low tpt\n");
-    scale_action = -1;
-   } else if (sr >= IWL_RATE_INCREASE_TH) {
-    scale_action = 1;
-   }
-  }
+ /* Force a search in case BT doesn't like us being in MIMO */
+ if (is_mimo(rate) &&
+     !iwl_mvm_bt_coex_is_mimo_allowed(mvm, sta)) {
+  IWL_DEBUG_RATE(mvm,
+          "BT Coex forbids MIMO. Search for new config\n");
+  rs_stay_in_table(lq_sta, true);
+  goto lq_update;
  }
 
- /* Sanity check; asked for decrease, but success rate or throughput
-  * has been good at old rate.  Don't change it. */
- if ((scale_action == -1) && (low != IWL_RATE_INVALID) &&
-     ((sr > IWL_RATE_HIGH_TH) ||
-      (current_tpt > (100 * tbl->expected_tpt[low]))))
-  scale_action = 0;
-
  switch (scale_action) {
- case -1:
+ case RS_ACTION_DOWNSCALE:
   /* Decrease starting rate, update uCode's rate table */
   if (low != IWL_RATE_INVALID) {
    update_lq = 1;
    index = low;
+  } else {
+   IWL_DEBUG_RATE(mvm,
+           "At the bottom rate. Can't decrease\n");
   }
 
   break;
- case 1:
+ case RS_ACTION_UPSCALE:
   /* Increase starting rate, update uCode's rate table */
   if (high != IWL_RATE_INVALID) {
    update_lq = 1;
    index = high;
+  } else {
+   IWL_DEBUG_RATE(mvm,
+           "At the top rate. Can't increase\n");
   }
 
   break;
- case 0:
+ case RS_ACTION_STAY:
   /* No change */
+  if (lq_sta->rs_state == RS_STATE_STAY_IN_COLUMN)
+   update_lq = rs_tpc_perform(mvm, sta, lq_sta, tbl);
+  break;
  default:
   break;
  }
 
- IWL_DEBUG_RATE(mvm,
-         "choose rate scale index %d action %d low %d high %d type %d\n",
-         index, scale_action, low, high, tbl->lq_type);
-
 lq_update:
  /* Replace uCode's rate table for the destination station. */
- if (update_lq)
-  rs_update_rate_tbl(mvm, lq_sta, tbl, index, is_green);
+ if (update_lq) {
+  tbl->rate.index = index;
+  rs_update_rate_tbl(mvm, sta, lq_sta, &tbl->rate);
+ }
 
  rs_stay_in_table(lq_sta, false);
 
@@ -2343,59 +2208,72 @@ lq_update:
   * 3)  Allowing a new search
   */
  if (!update_lq && !done_search &&
-     !lq_sta->stay_in_tbl && window->counter) {
+     lq_sta->rs_state == RS_STATE_SEARCH_CYCLE_STARTED
+     && window->counter) {
+  enum rs_column next_column;
+
   /* Save current throughput to compare with "search" throughput*/
   lq_sta->last_tpt = current_tpt;
 
-  /* Select a new "search" modulation mode to try.
-   * If one is found, set up the new "search" table. */
-  if (is_legacy(tbl->lq_type))
-   rs_move_legacy_other(mvm, lq_sta, sta, index);
-  else if (is_siso(tbl->lq_type))
-   rs_move_siso_to_other(mvm, lq_sta, sta, index);
-  else if (is_mimo2(tbl->lq_type))
-   rs_move_mimo2_to_other(mvm, lq_sta, sta, index);
-  else
-   rs_move_mimo3_to_other(mvm, lq_sta, sta, index);
+  IWL_DEBUG_RATE(mvm,
+          "Start Search: update_lq %d done_search %d rs_state %d win->counter %d\n",
+          update_lq, done_search, lq_sta->rs_state,
+          window->counter);
+
+  next_column = rs_get_next_column(mvm, lq_sta, sta, tbl);
+  if (next_column != RS_COLUMN_INVALID) {
+   int ret = rs_switch_to_column(mvm, lq_sta, sta,
+            next_column);
+   if (!ret)
+    lq_sta->search_better_tbl = 1;
+  } else {
+   IWL_DEBUG_RATE(mvm,
+           "No more columns to explore in search cycle. Go to RS_STATE_SEARCH_CYCLE_ENDED\n");
+   lq_sta->rs_state = RS_STATE_SEARCH_CYCLE_ENDED;
+  }
 
   /* If new "search" mode was selected, set up in uCode table */
   if (lq_sta->search_better_tbl) {
    /* Access the "search" table, clear its history. */
    tbl = &(lq_sta->lq_info[(1 - lq_sta->active_tbl)]);
-   for (i = 0; i < IWL_RATE_COUNT; i++)
-    rs_rate_scale_clear_window(&(tbl->win[i]));
+   rs_rate_scale_clear_tbl_windows(mvm, tbl);
 
    /* Use new "search" start rate */
-   index = iwl_hwrate_to_plcp_idx(tbl->current_rate);
+   index = tbl->rate.index;
 
-   IWL_DEBUG_RATE(mvm,
-           "Switch current  mcs: %X index: %d\n",
-           tbl->current_rate, index);
-   rs_fill_link_cmd(mvm, lq_sta, tbl->current_rate);
-   iwl_mvm_send_lq_cmd(mvm, &lq_sta->lq, CMD_ASYNC, false);
+   rs_dump_rate(mvm, &tbl->rate,
+         "Switch to SEARCH TABLE:");
+   rs_fill_lq_cmd(mvm, sta, lq_sta, &tbl->rate);
+   iwl_mvm_send_lq_cmd(mvm, &lq_sta->lq, false);
   } else {
    done_search = 1;
   }
  }
 
- if (done_search && !lq_sta->stay_in_tbl) {
+ if (done_search && lq_sta->rs_state == RS_STATE_SEARCH_CYCLE_ENDED) {
   /* If the "active" (non-search) mode was legacy,
    * and we've tried switching antennas,
    * but we haven't been able to try HT modes (not available),
    * stay with best antenna legacy modulation for a while
    * before next round of mode comparisons. */
   tbl1 = &(lq_sta->lq_info[lq_sta->active_tbl]);
-  if (is_legacy(tbl1->lq_type) && !sta->ht_cap.ht_supported &&
-      lq_sta->action_counter > tbl1->max_search) {
+  if (is_legacy(&tbl1->rate)) {
    IWL_DEBUG_RATE(mvm, "LQ: STAY in legacy table\n");
-   rs_set_stay_in_table(mvm, 1, lq_sta);
-  }
 
+   if (tid != IWL_MAX_TID_COUNT) {
+    tid_data = &sta_priv->tid_data[tid];
+    if (tid_data->state != IWL_AGG_OFF) {
+     IWL_DEBUG_RATE(mvm,
+             "Stop aggregation on tid %d\n",
+             tid);
+     ieee80211_stop_tx_ba_session(sta, tid);
+    }
+   }
+   rs_set_stay_in_table(mvm, 1, lq_sta);
+  } else {
   /* If we're in an HT mode, and all 3 mode switch actions
    * have been tried and compared, stay in this best modulation
    * mode for a while before next round of mode comparisons. */
-  if (lq_sta->enable_counter &&
-      (lq_sta->action_counter >= tbl1->max_search)) {
    if ((lq_sta->last_tpt > IWL_AGG_TPT_THREHOLD) &&
        (lq_sta->tx_agg_tid_en & (1 << tid)) &&
        (tid != IWL_MAX_TID_COUNT)) {
@@ -2413,7 +2291,6 @@ lq_update:
  }
 
 out:
- tbl->current_rate = rate_n_flags_from_tbl(mvm, tbl, index, is_green);
  lq_sta->last_txrate_idx = index;
 }
 
@@ -2434,13 +2311,12 @@ out:
 static void rs_initialize_lq(struct iwl_mvm *mvm,
         struct ieee80211_sta *sta,
         struct iwl_lq_sta *lq_sta,
-        enum ieee80211_band band)
+        enum ieee80211_band band,
+        bool init)
 {
  struct iwl_scale_tbl_info *tbl;
- int rate_idx;
+ struct rs_rate *rate;
  int i;
- u32 rate;
- u8 use_green = rs_use_green(sta);
  u8 active_tbl = 0;
  u8 valid_tx_ant;
 
@@ -2449,7 +2325,7 @@ static void rs_initialize_lq(struct iwl_mvm *mvm,
 
  i = lq_sta->last_txrate_idx;
 
- valid_tx_ant = iwl_fw_valid_tx_ant(mvm->fw);
+ valid_tx_ant = mvm->fw->valid_tx_ant;
 
  if (!lq_sta->search_better_tbl)
   active_tbl = lq_sta->active_tbl;
@@ -2457,27 +2333,30 @@ static void rs_initialize_lq(struct iwl_mvm *mvm,
   active_tbl = 1 - lq_sta->active_tbl;
 
  tbl = &(lq_sta->lq_info[active_tbl]);
+ rate = &tbl->rate;
 
  if ((i < 0) || (i >= IWL_RATE_COUNT))
   i = 0;
 
- rate = iwl_rates[i].plcp;
- tbl->ant_type = first_antenna(valid_tx_ant);
- rate |= tbl->ant_type << RATE_MCS_ANT_POS;
-
- if (i >= IWL_FIRST_CCK_RATE && i <= IWL_LAST_CCK_RATE)
-  rate |= RATE_MCS_CCK_MSK;
+ rate->index = i;
+ rate->ant = first_antenna(valid_tx_ant);
+ rate->sgi = false;
+ rate->bw = RATE_MCS_CHAN_WIDTH_20;
+ if (band == IEEE80211_BAND_5GHZ)
+  rate->type = LQ_LEGACY_A;
+ else
+  rate->type = LQ_LEGACY_G;
 
- rs_get_tbl_info_from_mcs(rate, band, tbl, &rate_idx);
- if (!rs_is_valid_ant(valid_tx_ant, tbl->ant_type))
-  rs_toggle_antenna(valid_tx_ant, &rate, tbl);
+ WARN_ON_ONCE(rate->ant != ANT_A && rate->ant != ANT_B);
+ if (rate->ant == ANT_A)
+  tbl->column = RS_COLUMN_LEGACY_ANT_A;
+ else
+  tbl->column = RS_COLUMN_LEGACY_ANT_B;
 
- rate = rate_n_flags_from_tbl(mvm, tbl, rate_idx, use_green);
- tbl->current_rate = rate;
  rs_set_expected_tpt_table(lq_sta, tbl);
- rs_fill_link_cmd(NULL, lq_sta, rate);
+ rs_fill_lq_cmd(mvm, sta, lq_sta, rate);
  /* TODO restore station should remember the lq cmd */
- iwl_mvm_send_lq_cmd(mvm, &lq_sta->lq, CMD_SYNC, true);
+ iwl_mvm_send_lq_cmd(mvm, &lq_sta->lq, init);
 }
 
 static void rs_get_rate(void *mvm_r, struct ieee80211_sta *sta, void *mvm_sta,
@@ -2490,9 +2369,6 @@ static void rs_get_rate(void *mvm_r, struct ieee80211_sta *sta, void *mvm_sta,
  struct iwl_mvm *mvm __maybe_unused = IWL_OP_MODE_GET_MVM(op_mode);
  struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
  struct iwl_lq_sta *lq_sta = mvm_sta;
- int rate_idx;
-
- IWL_DEBUG_RATE_LIMIT(mvm, "rate scale calculate new rate for skb\n");
 
  /* Get max rate if user set max rate */
  if (lq_sta) {
@@ -2515,37 +2391,9 @@ static void rs_get_rate(void *mvm_r, struct ieee80211_sta *sta, void *mvm_sta,
  if (rate_control_send_low(sta, mvm_sta, txrc))
   return;
 
- rate_idx  = lq_sta->last_txrate_idx;
-
- if (lq_sta->last_rate_n_flags & RATE_MCS_HT_MSK) {
-  rate_idx -= IWL_FIRST_OFDM_RATE;
-  /* 6M and 9M shared same MCS index */
-  rate_idx = (rate_idx > 0) ? (rate_idx - 1) : 0;
-  if (rs_extract_rate(lq_sta->last_rate_n_flags) >=
-      IWL_RATE_MIMO3_6M_PLCP)
-   rate_idx = rate_idx + (2 * MCS_INDEX_PER_STREAM);
-  else if (rs_extract_rate(lq_sta->last_rate_n_flags) >=
-    IWL_RATE_MIMO2_6M_PLCP)
-   rate_idx = rate_idx + MCS_INDEX_PER_STREAM;
-  info->control.rates[0].flags = IEEE80211_TX_RC_MCS;
-  if (lq_sta->last_rate_n_flags & RATE_MCS_SGI_MSK)
-   info->control.rates[0].flags |= IEEE80211_TX_RC_SHORT_GI;
-  if (lq_sta->last_rate_n_flags & RATE_MCS_CHAN_WIDTH_40) /* TODO */
-   info->control.rates[0].flags |= IEEE80211_TX_RC_40_MHZ_WIDTH;
-  if (lq_sta->last_rate_n_flags & RATE_HT_MCS_GF_MSK)
-   info->control.rates[0].flags |= IEEE80211_TX_RC_GREEN_FIELD;
- } else {
-  /* Check for invalid rates */
-  if ((rate_idx < 0) || (rate_idx >= IWL_RATE_COUNT_LEGACY) ||
-      ((sband->band == IEEE80211_BAND_5GHZ) &&
-       (rate_idx < IWL_FIRST_OFDM_RATE)))
-   rate_idx = rate_lowest_index(sband, sta);
-  /* On valid 5 GHz rate, adjust index */
-  else if (sband->band == IEEE80211_BAND_5GHZ)
-   rate_idx -= IWL_FIRST_OFDM_RATE;
-  info->control.rates[0].flags = 0;
- }
- info->control.rates[0].idx = rate_idx;
+ iwl_mvm_hwrate_to_tx_rate(lq_sta->last_rate_n_flags,
+      info->band, &info->control.rates[0]);
+
  info->control.rates[0].count = 1;
 }
 
@@ -2562,15 +2410,141 @@ static void *rs_alloc_sta(void *mvm_rate, struct ieee80211_sta *sta,
  return &sta_priv->lq_sta;
 }
 
+static int rs_vht_highest_rx_mcs_index(struct ieee80211_sta_vht_cap *vht_cap,
+           int nss)
+{
+ u16 rx_mcs = le16_to_cpu(vht_cap->vht_mcs.rx_mcs_map) &
+  (0x3 << (2 * (nss - 1)));
+ rx_mcs >>= (2 * (nss - 1));
+
+ if (rx_mcs == IEEE80211_VHT_MCS_SUPPORT_0_7)
+  return IWL_RATE_MCS_7_INDEX;
+ else if (rx_mcs == IEEE80211_VHT_MCS_SUPPORT_0_8)
+  return IWL_RATE_MCS_8_INDEX;
+ else if (rx_mcs == IEEE80211_VHT_MCS_SUPPORT_0_9)
+  return IWL_RATE_MCS_9_INDEX;
+
+ WARN_ON_ONCE(rx_mcs != IEEE80211_VHT_MCS_NOT_SUPPORTED);
+ return -1;
+}
+
+static void rs_vht_set_enabled_rates(struct ieee80211_sta *sta,
+         struct ieee80211_sta_vht_cap *vht_cap,
+         struct iwl_lq_sta *lq_sta)
+{
+ int i;
+ int highest_mcs = rs_vht_highest_rx_mcs_index(vht_cap, 1);
+
+ if (highest_mcs >= IWL_RATE_MCS_0_INDEX) {
+  for (i = IWL_RATE_MCS_0_INDEX; i <= highest_mcs; i++) {
+   if (i == IWL_RATE_9M_INDEX)
+    continue;
+
+   /* VHT MCS9 isn't valid for 20Mhz for NSS=1,2 */
+   if (i == IWL_RATE_MCS_9_INDEX &&
+       sta->bandwidth == IEEE80211_STA_RX_BW_20)
+    continue;
+
+   lq_sta->active_siso_rate |= BIT(i);
+  }
+ }
+
+ if (sta->rx_nss < 2)
+  return;
+
+ highest_mcs = rs_vht_highest_rx_mcs_index(vht_cap, 2);
+ if (highest_mcs >= IWL_RATE_MCS_0_INDEX) {
+  for (i = IWL_RATE_MCS_0_INDEX; i <= highest_mcs; i++) {
+   if (i == IWL_RATE_9M_INDEX)
+    continue;
+
+   /* VHT MCS9 isn't valid for 20Mhz for NSS=1,2 */
+   if (i == IWL_RATE_MCS_9_INDEX &&
+       sta->bandwidth == IEEE80211_STA_RX_BW_20)
+    continue;
+
+   lq_sta->active_mimo2_rate |= BIT(i);
+  }
+ }
+}
+
+#ifdef CONFIG_IWLWIFI_DEBUGFS
+static void iwl_mvm_reset_frame_stats(struct iwl_mvm *mvm,
+          struct iwl_mvm_frame_stats *stats)
+{
+ spin_lock_bh(&mvm->drv_stats_lock);
+ memset(stats, 0, sizeof(*stats));
+ spin_unlock_bh(&mvm->drv_stats_lock);
+}
+
+void iwl_mvm_update_frame_stats(struct iwl_mvm *mvm,
+    struct iwl_mvm_frame_stats *stats,
+    u32 rate, bool agg)
+{
+ u8 nss = 0, mcs = 0;
+
+ spin_lock(&mvm->drv_stats_lock);
+
+ if (agg)
+  stats->agg_frames++;
+
+ stats->success_frames++;
+
+ switch (rate & RATE_MCS_CHAN_WIDTH_MSK) {
+ case RATE_MCS_CHAN_WIDTH_20:
+  stats->bw_20_frames++;
+  break;
+ case RATE_MCS_CHAN_WIDTH_40:
+  stats->bw_40_frames++;
+  break;
+ case RATE_MCS_CHAN_WIDTH_80:
+  stats->bw_80_frames++;
+  break;
+ default:
+  WARN_ONCE(1, "bad BW. rate 0x%x", rate);
+ }
+
+ if (rate & RATE_MCS_HT_MSK) {
+  stats->ht_frames++;
+  mcs = rate & RATE_HT_MCS_RATE_CODE_MSK;
+  nss = ((rate & RATE_HT_MCS_NSS_MSK) >> RATE_HT_MCS_NSS_POS) + 1;
+ } else if (rate & RATE_MCS_VHT_MSK) {
+  stats->vht_frames++;
+  mcs = rate & RATE_VHT_MCS_RATE_CODE_MSK;
+  nss = ((rate & RATE_VHT_MCS_NSS_MSK) >>
+         RATE_VHT_MCS_NSS_POS) + 1;
+ } else {
+  stats->legacy_frames++;
+ }
+
+ if (nss == 1)
+  stats->siso_frames++;
+ else if (nss == 2)
+  stats->mimo2_frames++;
+
+ if (rate & RATE_MCS_SGI_MSK)
+  stats->sgi_frames++;
+ else
+  stats->ngi_frames++;
+
+ stats->last_rates[stats->last_frame_idx] = rate;
+ stats->last_frame_idx = (stats->last_frame_idx + 1) %
+  ARRAY_SIZE(stats->last_rates);
+
+ spin_unlock(&mvm->drv_stats_lock);
+}
+#endif
+
 /*
  * Called after adding a new station to initialize rate scaling
  */
 void iwl_mvm_rs_rate_init(struct iwl_mvm *mvm, struct ieee80211_sta *sta,
-     enum ieee80211_band band)
+     enum ieee80211_band band, bool init)
 {
  int i, j;
  struct ieee80211_hw *hw = mvm->hw;
  struct ieee80211_sta_ht_cap *ht_cap = &sta->ht_cap;
+ struct ieee80211_sta_vht_cap *vht_cap = &sta->vht_cap;
  struct iwl_mvm_sta *sta_priv;
  struct iwl_lq_sta *lq_sta;
  struct ieee80211_supported_band *sband;
@@ -2578,19 +2552,17 @@ void iwl_mvm_rs_rate_init(struct iwl_mvm *mvm, struct ieee80211_sta *sta,
 
  sta_priv = (struct iwl_mvm_sta *)sta->drv_priv;
  lq_sta = &sta_priv->lq_sta;
+ memset(lq_sta, 0, sizeof(*lq_sta));
+
  sband = hw->wiphy->bands[band];
 
  lq_sta->lq.sta_id = sta_priv->sta_id;
 
  for (j = 0; j < LQ_SIZE; j++)
-  for (i = 0; i < IWL_RATE_COUNT; i++)
-   rs_rate_scale_clear_window(&lq_sta->lq_info[j].win[i]);
+  rs_rate_scale_clear_tbl_windows(mvm, &lq_sta->lq_info[j]);
 
  lq_sta->flush_timer = 0;
- lq_sta->supp_rates = sta->supp_rates[sband->band];
- for (j = 0; j < LQ_SIZE; j++)
-  for (i = 0; i < IWL_RATE_COUNT; i++)
-   rs_rate_scale_clear_window(&lq_sta->lq_info[j].win[i]);
+ lq_sta->last_tx = jiffies;
 
  IWL_DEBUG_RATE(mvm,
          "LQ: *** rate scale station global init for station %d ***\n",
@@ -2602,7 +2574,6 @@ void iwl_mvm_rs_rate_init(struct iwl_mvm *mvm, struct ieee80211_sta *sta,
 
  lq_sta->max_rate_idx = -1;
  lq_sta->missed_rate_counter = IWL_MISSED_RATE_MAX;
- lq_sta->is_green = rs_use_green(sta);
  lq_sta->band = sband->band;
  /*
   * active legacy rates as per supported rates bitmap
@@ -2612,44 +2583,50 @@ void iwl_mvm_rs_rate_init(struct iwl_mvm *mvm, struct ieee80211_sta *sta,
  for_each_set_bit(i, &supp, BITS_PER_LONG)
   lq_sta->active_legacy_rate |= BIT(sband->bitrates[i].hw_value);
 
- /*
-  * active_siso_rate mask includes 9 MBits (bit 5), and CCK (bits 0-3),
-  * supp_rates[] does not; shift to convert format, force 9 MBits off.
-  */
- lq_sta->active_siso_rate = ht_cap->mcs.rx_mask[0] << 1;
- lq_sta->active_siso_rate |= ht_cap->mcs.rx_mask[0] & 0x1;
- lq_sta->active_siso_rate &= ~((u16)0x2);
- lq_sta->active_siso_rate <<= IWL_FIRST_OFDM_RATE;
-
- /* Same here */
- lq_sta->active_mimo2_rate = ht_cap->mcs.rx_mask[1] << 1;
- lq_sta->active_mimo2_rate |= ht_cap->mcs.rx_mask[1] & 0x1;
- lq_sta->active_mimo2_rate &= ~((u16)0x2);
- lq_sta->active_mimo2_rate <<= IWL_FIRST_OFDM_RATE;
-
- lq_sta->active_mimo3_rate = ht_cap->mcs.rx_mask[2] << 1;
- lq_sta->active_mimo3_rate |= ht_cap->mcs.rx_mask[2] & 0x1;
- lq_sta->active_mimo3_rate &= ~((u16)0x2);
- lq_sta->active_mimo3_rate <<= IWL_FIRST_OFDM_RATE;
+ /* TODO: should probably account for rx_highest for both HT/VHT */
+ if (!vht_cap || !vht_cap->vht_supported) {
+  /* active_siso_rate mask includes 9 MBits (bit 5),
+   * and CCK (bits 0-3), supp_rates[] does not;
+   * shift to convert format, force 9 MBits off.
+   */
+  lq_sta->active_siso_rate = ht_cap->mcs.rx_mask[0] << 1;
+  lq_sta->active_siso_rate |= ht_cap->mcs.rx_mask[0] & 0x1;
+  lq_sta->active_siso_rate &= ~((u16)0x2);
+  lq_sta->active_siso_rate <<= IWL_FIRST_OFDM_RATE;
+
+  /* Same here */
+  lq_sta->active_mimo2_rate = ht_cap->mcs.rx_mask[1] << 1;
+  lq_sta->active_mimo2_rate |= ht_cap->mcs.rx_mask[1] & 0x1;
+  lq_sta->active_mimo2_rate &= ~((u16)0x2);
+  lq_sta->active_mimo2_rate <<= IWL_FIRST_OFDM_RATE;
+
+  lq_sta->is_vht = false;
+ } else {
+  rs_vht_set_enabled_rates(sta, vht_cap, lq_sta);
+  lq_sta->is_vht = true;
+ }
 
- IWL_DEBUG_RATE(mvm,
-         "SISO-RATE=%X MIMO2-RATE=%X MIMO3-RATE=%X\n",
+ lq_sta->max_legacy_rate_idx = find_last_bit(&lq_sta->active_legacy_rate,
+          BITS_PER_LONG);
+ lq_sta->max_siso_rate_idx = find_last_bit(&lq_sta->active_siso_rate,
+        BITS_PER_LONG);
+ lq_sta->max_mimo2_rate_idx = find_last_bit(&lq_sta->active_mimo2_rate,
+         BITS_PER_LONG);
+
+ IWL_DEBUG_RATE(mvm, "RATE MASK: LEGACY=%lX SISO=%lX MIMO2=%lX VHT=%d\n",
+         lq_sta->active_legacy_rate,
          lq_sta->active_siso_rate,
          lq_sta->active_mimo2_rate,
-         lq_sta->active_mimo3_rate);
+         lq_sta->is_vht);
+ IWL_DEBUG_RATE(mvm, "MAX RATE: LEGACY=%d SISO=%d MIMO2=%d\n",
+         lq_sta->max_legacy_rate_idx,
+         lq_sta->max_siso_rate_idx,
+         lq_sta->max_mimo2_rate_idx);
 
  /* These values will be overridden later */
  lq_sta->lq.single_stream_ant_msk =
-  first_antenna(iwl_fw_valid_tx_ant(mvm->fw));
- lq_sta->lq.dual_stream_ant_msk =
-  iwl_fw_valid_tx_ant(mvm->fw) &
-  ~first_antenna(iwl_fw_valid_tx_ant(mvm->fw));
- if (!lq_sta->lq.dual_stream_ant_msk) {
-  lq_sta->lq.dual_stream_ant_msk = ANT_AB;
- } else if (num_of_ant(iwl_fw_valid_tx_ant(mvm->fw)) == 2) {
-  lq_sta->lq.dual_stream_ant_msk =
-   iwl_fw_valid_tx_ant(mvm->fw);
- }
+  first_antenna(mvm->fw->valid_tx_ant);
+ lq_sta->lq.dual_stream_ant_msk = ANT_AB;
 
  /* as default allow aggregation for all tids */
  lq_sta->tx_agg_tid_en = IWL_AGG_ALL_TID;
@@ -2662,127 +2639,201 @@ void iwl_mvm_rs_rate_init(struct iwl_mvm *mvm, struct ieee80211_sta *sta,
  lq_sta->is_agg = 0;
 #ifdef CONFIG_MAC80211_DEBUGFS
  lq_sta->dbg_fixed_rate = 0;
+ lq_sta->dbg_fixed_txp_reduction = TPC_INVALID;
+#endif
+#ifdef CONFIG_IWLWIFI_DEBUGFS
+ iwl_mvm_reset_frame_stats(mvm, &mvm->drv_rx_stats);
 #endif
+ rs_initialize_lq(mvm, sta, lq_sta, band, init);
+}
+
+static void rs_rate_update(void *mvm_r,
+      struct ieee80211_supported_band *sband,
+      struct cfg80211_chan_def *chandef,
+      struct ieee80211_sta *sta, void *priv_sta,
+      u32 changed)
+{
+ u8 tid;
+ struct iwl_op_mode *op_mode  =
+   (struct iwl_op_mode *)mvm_r;
+ struct iwl_mvm *mvm = IWL_OP_MODE_GET_MVM(op_mode);
+
+ /* Stop any ongoing aggregations as rs starts off assuming no agg */
+ for (tid = 0; tid < IWL_MAX_TID_COUNT; tid++)
+  ieee80211_stop_tx_ba_session(sta, tid);
 
- rs_initialize_lq(mvm, sta, lq_sta, band);
+ iwl_mvm_rs_rate_init(mvm, sta, sband->band, false);
 }
 
-static void rs_fill_link_cmd(struct iwl_mvm *mvm,
-        struct iwl_lq_sta *lq_sta, u32 new_rate)
+#ifdef CONFIG_MAC80211_DEBUGFS
+static void rs_build_rates_table_from_fixed(struct iwl_mvm *mvm,
+         struct iwl_lq_cmd *lq_cmd,
+         enum ieee80211_band band,
+         u32 ucode_rate)
 {
- struct iwl_scale_tbl_info tbl_type;
- int index = 0;
- int rate_idx;
- int repeat_rate = 0;
- u8 ant_toggle_cnt = 0;
- u8 use_ht_possible = 1;
+ struct rs_rate rate;
+ int i;
+ int num_rates = ARRAY_SIZE(lq_cmd->rs_table);
+ __le32 ucode_rate_le32 = cpu_to_le32(ucode_rate);
+
+ for (i = 0; i < num_rates; i++)
+  lq_cmd->rs_table[i] = ucode_rate_le32;
+
+ rs_rate_from_ucode_rate(ucode_rate, band, &rate);
+
+ if (is_mimo(&rate))
+  lq_cmd->mimo_delim = num_rates - 1;
+ else
+  lq_cmd->mimo_delim = 0;
+}
+#endif /* CONFIG_MAC80211_DEBUGFS */
+
+static void rs_fill_rates_for_column(struct iwl_mvm *mvm,
+         struct iwl_lq_sta *lq_sta,
+         struct rs_rate *rate,
+         __le32 *rs_table, int *rs_table_index,
+         int num_rates, int num_retries,
+         u8 valid_tx_ant, bool toggle_ant)
+{
+ int i, j;
+ __le32 ucode_rate;
+ bool bottom_reached = false;
+ int prev_rate_idx = rate->index;
+ int end = LINK_QUAL_MAX_RETRY_NUM;
+ int index = *rs_table_index;
+
+ for (i = 0; i < num_rates && index < end; i++) {
+  ucode_rate = cpu_to_le32(ucode_rate_from_rs_rate(mvm, rate));
+  for (j = 0; j < num_retries && index < end; j++, index++)
+   rs_table[index] = ucode_rate;
+
+  if (toggle_ant)
+   rs_toggle_antenna(valid_tx_ant, rate);
+
+  prev_rate_idx = rate->index;
+  bottom_reached = rs_get_lower_rate_in_column(lq_sta, rate);
+  if (bottom_reached && !is_legacy(rate))
+   break;
+ }
+
+ if (!bottom_reached)
+  rate->index = prev_rate_idx;
+
+ *rs_table_index = index;
+}
+
+/* Building the rate table is non trivial. When we're in MIMO2/VHT/80Mhz/SGI
+ * column the rate table should look like this:
+ *
+ * rate[0] 0x400D019 VHT | ANT: AB BW: 80Mhz MCS: 9 NSS: 2 SGI
+ * rate[1] 0x400D019 VHT | ANT: AB BW: 80Mhz MCS: 9 NSS: 2 SGI
+ * rate[2] 0x400D018 VHT | ANT: AB BW: 80Mhz MCS: 8 NSS: 2 SGI
+ * rate[3] 0x400D018 VHT | ANT: AB BW: 80Mhz MCS: 8 NSS: 2 SGI
+ * rate[4] 0x400D017 VHT | ANT: AB BW: 80Mhz MCS: 7 NSS: 2 SGI
+ * rate[5] 0x400D017 VHT | ANT: AB BW: 80Mhz MCS: 7 NSS: 2 SGI
+ * rate[6] 0x4005007 VHT | ANT: A BW: 80Mhz MCS: 7 NSS: 1 NGI
+ * rate[7] 0x4009006 VHT | ANT: B BW: 80Mhz MCS: 6 NSS: 1 NGI
+ * rate[8] 0x4005005 VHT | ANT: A BW: 80Mhz MCS: 5 NSS: 1 NGI
+ * rate[9] 0x800B Legacy | ANT: B Rate: 36 Mbps
+ * rate[10] 0x4009 Legacy | ANT: A Rate: 24 Mbps
+ * rate[11] 0x8007 Legacy | ANT: B Rate: 18 Mbps
+ * rate[12] 0x4005 Legacy | ANT: A Rate: 12 Mbps
+ * rate[13] 0x800F Legacy | ANT: B Rate: 9 Mbps
+ * rate[14] 0x400D Legacy | ANT: A Rate: 6 Mbps
+ * rate[15] 0x800D Legacy | ANT: B Rate: 6 Mbps
+ */
+static void rs_build_rates_table(struct iwl_mvm *mvm,
+     struct iwl_lq_sta *lq_sta,
+     const struct rs_rate *initial_rate)
+{
+ struct rs_rate rate;
+ int num_rates, num_retries, index = 0;
  u8 valid_tx_ant = 0;
  struct iwl_lq_cmd *lq_cmd = &lq_sta->lq;
+ bool toggle_ant = false;
 
- /* Override starting rate (index 0) if needed for debug purposes */
- rs_dbgfs_set_mcs(lq_sta, &new_rate, index);
+ memcpy(&rate, initial_rate, sizeof(rate));
 
- /* Interpret new_rate (rate_n_flags) */
- rs_get_tbl_info_from_mcs(new_rate, lq_sta->band,
-     &tbl_type, &rate_idx);
+ valid_tx_ant = mvm->fw->valid_tx_ant;
 
- /* How many times should we repeat the initial rate? */
- if (is_legacy(tbl_type.lq_type)) {
-  ant_toggle_cnt = 1;
-  repeat_rate = IWL_NUMBER_TRY;
+ if (is_siso(&rate)) {
+  num_rates = RS_INITIAL_SISO_NUM_RATES;
+  num_retries = RS_HT_VHT_RETRIES_PER_RATE;
+ } else if (is_mimo(&rate)) {
+  num_rates = RS_INITIAL_MIMO_NUM_RATES;
+  num_retries = RS_HT_VHT_RETRIES_PER_RATE;
  } else {
-  repeat_rate = min(IWL_HT_NUMBER_TRY,
-      LINK_QUAL_AGG_DISABLE_START_DEF - 1);
- }
-
- lq_cmd->mimo_delim = is_mimo(tbl_type.lq_type) ? 1 : 0;
-
- /* Fill 1st table entry (index 0) */
- lq_cmd->rs_table[index] = cpu_to_le32(new_rate);
-
- if (num_of_ant(tbl_type.ant_type) == 1)
-  lq_cmd->single_stream_ant_msk = tbl_type.ant_type;
- else if (num_of_ant(tbl_type.ant_type) == 2)
-  lq_cmd->dual_stream_ant_msk = tbl_type.ant_type;
- /* otherwise we don't modify the existing value */
-
- index++;
- repeat_rate--;
- if (mvm)
-  valid_tx_ant = iwl_fw_valid_tx_ant(mvm->fw);
-
- /* Fill rest of rate table */
- while (index < LINK_QUAL_MAX_RETRY_NUM) {
-  /* Repeat initial/next rate.
-   * For legacy IWL_NUMBER_TRY == 1, this loop will not execute.
-   * For HT IWL_HT_NUMBER_TRY == 3, this executes twice. */
-  while (repeat_rate > 0 && (index < LINK_QUAL_MAX_RETRY_NUM)) {
-   if (is_legacy(tbl_type.lq_type)) {
-    if (ant_toggle_cnt < NUM_TRY_BEFORE_ANT_TOGGLE)
-     ant_toggle_cnt++;
-    else if (mvm &&
-      rs_toggle_antenna(valid_tx_ant,
-       &new_rate, &tbl_type))
-     ant_toggle_cnt = 1;
-   }
+  num_rates = RS_INITIAL_LEGACY_NUM_RATES;
+  num_retries = RS_LEGACY_RETRIES_PER_RATE;
+  toggle_ant = true;
+ }
 
-   /* Override next rate if needed for debug purposes */
-   rs_dbgfs_set_mcs(lq_sta, &new_rate, index);
+ rs_fill_rates_for_column(mvm, lq_sta, &rate, lq_cmd->rs_table, &index,
+     num_rates, num_retries, valid_tx_ant,
+     toggle_ant);
 
-   /* Fill next table entry */
-   lq_cmd->rs_table[index] =
-     cpu_to_le32(new_rate);
-   repeat_rate--;
-   index++;
-  }
+ rs_get_lower_rate_down_column(lq_sta, &rate);
 
-  rs_get_tbl_info_from_mcs(new_rate, lq_sta->band, &tbl_type,
-      &rate_idx);
+ if (is_siso(&rate)) {
+  num_rates = RS_SECONDARY_SISO_NUM_RATES;
+  num_retries = RS_SECONDARY_SISO_RETRIES;
+  lq_cmd->mimo_delim = index;
+ } else if (is_legacy(&rate)) {
+  num_rates = RS_SECONDARY_LEGACY_NUM_RATES;
+  num_retries = RS_LEGACY_RETRIES_PER_RATE;
+ } else {
+  WARN_ON_ONCE(1);
+ }
 
+ toggle_ant = true;
 
-  /* Indicate to uCode which entries might be MIMO.
-   * If initial rate was MIMO, this will finally end up
-   * as (IWL_HT_NUMBER_TRY * 2), after 2nd pass, otherwise 0. */
-  if (is_mimo(tbl_type.lq_type))
-   lq_cmd->mimo_delim = index;
+ rs_fill_rates_for_column(mvm, lq_sta, &rate, lq_cmd->rs_table, &index,
+     num_rates, num_retries, valid_tx_ant,
+     toggle_ant);
 
-  /* Get next rate */
-  new_rate = rs_get_lower_rate(lq_sta, &tbl_type, rate_idx,
-          use_ht_possible);
+ rs_get_lower_rate_down_column(lq_sta, &rate);
 
-  /* How many times should we repeat the next rate? */
-  if (is_legacy(tbl_type.lq_type)) {
-   if (ant_toggle_cnt < NUM_TRY_BEFORE_ANT_TOGGLE)
-    ant_toggle_cnt++;
-   else if (mvm &&
-     rs_toggle_antenna(valid_tx_ant,
-         &new_rate, &tbl_type))
-    ant_toggle_cnt = 1;
+ num_rates = RS_SECONDARY_LEGACY_NUM_RATES;
+ num_retries = RS_LEGACY_RETRIES_PER_RATE;
 
-   repeat_rate = IWL_NUMBER_TRY;
-  } else {
-   repeat_rate = IWL_HT_NUMBER_TRY;
-  }
+ rs_fill_rates_for_column(mvm, lq_sta, &rate, lq_cmd->rs_table, &index,
+     num_rates, num_retries, valid_tx_ant,
+     toggle_ant);
 
-  /* Don't allow HT rates after next pass.
-   * rs_get_lower_rate() will change type to LQ_A or LQ_G. */
-  use_ht_possible = 0;
+}
 
-  /* Override next rate if needed for debug purposes */
-  rs_dbgfs_set_mcs(lq_sta, &new_rate, index);
+static void rs_fill_lq_cmd(struct iwl_mvm *mvm,
+      struct ieee80211_sta *sta,
+      struct iwl_lq_sta *lq_sta,
+      const struct rs_rate *initial_rate)
+{
+ struct iwl_lq_cmd *lq_cmd = &lq_sta->lq;
+ u8 ant = initial_rate->ant;
 
-  /* Fill next table entry */
-  lq_cmd->rs_table[index] = cpu_to_le32(new_rate);
+#ifdef CONFIG_MAC80211_DEBUGFS
+ if (lq_sta->dbg_fixed_rate) {
+  rs_build_rates_table_from_fixed(mvm, lq_cmd,
+      lq_sta->band,
+      lq_sta->dbg_fixed_rate);
+  lq_cmd->reduced_tpc = 0;
+  ant = (lq_sta->dbg_fixed_rate & RATE_MCS_ANT_ABC_MSK) >>
+   RATE_MCS_ANT_POS;
+ } else
+#endif
+  rs_build_rates_table(mvm, lq_sta, initial_rate);
 
-  index++;
-  repeat_rate--;
- }
+ if (num_of_ant(ant) == 1)
+  lq_cmd->single_stream_ant_msk = ant;
 
  lq_cmd->agg_frame_cnt_limit = LINK_QUAL_AGG_FRAME_LIMIT_DEF;
  lq_cmd->agg_disable_start_th = LINK_QUAL_AGG_DISABLE_START_DEF;
 
  lq_cmd->agg_time_limit =
   cpu_to_le16(LINK_QUAL_AGG_TIME_LIMIT_DEF);
+
+ if (sta)
+  lq_cmd->agg_time_limit =
+   cpu_to_le16(iwl_mvm_coex_agg_time_limit(mvm, sta));
 }
 
 static void *rs_alloc(struct ieee80211_hw *hw, struct dentry *debugfsdir)
@@ -2806,31 +2857,83 @@ static void rs_free_sta(void *mvm_r, struct ieee80211_sta *sta,
 }
 
 #ifdef CONFIG_MAC80211_DEBUGFS
-static void rs_dbgfs_set_mcs(struct iwl_lq_sta *lq_sta,
-        u32 *rate_n_flags, int index)
+int rs_pretty_print_rate(char *buf, const u32 rate)
 {
- struct iwl_mvm *mvm;
- u8 valid_tx_ant;
- u8 ant_sel_tx;
 
- mvm = lq_sta->drv;
- valid_tx_ant = iwl_fw_valid_tx_ant(mvm->fw);
- if (lq_sta->dbg_fixed_rate) {
-  ant_sel_tx =
-    ((lq_sta->dbg_fixed_rate & RATE_MCS_ANT_ABC_MSK)
-    >> RATE_MCS_ANT_POS);
-  if ((valid_tx_ant & ant_sel_tx) == ant_sel_tx) {
-   *rate_n_flags = lq_sta->dbg_fixed_rate;
-   IWL_DEBUG_RATE(mvm, "Fixed rate ON\n");
-  } else {
-   lq_sta->dbg_fixed_rate = 0;
-   IWL_ERR(mvm,
-    "Invalid antenna selection 0x%X, Valid is 0x%X\n",
-    ant_sel_tx, valid_tx_ant);
-   IWL_DEBUG_RATE(mvm, "Fixed rate OFF\n");
-  }
+ char *type, *bw;
+ u8 mcs = 0, nss = 0;
+ u8 ant = (rate & RATE_MCS_ANT_ABC_MSK) >> RATE_MCS_ANT_POS;
+
+ if (!(rate & RATE_MCS_HT_MSK) &&
+     !(rate & RATE_MCS_VHT_MSK)) {
+  int index = iwl_hwrate_to_plcp_idx(rate);
+
+  return sprintf(buf, "Legacy | ANT: %s Rate: %s Mbps\n",
+          rs_pretty_ant(ant),
+          index == IWL_RATE_INVALID ? "BAD" :
+          iwl_rate_mcs[index].mbps);
+ }
+
+ if (rate & RATE_MCS_VHT_MSK) {
+  type = "VHT";
+  mcs = rate & RATE_VHT_MCS_RATE_CODE_MSK;
+  nss = ((rate & RATE_VHT_MCS_NSS_MSK)
+         >> RATE_VHT_MCS_NSS_POS) + 1;
+ } else if (rate & RATE_MCS_HT_MSK) {
+  type = "HT";
+  mcs = rate & RATE_HT_MCS_INDEX_MSK;
  } else {
-  IWL_DEBUG_RATE(mvm, "Fixed rate OFF\n");
+  type = "Unknown"; /* shouldn't happen */
+ }
+
+ switch (rate & RATE_MCS_CHAN_WIDTH_MSK) {
+ case RATE_MCS_CHAN_WIDTH_20:
+  bw = "20Mhz";
+  break;
+ case RATE_MCS_CHAN_WIDTH_40:
+  bw = "40Mhz";
+  break;
+ case RATE_MCS_CHAN_WIDTH_80:
+  bw = "80Mhz";
+  break;
+ case RATE_MCS_CHAN_WIDTH_160:
+  bw = "160Mhz";
+  break;
+ default:
+  bw = "BAD BW";
+ }
+
+ return sprintf(buf, "%s | ANT: %s BW: %s MCS: %d NSS: %d %s%s%s%s%s\n",
+         type, rs_pretty_ant(ant), bw, mcs, nss,
+         (rate & RATE_MCS_SGI_MSK) ? "SGI " : "NGI ",
+         (rate & RATE_MCS_HT_STBC_MSK) ? "STBC " : "",
+         (rate & RATE_MCS_LDPC_MSK) ? "LDPC " : "",
+         (rate & RATE_MCS_BF_MSK) ? "BF " : "",
+         (rate & RATE_MCS_ZLF_MSK) ? "ZLF " : "");
+}
+
+/**
+ * Program the device to use fixed rate for frame transmit
+ * This is for debugging/testing only
+ * once the device start use fixed rate, we need to reload the module
+ * to being back the normal operation.
+ */
+static void rs_program_fix_rate(struct iwl_mvm *mvm,
+    struct iwl_lq_sta *lq_sta)
+{
+ lq_sta->active_legacy_rate = 0x0FFF; /* 1 - 54 MBits, includes CCK */
+ lq_sta->active_siso_rate   = 0x1FD0; /* 6 - 60 MBits, no 9, no CCK */
+ lq_sta->active_mimo2_rate  = 0x1FD0; /* 6 - 60 MBits, no 9, no CCK */
+
+ IWL_DEBUG_RATE(mvm, "sta_id %d rate 0x%X\n",
+         lq_sta->lq.sta_id, lq_sta->dbg_fixed_rate);
+
+ if (lq_sta->dbg_fixed_rate) {
+  struct rs_rate rate;
+  rs_rate_from_ucode_rate(lq_sta->dbg_fixed_rate,
+     lq_sta->band, &rate);
+  rs_fill_lq_cmd(mvm, NULL, lq_sta, &rate);
+  iwl_mvm_send_lq_cmd(lq_sta->drv, &lq_sta->lq, false);
  }
 }
 
@@ -2843,7 +2946,6 @@ static ssize_t rs_sta_dbgfs_scale_table_write(struct file *file,
  size_t buf_size;
  u32 parsed_rate;
 
-
  mvm = lq_sta->drv;
  memset(buf, 0, sizeof(buf));
  buf_size = min(count, sizeof(buf) -  1);
@@ -2866,45 +2968,45 @@ static ssize_t rs_sta_dbgfs_scale_table_read(struct file *file,
  char *buff;
  int desc = 0;
  int i = 0;
- int index = 0;
  ssize_t ret;
 
  struct iwl_lq_sta *lq_sta = file->private_data;
  struct iwl_mvm *mvm;
  struct iwl_scale_tbl_info *tbl = &(lq_sta->lq_info[lq_sta->active_tbl]);
-
+ struct rs_rate *rate = &tbl->rate;
  mvm = lq_sta->drv;
- buff = kmalloc(1024, GFP_KERNEL);
+ buff = kmalloc(2048, GFP_KERNEL);
  if (!buff)
   return -ENOMEM;
 
  desc += sprintf(buff+desc, "sta_id %d\n", lq_sta->lq.sta_id);
- desc += sprintf(buff+desc, "failed=%d success=%d rate=0%X\n",
+ desc += sprintf(buff+desc, "failed=%d success=%d rate=0%lX\n",
    lq_sta->total_failed, lq_sta->total_success,
    lq_sta->active_legacy_rate);
  desc += sprintf(buff+desc, "fixed rate 0x%X\n",
    lq_sta->dbg_fixed_rate);
  desc += sprintf(buff+desc, "valid_tx_ant %s%s%s\n",
-     (iwl_fw_valid_tx_ant(mvm->fw) & ANT_A) ? "ANT_A," : "",
-     (iwl_fw_valid_tx_ant(mvm->fw) & ANT_B) ? "ANT_B," : "",
-     (iwl_fw_valid_tx_ant(mvm->fw) & ANT_C) ? "ANT_C" : "");
+     (mvm->fw->valid_tx_ant & ANT_A) ? "ANT_A," : "",
+     (mvm->fw->valid_tx_ant & ANT_B) ? "ANT_B," : "",
+     (mvm->fw->valid_tx_ant & ANT_C) ? "ANT_C" : "");
  desc += sprintf(buff+desc, "lq type %s\n",
-    (is_legacy(tbl->lq_type)) ? "legacy" : "HT");
- if (is_Ht(tbl->lq_type)) {
+   (is_legacy(rate)) ? "legacy" :
+   is_vht(rate) ? "VHT" : "HT");
+ if (!is_legacy(rate)) {
   desc += sprintf(buff+desc, " %s",
-     (is_siso(tbl->lq_type)) ? "SISO" :
-     ((is_mimo2(tbl->lq_type)) ? "MIMO2" : "MIMO3"));
+     (is_siso(rate)) ? "SISO" : "MIMO2");
      desc += sprintf(buff+desc, " %s",
-     (tbl->is_ht40) ? "40MHz" : "20MHz");
-     desc += sprintf(buff+desc, " %s %s %s\n",
-       (tbl->is_SGI) ? "SGI" : "",
-     (lq_sta->is_green) ? "GF enabled" : "",
-     (lq_sta->is_agg) ? "AGG on" : "");
+       (is_ht20(rate)) ? "20MHz" :
+       (is_ht40(rate)) ? "40MHz" :
+       (is_ht80(rate)) ? "80Mhz" : "BAD BW");
+     desc += sprintf(buff+desc, " %s %s\n",
+       (rate->sgi) ? "SGI" : "NGI",
+       (lq_sta->is_agg) ? "AGG on" : "");
  }
  desc += sprintf(buff+desc, "last tx rate=0x%X\n",
    lq_sta->last_rate_n_flags);
  desc += sprintf(buff+desc,
-   "general: flags=0x%X mimo-d=%d s-ant0x%x d-ant=0x%x\n",
+   "general: flags=0x%X mimo-d=%d s-ant=0x%x d-ant=0x%x\n",
    lq_sta->lq.flags,
    lq_sta->lq.mimo_delim,
    lq_sta->lq.single_stream_ant_msk,
@@ -2916,6 +3018,7 @@ static ssize_t rs_sta_dbgfs_scale_table_read(struct file *file,
    lq_sta->lq.agg_disable_start_th,
    lq_sta->lq.agg_frame_cnt_limit);
 
+ desc += sprintf(buff+desc, "reduced tpc=%d\n", lq_sta->lq.reduced_tpc);
  desc += sprintf(buff+desc,
    "Start idx [0]=0x%x [1]=0x%x [2]=0x%x [3]=0x%x\n",
    lq_sta->lq.initial_rate_index[0],
@@ -2924,19 +3027,10 @@ static ssize_t rs_sta_dbgfs_scale_table_read(struct file *file,
    lq_sta->lq.initial_rate_index[3]);
 
  for (i = 0; i < LINK_QUAL_MAX_RETRY_NUM; i++) {
-  index = iwl_hwrate_to_plcp_idx(
-   le32_to_cpu(lq_sta->lq.rs_table[i]));
-  if (is_legacy(tbl->lq_type)) {
-   desc += sprintf(buff+desc, " rate[%d] 0x%X %smbps\n",
-     i, le32_to_cpu(lq_sta->lq.rs_table[i]),
-     iwl_rate_mcs[index].mbps);
-  } else {
-   desc += sprintf(buff+desc,
-     " rate[%d] 0x%X %smbps (%s)\n",
-     i, le32_to_cpu(lq_sta->lq.rs_table[i]),
-     iwl_rate_mcs[index].mbps,
-     iwl_rate_mcs[index].mcs);
-  }
+  u32 r = le32_to_cpu(lq_sta->lq.rs_table[i]);
+
+  desc += sprintf(buff+desc, " rate[%d] 0x%X ", i, r);
+  desc += rs_pretty_print_rate(buff+desc, r);
  }
 
  ret = simple_read_from_buffer(user_buf, count, ppos, buff, desc);
@@ -2957,7 +3051,8 @@ static ssize_t rs_sta_dbgfs_stats_table_read(struct file *file,
  int desc = 0;
  int i, j;
  ssize_t ret;
-
+ struct iwl_scale_tbl_info *tbl;
+ struct rs_rate *rate;
  struct iwl_lq_sta *lq_sta = file->private_data;
 
  buff = kmalloc(1024, GFP_KERNEL);
@@ -2965,21 +3060,24 @@ static ssize_t rs_sta_dbgfs_stats_table_read(struct file *file,
   return -ENOMEM;
 
  for (i = 0; i < LQ_SIZE; i++) {
+  tbl = &(lq_sta->lq_info[i]);
+  rate = &tbl->rate;
   desc += sprintf(buff+desc,
-    "%s type=%d SGI=%d HT40=%d DUP=0 GF=%d\n"
-    "rate=0x%X\n",
+    "%s type=%d SGI=%d BW=%s DUP=0\n"
+    "index=%d\n",
     lq_sta->active_tbl == i ? "*" : "x",
-    lq_sta->lq_info[i].lq_type,
-    lq_sta->lq_info[i].is_SGI,
-    lq_sta->lq_info[i].is_ht40,
-    lq_sta->is_green,
-    lq_sta->lq_info[i].current_rate);
+    rate->type,
+    rate->sgi,
+    is_ht20(rate) ? "20Mhz" :
+    is_ht40(rate) ? "40Mhz" :
+    is_ht80(rate) ? "80Mhz" : "ERR",
+    rate->index);
   for (j = 0; j < IWL_RATE_COUNT; j++) {
    desc += sprintf(buff+desc,
     "counter=%d success=%d %%=%d\n",
-    lq_sta->lq_info[i].win[j].counter,
-    lq_sta->lq_info[i].win[j].success_counter,
-    lq_sta->lq_info[i].win[j].success_ratio);
+    tbl->win[j].counter,
+    tbl->win[j].success_counter,
+    tbl->win[j].success_ratio);
   }
  }
  ret = simple_read_from_buffer(user_buf, count, ppos, buff, desc);
@@ -2993,28 +3091,90 @@ static const struct file_operations rs_sta_dbgfs_stats_table_ops = {
  .llseek = default_llseek,
 };
 
-static ssize_t rs_sta_dbgfs_rate_scale_data_read(struct file *file,
-   char __user *user_buf, size_t count, loff_t *ppos)
+static ssize_t rs_sta_dbgfs_drv_tx_stats_read(struct file *file,
+           char __user *user_buf,
+           size_t count, loff_t *ppos)
 {
+ static const char * const column_name[] = {
+  [RS_COLUMN_LEGACY_ANT_A] = "LEGACY_ANT_A",
+  [RS_COLUMN_LEGACY_ANT_B] = "LEGACY_ANT_B",
+  [RS_COLUMN_SISO_ANT_A] = "SISO_ANT_A",
+  [RS_COLUMN_SISO_ANT_B] = "SISO_ANT_B",
+  [RS_COLUMN_SISO_ANT_A_SGI] = "SISO_ANT_A_SGI",
+  [RS_COLUMN_SISO_ANT_B_SGI] = "SISO_ANT_B_SGI",
+  [RS_COLUMN_MIMO2] = "MIMO2",
+  [RS_COLUMN_MIMO2_SGI] = "MIMO2_SGI",
+ };
+
+ static const char * const rate_name[] = {
+  [IWL_RATE_1M_INDEX] = "1M",
+  [IWL_RATE_2M_INDEX] = "2M",
+  [IWL_RATE_5M_INDEX] = "5.5M",
+  [IWL_RATE_11M_INDEX] = "11M",
+  [IWL_RATE_6M_INDEX] = "6M|MCS0",
+  [IWL_RATE_9M_INDEX] = "9M",
+  [IWL_RATE_12M_INDEX] = "12M|MCS1",
+  [IWL_RATE_18M_INDEX] = "18M|MCS2",
+  [IWL_RATE_24M_INDEX] = "24M|MCS3",
+  [IWL_RATE_36M_INDEX] = "36M|MCS4",
+  [IWL_RATE_48M_INDEX] = "48M|MCS5",
+  [IWL_RATE_54M_INDEX] = "54M|MCS6",
+  [IWL_RATE_MCS_7_INDEX] = "MCS7",
+  [IWL_RATE_MCS_8_INDEX] = "MCS8",
+  [IWL_RATE_MCS_9_INDEX] = "MCS9",
+ };
+
+ char *buff, *pos, *endpos;
+ int col, rate;
+ ssize_t ret;
  struct iwl_lq_sta *lq_sta = file->private_data;
- struct iwl_scale_tbl_info *tbl = &lq_sta->lq_info[lq_sta->active_tbl];
- char buff[120];
- int desc = 0;
+ struct rs_rate_stats *stats;
+ static const size_t bufsz = 1024;
 
- if (is_Ht(tbl->lq_type))
-  desc += sprintf(buff+desc,
-    "Bit Rate= %d Mb/s\n",
-    tbl->expected_tpt[lq_sta->last_txrate_idx]);
- else
-  desc += sprintf(buff+desc,
-    "Bit Rate= %d Mb/s\n",
-    iwl_rates[lq_sta->last_txrate_idx].ieee >> 1);
+ buff = kmalloc(bufsz, GFP_KERNEL);
+ if (!buff)
+  return -ENOMEM;
+
+ pos = buff;
+ endpos = pos + bufsz;
+
+ pos += scnprintf(pos, endpos - pos, "COLUMN,");
+ for (rate = 0; rate < IWL_RATE_COUNT; rate++)
+  pos += scnprintf(pos, endpos - pos, "%s,", rate_name[rate]);
+ pos += scnprintf(pos, endpos - pos, "\n");
+
+ for (col = 0; col < RS_COLUMN_COUNT; col++) {
+  pos += scnprintf(pos, endpos - pos,
+     "%s,", column_name[col]);
+
+  for (rate = 0; rate < IWL_RATE_COUNT; rate++) {
+   stats = &(lq_sta->tx_stats[col][rate]);
+   pos += scnprintf(pos, endpos - pos,
+      "%llu/%llu,",
+      stats->success,
+      stats->total);
+  }
+  pos += scnprintf(pos, endpos - pos, "\n");
+ }
+
+ ret = simple_read_from_buffer(user_buf, count, ppos, buff, pos - buff);
+ kfree(buff);
+ return ret;
+}
+
+static ssize_t rs_sta_dbgfs_drv_tx_stats_write(struct file *file,
+            const char __user *user_buf,
+            size_t count, loff_t *ppos)
+{
+ struct iwl_lq_sta *lq_sta = file->private_data;
+ memset(lq_sta->tx_stats, 0, sizeof(lq_sta->tx_stats));
 
- return simple_read_from_buffer(user_buf, count, ppos, buff, desc);
+ return count;
 }
 
-static const struct file_operations rs_sta_dbgfs_rate_scale_data_ops = {
- .read = rs_sta_dbgfs_rate_scale_data_read,
+static const struct file_operations rs_sta_dbgfs_drv_tx_stats_ops = {
+ .read = rs_sta_dbgfs_drv_tx_stats_read,
+ .write = rs_sta_dbgfs_drv_tx_stats_write,
  .open = simple_open,
  .llseek = default_llseek,
 };
@@ -3028,12 +3188,15 @@ static void rs_add_debugfs(void *mvm, void *mvm_sta, struct dentry *dir)
  lq_sta->rs_sta_dbgfs_stats_table_file =
   debugfs_create_file("rate_stats_table", S_IRUSR, dir,
         lq_sta, &rs_sta_dbgfs_stats_table_ops);
- lq_sta->rs_sta_dbgfs_rate_scale_data_file =
-  debugfs_create_file("rate_scale_data", S_IRUSR, dir,
-        lq_sta, &rs_sta_dbgfs_rate_scale_data_ops);
+ lq_sta->rs_sta_dbgfs_drv_tx_stats_file =
+  debugfs_create_file("drv_tx_stats", S_IRUSR | S_IWUSR, dir,
+        lq_sta, &rs_sta_dbgfs_drv_tx_stats_ops);
  lq_sta->rs_sta_dbgfs_tx_agg_tid_en_file =
   debugfs_create_u8("tx_agg_tid_enable", S_IRUSR | S_IWUSR, dir,
       &lq_sta->tx_agg_tid_en);
+ lq_sta->rs_sta_dbgfs_reduced_txp_file =
+  debugfs_create_u8("reduced_tpc", S_IRUSR | S_IWUSR, dir,
+      &lq_sta->dbg_fixed_txp_reduction);
 }
 
 static void rs_remove_debugfs(void *mvm, void *mvm_sta)
@@ -3041,8 +3204,9 @@ static void rs_remove_debugfs(void *mvm, void *mvm_sta)
  struct iwl_lq_sta *lq_sta = mvm_sta;
  debugfs_remove(lq_sta->rs_sta_dbgfs_scale_table_file);
  debugfs_remove(lq_sta->rs_sta_dbgfs_stats_table_file);
- debugfs_remove(lq_sta->rs_sta_dbgfs_rate_scale_data_file);
+ debugfs_remove(lq_sta->rs_sta_dbgfs_drv_tx_stats_file);
  debugfs_remove(lq_sta->rs_sta_dbgfs_tx_agg_tid_en_file);
+ debugfs_remove(lq_sta->rs_sta_dbgfs_reduced_txp_file);
 }
 #endif
 
@@ -3052,12 +3216,13 @@ static void rs_remove_debugfs(void *mvm, void *mvm_sta)
  * station is added we ignore it.
  */
 static void rs_rate_init_stub(void *mvm_r,
-     struct ieee80211_supported_band *sband,
-     struct ieee80211_sta *sta, void *mvm_sta)
+         struct ieee80211_supported_band *sband,
+         struct cfg80211_chan_def *chandef,
+         struct ieee80211_sta *sta, void *mvm_sta)
 {
 }
-static struct rate_control_ops rs_mvm_ops = {
- .module = NULL,
+
+static const struct rate_control_ops rs_mvm_ops = {
  .name = RS_NAME,
  .tx_status = rs_tx_status,
  .get_rate = rs_get_rate,
@@ -3066,6 +3231,7 @@ static struct rate_control_ops rs_mvm_ops = {
  .free = rs_free,
  .alloc_sta = rs_alloc_sta,
  .free_sta = rs_free_sta,
+ .rate_update = rs_rate_update,
 #ifdef CONFIG_MAC80211_DEBUGFS
  .add_sta_debugfs = rs_add_debugfs,
  .remove_sta_debugfs = rs_remove_debugfs,
@@ -3081,3 +3247,30 @@ void iwl_mvm_rate_control_unregister(void)
 {
  ieee80211_rate_control_unregister(&rs_mvm_ops);
 }
+
+/**
+ * iwl_mvm_tx_protection - Gets LQ command, change it to enable/disable
+ * Tx protection, according to this rquest and previous requests,
+ * and send the LQ command.
+ * @mvmsta: The station
+ * @enable: Enable Tx protection?
+ */
+int iwl_mvm_tx_protection(struct iwl_mvm *mvm, struct iwl_mvm_sta *mvmsta,
+     bool enable)
+{
+ struct iwl_lq_cmd *lq = &mvmsta->lq_sta.lq;
+
+ lockdep_assert_held(&mvm->mutex);
+
+ if (enable) {
+  if (mvmsta->tx_protection == 0)
+   lq->flags |= LQ_FLAG_USE_RTS_MSK;
+  mvmsta->tx_protection++;
+ } else {
+  mvmsta->tx_protection--;
+  if (mvmsta->tx_protection == 0)
+   lq->flags &= ~LQ_FLAG_USE_RTS_MSK;
+ }
+
+ return iwl_mvm_send_lq_cmd(mvm, lq, false);
+}
diff --git a/drivers/net/wireless/iwlwifi/mvm/rs.h b/drivers/net/wireless/iwlwifi/mvm/rs.h
index 219c685..374a83d 100644
--- a/drivers/net/wireless/iwlwifi/mvm/rs.h
+++ b/drivers/net/wireless/iwlwifi/mvm/rs.h
@@ -1,6 +1,6 @@
 /******************************************************************************
  *
- * Copyright(c) 2003 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2003 - 2014 Intel Corporation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
@@ -35,17 +35,13 @@
 #include "iwl-trans.h"
 
 struct iwl_rs_rate_info {
- u8 plcp; /* uCode API:  IWL_RATE_6M_PLCP, etc. */
- u8 plcp_siso; /* uCode API:  IWL_RATE_SISO_6M_PLCP, etc. */
- u8 plcp_mimo2; /* uCode API:  IWL_RATE_MIMO2_6M_PLCP, etc. */
- u8 plcp_mimo3;  /* uCode API:  IWL_RATE_MIMO3_6M_PLCP, etc. */
- u8 ieee; /* MAC header:  IWL_RATE_6M_IEEE, etc. */
- u8 prev_ieee;    /* previous rate in IEEE speeds */
- u8 next_ieee;    /* next rate in IEEE speeds */
+ u8 plcp;   /* uCode API:  IWL_RATE_6M_PLCP, etc. */
+ u8 plcp_ht_siso;  /* uCode API:  IWL_RATE_SISO_6M_PLCP, etc. */
+ u8 plcp_ht_mimo2; /* uCode API:  IWL_RATE_MIMO2_6M_PLCP, etc. */
+ u8 plcp_vht_siso;
+ u8 plcp_vht_mimo2;
  u8 prev_rs;      /* previous rate used in rs algo */
  u8 next_rs;      /* next rate used in rs algo */
- u8 prev_rs_tgg;  /* previous rate used in TGG rs algo */
- u8 next_rs_tgg;  /* next rate used in TGG rs algo */
 };
 
 #define IWL_RATE_60M_PLCP 3
@@ -89,52 +85,52 @@ enum {
 #define IWL_RATE_11M_MASK  (1 << IWL_RATE_11M_INDEX)
 
 
-/* uCode API values for OFDM high-throughput (HT) bit rates */
+/* uCode API values for HT/VHT bit rates */
 enum {
- IWL_RATE_SISO_6M_PLCP = 0,
- IWL_RATE_SISO_12M_PLCP = 1,
- IWL_RATE_SISO_18M_PLCP = 2,
- IWL_RATE_SISO_24M_PLCP = 3,
- IWL_RATE_SISO_36M_PLCP = 4,
- IWL_RATE_SISO_48M_PLCP = 5,
- IWL_RATE_SISO_54M_PLCP = 6,
- IWL_RATE_SISO_60M_PLCP = 7,
- IWL_RATE_MIMO2_6M_PLCP  = 0x8,
- IWL_RATE_MIMO2_12M_PLCP = 0x9,
- IWL_RATE_MIMO2_18M_PLCP = 0xa,
- IWL_RATE_MIMO2_24M_PLCP = 0xb,
- IWL_RATE_MIMO2_36M_PLCP = 0xc,
- IWL_RATE_MIMO2_48M_PLCP = 0xd,
- IWL_RATE_MIMO2_54M_PLCP = 0xe,
- IWL_RATE_MIMO2_60M_PLCP = 0xf,
- IWL_RATE_MIMO3_6M_PLCP  = 0x10,
- IWL_RATE_MIMO3_12M_PLCP = 0x11,
- IWL_RATE_MIMO3_18M_PLCP = 0x12,
- IWL_RATE_MIMO3_24M_PLCP = 0x13,
- IWL_RATE_MIMO3_36M_PLCP = 0x14,
- IWL_RATE_MIMO3_48M_PLCP = 0x15,
- IWL_RATE_MIMO3_54M_PLCP = 0x16,
- IWL_RATE_MIMO3_60M_PLCP = 0x17,
- IWL_RATE_SISO_INVM_PLCP,
- IWL_RATE_MIMO2_INVM_PLCP = IWL_RATE_SISO_INVM_PLCP,
- IWL_RATE_MIMO3_INVM_PLCP = IWL_RATE_SISO_INVM_PLCP,
-};
-
-/* MAC header values for bit rates */
-enum {
- IWL_RATE_6M_IEEE  = 12,
- IWL_RATE_9M_IEEE  = 18,
- IWL_RATE_12M_IEEE = 24,
- IWL_RATE_18M_IEEE = 36,
- IWL_RATE_24M_IEEE = 48,
- IWL_RATE_36M_IEEE = 72,
- IWL_RATE_48M_IEEE = 96,
- IWL_RATE_54M_IEEE = 108,
- IWL_RATE_60M_IEEE = 120,
- IWL_RATE_1M_IEEE  = 2,
- IWL_RATE_2M_IEEE  = 4,
- IWL_RATE_5M_IEEE  = 11,
- IWL_RATE_11M_IEEE = 22,
+ IWL_RATE_HT_SISO_MCS_0_PLCP = 0,
+ IWL_RATE_HT_SISO_MCS_1_PLCP = 1,
+ IWL_RATE_HT_SISO_MCS_2_PLCP = 2,
+ IWL_RATE_HT_SISO_MCS_3_PLCP = 3,
+ IWL_RATE_HT_SISO_MCS_4_PLCP = 4,
+ IWL_RATE_HT_SISO_MCS_5_PLCP = 5,
+ IWL_RATE_HT_SISO_MCS_6_PLCP = 6,
+ IWL_RATE_HT_SISO_MCS_7_PLCP = 7,
+ IWL_RATE_HT_MIMO2_MCS_0_PLCP = 0x8,
+ IWL_RATE_HT_MIMO2_MCS_1_PLCP = 0x9,
+ IWL_RATE_HT_MIMO2_MCS_2_PLCP = 0xA,
+ IWL_RATE_HT_MIMO2_MCS_3_PLCP = 0xB,
+ IWL_RATE_HT_MIMO2_MCS_4_PLCP = 0xC,
+ IWL_RATE_HT_MIMO2_MCS_5_PLCP = 0xD,
+ IWL_RATE_HT_MIMO2_MCS_6_PLCP = 0xE,
+ IWL_RATE_HT_MIMO2_MCS_7_PLCP = 0xF,
+ IWL_RATE_VHT_SISO_MCS_0_PLCP = 0,
+ IWL_RATE_VHT_SISO_MCS_1_PLCP = 1,
+ IWL_RATE_VHT_SISO_MCS_2_PLCP = 2,
+ IWL_RATE_VHT_SISO_MCS_3_PLCP = 3,
+ IWL_RATE_VHT_SISO_MCS_4_PLCP = 4,
+ IWL_RATE_VHT_SISO_MCS_5_PLCP = 5,
+ IWL_RATE_VHT_SISO_MCS_6_PLCP = 6,
+ IWL_RATE_VHT_SISO_MCS_7_PLCP = 7,
+ IWL_RATE_VHT_SISO_MCS_8_PLCP = 8,
+ IWL_RATE_VHT_SISO_MCS_9_PLCP = 9,
+ IWL_RATE_VHT_MIMO2_MCS_0_PLCP = 0x10,
+ IWL_RATE_VHT_MIMO2_MCS_1_PLCP = 0x11,
+ IWL_RATE_VHT_MIMO2_MCS_2_PLCP = 0x12,
+ IWL_RATE_VHT_MIMO2_MCS_3_PLCP = 0x13,
+ IWL_RATE_VHT_MIMO2_MCS_4_PLCP = 0x14,
+ IWL_RATE_VHT_MIMO2_MCS_5_PLCP = 0x15,
+ IWL_RATE_VHT_MIMO2_MCS_6_PLCP = 0x16,
+ IWL_RATE_VHT_MIMO2_MCS_7_PLCP = 0x17,
+ IWL_RATE_VHT_MIMO2_MCS_8_PLCP = 0x18,
+ IWL_RATE_VHT_MIMO2_MCS_9_PLCP = 0x19,
+ IWL_RATE_HT_SISO_MCS_INV_PLCP,
+ IWL_RATE_HT_MIMO2_MCS_INV_PLCP = IWL_RATE_HT_SISO_MCS_INV_PLCP,
+ IWL_RATE_VHT_SISO_MCS_INV_PLCP = IWL_RATE_HT_SISO_MCS_INV_PLCP,
+ IWL_RATE_VHT_MIMO2_MCS_INV_PLCP = IWL_RATE_HT_SISO_MCS_INV_PLCP,
+ IWL_RATE_HT_SISO_MCS_8_PLCP = IWL_RATE_HT_SISO_MCS_INV_PLCP,
+ IWL_RATE_HT_SISO_MCS_9_PLCP = IWL_RATE_HT_SISO_MCS_INV_PLCP,
+ IWL_RATE_HT_MIMO2_MCS_8_PLCP = IWL_RATE_HT_SISO_MCS_INV_PLCP,
+ IWL_RATE_HT_MIMO2_MCS_9_PLCP = IWL_RATE_HT_SISO_MCS_INV_PLCP,
 };
 
 #define IWL_RATES_MASK ((1 << IWL_RATE_COUNT) - 1)
@@ -159,55 +155,15 @@ enum {
 #define IWL_RATE_SCALE_SWITCH  10880 /*  85% */
 #define IWL_RATE_HIGH_TH  10880 /*  85% */
 #define IWL_RATE_INCREASE_TH  6400 /*  50% */
-#define IWL_RATE_DECREASE_TH  1920 /*  15% */
-
-/* possible actions when in legacy mode */
-#define IWL_LEGACY_SWITCH_ANTENNA1      0
-#define IWL_LEGACY_SWITCH_ANTENNA2      1
-#define IWL_LEGACY_SWITCH_SISO          2
-#define IWL_LEGACY_SWITCH_MIMO2_AB      3
-#define IWL_LEGACY_SWITCH_MIMO2_AC      4
-#define IWL_LEGACY_SWITCH_MIMO2_BC      5
-#define IWL_LEGACY_SWITCH_MIMO3_ABC     6
-
-/* possible actions when in siso mode */
-#define IWL_SISO_SWITCH_ANTENNA1        0
-#define IWL_SISO_SWITCH_ANTENNA2        1
-#define IWL_SISO_SWITCH_MIMO2_AB        2
-#define IWL_SISO_SWITCH_MIMO2_AC        3
-#define IWL_SISO_SWITCH_MIMO2_BC        4
-#define IWL_SISO_SWITCH_GI              5
-#define IWL_SISO_SWITCH_MIMO3_ABC       6
-
-
-/* possible actions when in mimo mode */
-#define IWL_MIMO2_SWITCH_ANTENNA1       0
-#define IWL_MIMO2_SWITCH_ANTENNA2       1
-#define IWL_MIMO2_SWITCH_SISO_A         2
-#define IWL_MIMO2_SWITCH_SISO_B         3
-#define IWL_MIMO2_SWITCH_SISO_C         4
-#define IWL_MIMO2_SWITCH_GI             5
-#define IWL_MIMO2_SWITCH_MIMO3_ABC      6
-
-
-/* possible actions when in mimo3 mode */
-#define IWL_MIMO3_SWITCH_ANTENNA1       0
-#define IWL_MIMO3_SWITCH_ANTENNA2       1
-#define IWL_MIMO3_SWITCH_SISO_A         2
-#define IWL_MIMO3_SWITCH_SISO_B         3
-#define IWL_MIMO3_SWITCH_SISO_C         4
-#define IWL_MIMO3_SWITCH_MIMO2_AB       5
-#define IWL_MIMO3_SWITCH_MIMO2_AC       6
-#define IWL_MIMO3_SWITCH_MIMO2_BC       7
-#define IWL_MIMO3_SWITCH_GI             8
-
-
-#define IWL_MAX_11N_MIMO3_SEARCH IWL_MIMO3_SWITCH_GI
-#define IWL_MAX_SEARCH IWL_MIMO2_SWITCH_MIMO3_ABC
-
-/*FIXME:RS:add possible actions for MIMO3*/
-
-#define IWL_ACTION_LIMIT  3 /* # possible actions */
+#define RS_SR_FORCE_DECREASE  1920 /*  15% */
+#define RS_SR_NO_DECREASE  10880 /*  85% */
+
+#define TPC_SR_FORCE_INCREASE  9600 /* 75% */
+#define TPC_SR_NO_INCREASE  10880 /* 85% */
+#define TPC_TX_POWER_STEP  3
+#define TPC_MAX_REDUCTION  15
+#define TPC_NO_REDUCTION  0
+#define TPC_INVALID   0xff
 
 #define LINK_QUAL_AGG_TIME_LIMIT_DEF (4000) /* 4 milliseconds */
 #define LINK_QUAL_AGG_TIME_LIMIT_MAX (8000)
@@ -236,22 +192,54 @@ enum {
 
 enum iwl_table_type {
  LQ_NONE,
- LQ_G,  /* legacy types */
- LQ_A,
- LQ_SISO, /* high-throughput types */
- LQ_MIMO2,
- LQ_MIMO3,
+ LQ_LEGACY_G, /* legacy types */
+ LQ_LEGACY_A,
+ LQ_HT_SISO, /* HT types */
+ LQ_HT_MIMO2,
+ LQ_VHT_SISO,    /* VHT types */
+ LQ_VHT_MIMO2,
  LQ_MAX,
 };
 
-#define is_legacy(tbl) (((tbl) == LQ_G) || ((tbl) == LQ_A))
-#define is_siso(tbl) ((tbl) == LQ_SISO)
-#define is_mimo2(tbl) ((tbl) == LQ_MIMO2)
-#define is_mimo3(tbl) ((tbl) == LQ_MIMO3)
-#define is_mimo(tbl) (is_mimo2(tbl) || is_mimo3(tbl))
-#define is_Ht(tbl) (is_siso(tbl) || is_mimo(tbl))
-#define is_a_band(tbl) ((tbl) == LQ_A)
-#define is_g_and(tbl) ((tbl) == LQ_G)
+struct rs_rate {
+ int index;
+ enum iwl_table_type type;
+ u8 ant;
+ u32 bw;
+ bool sgi;
+};
+
+
+#define is_type_legacy(type) (((type) == LQ_LEGACY_G) || \
+         ((type) == LQ_LEGACY_A))
+#define is_type_ht_siso(type) ((type) == LQ_HT_SISO)
+#define is_type_ht_mimo2(type) ((type) == LQ_HT_MIMO2)
+#define is_type_vht_siso(type) ((type) == LQ_VHT_SISO)
+#define is_type_vht_mimo2(type) ((type) == LQ_VHT_MIMO2)
+#define is_type_siso(type) (is_type_ht_siso(type) || is_type_vht_siso(type))
+#define is_type_mimo2(type) (is_type_ht_mimo2(type) || is_type_vht_mimo2(type))
+#define is_type_mimo(type) (is_type_mimo2(type))
+#define is_type_ht(type) (is_type_ht_siso(type) || is_type_ht_mimo2(type))
+#define is_type_vht(type) (is_type_vht_siso(type) || is_type_vht_mimo2(type))
+#define is_type_a_band(type) ((type) == LQ_LEGACY_A)
+#define is_type_g_band(type) ((type) == LQ_LEGACY_G)
+
+#define is_legacy(rate)       is_type_legacy((rate)->type)
+#define is_ht_siso(rate)      is_type_ht_siso((rate)->type)
+#define is_ht_mimo2(rate)     is_type_ht_mimo2((rate)->type)
+#define is_vht_siso(rate)     is_type_vht_siso((rate)->type)
+#define is_vht_mimo2(rate)    is_type_vht_mimo2((rate)->type)
+#define is_siso(rate)         is_type_siso((rate)->type)
+#define is_mimo2(rate)        is_type_mimo2((rate)->type)
+#define is_mimo(rate)         is_type_mimo((rate)->type)
+#define is_ht(rate)           is_type_ht((rate)->type)
+#define is_vht(rate)          is_type_vht((rate)->type)
+#define is_a_band(rate)       is_type_a_band((rate)->type)
+#define is_g_band(rate)       is_type_g_band((rate)->type)
+
+#define is_ht20(rate)         ((rate)->bw == RATE_MCS_CHAN_WIDTH_20)
+#define is_ht40(rate)         ((rate)->bw == RATE_MCS_CHAN_WIDTH_40)
+#define is_ht80(rate)         ((rate)->bw == RATE_MCS_CHAN_WIDTH_80)
 
 #define IWL_MAX_MCS_DISPLAY_SIZE 12
 
@@ -269,7 +257,30 @@ struct iwl_rate_scale_data {
  s32 success_ratio; /* per-cent * 128  */
  s32 counter;  /* number of frames attempted */
  s32 average_tpt; /* success ratio * expected throughput */
- unsigned long stamp;
+};
+
+/* Possible Tx columns
+ * Tx Column = a combo of legacy/siso/mimo x antenna x SGI
+ */
+enum rs_column {
+ RS_COLUMN_LEGACY_ANT_A = 0,
+ RS_COLUMN_LEGACY_ANT_B,
+ RS_COLUMN_SISO_ANT_A,
+ RS_COLUMN_SISO_ANT_B,
+ RS_COLUMN_SISO_ANT_A_SGI,
+ RS_COLUMN_SISO_ANT_B_SGI,
+ RS_COLUMN_MIMO2,
+ RS_COLUMN_MIMO2_SGI,
+
+ RS_COLUMN_LAST = RS_COLUMN_MIMO2_SGI,
+ RS_COLUMN_COUNT = RS_COLUMN_LAST + 1,
+ RS_COLUMN_INVALID,
+};
+
+/* Packet stats per rate */
+struct rs_rate_stats {
+ u64 success;
+ u64 total;
 };
 
 /**
@@ -279,26 +290,18 @@ struct iwl_rate_scale_data {
  * one for "active", and one for "search".
  */
 struct iwl_scale_tbl_info {
- enum iwl_table_type lq_type;
- u8 ant_type;
- u8 is_SGI; /* 1 = short guard interval */
- u8 is_ht40; /* 1 = 40 MHz channel width */
- u8 action; /* change modulation; IWL_[LEGACY/SISO/MIMO]_SWITCH_* */
- u8 max_search; /* maximun number of tables we can search */
- s32 *expected_tpt; /* throughput metrics; expected_tpt_G, etc. */
- u32 current_rate;  /* rate_n_flags, uCode API format */
+ struct rs_rate rate;
+ enum rs_column column;
+ const u16 *expected_tpt; /* throughput metrics; expected_tpt_G, etc. */
  struct iwl_rate_scale_data win[IWL_RATE_COUNT]; /* rate histories */
+ /* per txpower-reduction history */
+ struct iwl_rate_scale_data tpc_win[TPC_MAX_REDUCTION + 1];
 };
 
-struct iwl_traffic_load {
- unsigned long time_stamp; /* age of the oldest statistics */
- u32 packet_count[TID_QUEUE_MAX_SIZE];   /* packet count in this time
-       * slice */
- u32 total;   /* total num of packets during the
-      * last TID_MAX_TIME_DIFF */
- u8 queue_count;   /* number of queues that has
-      * been used since the last cleanup */
- u8 head;   /* start of the circular buffer */
+enum {
+ RS_STATE_SEARCH_CYCLE_STARTED,
+ RS_STATE_SEARCH_CYCLE_ENDED,
+ RS_STATE_STAY_IN_COLUMN,
 };
 
 /**
@@ -308,8 +311,7 @@ struct iwl_traffic_load {
  */
 struct iwl_lq_sta {
  u8 active_tbl;  /* index of active table, range 0-1 */
- u8 enable_counter; /* indicates HT mode */
- u8 stay_in_tbl;  /* 1: disallow, 0: allow search for new mode */
+ u8 rs_state;            /* RS_STATE_* */
  u8 search_better_tbl; /* 1: currently trying alternate mode */
  s32 last_tpt;
 
@@ -322,29 +324,39 @@ struct iwl_lq_sta {
  u32 total_success; /* total successful frames, any/all rates */
  u64 flush_timer; /* time staying in mode before new search */
 
- u8 action_counter; /* # mode-switch actions tried */
- u8 is_green;
+ u32 visited_columns;    /* Bitmask marking which Tx columns were
+     * explored during a search cycle
+     */
+ u64 last_tx;
+ bool is_vht;
  enum ieee80211_band band;
 
+ struct rs_rate_stats tx_stats[RS_COLUMN_COUNT][IWL_RATE_COUNT];
+
  /* The following are bitmaps of rates; IWL_RATE_6M_MASK, etc. */
- u32 supp_rates;
- u16 active_legacy_rate;
- u16 active_siso_rate;
- u16 active_mimo2_rate;
- u16 active_mimo3_rate;
+ unsigned long active_legacy_rate;
+ unsigned long active_siso_rate;
+ unsigned long active_mimo2_rate;
+
+ /* Highest rate per Tx mode */
+ u8 max_legacy_rate_idx;
+ u8 max_siso_rate_idx;
+ u8 max_mimo2_rate_idx;
+
  s8 max_rate_idx;     /* Max rate set by user */
  u8 missed_rate_counter;
 
  struct iwl_lq_cmd lq;
  struct iwl_scale_tbl_info lq_info[LQ_SIZE]; /* "active", "search" */
- struct iwl_traffic_load load[IWL_MAX_TID_COUNT];
  u8 tx_agg_tid_en;
 #ifdef CONFIG_MAC80211_DEBUGFS
  struct dentry *rs_sta_dbgfs_scale_table_file;
  struct dentry *rs_sta_dbgfs_stats_table_file;
- struct dentry *rs_sta_dbgfs_rate_scale_data_file;
+ struct dentry *rs_sta_dbgfs_drv_tx_stats_file;
  struct dentry *rs_sta_dbgfs_tx_agg_tid_en_file;
+ struct dentry *rs_sta_dbgfs_reduced_txp_file;
  u32 dbg_fixed_rate;
+ u8 dbg_fixed_txp_reduction;
 #endif
  struct iwl_mvm *drv;
 
@@ -354,21 +366,14 @@ struct iwl_lq_sta {
  u32 last_rate_n_flags;
  /* packets destined for this STA are aggregated */
  u8 is_agg;
- /* BT traffic this sta was last updated in */
- u8 last_bt_traffic;
-};
 
-static inline u8 num_of_ant(u8 mask)
-{
- return  !!((mask) & ANT_A) +
-  !!((mask) & ANT_B) +
-  !!((mask) & ANT_C);
-}
+ /* tx power reduce for this sta */
+ int tpc_reduce;
+};
 
 /* Initialize station's rate scaling information after adding station */
-extern void iwl_mvm_rs_rate_init(struct iwl_mvm *mvm,
-     struct ieee80211_sta *sta,
-     enum ieee80211_band band);
+void iwl_mvm_rs_rate_init(struct iwl_mvm *mvm, struct ieee80211_sta *sta,
+     enum ieee80211_band band, bool init);
 
 /**
  * iwl_rate_control_register - Register the rate control algorithm callbacks
@@ -380,7 +385,7 @@ extern void iwl_mvm_rs_rate_init(struct iwl_mvm *mvm,
  * ieee80211_register_hw
  *
  */
-extern int iwl_mvm_rate_control_register(void);
+int iwl_mvm_rate_control_register(void);
 
 /**
  * iwl_rate_control_unregister - Unregister the rate control callbacks
@@ -388,6 +393,11 @@ extern int iwl_mvm_rate_control_register(void);
  * This should be called after calling ieee80211_unregister_hw, but before
  * the driver is unloaded.
  */
-extern void iwl_mvm_rate_control_unregister(void);
+void iwl_mvm_rate_control_unregister(void);
+
+struct iwl_mvm_sta;
+
+int iwl_mvm_tx_protection(struct iwl_mvm *mvm, struct iwl_mvm_sta *mvmsta,
+     bool enable);
 
 #endif /* __rs__ */
diff --git a/drivers/net/wireless/iwlwifi/mvm/rx.c b/drivers/net/wireless/iwlwifi/mvm/rx.c
index 4dfc21a..cf72769 100644
--- a/drivers/net/wireless/iwlwifi/mvm/rx.c
+++ b/drivers/net/wireless/iwlwifi/mvm/rx.c
@@ -5,7 +5,7 @@
  *
  * GPL LICENSE SUMMARY
  *
- * Copyright(c) 2012 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2012 - 2014 Intel Corporation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of version 2 of the GNU General Public License as
@@ -30,7 +30,7 @@
  *
  * BSD LICENSE
  *
- * Copyright(c) 2012 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2012 - 2014 Intel Corporation. All rights reserved.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -60,7 +60,6 @@
  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  *****************************************************************************/
 #include "iwl-trans.h"
-
 #include "mvm.h"
 #include "fw-api.h"
 
@@ -77,6 +76,15 @@ int iwl_mvm_rx_rx_phy_cmd(struct iwl_mvm *mvm, struct iwl_rx_cmd_buffer *rxb,
 
  memcpy(&mvm->last_phy_info, pkt->data, sizeof(mvm->last_phy_info));
  mvm->ampdu_ref++;
+
+#ifdef CONFIG_IWLWIFI_DEBUGFS
+ if (mvm->last_phy_info.phy_flags & cpu_to_le16(RX_RES_PHY_FLAGS_AGG)) {
+  spin_lock(&mvm->drv_stats_lock);
+  mvm->drv_rx_stats.ampdu_count++;
+  spin_unlock(&mvm->drv_stats_lock);
+ }
+#endif
+
  return 0;
 }
 
@@ -121,52 +129,46 @@ static void iwl_mvm_pass_packet_to_mac80211(struct iwl_mvm *mvm,
 
  memcpy(IEEE80211_SKB_RXCB(skb), stats, sizeof(*stats));
 
- ieee80211_rx_ni(mvm->hw, skb);
+ ieee80211_rx(mvm->hw, skb);
 }
 
 /*
- * iwl_mvm_calc_rssi - calculate the rssi in dBm
- * @phy_info: the phy information for the coming packet
+ * iwl_mvm_get_signal_strength - use new rx PHY INFO API
+ * values are reported by the fw as positive values - need to negate
+ * to obtain their dBM.  Account for missing antennas by replacing 0
+ * values by -256dBm: practically 0 power and a non-feasible 8 bit value.
  */
-static int iwl_mvm_calc_rssi(struct iwl_mvm *mvm,
-        struct iwl_rx_phy_info *phy_info)
+static void iwl_mvm_get_signal_strength(struct iwl_mvm *mvm,
+     struct iwl_rx_phy_info *phy_info,
+     struct ieee80211_rx_status *rx_status)
 {
- int rssi_a, rssi_b, rssi_a_dbm, rssi_b_dbm, max_rssi_dbm;
- int rssi_all_band_a, rssi_all_band_b;
- u32 agc_a, agc_b, max_agc;
+ int energy_a, energy_b, energy_c, max_energy;
  u32 val;
 
- /* Find max rssi among 2 possible receivers.
-  * These values are measured by the Digital Signal Processor (DSP).
-  * They should stay fairly constant even as the signal strength varies,
-  * if the radio's Automatic Gain Control (AGC) is working right.
-  * AGC value (see below) will provide the "interesting" info.
-  */
- val = le32_to_cpu(phy_info->non_cfg_phy[IWL_RX_INFO_AGC_IDX]);
- agc_a = (val & IWL_OFDM_AGC_A_MSK) >> IWL_OFDM_AGC_A_POS;
- agc_b = (val & IWL_OFDM_AGC_B_MSK) >> IWL_OFDM_AGC_B_POS;
- max_agc = max_t(u32, agc_a, agc_b);
-
- val = le32_to_cpu(phy_info->non_cfg_phy[IWL_RX_INFO_RSSI_AB_IDX]);
- rssi_a = (val & IWL_OFDM_RSSI_INBAND_A_MSK) >> IWL_OFDM_RSSI_A_POS;
- rssi_b = (val & IWL_OFDM_RSSI_INBAND_B_MSK) >> IWL_OFDM_RSSI_B_POS;
- rssi_all_band_a = (val & IWL_OFDM_RSSI_ALLBAND_A_MSK) >>
-    IWL_OFDM_RSSI_ALLBAND_A_POS;
- rssi_all_band_b = (val & IWL_OFDM_RSSI_ALLBAND_B_MSK) >>
-    IWL_OFDM_RSSI_ALLBAND_B_POS;
-
- /*
-  * dBm = rssi dB - agc dB - constant.
-  * Higher AGC (higher radio gain) means lower signal.
-  */
- rssi_a_dbm = rssi_a - IWL_RSSI_OFFSET - agc_a;
- rssi_b_dbm = rssi_b - IWL_RSSI_OFFSET - agc_b;
- max_rssi_dbm = max_t(int, rssi_a_dbm, rssi_b_dbm);
-
- IWL_DEBUG_STATS(mvm, "Rssi In A %d B %d Max %d AGCA %d AGCB %d\n",
-   rssi_a_dbm, rssi_b_dbm, max_rssi_dbm, agc_a, agc_b);
-
- return max_rssi_dbm;
+ val =
+     le32_to_cpu(phy_info->non_cfg_phy[IWL_RX_INFO_ENERGY_ANT_ABC_IDX]);
+ energy_a = (val & IWL_RX_INFO_ENERGY_ANT_A_MSK) >>
+      IWL_RX_INFO_ENERGY_ANT_A_POS;
+ energy_a = energy_a ? -energy_a : -256;
+ energy_b = (val & IWL_RX_INFO_ENERGY_ANT_B_MSK) >>
+      IWL_RX_INFO_ENERGY_ANT_B_POS;
+ energy_b = energy_b ? -energy_b : -256;
+ energy_c = (val & IWL_RX_INFO_ENERGY_ANT_C_MSK) >>
+      IWL_RX_INFO_ENERGY_ANT_C_POS;
+ energy_c = energy_c ? -energy_c : -256;
+ max_energy = max(energy_a, energy_b);
+ max_energy = max(max_energy, energy_c);
+
+ IWL_DEBUG_STATS(mvm, "energy In A %d B %d C %d , and max %d\n",
+   energy_a, energy_b, energy_c, max_energy);
+
+ rx_status->signal = max_energy;
+ rx_status->chains = (le16_to_cpu(phy_info->phy_flags) &
+    RX_RES_PHY_FLAGS_ANTENNA)
+     >> RX_RES_PHY_FLAGS_ANTENNA_POS;
+ rx_status->chain_signal[0] = energy_a;
+ rx_status->chain_signal[1] = energy_b;
+ rx_status->chain_signal[2] = energy_c;
 }
 
 /*
@@ -216,6 +218,12 @@ static u32 iwl_mvm_set_mac80211_rx_flag(struct iwl_mvm *mvm,
   stats->flag |= RX_FLAG_DECRYPTED;
   return 0;
 
+ case RX_MPDU_RES_STATUS_SEC_EXT_ENC:
+  if (!(rx_pkt_status & RX_MPDU_RES_STATUS_MIC_OK))
+   return -1;
+  stats->flag |= RX_FLAG_DECRYPTED;
+  return 0;
+
  default:
   IWL_ERR(mvm, "Unhandled alg: 0x%x\n", rx_pkt_status);
  }
@@ -265,10 +273,14 @@ int iwl_mvm_rx_rx_mpdu(struct iwl_mvm *mvm, struct iwl_rx_cmd_buffer *rxb,
   return 0;
  }
 
+ /*
+  * Keep packets with CRC errors (and with overrun) for monitor mode
+  * (otherwise the firmware discards them) but mark them as bad.
+  */
  if (!(rx_pkt_status & RX_MPDU_RES_STATUS_CRC_OK) ||
      !(rx_pkt_status & RX_MPDU_RES_STATUS_OVERRUN_OK)) {
   IWL_DEBUG_RX(mvm, "Bad CRC or FIFO: 0x%08X.\n", rx_pkt_status);
-  return 0;
+  rx_status.flag |= RX_FLAG_FAILED_FCS_CRC;
  }
 
  /* This will be used in several places later */
@@ -289,29 +301,11 @@ int iwl_mvm_rx_rx_mpdu(struct iwl_mvm *mvm, struct iwl_rx_cmd_buffer *rxb,
   */
  /*rx_status.flag |= RX_FLAG_MACTIME_MPDU;*/
 
- /* Find max signal strength (dBm) among 3 antenna/receiver chains */
- rx_status.signal = iwl_mvm_calc_rssi(mvm, phy_info);
+ iwl_mvm_get_signal_strength(mvm, phy_info, &rx_status);
 
  IWL_DEBUG_STATS_LIMIT(mvm, "Rssi %d, TSF %llu\n", rx_status.signal,
          (unsigned long long)rx_status.mactime);
 
- /*
-  * "antenna number"
-  *
-  * It seems that the antenna field in the phy flags value
-  * is actually a bit field. This is undefined by radiotap,
-  * it wants an actual antenna number but I always get "7"
-  * for most legacy frames I receive indicating that the
-  * same frame was received on all three RX chains.
-  *
-  * I think this field should be removed in favor of a
-  * new 802.11n radiotap field "RX chains" that is defined
-  * as a bitmask.
-  */
- rx_status.antenna = (le16_to_cpu(phy_info->phy_flags) &
-    RX_RES_PHY_FLAGS_ANTENNA)
-    >> RX_RES_PHY_FLAGS_ANTENNA_POS;
-
  /* set the preamble flag if appropriate */
  if (phy_info->phy_flags & cpu_to_le16(RX_RES_PHY_FLAGS_SHORT_PREAMBLE))
   rx_status.flag |= RX_FLAG_SHORTPRE;
@@ -334,32 +328,161 @@ int iwl_mvm_rx_rx_mpdu(struct iwl_mvm *mvm, struct iwl_rx_cmd_buffer *rxb,
   rx_status.flag |= RX_FLAG_40MHZ;
   break;
  case RATE_MCS_CHAN_WIDTH_80:
-  rx_status.flag |= RX_FLAG_80MHZ;
+  rx_status.vht_flag |= RX_VHT_FLAG_80MHZ;
   break;
  case RATE_MCS_CHAN_WIDTH_160:
-  rx_status.flag |= RX_FLAG_160MHZ;
+  rx_status.vht_flag |= RX_VHT_FLAG_160MHZ;
   break;
  }
  if (rate_n_flags & RATE_MCS_SGI_MSK)
   rx_status.flag |= RX_FLAG_SHORT_GI;
  if (rate_n_flags & RATE_HT_MCS_GF_MSK)
   rx_status.flag |= RX_FLAG_HT_GF;
+ if (rate_n_flags & RATE_MCS_LDPC_MSK)
+  rx_status.flag |= RX_FLAG_LDPC;
  if (rate_n_flags & RATE_MCS_HT_MSK) {
+  u8 stbc = (rate_n_flags & RATE_MCS_HT_STBC_MSK) >>
+    RATE_MCS_STBC_POS;
   rx_status.flag |= RX_FLAG_HT;
   rx_status.rate_idx = rate_n_flags & RATE_HT_MCS_INDEX_MSK;
+  rx_status.flag |= stbc << RX_FLAG_STBC_SHIFT;
  } else if (rate_n_flags & RATE_MCS_VHT_MSK) {
+  u8 stbc = (rate_n_flags & RATE_MCS_VHT_STBC_MSK) >>
+    RATE_MCS_STBC_POS;
   rx_status.vht_nss =
    ((rate_n_flags & RATE_VHT_MCS_NSS_MSK) >>
       RATE_VHT_MCS_NSS_POS) + 1;
   rx_status.rate_idx = rate_n_flags & RATE_VHT_MCS_RATE_CODE_MSK;
   rx_status.flag |= RX_FLAG_VHT;
+  rx_status.flag |= stbc << RX_FLAG_STBC_SHIFT;
+  if (rate_n_flags & RATE_MCS_BF_MSK)
+   rx_status.vht_flag |= RX_VHT_FLAG_BF;
  } else {
   rx_status.rate_idx =
    iwl_mvm_legacy_rate_to_mac80211_idx(rate_n_flags,
            rx_status.band);
  }
 
+#ifdef CONFIG_IWLWIFI_DEBUGFS
+ iwl_mvm_update_frame_stats(mvm, &mvm->drv_rx_stats, rate_n_flags,
+       rx_status.flag & RX_FLAG_AMPDU_DETAILS);
+#endif
  iwl_mvm_pass_packet_to_mac80211(mvm, hdr, len, ampdu_status,
      rxb, &rx_status);
  return 0;
 }
+
+static void iwl_mvm_update_rx_statistics(struct iwl_mvm *mvm,
+      struct iwl_notif_statistics *stats)
+{
+ /*
+  * NOTE FW aggregates the statistics - BUT the statistics are cleared
+  * when the driver issues REPLY_STATISTICS_CMD 0x9c with CLEAR_STATS
+  * bit set.
+  */
+ lockdep_assert_held(&mvm->mutex);
+ memcpy(&mvm->rx_stats, &stats->rx, sizeof(struct mvm_statistics_rx));
+}
+
+struct iwl_mvm_stat_data {
+ struct iwl_notif_statistics *stats;
+ struct iwl_mvm *mvm;
+};
+
+static void iwl_mvm_stat_iterator(void *_data, u8 *mac,
+      struct ieee80211_vif *vif)
+{
+ struct iwl_mvm_stat_data *data = _data;
+ struct iwl_notif_statistics *stats = data->stats;
+ struct iwl_mvm *mvm = data->mvm;
+ int sig = -stats->general.beacon_filter_average_energy;
+ int last_event;
+ int thold = vif->bss_conf.cqm_rssi_thold;
+ int hyst = vif->bss_conf.cqm_rssi_hyst;
+ u16 id = le32_to_cpu(stats->rx.general.mac_id);
+ struct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);
+
+ if (mvmvif->id != id)
+  return;
+
+ if (vif->type != NL80211_IFTYPE_STATION)
+  return;
+
+ mvmvif->bf_data.ave_beacon_signal = sig;
+
+ /* BT Coex */
+ if (mvmvif->bf_data.bt_coex_min_thold !=
+     mvmvif->bf_data.bt_coex_max_thold) {
+  last_event = mvmvif->bf_data.last_bt_coex_event;
+  if (sig > mvmvif->bf_data.bt_coex_max_thold &&
+      (last_event <= mvmvif->bf_data.bt_coex_min_thold ||
+       last_event == 0)) {
+   mvmvif->bf_data.last_bt_coex_event = sig;
+   IWL_DEBUG_RX(mvm, "cqm_iterator bt coex high %d\n",
+         sig);
+   iwl_mvm_bt_rssi_event(mvm, vif, RSSI_EVENT_HIGH);
+  } else if (sig < mvmvif->bf_data.bt_coex_min_thold &&
+      (last_event >= mvmvif->bf_data.bt_coex_max_thold ||
+       last_event == 0)) {
+   mvmvif->bf_data.last_bt_coex_event = sig;
+   IWL_DEBUG_RX(mvm, "cqm_iterator bt coex low %d\n",
+         sig);
+   iwl_mvm_bt_rssi_event(mvm, vif, RSSI_EVENT_LOW);
+  }
+ }
+
+ if (!(vif->driver_flags & IEEE80211_VIF_SUPPORTS_CQM_RSSI))
+  return;
+
+ /* CQM Notification */
+ last_event = mvmvif->bf_data.last_cqm_event;
+ if (thold && sig < thold && (last_event == 0 ||
+         sig < last_event - hyst)) {
+  mvmvif->bf_data.last_cqm_event = sig;
+  IWL_DEBUG_RX(mvm, "cqm_iterator cqm low %d\n",
+        sig);
+  ieee80211_cqm_rssi_notify(
+   vif,
+   NL80211_CQM_RSSI_THRESHOLD_EVENT_LOW,
+   GFP_KERNEL);
+ } else if (sig > thold &&
+     (last_event == 0 || sig > last_event + hyst)) {
+  mvmvif->bf_data.last_cqm_event = sig;
+  IWL_DEBUG_RX(mvm, "cqm_iterator cqm high %d\n",
+        sig);
+  ieee80211_cqm_rssi_notify(
+   vif,
+   NL80211_CQM_RSSI_THRESHOLD_EVENT_HIGH,
+   GFP_KERNEL);
+ }
+}
+
+/*
+ * iwl_mvm_rx_statistics - STATISTICS_NOTIFICATION handler
+ *
+ * TODO: This handler is implemented partially.
+ */
+int iwl_mvm_rx_statistics(struct iwl_mvm *mvm,
+     struct iwl_rx_cmd_buffer *rxb,
+     struct iwl_device_cmd *cmd)
+{
+ struct iwl_rx_packet *pkt = rxb_addr(rxb);
+ struct iwl_notif_statistics *stats = (void *)&pkt->data;
+ struct mvm_statistics_general_common *common = &stats->general.common;
+ struct iwl_mvm_stat_data data = {
+  .stats = stats,
+  .mvm = mvm,
+ };
+
+ if (mvm->temperature != le32_to_cpu(common->temperature)) {
+  mvm->temperature = le32_to_cpu(common->temperature);
+  iwl_mvm_tt_handler(mvm);
+ }
+ iwl_mvm_update_rx_statistics(mvm, stats);
+
+ ieee80211_iterate_active_interfaces(mvm->hw,
+         IEEE80211_IFACE_ITER_NORMAL,
+         iwl_mvm_stat_iterator,
+         &data);
+ return 0;
+}
diff --git a/drivers/net/wireless/iwlwifi/mvm/scan.c b/drivers/net/wireless/iwlwifi/mvm/scan.c
index 8e1f6c0..eac2b42 100644
--- a/drivers/net/wireless/iwlwifi/mvm/scan.c
+++ b/drivers/net/wireless/iwlwifi/mvm/scan.c
@@ -5,7 +5,7 @@
  *
  * GPL LICENSE SUMMARY
  *
- * Copyright(c) 2012 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2012 - 2014 Intel Corporation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of version 2 of the GNU General Public License as
@@ -30,7 +30,7 @@
  *
  * BSD LICENSE
  *
- * Copyright(c) 2012 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2012 - 2014 Intel Corporation. All rights reserved.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -71,11 +71,25 @@
 #define IWL_PLCP_QUIET_THRESH 1
 #define IWL_ACTIVE_QUIET_TIME 10
 
+struct iwl_mvm_scan_params {
+ u32 max_out_time;
+ u32 suspend_time;
+ bool passive_fragmented;
+ struct _dwell {
+  u16 passive;
+  u16 active;
+ } dwell[IEEE80211_NUM_BANDS];
+};
+
 static inline __le16 iwl_mvm_scan_rx_chain(struct iwl_mvm *mvm)
 {
  u16 rx_chain;
- u8 rx_ant = iwl_fw_valid_rx_ant(mvm->fw);
+ u8 rx_ant;
 
+ if (mvm->scan_rx_ant != ANT_NONE)
+  rx_ant = mvm->scan_rx_ant;
+ else
+  rx_ant = mvm->fw->valid_rx_ant;
  rx_chain = rx_ant << PHY_RX_CHAIN_VALID_POS;
  rx_chain |= rx_ant << PHY_RX_CHAIN_FORCE_MIMO_SEL_POS;
  rx_chain |= rx_ant << PHY_RX_CHAIN_FORCE_SEL_POS;
@@ -83,22 +97,6 @@ static inline __le16 iwl_mvm_scan_rx_chain(struct iwl_mvm *mvm)
  return cpu_to_le16(rx_chain);
 }
 
-static inline __le32 iwl_mvm_scan_max_out_time(struct ieee80211_vif *vif)
-{
- if (vif->bss_conf.assoc)
-  return cpu_to_le32(200 * 1024);
- else
-  return 0;
-}
-
-static inline __le32 iwl_mvm_scan_suspend_time(struct ieee80211_vif *vif)
-{
- if (vif->bss_conf.assoc)
-  return cpu_to_le32(vif->bss_conf.beacon_int);
- else
-  return 0;
-}
-
 static inline __le32
 iwl_mvm_scan_rxon_flags(struct cfg80211_scan_request *req)
 {
@@ -115,7 +113,7 @@ iwl_mvm_scan_rate_n_flags(struct iwl_mvm *mvm, enum ieee80211_band band,
  u32 tx_ant;
 
  mvm->scan_last_antenna_idx =
-  iwl_mvm_next_antenna(mvm, iwl_fw_valid_tx_ant(mvm->fw),
+  iwl_mvm_next_antenna(mvm, mvm->fw->valid_tx_ant,
          mvm->scan_last_antenna_idx);
  tx_ant = BIT(mvm->scan_last_antenna_idx) << RATE_MCS_ANT_POS;
 
@@ -133,11 +131,12 @@ iwl_mvm_scan_rate_n_flags(struct iwl_mvm *mvm, enum ieee80211_band band,
  * request.
  */
 static void iwl_mvm_scan_fill_ssids(struct iwl_scan_cmd *cmd,
-        struct cfg80211_scan_request *req)
+        struct cfg80211_scan_request *req,
+        int first)
 {
  int fw_idx, req_idx;
 
- for (req_idx = req->n_ssids - 1, fw_idx = 0; req_idx > 0;
+ for (req_idx = req->n_ssids - 1, fw_idx = 0; req_idx >= first;
       req_idx--, fw_idx++) {
   cmd->direct_scan[fw_idx].id = WLAN_EID_SSID;
   cmd->direct_scan[fw_idx].len = req->ssids[req_idx].ssid_len;
@@ -153,7 +152,9 @@ static void iwl_mvm_scan_fill_ssids(struct iwl_scan_cmd *cmd,
  * just to notify that this scan is active and not passive.
  * In order to notify the FW of the number of SSIDs we wish to scan (including
  * the zero-length one), we need to set the corresponding bits in chan->type,
- * one for each SSID, and set the active bit (first).
+ * one for each SSID, and set the active bit (first). If the first SSID is
+ * already included in the probe template, so we need to set only
+ * req->n_ssids - 1 bits in addition to the first bit.
  */
 static u16 iwl_mvm_get_active_dwell(enum ieee80211_band band, int n_ssids)
 {
@@ -168,22 +169,26 @@ static u16 iwl_mvm_get_passive_dwell(enum ieee80211_band band)
 }
 
 static void iwl_mvm_scan_fill_channels(struct iwl_scan_cmd *cmd,
-           struct cfg80211_scan_request *req)
+           struct cfg80211_scan_request *req,
+           bool basic_ssid,
+           struct iwl_mvm_scan_params *params)
 {
- u16 passive_dwell = iwl_mvm_get_passive_dwell(req->channels[0]->band);
- u16 active_dwell = iwl_mvm_get_active_dwell(req->channels[0]->band,
-          req->n_ssids);
  struct iwl_scan_channel *chan = (struct iwl_scan_channel *)
   (cmd->data + le16_to_cpu(cmd->tx_cmd.len));
  int i;
+ int type = BIT(req->n_ssids) - 1;
+ enum ieee80211_band band = req->channels[0]->band;
+
+ if (!basic_ssid)
+  type |= BIT(req->n_ssids);
 
  for (i = 0; i < cmd->channel_count; i++) {
   chan->channel = cpu_to_le16(req->channels[i]->hw_value);
-  chan->type = cpu_to_le32(BIT(req->n_ssids) - 1);
-  if (req->channels[i]->flags & IEEE80211_CHAN_PASSIVE_SCAN)
+  chan->type = cpu_to_le32(type);
+  if (req->channels[i]->flags & IEEE80211_CHAN_NO_IR)
    chan->type &= cpu_to_le32(~SCAN_CHANNEL_TYPE_ACTIVE);
-  chan->active_dwell = cpu_to_le16(active_dwell);
-  chan->passive_dwell = cpu_to_le16(passive_dwell);
+  chan->active_dwell = cpu_to_le16(params->dwell[band].active);
+  chan->passive_dwell = cpu_to_le16(params->dwell[band].passive);
   chan->iteration_count = cpu_to_le16(1);
   chan++;
  }
@@ -250,6 +255,49 @@ static u16 iwl_mvm_fill_probe_req(struct ieee80211_mgmt *frame, const u8 *ta,
  return (u16)len;
 }
 
+static void iwl_mvm_scan_condition_iterator(void *data, u8 *mac,
+         struct ieee80211_vif *vif)
+{
+ struct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);
+ bool *global_bound = data;
+
+ if (mvmvif->phy_ctxt && mvmvif->phy_ctxt->id < MAX_PHYS)
+  *global_bound = true;
+}
+
+static void iwl_mvm_scan_calc_params(struct iwl_mvm *mvm,
+         struct ieee80211_vif *vif,
+         int n_ssids,
+         struct iwl_mvm_scan_params *params)
+{
+ bool global_bound = false;
+ enum ieee80211_band band;
+
+ ieee80211_iterate_active_interfaces_atomic(mvm->hw,
+         IEEE80211_IFACE_ITER_NORMAL,
+         iwl_mvm_scan_condition_iterator,
+         &global_bound);
+
+ if (!global_bound)
+  goto not_bound;
+
+ params->suspend_time = 100;
+ params->max_out_time = 600;
+
+ if (iwl_mvm_low_latency(mvm)) {
+  params->suspend_time = 250;
+  params->max_out_time = 250;
+ }
+
+not_bound:
+
+ for (band = IEEE80211_BAND_2GHZ; band < IEEE80211_NUM_BANDS; band++) {
+  params->dwell[band].passive = iwl_mvm_get_passive_dwell(band);
+  params->dwell[band].active = iwl_mvm_get_active_dwell(band,
+              n_ssids);
+ }
+}
+
 int iwl_mvm_scan_request(struct iwl_mvm *mvm,
     struct ieee80211_vif *vif,
     struct cfg80211_scan_request *req)
@@ -258,7 +306,6 @@ int iwl_mvm_scan_request(struct iwl_mvm *mvm,
   .id = SCAN_REQUEST_CMD,
   .len = { 0, },
   .data = { mvm->scan_cmd, },
-  .flags = CMD_SYNC,
   .dataflags = { IWL_HCMD_DFL_NOCOPY, },
  };
  struct iwl_scan_cmd *cmd = mvm->scan_cmd;
@@ -266,9 +313,15 @@ int iwl_mvm_scan_request(struct iwl_mvm *mvm,
  u32 status;
  int ssid_len = 0;
  u8 *ssid = NULL;
+ bool basic_ssid = !(mvm->fw->ucode_capa.flags &
+      IWL_UCODE_TLV_FLAGS_NO_BASIC_SSID);
+ struct iwl_mvm_scan_params params = {};
 
  lockdep_assert_held(&mvm->mutex);
- BUG_ON(mvm->scan_cmd == NULL);
+
+ /* we should have failed registration if scan_cmd was NULL */
+ if (WARN_ON(mvm->scan_cmd == NULL))
+  return -ENOMEM;
 
  IWL_DEBUG_SCAN(mvm, "Handling mac80211 scan request\n");
  mvm->scan_status = IWL_MVM_SCAN_OS;
@@ -280,8 +333,13 @@ int iwl_mvm_scan_request(struct iwl_mvm *mvm,
  cmd->quiet_time = cpu_to_le16(IWL_ACTIVE_QUIET_TIME);
  cmd->quiet_plcp_th = cpu_to_le16(IWL_PLCP_QUIET_THRESH);
  cmd->rxchain_sel_flags = iwl_mvm_scan_rx_chain(mvm);
- cmd->max_out_time = iwl_mvm_scan_max_out_time(vif);
- cmd->suspend_time = iwl_mvm_scan_suspend_time(vif);
+
+ iwl_mvm_scan_calc_params(mvm, vif, req->n_ssids, &params);
+ cmd->max_out_time = cpu_to_le32(params.max_out_time);
+ cmd->suspend_time = cpu_to_le32(params.suspend_time);
+ if (params.passive_fragmented)
+  cmd->scan_flags |= SCAN_FLAGS_FRAGMENTED_SCAN;
+
  cmd->rxon_flags = iwl_mvm_scan_rxon_flags(req);
  cmd->filter_flags = cpu_to_le32(MAC_FILTER_ACCEPT_GRP |
      MAC_FILTER_IN_BEACON);
@@ -291,12 +349,6 @@ int iwl_mvm_scan_request(struct iwl_mvm *mvm,
  else
   cmd->type = cpu_to_le32(SCAN_TYPE_FORCED);
 
- /*
-  * TODO: This is a WA due to a bug in the FW AUX framework that does not
-  * properly handle time events that fail to be scheduled
-  */
- cmd->type = cpu_to_le32(SCAN_TYPE_FORCED);
-
  cmd->repeats = cpu_to_le32(1);
 
  /*
@@ -305,15 +357,20 @@ int iwl_mvm_scan_request(struct iwl_mvm *mvm,
   */
  if (req->n_ssids > 0) {
   cmd->passive2active = cpu_to_le16(1);
-  ssid = req->ssids[0].ssid;
-  ssid_len = req->ssids[0].ssid_len;
+  cmd->scan_flags |= SCAN_FLAGS_PASSIVE2ACTIVE;
+  if (basic_ssid) {
+   ssid = req->ssids[0].ssid;
+   ssid_len = req->ssids[0].ssid_len;
+  }
  } else {
   cmd->passive2active = 0;
+  cmd->scan_flags &= ~SCAN_FLAGS_PASSIVE2ACTIVE;
  }
 
- iwl_mvm_scan_fill_ssids(cmd, req);
+ iwl_mvm_scan_fill_ssids(cmd, req, basic_ssid ? 1 : 0);
 
- cmd->tx_cmd.tx_flags = cpu_to_le32(TX_CMD_FLG_SEQ_CTL);
+ cmd->tx_cmd.tx_flags = cpu_to_le32(TX_CMD_FLG_SEQ_CTL |
+        TX_CMD_FLG_BT_DIS);
  cmd->tx_cmd.sta_id = mvm->aux_sta.sta_id;
  cmd->tx_cmd.life_time = cpu_to_le32(TX_CMD_LIFE_TIME_INFINITE);
  cmd->tx_cmd.rate_n_flags =
@@ -328,7 +385,7 @@ int iwl_mvm_scan_request(struct iwl_mvm *mvm,
        req->ie, req->ie_len,
        mvm->fw->ucode_capa.max_probe_length));
 
- iwl_mvm_scan_fill_channels(cmd, req);
+ iwl_mvm_scan_fill_channels(cmd, req, basic_ssid, &params);
 
  cmd->len = cpu_to_le16(sizeof(struct iwl_scan_cmd) +
   le16_to_cpu(cmd->tx_cmd.len) +
@@ -370,12 +427,32 @@ int iwl_mvm_rx_scan_complete(struct iwl_mvm *mvm, struct iwl_rx_cmd_buffer *rxb,
  struct iwl_rx_packet *pkt = rxb_addr(rxb);
  struct iwl_scan_complete_notif *notif = (void *)pkt->data;
 
+ lockdep_assert_held(&mvm->mutex);
+
  IWL_DEBUG_SCAN(mvm, "Scan complete: status=0x%x scanned channels=%d\n",
          notif->status, notif->scanned_channels);
 
- mvm->scan_status = IWL_MVM_SCAN_NONE;
+ if (mvm->scan_status == IWL_MVM_SCAN_OS)
+  mvm->scan_status = IWL_MVM_SCAN_NONE;
  ieee80211_scan_completed(mvm->hw, notif->status != SCAN_COMP_STATUS_OK);
 
+ iwl_mvm_unref(mvm, IWL_MVM_REF_SCAN);
+
+ return 0;
+}
+
+int iwl_mvm_rx_sched_scan_results(struct iwl_mvm *mvm,
+      struct iwl_rx_cmd_buffer *rxb,
+      struct iwl_device_cmd *cmd)
+{
+ struct iwl_rx_packet *pkt = rxb_addr(rxb);
+ struct iwl_sched_scan_results *notif = (void *)pkt->data;
+
+ if (notif->client_bitmap & SCAN_CLIENT_SCHED_SCAN) {
+  IWL_DEBUG_SCAN(mvm, "Scheduled scan results\n");
+  ieee80211_sched_scan_results(mvm->hw);
+ }
+
  return 0;
 }
 
@@ -396,6 +473,11 @@ static bool iwl_mvm_scan_abort_notif(struct iwl_notif_wait_data *notif_wait,
    return false;
   }
 
+  /*
+   * If scan cannot be aborted, it means that we had a
+   * SCAN_COMPLETE_NOTIFICATION in the pipe and it called
+   * ieee80211_scan_completed already.
+   */
   IWL_DEBUG_SCAN(mvm, "Scan cannot be aborted, exit now: %d\n",
           *resp);
   return true;
@@ -412,30 +494,457 @@ static bool iwl_mvm_scan_abort_notif(struct iwl_notif_wait_data *notif_wait,
  };
 }
 
-void iwl_mvm_cancel_scan(struct iwl_mvm *mvm)
+int iwl_mvm_cancel_scan(struct iwl_mvm *mvm)
 {
  struct iwl_notification_wait wait_scan_abort;
  static const u8 scan_abort_notif[] = { SCAN_ABORT_CMD,
             SCAN_COMPLETE_NOTIFICATION };
  int ret;
 
+ if (mvm->scan_status == IWL_MVM_SCAN_NONE)
+  return 0;
+
+ if (iwl_mvm_is_radio_killed(mvm)) {
+  ieee80211_scan_completed(mvm->hw, true);
+  iwl_mvm_unref(mvm, IWL_MVM_REF_SCAN);
+  mvm->scan_status = IWL_MVM_SCAN_NONE;
+  return 0;
+ }
+
  iwl_init_notification_wait(&mvm->notif_wait, &wait_scan_abort,
        scan_abort_notif,
        ARRAY_SIZE(scan_abort_notif),
        iwl_mvm_scan_abort_notif, NULL);
 
- ret = iwl_mvm_send_cmd_pdu(mvm, SCAN_ABORT_CMD, CMD_SYNC, 0, NULL);
+ ret = iwl_mvm_send_cmd_pdu(mvm, SCAN_ABORT_CMD, 0, 0, NULL);
  if (ret) {
   IWL_ERR(mvm, "Couldn't send SCAN_ABORT_CMD: %d\n", ret);
+  /* mac80211's state will be cleaned in the nic_restart flow */
   goto out_remove_notif;
  }
 
- ret = iwl_wait_notification(&mvm->notif_wait, &wait_scan_abort, 1 * HZ);
- if (ret)
-  IWL_ERR(mvm, "%s - failed on timeout\n", __func__);
-
- return;
+ return iwl_wait_notification(&mvm->notif_wait, &wait_scan_abort, HZ);
 
 out_remove_notif:
  iwl_remove_notification(&mvm->notif_wait, &wait_scan_abort);
+ return ret;
+}
+
+int iwl_mvm_rx_scan_offload_complete_notif(struct iwl_mvm *mvm,
+        struct iwl_rx_cmd_buffer *rxb,
+        struct iwl_device_cmd *cmd)
+{
+ struct iwl_rx_packet *pkt = rxb_addr(rxb);
+ struct iwl_scan_offload_complete *scan_notif = (void *)pkt->data;
+
+ /* scan status must be locked for proper checking */
+ lockdep_assert_held(&mvm->mutex);
+
+ IWL_DEBUG_SCAN(mvm,
+         "Scheduled scan completed, status %s EBS status %s:%d\n",
+         scan_notif->status == IWL_SCAN_OFFLOAD_COMPLETED ?
+         "completed" : "aborted", scan_notif->ebs_status ==
+         IWL_SCAN_EBS_SUCCESS ? "success" : "failed",
+         scan_notif->ebs_status);
+
+
+ /* only call mac80211 completion if the stop was initiated by FW */
+ if (mvm->scan_status == IWL_MVM_SCAN_SCHED) {
+  mvm->scan_status = IWL_MVM_SCAN_NONE;
+  ieee80211_sched_scan_stopped(mvm->hw);
+ }
+
+ mvm->last_ebs_successful = !scan_notif->ebs_status;
+
+ return 0;
+}
+
+static void iwl_scan_offload_build_tx_cmd(struct iwl_mvm *mvm,
+       struct ieee80211_vif *vif,
+       struct ieee80211_sched_scan_ies *ies,
+       enum ieee80211_band band,
+       struct iwl_tx_cmd *cmd,
+       u8 *data)
+{
+ u16 cmd_len;
+
+ cmd->tx_flags = cpu_to_le32(TX_CMD_FLG_SEQ_CTL);
+ cmd->life_time = cpu_to_le32(TX_CMD_LIFE_TIME_INFINITE);
+ cmd->sta_id = mvm->aux_sta.sta_id;
+
+ cmd->rate_n_flags = iwl_mvm_scan_rate_n_flags(mvm, band, false);
+
+ cmd_len = iwl_mvm_fill_probe_req((struct ieee80211_mgmt *)data,
+      vif->addr,
+      1, NULL, 0,
+      ies->ie[band], ies->len[band],
+      SCAN_OFFLOAD_PROBE_REQ_SIZE);
+ cmd->len = cpu_to_le16(cmd_len);
+}
+
+static void iwl_build_scan_cmd(struct iwl_mvm *mvm,
+          struct ieee80211_vif *vif,
+          struct cfg80211_sched_scan_request *req,
+          struct iwl_scan_offload_cmd *scan,
+          struct iwl_mvm_scan_params *params)
+{
+ scan->channel_count = req->n_channels;
+ scan->quiet_time = cpu_to_le16(IWL_ACTIVE_QUIET_TIME);
+ scan->quiet_plcp_th = cpu_to_le16(IWL_PLCP_QUIET_THRESH);
+ scan->good_CRC_th = IWL_GOOD_CRC_TH_DEFAULT;
+ scan->rx_chain = iwl_mvm_scan_rx_chain(mvm);
+
+ scan->max_out_time = cpu_to_le32(params->max_out_time);
+ scan->suspend_time = cpu_to_le32(params->suspend_time);
+
+ scan->filter_flags |= cpu_to_le32(MAC_FILTER_ACCEPT_GRP |
+       MAC_FILTER_IN_BEACON);
+ scan->scan_type = cpu_to_le32(SCAN_TYPE_BACKGROUND);
+ scan->rep_count = cpu_to_le32(1);
+
+ if (params->passive_fragmented)
+  scan->scan_flags |= SCAN_FLAGS_FRAGMENTED_SCAN;
+}
+
+static int iwl_ssid_exist(u8 *ssid, u8 ssid_len, struct iwl_ssid_ie *ssid_list)
+{
+ int i;
+
+ for (i = 0; i < PROBE_OPTION_MAX; i++) {
+  if (!ssid_list[i].len)
+   break;
+  if (ssid_list[i].len == ssid_len &&
+      !memcmp(ssid_list->ssid, ssid, ssid_len))
+   return i;
+ }
+ return -1;
+}
+
+static void iwl_scan_offload_build_ssid(struct cfg80211_sched_scan_request *req,
+     struct iwl_scan_offload_cmd *scan,
+     u32 *ssid_bitmap)
+{
+ int i, j;
+ int index;
+
+ /*
+  * copy SSIDs from match list.
+  * iwl_config_sched_scan_profiles() uses the order of these ssids to
+  * config match list.
+  */
+ for (i = 0; i < req->n_match_sets && i < PROBE_OPTION_MAX; i++) {
+  /* skip empty SSID matchsets */
+  if (!req->match_sets[i].ssid.ssid_len)
+   continue;
+  scan->direct_scan[i].id = WLAN_EID_SSID;
+  scan->direct_scan[i].len = req->match_sets[i].ssid.ssid_len;
+  memcpy(scan->direct_scan[i].ssid, req->match_sets[i].ssid.ssid,
+         scan->direct_scan[i].len);
+ }
+
+ /* add SSIDs from scan SSID list */
+ *ssid_bitmap = 0;
+ for (j = 0; j < req->n_ssids && i < PROBE_OPTION_MAX; j++) {
+  index = iwl_ssid_exist(req->ssids[j].ssid,
+           req->ssids[j].ssid_len,
+           scan->direct_scan);
+  if (index < 0) {
+   if (!req->ssids[j].ssid_len)
+    continue;
+   scan->direct_scan[i].id = WLAN_EID_SSID;
+   scan->direct_scan[i].len = req->ssids[j].ssid_len;
+   memcpy(scan->direct_scan[i].ssid, req->ssids[j].ssid,
+          scan->direct_scan[i].len);
+   *ssid_bitmap |= BIT(i + 1);
+   i++;
+  } else {
+   *ssid_bitmap |= BIT(index + 1);
+  }
+ }
+}
+
+static void iwl_build_channel_cfg(struct iwl_mvm *mvm,
+      struct cfg80211_sched_scan_request *req,
+      struct iwl_scan_channel_cfg *channels,
+      enum ieee80211_band band,
+      int *head,
+      u32 ssid_bitmap,
+      struct iwl_mvm_scan_params *params)
+{
+ int i, index = 0;
+
+ for (i = 0; i < req->n_channels; i++) {
+  struct ieee80211_channel *chan = req->channels[i];
+
+  if (chan->band != band)
+   continue;
+
+  index = *head;
+  (*head)++;
+
+  channels->channel_number[index] = cpu_to_le16(chan->hw_value);
+  channels->dwell_time[index][0] = params->dwell[band].active;
+  channels->dwell_time[index][1] = params->dwell[band].passive;
+
+  channels->iter_count[index] = cpu_to_le16(1);
+  channels->iter_interval[index] = 0;
+
+  if (!(chan->flags & IEEE80211_CHAN_NO_IR))
+   channels->type[index] |=
+    cpu_to_le32(IWL_SCAN_OFFLOAD_CHANNEL_ACTIVE);
+
+  channels->type[index] |=
+    cpu_to_le32(IWL_SCAN_OFFLOAD_CHANNEL_FULL |
+         IWL_SCAN_OFFLOAD_CHANNEL_PARTIAL);
+
+  if (chan->flags & IEEE80211_CHAN_NO_HT40)
+   channels->type[index] |=
+    cpu_to_le32(IWL_SCAN_OFFLOAD_CHANNEL_NARROW);
+
+  /* scan for all SSIDs from req->ssids */
+  channels->type[index] |= cpu_to_le32(ssid_bitmap);
+ }
+}
+
+int iwl_mvm_config_sched_scan(struct iwl_mvm *mvm,
+         struct ieee80211_vif *vif,
+         struct cfg80211_sched_scan_request *req,
+         struct ieee80211_sched_scan_ies *ies)
+{
+ int band_2ghz = mvm->nvm_data->bands[IEEE80211_BAND_2GHZ].n_channels;
+ int band_5ghz = mvm->nvm_data->bands[IEEE80211_BAND_5GHZ].n_channels;
+ int head = 0;
+ u32 ssid_bitmap;
+ int cmd_len;
+ int ret;
+
+ struct iwl_scan_offload_cfg *scan_cfg;
+ struct iwl_host_cmd cmd = {
+  .id = SCAN_OFFLOAD_CONFIG_CMD,
+ };
+ struct iwl_mvm_scan_params params = {};
+
+ lockdep_assert_held(&mvm->mutex);
+
+ cmd_len = sizeof(struct iwl_scan_offload_cfg) +
+    2 * SCAN_OFFLOAD_PROBE_REQ_SIZE;
+
+ scan_cfg = kzalloc(cmd_len, GFP_KERNEL);
+ if (!scan_cfg)
+  return -ENOMEM;
+
+ iwl_mvm_scan_calc_params(mvm, vif, req->n_ssids, &params);
+ iwl_build_scan_cmd(mvm, vif, req, &scan_cfg->scan_cmd, &params);
+ scan_cfg->scan_cmd.len = cpu_to_le16(cmd_len);
+
+ iwl_scan_offload_build_ssid(req, &scan_cfg->scan_cmd, &ssid_bitmap);
+ /* build tx frames for supported bands */
+ if (band_2ghz) {
+  iwl_scan_offload_build_tx_cmd(mvm, vif, ies,
+           IEEE80211_BAND_2GHZ,
+           &scan_cfg->scan_cmd.tx_cmd[0],
+           scan_cfg->data);
+  iwl_build_channel_cfg(mvm, req, &scan_cfg->channel_cfg,
+          IEEE80211_BAND_2GHZ, &head,
+          ssid_bitmap, &params);
+ }
+ if (band_5ghz) {
+  iwl_scan_offload_build_tx_cmd(mvm, vif, ies,
+           IEEE80211_BAND_5GHZ,
+           &scan_cfg->scan_cmd.tx_cmd[1],
+           scan_cfg->data +
+      SCAN_OFFLOAD_PROBE_REQ_SIZE);
+  iwl_build_channel_cfg(mvm, req, &scan_cfg->channel_cfg,
+          IEEE80211_BAND_5GHZ, &head,
+          ssid_bitmap, &params);
+ }
+
+ cmd.data[0] = scan_cfg;
+ cmd.len[0] = cmd_len;
+ cmd.dataflags[0] = IWL_HCMD_DFL_NOCOPY;
+
+ IWL_DEBUG_SCAN(mvm, "Sending scheduled scan config\n");
+
+ ret = iwl_mvm_send_cmd(mvm, &cmd);
+ kfree(scan_cfg);
+ return ret;
+}
+
+int iwl_mvm_config_sched_scan_profiles(struct iwl_mvm *mvm,
+           struct cfg80211_sched_scan_request *req)
+{
+ struct iwl_scan_offload_profile *profile;
+ struct iwl_scan_offload_profile_cfg *profile_cfg;
+ struct iwl_scan_offload_blacklist *blacklist;
+ struct iwl_host_cmd cmd = {
+  .id = SCAN_OFFLOAD_UPDATE_PROFILES_CMD,
+  .len[1] = sizeof(*profile_cfg),
+  .dataflags[0] = IWL_HCMD_DFL_NOCOPY,
+  .dataflags[1] = IWL_HCMD_DFL_NOCOPY,
+ };
+ int blacklist_len;
+ int i;
+ int ret;
+
+ if (WARN_ON(req->n_match_sets > IWL_SCAN_MAX_PROFILES))
+   return -EIO;
+
+ if (mvm->fw->ucode_capa.flags & IWL_UCODE_TLV_FLAGS_SHORT_BL)
+  blacklist_len = IWL_SCAN_SHORT_BLACKLIST_LEN;
+ else
+  blacklist_len = IWL_SCAN_MAX_BLACKLIST_LEN;
+
+ blacklist = kzalloc(sizeof(*blacklist) * blacklist_len, GFP_KERNEL);
+ if (!blacklist)
+  return -ENOMEM;
+
+ profile_cfg = kzalloc(sizeof(*profile_cfg), GFP_KERNEL);
+ if (!profile_cfg) {
+  ret = -ENOMEM;
+  goto free_blacklist;
+ }
+
+ cmd.data[0] = blacklist;
+ cmd.len[0] = sizeof(*blacklist) * blacklist_len;
+ cmd.data[1] = profile_cfg;
+
+ /* No blacklist configuration */
+
+ profile_cfg->num_profiles = req->n_match_sets;
+ profile_cfg->active_clients = SCAN_CLIENT_SCHED_SCAN;
+ profile_cfg->pass_match = SCAN_CLIENT_SCHED_SCAN;
+ profile_cfg->match_notify = SCAN_CLIENT_SCHED_SCAN;
+ if (!req->n_match_sets || !req->match_sets[0].ssid.ssid_len)
+  profile_cfg->any_beacon_notify = SCAN_CLIENT_SCHED_SCAN;
+
+ for (i = 0; i < req->n_match_sets; i++) {
+  profile = &profile_cfg->profiles[i];
+  profile->ssid_index = i;
+  /* Support any cipher and auth algorithm */
+  profile->unicast_cipher = 0xff;
+  profile->auth_alg = 0xff;
+  profile->network_type = IWL_NETWORK_TYPE_ANY;
+  profile->band_selection = IWL_SCAN_OFFLOAD_SELECT_ANY;
+  profile->client_bitmap = SCAN_CLIENT_SCHED_SCAN;
+ }
+
+ IWL_DEBUG_SCAN(mvm, "Sending scheduled scan profile config\n");
+
+ ret = iwl_mvm_send_cmd(mvm, &cmd);
+ kfree(profile_cfg);
+free_blacklist:
+ kfree(blacklist);
+
+ return ret;
+}
+
+int iwl_mvm_sched_scan_start(struct iwl_mvm *mvm,
+        struct cfg80211_sched_scan_request *req)
+{
+ struct iwl_scan_offload_req scan_req = {
+  .watchdog = IWL_SCHED_SCAN_WATCHDOG,
+
+  .schedule_line[0].iterations = IWL_FAST_SCHED_SCAN_ITERATIONS,
+  .schedule_line[0].delay = req->interval / 1000,
+  .schedule_line[0].full_scan_mul = 1,
+
+  .schedule_line[1].iterations = 0xff,
+  .schedule_line[1].delay = req->interval / 1000,
+  .schedule_line[1].full_scan_mul = IWL_FULL_SCAN_MULTIPLIER,
+ };
+
+ if (req->n_match_sets && req->match_sets[0].ssid.ssid_len) {
+  IWL_DEBUG_SCAN(mvm,
+          "Sending scheduled scan with filtering, filter len %d\n",
+          req->n_match_sets);
+ } else {
+  IWL_DEBUG_SCAN(mvm,
+          "Sending Scheduled scan without filtering\n");
+  scan_req.flags |= cpu_to_le16(IWL_SCAN_OFFLOAD_FLAG_PASS_ALL);
+ }
+
+ if (mvm->last_ebs_successful &&
+     mvm->fw->ucode_capa.flags & IWL_UCODE_TLV_FLAGS_EBS_SUPPORT)
+  scan_req.flags |=
+   cpu_to_le16(IWL_SCAN_OFFLOAD_FLAG_EBS_ACCURATE_MODE);
+
+ return iwl_mvm_send_cmd_pdu(mvm, SCAN_OFFLOAD_REQUEST_CMD, 0,
+        sizeof(scan_req), &scan_req);
+}
+
+static int iwl_mvm_send_sched_scan_abort(struct iwl_mvm *mvm)
+{
+ int ret;
+ struct iwl_host_cmd cmd = {
+  .id = SCAN_OFFLOAD_ABORT_CMD,
+ };
+ u32 status;
+
+ /* Exit instantly with error when device is not ready
+  * to receive scan abort command or it does not perform
+  * scheduled scan currently */
+ if (mvm->scan_status != IWL_MVM_SCAN_SCHED)
+  return -EIO;
+
+ ret = iwl_mvm_send_cmd_status(mvm, &cmd, &status);
+ if (ret)
+  return ret;
+
+ if (status != CAN_ABORT_STATUS) {
+  /*
+   * The scan abort will return 1 for success or
+   * 2 for "failure".  A failure condition can be
+   * due to simply not being in an active scan which
+   * can occur if we send the scan abort before the
+   * microcode has notified us that a scan is completed.
+   */
+  IWL_DEBUG_SCAN(mvm, "SCAN OFFLOAD ABORT ret %d.\n", status);
+  ret = -ENOENT;
+ }
+
+ return ret;
+}
+
+int iwl_mvm_sched_scan_stop(struct iwl_mvm *mvm, bool notify)
+{
+ int ret;
+ struct iwl_notification_wait wait_scan_done;
+ static const u8 scan_done_notif[] = { SCAN_OFFLOAD_COMPLETE, };
+
+ lockdep_assert_held(&mvm->mutex);
+
+ if (mvm->scan_status != IWL_MVM_SCAN_SCHED) {
+  IWL_DEBUG_SCAN(mvm, "No offloaded scan to stop\n");
+  return 0;
+ }
+
+ iwl_init_notification_wait(&mvm->notif_wait, &wait_scan_done,
+       scan_done_notif,
+       ARRAY_SIZE(scan_done_notif),
+       NULL, NULL);
+
+ ret = iwl_mvm_send_sched_scan_abort(mvm);
+ if (ret) {
+  IWL_DEBUG_SCAN(mvm, "Send stop offload scan failed %d\n", ret);
+  iwl_remove_notification(&mvm->notif_wait, &wait_scan_done);
+  return ret;
+ }
+
+ IWL_DEBUG_SCAN(mvm, "Successfully sent stop offload scan\n");
+
+ ret = iwl_wait_notification(&mvm->notif_wait, &wait_scan_done, 1 * HZ);
+ if (ret)
+  return ret;
+
+ /*
+  * Clear the scan status so the next scan requests will succeed. This
+  * also ensures the Rx handler doesn't do anything, as the scan was
+  * stopped from above.
+  */
+ mvm->scan_status = IWL_MVM_SCAN_NONE;
+
+ if (notify)
+  ieee80211_sched_scan_stopped(mvm->hw);
+
+ return 0;
 }
diff --git a/drivers/net/wireless/iwlwifi/mvm/sf.c b/drivers/net/wireless/iwlwifi/mvm/sf.c
new file mode 100644
index 0000000..7edfd15
--- /dev/null
+++ b/drivers/net/wireless/iwlwifi/mvm/sf.c
@@ -0,0 +1,289 @@
+/******************************************************************************
+ *
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ * redistributing this file, you may do so under either license.
+ *
+ * GPL LICENSE SUMMARY
+ *
+ * Copyright(c) 2013 - 2014 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110,
+ * USA
+ *
+ * The full GNU General Public License is included in this distribution
+ * in the file called COPYING.
+ *
+ * Contact Information:
+ *  Intel Linux Wireless <ilw@linux.intel.com>
+ * Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497
+ *
+ * BSD LICENSE
+ *
+ * Copyright(c) 2013 - 2014 Intel Corporation. All rights reserved.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *  * Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *  * Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *  * Neither the name Intel Corporation nor the names of its
+ *    contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *****************************************************************************/
+#include "mvm.h"
+
+/* For counting bound interfaces */
+struct iwl_mvm_active_iface_iterator_data {
+ struct ieee80211_vif *ignore_vif;
+ u8 sta_vif_ap_sta_id;
+ enum iwl_sf_state sta_vif_state;
+ int num_active_macs;
+};
+
+/*
+ * Count bound interfaces which are not p2p, besides data->ignore_vif.
+ * data->station_vif will point to one bound vif of type station, if exists.
+ */
+static void iwl_mvm_bound_iface_iterator(void *_data, u8 *mac,
+      struct ieee80211_vif *vif)
+{
+ struct iwl_mvm_active_iface_iterator_data *data = _data;
+ struct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);
+
+ if (vif == data->ignore_vif || !mvmvif->phy_ctxt ||
+     vif->type == NL80211_IFTYPE_P2P_DEVICE)
+  return;
+
+ data->num_active_macs++;
+
+ if (vif->type == NL80211_IFTYPE_STATION) {
+  data->sta_vif_ap_sta_id = mvmvif->ap_sta_id;
+  if (vif->bss_conf.assoc)
+   data->sta_vif_state = SF_FULL_ON;
+  else
+   data->sta_vif_state = SF_INIT_OFF;
+ }
+}
+
+/*
+ * Aging and idle timeouts for the different possible scenarios
+ * in SF_FULL_ON state.
+ */
+static const __le32 sf_full_timeout[SF_NUM_SCENARIO][SF_NUM_TIMEOUT_TYPES] = {
+ {
+  cpu_to_le32(SF_SINGLE_UNICAST_AGING_TIMER),
+  cpu_to_le32(SF_SINGLE_UNICAST_IDLE_TIMER)
+ },
+ {
+  cpu_to_le32(SF_AGG_UNICAST_AGING_TIMER),
+  cpu_to_le32(SF_AGG_UNICAST_IDLE_TIMER)
+ },
+ {
+  cpu_to_le32(SF_MCAST_AGING_TIMER),
+  cpu_to_le32(SF_MCAST_IDLE_TIMER)
+ },
+ {
+  cpu_to_le32(SF_BA_AGING_TIMER),
+  cpu_to_le32(SF_BA_IDLE_TIMER)
+ },
+ {
+  cpu_to_le32(SF_TX_RE_AGING_TIMER),
+  cpu_to_le32(SF_TX_RE_IDLE_TIMER)
+ },
+};
+
+static void iwl_mvm_fill_sf_command(struct iwl_sf_cfg_cmd *sf_cmd,
+        struct ieee80211_sta *sta)
+{
+ int i, j, watermark;
+
+ sf_cmd->watermark[SF_LONG_DELAY_ON] = cpu_to_le32(SF_W_MARK_SCAN);
+
+ /*
+  * If we are in association flow - check antenna configuration
+  * capabilities of the AP station, and choose the watermark accordingly.
+  */
+ if (sta) {
+  if (sta->ht_cap.ht_supported || sta->vht_cap.vht_supported) {
+   switch (sta->rx_nss) {
+   case 1:
+    watermark = SF_W_MARK_SISO;
+    break;
+   case 2:
+    watermark = SF_W_MARK_MIMO2;
+    break;
+   default:
+    watermark = SF_W_MARK_MIMO3;
+    break;
+   }
+  } else {
+   watermark = SF_W_MARK_LEGACY;
+  }
+ /* default watermark value for unassociated mode. */
+ } else {
+  watermark = SF_W_MARK_MIMO2;
+ }
+ sf_cmd->watermark[SF_FULL_ON] = cpu_to_le32(watermark);
+
+ for (i = 0; i < SF_NUM_SCENARIO; i++) {
+  for (j = 0; j < SF_NUM_TIMEOUT_TYPES; j++) {
+   sf_cmd->long_delay_timeouts[i][j] =
+     cpu_to_le32(SF_LONG_DELAY_AGING_TIMER);
+  }
+ }
+ BUILD_BUG_ON(sizeof(sf_full_timeout) !=
+       sizeof(__le32) * SF_NUM_SCENARIO * SF_NUM_TIMEOUT_TYPES);
+
+ memcpy(sf_cmd->full_on_timeouts, sf_full_timeout,
+        sizeof(sf_full_timeout));
+}
+
+static int iwl_mvm_sf_config(struct iwl_mvm *mvm, u8 sta_id,
+        enum iwl_sf_state new_state)
+{
+ struct iwl_sf_cfg_cmd sf_cmd = {
+  .state = new_state,
+ };
+ struct ieee80211_sta *sta;
+ int ret = 0;
+
+ /*
+  * If an associated AP sta changed its antenna configuration, the state
+  * will remain FULL_ON but SF parameters need to be reconsidered.
+  */
+ if (new_state != SF_FULL_ON && mvm->sf_state == new_state)
+  return 0;
+
+ switch (new_state) {
+ case SF_UNINIT:
+  break;
+ case SF_FULL_ON:
+  if (sta_id == IWL_MVM_STATION_COUNT) {
+   IWL_ERR(mvm,
+    "No station: Cannot switch SF to FULL_ON\n");
+   return -EINVAL;
+  }
+  rcu_read_lock();
+  sta = rcu_dereference(mvm->fw_id_to_mac_id[sta_id]);
+  if (IS_ERR_OR_NULL(sta)) {
+   IWL_ERR(mvm, "Invalid station id\n");
+   rcu_read_unlock();
+   return -EINVAL;
+  }
+  iwl_mvm_fill_sf_command(&sf_cmd, sta);
+  rcu_read_unlock();
+  break;
+ case SF_INIT_OFF:
+  iwl_mvm_fill_sf_command(&sf_cmd, NULL);
+  break;
+ default:
+  WARN_ONCE(1, "Invalid state: %d. not sending Smart Fifo cmd\n",
+     new_state);
+  return -EINVAL;
+ }
+
+ ret = iwl_mvm_send_cmd_pdu(mvm, REPLY_SF_CFG_CMD, CMD_ASYNC,
+       sizeof(sf_cmd), &sf_cmd);
+ if (!ret)
+  mvm->sf_state = new_state;
+
+ return ret;
+}
+
+/*
+ * Update Smart fifo:
+ * Count bound interfaces that are not to be removed, ignoring p2p devices,
+ * and set new state accordingly.
+ */
+int iwl_mvm_sf_update(struct iwl_mvm *mvm, struct ieee80211_vif *changed_vif,
+        bool remove_vif)
+{
+ enum iwl_sf_state new_state;
+ u8 sta_id = IWL_MVM_STATION_COUNT;
+ struct iwl_mvm_vif *mvmvif = NULL;
+ struct iwl_mvm_active_iface_iterator_data data = {
+  .ignore_vif = changed_vif,
+  .sta_vif_state = SF_UNINIT,
+  .sta_vif_ap_sta_id = IWL_MVM_STATION_COUNT,
+ };
+
+ /*
+  * Ignore the call if we are in HW Restart flow, or if the handled
+  * vif is a p2p device.
+  */
+ if (test_bit(IWL_MVM_STATUS_IN_HW_RESTART, &mvm->status) ||
+     (changed_vif && changed_vif->type == NL80211_IFTYPE_P2P_DEVICE))
+  return 0;
+
+ ieee80211_iterate_active_interfaces_atomic(mvm->hw,
+         IEEE80211_IFACE_ITER_NORMAL,
+         iwl_mvm_bound_iface_iterator,
+         &data);
+
+ /* If changed_vif exists and is not to be removed, add to the count */
+ if (changed_vif && !remove_vif)
+  data.num_active_macs++;
+
+ switch (data.num_active_macs) {
+ case 0:
+  /* If there are no active macs - change state to SF_INIT_OFF */
+  new_state = SF_INIT_OFF;
+  break;
+ case 1:
+  if (remove_vif) {
+   /* The one active mac left is of type station
+    * and we filled the relevant data during iteration
+    */
+   new_state = data.sta_vif_state;
+   sta_id = data.sta_vif_ap_sta_id;
+  } else {
+   if (WARN_ON(!changed_vif))
+    return -EINVAL;
+   if (changed_vif->type != NL80211_IFTYPE_STATION) {
+    new_state = SF_UNINIT;
+   } else if (changed_vif->bss_conf.assoc &&
+       changed_vif->bss_conf.dtim_period) {
+    mvmvif = iwl_mvm_vif_from_mac80211(changed_vif);
+    sta_id = mvmvif->ap_sta_id;
+    new_state = SF_FULL_ON;
+   } else {
+    new_state = SF_INIT_OFF;
+   }
+  }
+  break;
+ default:
+  /* If there are multiple active macs - change to SF_UNINIT */
+  new_state = SF_UNINIT;
+ }
+ return iwl_mvm_sf_config(mvm, sta_id, new_state);
+}
diff --git a/drivers/net/wireless/iwlwifi/mvm/sta.c b/drivers/net/wireless/iwlwifi/mvm/sta.c
index 68f0bbe..1fb01ea 100644
--- a/drivers/net/wireless/iwlwifi/mvm/sta.c
+++ b/drivers/net/wireless/iwlwifi/mvm/sta.c
@@ -5,7 +5,7 @@
  *
  * GPL LICENSE SUMMARY
  *
- * Copyright(c) 2012 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2012 - 2014 Intel Corporation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of version 2 of the GNU General Public License as
@@ -30,7 +30,7 @@
  *
  * BSD LICENSE
  *
- * Copyright(c) 2012 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2012 - 2014 Intel Corporation. All rights reserved.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -64,20 +64,32 @@
 
 #include "mvm.h"
 #include "sta.h"
+#include "rs.h"
 
-static int iwl_mvm_find_free_sta_id(struct iwl_mvm *mvm)
+static int iwl_mvm_find_free_sta_id(struct iwl_mvm *mvm,
+        enum nl80211_iftype iftype)
 {
  int sta_id;
+ u32 reserved_ids = 0;
 
+ BUILD_BUG_ON(IWL_MVM_STATION_COUNT > 32);
  WARN_ON_ONCE(test_bit(IWL_MVM_STATUS_IN_HW_RESTART, &mvm->status));
 
  lockdep_assert_held(&mvm->mutex);
 
+ /* d0i3/d3 assumes the AP's sta_id (of sta vif) is 0. reserve it. */
+ if (iftype != NL80211_IFTYPE_STATION)
+  reserved_ids = BIT(0);
+
  /* Don't take rcu_read_lock() since we are protected by mvm->mutex */
- for (sta_id = 0; sta_id < IWL_MVM_STATION_COUNT; sta_id++)
+ for (sta_id = 0; sta_id < IWL_MVM_STATION_COUNT; sta_id++) {
+  if (BIT(sta_id) & reserved_ids)
+   continue;
+
   if (!rcu_dereference_protected(mvm->fw_id_to_mac_id[sta_id],
             lockdep_is_held(&mvm->mutex)))
    return sta_id;
+ }
  return IWL_MVM_STATION_COUNT;
 }
 
@@ -203,7 +215,8 @@ int iwl_mvm_add_sta(struct iwl_mvm *mvm,
  lockdep_assert_held(&mvm->mutex);
 
  if (!test_bit(IWL_MVM_STATUS_IN_HW_RESTART, &mvm->status))
-  sta_id = iwl_mvm_find_free_sta_id(mvm);
+  sta_id = iwl_mvm_find_free_sta_id(mvm,
+        ieee80211_vif_type_p2p(vif));
  else
   sta_id = mvm_sta->sta_id;
 
@@ -217,6 +230,8 @@ int iwl_mvm_add_sta(struct iwl_mvm *mvm,
             mvmvif->color);
  mvm_sta->vif = vif;
  mvm_sta->max_agg_bufsize = LINK_QUAL_AGG_FRAME_LIMIT_DEF;
+ mvm_sta->tx_protection = 0;
+ mvm_sta->tt_tx_protection = false;
 
  /* HW restart, don't assume the memory has been zeroed */
  atomic_set(&mvm->pending_frames[sta_id], 0);
@@ -226,8 +241,12 @@ int iwl_mvm_add_sta(struct iwl_mvm *mvm,
   if (vif->hw_queue[i] != IEEE80211_INVAL_HW_QUEUE)
    mvm_sta->tfd_queue_msk |= BIT(vif->hw_queue[i]);
 
- /* for HW restart - need to reset the seq_number etc... */
- memset(mvm_sta->tid_data, 0, sizeof(mvm_sta->tid_data));
+ /* for HW restart - reset everything but the sequence number */
+ for (i = 0; i < IWL_MAX_TID_COUNT; i++) {
+  u16 seq = mvm_sta->tid_data[i].seq_number;
+  memset(&mvm_sta->tid_data[i], 0, sizeof(mvm_sta->tid_data[i]));
+  mvm_sta->tid_data[i].seq_number = seq;
+ }
 
  ret = iwl_mvm_sta_send_to_fw(mvm, sta, false);
  if (ret)
@@ -308,7 +327,7 @@ static int iwl_mvm_rm_sta_common(struct iwl_mvm *mvm, u8 sta_id)
   return -EINVAL;
  }
 
- ret = iwl_mvm_send_cmd_pdu(mvm, REMOVE_STA, CMD_SYNC,
+ ret = iwl_mvm_send_cmd_pdu(mvm, REMOVE_STA, 0,
        sizeof(rm_sta_cmd), &rm_sta_cmd);
  if (ret) {
   IWL_ERR(mvm, "Failed to remove station. Id=%d\n", sta_id);
@@ -338,8 +357,15 @@ void iwl_mvm_sta_drained_wk(struct work_struct *wk)
    rcu_dereference_protected(mvm->fw_id_to_mac_id[sta_id],
         lockdep_is_held(&mvm->mutex));
 
-  /* This station is in use */
-  if (!IS_ERR(sta))
+  /*
+   * This station is in use or RCU-removed; the latter happens in
+   * managed mode, where mac80211 removes the station before we
+   * can remove it from firmware (we can only do that after the
+   * MAC is marked unassociated), and possibly while the deauth
+   * frame to disconnect from the AP is still queued. Then, the
+   * station pointer is -ENOENT when the last skb is reclaimed.
+   */
+  if (!IS_ERR(sta) || PTR_ERR(sta) == -ENOENT)
    continue;
 
   if (PTR_ERR(sta) == -EINVAL) {
@@ -365,7 +391,7 @@ void iwl_mvm_sta_drained_wk(struct work_struct *wk)
     sta_id);
    continue;
   }
-  rcu_assign_pointer(mvm->fw_id_to_mac_id[sta_id], NULL);
+  RCU_INIT_POINTER(mvm->fw_id_to_mac_id[sta_id], NULL);
   clear_bit(sta_id, mvm->sta_drained);
  }
 
@@ -387,20 +413,16 @@ int iwl_mvm_rm_sta(struct iwl_mvm *mvm,
   /* flush its queues here since we are freeing mvm_sta */
   ret = iwl_mvm_flush_tx_path(mvm, mvm_sta->tfd_queue_msk, true);
 
-  /*
-   * Put a non-NULL since the fw station isn't removed.
-   * It will be removed after the MAC will be set as
-   * unassoc.
-   */
-  rcu_assign_pointer(mvm->fw_id_to_mac_id[mvm_sta->sta_id],
-       ERR_PTR(-EINVAL));
-
   /* if we are associated - we can't remove the AP STA now */
   if (vif->bss_conf.assoc)
    return ret;
 
   /* unassoc - go ahead - remove the AP STA now */
   mvmvif->ap_sta_id = IWL_MVM_STATION_COUNT;
+
+  /* clear d0i3_ap_sta_id if no longer relevant */
+  if (mvm->d0i3_ap_sta_id == mvm_sta->sta_id)
+   mvm->d0i3_ap_sta_id = IWL_MVM_STATION_COUNT;
  }
 
  /*
@@ -420,7 +442,7 @@ int iwl_mvm_rm_sta(struct iwl_mvm *mvm,
  } else {
   spin_unlock_bh(&mvm_sta->lock);
   ret = iwl_mvm_rm_sta_common(mvm, mvm_sta->sta_id);
-  rcu_assign_pointer(mvm->fw_id_to_mac_id[mvm_sta->sta_id], NULL);
+  RCU_INIT_POINTER(mvm->fw_id_to_mac_id[mvm_sta->sta_id], NULL);
  }
 
  return ret;
@@ -434,15 +456,15 @@ int iwl_mvm_rm_sta_id(struct iwl_mvm *mvm,
 
  lockdep_assert_held(&mvm->mutex);
 
- rcu_assign_pointer(mvm->fw_id_to_mac_id[sta_id], NULL);
+ RCU_INIT_POINTER(mvm->fw_id_to_mac_id[sta_id], NULL);
  return ret;
 }
 
 int iwl_mvm_allocate_int_sta(struct iwl_mvm *mvm, struct iwl_mvm_int_sta *sta,
-        u32 qmask)
+        u32 qmask, enum nl80211_iftype iftype)
 {
  if (!test_bit(IWL_MVM_STATUS_IN_HW_RESTART, &mvm->status)) {
-  sta->sta_id = iwl_mvm_find_free_sta_id(mvm);
+  sta->sta_id = iwl_mvm_find_free_sta_id(mvm, iftype);
   if (WARN_ON_ONCE(sta->sta_id == IWL_MVM_STATION_COUNT))
    return -ENOSPC;
  }
@@ -456,7 +478,7 @@ int iwl_mvm_allocate_int_sta(struct iwl_mvm *mvm, struct iwl_mvm_int_sta *sta,
 
 void iwl_mvm_dealloc_int_sta(struct iwl_mvm *mvm, struct iwl_mvm_int_sta *sta)
 {
- rcu_assign_pointer(mvm->fw_id_to_mac_id[sta->sta_id], NULL);
+ RCU_INIT_POINTER(mvm->fw_id_to_mac_id[sta->sta_id], NULL);
  memset(sta, 0, sizeof(struct iwl_mvm_int_sta));
  sta->sta_id = IWL_MVM_STATION_COUNT;
 }
@@ -472,7 +494,7 @@ static int iwl_mvm_add_int_sta_common(struct iwl_mvm *mvm,
 
  lockdep_assert_held(&mvm->mutex);
 
- memset(&cmd, 0, sizeof(struct iwl_mvm_add_sta_cmd));
+ memset(&cmd, 0, sizeof(cmd));
  cmd.sta_id = sta->sta_id;
  cmd.mac_id_n_color = cpu_to_le32(FW_CMD_ID_AND_COLOR(mac_id,
             color));
@@ -507,7 +529,8 @@ int iwl_mvm_add_aux_sta(struct iwl_mvm *mvm)
  lockdep_assert_held(&mvm->mutex);
 
  /* Add the aux station, but without any queues */
- ret = iwl_mvm_allocate_int_sta(mvm, &mvm->aux_sta, 0);
+ ret = iwl_mvm_allocate_int_sta(mvm, &mvm->aux_sta, 0,
+           NL80211_IFTYPE_UNSPECIFIED);
  if (ret)
   return ret;
 
@@ -531,10 +554,14 @@ int iwl_mvm_send_bcast_sta(struct iwl_mvm *mvm, struct ieee80211_vif *vif,
       struct iwl_mvm_int_sta *bsta)
 {
  struct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);
- static const u8 baddr[] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};
+ static const u8 _baddr[] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};
+ const u8 *baddr = _baddr;
 
  lockdep_assert_held(&mvm->mutex);
 
+ if (vif->type == NL80211_IFTYPE_ADHOC)
+  baddr = vif->bss_conf.bssid;
+
  if (WARN_ON_ONCE(bsta->sta_id == IWL_MVM_STATION_COUNT))
   return -ENOSPC;
 
@@ -575,7 +602,8 @@ int iwl_mvm_add_bcast_sta(struct iwl_mvm *mvm, struct ieee80211_vif *vif,
  lockdep_assert_held(&mvm->mutex);
 
  qmask = iwl_mvm_mac_get_queues_mask(mvm, vif);
- ret = iwl_mvm_allocate_int_sta(mvm, bsta, qmask);
+ ret = iwl_mvm_allocate_int_sta(mvm, bsta, qmask,
+           ieee80211_vif_type_p2p(vif));
  if (ret)
   return ret;
 
@@ -605,6 +633,8 @@ int iwl_mvm_rm_bcast_sta(struct iwl_mvm *mvm, struct iwl_mvm_int_sta *bsta)
  return ret;
 }
 
+#define IWL_MAX_RX_BA_SESSIONS 16
+
 int iwl_mvm_sta_rx_agg(struct iwl_mvm *mvm, struct ieee80211_sta *sta,
          int tid, u16 ssn, bool start)
 {
@@ -615,6 +645,11 @@ int iwl_mvm_sta_rx_agg(struct iwl_mvm *mvm, struct ieee80211_sta *sta,
 
  lockdep_assert_held(&mvm->mutex);
 
+ if (start && mvm->rx_ba_sessions >= IWL_MAX_RX_BA_SESSIONS) {
+  IWL_WARN(mvm, "Not enough RX BA SESSIONS\n");
+  return -ENOSPC;
+ }
+
  cmd.mac_id_n_color = cpu_to_le32(mvm_sta->mac_id_n_color);
  cmd.sta_id = mvm_sta->sta_id;
  cmd.add_modify = STA_MODE_MODIFY;
@@ -649,6 +684,14 @@ int iwl_mvm_sta_rx_agg(struct iwl_mvm *mvm, struct ieee80211_sta *sta,
   break;
  }
 
+ if (!ret) {
+  if (start)
+   mvm->rx_ba_sessions++;
+  else if (mvm->rx_ba_sessions > 0)
+   /* check that restart flow didn't zero the counter */
+   mvm->rx_ba_sessions--;
+ }
+
  return ret;
 }
 
@@ -696,7 +739,7 @@ static int iwl_mvm_sta_tx_agg(struct iwl_mvm *mvm, struct ieee80211_sta *sta,
  return ret;
 }
 
-static const u8 tid_to_ac[] = {
+const u8 tid_to_mac80211_ac[] = {
  IEEE80211_AC_BE,
  IEEE80211_AC_BK,
  IEEE80211_AC_BK,
@@ -707,10 +750,21 @@ static const u8 tid_to_ac[] = {
  IEEE80211_AC_VO,
 };
 
+static const u8 tid_to_ucode_ac[] = {
+ AC_BE,
+ AC_BK,
+ AC_BK,
+ AC_BE,
+ AC_VI,
+ AC_VI,
+ AC_VO,
+ AC_VO,
+};
+
 int iwl_mvm_sta_tx_agg_start(struct iwl_mvm *mvm, struct ieee80211_vif *vif,
         struct ieee80211_sta *sta, u16 tid, u16 *ssn)
 {
- struct iwl_mvm_sta *mvmsta = (void *)sta->drv_priv;
+ struct iwl_mvm_sta *mvmsta = iwl_mvm_sta_from_mac80211(sta);
  struct iwl_mvm_tid_data *tid_data;
  int txq_id;
 
@@ -725,21 +779,29 @@ int iwl_mvm_sta_tx_agg_start(struct iwl_mvm *mvm, struct ieee80211_vif *vif,
 
  lockdep_assert_held(&mvm->mutex);
 
- for (txq_id = IWL_MVM_FIRST_AGG_QUEUE;
-      txq_id <= IWL_MVM_LAST_AGG_QUEUE; txq_id++)
+ for (txq_id = mvm->first_agg_queue;
+      txq_id <= mvm->last_agg_queue; txq_id++)
   if (mvm->queue_to_mac80211[txq_id] ==
       IWL_INVALID_MAC80211_QUEUE)
    break;
 
- if (txq_id > IWL_MVM_LAST_AGG_QUEUE) {
+ if (txq_id > mvm->last_agg_queue) {
   IWL_ERR(mvm, "Failed to allocate agg queue\n");
   return -EIO;
  }
 
+ spin_lock_bh(&mvmsta->lock);
+
+ /* possible race condition - we entered D0i3 while starting agg */
+ if (test_bit(IWL_MVM_STATUS_IN_D0I3, &mvm->status)) {
+  spin_unlock_bh(&mvmsta->lock);
+  IWL_ERR(mvm, "Entered D0i3 while starting Tx agg\n");
+  return -EIO;
+ }
+
  /* the new tx queue is still connected to the same mac80211 queue */
- mvm->queue_to_mac80211[txq_id] = vif->hw_queue[tid_to_ac[tid]];
+ mvm->queue_to_mac80211[txq_id] = vif->hw_queue[tid_to_mac80211_ac[tid]];
 
- spin_lock_bh(&mvmsta->lock);
  tid_data = &mvmsta->tid_data[tid];
  tid_data->ssn = IEEE80211_SEQ_TO_SN(tid_data->seq_number);
  tid_data->txq_id = txq_id;
@@ -765,7 +827,7 @@ int iwl_mvm_sta_tx_agg_start(struct iwl_mvm *mvm, struct ieee80211_vif *vif,
 int iwl_mvm_sta_tx_agg_oper(struct iwl_mvm *mvm, struct ieee80211_vif *vif,
        struct ieee80211_sta *sta, u16 tid, u8 buf_size)
 {
- struct iwl_mvm_sta *mvmsta = (void *)sta->drv_priv;
+ struct iwl_mvm_sta *mvmsta = iwl_mvm_sta_from_mac80211(sta);
  struct iwl_mvm_tid_data *tid_data = &mvmsta->tid_data[tid];
  int queue, fifo, ret;
  u16 ssn;
@@ -779,7 +841,7 @@ int iwl_mvm_sta_tx_agg_oper(struct iwl_mvm *mvm, struct ieee80211_vif *vif,
  tid_data->ssn = 0xffff;
  spin_unlock_bh(&mvmsta->lock);
 
- fifo = iwl_mvm_ac_to_tx_fifo[tid_to_ac[tid]];
+ fifo = iwl_mvm_ac_to_tx_fifo[tid_to_mac80211_ac[tid]];
 
  ret = iwl_mvm_sta_tx_agg(mvm, sta, tid, queue, true);
  if (ret)
@@ -799,28 +861,16 @@ int iwl_mvm_sta_tx_agg_oper(struct iwl_mvm *mvm, struct ieee80211_vif *vif,
   min(mvmsta->max_agg_bufsize, buf_size);
  mvmsta->lq_sta.lq.agg_frame_cnt_limit = mvmsta->max_agg_bufsize;
 
- if (mvm->cfg->ht_params->use_rts_for_aggregation) {
-  /*
-   * switch to RTS/CTS if it is the prefer protection
-   * method for HT traffic
-   */
-  mvmsta->lq_sta.lq.flags |= LQ_FLAG_SET_STA_TLC_RTS_MSK;
-  /*
-   * TODO: remove the TLC_RTS flag when we tear down the last
-   * AGG session (agg_tids_count in DVM)
-   */
- }
-
  IWL_DEBUG_HT(mvm, "Tx aggregation enabled on ra = %pM tid = %d\n",
        sta->addr, tid);
 
- return iwl_mvm_send_lq_cmd(mvm, &mvmsta->lq_sta.lq, CMD_ASYNC, false);
+ return iwl_mvm_send_lq_cmd(mvm, &mvmsta->lq_sta.lq, false);
 }
 
 int iwl_mvm_sta_tx_agg_stop(struct iwl_mvm *mvm, struct ieee80211_vif *vif,
        struct ieee80211_sta *sta, u16 tid)
 {
- struct iwl_mvm_sta *mvmsta = (void *)sta->drv_priv;
+ struct iwl_mvm_sta *mvmsta = iwl_mvm_sta_from_mac80211(sta);
  struct iwl_mvm_tid_data *tid_data = &mvmsta->tid_data[tid];
  u16 txq_id;
  int err;
@@ -892,7 +942,7 @@ int iwl_mvm_sta_tx_agg_stop(struct iwl_mvm *mvm, struct ieee80211_vif *vif,
 int iwl_mvm_sta_tx_agg_flush(struct iwl_mvm *mvm, struct ieee80211_vif *vif,
        struct ieee80211_sta *sta, u16 tid)
 {
- struct iwl_mvm_sta *mvmsta = (void *)sta->drv_priv;
+ struct iwl_mvm_sta *mvmsta = iwl_mvm_sta_from_mac80211(sta);
  struct iwl_mvm_tid_data *tid_data = &mvmsta->tid_data[tid];
  u16 txq_id;
  enum iwl_mvm_agg_state old_state;
@@ -967,8 +1017,8 @@ static int iwl_mvm_send_sta_key(struct iwl_mvm *mvm,
     u8 sta_id, u32 tkip_iv32, u16 *tkip_p1k,
     u32 cmd_flags)
 {
+ struct iwl_mvm_add_sta_key_cmd cmd = {};
  __le16 key_flags;
- struct iwl_mvm_add_sta_cmd cmd = {};
  int ret, status;
  u16 keyidx;
  int i;
@@ -981,37 +1031,34 @@ static int iwl_mvm_send_sta_key(struct iwl_mvm *mvm,
  switch (keyconf->cipher) {
  case WLAN_CIPHER_SUITE_TKIP:
   key_flags |= cpu_to_le16(STA_KEY_FLG_TKIP);
-  cmd.key.tkip_rx_tsc_byte2 = tkip_iv32;
+  cmd.tkip_rx_tsc_byte2 = tkip_iv32;
   for (i = 0; i < 5; i++)
-   cmd.key.tkip_rx_ttak[i] = cpu_to_le16(tkip_p1k[i]);
-  memcpy(cmd.key.key, keyconf->key, keyconf->keylen);
+   cmd.tkip_rx_ttak[i] = cpu_to_le16(tkip_p1k[i]);
+  memcpy(cmd.key, keyconf->key, keyconf->keylen);
   break;
  case WLAN_CIPHER_SUITE_CCMP:
   key_flags |= cpu_to_le16(STA_KEY_FLG_CCM);
-  memcpy(cmd.key.key, keyconf->key, keyconf->keylen);
+  memcpy(cmd.key, keyconf->key, keyconf->keylen);
   break;
  default:
-  WARN_ON(1);
-  return -EINVAL;
+  key_flags |= cpu_to_le16(STA_KEY_FLG_EXT);
+  memcpy(cmd.key, keyconf->key, keyconf->keylen);
  }
 
  if (!(keyconf->flags & IEEE80211_KEY_FLAG_PAIRWISE))
   key_flags |= cpu_to_le16(STA_KEY_MULTICAST);
 
- cmd.mac_id_n_color = cpu_to_le32(mvm_sta->mac_id_n_color);
- cmd.key.key_offset = keyconf->hw_key_idx;
- cmd.key.key_flags = key_flags;
- cmd.add_modify = STA_MODE_MODIFY;
- cmd.modify_mask = STA_MODIFY_KEY;
+ cmd.key_offset = keyconf->hw_key_idx;
+ cmd.key_flags = key_flags;
  cmd.sta_id = sta_id;
 
  status = ADD_STA_SUCCESS;
- if (cmd_flags == CMD_SYNC)
-  ret = iwl_mvm_send_cmd_pdu_status(mvm, ADD_STA, sizeof(cmd),
-        &cmd, &status);
+ if (cmd_flags & CMD_ASYNC)
+  ret =  iwl_mvm_send_cmd_pdu(mvm, ADD_STA_KEY, CMD_ASYNC,
+         sizeof(cmd), &cmd);
  else
-  ret = iwl_mvm_send_cmd_pdu(mvm, ADD_STA, CMD_ASYNC,
-        sizeof(cmd), &cmd);
+  ret = iwl_mvm_send_cmd_pdu_status(mvm, ADD_STA_KEY, sizeof(cmd),
+        &cmd, &status);
 
  switch (status) {
  case ADD_STA_SUCCESS:
@@ -1064,7 +1111,7 @@ static int iwl_mvm_send_sta_igtk(struct iwl_mvm *mvm,
          remove_key ? "removing" : "installing",
          igtk_cmd.sta_id);
 
- return iwl_mvm_send_cmd_pdu(mvm, MGMT_MCAST_KEY, CMD_SYNC,
+ return iwl_mvm_send_cmd_pdu(mvm, MGMT_MCAST_KEY, 0,
         sizeof(igtk_cmd), &igtk_cmd);
 }
 
@@ -1151,15 +1198,15 @@ int iwl_mvm_set_sta_key(struct iwl_mvm *mvm,
   ieee80211_get_key_rx_seq(keyconf, 0, &seq);
   ieee80211_get_tkip_rx_p1k(keyconf, addr, seq.tkip.iv32, p1k);
   ret = iwl_mvm_send_sta_key(mvm, mvm_sta, keyconf, sta_id,
-        seq.tkip.iv32, p1k, CMD_SYNC);
+        seq.tkip.iv32, p1k, 0);
   break;
  case WLAN_CIPHER_SUITE_CCMP:
   ret = iwl_mvm_send_sta_key(mvm, mvm_sta, keyconf, sta_id,
-        0, NULL, CMD_SYNC);
+        0, NULL, 0);
   break;
  default:
-  IWL_ERR(mvm, "Unknown cipher %x\n", keyconf->cipher);
-  ret = -EINVAL;
+  ret = iwl_mvm_send_sta_key(mvm, mvm_sta, keyconf,
+        sta_id, 0, NULL, 0);
  }
 
  if (ret)
@@ -1178,7 +1225,7 @@ int iwl_mvm_remove_sta_key(struct iwl_mvm *mvm,
       struct ieee80211_key_conf *keyconf)
 {
  struct iwl_mvm_sta *mvm_sta;
- struct iwl_mvm_add_sta_cmd cmd = {};
+ struct iwl_mvm_add_sta_key_cmd cmd = {};
  __le16 key_flags;
  int ret, status;
  u8 sta_id;
@@ -1233,16 +1280,12 @@ int iwl_mvm_remove_sta_key(struct iwl_mvm *mvm,
  if (!(keyconf->flags & IEEE80211_KEY_FLAG_PAIRWISE))
   key_flags |= cpu_to_le16(STA_KEY_MULTICAST);
 
- cmd.mac_id_n_color = cpu_to_le32(mvm_sta->mac_id_n_color);
- cmd.key.key_flags = key_flags;
- cmd.key.key_offset = keyconf->hw_key_idx;
+ cmd.key_flags = key_flags;
+ cmd.key_offset = keyconf->hw_key_idx;
  cmd.sta_id = sta_id;
 
- cmd.modify_mask = STA_MODIFY_KEY;
- cmd.add_modify = STA_MODE_MODIFY;
-
  status = ADD_STA_SUCCESS;
- ret = iwl_mvm_send_cmd_pdu_status(mvm, ADD_STA, sizeof(cmd),
+ ret = iwl_mvm_send_cmd_pdu_status(mvm, ADD_STA_KEY, sizeof(cmd),
        &cmd, &status);
 
  switch (status) {
@@ -1289,7 +1332,7 @@ void iwl_mvm_update_tkip_key(struct iwl_mvm *mvm,
 void iwl_mvm_sta_modify_ps_wake(struct iwl_mvm *mvm,
     struct ieee80211_sta *sta)
 {
- struct iwl_mvm_sta *mvmsta = (void *)sta->drv_priv;
+ struct iwl_mvm_sta *mvmsta = iwl_mvm_sta_from_mac80211(sta);
  struct iwl_mvm_add_sta_cmd cmd = {
   .add_modify = STA_MODE_MODIFY,
   .sta_id = mvmsta->sta_id,
@@ -1306,28 +1349,102 @@ void iwl_mvm_sta_modify_ps_wake(struct iwl_mvm *mvm,
 void iwl_mvm_sta_modify_sleep_tx_count(struct iwl_mvm *mvm,
            struct ieee80211_sta *sta,
            enum ieee80211_frame_release_type reason,
-           u16 cnt)
+           u16 cnt, u16 tids, bool more_data,
+           bool agg)
 {
- u16 sleep_state_flags =
-  (reason == IEEE80211_FRAME_RELEASE_UAPSD) ?
-   STA_SLEEP_STATE_UAPSD : STA_SLEEP_STATE_PS_POLL;
- struct iwl_mvm_sta *mvmsta = (void *)sta->drv_priv;
+ struct iwl_mvm_sta *mvmsta = iwl_mvm_sta_from_mac80211(sta);
  struct iwl_mvm_add_sta_cmd cmd = {
   .add_modify = STA_MODE_MODIFY,
   .sta_id = mvmsta->sta_id,
   .modify_mask = STA_MODIFY_SLEEPING_STA_TX_COUNT,
   .sleep_tx_count = cpu_to_le16(cnt),
   .mac_id_n_color = cpu_to_le32(mvmsta->mac_id_n_color),
-  /*
-   * Same modify mask for sleep_tx_count and sleep_state_flags so
-   * we must set the sleep_state_flags too.
-   */
-  .sleep_state_flags = cpu_to_le16(sleep_state_flags),
  };
- int ret;
+ int tid, ret;
+ unsigned long _tids = tids;
+
+ /* convert TIDs to ACs - we don't support TSPEC so that's OK
+  * Note that this field is reserved and unused by firmware not
+  * supporting GO uAPSD, so it's safe to always do this.
+  */
+ for_each_set_bit(tid, &_tids, IWL_MAX_TID_COUNT)
+  cmd.awake_acs |= BIT(tid_to_ucode_ac[tid]);
+
+ /* If we're releasing frames from aggregation queues then check if the
+  * all queues combined that we're releasing frames from have
+  *  - more frames than the service period, in which case more_data
+  *    needs to be set
+  *  - fewer than 'cnt' frames, in which case we need to adjust the
+  *    firmware command (but do that unconditionally)
+  */
+ if (agg) {
+  int remaining = cnt;
+
+  spin_lock_bh(&mvmsta->lock);
+  for_each_set_bit(tid, &_tids, IWL_MAX_TID_COUNT) {
+   struct iwl_mvm_tid_data *tid_data;
+   u16 n_queued;
+
+   tid_data = &mvmsta->tid_data[tid];
+   if (WARN(tid_data->state != IWL_AGG_ON &&
+     tid_data->state != IWL_EMPTYING_HW_QUEUE_DELBA,
+     "TID %d state is %d\n",
+     tid, tid_data->state)) {
+    spin_unlock_bh(&mvmsta->lock);
+    ieee80211_sta_eosp(sta);
+    return;
+   }
+
+   n_queued = iwl_mvm_tid_queued(tid_data);
+   if (n_queued > remaining) {
+    more_data = true;
+    remaining = 0;
+    break;
+   }
+   remaining -= n_queued;
+  }
+  spin_unlock_bh(&mvmsta->lock);
+
+  cmd.sleep_tx_count = cpu_to_le16(cnt - remaining);
+  if (WARN_ON(cnt - remaining == 0)) {
+   ieee80211_sta_eosp(sta);
+   return;
+  }
+ }
+
+ /* Note: this is ignored by firmware not supporting GO uAPSD */
+ if (more_data)
+  cmd.sleep_state_flags |= cpu_to_le16(STA_SLEEP_STATE_MOREDATA);
+
+ if (reason == IEEE80211_FRAME_RELEASE_PSPOLL) {
+  mvmsta->next_status_eosp = true;
+  cmd.sleep_state_flags |= cpu_to_le16(STA_SLEEP_STATE_PS_POLL);
+ } else {
+  cmd.sleep_state_flags |= cpu_to_le16(STA_SLEEP_STATE_UAPSD);
+ }
 
- /* TODO: somehow the fw doesn't seem to take PS_POLL into account */
  ret = iwl_mvm_send_cmd_pdu(mvm, ADD_STA, CMD_ASYNC, sizeof(cmd), &cmd);
  if (ret)
   IWL_ERR(mvm, "Failed to send ADD_STA command (%d)\n", ret);
 }
+
+int iwl_mvm_rx_eosp_notif(struct iwl_mvm *mvm,
+     struct iwl_rx_cmd_buffer *rxb,
+     struct iwl_device_cmd *cmd)
+{
+ struct iwl_rx_packet *pkt = rxb_addr(rxb);
+ struct iwl_mvm_eosp_notification *notif = (void *)pkt->data;
+ struct ieee80211_sta *sta;
+ u32 sta_id = le32_to_cpu(notif->sta_id);
+
+ if (WARN_ON_ONCE(sta_id >= IWL_MVM_STATION_COUNT))
+  return 0;
+
+ rcu_read_lock();
+ sta = rcu_dereference(mvm->fw_id_to_mac_id[sta_id]);
+ if (!IS_ERR_OR_NULL(sta))
+  ieee80211_sta_eosp(sta);
+ rcu_read_unlock();
+
+ return 0;
+}
diff --git a/drivers/net/wireless/iwlwifi/mvm/sta.h b/drivers/net/wireless/iwlwifi/mvm/sta.h
index a4ddce7..d98e8a2 100644
--- a/drivers/net/wireless/iwlwifi/mvm/sta.h
+++ b/drivers/net/wireless/iwlwifi/mvm/sta.h
@@ -5,7 +5,7 @@
  *
  * GPL LICENSE SUMMARY
  *
- * Copyright(c) 2012 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2012 - 2014 Intel Corporation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of version 2 of the GNU General Public License as
@@ -30,7 +30,7 @@
  *
  * BSD LICENSE
  *
- * Copyright(c) 2012 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2012 - 2014 Intel Corporation. All rights reserved.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -195,24 +195,33 @@ struct iwl_mvm;
 /**
  * DOC: AP mode - PS
  *
- * When a station is asleep, the fw will set it as "asleep". All the
- * non-aggregation frames to that station will be dropped by the fw
- * (%TX_STATUS_FAIL_DEST_PS failure code).
+ * When a station is asleep, the fw will set it as "asleep". All frames on
+ * shared queues (i.e. non-aggregation queues) to that station will be dropped
+ * by the fw (%TX_STATUS_FAIL_DEST_PS failure code).
+ *
  * AMPDUs are in a separate queue that is stopped by the fw. We just need to
- * let mac80211 know how many frames we have in these queues so that it can
+ * let mac80211 know when there are frames in these queues so that it can
  * properly handle trigger frames.
- * When the a trigger frame is received, mac80211 tells the driver to send
- * frames from the AMPDU queues or AC queue depending on which queue are
- * delivery-enabled and what TID has frames to transmit (Note that mac80211 has
- * all the knowledege since all the non-agg frames are buffered / filtered, and
- * the driver tells mac80211 about agg frames). The driver needs to tell the fw
- * to let frames out even if the station is asleep. This is done by
- * %iwl_mvm_sta_modify_sleep_tx_count.
- * When we receive a frame from that station with PM bit unset, the
- * driver needs to let the fw know that this station isn't alseep any more.
- * This is done by %iwl_mvm_sta_modify_ps_wake.
- *
- * TODO - EOSP handling
+ *
+ * When a trigger frame is received, mac80211 tells the driver to send frames
+ * from the AMPDU queues or sends frames to non-aggregation queues itself,
+ * depending on which ACs are delivery-enabled and what TID has frames to
+ * transmit. Note that mac80211 has all the knowledege since all the non-agg
+ * frames are buffered / filtered, and the driver tells mac80211 about agg
+ * frames). The driver needs to tell the fw to let frames out even if the
+ * station is asleep. This is done by %iwl_mvm_sta_modify_sleep_tx_count.
+ *
+ * When we receive a frame from that station with PM bit unset, the driver
+ * needs to let the fw know that this station isn't asleep any more. This is
+ * done by %iwl_mvm_sta_modify_ps_wake in response to mac80211 signalling the
+ * station's wakeup.
+ *
+ * For a GO, the Service Period might be cut short due to an absence period
+ * of the GO. In this (and all other cases) the firmware notifies us with the
+ * EOSP_NOTIFICATION, and we notify mac80211 of that. Further frames that we
+ * already sent to the device will be rejected again.
+ *
+ * See also "AP support for powersaving clients" in mac80211.h.
  */
 
 /**
@@ -244,25 +253,32 @@ enum iwl_mvm_agg_state {
  * This is basically (last acked packet++).
  * @rate_n_flags: Rate at which Tx was attempted. Holds the data between the
  * Tx response (TX_CMD), and the block ack notification (COMPRESSED_BA).
+ * @reduced_tpc: Reduced tx power. Holds the data between the
+ * Tx response (TX_CMD), and the block ack notification (COMPRESSED_BA).
  * @state: state of the BA agreement establishment / tear down.
  * @txq_id: Tx queue used by the BA session
  * @ssn: the first packet to be sent in AGG HW queue in Tx AGG start flow, or
  * the first packet to be sent in legacy HW queue in Tx AGG stop flow.
  * Basically when next_reclaimed reaches ssn, we can tell mac80211 that
  * we are ready to finish the Tx AGG stop / start flow.
- * @wait_for_ba: Expect block-ack before next Tx reply
  */
 struct iwl_mvm_tid_data {
  u16 seq_number;
  u16 next_reclaimed;
  /* The rest is Tx AGG related */
  u32 rate_n_flags;
+ u8 reduced_tpc;
  enum iwl_mvm_agg_state state;
  u16 txq_id;
  u16 ssn;
- bool wait_for_ba;
 };
 
+static inline u16 iwl_mvm_tid_queued(struct iwl_mvm_tid_data *tid_data)
+{
+ return ieee80211_sn_sub(IEEE80211_SEQ_TO_SN(tid_data->seq_number),
+    tid_data->next_reclaimed);
+}
+
 /**
  * struct iwl_mvm_sta - representation of a station in the driver
  * @sta_id: the index of the station in the fw (will be replaced by id_n_color)
@@ -272,9 +288,13 @@ struct iwl_mvm_tid_data {
  * tid.
  * @max_agg_bufsize: the maximal size of the AGG buffer for this station
  * @bt_reduced_txpower: is reduced tx power enabled for this station
+ * @next_status_eosp: the next reclaimed packet is a PS-Poll response and
+ * we need to signal the EOSP
  * @lock: lock to protect the whole struct. Since %tid_data is access from Tx
  * and from Tx response flow, it needs a spinlock.
  * @tid_data: per tid data. Look at %iwl_mvm_tid_data.
+ * @tx_protection: reference counter for controlling the Tx protection.
+ * @tt_tx_protection: is thermal throttling enable Tx protection?
  *
  * When mac80211 creates a station it reserves some space (hw->sta_data_size)
  * in the structure for use by driver. This structure is placed in that
@@ -288,16 +308,23 @@ struct iwl_mvm_sta {
  u16 tid_disable_agg;
  u8 max_agg_bufsize;
  bool bt_reduced_txpower;
+ bool next_status_eosp;
  spinlock_t lock;
  struct iwl_mvm_tid_data tid_data[IWL_MAX_TID_COUNT];
  struct iwl_lq_sta lq_sta;
  struct ieee80211_vif *vif;
 
-#ifdef CONFIG_PM_SLEEP
- u16 last_seq_ctl;
-#endif
+ /* Temporary, until the new TLC will control the Tx protection */
+ s8 tx_protection;
+ bool tt_tx_protection;
 };
 
+static inline struct iwl_mvm_sta *
+iwl_mvm_sta_from_mac80211(struct ieee80211_sta *sta)
+{
+ return (void *)sta->drv_priv;
+}
+
 /**
  * struct iwl_mvm_int_sta - representation of an internal station (auxiliary or
  * broadcast)
@@ -339,6 +366,10 @@ void iwl_mvm_update_tkip_key(struct iwl_mvm *mvm,
         struct ieee80211_sta *sta, u32 iv32,
         u16 *phase1key);
 
+int iwl_mvm_rx_eosp_notif(struct iwl_mvm *mvm,
+     struct iwl_rx_cmd_buffer *rxb,
+     struct iwl_device_cmd *cmd);
+
 /* AMPDU */
 int iwl_mvm_sta_rx_agg(struct iwl_mvm *mvm, struct ieee80211_sta *sta,
          int tid, u16 ssn, bool start);
@@ -353,7 +384,7 @@ int iwl_mvm_sta_tx_agg_flush(struct iwl_mvm *mvm, struct ieee80211_vif *vif,
 
 int iwl_mvm_add_aux_sta(struct iwl_mvm *mvm);
 int iwl_mvm_allocate_int_sta(struct iwl_mvm *mvm, struct iwl_mvm_int_sta *sta,
-        u32 qmask);
+        u32 qmask, enum nl80211_iftype iftype);
 void iwl_mvm_dealloc_int_sta(struct iwl_mvm *mvm,
         struct iwl_mvm_int_sta *sta);
 int iwl_mvm_send_bcast_sta(struct iwl_mvm *mvm, struct ieee80211_vif *vif,
@@ -369,7 +400,8 @@ void iwl_mvm_sta_modify_ps_wake(struct iwl_mvm *mvm,
 void iwl_mvm_sta_modify_sleep_tx_count(struct iwl_mvm *mvm,
            struct ieee80211_sta *sta,
            enum ieee80211_frame_release_type reason,
-           u16 cnt);
+           u16 cnt, u16 tids, bool more_data,
+           bool agg);
 int iwl_mvm_drain_sta(struct iwl_mvm *mvm, struct iwl_mvm_sta *mvmsta,
         bool drain);
 
diff --git a/drivers/net/wireless/iwlwifi/mvm/testmode.h b/drivers/net/wireless/iwlwifi/mvm/testmode.h
new file mode 100644
index 0000000..0241665
--- /dev/null
+++ b/drivers/net/wireless/iwlwifi/mvm/testmode.h
@@ -0,0 +1,95 @@
+/******************************************************************************
+ *
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ * redistributing this file, you may do so under either license.
+ *
+ * GPL LICENSE SUMMARY
+ *
+ * Copyright(c) 2013 - 2014 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110,
+ * USA
+ *
+ * The full GNU General Public License is included in this distribution
+ * in the file called COPYING.
+ *
+ * Contact Information:
+ *  Intel Linux Wireless <ilw@linux.intel.com>
+ * Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497
+ *
+ * BSD LICENSE
+ *
+ * Copyright(c) 2013 - 2014 Intel Corporation. All rights reserved.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *  * Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *  * Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *  * Neither the name Intel Corporation nor the names of its
+ *    contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *****************************************************************************/
+
+#ifndef __IWL_MVM_TESTMODE_H__
+#define __IWL_MVM_TESTMODE_H__
+
+/**
+ * enum iwl_mvm_testmode_attrs - testmode attributes inside NL80211_ATTR_TESTDATA
+ * @IWL_MVM_TM_ATTR_UNSPEC: (invalid attribute)
+ * @IWL_MVM_TM_ATTR_CMD: sub command, see &enum iwl_mvm_testmode_commands (u32)
+ * @IWL_MVM_TM_ATTR_NOA_DURATION: requested NoA duration (u32)
+ * @IWL_MVM_TM_ATTR_BEACON_FILTER_STATE: beacon filter state (0 or 1, u32)
+ */
+enum iwl_mvm_testmode_attrs {
+ IWL_MVM_TM_ATTR_UNSPEC,
+ IWL_MVM_TM_ATTR_CMD,
+ IWL_MVM_TM_ATTR_NOA_DURATION,
+ IWL_MVM_TM_ATTR_BEACON_FILTER_STATE,
+
+ /* keep last */
+ NUM_IWL_MVM_TM_ATTRS,
+ IWL_MVM_TM_ATTR_MAX = NUM_IWL_MVM_TM_ATTRS - 1,
+};
+
+/**
+ * enum iwl_mvm_testmode_commands - MVM testmode commands
+ * @IWL_MVM_TM_CMD_SET_NOA: set NoA on GO vif for testing
+ * @IWL_MVM_TM_CMD_SET_BEACON_FILTER: turn beacon filtering off/on
+ */
+enum iwl_mvm_testmode_commands {
+ IWL_MVM_TM_CMD_SET_NOA,
+ IWL_MVM_TM_CMD_SET_BEACON_FILTER,
+};
+
+#endif /* __IWL_MVM_TESTMODE_H__ */
diff --git a/drivers/net/wireless/iwlwifi/mvm/time-event.c b/drivers/net/wireless/iwlwifi/mvm/time-event.c
index ad9bbca..80100f6 100644
--- a/drivers/net/wireless/iwlwifi/mvm/time-event.c
+++ b/drivers/net/wireless/iwlwifi/mvm/time-event.c
@@ -5,7 +5,7 @@
  *
  * GPL LICENSE SUMMARY
  *
- * Copyright(c) 2012 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2012 - 2014 Intel Corporation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of version 2 of the GNU General Public License as
@@ -30,7 +30,7 @@
  *
  * BSD LICENSE
  *
- * Copyright(c) 2012 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2012 - 2014 Intel Corporation. All rights reserved.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -73,7 +73,6 @@
 #include "iwl-prph.h"
 
 /* A TimeUnit is 1024 microsecond */
-#define TU_TO_JIFFIES(_tu) (usecs_to_jiffies((_tu) * 1024))
 #define MSEC_TO_TU(_msec) (_msec*1000/1024)
 
 /*
@@ -127,6 +126,7 @@ static void iwl_mvm_roc_finished(struct iwl_mvm *mvm)
   * in iwl_mvm_te_handle_notif).
   */
  clear_bit(IWL_MVM_STATUS_ROC_RUNNING, &mvm->status);
+ iwl_mvm_unref(mvm, IWL_MVM_REF_ROC);
 
  /*
   * Of course, our status bit is just as racy as mac80211, so in
@@ -138,6 +138,20 @@ static void iwl_mvm_roc_finished(struct iwl_mvm *mvm)
  schedule_work(&mvm->roc_done_wk);
 }
 
+static bool iwl_mvm_te_check_disconnect(struct iwl_mvm *mvm,
+     struct ieee80211_vif *vif,
+     const char *errmsg)
+{
+ if (vif->type != NL80211_IFTYPE_STATION)
+  return false;
+ if (vif->bss_conf.assoc && vif->bss_conf.dtim_period)
+  return false;
+ if (errmsg)
+  IWL_ERR(mvm, "%s\n", errmsg);
+ ieee80211_connection_loss(vif);
+ return true;
+}
+
 /*
  * Handles a FW notification for an event that is known to the driver.
  *
@@ -163,10 +177,18 @@ static void iwl_mvm_te_handle_notif(struct iwl_mvm *mvm,
   * P2P Device discoveribility, while there are other higher priority
   * events in the system).
   */
- WARN_ONCE(!le32_to_cpu(notif->status),
-    "Failed to schedule time event\n");
+ if (!le32_to_cpu(notif->status)) {
+  bool start = le32_to_cpu(notif->action) &
+    TE_V2_NOTIF_HOST_EVENT_START;
+  IWL_WARN(mvm, "Time Event %s notification failure\n",
+    start ? "start" : "end");
+  if (iwl_mvm_te_check_disconnect(mvm, te_data->vif, NULL)) {
+   iwl_mvm_te_clear_data(mvm, te_data);
+   return;
+  }
+ }
 
- if (le32_to_cpu(notif->action) & TE_NOTIF_HOST_EVENT_END) {
+ if (le32_to_cpu(notif->action) & TE_V2_NOTIF_HOST_EVENT_END) {
   IWL_DEBUG_TE(mvm,
         "TE ended - current time %lu, estimated end %lu\n",
         jiffies, te_data->end_jiffies);
@@ -180,22 +202,16 @@ static void iwl_mvm_te_handle_notif(struct iwl_mvm *mvm,
    * By now, we should have finished association
    * and know the dtim period.
    */
-  if (te_data->vif->type == NL80211_IFTYPE_STATION &&
-      (!te_data->vif->bss_conf.assoc ||
-       !te_data->vif->bss_conf.dtim_period)) {
-   IWL_ERR(mvm,
-    "No assocation and the time event is over already...\n");
-   ieee80211_connection_loss(te_data->vif);
-  }
-
+  iwl_mvm_te_check_disconnect(mvm, te_data->vif,
+   "No association and the time event is over already...");
   iwl_mvm_te_clear_data(mvm, te_data);
- } else if (le32_to_cpu(notif->action) & TE_NOTIF_HOST_EVENT_START) {
+ } else if (le32_to_cpu(notif->action) & TE_V2_NOTIF_HOST_EVENT_START) {
   te_data->running = true;
-  te_data->end_jiffies = jiffies +
-   TU_TO_JIFFIES(te_data->duration);
+  te_data->end_jiffies = TU_TO_EXP_TIME(te_data->duration);
 
   if (te_data->vif->type == NL80211_IFTYPE_P2P_DEVICE) {
    set_bit(IWL_MVM_STATUS_ROC_RUNNING, &mvm->status);
+   iwl_mvm_ref(mvm, IWL_MVM_REF_ROC);
    ieee80211_ready_on_channel(mvm->hw);
   }
  } else {
@@ -235,12 +251,12 @@ static bool iwl_mvm_time_event_response(struct iwl_notif_wait_data *notif_wait,
   container_of(notif_wait, struct iwl_mvm, notif_wait);
  struct iwl_mvm_time_event_data *te_data = data;
  struct iwl_time_event_resp *resp;
- int resp_len = le32_to_cpu(pkt->len_n_flags) & FH_RSCSR_FRAME_SIZE_MSK;
+ int resp_len = iwl_rx_packet_payload_len(pkt);
 
  if (WARN_ON(pkt->hdr.cmd != TIME_EVENT_CMD))
   return true;
 
- if (WARN_ON_ONCE(resp_len != sizeof(pkt->hdr) + sizeof(*resp))) {
+ if (WARN_ON_ONCE(resp_len != sizeof(*resp))) {
   IWL_ERR(mvm, "Invalid TIME_EVENT_CMD response\n");
   return true;
  }
@@ -296,8 +312,8 @@ static int iwl_mvm_time_event_send_add(struct iwl_mvm *mvm,
        ARRAY_SIZE(time_event_response),
        iwl_mvm_time_event_response, te_data);
 
- ret = iwl_mvm_send_cmd_pdu(mvm, TIME_EVENT_CMD, CMD_SYNC,
-       sizeof(*te_cmd), te_cmd);
+ ret = iwl_mvm_send_cmd_pdu(mvm, TIME_EVENT_CMD, 0,
+         sizeof(*te_cmd), te_cmd);
  if (ret) {
   IWL_ERR(mvm, "Couldn't send TIME_EVENT_CMD: %d\n", ret);
   iwl_remove_notification(&mvm->notif_wait, &wait_time_event);
@@ -320,7 +336,8 @@ static int iwl_mvm_time_event_send_add(struct iwl_mvm *mvm,
 
 void iwl_mvm_protect_session(struct iwl_mvm *mvm,
         struct ieee80211_vif *vif,
-        u32 duration, u32 min_duration)
+        u32 duration, u32 min_duration,
+        u32 max_delay)
 {
  struct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);
  struct iwl_mvm_time_event_data *te_data = &mvmvif->time_event_data;
@@ -329,8 +346,7 @@ void iwl_mvm_protect_session(struct iwl_mvm *mvm,
  lockdep_assert_held(&mvm->mutex);
 
  if (te_data->running &&
-     time_after(te_data->end_jiffies,
-         jiffies + TU_TO_JIFFIES(min_duration))) {
+     time_after(te_data->end_jiffies, TU_TO_EXP_TIME(min_duration))) {
   IWL_DEBUG_TE(mvm, "We have enough time in the current TE: %u\n",
         jiffies_to_msecs(te_data->end_jiffies - jiffies));
   return;
@@ -359,17 +375,15 @@ void iwl_mvm_protect_session(struct iwl_mvm *mvm,
  time_cmd.apply_time =
   cpu_to_le32(iwl_read_prph(mvm->trans, DEVICE_SYSTEM_TIME_REG));
 
- time_cmd.dep_policy = TE_INDEPENDENT;
- time_cmd.is_present = cpu_to_le32(1);
- time_cmd.max_frags = cpu_to_le32(TE_FRAG_NONE);
- time_cmd.max_delay = cpu_to_le32(500);
+ time_cmd.max_frags = TE_V2_FRAG_NONE;
+ time_cmd.max_delay = cpu_to_le32(max_delay);
  /* TODO: why do we need to interval = bi if it is not periodic? */
  time_cmd.interval = cpu_to_le32(1);
- time_cmd.interval_reciprocal = cpu_to_le32(iwl_mvm_reciprocal(1));
  time_cmd.duration = cpu_to_le32(duration);
- time_cmd.repeat = cpu_to_le32(1);
- time_cmd.notify = cpu_to_le32(TE_NOTIF_HOST_EVENT_START |
-          TE_NOTIF_HOST_EVENT_END);
+ time_cmd.repeat = 1;
+ time_cmd.policy = cpu_to_le16(TE_V2_NOTIF_HOST_EVENT_START |
+          TE_V2_NOTIF_HOST_EVENT_END |
+          T2_V2_START_IMMEDIATELY);
 
  iwl_mvm_time_event_send_add(mvm, vif, te_data, &time_cmd);
 }
@@ -420,7 +434,7 @@ void iwl_mvm_remove_time_event(struct iwl_mvm *mvm,
   cpu_to_le32(FW_CMD_ID_AND_COLOR(mvmvif->id, mvmvif->color));
 
  IWL_DEBUG_TE(mvm, "Removing TE 0x%x\n", le32_to_cpu(time_cmd.id));
- ret = iwl_mvm_send_cmd_pdu(mvm, TIME_EVENT_CMD, CMD_SYNC,
+ ret = iwl_mvm_send_cmd_pdu(mvm, TIME_EVENT_CMD, 0,
        sizeof(time_cmd), &time_cmd);
  if (WARN_ON(ret))
   return;
@@ -472,8 +486,6 @@ int iwl_mvm_start_p2p_roc(struct iwl_mvm *mvm, struct ieee80211_vif *vif,
  }
 
  time_cmd.apply_time = cpu_to_le32(0);
- time_cmd.dep_policy = cpu_to_le32(TE_INDEPENDENT);
- time_cmd.is_present = cpu_to_le32(1);
  time_cmd.interval = cpu_to_le32(1);
 
  /*
@@ -482,12 +494,13 @@ int iwl_mvm_start_p2p_roc(struct iwl_mvm *mvm, struct ieee80211_vif *vif,
   * scheduled. To improve the chances of it being scheduled, allow them
   * to be fragmented, and in addition allow them to be delayed.
   */
- time_cmd.max_frags = cpu_to_le32(MSEC_TO_TU(duration)/20);
+ time_cmd.max_frags = min(MSEC_TO_TU(duration)/50, TE_V2_FRAG_ENDLESS);
  time_cmd.max_delay = cpu_to_le32(MSEC_TO_TU(duration/2));
  time_cmd.duration = cpu_to_le32(MSEC_TO_TU(duration));
- time_cmd.repeat = cpu_to_le32(1);
- time_cmd.notify = cpu_to_le32(TE_NOTIF_HOST_EVENT_START |
-          TE_NOTIF_HOST_EVENT_END);
+ time_cmd.repeat = 1;
+ time_cmd.policy = cpu_to_le16(TE_V2_NOTIF_HOST_EVENT_START |
+          TE_V2_NOTIF_HOST_EVENT_END |
+          T2_V2_START_IMMEDIATELY);
 
  return iwl_mvm_time_event_send_add(mvm, vif, te_data, &time_cmd);
 }
diff --git a/drivers/net/wireless/iwlwifi/mvm/time-event.h b/drivers/net/wireless/iwlwifi/mvm/time-event.h
index f86c510..4a61c8c 100644
--- a/drivers/net/wireless/iwlwifi/mvm/time-event.h
+++ b/drivers/net/wireless/iwlwifi/mvm/time-event.h
@@ -5,7 +5,7 @@
  *
  * GPL LICENSE SUMMARY
  *
- * Copyright(c) 2012 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2012 - 2014 Intel Corporation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of version 2 of the GNU General Public License as
@@ -30,7 +30,7 @@
  *
  * BSD LICENSE
  *
- * Copyright(c) 2012 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2012 - 2014 Intel Corporation. All rights reserved.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -123,6 +123,7 @@
  * @duration: the duration of the session in TU.
  * @min_duration: will start a new session if the current session will end
  * in less than min_duration.
+ * @max_delay: maximum delay before starting the time event (in TU)
  *
  * This function can be used to start a session protection which means that the
  * fw will stay on the channel for %duration_ms milliseconds. This function
@@ -133,7 +134,8 @@
  */
 void iwl_mvm_protect_session(struct iwl_mvm *mvm,
         struct ieee80211_vif *vif,
-        u32 duration, u32 min_duration);
+        u32 duration, u32 min_duration,
+        u32 max_delay);
 
 /**
  * iwl_mvm_stop_session_protection - cancel the session protection.
diff --git a/drivers/net/wireless/iwlwifi/mvm/tt.c b/drivers/net/wireless/iwlwifi/mvm/tt.c
new file mode 100644
index 0000000..8685615
--- /dev/null
+++ b/drivers/net/wireless/iwlwifi/mvm/tt.c
@@ -0,0 +1,560 @@
+/******************************************************************************
+ *
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ * redistributing this file, you may do so under either license.
+ *
+ * GPL LICENSE SUMMARY
+ *
+ * Copyright(c) 2013 - 2014 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110,
+ * USA
+ *
+ * The full GNU General Public License is included in this distribution
+ * in the file called COPYING.
+ *
+ * Contact Information:
+ *  Intel Linux Wireless <ilw@linux.intel.com>
+ * Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497
+ *
+ * BSD LICENSE
+ *
+ * Copyright(c) 2012 - 2014 Intel Corporation. All rights reserved.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *  * Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *  * Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *  * Neither the name Intel Corporation nor the names of its
+ *    contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *****************************************************************************/
+
+#include "mvm.h"
+#include "iwl-config.h"
+#include "iwl-io.h"
+#include "iwl-csr.h"
+#include "iwl-prph.h"
+
+#define OTP_DTS_DIODE_DEVIATION 96 /*in words*/
+/* VBG - Voltage Band Gap error data (temperature offset) */
+#define OTP_WP_DTS_VBG   (OTP_DTS_DIODE_DEVIATION + 2)
+#define MEAS_VBG_MIN_VAL  2300
+#define MEAS_VBG_MAX_VAL  3000
+#define MEAS_VBG_DEFAULT_VAL  2700
+#define DTS_DIODE_VALID(flags)  (flags & DTS_DIODE_REG_FLAGS_PASS_ONCE)
+#define MIN_TEMPERATURE   0
+#define MAX_TEMPERATURE   125
+#define TEMPERATURE_ERROR  (MAX_TEMPERATURE + 1)
+#define PTAT_DIGITAL_VALUE_MIN_VALUE 0
+#define PTAT_DIGITAL_VALUE_MAX_VALUE 0xFF
+#define DTS_VREFS_NUM   5
+static inline u32 DTS_DIODE_GET_VREFS_ID(u32 flags)
+{
+ return (flags & DTS_DIODE_REG_FLAGS_VREFS_ID) >>
+     DTS_DIODE_REG_FLAGS_VREFS_ID_POS;
+}
+
+#define CALC_VREFS_MIN_DIFF 43
+#define CALC_VREFS_MAX_DIFF 51
+#define CALC_LUT_SIZE  (1 + CALC_VREFS_MAX_DIFF - CALC_VREFS_MIN_DIFF)
+#define CALC_LUT_INDEX_OFFSET CALC_VREFS_MIN_DIFF
+#define CALC_TEMPERATURE_RESULT_SHIFT_OFFSET 23
+
+/*
+ * @digital_value: The diode's digital-value sampled (temperature/voltage)
+ * @vref_low: The lower voltage-reference (the vref just below the diode's
+ * sampled digital-value)
+ * @vref_high: The higher voltage-reference (the vref just above the diode's
+ * sampled digital-value)
+ * @flags: bits[1:0]: The ID of the Vrefs pair (lowVref,highVref)
+ * bits[6:2]: Reserved.
+ * bits[7:7]: Indicates completion of at least 1 successful sample
+ * since last DTS reset.
+ */
+struct iwl_mvm_dts_diode_bits {
+ u8 digital_value;
+ u8 vref_low;
+ u8 vref_high;
+ u8 flags;
+} __packed;
+
+union dts_diode_results {
+ u32 reg_value;
+ struct iwl_mvm_dts_diode_bits bits;
+} __packed;
+
+static s16 iwl_mvm_dts_get_volt_band_gap(struct iwl_mvm *mvm)
+{
+ struct iwl_nvm_section calib_sec;
+ const __le16 *calib;
+ u16 vbg;
+
+ /* TODO: move parsing to NVM code */
+ calib_sec = mvm->nvm_sections[NVM_SECTION_TYPE_CALIBRATION];
+ calib = (__le16 *)calib_sec.data;
+
+ vbg = le16_to_cpu(calib[OTP_WP_DTS_VBG]);
+
+ if (vbg < MEAS_VBG_MIN_VAL || vbg > MEAS_VBG_MAX_VAL)
+  vbg = MEAS_VBG_DEFAULT_VAL;
+
+ return vbg;
+}
+
+static u16 iwl_mvm_dts_get_ptat_deviation_offset(struct iwl_mvm *mvm)
+{
+ const u8 *calib;
+ u8 ptat, pa1, pa2, median;
+
+ /* TODO: move parsing to NVM code */
+ calib = mvm->nvm_sections[NVM_SECTION_TYPE_CALIBRATION].data;
+ ptat = calib[OTP_DTS_DIODE_DEVIATION];
+ pa1 = calib[OTP_DTS_DIODE_DEVIATION + 1];
+ pa2 = calib[OTP_DTS_DIODE_DEVIATION + 2];
+
+ /* get the median: */
+ if (ptat > pa1) {
+  if (ptat > pa2)
+   median = (pa1 > pa2) ? pa1 : pa2;
+  else
+   median = ptat;
+ } else {
+  if (pa1 > pa2)
+   median = (ptat > pa2) ? ptat : pa2;
+  else
+   median = pa1;
+ }
+
+ return ptat - median;
+}
+
+static u8 iwl_mvm_dts_calibrate_ptat_deviation(struct iwl_mvm *mvm, u8 value)
+{
+ /* Calibrate the PTAT digital value, based on PTAT deviation data: */
+ s16 new_val = value - iwl_mvm_dts_get_ptat_deviation_offset(mvm);
+
+ if (new_val > PTAT_DIGITAL_VALUE_MAX_VALUE)
+  new_val = PTAT_DIGITAL_VALUE_MAX_VALUE;
+ else if (new_val < PTAT_DIGITAL_VALUE_MIN_VALUE)
+  new_val = PTAT_DIGITAL_VALUE_MIN_VALUE;
+
+ return new_val;
+}
+
+static bool dts_get_adjacent_vrefs(struct iwl_mvm *mvm,
+       union dts_diode_results *avg_ptat)
+{
+ u8 vrefs_results[DTS_VREFS_NUM];
+ u8 low_vref_index = 0, flags;
+ u32 reg;
+
+ reg = iwl_read_prph(mvm->trans, DTSC_VREF_AVG);
+ memcpy(vrefs_results, &reg, sizeof(reg));
+ reg = iwl_read_prph(mvm->trans, DTSC_VREF5_AVG);
+ vrefs_results[4] = reg & 0xff;
+
+ if (avg_ptat->bits.digital_value < vrefs_results[0] ||
+     avg_ptat->bits.digital_value > vrefs_results[4])
+  return false;
+
+ if (avg_ptat->bits.digital_value > vrefs_results[3])
+  low_vref_index = 3;
+ else if (avg_ptat->bits.digital_value > vrefs_results[2])
+  low_vref_index = 2;
+ else if (avg_ptat->bits.digital_value > vrefs_results[1])
+  low_vref_index = 1;
+
+ avg_ptat->bits.vref_low  = vrefs_results[low_vref_index];
+ avg_ptat->bits.vref_high = vrefs_results[low_vref_index + 1];
+ flags = avg_ptat->bits.flags;
+ avg_ptat->bits.flags =
+  (flags & ~DTS_DIODE_REG_FLAGS_VREFS_ID) |
+  (low_vref_index & DTS_DIODE_REG_FLAGS_VREFS_ID);
+ return true;
+}
+
+/*
+ * return true it the results are valid, and false otherwise.
+ */
+static bool dts_read_ptat_avg_results(struct iwl_mvm *mvm,
+          union dts_diode_results *avg_ptat)
+{
+ u32 reg;
+ u8 tmp;
+
+ /* fill the diode value and pass_once with avg-reg results */
+ reg = iwl_read_prph(mvm->trans, DTSC_PTAT_AVG);
+ reg &= DTS_DIODE_REG_DIG_VAL | DTS_DIODE_REG_PASS_ONCE;
+ avg_ptat->reg_value = reg;
+
+ /* calibrate the PTAT digital value */
+ tmp = avg_ptat->bits.digital_value;
+ tmp = iwl_mvm_dts_calibrate_ptat_deviation(mvm, tmp);
+ avg_ptat->bits.digital_value = tmp;
+
+ /*
+  * fill vrefs fields, based on the avgVrefs results
+  * and the diode value
+  */
+ return dts_get_adjacent_vrefs(mvm, avg_ptat) &&
+  DTS_DIODE_VALID(avg_ptat->bits.flags);
+}
+
+static s32 calculate_nic_temperature(union dts_diode_results avg_ptat,
+         u16 volt_band_gap)
+{
+ u32 tmp_result;
+ u8 vrefs_diff;
+ /*
+  * For temperature calculation (at the end, shift right by 23)
+  * LUT[(D2-D1)] = ROUND{ 2^23 / ((D2-D1)*9*10) }
+  * (D2-D1) ==   43    44    45    46    47    48    49    50    51
+  */
+ static const u16 calc_lut[CALC_LUT_SIZE] = {
+  2168, 2118, 2071, 2026, 1983, 1942, 1902, 1864, 1828,
+ };
+
+ /*
+  * The diff between the high and low voltage-references is assumed
+  * to be strictly be in range of [60,68]
+  */
+ vrefs_diff = avg_ptat.bits.vref_high - avg_ptat.bits.vref_low;
+
+ if (vrefs_diff < CALC_VREFS_MIN_DIFF ||
+     vrefs_diff > CALC_VREFS_MAX_DIFF)
+  return TEMPERATURE_ERROR;
+
+ /* calculate the result: */
+ tmp_result =
+  vrefs_diff * (DTS_DIODE_GET_VREFS_ID(avg_ptat.bits.flags) + 9);
+ tmp_result += avg_ptat.bits.digital_value;
+ tmp_result -= avg_ptat.bits.vref_high;
+
+ /* multiply by the LUT value (based on the diff) */
+ tmp_result *= calc_lut[vrefs_diff - CALC_LUT_INDEX_OFFSET];
+
+ /*
+  * Get the BandGap (the voltage refereces source) error data
+  * (temperature offset)
+  */
+ tmp_result *= volt_band_gap;
+
+ /*
+  * here, tmp_result value can be up to 32-bits. We want to right-shift
+  * it *without* sign-extend.
+  */
+ tmp_result = tmp_result >> CALC_TEMPERATURE_RESULT_SHIFT_OFFSET;
+
+ /*
+  * at this point, tmp_result should be in the range:
+  * 200 <= tmp_result <= 365
+  */
+ return (s16)tmp_result - 240;
+}
+
+static s32 check_nic_temperature(struct iwl_mvm *mvm)
+{
+ u16 volt_band_gap;
+ union dts_diode_results avg_ptat;
+
+ volt_band_gap = iwl_mvm_dts_get_volt_band_gap(mvm);
+
+ /* disable DTS */
+ iwl_write_prph(mvm->trans, SHR_MISC_WFM_DTS_EN, 0);
+
+ /* SV initialization */
+ iwl_write_prph(mvm->trans, SHR_MISC_WFM_DTS_EN, 1);
+ iwl_write_prph(mvm->trans, DTSC_CFG_MODE,
+         DTSC_CFG_MODE_PERIODIC);
+
+ /* wait for results */
+ msleep(100);
+ if (!dts_read_ptat_avg_results(mvm, &avg_ptat))
+  return TEMPERATURE_ERROR;
+
+ /* disable DTS */
+ iwl_write_prph(mvm->trans, SHR_MISC_WFM_DTS_EN, 0);
+
+ return calculate_nic_temperature(avg_ptat, volt_band_gap);
+}
+
+static void iwl_mvm_enter_ctkill(struct iwl_mvm *mvm)
+{
+ u32 duration = mvm->thermal_throttle.params->ct_kill_duration;
+
+ IWL_ERR(mvm, "Enter CT Kill\n");
+ iwl_mvm_set_hw_ctkill_state(mvm, true);
+ schedule_delayed_work(&mvm->thermal_throttle.ct_kill_exit,
+         round_jiffies_relative(duration * HZ));
+}
+
+static void iwl_mvm_exit_ctkill(struct iwl_mvm *mvm)
+{
+ IWL_ERR(mvm, "Exit CT Kill\n");
+ iwl_mvm_set_hw_ctkill_state(mvm, false);
+}
+
+static void check_exit_ctkill(struct work_struct *work)
+{
+ struct iwl_mvm_tt_mgmt *tt;
+ struct iwl_mvm *mvm;
+ u32 duration;
+ s32 temp;
+
+ tt = container_of(work, struct iwl_mvm_tt_mgmt, ct_kill_exit.work);
+ mvm = container_of(tt, struct iwl_mvm, thermal_throttle);
+
+ duration = tt->params->ct_kill_duration;
+
+ iwl_trans_start_hw(mvm->trans);
+ temp = check_nic_temperature(mvm);
+ iwl_trans_stop_device(mvm->trans);
+
+ if (temp < MIN_TEMPERATURE || temp > MAX_TEMPERATURE) {
+  IWL_DEBUG_TEMP(mvm, "Failed to measure NIC temperature\n");
+  goto reschedule;
+ }
+ IWL_DEBUG_TEMP(mvm, "NIC temperature: %d\n", temp);
+
+ if (temp <= tt->params->ct_kill_exit) {
+  iwl_mvm_exit_ctkill(mvm);
+  return;
+ }
+
+reschedule:
+ schedule_delayed_work(&mvm->thermal_throttle.ct_kill_exit,
+         round_jiffies(duration * HZ));
+}
+
+static void iwl_mvm_tt_smps_iterator(void *_data, u8 *mac,
+         struct ieee80211_vif *vif)
+{
+ struct iwl_mvm *mvm = _data;
+ enum ieee80211_smps_mode smps_mode;
+
+ lockdep_assert_held(&mvm->mutex);
+
+ if (mvm->thermal_throttle.dynamic_smps)
+  smps_mode = IEEE80211_SMPS_DYNAMIC;
+ else
+  smps_mode = IEEE80211_SMPS_AUTOMATIC;
+
+ if (vif->type != NL80211_IFTYPE_STATION)
+  return;
+
+ iwl_mvm_update_smps(mvm, vif, IWL_MVM_SMPS_REQ_TT, smps_mode);
+}
+
+static void iwl_mvm_tt_tx_protection(struct iwl_mvm *mvm, bool enable)
+{
+ struct ieee80211_sta *sta;
+ struct iwl_mvm_sta *mvmsta;
+ int i, err;
+
+ for (i = 0; i < IWL_MVM_STATION_COUNT; i++) {
+  sta = rcu_dereference_protected(mvm->fw_id_to_mac_id[i],
+      lockdep_is_held(&mvm->mutex));
+  if (IS_ERR_OR_NULL(sta))
+   continue;
+  mvmsta = iwl_mvm_sta_from_mac80211(sta);
+  if (enable == mvmsta->tt_tx_protection)
+   continue;
+  err = iwl_mvm_tx_protection(mvm, mvmsta, enable);
+  if (err) {
+   IWL_ERR(mvm, "Failed to %s Tx protection\n",
+    enable ? "enable" : "disable");
+  } else {
+   IWL_DEBUG_TEMP(mvm, "%s Tx protection\n",
+           enable ? "Enable" : "Disable");
+   mvmsta->tt_tx_protection = enable;
+  }
+ }
+}
+
+void iwl_mvm_tt_tx_backoff(struct iwl_mvm *mvm, u32 backoff)
+{
+ struct iwl_host_cmd cmd = {
+  .id = REPLY_THERMAL_MNG_BACKOFF,
+  .len = { sizeof(u32), },
+  .data = { &backoff, },
+ };
+
+ backoff = max(backoff, mvm->thermal_throttle.min_backoff);
+
+ if (iwl_mvm_send_cmd(mvm, &cmd) == 0) {
+  IWL_DEBUG_TEMP(mvm, "Set Thermal Tx backoff to: %u\n",
+          backoff);
+  mvm->thermal_throttle.tx_backoff = backoff;
+ } else {
+  IWL_ERR(mvm, "Failed to change Thermal Tx backoff\n");
+ }
+}
+
+void iwl_mvm_tt_handler(struct iwl_mvm *mvm)
+{
+ const struct iwl_tt_params *params = mvm->thermal_throttle.params;
+ struct iwl_mvm_tt_mgmt *tt = &mvm->thermal_throttle;
+ s32 temperature = mvm->temperature;
+ bool throttle_enable = false;
+ int i;
+ u32 tx_backoff;
+
+ IWL_DEBUG_TEMP(mvm, "NIC temperature: %d\n", mvm->temperature);
+
+ if (params->support_ct_kill && temperature >= params->ct_kill_entry) {
+  iwl_mvm_enter_ctkill(mvm);
+  return;
+ }
+
+ if (params->support_dynamic_smps) {
+  if (!tt->dynamic_smps &&
+      temperature >= params->dynamic_smps_entry) {
+   IWL_DEBUG_TEMP(mvm, "Enable dynamic SMPS\n");
+   tt->dynamic_smps = true;
+   ieee80211_iterate_active_interfaces_atomic(
+     mvm->hw, IEEE80211_IFACE_ITER_NORMAL,
+     iwl_mvm_tt_smps_iterator, mvm);
+   throttle_enable = true;
+  } else if (tt->dynamic_smps &&
+      temperature <= params->dynamic_smps_exit) {
+   IWL_DEBUG_TEMP(mvm, "Disable dynamic SMPS\n");
+   tt->dynamic_smps = false;
+   ieee80211_iterate_active_interfaces_atomic(
+     mvm->hw, IEEE80211_IFACE_ITER_NORMAL,
+     iwl_mvm_tt_smps_iterator, mvm);
+  }
+ }
+
+ if (params->support_tx_protection) {
+  if (temperature >= params->tx_protection_entry) {
+   iwl_mvm_tt_tx_protection(mvm, true);
+   throttle_enable = true;
+  } else if (temperature <= params->tx_protection_exit) {
+   iwl_mvm_tt_tx_protection(mvm, false);
+  }
+ }
+
+ if (params->support_tx_backoff) {
+  tx_backoff = tt->min_backoff;
+  for (i = 0; i < TT_TX_BACKOFF_SIZE; i++) {
+   if (temperature < params->tx_backoff[i].temperature)
+    break;
+   tx_backoff = max(tt->min_backoff,
+      params->tx_backoff[i].backoff);
+  }
+  if (tx_backoff != tt->min_backoff)
+   throttle_enable = true;
+  if (tt->tx_backoff != tx_backoff)
+   iwl_mvm_tt_tx_backoff(mvm, tx_backoff);
+ }
+
+ if (!tt->throttle && throttle_enable) {
+  IWL_WARN(mvm,
+    "Due to high temperature thermal throttling initiated\n");
+  tt->throttle = true;
+ } else if (tt->throttle && !tt->dynamic_smps &&
+     tt->tx_backoff == tt->min_backoff &&
+     temperature <= params->tx_protection_exit) {
+  IWL_WARN(mvm,
+    "Temperature is back to normal thermal throttling stopped\n");
+  tt->throttle = false;
+ }
+}
+
+static const struct iwl_tt_params iwl7000_tt_params = {
+ .ct_kill_entry = 118,
+ .ct_kill_exit = 96,
+ .ct_kill_duration = 5,
+ .dynamic_smps_entry = 114,
+ .dynamic_smps_exit = 110,
+ .tx_protection_entry = 114,
+ .tx_protection_exit = 108,
+ .tx_backoff = {
+  {.temperature = 112, .backoff = 200},
+  {.temperature = 113, .backoff = 600},
+  {.temperature = 114, .backoff = 1200},
+  {.temperature = 115, .backoff = 2000},
+  {.temperature = 116, .backoff = 4000},
+  {.temperature = 117, .backoff = 10000},
+ },
+ .support_ct_kill = true,
+ .support_dynamic_smps = true,
+ .support_tx_protection = true,
+ .support_tx_backoff = true,
+};
+
+static const struct iwl_tt_params iwl7000_high_temp_tt_params = {
+ .ct_kill_entry = 118,
+ .ct_kill_exit = 96,
+ .ct_kill_duration = 5,
+ .dynamic_smps_entry = 114,
+ .dynamic_smps_exit = 110,
+ .tx_protection_entry = 114,
+ .tx_protection_exit = 108,
+ .tx_backoff = {
+  {.temperature = 112, .backoff = 300},
+  {.temperature = 113, .backoff = 800},
+  {.temperature = 114, .backoff = 1500},
+  {.temperature = 115, .backoff = 3000},
+  {.temperature = 116, .backoff = 5000},
+  {.temperature = 117, .backoff = 10000},
+ },
+ .support_ct_kill = true,
+ .support_dynamic_smps = true,
+ .support_tx_protection = true,
+ .support_tx_backoff = true,
+};
+
+void iwl_mvm_tt_initialize(struct iwl_mvm *mvm, u32 min_backoff)
+{
+ struct iwl_mvm_tt_mgmt *tt = &mvm->thermal_throttle;
+
+ IWL_DEBUG_TEMP(mvm, "Initialize Thermal Throttling\n");
+
+ if (mvm->cfg->high_temp)
+  tt->params = &iwl7000_high_temp_tt_params;
+ else
+  tt->params = &iwl7000_tt_params;
+
+ tt->throttle = false;
+ tt->min_backoff = min_backoff;
+ INIT_DELAYED_WORK(&tt->ct_kill_exit, check_exit_ctkill);
+}
+
+void iwl_mvm_tt_exit(struct iwl_mvm *mvm)
+{
+ cancel_delayed_work_sync(&mvm->thermal_throttle.ct_kill_exit);
+ IWL_DEBUG_TEMP(mvm, "Exit Thermal Throttling\n");
+}
diff --git a/drivers/net/wireless/iwlwifi/mvm/tx.c b/drivers/net/wireless/iwlwifi/mvm/tx.c
index a2e6112..3846a6c 100644
--- a/drivers/net/wireless/iwlwifi/mvm/tx.c
+++ b/drivers/net/wireless/iwlwifi/mvm/tx.c
@@ -5,7 +5,7 @@
  *
  * GPL LICENSE SUMMARY
  *
- * Copyright(c) 2012 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2012 - 2014 Intel Corporation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of version 2 of the GNU General Public License as
@@ -30,7 +30,7 @@
  *
  * BSD LICENSE
  *
- * Copyright(c) 2012 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2012 - 2014 Intel Corporation. All rights reserved.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -79,6 +79,7 @@ static void iwl_mvm_set_tx_cmd(struct iwl_mvm *mvm, struct sk_buff *skb,
  __le16 fc = hdr->frame_control;
  u32 tx_flags = le32_to_cpu(tx_cmd->tx_flags);
  u32 len = skb->len + FCS_LEN;
+ u8 ac;
 
  if (!(info->flags & IEEE80211_TX_CTL_NO_ACK))
   tx_flags |= TX_CMD_FLG_ACK;
@@ -90,14 +91,6 @@ static void iwl_mvm_set_tx_cmd(struct iwl_mvm *mvm, struct sk_buff *skb,
  else if (ieee80211_is_back_req(fc))
   tx_flags |= TX_CMD_FLG_ACK | TX_CMD_FLG_BAR;
 
- /* High prio packet (wrt. BT coex) if it is EAPOL, MCAST or MGMT */
- if (info->band == IEEE80211_BAND_2GHZ        &&
-     (skb->protocol == cpu_to_be16(ETH_P_PAE)  ||
-      is_multicast_ether_addr(hdr->addr1)      ||
-      ieee80211_is_back_req(fc)                ||
-      ieee80211_is_mgmt(fc)))
-  tx_flags |= TX_CMD_FLG_BT_DIS;
-
  if (ieee80211_has_morefrags(fc))
   tx_flags |= TX_CMD_FLG_MORE_FRAG;
 
@@ -113,6 +106,11 @@ static void iwl_mvm_set_tx_cmd(struct iwl_mvm *mvm, struct sk_buff *skb,
    tx_flags &= ~TX_CMD_FLG_SEQ_CTL;
  }
 
+ /* tid_tspec will default to 0 = BE when QOS isn't enabled */
+ ac = tid_to_mac80211_ac[tx_cmd->tid_tspec];
+ tx_flags |= iwl_mvm_bt_coex_tx_prio(mvm, hdr, info, ac) <<
+   TX_CMD_FLG_BT_PRIO_POS;
+
  if (ieee80211_is_mgmt(fc)) {
   if (ieee80211_is_assoc_req(fc) || ieee80211_is_reassoc_req(fc))
    tx_cmd->pm_frame_timeout = cpu_to_le16(3);
@@ -123,13 +121,12 @@ static void iwl_mvm_set_tx_cmd(struct iwl_mvm *mvm, struct sk_buff *skb,
    * it
    */
   WARN_ON_ONCE(info->flags & IEEE80211_TX_CTL_AMPDU);
+ } else if (info->control.flags & IEEE80211_TX_CTRL_PORT_CTRL_PROTO) {
+  tx_cmd->pm_frame_timeout = cpu_to_le16(2);
  } else {
   tx_cmd->pm_frame_timeout = 0;
  }
 
- if (info->flags & IEEE80211_TX_CTL_AMPDU)
-  tx_flags |= TX_CMD_FLG_PROT_REQUIRE;
-
  if (ieee80211_is_data(fc) && len > mvm->rts_threshold &&
      !is_multicast_ether_addr(ieee80211_get_DA(hdr)))
   tx_flags |= TX_CMD_FLG_PROT_REQUIRE;
@@ -171,7 +168,7 @@ static void iwl_mvm_set_tx_cmd_rate(struct iwl_mvm *mvm,
  }
 
  /*
-  * for data packets, rate info comes from the table inside he fw. This
+  * for data packets, rate info comes from the table inside the fw. This
   * table is controlled by LINK_QUALITY commands
   */
 
@@ -206,7 +203,7 @@ static void iwl_mvm_set_tx_cmd_rate(struct iwl_mvm *mvm,
  rate_plcp = iwl_mvm_mac80211_idx_to_hwrate(rate_idx);
 
  mvm->mgmt_last_antenna_idx =
-  iwl_mvm_next_antenna(mvm, iwl_fw_valid_tx_ant(mvm->fw),
+  iwl_mvm_next_antenna(mvm, mvm->fw->valid_tx_ant,
          mvm->mgmt_last_antenna_idx);
  rate_flags = BIT(mvm->mgmt_last_antenna_idx) << RATE_MCS_ANT_POS;
 
@@ -252,8 +249,7 @@ static void iwl_mvm_set_tx_cmd_crypto(struct iwl_mvm *mvm,
   memcpy(&tx_cmd->key[3], keyconf->key, keyconf->keylen);
   break;
  default:
-  IWL_ERR(mvm, "Unknown encode cipher %x\n", keyconf->cipher);
-  break;
+  tx_cmd->sec_ctl |= TX_CMD_SEC_EXT;
  }
 }
 
@@ -275,6 +271,7 @@ iwl_mvm_set_tx_params(struct iwl_mvm *mvm, struct sk_buff *skb,
   return NULL;
 
  memset(dev_cmd, 0, sizeof(*dev_cmd));
+ dev_cmd->hdr.cmd = TX_CMD;
  tx_cmd = (struct iwl_tx_cmd *)dev_cmd->payload;
 
  if (info->control.hw_key)
@@ -360,7 +357,7 @@ int iwl_mvm_tx_skb(struct iwl_mvm *mvm, struct sk_buff *skb,
  u8 txq_id = info->hw_queue;
  bool is_data_qos = false, is_ampdu = false;
 
- mvmsta = (void *)sta->drv_priv;
+ mvmsta = iwl_mvm_sta_from_mac80211(sta);
  fc = hdr->frame_control;
 
  if (WARN_ON_ONCE(!mvmsta))
@@ -376,6 +373,13 @@ int iwl_mvm_tx_skb(struct iwl_mvm *mvm, struct sk_buff *skb,
  tx_cmd = (struct iwl_tx_cmd *)dev_cmd->payload;
  /* From now on, we cannot access info->control */
 
+ /*
+  * we handle that entirely ourselves -- for uAPSD the firmware
+  * will always send a notification, and for PS-Poll responses
+  * we'll notify mac80211 when getting frame status
+  */
+ info->flags &= ~IEEE80211_TX_STATUS_EOSP;
+
  spin_lock(&mvmsta->lock);
 
  if (ieee80211_is_data_qos(fc) && !ieee80211_is_qos_nullfunc(fc)) {
@@ -389,7 +393,6 @@ int iwl_mvm_tx_skb(struct iwl_mvm *mvm, struct sk_buff *skb,
   seq_number &= IEEE80211_SCTL_SEQ;
   hdr->seq_ctrl &= cpu_to_le16(IEEE80211_SCTL_FRAG);
   hdr->seq_ctrl |= cpu_to_le16(seq_number);
-  seq_number += 0x10;
   is_data_qos = true;
   is_ampdu = info->flags & IEEE80211_TX_CTL_AMPDU;
  }
@@ -406,18 +409,17 @@ int iwl_mvm_tx_skb(struct iwl_mvm *mvm, struct sk_buff *skb,
  }
 
  IWL_DEBUG_TX(mvm, "TX to [%d|%d] Q:%d - seq: 0x%x\n", mvmsta->sta_id,
-       tid, txq_id, seq_number);
+       tid, txq_id, IEEE80211_SEQ_TO_SN(seq_number));
 
- /* NOTE: aggregation will need changes here (for txq id) */
  if (iwl_trans_tx(mvm->trans, skb, dev_cmd, txq_id))
   goto drop_unlock_sta;
 
  if (is_data_qos && !ieee80211_has_morefrags(fc))
-  mvmsta->tid_data[tid].seq_number = seq_number;
+  mvmsta->tid_data[tid].seq_number = seq_number + 0x10;
 
  spin_unlock(&mvmsta->lock);
 
- if (txq_id < IWL_MVM_FIRST_AGG_QUEUE)
+ if (txq_id < mvm->first_agg_queue)
   atomic_inc(&mvm->pending_frames[mvmsta->sta_id]);
 
  return 0;
@@ -432,12 +434,23 @@ drop:
 static void iwl_mvm_check_ratid_empty(struct iwl_mvm *mvm,
           struct ieee80211_sta *sta, u8 tid)
 {
- struct iwl_mvm_sta *mvmsta = (void *)sta->drv_priv;
+ struct iwl_mvm_sta *mvmsta = iwl_mvm_sta_from_mac80211(sta);
  struct iwl_mvm_tid_data *tid_data = &mvmsta->tid_data[tid];
  struct ieee80211_vif *vif = mvmsta->vif;
 
  lockdep_assert_held(&mvmsta->lock);
 
+ if ((tid_data->state == IWL_AGG_ON ||
+      tid_data->state == IWL_EMPTYING_HW_QUEUE_DELBA) &&
+     iwl_mvm_tid_queued(tid_data) == 0) {
+  /*
+   * Now that this aggregation queue is empty tell mac80211 so it
+   * knows we no longer have frames buffered for the station on
+   * this TID (for the TIM bitmap calculation.)
+   */
+  ieee80211_sta_set_buffered(sta, tid, false);
+ }
+
  if (tid_data->ssn != tid_data->next_reclaimed)
   return;
 
@@ -511,16 +524,10 @@ const char *iwl_mvm_get_tx_fail_reason(u32 status)
 }
 #endif /* CONFIG_IWLWIFI_DEBUG */
 
-/**
- * translate ucode response to mac80211 tx status control values
- */
-static void iwl_mvm_hwrate_to_tx_control(u32 rate_n_flags,
-      struct ieee80211_tx_info *info)
+void iwl_mvm_hwrate_to_tx_rate(u32 rate_n_flags,
+          enum ieee80211_band band,
+          struct ieee80211_tx_rate *r)
 {
- struct ieee80211_tx_rate *r = &info->status.rates[0];
-
- info->status.antenna =
-  ((rate_n_flags & RATE_MCS_ANT_ABC_MSK) >> RATE_MCS_ANT_POS);
  if (rate_n_flags & RATE_HT_MCS_GF_MSK)
   r->flags |= IEEE80211_TX_RC_GREEN_FIELD;
  switch (rate_n_flags & RATE_MCS_CHAN_WIDTH_MSK) {
@@ -549,10 +556,23 @@ static void iwl_mvm_hwrate_to_tx_control(u32 rate_n_flags,
   r->flags |= IEEE80211_TX_RC_VHT_MCS;
  } else {
   r->idx = iwl_mvm_legacy_rate_to_mac80211_idx(rate_n_flags,
-            info->band);
+            band);
  }
 }
 
+/**
+ * translate ucode response to mac80211 tx status control values
+ */
+static void iwl_mvm_hwrate_to_tx_status(u32 rate_n_flags,
+     struct ieee80211_tx_info *info)
+{
+ struct ieee80211_tx_rate *r = &info->status.rates[0];
+
+ info->status.antenna =
+  ((rate_n_flags & RATE_MCS_ANT_ABC_MSK) >> RATE_MCS_ANT_POS);
+ iwl_mvm_hwrate_to_tx_rate(rate_n_flags, info->band, r);
+}
+
 static void iwl_mvm_rx_tx_cmd_single(struct iwl_mvm *mvm,
          struct iwl_rx_packet *pkt)
 {
@@ -602,11 +622,11 @@ static void iwl_mvm_rx_tx_cmd_single(struct iwl_mvm *mvm,
   }
 
   info->status.rates[0].count = tx_resp->failure_frame + 1;
-  iwl_mvm_hwrate_to_tx_control(le32_to_cpu(tx_resp->initial_rate),
-          info);
+  iwl_mvm_hwrate_to_tx_status(le32_to_cpu(tx_resp->initial_rate),
+         info);
 
   /* Single frame failure in an AMPDU queue => send BAR */
-  if (txq_id >= IWL_MVM_FIRST_AGG_QUEUE &&
+  if (txq_id >= mvm->first_agg_queue &&
       !(info->flags & IEEE80211_TX_STAT_ACK))
    info->flags |= IEEE80211_TX_STAT_AMPDU_NO_BACK;
 
@@ -616,10 +636,14 @@ static void iwl_mvm_rx_tx_cmd_single(struct iwl_mvm *mvm,
    seq_ctl = le16_to_cpu(hdr->seq_ctrl);
   }
 
-  ieee80211_tx_status_ni(mvm->hw, skb);
+  BUILD_BUG_ON(ARRAY_SIZE(info->status.status_driver_data) < 1);
+  info->status.status_driver_data[0] =
+    (void *)(uintptr_t)tx_resp->reduced_tpc;
+
+  ieee80211_tx_status(mvm->hw, skb);
  }
 
- if (txq_id >= IWL_MVM_FIRST_AGG_QUEUE) {
+ if (txq_id >= mvm->first_agg_queue) {
   /* If this is an aggregation queue, we use the ssn since:
    * ssn = wifi seq_num % 256.
    * The seq_ctl is the sequence control of the packet to which
@@ -653,9 +677,15 @@ static void iwl_mvm_rx_tx_cmd_single(struct iwl_mvm *mvm,
  rcu_read_lock();
 
  sta = rcu_dereference(mvm->fw_id_to_mac_id[sta_id]);
+ /*
+  * sta can't be NULL otherwise it'd mean that the sta has been freed in
+  * the firmware while we still have packets for it in the Tx queues.
+  */
+ if (WARN_ON_ONCE(!sta))
+  goto out;
 
- if (!IS_ERR_OR_NULL(sta)) {
-  mvmsta = (void *)sta->drv_priv;
+ if (!IS_ERR(sta)) {
+  mvmsta = iwl_mvm_sta_from_mac80211(sta);
 
   if (tid != IWL_TID_NON_QOS) {
    struct iwl_mvm_tid_data *tid_data =
@@ -669,11 +699,11 @@ static void iwl_mvm_rx_tx_cmd_single(struct iwl_mvm *mvm,
    spin_unlock_bh(&mvmsta->lock);
   }
 
-#ifdef CONFIG_PM_SLEEP
-  mvmsta->last_seq_ctl = seq_ctl;
-#endif
+  if (mvmsta->next_status_eosp) {
+   mvmsta->next_status_eosp = false;
+   ieee80211_sta_eosp(sta);
+  }
  } else {
-  sta = NULL;
   mvmsta = NULL;
  }
 
@@ -681,42 +711,38 @@ static void iwl_mvm_rx_tx_cmd_single(struct iwl_mvm *mvm,
   * If the txq is not an AMPDU queue, there is no chance we freed
   * several skbs. Check that out...
   */
- if (txq_id < IWL_MVM_FIRST_AGG_QUEUE && !WARN_ON(skb_freed > 1) &&
-     atomic_sub_and_test(skb_freed, &mvm->pending_frames[sta_id])) {
-  if (mvmsta) {
-   /*
-    * If there are no pending frames for this STA, notify
-    * mac80211 that this station can go to sleep in its
-    * STA table.
-    */
-   if (mvmsta->vif->type == NL80211_IFTYPE_AP)
-    ieee80211_sta_block_awake(mvm->hw, sta, false);
-   /*
-    * We might very well have taken mvmsta pointer while
-    * the station was being removed. The remove flow might
-    * have seen a pending_frame (because we didn't take
-    * the lock) even if now the queues are drained. So make
-    * really sure now that this the station is not being
-    * removed. If it is, run the drain worker to remove it.
-    */
-   spin_lock_bh(&mvmsta->lock);
-   sta = rcu_dereference(mvm->fw_id_to_mac_id[sta_id]);
-   if (IS_ERR_OR_NULL(sta)) {
-    /*
-     * Station disappeared in the meantime:
-     * so we are draining.
-     */
-    set_bit(sta_id, mvm->sta_drained);
-    schedule_work(&mvm->sta_drained_wk);
-   }
-   spin_unlock_bh(&mvmsta->lock);
-  } else if (!mvmsta) {
-   /* Tx response without STA, so we are draining */
-   set_bit(sta_id, mvm->sta_drained);
-   schedule_work(&mvm->sta_drained_wk);
-  }
+ if (txq_id >= mvm->first_agg_queue)
+  goto out;
+
+ /* We can't free more than one frame at once on a shared queue */
+ WARN_ON(skb_freed > 1);
+
+ /* If we have still frames from this STA nothing to do here */
+ if (!atomic_sub_and_test(skb_freed, &mvm->pending_frames[sta_id]))
+  goto out;
+
+ if (mvmsta && mvmsta->vif->type == NL80211_IFTYPE_AP) {
+  /*
+   * If there are no pending frames for this STA, notify
+   * mac80211 that this station can go to sleep in its
+   * STA table.
+   * If mvmsta is not NULL, sta is valid.
+   */
+  ieee80211_sta_block_awake(mvm->hw, sta, false);
  }
 
+ if (PTR_ERR(sta) == -EBUSY || PTR_ERR(sta) == -ENOENT) {
+  /*
+   * We are draining and this was the last packet - pre_rcu_remove
+   * has been called already. We might be after the
+   * synchronize_net already.
+   * Don't rely on iwl_mvm_rm_sta to see the empty Tx queues.
+   */
+  set_bit(sta_id, mvm->sta_drained);
+  schedule_work(&mvm->sta_drained_wk);
+ }
+
+out:
  rcu_read_unlock();
 }
 
@@ -777,7 +803,7 @@ static void iwl_mvm_rx_tx_cmd_agg(struct iwl_mvm *mvm,
  u16 sequence = le16_to_cpu(pkt->hdr.sequence);
  struct ieee80211_sta *sta;
 
- if (WARN_ON_ONCE(SEQ_TO_QUEUE(sequence) < IWL_MVM_FIRST_AGG_QUEUE))
+ if (WARN_ON_ONCE(SEQ_TO_QUEUE(sequence) < mvm->first_agg_queue))
   return;
 
  if (WARN_ON_ONCE(tid == IWL_TID_NON_QOS))
@@ -790,9 +816,10 @@ static void iwl_mvm_rx_tx_cmd_agg(struct iwl_mvm *mvm,
  sta = rcu_dereference(mvm->fw_id_to_mac_id[sta_id]);
 
  if (!WARN_ON_ONCE(IS_ERR_OR_NULL(sta))) {
-  struct iwl_mvm_sta *mvmsta = (void *)sta->drv_priv;
+  struct iwl_mvm_sta *mvmsta = iwl_mvm_sta_from_mac80211(sta);
   mvmsta->tid_data[tid].rate_n_flags =
    le32_to_cpu(tx_resp->initial_rate);
+  mvmsta->tid_data[tid].reduced_tpc = tx_resp->reduced_tpc;
  }
 
  rcu_read_unlock();
@@ -819,16 +846,12 @@ int iwl_mvm_rx_ba_notif(struct iwl_mvm *mvm, struct iwl_rx_cmd_buffer *rxb,
  struct iwl_mvm_ba_notif *ba_notif = (void *)pkt->data;
  struct sk_buff_head reclaimed_skbs;
  struct iwl_mvm_tid_data *tid_data;
- struct ieee80211_tx_info *info;
  struct ieee80211_sta *sta;
  struct iwl_mvm_sta *mvmsta;
- struct ieee80211_hdr *hdr;
  struct sk_buff *skb;
  int sta_id, tid, freed;
-
  /* "flow" corresponds to Tx queue */
  u16 scd_flow = le16_to_cpu(ba_notif->scd_flow);
-
  /* "ssn" is start of block-ack Tx window, corresponds to index
   * (in Tx queue's circular buffer) of first TFD/frame in window */
  u16 ba_resp_scd_ssn = le16_to_cpu(ba_notif->scd_ssn);
@@ -846,7 +869,7 @@ int iwl_mvm_rx_ba_notif(struct iwl_mvm *mvm, struct iwl_rx_cmd_buffer *rxb,
   return 0;
  }
 
- mvmsta = (void *)sta->drv_priv;
+ mvmsta = iwl_mvm_sta_from_mac80211(sta);
  tid_data = &mvmsta->tid_data[tid];
 
  if (WARN_ONCE(tid_data->txq_id != scd_flow, "Q %d, tid %d, flow %d",
@@ -885,27 +908,33 @@ int iwl_mvm_rx_ba_notif(struct iwl_mvm *mvm, struct iwl_rx_cmd_buffer *rxb,
  freed = 0;
 
  skb_queue_walk(&reclaimed_skbs, skb) {
-  hdr = (struct ieee80211_hdr *)skb->data;
+  struct ieee80211_hdr *hdr = (void *)skb->data;
+  struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
 
   if (ieee80211_is_data_qos(hdr->frame_control))
    freed++;
   else
    WARN_ON_ONCE(1);
 
-  info = IEEE80211_SKB_CB(skb);
   iwl_trans_free_tx_cmd(mvm->trans, info->driver_data[1]);
 
+  memset(&info->status, 0, sizeof(info->status));
+  /* Packet was transmitted successfully, failures come as single
+   * frames because before failing a frame the firmware transmits
+   * it without aggregation at least once.
+   */
+  info->flags |= IEEE80211_TX_STAT_ACK;
+
   if (freed == 1) {
    /* this is the first skb we deliver in this batch */
    /* put the rate scaling data there */
-   info = IEEE80211_SKB_CB(skb);
-   memset(&info->status, 0, sizeof(info->status));
-   info->flags |= IEEE80211_TX_STAT_ACK;
    info->flags |= IEEE80211_TX_STAT_AMPDU;
    info->status.ampdu_ack_len = ba_notif->txed_2_done;
    info->status.ampdu_len = ba_notif->txed;
-   iwl_mvm_hwrate_to_tx_control(tid_data->rate_n_flags,
-           info);
+   iwl_mvm_hwrate_to_tx_status(tid_data->rate_n_flags,
+          info);
+   info->status.status_driver_data[0] =
+    (void *)(uintptr_t)tid_data->reduced_tpc;
   }
  }
 
@@ -915,7 +944,7 @@ int iwl_mvm_rx_ba_notif(struct iwl_mvm *mvm, struct iwl_rx_cmd_buffer *rxb,
 
  while (!skb_queue_empty(&reclaimed_skbs)) {
   skb = __skb_dequeue(&reclaimed_skbs);
-  ieee80211_tx_status_ni(mvm->hw, skb);
+  ieee80211_tx_status(mvm->hw, skb);
  }
 
  return 0;
@@ -929,7 +958,7 @@ int iwl_mvm_flush_tx_path(struct iwl_mvm *mvm, u32 tfd_msk, bool sync)
   .flush_ctl = cpu_to_le16(DUMP_TX_FIFO_FLUSH),
  };
 
- u32 flags = sync ? CMD_SYNC : CMD_ASYNC;
+ u32 flags = sync ? 0 : CMD_ASYNC;
 
  ret = iwl_mvm_send_cmd_pdu(mvm, TXPATH_FLUSH, flags,
        sizeof(flush_cmd), &flush_cmd);
diff --git a/drivers/net/wireless/iwlwifi/mvm/utils.c b/drivers/net/wireless/iwlwifi/mvm/utils.c
index 687b34e..aa9fc77 100644
--- a/drivers/net/wireless/iwlwifi/mvm/utils.c
+++ b/drivers/net/wireless/iwlwifi/mvm/utils.c
@@ -5,7 +5,7 @@
  *
  * GPL LICENSE SUMMARY
  *
- * Copyright(c) 2012 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2012 - 2014 Intel Corporation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of version 2 of the GNU General Public License as
@@ -30,7 +30,7 @@
  *
  * BSD LICENSE
  *
- * Copyright(c) 2012 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2012 - 2014 Intel Corporation. All rights reserved.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -64,6 +64,7 @@
 
 #include "iwl-debug.h"
 #include "iwl-io.h"
+#include "iwl-prph.h"
 
 #include "mvm.h"
 #include "fw-api-rs.h"
@@ -76,6 +77,11 @@ int iwl_mvm_send_cmd(struct iwl_mvm *mvm, struct iwl_host_cmd *cmd)
 {
  int ret;
 
+#if defined(CONFIG_IWLWIFI_DEBUGFS) && defined(CONFIG_PM_SLEEP)
+ if (WARN_ON(mvm->d3_test_active))
+  return -EIO;
+#endif
+
  /*
   * Synchronous commands from this op-mode must hold
   * the mutex, this ensures we don't try to send two
@@ -125,6 +131,11 @@ int iwl_mvm_send_cmd_status(struct iwl_mvm *mvm, struct iwl_host_cmd *cmd,
 
  lockdep_assert_held(&mvm->mutex);
 
+#if defined(CONFIG_IWLWIFI_DEBUGFS) && defined(CONFIG_PM_SLEEP)
+ if (WARN_ON(mvm->d3_test_active))
+  return -EIO;
+#endif
+
  /*
   * Only synchronous commands can wait for status,
   * we use WANT_SKB so the caller can't.
@@ -133,7 +144,7 @@ int iwl_mvm_send_cmd_status(struct iwl_mvm *mvm, struct iwl_host_cmd *cmd,
         "cmd flags %x", cmd->flags))
   return -EINVAL;
 
- cmd->flags |= CMD_SYNC | CMD_WANT_SKB;
+ cmd->flags |= CMD_WANT_SKB;
 
  ret = iwl_trans_send_cmd(mvm->trans, cmd);
  if (ret == -ERFKILL) {
@@ -158,8 +169,8 @@ int iwl_mvm_send_cmd_status(struct iwl_mvm *mvm, struct iwl_host_cmd *cmd,
   goto out_free_resp;
  }
 
- resp_len = le32_to_cpu(pkt->len_n_flags) & FH_RSCSR_FRAME_SIZE_MSK;
- if (WARN_ON_ONCE(resp_len != sizeof(pkt->hdr) + sizeof(*resp))) {
+ resp_len = iwl_rx_packet_payload_len(pkt);
+ if (WARN_ON_ONCE(resp_len != sizeof(*resp))) {
   ret = -EIO;
   goto out_free_resp;
  }
@@ -279,8 +290,8 @@ u8 iwl_mvm_next_antenna(struct iwl_mvm *mvm, u8 valid, u8 last_idx)
  return last_idx;
 }
 
-static struct {
- char *name;
+static const struct {
+ const char *name;
  u8 num;
 } advanced_lookup[] = {
  { "NMI_INTERRUPT_WDG", 0x34 },
@@ -366,9 +377,67 @@ struct iwl_error_event_table {
  u32 flow_handler; /* FH read/write pointers, RX credit */
 } __packed;
 
+/*
+ * UMAC error struct - relevant starting from family 8000 chip.
+ * Note: This structure is read from the device with IO accesses,
+ * and the reading already does the endian conversion. As it is
+ * read with u32-sized accesses, any members with a different size
+ * need to be ordered correctly though!
+ */
+struct iwl_umac_error_event_table {
+ u32 valid;  /* (nonzero) valid, (0) log is empty */
+ u32 error_id;  /* type of error */
+ u32 pc;   /* program counter */
+ u32 blink1;  /* branch link */
+ u32 blink2;  /* branch link */
+ u32 ilink1;  /* interrupt link */
+ u32 ilink2;  /* interrupt link */
+ u32 data1;  /* error-specific data */
+ u32 data2;  /* error-specific data */
+ u32 line;  /* source code line of error */
+ u32 umac_ver;  /* umac version */
+} __packed;
+
 #define ERROR_START_OFFSET  (1 * sizeof(u32))
 #define ERROR_ELEM_SIZE     (7 * sizeof(u32))
 
+static void iwl_mvm_dump_umac_error_log(struct iwl_mvm *mvm)
+{
+ struct iwl_trans *trans = mvm->trans;
+ struct iwl_umac_error_event_table table;
+ u32 base;
+
+ base = mvm->umac_error_event_table;
+
+ if (base < 0x800000 || base >= 0x80C000) {
+  IWL_ERR(mvm,
+   "Not valid error log pointer 0x%08X for %s uCode\n",
+   base,
+   (mvm->cur_ucode == IWL_UCODE_INIT)
+     ? "Init" : "RT");
+  return;
+ }
+
+ iwl_trans_read_mem_bytes(trans, base, &table, sizeof(table));
+
+ if (ERROR_START_OFFSET <= table.valid * ERROR_ELEM_SIZE) {
+  IWL_ERR(trans, "Start IWL Error Log Dump:\n");
+  IWL_ERR(trans, "Status: 0x%08lX, count: %d\n",
+   mvm->status, table.valid);
+ }
+
+ IWL_ERR(mvm, "0x%08X | %-28s\n", table.error_id,
+  desc_lookup(table.error_id));
+ IWL_ERR(mvm, "0x%08X | umac uPc\n", table.pc);
+ IWL_ERR(mvm, "0x%08X | umac branchlink1\n", table.blink1);
+ IWL_ERR(mvm, "0x%08X | umac branchlink2\n", table.blink2);
+ IWL_ERR(mvm, "0x%08X | umac interruptlink1\n", table.ilink1);
+ IWL_ERR(mvm, "0x%08X | umac interruptlink2\n", table.ilink2);
+ IWL_ERR(mvm, "0x%08X | umac data1\n", table.data1);
+ IWL_ERR(mvm, "0x%08X | umac data2\n", table.data2);
+ IWL_ERR(mvm, "0x%08X | umac version\n", table.umac_ver);
+}
+
 void iwl_mvm_dump_nic_error_log(struct iwl_mvm *mvm)
 {
  struct iwl_trans *trans = mvm->trans;
@@ -384,7 +453,7 @@ void iwl_mvm_dump_nic_error_log(struct iwl_mvm *mvm)
    base = mvm->fw->inst_errlog_ptr;
  }
 
- if (base < 0x800000 || base >= 0x80C000) {
+ if (base < 0x800000) {
   IWL_ERR(mvm,
    "Not valid error log pointer 0x%08X for %s uCode\n",
    base,
@@ -401,6 +470,10 @@ void iwl_mvm_dump_nic_error_log(struct iwl_mvm *mvm)
    mvm->status, table.valid);
  }
 
+ /* Do not change this output - scripts rely on it */
+
+ IWL_ERR(mvm, "Loaded firmware version: %s\n", mvm->fw->fw_version);
+
  trace_iwlwifi_dev_ucode_error(trans->dev, table.error_id, table.tsf_low,
           table.data1, table.data2, table.data3,
           table.blink1, table.blink2, table.ilink1,
@@ -441,7 +514,75 @@ void iwl_mvm_dump_nic_error_log(struct iwl_mvm *mvm)
  IWL_ERR(mvm, "0x%08X | lmpm_pmg_sel\n", table.lmpm_pmg_sel);
  IWL_ERR(mvm, "0x%08X | timestamp\n", table.u_timestamp);
  IWL_ERR(mvm, "0x%08X | flow_handler\n", table.flow_handler);
+
+ if (mvm->support_umac_log)
+  iwl_mvm_dump_umac_error_log(mvm);
+}
+
+#ifdef CONFIG_IWLWIFI_DEBUGFS
+void iwl_mvm_fw_error_sram_dump(struct iwl_mvm *mvm)
+{
+ const struct fw_img *img;
+ u32 ofs, sram_len;
+ void *sram;
+
+ if (!mvm->ucode_loaded || mvm->fw_error_sram || mvm->fw_error_dump)
+  return;
+
+ img = &mvm->fw->img[mvm->cur_ucode];
+ ofs = img->sec[IWL_UCODE_SECTION_DATA].offset;
+ sram_len = img->sec[IWL_UCODE_SECTION_DATA].len;
+
+ sram = kzalloc(sram_len, GFP_ATOMIC);
+ if (!sram)
+  return;
+
+ iwl_trans_read_mem_bytes(mvm->trans, ofs, sram, sram_len);
+ mvm->fw_error_sram = sram;
+ mvm->fw_error_sram_len = sram_len;
+}
+
+void iwl_mvm_fw_error_rxf_dump(struct iwl_mvm *mvm)
+{
+ int i, reg_val;
+ unsigned long flags;
+
+ if (!mvm->ucode_loaded || mvm->fw_error_rxf || mvm->fw_error_dump)
+  return;
+
+ /* reading buffer size */
+ reg_val = iwl_trans_read_prph(mvm->trans, RXF_SIZE_ADDR);
+ mvm->fw_error_rxf_len =
+  (reg_val & RXF_SIZE_BYTE_CNT_MSK) >> RXF_SIZE_BYTE_CND_POS;
+
+ /* the register holds the value divided by 128 */
+ mvm->fw_error_rxf_len = mvm->fw_error_rxf_len << 7;
+
+ if (!mvm->fw_error_rxf_len)
+  return;
+
+ mvm->fw_error_rxf =  kzalloc(mvm->fw_error_rxf_len, GFP_ATOMIC);
+ if (!mvm->fw_error_rxf) {
+  mvm->fw_error_rxf_len = 0;
+  return;
+ }
+
+ if (!iwl_trans_grab_nic_access(mvm->trans, false, &flags)) {
+  kfree(mvm->fw_error_rxf);
+  mvm->fw_error_rxf = NULL;
+  mvm->fw_error_rxf_len = 0;
+  return;
+ }
+
+ for (i = 0; i < (mvm->fw_error_rxf_len / sizeof(u32)); i++) {
+  iwl_trans_write_prph(mvm->trans, RXF_LD_FENCE_OFFSET_ADDR,
+         i * sizeof(u32));
+  mvm->fw_error_rxf[i] =
+   iwl_trans_read_prph(mvm->trans, RXF_FIFO_RD_FENCE_ADDR);
+ }
+ iwl_trans_release_nic_access(mvm->trans, &flags);
 }
+#endif
 
 /**
  * iwl_mvm_send_lq_cmd() - Send link quality command
@@ -453,21 +594,151 @@ void iwl_mvm_dump_nic_error_log(struct iwl_mvm *mvm)
  * this case to clear the state indicating that station creation is in
  * progress.
  */
-int iwl_mvm_send_lq_cmd(struct iwl_mvm *mvm, struct iwl_lq_cmd *lq,
-   u8 flags, bool init)
+int iwl_mvm_send_lq_cmd(struct iwl_mvm *mvm, struct iwl_lq_cmd *lq, bool init)
 {
  struct iwl_host_cmd cmd = {
   .id = LQ_CMD,
   .len = { sizeof(struct iwl_lq_cmd), },
-  .flags = flags,
+  .flags = init ? 0 : CMD_ASYNC,
   .data = { lq, },
  };
 
  if (WARN_ON(lq->sta_id == IWL_MVM_STATION_COUNT))
   return -EINVAL;
 
- if (WARN_ON(init && (cmd.flags & CMD_ASYNC)))
-  return -EINVAL;
-
  return iwl_mvm_send_cmd(mvm, &cmd);
 }
+
+/**
+ * iwl_mvm_update_smps - Get a requst to change the SMPS mode
+ * @req_type: The part of the driver who call for a change.
+ * @smps_requests: The request to change the SMPS mode.
+ *
+ * Get a requst to change the SMPS mode,
+ * and change it according to all other requests in the driver.
+ */
+void iwl_mvm_update_smps(struct iwl_mvm *mvm, struct ieee80211_vif *vif,
+    enum iwl_mvm_smps_type_request req_type,
+    enum ieee80211_smps_mode smps_request)
+{
+ struct iwl_mvm_vif *mvmvif;
+ enum ieee80211_smps_mode smps_mode;
+ int i;
+
+ lockdep_assert_held(&mvm->mutex);
+
+ /* SMPS is irrelevant for NICs that don't have at least 2 RX antenna */
+ if (num_of_ant(mvm->fw->valid_rx_ant) == 1)
+  return;
+
+ if (vif->type == NL80211_IFTYPE_AP)
+  smps_mode = IEEE80211_SMPS_OFF;
+ else
+  smps_mode = IEEE80211_SMPS_AUTOMATIC;
+
+ mvmvif = iwl_mvm_vif_from_mac80211(vif);
+ mvmvif->smps_requests[req_type] = smps_request;
+ for (i = 0; i < NUM_IWL_MVM_SMPS_REQ; i++) {
+  if (mvmvif->smps_requests[i] == IEEE80211_SMPS_STATIC) {
+   smps_mode = IEEE80211_SMPS_STATIC;
+   break;
+  }
+  if (mvmvif->smps_requests[i] == IEEE80211_SMPS_DYNAMIC)
+   smps_mode = IEEE80211_SMPS_DYNAMIC;
+ }
+
+ ieee80211_request_smps(vif, smps_mode);
+}
+
+static void iwl_mvm_diversity_iter(void *_data, u8 *mac,
+       struct ieee80211_vif *vif)
+{
+ struct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);
+ bool *result = _data;
+ int i;
+
+ for (i = 0; i < NUM_IWL_MVM_SMPS_REQ; i++) {
+  if (mvmvif->smps_requests[i] == IEEE80211_SMPS_STATIC ||
+      mvmvif->smps_requests[i] == IEEE80211_SMPS_DYNAMIC)
+   *result = false;
+ }
+}
+
+bool iwl_mvm_rx_diversity_allowed(struct iwl_mvm *mvm)
+{
+ bool result = true;
+
+ lockdep_assert_held(&mvm->mutex);
+
+ if (num_of_ant(mvm->fw->valid_rx_ant) == 1)
+  return false;
+
+ if (!mvm->cfg->rx_with_siso_diversity)
+  return false;
+
+ ieee80211_iterate_active_interfaces_atomic(
+   mvm->hw, IEEE80211_IFACE_ITER_NORMAL,
+   iwl_mvm_diversity_iter, &result);
+
+ return result;
+}
+
+int iwl_mvm_update_low_latency(struct iwl_mvm *mvm, struct ieee80211_vif *vif,
+          bool value)
+{
+ struct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);
+ int res;
+
+ lockdep_assert_held(&mvm->mutex);
+
+ if (mvmvif->low_latency == value)
+  return 0;
+
+ mvmvif->low_latency = value;
+
+ res = iwl_mvm_update_quotas(mvm, NULL);
+ if (res)
+  return res;
+
+ iwl_mvm_bt_coex_vif_change(mvm);
+
+ return iwl_mvm_power_update_mac(mvm);
+}
+
+static void iwl_mvm_ll_iter(void *_data, u8 *mac, struct ieee80211_vif *vif)
+{
+ bool *result = _data;
+
+ if (iwl_mvm_vif_low_latency(iwl_mvm_vif_from_mac80211(vif)))
+  *result = true;
+}
+
+bool iwl_mvm_low_latency(struct iwl_mvm *mvm)
+{
+ bool result = false;
+
+ ieee80211_iterate_active_interfaces_atomic(
+   mvm->hw, IEEE80211_IFACE_ITER_NORMAL,
+   iwl_mvm_ll_iter, &result);
+
+ return result;
+}
+
+static void iwl_mvm_idle_iter(void *_data, u8 *mac, struct ieee80211_vif *vif)
+{
+ bool *idle = _data;
+
+ if (!vif->bss_conf.idle)
+  *idle = false;
+}
+
+bool iwl_mvm_is_idle(struct iwl_mvm *mvm)
+{
+ bool idle = true;
+
+ ieee80211_iterate_active_interfaces_atomic(
+   mvm->hw, IEEE80211_IFACE_ITER_NORMAL,
+   iwl_mvm_idle_iter, &idle);
+
+ return idle;
+}
diff --git a/drivers/net/wireless/iwlwifi/pcie/drv.c b/drivers/net/wireless/iwlwifi/pcie/drv.c
index b53e5c3..98950e4 100644
--- a/drivers/net/wireless/iwlwifi/pcie/drv.c
+++ b/drivers/net/wireless/iwlwifi/pcie/drv.c
@@ -5,7 +5,7 @@
  *
  * GPL LICENSE SUMMARY
  *
- * Copyright(c) 2007 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2007 - 2014 Intel Corporation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of version 2 of the GNU General Public License as
@@ -30,7 +30,7 @@
  *
  * BSD LICENSE
  *
- * Copyright(c) 2005 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2005 - 2014 Intel Corporation. All rights reserved.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -66,6 +66,7 @@
 #include <linux/module.h>
 #include <linux/pci.h>
 #include <linux/pci-aspm.h>
+#include <linux/acpi.h>
 
 #include "iwl-trans.h"
 #include "iwl-drv.h"
@@ -78,6 +79,7 @@
 
 /* Hardware specific file defines the PCI IDs table for that hardware module */
 static DEFINE_PCI_DEVICE_TABLE(iwl_hw_card_ids) = {
+#if IS_ENABLED(CONFIG_IWLDVM)
  {IWL_PCI_DEVICE(0x4232, 0x1201, iwl5100_agn_cfg)}, /* Mini Card */
  {IWL_PCI_DEVICE(0x4232, 0x1301, iwl5100_agn_cfg)}, /* Half Mini Card */
  {IWL_PCI_DEVICE(0x4232, 0x1204, iwl5100_agn_cfg)}, /* Mini Card */
@@ -264,8 +266,10 @@ static DEFINE_PCI_DEVICE_TABLE(iwl_hw_card_ids) = {
  {IWL_PCI_DEVICE(0x0892, 0x0062, iwl135_bgn_cfg)},
  {IWL_PCI_DEVICE(0x0893, 0x0262, iwl135_bgn_cfg)},
  {IWL_PCI_DEVICE(0x0892, 0x0462, iwl135_bgn_cfg)},
+#endif /* CONFIG_IWLDVM */
 
-/* 7000 Series */
+#if IS_ENABLED(CONFIG_IWLMVM)
+/* 7260 Series */
  {IWL_PCI_DEVICE(0x08B1, 0x4070, iwl7260_2ac_cfg)},
  {IWL_PCI_DEVICE(0x08B1, 0x4072, iwl7260_2ac_cfg)},
  {IWL_PCI_DEVICE(0x08B1, 0x4170, iwl7260_2ac_cfg)},
@@ -286,11 +290,17 @@ static DEFINE_PCI_DEVICE_TABLE(iwl_hw_card_ids) = {
  {IWL_PCI_DEVICE(0x08B1, 0x4462, iwl7260_n_cfg)},
  {IWL_PCI_DEVICE(0x08B1, 0x4870, iwl7260_2ac_cfg)},
  {IWL_PCI_DEVICE(0x08B1, 0x486E, iwl7260_2ac_cfg)},
+ {IWL_PCI_DEVICE(0x08B1, 0x4A70, iwl7260_2ac_cfg_high_temp)},
+ {IWL_PCI_DEVICE(0x08B1, 0x4A6E, iwl7260_2ac_cfg_high_temp)},
+ {IWL_PCI_DEVICE(0x08B1, 0x4A6C, iwl7260_2ac_cfg_high_temp)},
  {IWL_PCI_DEVICE(0x08B1, 0x4570, iwl7260_2ac_cfg)},
  {IWL_PCI_DEVICE(0x08B1, 0x4560, iwl7260_2n_cfg)},
  {IWL_PCI_DEVICE(0x08B2, 0x4370, iwl7260_2ac_cfg)},
  {IWL_PCI_DEVICE(0x08B2, 0x4360, iwl7260_2n_cfg)},
  {IWL_PCI_DEVICE(0x08B1, 0x5070, iwl7260_2ac_cfg)},
+ {IWL_PCI_DEVICE(0x08B1, 0x5072, iwl7260_2ac_cfg)},
+ {IWL_PCI_DEVICE(0x08B1, 0x5170, iwl7260_2ac_cfg)},
+ {IWL_PCI_DEVICE(0x08B1, 0x5770, iwl7260_2ac_cfg)},
  {IWL_PCI_DEVICE(0x08B1, 0x4020, iwl7260_2n_cfg)},
  {IWL_PCI_DEVICE(0x08B1, 0x402A, iwl7260_2n_cfg)},
  {IWL_PCI_DEVICE(0x08B2, 0x4220, iwl7260_2n_cfg)},
@@ -344,11 +354,131 @@ static DEFINE_PCI_DEVICE_TABLE(iwl_hw_card_ids) = {
  {IWL_PCI_DEVICE(0x08B4, 0x8270, iwl3160_2ac_cfg)},
  {IWL_PCI_DEVICE(0x08B3, 0x8470, iwl3160_2ac_cfg)},
  {IWL_PCI_DEVICE(0x08B3, 0x8570, iwl3160_2ac_cfg)},
+ {IWL_PCI_DEVICE(0x08B3, 0x1070, iwl3160_2ac_cfg)},
+ {IWL_PCI_DEVICE(0x08B3, 0x1170, iwl3160_2ac_cfg)},
+
+/* 7265 Series */
+ {IWL_PCI_DEVICE(0x095A, 0x5010, iwl7265_2ac_cfg)},
+ {IWL_PCI_DEVICE(0x095A, 0x5110, iwl7265_2ac_cfg)},
+ {IWL_PCI_DEVICE(0x095A, 0x5100, iwl7265_2ac_cfg)},
+ {IWL_PCI_DEVICE(0x095B, 0x5310, iwl7265_2ac_cfg)},
+ {IWL_PCI_DEVICE(0x095B, 0x5302, iwl7265_n_cfg)},
+ {IWL_PCI_DEVICE(0x095B, 0x5210, iwl7265_2ac_cfg)},
+ {IWL_PCI_DEVICE(0x095A, 0x5012, iwl7265_2ac_cfg)},
+ {IWL_PCI_DEVICE(0x095A, 0x5412, iwl7265_2ac_cfg)},
+ {IWL_PCI_DEVICE(0x095A, 0x5410, iwl7265_2ac_cfg)},
+ {IWL_PCI_DEVICE(0x095A, 0x5510, iwl7265_2ac_cfg)},
+ {IWL_PCI_DEVICE(0x095A, 0x5400, iwl7265_2ac_cfg)},
+ {IWL_PCI_DEVICE(0x095A, 0x1010, iwl7265_2ac_cfg)},
+ {IWL_PCI_DEVICE(0x095A, 0x5000, iwl7265_2n_cfg)},
+ {IWL_PCI_DEVICE(0x095A, 0x500A, iwl7265_2n_cfg)},
+ {IWL_PCI_DEVICE(0x095B, 0x5200, iwl7265_2n_cfg)},
+ {IWL_PCI_DEVICE(0x095A, 0x5002, iwl7265_n_cfg)},
+ {IWL_PCI_DEVICE(0x095A, 0x5102, iwl7265_n_cfg)},
+ {IWL_PCI_DEVICE(0x095B, 0x5202, iwl7265_n_cfg)},
+ {IWL_PCI_DEVICE(0x095A, 0x9010, iwl7265_2ac_cfg)},
+ {IWL_PCI_DEVICE(0x095A, 0x9012, iwl7265_2ac_cfg)},
+ {IWL_PCI_DEVICE(0x095A, 0x9110, iwl7265_2ac_cfg)},
+ {IWL_PCI_DEVICE(0x095A, 0x9112, iwl7265_2ac_cfg)},
+ {IWL_PCI_DEVICE(0x095A, 0x9210, iwl7265_2ac_cfg)},
+ {IWL_PCI_DEVICE(0x095B, 0x9200, iwl7265_2ac_cfg)},
+ {IWL_PCI_DEVICE(0x095A, 0x9510, iwl7265_2ac_cfg)},
+ {IWL_PCI_DEVICE(0x095A, 0x9310, iwl7265_2ac_cfg)},
+ {IWL_PCI_DEVICE(0x095A, 0x9410, iwl7265_2ac_cfg)},
+ {IWL_PCI_DEVICE(0x095A, 0x5020, iwl7265_2n_cfg)},
+ {IWL_PCI_DEVICE(0x095A, 0x502A, iwl7265_2n_cfg)},
+ {IWL_PCI_DEVICE(0x095A, 0x5420, iwl7265_2n_cfg)},
+ {IWL_PCI_DEVICE(0x095A, 0x5090, iwl7265_2ac_cfg)},
+ {IWL_PCI_DEVICE(0x095A, 0x5190, iwl7265_2ac_cfg)},
+ {IWL_PCI_DEVICE(0x095A, 0x5590, iwl7265_2ac_cfg)},
+ {IWL_PCI_DEVICE(0x095B, 0x5290, iwl7265_2ac_cfg)},
+ {IWL_PCI_DEVICE(0x095A, 0x5490, iwl7265_2ac_cfg)},
+
+/* 8000 Series */
+ {IWL_PCI_DEVICE(0x24F3, 0x0010, iwl8260_2ac_cfg)},
+ {IWL_PCI_DEVICE(0x24F4, 0x0030, iwl8260_2ac_cfg)},
+#endif /* CONFIG_IWLMVM */
 
  {0}
 };
 MODULE_DEVICE_TABLE(pci, iwl_hw_card_ids);
 
+#ifdef CONFIG_ACPI
+#define SPL_METHOD  "SPLC"
+#define SPL_DOMAINTYPE_MODULE BIT(0)
+#define SPL_DOMAINTYPE_WIFI BIT(1)
+#define SPL_DOMAINTYPE_WIGIG BIT(2)
+#define SPL_DOMAINTYPE_RFEM BIT(3)
+
+static u64 splx_get_pwr_limit(struct iwl_trans *trans, union acpi_object *splx)
+{
+ union acpi_object *limits, *domain_type, *power_limit;
+
+ if (splx->type != ACPI_TYPE_PACKAGE ||
+     splx->package.count != 2 ||
+     splx->package.elements[0].type != ACPI_TYPE_INTEGER ||
+     splx->package.elements[0].integer.value != 0) {
+  IWL_ERR(trans, "Unsupported splx structure\n");
+  return 0;
+ }
+
+ limits = &splx->package.elements[1];
+ if (limits->type != ACPI_TYPE_PACKAGE ||
+     limits->package.count < 2 ||
+     limits->package.elements[0].type != ACPI_TYPE_INTEGER ||
+     limits->package.elements[1].type != ACPI_TYPE_INTEGER) {
+  IWL_ERR(trans, "Invalid limits element\n");
+  return 0;
+ }
+
+ domain_type = &limits->package.elements[0];
+ power_limit = &limits->package.elements[1];
+ if (!(domain_type->integer.value & SPL_DOMAINTYPE_WIFI)) {
+  IWL_DEBUG_INFO(trans, "WiFi power is not limited\n");
+  return 0;
+ }
+
+ return power_limit->integer.value;
+}
+
+static void set_dflt_pwr_limit(struct iwl_trans *trans, struct pci_dev *pdev)
+{
+ acpi_handle pxsx_handle;
+ acpi_handle handle;
+ struct acpi_buffer splx = {ACPI_ALLOCATE_BUFFER, NULL};
+ acpi_status status;
+
+ pxsx_handle = ACPI_HANDLE(&pdev->dev);
+ if (!pxsx_handle) {
+  IWL_DEBUG_INFO(trans,
+          "Could not retrieve root port ACPI handle\n");
+  return;
+ }
+
+ /* Get the method's handle */
+ status = acpi_get_handle(pxsx_handle, (acpi_string)SPL_METHOD, &handle);
+ if (ACPI_FAILURE(status)) {
+  IWL_DEBUG_INFO(trans, "SPL method not found\n");
+  return;
+ }
+
+ /* Call SPLC with no arguments */
+ status = acpi_evaluate_object(handle, NULL, NULL, &splx);
+ if (ACPI_FAILURE(status)) {
+  IWL_ERR(trans, "SPLC invocation failed (0x%x)\n", status);
+  return;
+ }
+
+ trans->dflt_pwr_limit = splx_get_pwr_limit(trans, splx.pointer);
+ IWL_DEBUG_INFO(trans, "Default power limit set to %lld\n",
+         trans->dflt_pwr_limit);
+ kfree(splx.pointer);
+}
+
+#else /* CONFIG_ACPI */
+static void set_dflt_pwr_limit(struct iwl_trans *trans, struct pci_dev *pdev) {}
+#endif
+
 /* PCI registers */
 #define PCI_CFG_RETRY_TIMEOUT 0x041
 
@@ -360,19 +490,21 @@ static int iwl_pci_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
  int ret;
 
  iwl_trans = iwl_trans_pcie_alloc(pdev, ent, cfg);
- if (iwl_trans == NULL)
-  return -ENOMEM;
+ if (IS_ERR(iwl_trans))
+  return PTR_ERR(iwl_trans);
 
  pci_set_drvdata(pdev, iwl_trans);
 
  trans_pcie = IWL_TRANS_GET_PCIE_TRANS(iwl_trans);
  trans_pcie->drv = iwl_drv_start(iwl_trans, cfg);
 
- if (IS_ERR_OR_NULL(trans_pcie->drv)) {
+ if (IS_ERR(trans_pcie->drv)) {
   ret = PTR_ERR(trans_pcie->drv);
   goto out_free_trans;
  }
 
+ set_dflt_pwr_limit(iwl_trans, pdev);
+
  /* register transport layer debugfs here */
  ret = iwl_trans_dbgfs_register(iwl_trans, iwl_trans->dbgfs_dir);
  if (ret)
@@ -384,7 +516,6 @@ out_free_drv:
  iwl_drv_stop(trans_pcie->drv);
 out_free_trans:
  iwl_trans_pcie_free(iwl_trans);
- pci_set_drvdata(pdev, NULL);
  return ret;
 }
 
@@ -395,29 +526,25 @@ static void iwl_pci_remove(struct pci_dev *pdev)
 
  iwl_drv_stop(trans_pcie->drv);
  iwl_trans_pcie_free(trans);
-
- pci_set_drvdata(pdev, NULL);
 }
 
 #ifdef CONFIG_PM_SLEEP
 
 static int iwl_pci_suspend(struct device *device)
 {
- struct pci_dev *pdev = to_pci_dev(device);
- struct iwl_trans *iwl_trans = pci_get_drvdata(pdev);
-
  /* Before you put code here, think about WoWLAN. You cannot check here
   * whether WoWLAN is enabled or not, and your code will run even if
   * WoWLAN is enabled - don't kill the NIC, someone may need it in Sx.
   */
 
- return iwl_trans_suspend(iwl_trans);
+ return 0;
 }
 
 static int iwl_pci_resume(struct device *device)
 {
  struct pci_dev *pdev = to_pci_dev(device);
- struct iwl_trans *iwl_trans = pci_get_drvdata(pdev);
+ struct iwl_trans *trans = pci_get_drvdata(pdev);
+ bool hw_rfkill;
 
  /* Before you put code here, think about WoWLAN. You cannot check here
   * whether WoWLAN is enabled or not, and your code will run even if
@@ -430,7 +557,15 @@ static int iwl_pci_resume(struct device *device)
   */
  pci_write_config_byte(pdev, PCI_CFG_RETRY_TIMEOUT, 0x00);
 
- return iwl_trans_resume(iwl_trans);
+ if (!trans->op_mode)
+  return 0;
+
+ iwl_enable_rfkill_int(trans);
+
+ hw_rfkill = iwl_is_rfkill_set(trans);
+ iwl_trans_pcie_rf_kill(trans, hw_rfkill);
+
+ return 0;
 }
 
 static SIMPLE_DEV_PM_OPS(iwl_dev_pm_ops, iwl_pci_suspend, iwl_pci_resume);
diff --git a/drivers/net/wireless/iwlwifi/pcie/internal.h b/drivers/net/wireless/iwlwifi/pcie/internal.h
index 148843e..6c22b23 100644
--- a/drivers/net/wireless/iwlwifi/pcie/internal.h
+++ b/drivers/net/wireless/iwlwifi/pcie/internal.h
@@ -1,6 +1,6 @@
 /******************************************************************************
  *
- * Copyright(c) 2003 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2003 - 2014 Intel Corporation. All rights reserved.
  *
  * Portions of this file are derived from the ipw3945 project, as well
  * as portions of the ieee80211 subsystem header files.
@@ -102,7 +102,7 @@ struct iwl_rxq {
  u32 write_actual;
  struct list_head rx_free;
  struct list_head rx_used;
- int need_update;
+ bool need_update;
  struct iwl_rb_status *rb_stts;
  dma_addr_t rb_stts_dma;
  spinlock_t lock;
@@ -117,21 +117,19 @@ struct iwl_dma_ptr {
 /**
  * iwl_queue_inc_wrap - increment queue index, wrap back to beginning
  * @index -- current index
- * @n_bd -- total number of entries in queue (must be power of 2)
  */
-static inline int iwl_queue_inc_wrap(int index, int n_bd)
+static inline int iwl_queue_inc_wrap(int index)
 {
- return ++index & (n_bd - 1);
+ return ++index & (TFD_QUEUE_SIZE_MAX - 1);
 }
 
 /**
  * iwl_queue_dec_wrap - decrement queue index, wrap back to end
  * @index -- current index
- * @n_bd -- total number of entries in queue (must be power of 2)
  */
-static inline int iwl_queue_dec_wrap(int index, int n_bd)
+static inline int iwl_queue_dec_wrap(int index)
 {
- return --index & (n_bd - 1);
+ return --index & (TFD_QUEUE_SIZE_MAX - 1);
 }
 
 struct iwl_cmd_meta {
@@ -145,13 +143,13 @@ struct iwl_cmd_meta {
  *
  * Contains common data for Rx and Tx queues.
  *
- * Note the difference between n_bd and n_window: the hardware
- * always assumes 256 descriptors, so n_bd is always 256 (unless
+ * Note the difference between TFD_QUEUE_SIZE_MAX and n_window: the hardware
+ * always assumes 256 descriptors, so TFD_QUEUE_SIZE_MAX is always 256 (unless
  * there might be HW changes in the future). For the normal TX
  * queues, n_window, which is the size of the software queue data
  * is also 256; however, for the command queue, n_window is only
  * 32 since we don't need so many commands pending. Since the HW
- * still uses 256 BDs for DMA though, n_bd stays 256. As a result,
+ * still uses 256 BDs for DMA though, TFD_QUEUE_SIZE_MAX stays 256. As a result,
  * the software buffers (in the variables @meta, @txb in struct
  * iwl_txq) only have 32 entries, while the HW buffers (@tfds in
  * the same struct) have 256.
@@ -162,7 +160,6 @@ struct iwl_cmd_meta {
  * data is a window overlayed over the HW queue.
  */
 struct iwl_queue {
- int n_bd;              /* number of BDs in this queue */
  int write_ptr;       /* 1-st empty entry (index) host_w*/
  int read_ptr;         /* last used entry (index) host_r*/
  /* use for monitoring and recovering the stuck queue */
@@ -217,6 +214,7 @@ struct iwl_pcie_txq_scratch_buf {
  * @trans_pcie: pointer back to transport (for timer)
  * @need_update: indicates need to update read/write index
  * @active: stores if queue is active
+ * @ampdu: true if this queue is an ampdu queue for an specific RA/TID
  *
  * A Tx queue consists of circular buffer of BDs (a.k.a. TFDs, transmit frame
  * descriptors) and required locking structures.
@@ -230,8 +228,9 @@ struct iwl_txq {
  spinlock_t lock;
  struct timer_list stuck_timer;
  struct iwl_trans_pcie *trans_pcie;
- u8 need_update;
+ bool need_update;
  u8 active;
+ bool ampdu;
 };
 
 static inline dma_addr_t
@@ -254,13 +253,13 @@ iwl_pcie_get_scratchbuf_dma(struct iwl_txq *txq, int idx)
  * @hw_base: pci hardware address support
  * @ucode_write_complete: indicates that the ucode has been copied.
  * @ucode_write_waitq: wait queue for uCode load
- * @status - transport specific status flags
  * @cmd_queue - command queue number
  * @rx_buf_size_8k: 8 kB RX buffer size
  * @bc_table_dword: true if the BC table expects DWORD (as opposed to bytes)
  * @rx_page_order: page order for receive buffer size
  * @wd_timeout: queue watchdog timeout (jiffies)
  * @reg_lock: protect hw register access
+ * @cmd_in_flight: true when we have a host command in flight
  */
 struct iwl_trans_pcie {
  struct iwl_rxq rxq;
@@ -268,11 +267,13 @@ struct iwl_trans_pcie {
  struct iwl_trans *trans;
  struct iwl_drv *drv;
 
+ struct net_device napi_dev;
+ struct napi_struct napi;
+
  /* INT ICT Table */
  __le32 *ict_tbl;
  dma_addr_t ict_tbl_dma;
  int ict_index;
- u32 inta;
  bool use_ict;
  struct isr_statistics isr_stats;
 
@@ -294,7 +295,6 @@ struct iwl_trans_pcie {
  wait_queue_head_t ucode_write_waitq;
  wait_queue_head_t wait_command_queue;
 
- unsigned long status;
  u8 cmd_queue;
  u8 cmd_fifo;
  u8 n_no_reclaim_cmds;
@@ -304,31 +304,14 @@ struct iwl_trans_pcie {
  bool bc_table_dword;
  u32 rx_page_order;
 
- const char **command_names;
+ const char *const *command_names;
 
  /* queue watchdog */
  unsigned long wd_timeout;
 
  /*protect hw register */
  spinlock_t reg_lock;
-};
-
-/**
- * enum iwl_pcie_status: status of the PCIe transport
- * @STATUS_HCMD_ACTIVE: a SYNC command is being processed
- * @STATUS_DEVICE_ENABLED: APM is enabled
- * @STATUS_TPOWER_PMI: the device might be asleep (need to wake it up)
- * @STATUS_INT_ENABLED: interrupts are enabled
- * @STATUS_RFKILL: the HW RFkill switch is in KILL position
- * @STATUS_FW_ERROR: the fw is in error state
- */
-enum iwl_pcie_status {
- STATUS_HCMD_ACTIVE,
- STATUS_DEVICE_ENABLED,
- STATUS_TPOWER_PMI,
- STATUS_INT_ENABLED,
- STATUS_RFKILL,
- STATUS_FW_ERROR,
+ bool cmd_in_flight;
 };
 
 #define IWL_TRANS_GET_PCIE_TRANS(_iwl_trans) \
@@ -361,7 +344,7 @@ void iwl_pcie_rx_free(struct iwl_trans *trans);
 /*****************************************************
 * ICT - interrupt handling
 ******************************************************/
-irqreturn_t iwl_pcie_isr_ict(int irq, void *data);
+irqreturn_t iwl_pcie_isr(int irq, void *data);
 int iwl_pcie_alloc_ict(struct iwl_trans *trans);
 void iwl_pcie_free_ict(struct iwl_trans *trans);
 void iwl_pcie_reset_ict(struct iwl_trans *trans);
@@ -379,7 +362,7 @@ void iwl_trans_pcie_txq_enable(struct iwl_trans *trans, int txq_id, int fifo,
 void iwl_trans_pcie_txq_disable(struct iwl_trans *trans, int queue);
 int iwl_trans_pcie_tx(struct iwl_trans *trans, struct sk_buff *skb,
         struct iwl_device_cmd *dev_cmd, int txq_id);
-void iwl_pcie_txq_inc_wr_ptr(struct iwl_trans *trans, struct iwl_txq *txq);
+void iwl_pcie_txq_check_wrptrs(struct iwl_trans *trans);
 int iwl_trans_pcie_send_hcmd(struct iwl_trans *trans, struct iwl_host_cmd *cmd);
 void iwl_pcie_hcmd_complete(struct iwl_trans *trans,
        struct iwl_rx_cmd_buffer *rxb, int handler_status);
@@ -387,10 +370,16 @@ void iwl_trans_pcie_reclaim(struct iwl_trans *trans, int txq_id, int ssn,
        struct sk_buff_head *skbs);
 void iwl_trans_pcie_tx_reset(struct iwl_trans *trans);
 
+static inline u16 iwl_pcie_tfd_tb_get_len(struct iwl_tfd *tfd, u8 idx)
+{
+ struct iwl_tfd_tb *tb = &tfd->tbs[idx];
+
+ return le16_to_cpu(tb->hi_n_len) >> 4;
+}
+
 /*****************************************************
 * Error handling
 ******************************************************/
-int iwl_pcie_dump_fh(struct iwl_trans *trans, char **buf);
 void iwl_pcie_dump_csr(struct iwl_trans *trans);
 
 /*****************************************************
@@ -398,8 +387,7 @@ void iwl_pcie_dump_csr(struct iwl_trans *trans);
 ******************************************************/
 static inline void iwl_disable_interrupts(struct iwl_trans *trans)
 {
- struct iwl_trans_pcie *trans_pcie = IWL_TRANS_GET_PCIE_TRANS(trans);
- clear_bit(STATUS_INT_ENABLED, &trans_pcie->status);
+ clear_bit(STATUS_INT_ENABLED, &trans->status);
 
  /* disable interrupts from uCode/NIC to host */
  iwl_write32(trans, CSR_INT_MASK, 0x00000000);
@@ -416,14 +404,18 @@ static inline void iwl_enable_interrupts(struct iwl_trans *trans)
  struct iwl_trans_pcie *trans_pcie = IWL_TRANS_GET_PCIE_TRANS(trans);
 
  IWL_DEBUG_ISR(trans, "Enabling interrupts\n");
- set_bit(STATUS_INT_ENABLED, &trans_pcie->status);
+ set_bit(STATUS_INT_ENABLED, &trans->status);
+ trans_pcie->inta_mask = CSR_INI_SET_MASK;
  iwl_write32(trans, CSR_INT_MASK, trans_pcie->inta_mask);
 }
 
 static inline void iwl_enable_rfkill_int(struct iwl_trans *trans)
 {
+ struct iwl_trans_pcie *trans_pcie = IWL_TRANS_GET_PCIE_TRANS(trans);
+
  IWL_DEBUG_ISR(trans, "Enabling rfkill interrupt\n");
- iwl_write32(trans, CSR_INT_MASK, CSR_INT_BIT_RF_KILL);
+ trans_pcie->inta_mask = CSR_INT_BIT_RF_KILL;
+ iwl_write32(trans, CSR_INT_MASK, trans_pcie->inta_mask);
 }
 
 static inline void iwl_wake_queue(struct iwl_trans *trans,
@@ -476,4 +468,33 @@ static inline bool iwl_is_rfkill_set(struct iwl_trans *trans)
   CSR_GP_CNTRL_REG_FLAG_HW_RF_KILL_SW);
 }
 
+static inline void __iwl_trans_pcie_set_bits_mask(struct iwl_trans *trans,
+        u32 reg, u32 mask, u32 value)
+{
+ u32 v;
+
+#ifdef CONFIG_IWLWIFI_DEBUG
+ WARN_ON_ONCE(value & ~mask);
+#endif
+
+ v = iwl_read32(trans, reg);
+ v &= ~mask;
+ v |= value;
+ iwl_write32(trans, reg, v);
+}
+
+static inline void __iwl_trans_pcie_clear_bit(struct iwl_trans *trans,
+           u32 reg, u32 mask)
+{
+ __iwl_trans_pcie_set_bits_mask(trans, reg, mask, 0);
+}
+
+static inline void __iwl_trans_pcie_set_bit(struct iwl_trans *trans,
+         u32 reg, u32 mask)
+{
+ __iwl_trans_pcie_set_bits_mask(trans, reg, mask, mask);
+}
+
+void iwl_trans_pcie_rf_kill(struct iwl_trans *trans, bool state);
+
 #endif /* __iwl_trans_int_pcie_h__ */
diff --git a/drivers/net/wireless/iwlwifi/pcie/rx.c b/drivers/net/wireless/iwlwifi/pcie/rx.c
index 567e67a..a2698e5 100644
--- a/drivers/net/wireless/iwlwifi/pcie/rx.c
+++ b/drivers/net/wireless/iwlwifi/pcie/rx.c
@@ -1,6 +1,6 @@
 /******************************************************************************
  *
- * Copyright(c) 2003 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2003 - 2014 Intel Corporation. All rights reserved.
  *
  * Portions of this file are derived from the ipw3945 project, as well
  * as portions of the ieee80211 subsystem header files.
@@ -110,16 +110,18 @@
 /*
  * iwl_rxq_space - Return number of free slots available in queue.
  */
-static int iwl_rxq_space(const struct iwl_rxq *q)
+static int iwl_rxq_space(const struct iwl_rxq *rxq)
 {
- int s = q->read - q->write;
- if (s <= 0)
-  s += RX_QUEUE_SIZE;
- /* keep some buffer to not confuse full and empty queue */
- s -= 2;
- if (s < 0)
-  s = 0;
- return s;
+ /* Make sure RX_QUEUE_SIZE is a power of 2 */
+ BUILD_BUG_ON(RX_QUEUE_SIZE & (RX_QUEUE_SIZE - 1));
+
+ /*
+  * There can be up to (RX_QUEUE_SIZE - 1) free slots, to avoid ambiguity
+  * between empty and completely full queues.
+  * The following is equivalent to modulo by RX_QUEUE_SIZE and is well
+  * defined for negative dividends.
+  */
+ return (rxq->read - rxq->write - 1) & (RX_QUEUE_SIZE - 1);
 }
 
 /*
@@ -143,54 +145,52 @@ int iwl_pcie_rx_stop(struct iwl_trans *trans)
 /*
  * iwl_pcie_rxq_inc_wr_ptr - Update the write pointer for the RX queue
  */
-static void iwl_pcie_rxq_inc_wr_ptr(struct iwl_trans *trans, struct iwl_rxq *q)
+static void iwl_pcie_rxq_inc_wr_ptr(struct iwl_trans *trans)
 {
- unsigned long flags;
+ struct iwl_trans_pcie *trans_pcie = IWL_TRANS_GET_PCIE_TRANS(trans);
+ struct iwl_rxq *rxq = &trans_pcie->rxq;
  u32 reg;
 
- spin_lock_irqsave(&q->lock, flags);
+ lockdep_assert_held(&rxq->lock);
 
- if (q->need_update == 0)
-  goto exit_unlock;
+ /*
+  * explicitly wake up the NIC if:
+  * 1. shadow registers aren't enabled
+  * 2. there is a chance that the NIC is asleep
+  */
+ if (!trans->cfg->base_params->shadow_reg_enable &&
+     test_bit(STATUS_TPOWER_PMI, &trans->status)) {
+  reg = iwl_read32(trans, CSR_UCODE_DRV_GP1);
+
+  if (reg & CSR_UCODE_DRV_GP1_BIT_MAC_SLEEP) {
+   IWL_DEBUG_INFO(trans, "Rx queue requesting wakeup, GP1 = 0x%x\n",
+           reg);
+   iwl_set_bit(trans, CSR_GP_CNTRL,
+        CSR_GP_CNTRL_REG_FLAG_MAC_ACCESS_REQ);
+   rxq->need_update = true;
+   return;
+  }
+ }
 
- if (trans->cfg->base_params->shadow_reg_enable) {
-  /* shadow register enabled */
-  /* Device expects a multiple of 8 */
-  q->write_actual = (q->write & ~0x7);
-  iwl_write32(trans, FH_RSCSR_CHNL0_WPTR, q->write_actual);
- } else {
-  struct iwl_trans_pcie *trans_pcie =
-   IWL_TRANS_GET_PCIE_TRANS(trans);
-
-  /* If power-saving is in use, make sure device is awake */
-  if (test_bit(STATUS_TPOWER_PMI, &trans_pcie->status)) {
-   reg = iwl_read32(trans, CSR_UCODE_DRV_GP1);
-
-   if (reg & CSR_UCODE_DRV_GP1_BIT_MAC_SLEEP) {
-    IWL_DEBUG_INFO(trans,
-     "Rx queue requesting wakeup,"
-     " GP1 = 0x%x\n", reg);
-    iwl_set_bit(trans, CSR_GP_CNTRL,
-     CSR_GP_CNTRL_REG_FLAG_MAC_ACCESS_REQ);
-    goto exit_unlock;
-   }
+ rxq->write_actual = round_down(rxq->write, 8);
+ iwl_write32(trans, FH_RSCSR_CHNL0_WPTR, rxq->write_actual);
+}
 
-   q->write_actual = (q->write & ~0x7);
-   iwl_write_direct32(trans, FH_RSCSR_CHNL0_WPTR,
-     q->write_actual);
+static void iwl_pcie_rxq_check_wrptr(struct iwl_trans *trans)
+{
+ struct iwl_trans_pcie *trans_pcie = IWL_TRANS_GET_PCIE_TRANS(trans);
+ struct iwl_rxq *rxq = &trans_pcie->rxq;
 
-  /* Else device is assumed to be awake */
-  } else {
-   /* Device expects a multiple of 8 */
-   q->write_actual = (q->write & ~0x7);
-   iwl_write_direct32(trans, FH_RSCSR_CHNL0_WPTR,
-    q->write_actual);
-  }
- }
- q->need_update = 0;
+ spin_lock(&rxq->lock);
+
+ if (!rxq->need_update)
+  goto exit_unlock;
+
+ iwl_pcie_rxq_inc_wr_ptr(trans);
+ rxq->need_update = false;
 
  exit_unlock:
- spin_unlock_irqrestore(&q->lock, flags);
+ spin_unlock(&rxq->lock);
 }
 
 /*
@@ -209,7 +209,6 @@ static void iwl_pcie_rxq_restock(struct iwl_trans *trans)
  struct iwl_trans_pcie *trans_pcie = IWL_TRANS_GET_PCIE_TRANS(trans);
  struct iwl_rxq *rxq = &trans_pcie->rxq;
  struct iwl_rx_mem_buffer *rxb;
- unsigned long flags;
 
  /*
   * If the device isn't enabled - not need to try to add buffers...
@@ -219,10 +218,10 @@ static void iwl_pcie_rxq_restock(struct iwl_trans *trans)
   * stopped, we cannot access the HW (in particular not prph).
   * So don't try to restock if the APM has been already stopped.
   */
- if (!test_bit(STATUS_DEVICE_ENABLED, &trans_pcie->status))
+ if (!test_bit(STATUS_DEVICE_ENABLED, &trans->status))
   return;
 
- spin_lock_irqsave(&rxq->lock, flags);
+ spin_lock(&rxq->lock);
  while ((iwl_rxq_space(rxq) > 0) && (rxq->free_count)) {
   /* The overwritten rxb must be a used one */
   rxb = rxq->queue[rxq->write];
@@ -239,7 +238,7 @@ static void iwl_pcie_rxq_restock(struct iwl_trans *trans)
   rxq->write = (rxq->write + 1) & RX_QUEUE_MASK;
   rxq->free_count--;
  }
- spin_unlock_irqrestore(&rxq->lock, flags);
+ spin_unlock(&rxq->lock);
  /* If the pre-allocated buffer pool is dropping low, schedule to
   * refill it */
  if (rxq->free_count <= RX_LOW_WATERMARK)
@@ -248,10 +247,9 @@ static void iwl_pcie_rxq_restock(struct iwl_trans *trans)
  /* If we've added more space for the firmware to place data, tell it.
   * Increment device's write pointer in multiples of 8. */
  if (rxq->write_actual != (rxq->write & ~0x7)) {
-  spin_lock_irqsave(&rxq->lock, flags);
-  rxq->need_update = 1;
-  spin_unlock_irqrestore(&rxq->lock, flags);
-  iwl_pcie_rxq_inc_wr_ptr(trans, rxq);
+  spin_lock(&rxq->lock);
+  iwl_pcie_rxq_inc_wr_ptr(trans);
+  spin_unlock(&rxq->lock);
  }
 }
 
@@ -270,16 +268,15 @@ static void iwl_pcie_rxq_alloc_rbs(struct iwl_trans *trans, gfp_t priority)
  struct iwl_rxq *rxq = &trans_pcie->rxq;
  struct iwl_rx_mem_buffer *rxb;
  struct page *page;
- unsigned long flags;
  gfp_t gfp_mask = priority;
 
  while (1) {
-  spin_lock_irqsave(&rxq->lock, flags);
+  spin_lock(&rxq->lock);
   if (list_empty(&rxq->rx_used)) {
-   spin_unlock_irqrestore(&rxq->lock, flags);
+   spin_unlock(&rxq->lock);
    return;
   }
-  spin_unlock_irqrestore(&rxq->lock, flags);
+  spin_unlock(&rxq->lock);
 
   if (rxq->free_count > RX_LOW_WATERMARK)
    gfp_mask |= __GFP_NOWARN;
@@ -308,17 +305,17 @@ static void iwl_pcie_rxq_alloc_rbs(struct iwl_trans *trans, gfp_t priority)
    return;
   }
 
-  spin_lock_irqsave(&rxq->lock, flags);
+  spin_lock(&rxq->lock);
 
   if (list_empty(&rxq->rx_used)) {
-   spin_unlock_irqrestore(&rxq->lock, flags);
+   spin_unlock(&rxq->lock);
    __free_pages(page, trans_pcie->rx_page_order);
    return;
   }
   rxb = list_first_entry(&rxq->rx_used, struct iwl_rx_mem_buffer,
            list);
   list_del(&rxb->list);
-  spin_unlock_irqrestore(&rxq->lock, flags);
+  spin_unlock(&rxq->lock);
 
   BUG_ON(rxb->page);
   rxb->page = page;
@@ -329,9 +326,9 @@ static void iwl_pcie_rxq_alloc_rbs(struct iwl_trans *trans, gfp_t priority)
          DMA_FROM_DEVICE);
   if (dma_mapping_error(trans->dev, rxb->page_dma)) {
    rxb->page = NULL;
-   spin_lock_irqsave(&rxq->lock, flags);
+   spin_lock(&rxq->lock);
    list_add(&rxb->list, &rxq->rx_used);
-   spin_unlock_irqrestore(&rxq->lock, flags);
+   spin_unlock(&rxq->lock);
    __free_pages(page, trans_pcie->rx_page_order);
    return;
   }
@@ -340,12 +337,12 @@ static void iwl_pcie_rxq_alloc_rbs(struct iwl_trans *trans, gfp_t priority)
   /* and also 256 byte aligned! */
   BUG_ON(rxb->page_dma & DMA_BIT_MASK(8));
 
-  spin_lock_irqsave(&rxq->lock, flags);
+  spin_lock(&rxq->lock);
 
   list_add_tail(&rxb->list, &rxq->rx_free);
   rxq->free_count++;
 
-  spin_unlock_irqrestore(&rxq->lock, flags);
+  spin_unlock(&rxq->lock);
  }
 }
 
@@ -355,19 +352,16 @@ static void iwl_pcie_rxq_free_rbs(struct iwl_trans *trans)
  struct iwl_rxq *rxq = &trans_pcie->rxq;
  int i;
 
- /* Fill the rx_used queue with _all_ of the Rx buffers */
+ lockdep_assert_held(&rxq->lock);
+
  for (i = 0; i < RX_FREE_BUFFERS + RX_QUEUE_SIZE; i++) {
-  /* In the reset function, these buffers may have been allocated
-   * to an SKB, so we need to unmap and free potential storage */
-  if (rxq->pool[i].page != NULL) {
-   dma_unmap_page(trans->dev, rxq->pool[i].page_dma,
-           PAGE_SIZE << trans_pcie->rx_page_order,
-           DMA_FROM_DEVICE);
-   __free_pages(rxq->pool[i].page,
-         trans_pcie->rx_page_order);
-   rxq->pool[i].page = NULL;
-  }
-  list_add_tail(&rxq->pool[i].list, &rxq->rx_used);
+  if (!rxq->pool[i].page)
+   continue;
+  dma_unmap_page(trans->dev, rxq->pool[i].page_dma,
+          PAGE_SIZE << trans_pcie->rx_page_order,
+          DMA_FROM_DEVICE);
+  __free_pages(rxq->pool[i].page, trans_pcie->rx_page_order);
+  rxq->pool[i].page = NULL;
  }
 }
 
@@ -379,21 +373,9 @@ static void iwl_pcie_rxq_free_rbs(struct iwl_trans *trans)
  * Also restock the Rx queue via iwl_pcie_rxq_restock.
  * This is called as a scheduled work item (except for during initialization)
  */
-static void iwl_pcie_rx_replenish(struct iwl_trans *trans)
+static void iwl_pcie_rx_replenish(struct iwl_trans *trans, gfp_t gfp)
 {
- struct iwl_trans_pcie *trans_pcie = IWL_TRANS_GET_PCIE_TRANS(trans);
- unsigned long flags;
-
- iwl_pcie_rxq_alloc_rbs(trans, GFP_KERNEL);
-
- spin_lock_irqsave(&trans_pcie->irq_lock, flags);
- iwl_pcie_rxq_restock(trans);
- spin_unlock_irqrestore(&trans_pcie->irq_lock, flags);
-}
-
-static void iwl_pcie_rx_replenish_now(struct iwl_trans *trans)
-{
- iwl_pcie_rxq_alloc_rbs(trans, GFP_ATOMIC);
+ iwl_pcie_rxq_alloc_rbs(trans, gfp);
 
  iwl_pcie_rxq_restock(trans);
 }
@@ -403,7 +385,7 @@ static void iwl_pcie_rx_replenish_work(struct work_struct *data)
  struct iwl_trans_pcie *trans_pcie =
      container_of(data, struct iwl_trans_pcie, rx_replenish);
 
- iwl_pcie_rx_replenish(trans_pcie->trans);
+ iwl_pcie_rx_replenish(trans_pcie->trans, GFP_KERNEL);
 }
 
 static int iwl_pcie_rx_alloc(struct iwl_trans *trans)
@@ -489,6 +471,24 @@ static void iwl_pcie_rx_hw_init(struct iwl_trans *trans, struct iwl_rxq *rxq)
 
  /* Set interrupt coalescing timer to default (2048 usecs) */
  iwl_write8(trans, CSR_INT_COALESCING, IWL_HOST_INT_TIMEOUT_DEF);
+
+ /* W/A for interrupt coalescing bug in 7260 and 3160 */
+ if (trans->cfg->host_interrupt_operation_mode)
+  iwl_set_bit(trans, CSR_INT_COALESCING, IWL_HOST_INT_OPER_MODE);
+}
+
+static void iwl_pcie_rx_init_rxb_lists(struct iwl_rxq *rxq)
+{
+ int i;
+
+ lockdep_assert_held(&rxq->lock);
+
+ INIT_LIST_HEAD(&rxq->rx_free);
+ INIT_LIST_HEAD(&rxq->rx_used);
+ rxq->free_count = 0;
+
+ for (i = 0; i < RX_FREE_BUFFERS + RX_QUEUE_SIZE; i++)
+  list_add(&rxq->pool[i].list, &rxq->rx_used);
 }
 
 int iwl_pcie_rx_init(struct iwl_trans *trans)
@@ -496,7 +496,6 @@ int iwl_pcie_rx_init(struct iwl_trans *trans)
  struct iwl_trans_pcie *trans_pcie = IWL_TRANS_GET_PCIE_TRANS(trans);
  struct iwl_rxq *rxq = &trans_pcie->rxq;
  int i, err;
- unsigned long flags;
 
  if (!rxq->bd) {
   err = iwl_pcie_rx_alloc(trans);
@@ -504,14 +503,13 @@ int iwl_pcie_rx_init(struct iwl_trans *trans)
    return err;
  }
 
- spin_lock_irqsave(&rxq->lock, flags);
- INIT_LIST_HEAD(&rxq->rx_free);
- INIT_LIST_HEAD(&rxq->rx_used);
+ spin_lock(&rxq->lock);
 
- INIT_WORK(&trans_pcie->rx_replenish,
-    iwl_pcie_rx_replenish_work);
+ INIT_WORK(&trans_pcie->rx_replenish, iwl_pcie_rx_replenish_work);
 
+ /* free all first - we might be reconfigured for a different size */
  iwl_pcie_rxq_free_rbs(trans);
+ iwl_pcie_rx_init_rxb_lists(rxq);
 
  for (i = 0; i < RX_QUEUE_SIZE; i++)
   rxq->queue[i] = NULL;
@@ -520,18 +518,16 @@ int iwl_pcie_rx_init(struct iwl_trans *trans)
   * not restocked the Rx queue with fresh buffers */
  rxq->read = rxq->write = 0;
  rxq->write_actual = 0;
- rxq->free_count = 0;
  memset(rxq->rb_stts, 0, sizeof(*rxq->rb_stts));
- spin_unlock_irqrestore(&rxq->lock, flags);
+ spin_unlock(&rxq->lock);
 
- iwl_pcie_rx_replenish(trans);
+ iwl_pcie_rx_replenish(trans, GFP_KERNEL);
 
  iwl_pcie_rx_hw_init(trans, rxq);
 
- spin_lock_irqsave(&trans_pcie->irq_lock, flags);
- rxq->need_update = 1;
- iwl_pcie_rxq_inc_wr_ptr(trans, rxq);
- spin_unlock_irqrestore(&trans_pcie->irq_lock, flags);
+ spin_lock(&rxq->lock);
+ iwl_pcie_rxq_inc_wr_ptr(trans);
+ spin_unlock(&rxq->lock);
 
  return 0;
 }
@@ -540,7 +536,6 @@ void iwl_pcie_rx_free(struct iwl_trans *trans)
 {
  struct iwl_trans_pcie *trans_pcie = IWL_TRANS_GET_PCIE_TRANS(trans);
  struct iwl_rxq *rxq = &trans_pcie->rxq;
- unsigned long flags;
 
  /*if rxq->bd is NULL, it means that nothing has been allocated,
   * exit now */
@@ -551,9 +546,9 @@ void iwl_pcie_rx_free(struct iwl_trans *trans)
 
  cancel_work_sync(&trans_pcie->rx_replenish);
 
- spin_lock_irqsave(&rxq->lock, flags);
+ spin_lock(&rxq->lock);
  iwl_pcie_rxq_free_rbs(trans);
- spin_unlock_irqrestore(&rxq->lock, flags);
+ spin_unlock(&rxq->lock);
 
  dma_free_coherent(trans->dev, sizeof(__le32) * RX_QUEUE_SIZE,
      rxq->bd, rxq->bd_dma);
@@ -576,7 +571,6 @@ static void iwl_pcie_rx_handle_rb(struct iwl_trans *trans,
  struct iwl_trans_pcie *trans_pcie = IWL_TRANS_GET_PCIE_TRANS(trans);
  struct iwl_rxq *rxq = &trans_pcie->rxq;
  struct iwl_txq *txq = &trans_pcie->txq[trans_pcie->cmd_queue];
- unsigned long flags;
  bool page_stolen = false;
  int max_len = PAGE_SIZE << trans_pcie->rx_page_order;
  u32 offset = 0;
@@ -609,7 +603,7 @@ static void iwl_pcie_rx_handle_rb(struct iwl_trans *trans,
    rxcb._offset, get_cmd_string(trans_pcie, pkt->hdr.cmd),
    pkt->hdr.cmd);
 
-  len = le32_to_cpu(pkt->len_n_flags) & FH_RSCSR_FRAME_SIZE_MSK;
+  len = iwl_rx_packet_len(pkt);
   len += sizeof(u32); /* account for status word */
   trace_iwlwifi_dev_rx(trans->dev, trans, pkt, len);
   trace_iwlwifi_dev_rx_data(trans->dev, trans, pkt, len);
@@ -678,7 +672,6 @@ static void iwl_pcie_rx_handle_rb(struct iwl_trans *trans,
  /* Reuse the page if possible. For notification packets and
   * SKBs that fail to Rx correctly, add them back into the
   * rx_free list for reuse later. */
- spin_lock_irqsave(&rxq->lock, flags);
  if (rxb->page != NULL) {
   rxb->page_dma =
    dma_map_page(trans->dev, rxb->page, 0,
@@ -699,7 +692,6 @@ static void iwl_pcie_rx_handle_rb(struct iwl_trans *trans,
   }
  } else
   list_add_tail(&rxb->list, &rxq->rx_used);
- spin_unlock_irqrestore(&rxq->lock, flags);
 }
 
 /*
@@ -714,6 +706,8 @@ static void iwl_pcie_rx_handle(struct iwl_trans *trans)
  u32 count = 8;
  int total_empty;
 
+restart:
+ spin_lock(&rxq->lock);
  /* uCode's read index (stored in shared DRAM) indicates the last Rx
   * buffer that the driver may process (last buffer filled by ucode). */
  r = le16_to_cpu(ACCESS_ONCE(rxq->rb_stts->closed_rb_num)) & 0x0FFF;
@@ -748,18 +742,25 @@ static void iwl_pcie_rx_handle(struct iwl_trans *trans)
    count++;
    if (count >= 8) {
     rxq->read = i;
-    iwl_pcie_rx_replenish_now(trans);
+    spin_unlock(&rxq->lock);
+    iwl_pcie_rx_replenish(trans, GFP_ATOMIC);
     count = 0;
+    goto restart;
    }
   }
  }
 
  /* Backtrack one entry */
  rxq->read = i;
+ spin_unlock(&rxq->lock);
+
  if (fill_rx)
-  iwl_pcie_rx_replenish_now(trans);
+  iwl_pcie_rx_replenish(trans, GFP_ATOMIC);
  else
   iwl_pcie_rxq_restock(trans);
+
+ if (trans_pcie->napi.poll)
+  napi_gro_flush(&trans_pcie->napi, false);
 }
 
 /*
@@ -775,22 +776,103 @@ static void iwl_pcie_irq_handle_error(struct iwl_trans *trans)
         APMS_CLK_VAL_MRB_FUNC_MODE) ||
       (iwl_read_prph(trans, APMG_PS_CTRL_REG) &
        APMG_PS_CTRL_VAL_RESET_REQ))) {
-  clear_bit(STATUS_HCMD_ACTIVE, &trans_pcie->status);
+  clear_bit(STATUS_SYNC_HCMD_ACTIVE, &trans->status);
   iwl_op_mode_wimax_active(trans->op_mode);
   wake_up(&trans_pcie->wait_command_queue);
   return;
  }
 
  iwl_pcie_dump_csr(trans);
- iwl_pcie_dump_fh(trans, NULL);
-
- set_bit(STATUS_FW_ERROR, &trans_pcie->status);
- clear_bit(STATUS_HCMD_ACTIVE, &trans_pcie->status);
- wake_up(&trans_pcie->wait_command_queue);
+ iwl_dump_fh(trans, NULL);
 
  local_bh_disable();
- iwl_op_mode_nic_error(trans->op_mode);
+ /* The STATUS_FW_ERROR bit is set in this function. This must happen
+  * before we wake up the command caller, to ensure a proper cleanup. */
+ iwl_trans_fw_error(trans);
  local_bh_enable();
+
+ clear_bit(STATUS_SYNC_HCMD_ACTIVE, &trans->status);
+ wake_up(&trans_pcie->wait_command_queue);
+}
+
+static u32 iwl_pcie_int_cause_non_ict(struct iwl_trans *trans)
+{
+ u32 inta;
+
+ lockdep_assert_held(&IWL_TRANS_GET_PCIE_TRANS(trans)->irq_lock);
+
+ trace_iwlwifi_dev_irq(trans->dev);
+
+ /* Discover which interrupts are active/pending */
+ inta = iwl_read32(trans, CSR_INT);
+
+ /* the thread will service interrupts and re-enable them */
+ return inta;
+}
+
+/* a device (PCI-E) page is 4096 bytes long */
+#define ICT_SHIFT 12
+#define ICT_SIZE (1 << ICT_SHIFT)
+#define ICT_COUNT (ICT_SIZE / sizeof(u32))
+
+/* interrupt handler using ict table, with this interrupt driver will
+ * stop using INTA register to get device's interrupt, reading this register
+ * is expensive, device will write interrupts in ICT dram table, increment
+ * index then will fire interrupt to driver, driver will OR all ICT table
+ * entries from current index up to table entry with 0 value. the result is
+ * the interrupt we need to service, driver will set the entries back to 0 and
+ * set index.
+ */
+static u32 iwl_pcie_int_cause_ict(struct iwl_trans *trans)
+{
+ struct iwl_trans_pcie *trans_pcie = IWL_TRANS_GET_PCIE_TRANS(trans);
+ u32 inta;
+ u32 val = 0;
+ u32 read;
+
+ trace_iwlwifi_dev_irq(trans->dev);
+
+ /* Ignore interrupt if there's nothing in NIC to service.
+  * This may be due to IRQ shared with another device,
+  * or due to sporadic interrupts thrown from our NIC. */
+ read = le32_to_cpu(trans_pcie->ict_tbl[trans_pcie->ict_index]);
+ trace_iwlwifi_dev_ict_read(trans->dev, trans_pcie->ict_index, read);
+ if (!read)
+  return 0;
+
+ /*
+  * Collect all entries up to the first 0, starting from ict_index;
+  * note we already read at ict_index.
+  */
+ do {
+  val |= read;
+  IWL_DEBUG_ISR(trans, "ICT index %d value 0x%08X\n",
+    trans_pcie->ict_index, read);
+  trans_pcie->ict_tbl[trans_pcie->ict_index] = 0;
+  trans_pcie->ict_index =
+   ((trans_pcie->ict_index + 1) & (ICT_COUNT - 1));
+
+  read = le32_to_cpu(trans_pcie->ict_tbl[trans_pcie->ict_index]);
+  trace_iwlwifi_dev_ict_read(trans->dev, trans_pcie->ict_index,
+        read);
+ } while (read);
+
+ /* We should not get this value, just ignore it. */
+ if (val == 0xffffffff)
+  val = 0;
+
+ /*
+  * this is a w/a for a h/w bug. the h/w bug may cause the Rx bit
+  * (bit 15 before shifting it to 31) to clear when using interrupt
+  * coalescing. fortunately, bits 18 and 19 stay set when this happens
+  * so we use them to decide on the real state of the Rx bit.
+  * In order words, bit 15 is set if bit 18 or bit 19 are set.
+  */
+ if (val & 0xC0000)
+  val |= 0x8000;
+
+ inta = (0xff & val) | ((0xff00 & val) << 16);
+ return inta;
 }
 
 irqreturn_t iwl_pcie_irq_handler(int irq, void *dev_id)
@@ -800,15 +882,60 @@ irqreturn_t iwl_pcie_irq_handler(int irq, void *dev_id)
  struct isr_statistics *isr_stats = &trans_pcie->isr_stats;
  u32 inta = 0;
  u32 handled = 0;
- unsigned long flags;
- u32 i;
-#ifdef CONFIG_IWLWIFI_DEBUG
- u32 inta_mask;
-#endif
 
  lock_map_acquire(&trans->sync_cmd_lockdep_map);
 
- spin_lock_irqsave(&trans_pcie->irq_lock, flags);
+ spin_lock(&trans_pcie->irq_lock);
+
+ /* dram interrupt table not set yet,
+  * use legacy interrupt.
+  */
+ if (likely(trans_pcie->use_ict))
+  inta = iwl_pcie_int_cause_ict(trans);
+ else
+  inta = iwl_pcie_int_cause_non_ict(trans);
+
+ if (iwl_have_debug_level(IWL_DL_ISR)) {
+  IWL_DEBUG_ISR(trans,
+         "ISR inta 0x%08x, enabled 0x%08x(sw), enabled(hw) 0x%08x, fh 0x%08x\n",
+         inta, trans_pcie->inta_mask,
+         iwl_read32(trans, CSR_INT_MASK),
+         iwl_read32(trans, CSR_FH_INT_STATUS));
+  if (inta & (~trans_pcie->inta_mask))
+   IWL_DEBUG_ISR(trans,
+          "We got a masked interrupt (0x%08x)\n",
+          inta & (~trans_pcie->inta_mask));
+ }
+
+ inta &= trans_pcie->inta_mask;
+
+ /*
+  * Ignore interrupt if there's nothing in NIC to service.
+  * This may be due to IRQ shared with another device,
+  * or due to sporadic interrupts thrown from our NIC.
+  */
+ if (unlikely(!inta)) {
+  IWL_DEBUG_ISR(trans, "Ignore interrupt, inta == 0\n");
+  /*
+   * Re-enable interrupts here since we don't
+   * have anything to service
+   */
+  if (test_bit(STATUS_INT_ENABLED, &trans->status))
+   iwl_enable_interrupts(trans);
+  spin_unlock(&trans_pcie->irq_lock);
+  lock_map_release(&trans->sync_cmd_lockdep_map);
+  return IRQ_NONE;
+ }
+
+ if (unlikely(inta == 0xFFFFFFFF || (inta & 0xFFFFFFF0) == 0xa5a5a5a0)) {
+  /*
+   * Hardware disappeared. It might have
+   * already raised an interrupt.
+   */
+  IWL_WARN(trans, "HARDWARE GONE?? INTA == 0x%08x\n", inta);
+  spin_unlock(&trans_pcie->irq_lock);
+  goto out;
+ }
 
  /* Ack/clear/reset pending uCode interrupts.
   * Note:  Some bits in CSR_INT are "OR" of bits in CSR_FH_INT_STATUS,
@@ -821,24 +948,13 @@ irqreturn_t iwl_pcie_irq_handler(int irq, void *dev_id)
   * hardware bugs here by ACKing all the possible interrupts so that
   * interrupt coalescing can still be achieved.
   */
- iwl_write32(trans, CSR_INT,
-      trans_pcie->inta | ~trans_pcie->inta_mask);
-
- inta = trans_pcie->inta;
+ iwl_write32(trans, CSR_INT, inta | ~trans_pcie->inta_mask);
 
-#ifdef CONFIG_IWLWIFI_DEBUG
- if (iwl_have_debug_level(IWL_DL_ISR)) {
-  /* just for debug */
-  inta_mask = iwl_read32(trans, CSR_INT_MASK);
+ if (iwl_have_debug_level(IWL_DL_ISR))
   IWL_DEBUG_ISR(trans, "inta 0x%08x, enabled 0x%08x\n",
-         inta, inta_mask);
- }
-#endif
+         inta, iwl_read32(trans, CSR_INT_MASK));
 
- /* saved interrupt in inta variable now we can reset trans_pcie->inta */
- trans_pcie->inta = 0;
-
- spin_unlock_irqrestore(&trans_pcie->irq_lock, flags);
+ spin_unlock(&trans_pcie->irq_lock);
 
  /* Now service all interrupt bits discovered above. */
  if (inta & CSR_INT_BIT_HW_ERR) {
@@ -855,12 +971,11 @@ irqreturn_t iwl_pcie_irq_handler(int irq, void *dev_id)
   goto out;
  }
 
-#ifdef CONFIG_IWLWIFI_DEBUG
  if (iwl_have_debug_level(IWL_DL_ISR)) {
   /* NIC fires this, but we don't use it, redundant with WAKEUP */
   if (inta & CSR_INT_BIT_SCD) {
-   IWL_DEBUG_ISR(trans, "Scheduler finished to transmit "
-          "the frame/frames.\n");
+   IWL_DEBUG_ISR(trans,
+          "Scheduler finished to transmit the frame/frames.\n");
    isr_stats->sch++;
   }
 
@@ -870,7 +985,7 @@ irqreturn_t iwl_pcie_irq_handler(int irq, void *dev_id)
    isr_stats->alive++;
   }
  }
-#endif
+
  /* Safely ignore these bits for debug checks below */
  inta &= ~(CSR_INT_BIT_SCD | CSR_INT_BIT_ALIVE);
 
@@ -884,16 +999,16 @@ irqreturn_t iwl_pcie_irq_handler(int irq, void *dev_id)
 
   isr_stats->rfkill++;
 
-  iwl_op_mode_hw_rf_kill(trans->op_mode, hw_rfkill);
+  iwl_trans_pcie_rf_kill(trans, hw_rfkill);
   if (hw_rfkill) {
-   set_bit(STATUS_RFKILL, &trans_pcie->status);
-   if (test_and_clear_bit(STATUS_HCMD_ACTIVE,
-            &trans_pcie->status))
+   set_bit(STATUS_RFKILL, &trans->status);
+   if (test_and_clear_bit(STATUS_SYNC_HCMD_ACTIVE,
+            &trans->status))
     IWL_DEBUG_RF_KILL(trans,
         "Rfkill while SYNC HCMD in flight\n");
    wake_up(&trans_pcie->wait_command_queue);
   } else {
-   clear_bit(STATUS_RFKILL, &trans_pcie->status);
+   clear_bit(STATUS_RFKILL, &trans->status);
   }
 
   handled |= CSR_INT_BIT_RF_KILL;
@@ -918,9 +1033,8 @@ irqreturn_t iwl_pcie_irq_handler(int irq, void *dev_id)
  /* uCode wakes up after power-down sleep */
  if (inta & CSR_INT_BIT_WAKEUP) {
   IWL_DEBUG_ISR(trans, "Wakeup interrupt\n");
-  iwl_pcie_rxq_inc_wr_ptr(trans, &trans_pcie->rxq);
-  for (i = 0; i < trans->cfg->base_params->num_of_queues; i++)
-   iwl_pcie_txq_inc_wr_ptr(trans, &trans_pcie->txq[i]);
+  iwl_pcie_rxq_check_wrptr(trans);
+  iwl_pcie_txq_check_wrptrs(trans);
 
   isr_stats->wakeup++;
 
@@ -958,8 +1072,6 @@ irqreturn_t iwl_pcie_irq_handler(int irq, void *dev_id)
   iwl_write8(trans, CSR_INT_PERIODIC_REG,
        CSR_INT_PERIODIC_DIS);
 
-  iwl_pcie_rx_handle(trans);
-
   /*
    * Enable periodic interrupt in 8 msec only if we received
    * real RX interrupt (instead of just periodic int), to catch
@@ -972,6 +1084,10 @@ irqreturn_t iwl_pcie_irq_handler(int irq, void *dev_id)
        CSR_INT_PERIODIC_ENA);
 
   isr_stats->rx++;
+
+  local_bh_disable();
+  iwl_pcie_rx_handle(trans);
+  local_bh_enable();
  }
 
  /* This "Tx" DMA channel is used only for loading uCode */
@@ -997,7 +1113,7 @@ irqreturn_t iwl_pcie_irq_handler(int irq, void *dev_id)
 
  /* Re-enable all interrupts */
  /* only Re-enable if disabled by irq */
- if (test_bit(STATUS_INT_ENABLED, &trans_pcie->status))
+ if (test_bit(STATUS_INT_ENABLED, &trans->status))
   iwl_enable_interrupts(trans);
  /* Re-enable RF_KILL if it occurred */
  else if (handled & CSR_INT_BIT_RF_KILL)
@@ -1014,11 +1130,6 @@ out:
  *
  ******************************************************************************/
 
-/* a device (PCI-E) page is 4096 bytes long */
-#define ICT_SHIFT 12
-#define ICT_SIZE (1 << ICT_SHIFT)
-#define ICT_COUNT (ICT_SIZE / sizeof(u32))
-
 /* Free dram table */
 void iwl_pcie_free_ict(struct iwl_trans *trans)
 {
@@ -1043,7 +1154,7 @@ int iwl_pcie_alloc_ict(struct iwl_trans *trans)
  struct iwl_trans_pcie *trans_pcie = IWL_TRANS_GET_PCIE_TRANS(trans);
 
  trans_pcie->ict_tbl =
-  dma_alloc_coherent(trans->dev, ICT_SIZE,
+  dma_zalloc_coherent(trans->dev, ICT_SIZE,
        &trans_pcie->ict_tbl_dma,
        GFP_KERNEL);
  if (!trans_pcie->ict_tbl)
@@ -1055,17 +1166,10 @@ int iwl_pcie_alloc_ict(struct iwl_trans *trans)
   return -EINVAL;
  }
 
- IWL_DEBUG_ISR(trans, "ict dma addr %Lx\n",
-        (unsigned long long)trans_pcie->ict_tbl_dma);
+ IWL_DEBUG_ISR(trans, "ict dma addr %Lx ict vir addr %p\n",
+        (unsigned long long)trans_pcie->ict_tbl_dma,
+        trans_pcie->ict_tbl);
 
- IWL_DEBUG_ISR(trans, "ict vir addr %p\n", trans_pcie->ict_tbl);
-
- /* reset table and index to all 0 */
- memset(trans_pcie->ict_tbl, 0, ICT_SIZE);
- trans_pcie->ict_index = 0;
-
- /* add periodic RX interrupt */
- trans_pcie->inta_mask |= CSR_INT_BIT_RX_PERIODIC;
  return 0;
 }
 
@@ -1076,12 +1180,11 @@ void iwl_pcie_reset_ict(struct iwl_trans *trans)
 {
  struct iwl_trans_pcie *trans_pcie = IWL_TRANS_GET_PCIE_TRANS(trans);
  u32 val;
- unsigned long flags;
 
  if (!trans_pcie->ict_tbl)
   return;
 
- spin_lock_irqsave(&trans_pcie->irq_lock, flags);
+ spin_lock(&trans_pcie->irq_lock);
  iwl_disable_interrupts(trans);
 
  memset(trans_pcie->ict_tbl, 0, ICT_SIZE);
@@ -1098,209 +1201,32 @@ void iwl_pcie_reset_ict(struct iwl_trans *trans)
  trans_pcie->ict_index = 0;
  iwl_write32(trans, CSR_INT, trans_pcie->inta_mask);
  iwl_enable_interrupts(trans);
- spin_unlock_irqrestore(&trans_pcie->irq_lock, flags);
+ spin_unlock(&trans_pcie->irq_lock);
 }
 
 /* Device is going down disable ict interrupt usage */
 void iwl_pcie_disable_ict(struct iwl_trans *trans)
 {
  struct iwl_trans_pcie *trans_pcie = IWL_TRANS_GET_PCIE_TRANS(trans);
- unsigned long flags;
 
- spin_lock_irqsave(&trans_pcie->irq_lock, flags);
+ spin_lock(&trans_pcie->irq_lock);
  trans_pcie->use_ict = false;
- spin_unlock_irqrestore(&trans_pcie->irq_lock, flags);
+ spin_unlock(&trans_pcie->irq_lock);
 }
 
-/* legacy (non-ICT) ISR. Assumes that trans_pcie->irq_lock is held */
-static irqreturn_t iwl_pcie_isr(int irq, void *data)
+irqreturn_t iwl_pcie_isr(int irq, void *data)
 {
  struct iwl_trans *trans = data;
- struct iwl_trans_pcie *trans_pcie = IWL_TRANS_GET_PCIE_TRANS(trans);
- u32 inta, inta_mask;
-#ifdef CONFIG_IWLWIFI_DEBUG
- u32 inta_fh;
-#endif
-
- lockdep_assert_held(&trans_pcie->irq_lock);
-
- trace_iwlwifi_dev_irq(trans->dev);
-
- /* Disable (but don't clear!) interrupts here to avoid
-  *    back-to-back ISRs and sporadic interrupts from our NIC.
-  * If we have something to service, the irq thread will re-enable ints.
-  * If we *don't* have something, we'll re-enable before leaving here. */
- inta_mask = iwl_read32(trans, CSR_INT_MASK);
- iwl_write32(trans, CSR_INT_MASK, 0x00000000);
-
- /* Discover which interrupts are active/pending */
- inta = iwl_read32(trans, CSR_INT);
-
- if (inta & (~inta_mask)) {
-  IWL_DEBUG_ISR(trans,
-         "We got a masked interrupt (0x%08x)...Ack and ignore\n",
-         inta & (~inta_mask));
-  iwl_write32(trans, CSR_INT, inta & (~inta_mask));
-  inta &= inta_mask;
- }
-
- /* Ignore interrupt if there's nothing in NIC to service.
-  * This may be due to IRQ shared with another device,
-  * or due to sporadic interrupts thrown from our NIC. */
- if (!inta) {
-  IWL_DEBUG_ISR(trans, "Ignore interrupt, inta == 0\n");
-  goto none;
- }
-
- if ((inta == 0xFFFFFFFF) || ((inta & 0xFFFFFFF0) == 0xa5a5a5a0)) {
-  /* Hardware disappeared. It might have already raised
-   * an interrupt */
-  IWL_WARN(trans, "HARDWARE GONE?? INTA == 0x%08x\n", inta);
-  return IRQ_HANDLED;
- }
-
-#ifdef CONFIG_IWLWIFI_DEBUG
- if (iwl_have_debug_level(IWL_DL_ISR)) {
-  inta_fh = iwl_read32(trans, CSR_FH_INT_STATUS);
-  IWL_DEBUG_ISR(trans, "ISR inta 0x%08x, enabled 0x%08x, "
-         "fh 0x%08x\n", inta, inta_mask, inta_fh);
- }
-#endif
-
- trans_pcie->inta |= inta;
- /* the thread will service interrupts and re-enable them */
- if (likely(inta))
-  return IRQ_WAKE_THREAD;
- else if (test_bit(STATUS_INT_ENABLED, &trans_pcie->status) &&
-   !trans_pcie->inta)
-  iwl_enable_interrupts(trans);
- return IRQ_HANDLED;
-
-none:
- /* re-enable interrupts here since we don't have anything to service. */
- /* only Re-enable if disabled by irq  and no schedules tasklet. */
- if (test_bit(STATUS_INT_ENABLED, &trans_pcie->status) &&
-     !trans_pcie->inta)
-  iwl_enable_interrupts(trans);
-
- return IRQ_NONE;
-}
-
-/* interrupt handler using ict table, with this interrupt driver will
- * stop using INTA register to get device's interrupt, reading this register
- * is expensive, device will write interrupts in ICT dram table, increment
- * index then will fire interrupt to driver, driver will OR all ICT table
- * entries from current index up to table entry with 0 value. the result is
- * the interrupt we need to service, driver will set the entries back to 0 and
- * set index.
- */
-irqreturn_t iwl_pcie_isr_ict(int irq, void *data)
-{
- struct iwl_trans *trans = data;
- struct iwl_trans_pcie *trans_pcie;
- u32 inta, inta_mask;
- u32 val = 0;
- u32 read;
- unsigned long flags;
 
  if (!trans)
   return IRQ_NONE;
 
- trans_pcie = IWL_TRANS_GET_PCIE_TRANS(trans);
-
- spin_lock_irqsave(&trans_pcie->irq_lock, flags);
-
- /* dram interrupt table not set yet,
-  * use legacy interrupt.
-  */
- if (unlikely(!trans_pcie->use_ict)) {
-  irqreturn_t ret = iwl_pcie_isr(irq, data);
-  spin_unlock_irqrestore(&trans_pcie->irq_lock, flags);
-  return ret;
- }
-
- trace_iwlwifi_dev_irq(trans->dev);
-
  /* Disable (but don't clear!) interrupts here to avoid
   * back-to-back ISRs and sporadic interrupts from our NIC.
   * If we have something to service, the tasklet will re-enable ints.
   * If we *don't* have something, we'll re-enable before leaving here.
   */
- inta_mask = iwl_read32(trans, CSR_INT_MASK);
  iwl_write32(trans, CSR_INT_MASK, 0x00000000);
 
- /* Ignore interrupt if there's nothing in NIC to service.
-  * This may be due to IRQ shared with another device,
-  * or due to sporadic interrupts thrown from our NIC. */
- read = le32_to_cpu(trans_pcie->ict_tbl[trans_pcie->ict_index]);
- trace_iwlwifi_dev_ict_read(trans->dev, trans_pcie->ict_index, read);
- if (!read) {
-  IWL_DEBUG_ISR(trans, "Ignore interrupt, inta == 0\n");
-  goto none;
- }
-
- /*
-  * Collect all entries up to the first 0, starting from ict_index;
-  * note we already read at ict_index.
-  */
- do {
-  val |= read;
-  IWL_DEBUG_ISR(trans, "ICT index %d value 0x%08X\n",
-    trans_pcie->ict_index, read);
-  trans_pcie->ict_tbl[trans_pcie->ict_index] = 0;
-  trans_pcie->ict_index =
-   iwl_queue_inc_wrap(trans_pcie->ict_index, ICT_COUNT);
-
-  read = le32_to_cpu(trans_pcie->ict_tbl[trans_pcie->ict_index]);
-  trace_iwlwifi_dev_ict_read(trans->dev, trans_pcie->ict_index,
-        read);
- } while (read);
-
- /* We should not get this value, just ignore it. */
- if (val == 0xffffffff)
-  val = 0;
-
- /*
-  * this is a w/a for a h/w bug. the h/w bug may cause the Rx bit
-  * (bit 15 before shifting it to 31) to clear when using interrupt
-  * coalescing. fortunately, bits 18 and 19 stay set when this happens
-  * so we use them to decide on the real state of the Rx bit.
-  * In order words, bit 15 is set if bit 18 or bit 19 are set.
-  */
- if (val & 0xC0000)
-  val |= 0x8000;
-
- inta = (0xff & val) | ((0xff00 & val) << 16);
- IWL_DEBUG_ISR(trans, "ISR inta 0x%08x, enabled 0x%08x ict 0x%08x\n",
-        inta, inta_mask, val);
-
- inta &= trans_pcie->inta_mask;
- trans_pcie->inta |= inta;
-
- /* iwl_pcie_tasklet() will service interrupts and re-enable them */
- if (likely(inta)) {
-  spin_unlock_irqrestore(&trans_pcie->irq_lock, flags);
-  return IRQ_WAKE_THREAD;
- } else if (test_bit(STATUS_INT_ENABLED, &trans_pcie->status) &&
-   !trans_pcie->inta) {
-  /* Allow interrupt if was disabled by this handler and
-   * no tasklet was schedules, We should not enable interrupt,
-   * tasklet will enable it.
-   */
-  iwl_enable_interrupts(trans);
- }
-
- spin_unlock_irqrestore(&trans_pcie->irq_lock, flags);
- return IRQ_HANDLED;
-
- none:
- /* re-enable interrupts here since we don't have anything to service.
-  * only Re-enable if disabled by irq.
-  */
- if (test_bit(STATUS_INT_ENABLED, &trans_pcie->status) &&
-     !trans_pcie->inta)
-  iwl_enable_interrupts(trans);
-
- spin_unlock_irqrestore(&trans_pcie->irq_lock, flags);
- return IRQ_NONE;
+ return IRQ_WAKE_THREAD;
 }
diff --git a/drivers/net/wireless/iwlwifi/pcie/trans.c b/drivers/net/wireless/iwlwifi/pcie/trans.c
index aeb70e1..788085b 100644
--- a/drivers/net/wireless/iwlwifi/pcie/trans.c
+++ b/drivers/net/wireless/iwlwifi/pcie/trans.c
@@ -5,7 +5,7 @@
  *
  * GPL LICENSE SUMMARY
  *
- * Copyright(c) 2007 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2007 - 2014 Intel Corporation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of version 2 of the GNU General Public License as
@@ -30,7 +30,7 @@
  *
  * BSD LICENSE
  *
- * Copyright(c) 2005 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2005 - 2014 Intel Corporation. All rights reserved.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -73,33 +73,21 @@
 #include "iwl-csr.h"
 #include "iwl-prph.h"
 #include "iwl-agn-hw.h"
+#include "iwl-fw-error-dump.h"
 #include "internal.h"
 
-static void __iwl_trans_pcie_set_bits_mask(struct iwl_trans *trans,
-        u32 reg, u32 mask, u32 value)
+static u32 iwl_trans_pcie_read_shr(struct iwl_trans *trans, u32 reg)
 {
- u32 v;
-
-#ifdef CONFIG_IWLWIFI_DEBUG
- WARN_ON_ONCE(value & ~mask);
-#endif
-
- v = iwl_read32(trans, reg);
- v &= ~mask;
- v |= value;
- iwl_write32(trans, reg, v);
-}
-
-static inline void __iwl_trans_pcie_clear_bit(struct iwl_trans *trans,
-           u32 reg, u32 mask)
-{
- __iwl_trans_pcie_set_bits_mask(trans, reg, mask, 0);
+ iwl_write32(trans, HEEP_CTRL_WRD_PCIEX_CTRL_REG,
+      ((reg & 0x0000ffff) | (2 << 28)));
+ return iwl_read32(trans, HEEP_CTRL_WRD_PCIEX_DATA_REG);
 }
 
-static inline void __iwl_trans_pcie_set_bit(struct iwl_trans *trans,
-         u32 reg, u32 mask)
+static void iwl_trans_pcie_write_shr(struct iwl_trans *trans, u32 reg, u32 val)
 {
- __iwl_trans_pcie_set_bits_mask(trans, reg, mask, mask);
+ iwl_write32(trans, HEEP_CTRL_WRD_PCIEX_DATA_REG, val);
+ iwl_write32(trans, HEEP_CTRL_WRD_PCIEX_CTRL_REG,
+      ((reg & 0x0000ffff) | (3 << 28)));
 }
 
 static void iwl_pcie_set_pwr(struct iwl_trans *trans, bool vaux)
@@ -150,7 +138,6 @@ static void iwl_pcie_apm_config(struct iwl_trans *trans)
  */
 static int iwl_pcie_apm_init(struct iwl_trans *trans)
 {
- struct iwl_trans_pcie *trans_pcie = IWL_TRANS_GET_PCIE_TRANS(trans);
  int ret = 0;
  IWL_DEBUG_INFO(trans, "Init card's basic functions\n");
 
@@ -160,8 +147,9 @@ static int iwl_pcie_apm_init(struct iwl_trans *trans)
   */
 
  /* Disable L0S exit timer (platform NMI Work/Around) */
- iwl_set_bit(trans, CSR_GIO_CHICKEN_BITS,
-      CSR_GIO_CHICKEN_BITS_REG_BIT_DIS_L0S_EXIT_TIMER);
+ if (trans->cfg->device_family != IWL_DEVICE_FAMILY_8000)
+  iwl_set_bit(trans, CSR_GIO_CHICKEN_BITS,
+       CSR_GIO_CHICKEN_BITS_REG_BIT_DIS_L0S_EXIT_TIMER);
 
  /*
   * Disable L0s without affecting L1;
@@ -206,26 +194,165 @@ static int iwl_pcie_apm_init(struct iwl_trans *trans)
   goto out;
  }
 
+ if (trans->cfg->host_interrupt_operation_mode) {
+  /*
+   * This is a bit of an abuse - This is needed for 7260 / 3160
+   * only check host_interrupt_operation_mode even if this is
+   * not related to host_interrupt_operation_mode.
+   *
+   * Enable the oscillator to count wake up time for L1 exit. This
+   * consumes slightly more power (100uA) - but allows to be sure
+   * that we wake up from L1 on time.
+   *
+   * This looks weird: read twice the same register, discard the
+   * value, set a bit, and yet again, read that same register
+   * just to discard the value. But that's the way the hardware
+   * seems to like it.
+   */
+  iwl_read_prph(trans, OSC_CLK);
+  iwl_read_prph(trans, OSC_CLK);
+  iwl_set_bits_prph(trans, OSC_CLK, OSC_CLK_FORCE_CONTROL);
+  iwl_read_prph(trans, OSC_CLK);
+  iwl_read_prph(trans, OSC_CLK);
+ }
+
  /*
   * Enable DMA clock and wait for it to stabilize.
   *
-  * Write to "CLK_EN_REG"; "1" bits enable clocks, while "0" bits
-  * do not disable clocks.  This preserves any hardware bits already
-  * set by default in "CLK_CTRL_REG" after reset.
+  * Write to "CLK_EN_REG"; "1" bits enable clocks, while "0"
+  * bits do not disable clocks.  This preserves any hardware
+  * bits already set by default in "CLK_CTRL_REG" after reset.
   */
- iwl_write_prph(trans, APMG_CLK_EN_REG, APMG_CLK_VAL_DMA_CLK_RQT);
- udelay(20);
+ if (trans->cfg->device_family != IWL_DEVICE_FAMILY_8000) {
+  iwl_write_prph(trans, APMG_CLK_EN_REG,
+          APMG_CLK_VAL_DMA_CLK_RQT);
+  udelay(20);
 
- /* Disable L1-Active */
- iwl_set_bits_prph(trans, APMG_PCIDEV_STT_REG,
-     APMG_PCIDEV_STT_VAL_L1_ACT_DIS);
+  /* Disable L1-Active */
+  iwl_set_bits_prph(trans, APMG_PCIDEV_STT_REG,
+      APMG_PCIDEV_STT_VAL_L1_ACT_DIS);
 
- set_bit(STATUS_DEVICE_ENABLED, &trans_pcie->status);
+  /* Clear the interrupt in APMG if the NIC is in RFKILL */
+  iwl_write_prph(trans, APMG_RTC_INT_STT_REG,
+          APMG_RTC_INT_STT_RFKILL);
+ }
+
+ set_bit(STATUS_DEVICE_ENABLED, &trans->status);
 
 out:
  return ret;
 }
 
+/*
+ * Enable LP XTAL to avoid HW bug where device may consume much power if
+ * FW is not loaded after device reset. LP XTAL is disabled by default
+ * after device HW reset. Do it only if XTAL is fed by internal source.
+ * Configure device's "persistence" mode to avoid resetting XTAL again when
+ * SHRD_HW_RST occurs in S3.
+ */
+static void iwl_pcie_apm_lp_xtal_enable(struct iwl_trans *trans)
+{
+ int ret;
+ u32 apmg_gp1_reg;
+ u32 apmg_xtal_cfg_reg;
+ u32 dl_cfg_reg;
+
+ /* Force XTAL ON */
+ __iwl_trans_pcie_set_bit(trans, CSR_GP_CNTRL,
+     CSR_GP_CNTRL_REG_FLAG_XTAL_ON);
+
+ /* Reset entire device - do controller reset (results in SHRD_HW_RST) */
+ iwl_set_bit(trans, CSR_RESET, CSR_RESET_REG_FLAG_SW_RESET);
+
+ udelay(10);
+
+ /*
+  * Set "initialization complete" bit to move adapter from
+  * D0U* --> D0A* (powered-up active) state.
+  */
+ iwl_set_bit(trans, CSR_GP_CNTRL, CSR_GP_CNTRL_REG_FLAG_INIT_DONE);
+
+ /*
+  * Wait for clock stabilization; once stabilized, access to
+  * device-internal resources is possible.
+  */
+ ret = iwl_poll_bit(trans, CSR_GP_CNTRL,
+      CSR_GP_CNTRL_REG_FLAG_MAC_CLOCK_READY,
+      CSR_GP_CNTRL_REG_FLAG_MAC_CLOCK_READY,
+      25000);
+ if (WARN_ON(ret < 0)) {
+  IWL_ERR(trans, "Access time out - failed to enable LP XTAL\n");
+  /* Release XTAL ON request */
+  __iwl_trans_pcie_clear_bit(trans, CSR_GP_CNTRL,
+        CSR_GP_CNTRL_REG_FLAG_XTAL_ON);
+  return;
+ }
+
+ /*
+  * Clear "disable persistence" to avoid LP XTAL resetting when
+  * SHRD_HW_RST is applied in S3.
+  */
+ iwl_clear_bits_prph(trans, APMG_PCIDEV_STT_REG,
+        APMG_PCIDEV_STT_VAL_PERSIST_DIS);
+
+ /*
+  * Force APMG XTAL to be active to prevent its disabling by HW
+  * caused by APMG idle state.
+  */
+ apmg_xtal_cfg_reg = iwl_trans_pcie_read_shr(trans,
+          SHR_APMG_XTAL_CFG_REG);
+ iwl_trans_pcie_write_shr(trans, SHR_APMG_XTAL_CFG_REG,
+     apmg_xtal_cfg_reg |
+     SHR_APMG_XTAL_CFG_XTAL_ON_REQ);
+
+ /*
+  * Reset entire device again - do controller reset (results in
+  * SHRD_HW_RST). Turn MAC off before proceeding.
+  */
+ iwl_set_bit(trans, CSR_RESET, CSR_RESET_REG_FLAG_SW_RESET);
+
+ udelay(10);
+
+ /* Enable LP XTAL by indirect access through CSR */
+ apmg_gp1_reg = iwl_trans_pcie_read_shr(trans, SHR_APMG_GP1_REG);
+ iwl_trans_pcie_write_shr(trans, SHR_APMG_GP1_REG, apmg_gp1_reg |
+     SHR_APMG_GP1_WF_XTAL_LP_EN |
+     SHR_APMG_GP1_CHICKEN_BIT_SELECT);
+
+ /* Clear delay line clock power up */
+ dl_cfg_reg = iwl_trans_pcie_read_shr(trans, SHR_APMG_DL_CFG_REG);
+ iwl_trans_pcie_write_shr(trans, SHR_APMG_DL_CFG_REG, dl_cfg_reg &
+     ~SHR_APMG_DL_CFG_DL_CLOCK_POWER_UP);
+
+ /*
+  * Enable persistence mode to avoid LP XTAL resetting when
+  * SHRD_HW_RST is applied in S3.
+  */
+ iwl_set_bit(trans, CSR_HW_IF_CONFIG_REG,
+      CSR_HW_IF_CONFIG_REG_PERSIST_MODE);
+
+ /*
+  * Clear "initialization complete" bit to move adapter from
+  * D0A* (powered-up Active) --> D0U* (Uninitialized) state.
+  */
+ iwl_clear_bit(trans, CSR_GP_CNTRL,
+        CSR_GP_CNTRL_REG_FLAG_INIT_DONE);
+
+ /* Activates XTAL resources monitor */
+ __iwl_trans_pcie_set_bit(trans, CSR_MONITOR_CFG_REG,
+     CSR_MONITOR_XTAL_RESOURCES);
+
+ /* Release XTAL ON request */
+ __iwl_trans_pcie_clear_bit(trans, CSR_GP_CNTRL,
+       CSR_GP_CNTRL_REG_FLAG_XTAL_ON);
+ udelay(10);
+
+ /* Release APMG XTAL */
+ iwl_trans_pcie_write_shr(trans, SHR_APMG_XTAL_CFG_REG,
+     apmg_xtal_cfg_reg &
+     ~SHR_APMG_XTAL_CFG_XTAL_ON_REQ);
+}
+
 static int iwl_pcie_apm_stop_master(struct iwl_trans *trans)
 {
  int ret = 0;
@@ -246,14 +373,18 @@ static int iwl_pcie_apm_stop_master(struct iwl_trans *trans)
 
 static void iwl_pcie_apm_stop(struct iwl_trans *trans)
 {
- struct iwl_trans_pcie *trans_pcie = IWL_TRANS_GET_PCIE_TRANS(trans);
  IWL_DEBUG_INFO(trans, "Stop card, put in low power state\n");
 
- clear_bit(STATUS_DEVICE_ENABLED, &trans_pcie->status);
+ clear_bit(STATUS_DEVICE_ENABLED, &trans->status);
 
  /* Stop device's DMA activity */
  iwl_pcie_apm_stop_master(trans);
 
+ if (trans->cfg->lp_xtal_workaround) {
+  iwl_pcie_apm_lp_xtal_enable(trans);
+  return;
+ }
+
  /* Reset the entire device */
  iwl_set_bit(trans, CSR_RESET, CSR_RESET_REG_FLAG_SW_RESET);
 
@@ -270,18 +401,15 @@ static void iwl_pcie_apm_stop(struct iwl_trans *trans)
 static int iwl_pcie_nic_init(struct iwl_trans *trans)
 {
  struct iwl_trans_pcie *trans_pcie = IWL_TRANS_GET_PCIE_TRANS(trans);
- unsigned long flags;
 
  /* nic_init */
- spin_lock_irqsave(&trans_pcie->irq_lock, flags);
+ spin_lock(&trans_pcie->irq_lock);
  iwl_pcie_apm_init(trans);
 
- /* Set interrupt coalescing calibration timer to default (512 usecs) */
- iwl_write8(trans, CSR_INT_COALESCING, IWL_HOST_INT_CALIB_TIMEOUT_DEF);
+ spin_unlock(&trans_pcie->irq_lock);
 
- spin_unlock_irqrestore(&trans_pcie->irq_lock, flags);
-
- iwl_pcie_set_pwr(trans, false);
+ if (trans->cfg->device_family != IWL_DEVICE_FAMILY_8000)
+  iwl_pcie_set_pwr(trans, false);
 
  iwl_op_mode_nic_config(trans->op_mode);
 
@@ -326,6 +454,7 @@ static int iwl_pcie_prepare_card_hw(struct iwl_trans *trans)
 {
  int ret;
  int t = 0;
+ int iter;
 
  IWL_DEBUG_INFO(trans, "iwl_trans_prepare_card_hw enter\n");
 
@@ -334,18 +463,23 @@ static int iwl_pcie_prepare_card_hw(struct iwl_trans *trans)
  if (ret >= 0)
   return 0;
 
- /* If HW is not ready, prepare the conditions to check again */
- iwl_set_bit(trans, CSR_HW_IF_CONFIG_REG,
-      CSR_HW_IF_CONFIG_REG_PREPARE);
+ for (iter = 0; iter < 10; iter++) {
+  /* If HW is not ready, prepare the conditions to check again */
+  iwl_set_bit(trans, CSR_HW_IF_CONFIG_REG,
+       CSR_HW_IF_CONFIG_REG_PREPARE);
+
+  do {
+   ret = iwl_pcie_set_hw_ready(trans);
+   if (ret >= 0)
+    return 0;
 
- do {
-  ret = iwl_pcie_set_hw_ready(trans);
-  if (ret >= 0)
-   return 0;
+   usleep_range(200, 1000);
+   t += 200;
+  } while (t < 150000);
+  msleep(25);
+ }
 
-  usleep_range(200, 1000);
-  t += 200;
- } while (t < 150000);
+ IWL_DEBUG_INFO(trans, "got NIC after %d iterations\n", iter);
 
  return ret;
 }
@@ -405,20 +539,27 @@ static int iwl_pcie_load_section(struct iwl_trans *trans, u8 section_num,
 {
  u8 *v_addr;
  dma_addr_t p_addr;
- u32 offset;
+ u32 offset, chunk_sz = section->len;
  int ret = 0;
 
  IWL_DEBUG_FW(trans, "[%d] uCode section being loaded...\n",
        section_num);
 
- v_addr = dma_alloc_coherent(trans->dev, PAGE_SIZE, &p_addr, GFP_KERNEL);
- if (!v_addr)
-  return -ENOMEM;
+ v_addr = dma_alloc_coherent(trans->dev, chunk_sz, &p_addr,
+        GFP_KERNEL | __GFP_NOWARN);
+ if (!v_addr) {
+  IWL_DEBUG_INFO(trans, "Falling back to small chunks of DMA\n");
+  chunk_sz = PAGE_SIZE;
+  v_addr = dma_alloc_coherent(trans->dev, chunk_sz,
+         &p_addr, GFP_KERNEL);
+  if (!v_addr)
+   return -ENOMEM;
+ }
 
- for (offset = 0; offset < section->len; offset += PAGE_SIZE) {
+ for (offset = 0; offset < section->len; offset += chunk_sz) {
   u32 copy_size;
 
-  copy_size = min_t(u32, PAGE_SIZE, section->len - offset);
+  copy_size = min_t(u32, chunk_sz, section->len - offset);
 
   memcpy(v_addr, (u8 *)section->data + offset, copy_size);
   ret = iwl_pcie_load_firmware_chunk(trans,
@@ -432,26 +573,185 @@ static int iwl_pcie_load_section(struct iwl_trans *trans, u8 section_num,
   }
  }
 
- dma_free_coherent(trans->dev, PAGE_SIZE, v_addr, p_addr);
+ dma_free_coherent(trans->dev, chunk_sz, v_addr, p_addr);
  return ret;
 }
 
-static int iwl_pcie_load_given_ucode(struct iwl_trans *trans,
-    const struct fw_img *image)
+static int iwl_pcie_load_cpu_secured_sections(struct iwl_trans *trans,
+           const struct fw_img *image,
+           int cpu,
+           int *first_ucode_section)
 {
+ int shift_param;
  int i, ret = 0;
+ u32 last_read_idx = 0;
+
+ if (cpu == 1) {
+  shift_param = 0;
+  *first_ucode_section = 0;
+ } else {
+  shift_param = 16;
+  (*first_ucode_section)++;
+ }
+
+ for (i = *first_ucode_section; i < IWL_UCODE_SECTION_MAX; i++) {
+  last_read_idx = i;
+
+  if (!image->sec[i].data ||
+      image->sec[i].offset == CPU1_CPU2_SEPARATOR_SECTION) {
+   IWL_DEBUG_FW(trans,
+         "Break since Data not valid or Empty section, sec = %d\n",
+         i);
+   break;
+  }
+
+  if (i == (*first_ucode_section) + 1)
+   /* set CPU to started */
+   iwl_set_bits_prph(trans,
+       CSR_UCODE_LOAD_STATUS_ADDR,
+       LMPM_CPU_HDRS_LOADING_COMPLETED
+       << shift_param);
+
+  ret = iwl_pcie_load_section(trans, i, &image->sec[i]);
+  if (ret)
+   return ret;
+ }
+ /* image loading complete */
+ iwl_set_bits_prph(trans,
+     CSR_UCODE_LOAD_STATUS_ADDR,
+     LMPM_CPU_UCODE_LOADING_COMPLETED << shift_param);
+
+ *first_ucode_section = last_read_idx;
+
+ return 0;
+}
+
+static int iwl_pcie_load_cpu_sections(struct iwl_trans *trans,
+          const struct fw_img *image,
+          int cpu,
+          int *first_ucode_section)
+{
+ int shift_param;
+ int i, ret = 0;
+ u32 last_read_idx = 0;
+
+ if (cpu == 1) {
+  shift_param = 0;
+  *first_ucode_section = 0;
+ } else {
+  shift_param = 16;
+  (*first_ucode_section)++;
+ }
+
+ for (i = *first_ucode_section; i < IWL_UCODE_SECTION_MAX; i++) {
+  last_read_idx = i;
 
- for (i = 0; i < IWL_UCODE_SECTION_MAX; i++) {
-  if (!image->sec[i].data)
+  if (!image->sec[i].data ||
+      image->sec[i].offset == CPU1_CPU2_SEPARATOR_SECTION) {
+   IWL_DEBUG_FW(trans,
+         "Break since Data not valid or Empty section, sec = %d\n",
+         i);
    break;
+  }
 
   ret = iwl_pcie_load_section(trans, i, &image->sec[i]);
   if (ret)
    return ret;
  }
 
- /* Remove all resets to allow NIC to operate */
- iwl_write32(trans, CSR_RESET, 0);
+ if (trans->cfg->device_family == IWL_DEVICE_FAMILY_8000)
+  iwl_set_bits_prph(trans,
+      CSR_UCODE_LOAD_STATUS_ADDR,
+      (LMPM_CPU_UCODE_LOADING_COMPLETED |
+       LMPM_CPU_HDRS_LOADING_COMPLETED |
+       LMPM_CPU_UCODE_LOADING_STARTED) <<
+     shift_param);
+
+ *first_ucode_section = last_read_idx;
+
+ return 0;
+}
+
+static int iwl_pcie_load_given_ucode(struct iwl_trans *trans,
+    const struct fw_img *image)
+{
+ int ret = 0;
+ int first_ucode_section;
+
+ IWL_DEBUG_FW(trans,
+       "working with %s image\n",
+       image->is_secure ? "Secured" : "Non Secured");
+ IWL_DEBUG_FW(trans,
+       "working with %s CPU\n",
+       image->is_dual_cpus ? "Dual" : "Single");
+
+ /* configure the ucode to be ready to get the secured image */
+ if (image->is_secure) {
+  /* set secure boot inspector addresses */
+  iwl_write_prph(trans,
+          LMPM_SECURE_INSPECTOR_CODE_ADDR,
+          LMPM_SECURE_INSPECTOR_CODE_MEM_SPACE);
+
+  iwl_write_prph(trans,
+          LMPM_SECURE_INSPECTOR_DATA_ADDR,
+          LMPM_SECURE_INSPECTOR_DATA_MEM_SPACE);
+
+  /* set CPU1 header address */
+  iwl_write_prph(trans,
+          LMPM_SECURE_UCODE_LOAD_CPU1_HDR_ADDR,
+          LMPM_SECURE_CPU1_HDR_MEM_SPACE);
+
+  /* load to FW the binary Secured sections of CPU1 */
+  ret = iwl_pcie_load_cpu_secured_sections(trans, image, 1,
+        &first_ucode_section);
+  if (ret)
+   return ret;
+
+ } else {
+  /* load to FW the binary Non secured sections of CPU1 */
+  ret = iwl_pcie_load_cpu_sections(trans, image, 1,
+       &first_ucode_section);
+  if (ret)
+   return ret;
+ }
+
+ if (image->is_dual_cpus) {
+  /* set CPU2 header address */
+  iwl_write_prph(trans,
+          LMPM_SECURE_UCODE_LOAD_CPU2_HDR_ADDR,
+          LMPM_SECURE_CPU2_HDR_MEM_SPACE);
+
+  /* load to FW the binary sections of CPU2 */
+  if (image->is_secure)
+   ret = iwl_pcie_load_cpu_secured_sections(
+       trans, image, 2,
+       &first_ucode_section);
+  else
+   ret = iwl_pcie_load_cpu_sections(trans, image, 2,
+        &first_ucode_section);
+  if (ret)
+   return ret;
+ }
+
+ /* release CPU reset */
+ if (trans->cfg->device_family == IWL_DEVICE_FAMILY_8000)
+  iwl_write_prph(trans, RELEASE_CPU_RESET, RELEASE_CPU_RESET_BIT);
+ else
+  iwl_write32(trans, CSR_RESET, 0);
+
+ if (image->is_secure) {
+  /* wait for image verification to complete  */
+  ret = iwl_poll_prph_bit(trans,
+     LMPM_SECURE_BOOT_CPU1_STATUS_ADDR,
+     LMPM_SECURE_BOOT_STATUS_SUCCESS,
+     LMPM_SECURE_BOOT_STATUS_SUCCESS,
+     LMPM_SECURE_TIME_OUT);
+
+  if (ret < 0) {
+   IWL_ERR(trans, "Time out on secure boot process\n");
+   return ret;
+  }
+ }
 
  return 0;
 }
@@ -459,7 +759,6 @@ static int iwl_pcie_load_given_ucode(struct iwl_trans *trans,
 static int iwl_trans_pcie_start_fw(struct iwl_trans *trans,
        const struct fw_img *fw, bool run_in_rfkill)
 {
- struct iwl_trans_pcie *trans_pcie = IWL_TRANS_GET_PCIE_TRANS(trans);
  int ret;
  bool hw_rfkill;
 
@@ -469,17 +768,15 @@ static int iwl_trans_pcie_start_fw(struct iwl_trans *trans,
   return -EIO;
  }
 
- clear_bit(STATUS_FW_ERROR, &trans_pcie->status);
-
  iwl_enable_rfkill_int(trans);
 
  /* If platform's RF_KILL switch is NOT set to KILL */
  hw_rfkill = iwl_is_rfkill_set(trans);
  if (hw_rfkill)
-  set_bit(STATUS_RFKILL, &trans_pcie->status);
+  set_bit(STATUS_RFKILL, &trans->status);
  else
-  clear_bit(STATUS_RFKILL, &trans_pcie->status);
- iwl_op_mode_hw_rf_kill(trans->op_mode, hw_rfkill);
+  clear_bit(STATUS_RFKILL, &trans->status);
+ iwl_trans_pcie_rf_kill(trans, hw_rfkill);
  if (hw_rfkill && !run_in_rfkill)
   return -ERFKILL;
 
@@ -517,12 +814,14 @@ static void iwl_trans_pcie_fw_alive(struct iwl_trans *trans, u32 scd_addr)
 static void iwl_trans_pcie_stop_device(struct iwl_trans *trans)
 {
  struct iwl_trans_pcie *trans_pcie = IWL_TRANS_GET_PCIE_TRANS(trans);
- unsigned long flags;
+ bool hw_rfkill, was_hw_rfkill;
+
+ was_hw_rfkill = iwl_is_rfkill_set(trans);
 
  /* tell the device to stop sending interrupts */
- spin_lock_irqsave(&trans_pcie->irq_lock, flags);
+ spin_lock(&trans_pcie->irq_lock);
  iwl_disable_interrupts(trans);
- spin_unlock_irqrestore(&trans_pcie->irq_lock, flags);
+ spin_unlock(&trans_pcie->irq_lock);
 
  /* device going down, Stop using ICT table */
  iwl_pcie_disable_ict(trans);
@@ -534,7 +833,7 @@ static void iwl_trans_pcie_stop_device(struct iwl_trans *trans)
   * restart. So don't process again if the device is
   * already dead.
   */
- if (test_bit(STATUS_DEVICE_ENABLED, &trans_pcie->status)) {
+ if (test_bit(STATUS_DEVICE_ENABLED, &trans->status)) {
   iwl_pcie_tx_stop(trans);
   iwl_pcie_rx_stop(trans);
 
@@ -554,30 +853,64 @@ static void iwl_trans_pcie_stop_device(struct iwl_trans *trans)
  /* Upon stop, the APM issues an interrupt if HW RF kill is set.
   * Clean again the interrupt here
   */
- spin_lock_irqsave(&trans_pcie->irq_lock, flags);
+ spin_lock(&trans_pcie->irq_lock);
  iwl_disable_interrupts(trans);
- spin_unlock_irqrestore(&trans_pcie->irq_lock, flags);
-
- iwl_enable_rfkill_int(trans);
+ spin_unlock(&trans_pcie->irq_lock);
 
  /* stop and reset the on-board processor */
  iwl_write32(trans, CSR_RESET, CSR_RESET_REG_FLAG_NEVO_RESET);
 
  /* clear all status bits */
- clear_bit(STATUS_HCMD_ACTIVE, &trans_pcie->status);
- clear_bit(STATUS_INT_ENABLED, &trans_pcie->status);
- clear_bit(STATUS_DEVICE_ENABLED, &trans_pcie->status);
- clear_bit(STATUS_TPOWER_PMI, &trans_pcie->status);
- clear_bit(STATUS_RFKILL, &trans_pcie->status);
+ clear_bit(STATUS_SYNC_HCMD_ACTIVE, &trans->status);
+ clear_bit(STATUS_INT_ENABLED, &trans->status);
+ clear_bit(STATUS_DEVICE_ENABLED, &trans->status);
+ clear_bit(STATUS_TPOWER_PMI, &trans->status);
+ clear_bit(STATUS_RFKILL, &trans->status);
+
+ /*
+  * Even if we stop the HW, we still want the RF kill
+  * interrupt
+  */
+ iwl_enable_rfkill_int(trans);
+
+ /*
+  * Check again since the RF kill state may have changed while
+  * all the interrupts were disabled, in this case we couldn't
+  * receive the RF kill interrupt and update the state in the
+  * op_mode.
+  * Don't call the op_mode if the rkfill state hasn't changed.
+  * This allows the op_mode to call stop_device from the rfkill
+  * notification without endless recursion. Under very rare
+  * circumstances, we might have a small recursion if the rfkill
+  * state changed exactly now while we were called from stop_device.
+  * This is very unlikely but can happen and is supported.
+  */
+ hw_rfkill = iwl_is_rfkill_set(trans);
+ if (hw_rfkill)
+  set_bit(STATUS_RFKILL, &trans->status);
+ else
+  clear_bit(STATUS_RFKILL, &trans->status);
+ if (hw_rfkill != was_hw_rfkill)
+  iwl_trans_pcie_rf_kill(trans, hw_rfkill);
 }
 
-static void iwl_trans_pcie_d3_suspend(struct iwl_trans *trans)
+void iwl_trans_pcie_rf_kill(struct iwl_trans *trans, bool state)
 {
- /* let the ucode operate on its own */
- iwl_write32(trans, CSR_UCODE_DRV_GP1_SET,
-      CSR_UCODE_DRV_GP1_BIT_D3_CFG_COMPLETE);
+ if (iwl_op_mode_hw_rf_kill(trans->op_mode, state))
+  iwl_trans_pcie_stop_device(trans);
+}
 
+static void iwl_trans_pcie_d3_suspend(struct iwl_trans *trans, bool test)
+{
  iwl_disable_interrupts(trans);
+
+ /*
+  * in testing mode, the host stays awake and the
+  * hardware won't be reset (not even partially)
+  */
+ if (test)
+  return;
+
  iwl_pcie_disable_ict(trans);
 
  iwl_clear_bit(trans, CSR_GP_CNTRL,
@@ -596,11 +929,18 @@ static void iwl_trans_pcie_d3_suspend(struct iwl_trans *trans)
 }
 
 static int iwl_trans_pcie_d3_resume(struct iwl_trans *trans,
-        enum iwl_d3_status *status)
+        enum iwl_d3_status *status,
+        bool test)
 {
  u32 val;
  int ret;
 
+ if (test) {
+  iwl_enable_interrupts(trans);
+  *status = IWL_D3_STATUS_ALIVE;
+  return 0;
+ }
+
  iwl_pcie_set_pwr(trans, false);
 
  val = iwl_read32(trans, CSR_RESET);
@@ -636,16 +976,12 @@ static int iwl_trans_pcie_d3_resume(struct iwl_trans *trans,
   return ret;
  }
 
- iwl_write32(trans, CSR_UCODE_DRV_GP1_CLR,
-      CSR_UCODE_DRV_GP1_BIT_D3_CFG_COMPLETE);
-
  *status = IWL_D3_STATUS_ALIVE;
  return 0;
 }
 
 static int iwl_trans_pcie_start_hw(struct iwl_trans *trans)
 {
- struct iwl_trans_pcie *trans_pcie = IWL_TRANS_GET_PCIE_TRANS(trans);
  bool hw_rfkill;
  int err;
 
@@ -655,6 +991,11 @@ static int iwl_trans_pcie_start_hw(struct iwl_trans *trans)
   return err;
  }
 
+ /* Reset the entire device */
+ iwl_write32(trans, CSR_RESET, CSR_RESET_REG_FLAG_SW_RESET);
+
+ usleep_range(10, 15);
+
  iwl_pcie_apm_init(trans);
 
  /* From now on, the op_mode will be kept updated about RF kill state */
@@ -662,53 +1003,30 @@ static int iwl_trans_pcie_start_hw(struct iwl_trans *trans)
 
  hw_rfkill = iwl_is_rfkill_set(trans);
  if (hw_rfkill)
-  set_bit(STATUS_RFKILL, &trans_pcie->status);
+  set_bit(STATUS_RFKILL, &trans->status);
  else
-  clear_bit(STATUS_RFKILL, &trans_pcie->status);
- iwl_op_mode_hw_rf_kill(trans->op_mode, hw_rfkill);
+  clear_bit(STATUS_RFKILL, &trans->status);
+ iwl_trans_pcie_rf_kill(trans, hw_rfkill);
 
  return 0;
 }
 
-static void iwl_trans_pcie_stop_hw(struct iwl_trans *trans,
-       bool op_mode_leaving)
+static void iwl_trans_pcie_op_mode_leave(struct iwl_trans *trans)
 {
  struct iwl_trans_pcie *trans_pcie = IWL_TRANS_GET_PCIE_TRANS(trans);
- bool hw_rfkill;
- unsigned long flags;
 
- spin_lock_irqsave(&trans_pcie->irq_lock, flags);
+ /* disable interrupts - don't enable HW RF kill interrupt */
+ spin_lock(&trans_pcie->irq_lock);
  iwl_disable_interrupts(trans);
- spin_unlock_irqrestore(&trans_pcie->irq_lock, flags);
+ spin_unlock(&trans_pcie->irq_lock);
 
  iwl_pcie_apm_stop(trans);
 
- spin_lock_irqsave(&trans_pcie->irq_lock, flags);
+ spin_lock(&trans_pcie->irq_lock);
  iwl_disable_interrupts(trans);
- spin_unlock_irqrestore(&trans_pcie->irq_lock, flags);
+ spin_unlock(&trans_pcie->irq_lock);
 
  iwl_pcie_disable_ict(trans);
-
- if (!op_mode_leaving) {
-  /*
-   * Even if we stop the HW, we still want the RF kill
-   * interrupt
-   */
-  iwl_enable_rfkill_int(trans);
-
-  /*
-   * Check again since the RF kill state may have changed while
-   * all the interrupts were disabled, in this case we couldn't
-   * receive the RF kill interrupt and update the state in the
-   * op_mode.
-   */
-  hw_rfkill = iwl_is_rfkill_set(trans);
-  if (hw_rfkill)
-   set_bit(STATUS_RFKILL, &trans_pcie->status);
-  else
-   clear_bit(STATUS_RFKILL, &trans_pcie->status);
-  iwl_op_mode_hw_rf_kill(trans->op_mode, hw_rfkill);
- }
 }
 
 static void iwl_trans_pcie_write8(struct iwl_trans *trans, u32 ofs, u8 val)
@@ -741,6 +1059,12 @@ static void iwl_trans_pcie_write_prph(struct iwl_trans *trans, u32 addr,
  iwl_trans_pcie_write32(trans, HBUS_TARG_PRPH_WDAT, val);
 }
 
+static int iwl_pcie_dummy_napi_poll(struct napi_struct *napi, int budget)
+{
+ WARN_ON(1);
+ return 0;
+}
+
 static void iwl_trans_pcie_configure(struct iwl_trans *trans,
          const struct iwl_trans_config *trans_cfg)
 {
@@ -767,6 +1091,18 @@ static void iwl_trans_pcie_configure(struct iwl_trans *trans,
 
  trans_pcie->command_names = trans_cfg->command_names;
  trans_pcie->bc_table_dword = trans_cfg->bc_table_dword;
+
+ /* Initialize NAPI here - it should be before registering to mac80211
+  * in the opmode but after the HW struct is allocated.
+  * As this function may be called again in some corner cases don't
+  * do anything if NAPI was already initialized.
+  */
+ if (!trans_pcie->napi.poll && trans->op_mode->ops->napi_add) {
+  init_dummy_netdev(&trans_pcie->napi_dev);
+  iwl_op_mode_napi_add(trans->op_mode, &trans_pcie->napi,
+         &trans_pcie->napi_dev,
+         iwl_pcie_dummy_napi_poll, 64);
+ }
 }
 
 void iwl_trans_pcie_free(struct iwl_trans *trans)
@@ -787,44 +1123,30 @@ void iwl_trans_pcie_free(struct iwl_trans *trans)
  pci_disable_device(trans_pcie->pci_dev);
  kmem_cache_destroy(trans->dev_cmd_pool);
 
+ if (trans_pcie->napi.poll)
+  netif_napi_del(&trans_pcie->napi);
+
  kfree(trans);
 }
 
 static void iwl_trans_pcie_set_pmi(struct iwl_trans *trans, bool state)
 {
- struct iwl_trans_pcie *trans_pcie = IWL_TRANS_GET_PCIE_TRANS(trans);
-
  if (state)
-  set_bit(STATUS_TPOWER_PMI, &trans_pcie->status);
+  set_bit(STATUS_TPOWER_PMI, &trans->status);
  else
-  clear_bit(STATUS_TPOWER_PMI, &trans_pcie->status);
-}
-
-#ifdef CONFIG_PM_SLEEP
-static int iwl_trans_pcie_suspend(struct iwl_trans *trans)
-{
- return 0;
+  clear_bit(STATUS_TPOWER_PMI, &trans->status);
 }
 
-static int iwl_trans_pcie_resume(struct iwl_trans *trans)
-{
- bool hw_rfkill;
-
- iwl_enable_rfkill_int(trans);
-
- hw_rfkill = iwl_is_rfkill_set(trans);
- iwl_op_mode_hw_rf_kill(trans->op_mode, hw_rfkill);
-
- return 0;
-}
-#endif /* CONFIG_PM_SLEEP */
-
 static bool iwl_trans_pcie_grab_nic_access(struct iwl_trans *trans, bool silent,
       unsigned long *flags)
 {
  int ret;
- struct iwl_trans_pcie *pcie_trans = IWL_TRANS_GET_PCIE_TRANS(trans);
- spin_lock_irqsave(&pcie_trans->reg_lock, *flags);
+ struct iwl_trans_pcie *trans_pcie = IWL_TRANS_GET_PCIE_TRANS(trans);
+
+ spin_lock_irqsave(&trans_pcie->reg_lock, *flags);
+
+ if (trans_pcie->cmd_in_flight)
+  goto out;
 
  /* this bit wakes up the NIC */
  __iwl_trans_pcie_set_bit(trans, CSR_GP_CNTRL,
@@ -860,31 +1182,35 @@ static bool iwl_trans_pcie_grab_nic_access(struct iwl_trans *trans, bool silent,
    WARN_ONCE(1,
       "Timeout waiting for hardware access (CSR_GP_CNTRL 0x%08x)\n",
       val);
-   spin_unlock_irqrestore(&pcie_trans->reg_lock, *flags);
+   spin_unlock_irqrestore(&trans_pcie->reg_lock, *flags);
    return false;
   }
  }
 
+out:
  /*
   * Fool sparse by faking we release the lock - sparse will
   * track nic_access anyway.
   */
- __release(&pcie_trans->reg_lock);
+ __release(&trans_pcie->reg_lock);
  return true;
 }
 
 static void iwl_trans_pcie_release_nic_access(struct iwl_trans *trans,
            unsigned long *flags)
 {
- struct iwl_trans_pcie *pcie_trans = IWL_TRANS_GET_PCIE_TRANS(trans);
+ struct iwl_trans_pcie *trans_pcie = IWL_TRANS_GET_PCIE_TRANS(trans);
 
- lockdep_assert_held(&pcie_trans->reg_lock);
+ lockdep_assert_held(&trans_pcie->reg_lock);
 
  /*
   * Fool sparse by faking we acquiring the lock - sparse will
   * track nic_access anyway.
   */
- __acquire(&pcie_trans->reg_lock);
+ __acquire(&trans_pcie->reg_lock);
+
+ if (trans_pcie->cmd_in_flight)
+  goto out;
 
  __iwl_trans_pcie_clear_bit(trans, CSR_GP_CNTRL,
        CSR_GP_CNTRL_REG_FLAG_MAC_ACCESS_REQ);
@@ -895,7 +1221,8 @@ static void iwl_trans_pcie_release_nic_access(struct iwl_trans *trans,
   * scheduled on different CPUs (after we drop reg_lock).
   */
  mmiowb();
- spin_unlock_irqrestore(&pcie_trans->reg_lock, *flags);
+out:
+ spin_unlock_irqrestore(&trans_pcie->reg_lock, *flags);
 }
 
 static int iwl_trans_pcie_read_mem(struct iwl_trans *trans, u32 addr,
@@ -917,11 +1244,11 @@ static int iwl_trans_pcie_read_mem(struct iwl_trans *trans, u32 addr,
 }
 
 static int iwl_trans_pcie_write_mem(struct iwl_trans *trans, u32 addr,
-        void *buf, int dwords)
+        const void *buf, int dwords)
 {
  unsigned long flags;
  int offs, ret = 0;
- u32 *vals = buf;
+ const u32 *vals = buf;
 
  if (iwl_trans_grab_nic_access(trans, false, &flags)) {
   iwl_write32(trans, HBUS_TARG_MEM_WADDR, addr);
@@ -937,7 +1264,7 @@ static int iwl_trans_pcie_write_mem(struct iwl_trans *trans, u32 addr,
 
 #define IWL_FLUSH_WAIT_MS 2000
 
-static int iwl_trans_pcie_wait_txq_empty(struct iwl_trans *trans)
+static int iwl_trans_pcie_wait_txq_empty(struct iwl_trans *trans, u32 txq_bm)
 {
  struct iwl_trans_pcie *trans_pcie = IWL_TRANS_GET_PCIE_TRANS(trans);
  struct iwl_txq *txq;
@@ -950,13 +1277,31 @@ static int iwl_trans_pcie_wait_txq_empty(struct iwl_trans *trans)
 
  /* waiting for all the tx frames complete might take a while */
  for (cnt = 0; cnt < trans->cfg->base_params->num_of_queues; cnt++) {
+  u8 wr_ptr;
+
   if (cnt == trans_pcie->cmd_queue)
    continue;
+  if (!test_bit(cnt, trans_pcie->queue_used))
+   continue;
+  if (!(BIT(cnt) & txq_bm))
+   continue;
+
+  IWL_DEBUG_TX_QUEUES(trans, "Emptying queue %d...\n", cnt);
   txq = &trans_pcie->txq[cnt];
   q = &txq->q;
-  while (q->read_ptr != q->write_ptr && !time_after(jiffies,
-         now + msecs_to_jiffies(IWL_FLUSH_WAIT_MS)))
+  wr_ptr = ACCESS_ONCE(q->write_ptr);
+
+  while (q->read_ptr != ACCESS_ONCE(q->write_ptr) &&
+         !time_after(jiffies,
+       now + msecs_to_jiffies(IWL_FLUSH_WAIT_MS))) {
+   u8 write_ptr = ACCESS_ONCE(q->write_ptr);
+
+   if (WARN_ONCE(wr_ptr != write_ptr,
+          "WR pointer moved while flushing %d -> %d\n",
+          wr_ptr, write_ptr))
+    return -ETIMEDOUT;
    msleep(1);
+  }
 
   if (q->read_ptr != q->write_ptr) {
    IWL_ERR(trans,
@@ -964,6 +1309,7 @@ static int iwl_trans_pcie_wait_txq_empty(struct iwl_trans *trans)
    ret = -ETIMEDOUT;
    break;
   }
+  IWL_DEBUG_TX_QUEUES(trans, "Queue %d is now empty.\n", cnt);
  }
 
  if (!ret)
@@ -998,8 +1344,8 @@ static int iwl_trans_pcie_wait_txq_empty(struct iwl_trans *trans)
   IWL_ERR(trans,
    "Q %d is %sactive and mapped to fifo %d ra_tid 0x%04x [%d,%d]\n",
    cnt, active ? "" : "in", fifo, tbl_dw,
-   iwl_read_prph(trans,
-          SCD_QUEUE_RDPTR(cnt)) & (txq->q.n_bd - 1),
+   iwl_read_prph(trans, SCD_QUEUE_RDPTR(cnt)) &
+    (TFD_QUEUE_SIZE_MAX - 1),
    iwl_read_prph(trans, SCD_QUEUE_WRPTR(cnt)));
  }
 
@@ -1017,71 +1363,6 @@ static void iwl_trans_pcie_set_bits_mask(struct iwl_trans *trans, u32 reg,
  spin_unlock_irqrestore(&trans_pcie->reg_lock, flags);
 }
 
-static const char *get_fh_string(int cmd)
-{
-#define IWL_CMD(x) case x: return #x
- switch (cmd) {
- IWL_CMD(FH_RSCSR_CHNL0_STTS_WPTR_REG);
- IWL_CMD(FH_RSCSR_CHNL0_RBDCB_BASE_REG);
- IWL_CMD(FH_RSCSR_CHNL0_WPTR);
- IWL_CMD(FH_MEM_RCSR_CHNL0_CONFIG_REG);
- IWL_CMD(FH_MEM_RSSR_SHARED_CTRL_REG);
- IWL_CMD(FH_MEM_RSSR_RX_STATUS_REG);
- IWL_CMD(FH_MEM_RSSR_RX_ENABLE_ERR_IRQ2DRV);
- IWL_CMD(FH_TSSR_TX_STATUS_REG);
- IWL_CMD(FH_TSSR_TX_ERROR_REG);
- default:
-  return "UNKNOWN";
- }
-#undef IWL_CMD
-}
-
-int iwl_pcie_dump_fh(struct iwl_trans *trans, char **buf)
-{
- int i;
- static const u32 fh_tbl[] = {
-  FH_RSCSR_CHNL0_STTS_WPTR_REG,
-  FH_RSCSR_CHNL0_RBDCB_BASE_REG,
-  FH_RSCSR_CHNL0_WPTR,
-  FH_MEM_RCSR_CHNL0_CONFIG_REG,
-  FH_MEM_RSSR_SHARED_CTRL_REG,
-  FH_MEM_RSSR_RX_STATUS_REG,
-  FH_MEM_RSSR_RX_ENABLE_ERR_IRQ2DRV,
-  FH_TSSR_TX_STATUS_REG,
-  FH_TSSR_TX_ERROR_REG
- };
-
-#ifdef CONFIG_IWLWIFI_DEBUGFS
- if (buf) {
-  int pos = 0;
-  size_t bufsz = ARRAY_SIZE(fh_tbl) * 48 + 40;
-
-  *buf = kmalloc(bufsz, GFP_KERNEL);
-  if (!*buf)
-   return -ENOMEM;
-
-  pos += scnprintf(*buf + pos, bufsz - pos,
-    "FH register values:\n");
-
-  for (i = 0; i < ARRAY_SIZE(fh_tbl); i++)
-   pos += scnprintf(*buf + pos, bufsz - pos,
-    "  %34s: 0X%08x\n",
-    get_fh_string(fh_tbl[i]),
-    iwl_read_direct32(trans, fh_tbl[i]));
-
-  return pos;
- }
-#endif
-
- IWL_ERR(trans, "FH register values:\n");
- for (i = 0; i <  ARRAY_SIZE(fh_tbl); i++)
-  IWL_ERR(trans, "  %34s: 0X%08x\n",
-   get_fh_string(fh_tbl[i]),
-   iwl_read_direct32(trans, fh_tbl[i]));
-
- return 0;
-}
-
 static const char *get_csr_string(int cmd)
 {
 #define IWL_CMD(x) case x: return #x
@@ -1108,6 +1389,7 @@ static const char *get_csr_string(int cmd)
  IWL_CMD(CSR_GIO_CHICKEN_BITS);
  IWL_CMD(CSR_ANA_PLL_CFG);
  IWL_CMD(CSR_HW_REV_WA_REG);
+ IWL_CMD(CSR_MONITOR_STATUS_REG);
  IWL_CMD(CSR_DBG_HPET_MEM_REG);
  default:
   return "UNKNOWN";
@@ -1140,6 +1422,7 @@ void iwl_pcie_dump_csr(struct iwl_trans *trans)
   CSR_DRAM_INT_TBL_REG,
   CSR_GIO_CHICKEN_BITS,
   CSR_ANA_PLL_CFG,
+  CSR_MONITOR_STATUS_REG,
   CSR_HW_REV_WA_REG,
   CSR_DBG_HPET_MEM_REG
  };
@@ -1162,18 +1445,7 @@ void iwl_pcie_dump_csr(struct iwl_trans *trans)
 } while (0)
 
 /* file operation */
-#define DEBUGFS_READ_FUNC(name)                                         \
-static ssize_t iwl_dbgfs_##name##_read(struct file *file,               \
-     char __user *user_buf,          \
-     size_t count, loff_t *ppos);
-
-#define DEBUGFS_WRITE_FUNC(name)                                        \
-static ssize_t iwl_dbgfs_##name##_write(struct file *file,              \
-     const char __user *user_buf,    \
-     size_t count, loff_t *ppos);
-
 #define DEBUGFS_READ_FILE_OPS(name)     \
- DEBUGFS_READ_FUNC(name);     \
 static const struct file_operations iwl_dbgfs_##name##_ops = {  \
  .read = iwl_dbgfs_##name##_read,    \
  .open = simple_open,      \
@@ -1181,7 +1453,6 @@ static const struct file_operations iwl_dbgfs_##name##_ops = {  \
 };
 
 #define DEBUGFS_WRITE_FILE_OPS(name)                                    \
- DEBUGFS_WRITE_FUNC(name);                                       \
 static const struct file_operations iwl_dbgfs_##name##_ops = {          \
  .write = iwl_dbgfs_##name##_write,                              \
  .open = simple_open,      \
@@ -1189,8 +1460,6 @@ static const struct file_operations iwl_dbgfs_##name##_ops = {          \
 };
 
 #define DEBUGFS_READ_WRITE_FILE_OPS(name)    \
- DEBUGFS_READ_FUNC(name);     \
- DEBUGFS_WRITE_FUNC(name);     \
 static const struct file_operations iwl_dbgfs_##name##_ops = {  \
  .write = iwl_dbgfs_##name##_write,    \
  .read = iwl_dbgfs_##name##_read,    \
@@ -1371,16 +1640,15 @@ static ssize_t iwl_dbgfs_fh_reg_read(struct file *file,
 {
  struct iwl_trans *trans = file->private_data;
  char *buf = NULL;
- int pos = 0;
- ssize_t ret = -EFAULT;
-
- ret = pos = iwl_pcie_dump_fh(trans, &buf);
- if (buf) {
-  ret = simple_read_from_buffer(user_buf,
-           count, ppos, buf, pos);
-  kfree(buf);
- }
+ ssize_t ret;
 
+ ret = iwl_dump_fh(trans, &buf);
+ if (ret < 0)
+  return ret;
+ if (!buf)
+  return -EINVAL;
+ ret = simple_read_from_buffer(user_buf, count, ppos, buf, ret);
+ kfree(buf);
  return ret;
 }
 
@@ -1408,6 +1676,61 @@ err:
  IWL_ERR(trans, "failed to create the trans debugfs entry\n");
  return -ENOMEM;
 }
+
+static u32 iwl_trans_pcie_get_cmdlen(struct iwl_tfd *tfd)
+{
+ u32 cmdlen = 0;
+ int i;
+
+ for (i = 0; i < IWL_NUM_OF_TBS; i++)
+  cmdlen += iwl_pcie_tfd_tb_get_len(tfd, i);
+
+ return cmdlen;
+}
+
+static u32 iwl_trans_pcie_dump_data(struct iwl_trans *trans,
+        void *buf, u32 buflen)
+{
+ struct iwl_trans_pcie *trans_pcie = IWL_TRANS_GET_PCIE_TRANS(trans);
+ struct iwl_fw_error_dump_data *data;
+ struct iwl_txq *cmdq = &trans_pcie->txq[trans_pcie->cmd_queue];
+ struct iwl_fw_error_dump_txcmd *txcmd;
+ u32 len;
+ int i, ptr;
+
+ if (!buf)
+  return sizeof(*data) +
+         cmdq->q.n_window * (sizeof(*txcmd) +
+        TFD_MAX_PAYLOAD_SIZE);
+
+ len = 0;
+ data = buf;
+ data->type = cpu_to_le32(IWL_FW_ERROR_DUMP_TXCMD);
+ txcmd = (void *)data->data;
+ spin_lock_bh(&cmdq->lock);
+ ptr = cmdq->q.write_ptr;
+ for (i = 0; i < cmdq->q.n_window; i++) {
+  u8 idx = get_cmd_index(&cmdq->q, ptr);
+  u32 caplen, cmdlen;
+
+  cmdlen = iwl_trans_pcie_get_cmdlen(&cmdq->tfds[ptr]);
+  caplen = min_t(u32, TFD_MAX_PAYLOAD_SIZE, cmdlen);
+
+  if (cmdlen) {
+   len += sizeof(*txcmd) + caplen;
+   txcmd->cmdlen = cpu_to_le32(cmdlen);
+   txcmd->caplen = cpu_to_le32(caplen);
+   memcpy(txcmd->data, cmdq->entries[idx].cmd, caplen);
+   txcmd = (void *)((u8 *)txcmd->data + caplen);
+  }
+
+  ptr = iwl_queue_dec_wrap(ptr);
+ }
+ spin_unlock_bh(&cmdq->lock);
+
+ data->len = cpu_to_le32(len);
+ return sizeof(*data) + len;
+}
 #else
 static int iwl_trans_pcie_dbgfs_register(struct iwl_trans *trans,
       struct dentry *dir)
@@ -1418,7 +1741,7 @@ static int iwl_trans_pcie_dbgfs_register(struct iwl_trans *trans,
 
 static const struct iwl_trans_ops trans_ops_pcie = {
  .start_hw = iwl_trans_pcie_start_hw,
- .stop_hw = iwl_trans_pcie_stop_hw,
+ .op_mode_leave = iwl_trans_pcie_op_mode_leave,
  .fw_alive = iwl_trans_pcie_fw_alive,
  .start_fw = iwl_trans_pcie_start_fw,
  .stop_device = iwl_trans_pcie_stop_device,
@@ -1438,10 +1761,6 @@ static const struct iwl_trans_ops trans_ops_pcie = {
 
  .wait_tx_queue_empty = iwl_trans_pcie_wait_txq_empty,
 
-#ifdef CONFIG_PM_SLEEP
- .suspend = iwl_trans_pcie_suspend,
- .resume = iwl_trans_pcie_resume,
-#endif
  .write8 = iwl_trans_pcie_write8,
  .write32 = iwl_trans_pcie_write32,
  .read32 = iwl_trans_pcie_read32,
@@ -1454,6 +1773,10 @@ static const struct iwl_trans_ops trans_ops_pcie = {
  .grab_nic_access = iwl_trans_pcie_grab_nic_access,
  .release_nic_access = iwl_trans_pcie_release_nic_access,
  .set_bits_mask = iwl_trans_pcie_set_bits_mask,
+
+#ifdef CONFIG_IWLWIFI_DEBUGFS
+ .dump_data = iwl_trans_pcie_dump_data,
+#endif
 };
 
 struct iwl_trans *iwl_trans_pcie_alloc(struct pci_dev *pdev,
@@ -1467,9 +1790,10 @@ struct iwl_trans *iwl_trans_pcie_alloc(struct pci_dev *pdev,
 
  trans = kzalloc(sizeof(struct iwl_trans) +
    sizeof(struct iwl_trans_pcie), GFP_KERNEL);
-
- if (!trans)
-  return NULL;
+ if (!trans) {
+  err = -ENOMEM;
+  goto out;
+ }
 
  trans_pcie = IWL_TRANS_GET_PCIE_TRANS(trans);
 
@@ -1481,15 +1805,20 @@ struct iwl_trans *iwl_trans_pcie_alloc(struct pci_dev *pdev,
  spin_lock_init(&trans_pcie->reg_lock);
  init_waitqueue_head(&trans_pcie->ucode_write_waitq);
 
- if (pci_enable_device(pdev)) {
-  err = -ENODEV;
+ err = pci_enable_device(pdev);
+ if (err)
   goto out_no_pci;
- }
 
- /* W/A - seems to solve weird behavior. We need to remove this if we
-  * don't want to stay in L1 all the time. This wastes a lot of power */
- pci_disable_link_state(pdev, PCIE_LINK_STATE_L0S | PCIE_LINK_STATE_L1 |
-          PCIE_LINK_STATE_CLKPM);
+ if (!cfg->base_params->pcie_l1_allowed) {
+  /*
+   * W/A - seems to solve weird behavior. We need to remove this
+   * if we don't want to stay in L1 all the time. This wastes a
+   * lot of power.
+   */
+  pci_disable_link_state(pdev, PCIE_LINK_STATE_L0S |
+           PCIE_LINK_STATE_L1 |
+           PCIE_LINK_STATE_CLKPM);
+ }
 
  pci_set_master(pdev);
 
@@ -1525,6 +1854,10 @@ struct iwl_trans *iwl_trans_pcie_alloc(struct pci_dev *pdev,
   * PCI Tx retries from interfering with C3 CPU state */
  pci_write_config_byte(pdev, PCI_CFG_RETRY_TIMEOUT, 0x00);
 
+ trans->dev = &pdev->dev;
+ trans_pcie->pci_dev = pdev;
+ iwl_disable_interrupts(trans);
+
  err = pci_enable_msi(pdev);
  if (err) {
   dev_err(&pdev->dev, "pci_enable_msi failed(0X%x)\n", err);
@@ -1536,8 +1869,6 @@ struct iwl_trans *iwl_trans_pcie_alloc(struct pci_dev *pdev,
   }
  }
 
- trans->dev = &pdev->dev;
- trans_pcie->pci_dev = pdev;
  trans->hw_rev = iwl_read32(trans, CSR_HW_REV);
  trans->hw_id = (pdev->device << 16) + pdev->subsystem_device;
  snprintf(trans->hw_id_str, sizeof(trans->hw_id_str),
@@ -1558,21 +1889,24 @@ struct iwl_trans *iwl_trans_pcie_alloc(struct pci_dev *pdev,
       SLAB_HWCACHE_ALIGN,
       NULL);
 
- if (!trans->dev_cmd_pool)
+ if (!trans->dev_cmd_pool) {
+  err = -ENOMEM;
   goto out_pci_disable_msi;
-
- trans_pcie->inta_mask = CSR_INI_SET_MASK;
+ }
 
  if (iwl_pcie_alloc_ict(trans))
   goto out_free_cmd_pool;
 
- if (request_threaded_irq(pdev->irq, iwl_pcie_isr_ict,
-     iwl_pcie_irq_handler,
-     IRQF_SHARED, DRV_NAME, trans)) {
+ err = request_threaded_irq(pdev->irq, iwl_pcie_isr,
+       iwl_pcie_irq_handler,
+       IRQF_SHARED, DRV_NAME, trans);
+ if (err) {
   IWL_ERR(trans, "Error allocating IRQ %d\n", pdev->irq);
   goto out_free_ict;
  }
 
+ trans_pcie->inta_mask = CSR_INI_SET_MASK;
+
  return trans;
 
 out_free_ict:
@@ -1587,5 +1921,6 @@ out_pci_disable_device:
  pci_disable_device(pdev);
 out_no_pci:
  kfree(trans);
- return NULL;
+out:
+ return ERR_PTR(err);
 }
diff --git a/drivers/net/wireless/iwlwifi/pcie/tx.c b/drivers/net/wireless/iwlwifi/pcie/tx.c
index 48acfc6..038940a 100644
--- a/drivers/net/wireless/iwlwifi/pcie/tx.c
+++ b/drivers/net/wireless/iwlwifi/pcie/tx.c
@@ -1,6 +1,6 @@
 /******************************************************************************
  *
- * Copyright(c) 2003 - 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2003 - 2014 Intel Corporation. All rights reserved.
  *
  * Portions of this file are derived from the ipw3945 project, as well
  * as portions of the ieee80211 subsystem header files.
@@ -65,34 +65,40 @@
  ***************************************************/
 static int iwl_queue_space(const struct iwl_queue *q)
 {
- int s = q->read_ptr - q->write_ptr;
-
- if (q->read_ptr > q->write_ptr)
-  s -= q->n_bd;
-
- if (s <= 0)
-  s += q->n_window;
- /* keep some reserve to not confuse empty and full situations */
- s -= 2;
- if (s < 0)
-  s = 0;
- return s;
+ unsigned int max;
+ unsigned int used;
+
+ /*
+  * To avoid ambiguity between empty and completely full queues, there
+  * should always be less than TFD_QUEUE_SIZE_MAX elements in the queue.
+  * If q->n_window is smaller than TFD_QUEUE_SIZE_MAX, there is no need
+  * to reserve any queue entries for this purpose.
+  */
+ if (q->n_window < TFD_QUEUE_SIZE_MAX)
+  max = q->n_window;
+ else
+  max = TFD_QUEUE_SIZE_MAX - 1;
+
+ /*
+  * TFD_QUEUE_SIZE_MAX is a power of 2, so the following is equivalent to
+  * modulo by TFD_QUEUE_SIZE_MAX and is well defined.
+  */
+ used = (q->write_ptr - q->read_ptr) & (TFD_QUEUE_SIZE_MAX - 1);
+
+ if (WARN_ON(used > max))
+  return 0;
+
+ return max - used;
 }
 
 /*
  * iwl_queue_init - Initialize queue's high/low-water and read/write indexes
  */
-static int iwl_queue_init(struct iwl_queue *q, int count, int slots_num, u32 id)
+static int iwl_queue_init(struct iwl_queue *q, int slots_num, u32 id)
 {
- q->n_bd = count;
  q->n_window = slots_num;
  q->id = id;
 
- /* count must be power-of-two size, otherwise iwl_queue_inc_wrap
-  * and iwl_queue_dec_wrap are broken. */
- if (WARN_ON(!is_power_of_2(count)))
-  return -EINVAL;
-
  /* slots_num must be power-of-two size, otherwise
   * get_cmd_index is broken. */
  if (WARN_ON(!is_power_of_2(slots_num)))
@@ -185,17 +191,17 @@ static void iwl_pcie_txq_stuck_timer(unsigned long data)
   IWL_ERR(trans,
    "Q %d is %sactive and mapped to fifo %d ra_tid 0x%04x [%d,%d]\n",
    i, active ? "" : "in", fifo, tbl_dw,
-   iwl_read_prph(trans,
-          SCD_QUEUE_RDPTR(i)) & (txq->q.n_bd - 1),
+   iwl_read_prph(trans, SCD_QUEUE_RDPTR(i)) &
+    (TFD_QUEUE_SIZE_MAX - 1),
    iwl_read_prph(trans, SCD_QUEUE_WRPTR(i)));
  }
 
  for (i = q->read_ptr; i != q->write_ptr;
-      i = iwl_queue_inc_wrap(i, q->n_bd))
+      i = iwl_queue_inc_wrap(i))
   IWL_ERR(trans, "scratch %d = 0x%08x\n", i,
    le32_to_cpu(txq->scratchbufs[i].scratch));
 
- iwl_op_mode_nic_error(trans->op_mode);
+ iwl_force_nmi(trans);
 }
 
 /*
@@ -224,13 +230,13 @@ static void iwl_pcie_txq_update_byte_cnt_tbl(struct iwl_trans *trans,
 
  switch (sec_ctl & TX_CMD_SEC_MSK) {
  case TX_CMD_SEC_CCM:
-  len += CCMP_MIC_LEN;
+  len += IEEE80211_CCMP_MIC_LEN;
   break;
  case TX_CMD_SEC_TKIP:
-  len += TKIP_ICV_LEN;
+  len += IEEE80211_TKIP_ICV_LEN;
   break;
  case TX_CMD_SEC_WEP:
-  len += WEP_IV_LEN + WEP_ICV_LEN;
+  len += IEEE80211_WEP_IV_LEN + IEEE80211_WEP_ICV_LEN;
   break;
  }
 
@@ -275,53 +281,64 @@ static void iwl_pcie_txq_inval_byte_cnt_tbl(struct iwl_trans *trans,
 /*
  * iwl_pcie_txq_inc_wr_ptr - Send new write index to hardware
  */
-void iwl_pcie_txq_inc_wr_ptr(struct iwl_trans *trans, struct iwl_txq *txq)
+static void iwl_pcie_txq_inc_wr_ptr(struct iwl_trans *trans,
+        struct iwl_txq *txq)
 {
+ struct iwl_trans_pcie *trans_pcie = IWL_TRANS_GET_PCIE_TRANS(trans);
  u32 reg = 0;
  int txq_id = txq->q.id;
 
- if (txq->need_update == 0)
-  return;
+ lockdep_assert_held(&txq->lock);
 
- if (trans->cfg->base_params->shadow_reg_enable) {
-  /* shadow register enabled */
-  iwl_write32(trans, HBUS_TARG_WRPTR,
-       txq->q.write_ptr | (txq_id << 8));
- } else {
-  struct iwl_trans_pcie *trans_pcie =
-   IWL_TRANS_GET_PCIE_TRANS(trans);
-  /* if we're trying to save power */
-  if (test_bit(STATUS_TPOWER_PMI, &trans_pcie->status)) {
-   /* wake up nic if it's powered down ...
-    * uCode will wake up, and interrupt us again, so next
-    * time we'll skip this part. */
-   reg = iwl_read32(trans, CSR_UCODE_DRV_GP1);
-
-   if (reg & CSR_UCODE_DRV_GP1_BIT_MAC_SLEEP) {
-    IWL_DEBUG_INFO(trans,
-     "Tx queue %d requesting wakeup,"
-     " GP1 = 0x%x\n", txq_id, reg);
-    iwl_set_bit(trans, CSR_GP_CNTRL,
-     CSR_GP_CNTRL_REG_FLAG_MAC_ACCESS_REQ);
-    return;
-   }
+ /*
+  * explicitly wake up the NIC if:
+  * 1. shadow registers aren't enabled
+  * 2. NIC is woken up for CMD regardless of shadow outside this function
+  * 3. there is a chance that the NIC is asleep
+  */
+ if (!trans->cfg->base_params->shadow_reg_enable &&
+     txq_id != trans_pcie->cmd_queue &&
+     test_bit(STATUS_TPOWER_PMI, &trans->status)) {
+  /*
+   * wake up nic if it's powered down ...
+   * uCode will wake up, and interrupt us again, so next
+   * time we'll skip this part.
+   */
+  reg = iwl_read32(trans, CSR_UCODE_DRV_GP1);
+
+  if (reg & CSR_UCODE_DRV_GP1_BIT_MAC_SLEEP) {
+   IWL_DEBUG_INFO(trans, "Tx queue %d requesting wakeup, GP1 = 0x%x\n",
+           txq_id, reg);
+   iwl_set_bit(trans, CSR_GP_CNTRL,
+        CSR_GP_CNTRL_REG_FLAG_MAC_ACCESS_REQ);
+   txq->need_update = true;
+   return;
+  }
+ }
 
-   IWL_DEBUG_TX(trans, "Q:%d WR: 0x%x\n", txq_id,
-         txq->q.write_ptr);
+ /*
+  * if not in power-save mode, uCode will never sleep when we're
+  * trying to tx (during RFKILL, we're not trying to tx).
+  */
+ IWL_DEBUG_TX(trans, "Q:%d WR: 0x%x\n", txq_id, txq->q.write_ptr);
+ iwl_write32(trans, HBUS_TARG_WRPTR, txq->q.write_ptr | (txq_id << 8));
+}
 
-   iwl_write_direct32(trans, HBUS_TARG_WRPTR,
-         txq->q.write_ptr | (txq_id << 8));
+void iwl_pcie_txq_check_wrptrs(struct iwl_trans *trans)
+{
+ struct iwl_trans_pcie *trans_pcie = IWL_TRANS_GET_PCIE_TRANS(trans);
+ int i;
 
-  /*
-   * else not in power-save mode,
-   * uCode will never sleep when we're
-   * trying to tx (during RFKILL, we're not trying to tx).
-   */
-  } else
-   iwl_write32(trans, HBUS_TARG_WRPTR,
-        txq->q.write_ptr | (txq_id << 8));
+ for (i = 0; i < trans->cfg->base_params->num_of_queues; i++) {
+  struct iwl_txq *txq = &trans_pcie->txq[i];
+
+  spin_lock_bh(&txq->lock);
+  if (trans_pcie->txq[i].need_update) {
+   iwl_pcie_txq_inc_wr_ptr(trans, txq);
+   trans_pcie->txq[i].need_update = false;
+  }
+  spin_unlock_bh(&txq->lock);
  }
- txq->need_update = 0;
 }
 
 static inline dma_addr_t iwl_pcie_tfd_tb_get_addr(struct iwl_tfd *tfd, u8 idx)
@@ -336,13 +353,6 @@ static inline dma_addr_t iwl_pcie_tfd_tb_get_addr(struct iwl_tfd *tfd, u8 idx)
  return addr;
 }
 
-static inline u16 iwl_pcie_tfd_tb_get_len(struct iwl_tfd *tfd, u8 idx)
-{
- struct iwl_tfd_tb *tb = &tfd->tbs[idx];
-
- return le16_to_cpu(tb->hi_n_len) >> 4;
-}
-
 static inline void iwl_pcie_tfd_set_tb(struct iwl_tfd *tfd, u8 idx,
            dma_addr_t addr, u16 len)
 {
@@ -402,13 +412,17 @@ static void iwl_pcie_txq_free_tfd(struct iwl_trans *trans, struct iwl_txq *txq)
 {
  struct iwl_tfd *tfd_tmp = txq->tfds;
 
- /* rd_ptr is bounded by n_bd and idx is bounded by n_window */
+ /* rd_ptr is bounded by TFD_QUEUE_SIZE_MAX and
+  * idx is bounded by n_window
+  */
  int rd_ptr = txq->q.read_ptr;
  int idx = get_cmd_index(&txq->q, rd_ptr);
 
  lockdep_assert_held(&txq->lock);
 
- /* We have only q->n_window txq->entries, but we use q->n_bd tfds */
+ /* We have only q->n_window txq->entries, but we use
+  * TFD_QUEUE_SIZE_MAX tfds
+  */
  iwl_pcie_tfd_unmap(trans, &txq->entries[idx].meta, &tfd_tmp[rd_ptr]);
 
  /* free SKB */
@@ -429,7 +443,7 @@ static void iwl_pcie_txq_free_tfd(struct iwl_trans *trans, struct iwl_txq *txq)
 }
 
 static int iwl_pcie_txq_build_tfd(struct iwl_trans *trans, struct iwl_txq *txq,
-      dma_addr_t addr, u16 len, u8 reset)
+      dma_addr_t addr, u16 len, bool reset)
 {
  struct iwl_queue *q;
  struct iwl_tfd *tfd, *tfd_tmp;
@@ -451,13 +465,10 @@ static int iwl_pcie_txq_build_tfd(struct iwl_trans *trans, struct iwl_txq *txq,
   return -EINVAL;
  }
 
- if (WARN_ON(addr & ~DMA_BIT_MASK(36)))
+ if (WARN(addr & ~IWL_TX_DMA_MASK,
+   "Unaligned address = %llx\n", (unsigned long long)addr))
   return -EINVAL;
 
- if (unlikely(addr & ~IWL_TX_DMA_MASK))
-  IWL_ERR(trans, "Unaligned address = %llx\n",
-   (unsigned long long)addr);
-
  iwl_pcie_tfd_set_tb(tfd, num_tbs, addr, len);
 
  return 0;
@@ -538,15 +549,14 @@ static int iwl_pcie_txq_init(struct iwl_trans *trans, struct iwl_txq *txq,
 {
  int ret;
 
- txq->need_update = 0;
+ txq->need_update = false;
 
  /* TFD_QUEUE_SIZE_MAX must be power-of-two size, otherwise
   * iwl_queue_inc_wrap and iwl_queue_dec_wrap are broken. */
  BUILD_BUG_ON(TFD_QUEUE_SIZE_MAX & (TFD_QUEUE_SIZE_MAX - 1));
 
  /* Initialize queue's high/low-water marks, and head/tail indexes */
- ret = iwl_queue_init(&txq->q, TFD_QUEUE_SIZE_MAX, slots_num,
-   txq_id);
+ ret = iwl_queue_init(&txq->q, slots_num, txq_id);
  if (ret)
   return ret;
 
@@ -571,15 +581,12 @@ static void iwl_pcie_txq_unmap(struct iwl_trans *trans, int txq_id)
  struct iwl_txq *txq = &trans_pcie->txq[txq_id];
  struct iwl_queue *q = &txq->q;
 
- if (!q->n_bd)
-  return;
-
  spin_lock_bh(&txq->lock);
  while (q->write_ptr != q->read_ptr) {
   IWL_DEBUG_TX_REPLY(trans, "Q %d Free %d\n",
        txq_id, q->read_ptr);
   iwl_pcie_txq_free_tfd(trans, txq);
-  q->read_ptr = iwl_queue_inc_wrap(q->read_ptr, q->n_bd);
+  q->read_ptr = iwl_queue_inc_wrap(q->read_ptr);
  }
  txq->active = false;
  spin_unlock_bh(&txq->lock);
@@ -616,10 +623,12 @@ static void iwl_pcie_txq_free(struct iwl_trans *trans, int txq_id)
   }
 
  /* De-alloc circular buffer of TFDs */
- if (txq->q.n_bd) {
-  dma_free_coherent(dev, sizeof(struct iwl_tfd) *
-      txq->q.n_bd, txq->tfds, txq->q.dma_addr);
+ if (txq->tfds) {
+  dma_free_coherent(dev,
+      sizeof(struct iwl_tfd) * TFD_QUEUE_SIZE_MAX,
+      txq->tfds, txq->q.dma_addr);
   txq->q.dma_addr = 0;
+  txq->tfds = NULL;
 
   dma_free_coherent(dev,
       sizeof(*txq->scratchbufs) * txq->q.n_window,
@@ -676,7 +685,8 @@ void iwl_pcie_tx_start(struct iwl_trans *trans, u32 scd_base_addr)
  /* The chain extension of the SCD doesn't work well. This feature is
   * enabled by default by the HW, so we need to disable it manually.
   */
- iwl_write_prph(trans, SCD_CHAINEXT_EN, 0);
+ if (trans->cfg->base_params->scd_chain_ext_wa)
+  iwl_write_prph(trans, SCD_CHAINEXT_EN, 0);
 
  iwl_trans_ac_txq_enable(trans, trans_pcie->cmd_queue,
     trans_pcie->cmd_fifo);
@@ -696,8 +706,9 @@ void iwl_pcie_tx_start(struct iwl_trans *trans, u32 scd_base_addr)
       reg_val | FH_TX_CHICKEN_BITS_SCD_AUTO_RETRY_EN);
 
  /* Enable L1-Active */
- iwl_clear_bits_prph(trans, APMG_PCIDEV_STT_REG,
-       APMG_PCIDEV_STT_VAL_L1_ACT_DIS);
+ if (trans->cfg->device_family != IWL_DEVICE_FAMILY_8000)
+  iwl_clear_bits_prph(trans, APMG_PCIDEV_STT_REG,
+        APMG_PCIDEV_STT_VAL_L1_ACT_DIS);
 }
 
 void iwl_trans_pcie_tx_reset(struct iwl_trans *trans)
@@ -730,10 +741,9 @@ int iwl_pcie_tx_stop(struct iwl_trans *trans)
 {
  struct iwl_trans_pcie *trans_pcie = IWL_TRANS_GET_PCIE_TRANS(trans);
  int ch, txq_id, ret;
- unsigned long flags;
 
  /* Turn off all Tx DMA fifos */
- spin_lock_irqsave(&trans_pcie->irq_lock, flags);
+ spin_lock(&trans_pcie->irq_lock);
 
  iwl_pcie_txq_set_sched(trans, 0);
 
@@ -750,13 +760,19 @@ int iwl_pcie_tx_stop(struct iwl_trans *trans)
     iwl_read_direct32(trans,
         FH_TSSR_TX_STATUS_REG));
  }
- spin_unlock_irqrestore(&trans_pcie->irq_lock, flags);
+ spin_unlock(&trans_pcie->irq_lock);
 
- if (!trans_pcie->txq) {
-  IWL_WARN(trans,
-    "Stopping tx queues that aren't allocated...\n");
+ /*
+  * This function can be called before the op_mode disabled the
+  * queues. This happens when we have an rfkill interrupt.
+  * Since we stop Tx altogether - mark the queues as stopped.
+  */
+ memset(trans_pcie->queue_stopped, 0, sizeof(trans_pcie->queue_stopped));
+ memset(trans_pcie->queue_used, 0, sizeof(trans_pcie->queue_used));
+
+ /* This can happen: start_hw, stop_device */
+ if (!trans_pcie->txq)
   return 0;
- }
 
  /* Unmap DMA from host system and free skb's */
  for (txq_id = 0; txq_id < trans->cfg->base_params->num_of_queues;
@@ -829,7 +845,7 @@ static int iwl_pcie_tx_alloc(struct iwl_trans *trans)
       sizeof(struct iwl_txq), GFP_KERNEL);
  if (!trans_pcie->txq) {
   IWL_ERR(trans, "Not enough memory for txq\n");
-  ret = ENOMEM;
+  ret = -ENOMEM;
   goto error;
  }
 
@@ -858,7 +874,6 @@ int iwl_pcie_tx_init(struct iwl_trans *trans)
  struct iwl_trans_pcie *trans_pcie = IWL_TRANS_GET_PCIE_TRANS(trans);
  int ret;
  int txq_id, slots_num;
- unsigned long flags;
  bool alloc = false;
 
  if (!trans_pcie->txq) {
@@ -868,7 +883,7 @@ int iwl_pcie_tx_init(struct iwl_trans *trans)
   alloc = true;
  }
 
- spin_lock_irqsave(&trans_pcie->irq_lock, flags);
+ spin_lock(&trans_pcie->irq_lock);
 
  /* Turn off all Tx DMA fifos */
  iwl_write_prph(trans, SCD_TXFACT, 0);
@@ -877,7 +892,7 @@ int iwl_pcie_tx_init(struct iwl_trans *trans)
  iwl_write_direct32(trans, FH_KW_MEM_ADDR_REG,
       trans_pcie->kw.dma >> 4);
 
- spin_unlock_irqrestore(&trans_pcie->irq_lock, flags);
+ spin_unlock(&trans_pcie->irq_lock);
 
  /* Alloc and init all Tx queues, including the command queue (#4/#9) */
  for (txq_id = 0; txq_id < trans->cfg->base_params->num_of_queues;
@@ -922,8 +937,7 @@ void iwl_trans_pcie_reclaim(struct iwl_trans *trans, int txq_id, int ssn,
 {
  struct iwl_trans_pcie *trans_pcie = IWL_TRANS_GET_PCIE_TRANS(trans);
  struct iwl_txq *txq = &trans_pcie->txq[txq_id];
- /* n_bd is usually 256 => n_bd - 1 = 0xff */
- int tfd_num = ssn & (txq->q.n_bd - 1);
+ int tfd_num = ssn & (TFD_QUEUE_SIZE_MAX - 1);
  struct iwl_queue *q = &txq->q;
  int last_to_free;
 
@@ -947,12 +961,12 @@ void iwl_trans_pcie_reclaim(struct iwl_trans *trans, int txq_id, int ssn,
 
  /*Since we free until index _not_ inclusive, the one before index is
   * the last we will free. This one must be used */
- last_to_free = iwl_queue_dec_wrap(tfd_num, q->n_bd);
+ last_to_free = iwl_queue_dec_wrap(tfd_num);
 
  if (!iwl_queue_used(q, last_to_free)) {
   IWL_ERR(trans,
    "%s: Read index for DMA queue txq id (%d), last_to_free %d is out of range [0-%d] %d %d.\n",
-   __func__, txq_id, last_to_free, q->n_bd,
+   __func__, txq_id, last_to_free, TFD_QUEUE_SIZE_MAX,
    q->write_ptr, q->read_ptr);
   goto out;
  }
@@ -962,7 +976,7 @@ void iwl_trans_pcie_reclaim(struct iwl_trans *trans, int txq_id, int ssn,
 
  for (;
       q->read_ptr != tfd_num;
-      q->read_ptr = iwl_queue_inc_wrap(q->read_ptr, q->n_bd)) {
+      q->read_ptr = iwl_queue_inc_wrap(q->read_ptr)) {
 
   if (WARN_ON_ONCE(txq->entries[txq->q.read_ptr].skb == NULL))
    continue;
@@ -996,28 +1010,40 @@ static void iwl_pcie_cmdq_reclaim(struct iwl_trans *trans, int txq_id, int idx)
  struct iwl_trans_pcie *trans_pcie = IWL_TRANS_GET_PCIE_TRANS(trans);
  struct iwl_txq *txq = &trans_pcie->txq[txq_id];
  struct iwl_queue *q = &txq->q;
+ unsigned long flags;
  int nfreed = 0;
 
  lockdep_assert_held(&txq->lock);
 
- if ((idx >= q->n_bd) || (!iwl_queue_used(q, idx))) {
+ if ((idx >= TFD_QUEUE_SIZE_MAX) || (!iwl_queue_used(q, idx))) {
   IWL_ERR(trans,
    "%s: Read index for DMA queue txq id (%d), index %d is out of range [0-%d] %d %d.\n",
-   __func__, txq_id, idx, q->n_bd,
+   __func__, txq_id, idx, TFD_QUEUE_SIZE_MAX,
    q->write_ptr, q->read_ptr);
   return;
  }
 
- for (idx = iwl_queue_inc_wrap(idx, q->n_bd); q->read_ptr != idx;
-      q->read_ptr = iwl_queue_inc_wrap(q->read_ptr, q->n_bd)) {
+ for (idx = iwl_queue_inc_wrap(idx); q->read_ptr != idx;
+      q->read_ptr = iwl_queue_inc_wrap(q->read_ptr)) {
 
   if (nfreed++ > 0) {
    IWL_ERR(trans, "HCMD skipped: index (%d) %d %d\n",
     idx, q->write_ptr, q->read_ptr);
-   iwl_op_mode_nic_error(trans->op_mode);
+   iwl_force_nmi(trans);
   }
  }
 
+ if (trans->cfg->base_params->apmg_wake_up_wa &&
+     q->read_ptr == q->write_ptr) {
+  spin_lock_irqsave(&trans_pcie->reg_lock, flags);
+  WARN_ON(!trans_pcie->cmd_in_flight);
+  trans_pcie->cmd_in_flight = false;
+  __iwl_trans_pcie_clear_bit(trans,
+        CSR_GP_CNTRL,
+        CSR_GP_CNTRL_REG_FLAG_MAC_ACCESS_REQ);
+  spin_unlock_irqrestore(&trans_pcie->reg_lock, flags);
+ }
+
  iwl_pcie_txq_progress(trans_pcie, txq);
 }
 
@@ -1057,6 +1083,10 @@ static inline void iwl_pcie_txq_set_inactive(struct iwl_trans *trans,
   (1 << SCD_QUEUE_STTS_REG_POS_SCD_ACT_EN));
 }
 
+/* Receiver address (actually, Rx station's index into station table),
+ * combined with Traffic ID (QOS priority), in format used by Tx Scheduler */
+#define BUILD_RAxTID(sta_id, tid) (((sta_id) << 4) + (tid))
+
 void iwl_trans_pcie_txq_enable(struct iwl_trans *trans, int txq_id, int fifo,
           int sta_id, int tid, int frame_limit, u16 ssn)
 {
@@ -1081,6 +1111,7 @@ void iwl_trans_pcie_txq_enable(struct iwl_trans *trans, int txq_id, int fifo,
 
   /* enable aggregations for the queue */
   iwl_set_bits_prph(trans, SCD_AGGR_SEL, BIT(txq_id));
+  trans_pcie->txq[txq_id].ampdu = true;
  } else {
   /*
    * disable aggregations for the queue, this will also make the
@@ -1088,6 +1119,8 @@ void iwl_trans_pcie_txq_enable(struct iwl_trans *trans, int txq_id, int fifo,
    * non-AGG queue.
    */
   iwl_clear_bits_prph(trans, SCD_AGGR_SEL, BIT(txq_id));
+
+  ssn = trans_pcie->txq[txq_id].q.read_ptr;
  }
 
  /* Place first TFD at index corresponding to start sequence number.
@@ -1127,8 +1160,15 @@ void iwl_trans_pcie_txq_disable(struct iwl_trans *trans, int txq_id)
    SCD_TX_STTS_QUEUE_OFFSET(txq_id);
  static const u32 zero_val[4] = {};
 
+ /*
+  * Upon HW Rfkill - we stop the device, and then stop the queues
+  * in the op_mode. Just for the sake of the simplicity of the op_mode,
+  * allow the op_mode to call txq_disable after it already called
+  * stop_device.
+  */
  if (!test_and_clear_bit(txq_id, trans_pcie->queue_used)) {
-  WARN_ONCE(1, "queue %d not used", txq_id);
+  WARN_ONCE(test_bit(STATUS_DEVICE_ENABLED, &trans->status),
+     "queue %d not used", txq_id);
   return;
  }
 
@@ -1138,6 +1178,7 @@ void iwl_trans_pcie_txq_disable(struct iwl_trans *trans, int txq_id)
        ARRAY_SIZE(zero_val));
 
  iwl_pcie_txq_unmap(trans, txq_id);
+ trans_pcie->txq[txq_id].ampdu = false;
 
  IWL_DEBUG_TX_QUEUES(trans, "Deactivate queue %d\n", txq_id);
 }
@@ -1147,10 +1188,10 @@ void iwl_trans_pcie_txq_disable(struct iwl_trans *trans, int txq_id)
 /*
  * iwl_pcie_enqueue_hcmd - enqueue a uCode command
  * @priv: device private data point
- * @cmd: a point to the ucode command structure
+ * @cmd: a pointer to the ucode command structure
  *
- * The function returns < 0 values to indicate the operation is
- * failed. On success, it turns the index (> 0) of command in the
+ * The function returns < 0 values to indicate the operation
+ * failed. On success, it returns the index (>= 0) of command in the
  * command queue.
  */
 static int iwl_pcie_enqueue_hcmd(struct iwl_trans *trans,
@@ -1161,12 +1202,13 @@ static int iwl_pcie_enqueue_hcmd(struct iwl_trans *trans,
  struct iwl_queue *q = &txq->q;
  struct iwl_device_cmd *out_cmd;
  struct iwl_cmd_meta *out_meta;
+ unsigned long flags;
  void *dup_buf = NULL;
  dma_addr_t phys_addr;
  int idx;
  u16 copy_size, cmd_size, scratch_size;
  bool had_nocopy = false;
- int i;
+ int i, ret;
  u32 cmd_pos;
  const u8 *cmddata[IWL_MAX_CMD_TBS_PER_TFD];
  u16 cmdlen[IWL_MAX_CMD_TBS_PER_TFD];
@@ -1273,28 +1315,39 @@ static int iwl_pcie_enqueue_hcmd(struct iwl_trans *trans,
  cmd_pos = offsetof(struct iwl_device_cmd, payload);
  copy_size = sizeof(out_cmd->hdr);
  for (i = 0; i < IWL_MAX_CMD_TBS_PER_TFD; i++) {
-  int copy = 0;
+  int copy;
 
   if (!cmd->len[i])
    continue;
 
-  /* need at least IWL_HCMD_SCRATCHBUF_SIZE copied */
-  if (copy_size < IWL_HCMD_SCRATCHBUF_SIZE) {
-   copy = IWL_HCMD_SCRATCHBUF_SIZE - copy_size;
-
-   if (copy > cmd->len[i])
-    copy = cmd->len[i];
-  }
-
   /* copy everything if not nocopy/dup */
   if (!(cmd->dataflags[i] & (IWL_HCMD_DFL_NOCOPY |
-        IWL_HCMD_DFL_DUP)))
+        IWL_HCMD_DFL_DUP))) {
    copy = cmd->len[i];
 
-  if (copy) {
    memcpy((u8 *)out_cmd + cmd_pos, cmd->data[i], copy);
    cmd_pos += copy;
    copy_size += copy;
+   continue;
+  }
+
+  /*
+   * Otherwise we need at least IWL_HCMD_SCRATCHBUF_SIZE copied
+   * in total (for the scratchbuf handling), but copy up to what
+   * we can fit into the payload for debug dump purposes.
+   */
+  copy = min_t(int, TFD_MAX_PAYLOAD_SIZE - cmd_pos, cmd->len[i]);
+
+  memcpy((u8 *)out_cmd + cmd_pos, cmd->data[i], copy);
+  cmd_pos += copy;
+
+  /* However, treat copy_size the proper way, we need it below */
+  if (copy_size < IWL_HCMD_SCRATCHBUF_SIZE) {
+   copy = IWL_HCMD_SCRATCHBUF_SIZE - copy_size;
+
+   if (copy > cmd->len[i])
+    copy = cmd->len[i];
+   copy_size += copy;
   }
  }
 
@@ -1309,7 +1362,7 @@ static int iwl_pcie_enqueue_hcmd(struct iwl_trans *trans,
  memcpy(&txq->scratchbufs[q->write_ptr], &out_cmd->hdr, scratch_size);
  iwl_pcie_txq_build_tfd(trans, txq,
           iwl_pcie_get_scratchbuf_dma(txq, q->write_ptr),
-          scratch_size, 1);
+          scratch_size, true);
 
  /* map first command fragment, if any remains */
  if (copy_size > scratch_size) {
@@ -1325,7 +1378,7 @@ static int iwl_pcie_enqueue_hcmd(struct iwl_trans *trans,
   }
 
   iwl_pcie_txq_build_tfd(trans, txq, phys_addr,
-           copy_size - scratch_size, 0);
+           copy_size - scratch_size, false);
  }
 
  /* map the remaining (adjusted) nocopy/dup fragments */
@@ -1348,7 +1401,7 @@ static int iwl_pcie_enqueue_hcmd(struct iwl_trans *trans,
    goto out;
   }
 
-  iwl_pcie_txq_build_tfd(trans, txq, phys_addr, cmdlen[i], 0);
+  iwl_pcie_txq_build_tfd(trans, txq, phys_addr, cmdlen[i], false);
  }
 
  out_meta->flags = cmd->flags;
@@ -1356,18 +1409,46 @@ static int iwl_pcie_enqueue_hcmd(struct iwl_trans *trans,
   kfree(txq->entries[idx].free_buf);
  txq->entries[idx].free_buf = dup_buf;
 
- txq->need_update = 1;
-
  trace_iwlwifi_dev_hcmd(trans->dev, cmd, cmd_size, &out_cmd->hdr);
 
  /* start timer if queue currently empty */
  if (q->read_ptr == q->write_ptr && trans_pcie->wd_timeout)
   mod_timer(&txq->stuck_timer, jiffies + trans_pcie->wd_timeout);
 
+ spin_lock_irqsave(&trans_pcie->reg_lock, flags);
+
+ /*
+  * wake up the NIC to make sure that the firmware will see the host
+  * command - we will let the NIC sleep once all the host commands
+  * returned. This needs to be done only on NICs that have
+  * apmg_wake_up_wa set.
+  */
+ if (trans->cfg->base_params->apmg_wake_up_wa &&
+     !trans_pcie->cmd_in_flight) {
+  trans_pcie->cmd_in_flight = true;
+  __iwl_trans_pcie_set_bit(trans, CSR_GP_CNTRL,
+      CSR_GP_CNTRL_REG_FLAG_MAC_ACCESS_REQ);
+  ret = iwl_poll_bit(trans, CSR_GP_CNTRL,
+       CSR_GP_CNTRL_REG_VAL_MAC_ACCESS_EN,
+       (CSR_GP_CNTRL_REG_FLAG_MAC_CLOCK_READY |
+        CSR_GP_CNTRL_REG_FLAG_GOING_TO_SLEEP),
+       15000);
+  if (ret < 0) {
+   __iwl_trans_pcie_clear_bit(trans, CSR_GP_CNTRL,
+       CSR_GP_CNTRL_REG_FLAG_MAC_ACCESS_REQ);
+   spin_unlock_irqrestore(&trans_pcie->reg_lock, flags);
+   trans_pcie->cmd_in_flight = false;
+   idx = -EIO;
+   goto out;
+  }
+ }
+
  /* Increment and update queue's write index */
- q->write_ptr = iwl_queue_inc_wrap(q->write_ptr, q->n_bd);
+ q->write_ptr = iwl_queue_inc_wrap(q->write_ptr);
  iwl_pcie_txq_inc_wr_ptr(trans, txq);
 
+ spin_unlock_irqrestore(&trans_pcie->reg_lock, flags);
+
  out:
  spin_unlock_bh(&txq->lock);
  free_dup_buf:
@@ -1432,12 +1513,12 @@ void iwl_pcie_hcmd_complete(struct iwl_trans *trans,
  iwl_pcie_cmdq_reclaim(trans, txq_id, index);
 
  if (!(meta->flags & CMD_ASYNC)) {
-  if (!test_bit(STATUS_HCMD_ACTIVE, &trans_pcie->status)) {
+  if (!test_bit(STATUS_SYNC_HCMD_ACTIVE, &trans->status)) {
    IWL_WARN(trans,
      "HCMD_ACTIVE already clear for command %s\n",
      get_cmd_string(trans_pcie, cmd->hdr.cmd));
   }
-  clear_bit(STATUS_HCMD_ACTIVE, &trans_pcie->status);
+  clear_bit(STATUS_SYNC_HCMD_ACTIVE, &trans->status);
   IWL_DEBUG_INFO(trans, "Clearing HCMD_ACTIVE for command %s\n",
           get_cmd_string(trans_pcie, cmd->hdr.cmd));
   wake_up(&trans_pcie->wait_command_queue);
@@ -1448,7 +1529,7 @@ void iwl_pcie_hcmd_complete(struct iwl_trans *trans,
  spin_unlock_bh(&txq->lock);
 }
 
-#define HOST_COMPLETE_TIMEOUT (2 * HZ)
+#define HOST_COMPLETE_TIMEOUT (2 * HZ)
 
 static int iwl_pcie_send_hcmd_async(struct iwl_trans *trans,
         struct iwl_host_cmd *cmd)
@@ -1480,12 +1561,11 @@ static int iwl_pcie_send_hcmd_sync(struct iwl_trans *trans,
  IWL_DEBUG_INFO(trans, "Attempting to send sync command %s\n",
          get_cmd_string(trans_pcie, cmd->id));
 
- if (WARN_ON(test_and_set_bit(STATUS_HCMD_ACTIVE,
-         &trans_pcie->status))) {
-  IWL_ERR(trans, "Command %s: a command is already active!\n",
-   get_cmd_string(trans_pcie, cmd->id));
+ if (WARN(test_and_set_bit(STATUS_SYNC_HCMD_ACTIVE,
+      &trans->status),
+   "Command %s: a command is already active!\n",
+   get_cmd_string(trans_pcie, cmd->id)))
   return -EIO;
- }
 
  IWL_DEBUG_INFO(trans, "Setting HCMD_ACTIVE for command %s\n",
          get_cmd_string(trans_pcie, cmd->id));
@@ -1493,7 +1573,7 @@ static int iwl_pcie_send_hcmd_sync(struct iwl_trans *trans,
  cmd_idx = iwl_pcie_enqueue_hcmd(trans, cmd);
  if (cmd_idx < 0) {
   ret = cmd_idx;
-  clear_bit(STATUS_HCMD_ACTIVE, &trans_pcie->status);
+  clear_bit(STATUS_SYNC_HCMD_ACTIVE, &trans->status);
   IWL_ERR(trans,
    "Error sending %s: enqueue_hcmd failed: %d\n",
    get_cmd_string(trans_pcie, cmd->id), ret);
@@ -1501,41 +1581,41 @@ static int iwl_pcie_send_hcmd_sync(struct iwl_trans *trans,
  }
 
  ret = wait_event_timeout(trans_pcie->wait_command_queue,
-     !test_bit(STATUS_HCMD_ACTIVE,
-        &trans_pcie->status),
+     !test_bit(STATUS_SYNC_HCMD_ACTIVE,
+        &trans->status),
      HOST_COMPLETE_TIMEOUT);
  if (!ret) {
-  if (test_bit(STATUS_HCMD_ACTIVE, &trans_pcie->status)) {
-   struct iwl_txq *txq =
-    &trans_pcie->txq[trans_pcie->cmd_queue];
-   struct iwl_queue *q = &txq->q;
+  struct iwl_txq *txq = &trans_pcie->txq[trans_pcie->cmd_queue];
+  struct iwl_queue *q = &txq->q;
 
-   IWL_ERR(trans,
-    "Error sending %s: time out after %dms.\n",
-    get_cmd_string(trans_pcie, cmd->id),
-    jiffies_to_msecs(HOST_COMPLETE_TIMEOUT));
+  IWL_ERR(trans, "Error sending %s: time out after %dms.\n",
+   get_cmd_string(trans_pcie, cmd->id),
+   jiffies_to_msecs(HOST_COMPLETE_TIMEOUT));
 
-   IWL_ERR(trans,
-    "Current CMD queue read_ptr %d write_ptr %d\n",
-    q->read_ptr, q->write_ptr);
-
-   clear_bit(STATUS_HCMD_ACTIVE, &trans_pcie->status);
-   IWL_DEBUG_INFO(trans,
-           "Clearing HCMD_ACTIVE for command %s\n",
-           get_cmd_string(trans_pcie, cmd->id));
-   ret = -ETIMEDOUT;
-   goto cancel;
-  }
+  IWL_ERR(trans, "Current CMD queue read_ptr %d write_ptr %d\n",
+   q->read_ptr, q->write_ptr);
+
+  clear_bit(STATUS_SYNC_HCMD_ACTIVE, &trans->status);
+  IWL_DEBUG_INFO(trans, "Clearing HCMD_ACTIVE for command %s\n",
+          get_cmd_string(trans_pcie, cmd->id));
+  ret = -ETIMEDOUT;
+
+  iwl_force_nmi(trans);
+  iwl_trans_fw_error(trans);
+
+  goto cancel;
  }
 
- if (test_bit(STATUS_FW_ERROR, &trans_pcie->status)) {
+ if (test_bit(STATUS_FW_ERROR, &trans->status)) {
   IWL_ERR(trans, "FW error in SYNC CMD %s\n",
    get_cmd_string(trans_pcie, cmd->id));
+  dump_stack();
   ret = -EIO;
   goto cancel;
  }
 
- if (test_bit(STATUS_RFKILL, &trans_pcie->status)) {
+ if (!(cmd->flags & CMD_SEND_IN_RFKILL) &&
+     test_bit(STATUS_RFKILL, &trans->status)) {
   IWL_DEBUG_RF_KILL(trans, "RFKILL in SYNC CMD... no rsp\n");
   ret = -ERFKILL;
   goto cancel;
@@ -1572,12 +1652,8 @@ cancel:
 
 int iwl_trans_pcie_send_hcmd(struct iwl_trans *trans, struct iwl_host_cmd *cmd)
 {
- struct iwl_trans_pcie *trans_pcie = IWL_TRANS_GET_PCIE_TRANS(trans);
-
- if (test_bit(STATUS_FW_ERROR, &trans_pcie->status))
-  return -EIO;
-
- if (test_bit(STATUS_RFKILL, &trans_pcie->status)) {
+ if (!(cmd->flags & CMD_SEND_IN_RFKILL) &&
+     test_bit(STATUS_RFKILL, &trans->status)) {
   IWL_DEBUG_RF_KILL(trans, "Dropping CMD 0x%x: RF KILL\n",
       cmd->id);
   return -ERFKILL;
@@ -1602,18 +1678,17 @@ int iwl_trans_pcie_tx(struct iwl_trans *trans, struct sk_buff *skb,
  dma_addr_t tb0_phys, tb1_phys, scratch_phys;
  void *tb1_addr;
  u16 len, tb1_len, tb2_len;
- u8 wait_write_ptr = 0;
+ bool wait_write_ptr;
  __le16 fc = hdr->frame_control;
  u8 hdr_len = ieee80211_hdrlen(fc);
- u16 __maybe_unused wifi_seq;
+ u16 wifi_seq;
 
  txq = &trans_pcie->txq[txq_id];
  q = &txq->q;
 
- if (unlikely(!test_bit(txq_id, trans_pcie->queue_used))) {
-  WARN_ON_ONCE(1);
+ if (WARN_ONCE(!test_bit(txq_id, trans_pcie->queue_used),
+        "TX on unused queue %d\n", txq_id))
   return -EINVAL;
- }
 
  spin_lock(&txq->lock);
 
@@ -1622,19 +1697,16 @@ int iwl_trans_pcie_tx(struct iwl_trans *trans, struct sk_buff *skb,
   * the BA.
   * Check here that the packets are in the right place on the ring.
   */
-#ifdef CONFIG_IWLWIFI_DEBUG
  wifi_seq = IEEE80211_SEQ_TO_SN(le16_to_cpu(hdr->seq_ctrl));
- WARN_ONCE((iwl_read_prph(trans, SCD_AGGR_SEL) & BIT(txq_id)) &&
-    ((wifi_seq & 0xff) != q->write_ptr),
+ WARN_ONCE(txq->ampdu &&
+    (wifi_seq & 0xff) != q->write_ptr,
     "Q: %d WiFi Seq %d tfdNum %d",
     txq_id, wifi_seq, q->write_ptr);
-#endif
 
  /* Set up driver data for this TFD */
  txq->entries[q->write_ptr].skb = skb;
  txq->entries[q->write_ptr].cmd = dev_cmd;
 
- dev_cmd->hdr.cmd = REPLY_TX;
  dev_cmd->hdr.sequence =
   cpu_to_le16((u16)(QUEUE_TO_SEQ(txq_id) |
        INDEX_TO_SEQ(q->write_ptr)));
@@ -1657,7 +1729,7 @@ int iwl_trans_pcie_tx(struct iwl_trans *trans, struct sk_buff *skb,
   */
  len = sizeof(struct iwl_tx_cmd) + sizeof(struct iwl_cmd_header) +
        hdr_len - IWL_HCMD_SCRATCHBUF_SIZE;
- tb1_len = (len + 3) & ~3;
+ tb1_len = ALIGN(len, 4);
 
  /* Tell NIC about any 2-byte padding after MAC header */
  if (tb1_len != len)
@@ -1667,7 +1739,7 @@ int iwl_trans_pcie_tx(struct iwl_trans *trans, struct sk_buff *skb,
  memcpy(&txq->scratchbufs[q->write_ptr], &dev_cmd->hdr,
         IWL_HCMD_SCRATCHBUF_SIZE);
  iwl_pcie_txq_build_tfd(trans, txq, tb0_phys,
-          IWL_HCMD_SCRATCHBUF_SIZE, 1);
+          IWL_HCMD_SCRATCHBUF_SIZE, true);
 
  /* there must be data left over for TB1 or this code must be changed */
  BUILD_BUG_ON(sizeof(struct iwl_tx_cmd) < IWL_HCMD_SCRATCHBUF_SIZE);
@@ -1677,7 +1749,7 @@ int iwl_trans_pcie_tx(struct iwl_trans *trans, struct sk_buff *skb,
  tb1_phys = dma_map_single(trans->dev, tb1_addr, tb1_len, DMA_TO_DEVICE);
  if (unlikely(dma_mapping_error(trans->dev, tb1_phys)))
   goto out_err;
- iwl_pcie_txq_build_tfd(trans, txq, tb1_phys, tb1_len, 0);
+ iwl_pcie_txq_build_tfd(trans, txq, tb1_phys, tb1_len, false);
 
  /*
   * Set up TFD's third entry to point directly to remainder
@@ -1693,7 +1765,7 @@ int iwl_trans_pcie_tx(struct iwl_trans *trans, struct sk_buff *skb,
         &txq->tfds[q->write_ptr]);
    goto out_err;
   }
-  iwl_pcie_txq_build_tfd(trans, txq, tb2_phys, tb2_len, 0);
+  iwl_pcie_txq_build_tfd(trans, txq, tb2_phys, tb2_len, false);
  }
 
  /* Set up entry for this TFD in Tx byte-count array */
@@ -1707,12 +1779,7 @@ int iwl_trans_pcie_tx(struct iwl_trans *trans, struct sk_buff *skb,
  trace_iwlwifi_dev_tx_data(trans->dev, skb,
       skb->data + hdr_len, tb2_len);
 
- if (!ieee80211_has_morefrags(fc)) {
-  txq->need_update = 1;
- } else {
-  wait_write_ptr = 1;
-  txq->need_update = 0;
- }
+ wait_write_ptr = ieee80211_has_morefrags(fc);
 
  /* start timer if queue currently empty */
  if (txq->need_update && q->read_ptr == q->write_ptr &&
@@ -1720,22 +1787,19 @@ int iwl_trans_pcie_tx(struct iwl_trans *trans, struct sk_buff *skb,
   mod_timer(&txq->stuck_timer, jiffies + trans_pcie->wd_timeout);
 
  /* Tell device the write index *just past* this latest filled TFD */
- q->write_ptr = iwl_queue_inc_wrap(q->write_ptr, q->n_bd);
- iwl_pcie_txq_inc_wr_ptr(trans, txq);
+ q->write_ptr = iwl_queue_inc_wrap(q->write_ptr);
+ if (!wait_write_ptr)
+  iwl_pcie_txq_inc_wr_ptr(trans, txq);
 
  /*
   * At this point the frame is "transmitted" successfully
-  * and we will get a TX status notification eventually,
-  * regardless of the value of ret. "ret" only indicates
-  * whether or not we should update the write pointer.
+  * and we will get a TX status notification eventually.
   */
  if (iwl_queue_space(q) < q->high_mark) {
-  if (wait_write_ptr) {
-   txq->need_update = 1;
+  if (wait_write_ptr)
    iwl_pcie_txq_inc_wr_ptr(trans, txq);
-  } else {
+  else
    iwl_stop_queue(trans, txq);
-  }
  }
  spin_unlock(&txq->lock);
  return 0;
-- 
1.7.1