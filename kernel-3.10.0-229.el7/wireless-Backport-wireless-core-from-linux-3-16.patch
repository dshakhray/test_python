From e707e67b500a1da5e927a5c89bf0ff6ca9797e7e Mon Sep 17 00:00:00 2001
From: Stanislaw Gruszka <sgruszka@redhat.com>
Date: Wed, 22 Oct 2014 12:11:11 -0400
Subject: [wireless] Backport wireless core from linux 3.16

Message-id: <20141022121106.GB1876@redhat.com>
Patchwork-id: 98042
O-Subject: [RHEL7 PATCH 05/15 v2] Backport wireless core from linux 3.16
Bugzilla: 1136324
RH-Acked-by: John Linville <linville@redhat.com>

Decription:
Sync wireless core and related includes to code from linux 3.16
(up to commit 19583ca584d6f574384e17fe7613dfaeadcdc4a6).

Brew:
https://brewweb.devel.redhat.com/taskinfo?taskID=8148529

Testing:
Tested on Intel, Atheros, Ralink wireless hardware.
---
v1 -> v2: update agains current netlink changes, since netlink core was
updated we do not need genetlink-backport clue any longer. The change
was smoke tested by myself (on iwlwifi, rt2800pci and ath9k).

Signed-off-by: Jarod Wilson <jarod@redhat.com>

diff --git a/include/linux/ieee80211.h b/include/linux/ieee80211.h
index 06b0ed0..6bff13f 100644
--- a/include/linux/ieee80211.h
+++ b/include/linux/ieee80211.h
@@ -16,6 +16,7 @@
 #define LINUX_IEEE80211_H
 
 #include <linux/types.h>
+#include <linux/if_ether.h>
 #include <asm/byteorder.h>
 
 /*
@@ -146,12 +147,17 @@ static inline u16 ieee80211_sn_sub(u16 sn1, u16 sn2)
 #define IEEE80211_MAX_RTS_THRESHOLD 2353
 #define IEEE80211_MAX_AID  2007
 #define IEEE80211_MAX_TIM_LEN  251
+#define IEEE80211_MAX_MESH_PEERINGS 63
 /* Maximum size for the MA-UNITDATA primitive, 802.11 standard section
    6.2.1.1.2.
 
    802.11e clarifies the figure in section 7.1.2. The frame body is
    up to 2304 octets long (maximum MSDU size) plus any crypt overhead. */
 #define IEEE80211_MAX_DATA_LEN  2304
+/* 802.11ad extends maximum MSDU size for DMG (freq > 40Ghz) networks
+ * to 7920 bytes, see 8.2.3 General frame format
+ */
+#define IEEE80211_MAX_DATA_LEN_DMG 7920
 /* 30 byte 4 addr hdr, 2 byte QoS, 2304 byte MSDU, 12 byte crypt, 4 byte FCS */
 #define IEEE80211_MAX_FRAME_LEN  2352
 
@@ -208,28 +214,28 @@ static inline u16 ieee80211_sn_sub(u16 sn1, u16 sn2)
 struct ieee80211_hdr {
  __le16 frame_control;
  __le16 duration_id;
- u8 addr1[6];
- u8 addr2[6];
- u8 addr3[6];
+ u8 addr1[ETH_ALEN];
+ u8 addr2[ETH_ALEN];
+ u8 addr3[ETH_ALEN];
  __le16 seq_ctrl;
- u8 addr4[6];
+ u8 addr4[ETH_ALEN];
 } __packed __aligned(2);
 
 struct ieee80211_hdr_3addr {
  __le16 frame_control;
  __le16 duration_id;
- u8 addr1[6];
- u8 addr2[6];
- u8 addr3[6];
+ u8 addr1[ETH_ALEN];
+ u8 addr2[ETH_ALEN];
+ u8 addr3[ETH_ALEN];
  __le16 seq_ctrl;
 } __packed __aligned(2);
 
 struct ieee80211_qos_hdr {
  __le16 frame_control;
  __le16 duration_id;
- u8 addr1[6];
- u8 addr2[6];
- u8 addr3[6];
+ u8 addr1[ETH_ALEN];
+ u8 addr2[ETH_ALEN];
+ u8 addr3[ETH_ALEN];
  __le16 seq_ctrl;
  __le16 qos_ctrl;
 } __packed __aligned(2);
@@ -595,6 +601,20 @@ static inline int ieee80211_is_qos_nullfunc(__le16 fc)
 }
 
 /**
+ * ieee80211_is_bufferable_mmpdu - check if frame is bufferable MMPDU
+ * @fc: frame control field in little-endian byteorder
+ */
+static inline bool ieee80211_is_bufferable_mmpdu(__le16 fc)
+{
+ /* IEEE 802.11-2012, definition of "bufferable management frame";
+  * note that this ignores the IBSS special case. */
+ return ieee80211_is_mgmt(fc) &&
+        (ieee80211_is_action(fc) ||
+  ieee80211_is_disassoc(fc) ||
+  ieee80211_is_deauth(fc));
+}
+
+/**
  * ieee80211_is_first_frag - check if IEEE80211_SCTL_FRAG is not set
  * @seq_ctrl: frame sequence control bytes in little-endian byteorder
  */
@@ -607,8 +627,8 @@ struct ieee80211s_hdr {
  u8 flags;
  u8 ttl;
  __le32 seqnum;
- u8 eaddr1[6];
- u8 eaddr2[6];
+ u8 eaddr1[ETH_ALEN];
+ u8 eaddr2[ETH_ALEN];
 } __packed __aligned(2);
 
 /* Mesh flags */
@@ -695,6 +715,18 @@ struct ieee80211_sec_chan_offs_ie {
 } __packed;
 
 /**
+ * struct ieee80211_mesh_chansw_params_ie - mesh channel switch parameters IE
+ *
+ * This structure represents the "Mesh Channel Switch Paramters element"
+ */
+struct ieee80211_mesh_chansw_params_ie {
+ u8 mesh_ttl;
+ u8 mesh_flags;
+ __le16 mesh_reason;
+ __le16 mesh_pre_value;
+} __packed;
+
+/**
  * struct ieee80211_wide_bw_chansw_ie - wide bandwidth channel switch IE
  */
 struct ieee80211_wide_bw_chansw_ie {
@@ -749,6 +781,14 @@ enum mesh_config_capab_flags {
 };
 
 /**
+ * mesh channel switch parameters element's flag indicator
+ *
+ */
+#define WLAN_EID_CHAN_SWITCH_PARAM_TX_RESTRICT BIT(0)
+#define WLAN_EID_CHAN_SWITCH_PARAM_INITIATOR BIT(1)
+#define WLAN_EID_CHAN_SWITCH_PARAM_REASON BIT(2)
+
+/**
  * struct ieee80211_rann_ie
  *
  * This structure refers to "Root Announcement information element"
@@ -757,7 +797,7 @@ struct ieee80211_rann_ie {
  u8 rann_flags;
  u8 rann_hopcount;
  u8 rann_ttl;
- u8 rann_addr[6];
+ u8 rann_addr[ETH_ALEN];
  __le32 rann_seq;
  __le32 rann_interval;
  __le32 rann_metric;
@@ -801,9 +841,9 @@ enum ieee80211_vht_opmode_bits {
 struct ieee80211_mgmt {
  __le16 frame_control;
  __le16 duration;
- u8 da[6];
- u8 sa[6];
- u8 bssid[6];
+ u8 da[ETH_ALEN];
+ u8 sa[ETH_ALEN];
+ u8 bssid[ETH_ALEN];
  __le16 seq_ctrl;
  union {
   struct {
@@ -832,7 +872,7 @@ struct ieee80211_mgmt {
   struct {
    __le16 capab_info;
    __le16 listen_interval;
-   u8 current_ap[6];
+   u8 current_ap[ETH_ALEN];
    /* followed by SSID and Supported rates */
    u8 variable[0];
   } __packed reassoc_req;
@@ -965,21 +1005,21 @@ struct ieee80211_vendor_ie {
 struct ieee80211_rts {
  __le16 frame_control;
  __le16 duration;
- u8 ra[6];
- u8 ta[6];
+ u8 ra[ETH_ALEN];
+ u8 ta[ETH_ALEN];
 } __packed __aligned(2);
 
 struct ieee80211_cts {
  __le16 frame_control;
  __le16 duration;
- u8 ra[6];
+ u8 ra[ETH_ALEN];
 } __packed __aligned(2);
 
 struct ieee80211_pspoll {
  __le16 frame_control;
  __le16 aid;
- u8 bssid[6];
- u8 ta[6];
+ u8 bssid[ETH_ALEN];
+ u8 ta[ETH_ALEN];
 } __packed __aligned(2);
 
 /* TDLS */
@@ -988,14 +1028,14 @@ struct ieee80211_pspoll {
 struct ieee80211_tdls_lnkie {
  u8 ie_type; /* Link Identifier IE */
  u8 ie_len;
- u8 bssid[6];
- u8 init_sta[6];
- u8 resp_sta[6];
+ u8 bssid[ETH_ALEN];
+ u8 init_sta[ETH_ALEN];
+ u8 resp_sta[ETH_ALEN];
 } __packed;
 
 struct ieee80211_tdls_data {
- u8 da[6];
- u8 sa[6];
+ u8 da[ETH_ALEN];
+ u8 sa[ETH_ALEN];
  __be16 ether_type;
  u8 payload_type;
  u8 category;
@@ -1089,8 +1129,8 @@ struct ieee80211_p2p_noa_attr {
 struct ieee80211_bar {
  __le16 frame_control;
  __le16 duration;
- __u8 ra[6];
- __u8 ta[6];
+ __u8 ra[ETH_ALEN];
+ __u8 ta[ETH_ALEN];
  __le16 control;
  __le16 start_seq_num;
 } __packed;
@@ -1389,8 +1429,12 @@ struct ieee80211_vht_operation {
 #define IEEE80211_VHT_CAP_RXSTBC_MASK    0x00000700
 #define IEEE80211_VHT_CAP_SU_BEAMFORMER_CAPABLE   0x00000800
 #define IEEE80211_VHT_CAP_SU_BEAMFORMEE_CAPABLE   0x00001000
-#define IEEE80211_VHT_CAP_BEAMFORMER_ANTENNAS_MAX  0x00006000
-#define IEEE80211_VHT_CAP_SOUNDING_DIMENSIONS_MAX  0x00030000
+#define IEEE80211_VHT_CAP_BEAMFORMEE_STS_SHIFT                  13
+#define IEEE80211_VHT_CAP_BEAMFORMEE_STS_MASK   \
+  (7 << IEEE80211_VHT_CAP_BEAMFORMEE_STS_SHIFT)
+#define IEEE80211_VHT_CAP_SOUNDING_DIMENSIONS_SHIFT  16
+#define IEEE80211_VHT_CAP_SOUNDING_DIMENSIONS_MASK  \
+  (7 << IEEE80211_VHT_CAP_SOUNDING_DIMENSIONS_SHIFT)
 #define IEEE80211_VHT_CAP_MU_BEAMFORMER_CAPABLE   0x00080000
 #define IEEE80211_VHT_CAP_MU_BEAMFORMEE_CAPABLE   0x00100000
 #define IEEE80211_VHT_CAP_VHT_TXOP_PS    0x00200000
@@ -1610,51 +1654,22 @@ enum ieee80211_reasoncode {
 enum ieee80211_eid {
  WLAN_EID_SSID = 0,
  WLAN_EID_SUPP_RATES = 1,
- WLAN_EID_FH_PARAMS = 2,
+ WLAN_EID_FH_PARAMS = 2, /* reserved now */
  WLAN_EID_DS_PARAMS = 3,
  WLAN_EID_CF_PARAMS = 4,
  WLAN_EID_TIM = 5,
  WLAN_EID_IBSS_PARAMS = 6,
- WLAN_EID_CHALLENGE = 16,
-
  WLAN_EID_COUNTRY = 7,
  WLAN_EID_HP_PARAMS = 8,
  WLAN_EID_HP_TABLE = 9,
  WLAN_EID_REQUEST = 10,
-
  WLAN_EID_QBSS_LOAD = 11,
  WLAN_EID_EDCA_PARAM_SET = 12,
  WLAN_EID_TSPEC = 13,
  WLAN_EID_TCLAS = 14,
  WLAN_EID_SCHEDULE = 15,
- WLAN_EID_TS_DELAY = 43,
- WLAN_EID_TCLAS_PROCESSING = 44,
- WLAN_EID_QOS_CAPA = 46,
- /* 802.11z */
- WLAN_EID_LINK_ID = 101,
- /* 802.11s */
- WLAN_EID_MESH_CONFIG = 113,
- WLAN_EID_MESH_ID = 114,
- WLAN_EID_LINK_METRIC_REPORT = 115,
- WLAN_EID_CONGESTION_NOTIFICATION = 116,
- WLAN_EID_PEER_MGMT = 117,
- WLAN_EID_CHAN_SWITCH_PARAM = 118,
- WLAN_EID_MESH_AWAKE_WINDOW = 119,
- WLAN_EID_BEACON_TIMING = 120,
- WLAN_EID_MCCAOP_SETUP_REQ = 121,
- WLAN_EID_MCCAOP_SETUP_RESP = 122,
- WLAN_EID_MCCAOP_ADVERT = 123,
- WLAN_EID_MCCAOP_TEARDOWN = 124,
- WLAN_EID_GANN = 125,
- WLAN_EID_RANN = 126,
- WLAN_EID_PREQ = 130,
- WLAN_EID_PREP = 131,
- WLAN_EID_PERR = 132,
- WLAN_EID_PXU = 137,
- WLAN_EID_PXUC = 138,
- WLAN_EID_AUTH_MESH_PEER_EXCH = 139,
- WLAN_EID_MIC = 140,
-
+ WLAN_EID_CHALLENGE = 16,
+ /* 17-31 reserved for challenge text extension */
  WLAN_EID_PWR_CONSTRAINT = 32,
  WLAN_EID_PWR_CAPABILITY = 33,
  WLAN_EID_TPC_REQUEST = 34,
@@ -1665,62 +1680,115 @@ enum ieee80211_eid {
  WLAN_EID_MEASURE_REPORT = 39,
  WLAN_EID_QUIET = 40,
  WLAN_EID_IBSS_DFS = 41,
-
  WLAN_EID_ERP_INFO = 42,
- WLAN_EID_EXT_SUPP_RATES = 50,
-
+ WLAN_EID_TS_DELAY = 43,
+ WLAN_EID_TCLAS_PROCESSING = 44,
  WLAN_EID_HT_CAPABILITY = 45,
- WLAN_EID_HT_OPERATION = 61,
- WLAN_EID_SECONDARY_CHANNEL_OFFSET = 62,
-
+ WLAN_EID_QOS_CAPA = 46,
+ /* 47 reserved for Broadcom */
  WLAN_EID_RSN = 48,
- WLAN_EID_MMIE = 76,
- WLAN_EID_VENDOR_SPECIFIC = 221,
- WLAN_EID_QOS_PARAMETER = 222,
-
+ WLAN_EID_802_15_COEX = 49,
+ WLAN_EID_EXT_SUPP_RATES = 50,
  WLAN_EID_AP_CHAN_REPORT = 51,
  WLAN_EID_NEIGHBOR_REPORT = 52,
  WLAN_EID_RCPI = 53,
+ WLAN_EID_MOBILITY_DOMAIN = 54,
+ WLAN_EID_FAST_BSS_TRANSITION = 55,
+ WLAN_EID_TIMEOUT_INTERVAL = 56,
+ WLAN_EID_RIC_DATA = 57,
+ WLAN_EID_DSE_REGISTERED_LOCATION = 58,
+ WLAN_EID_SUPPORTED_REGULATORY_CLASSES = 59,
+ WLAN_EID_EXT_CHANSWITCH_ANN = 60,
+ WLAN_EID_HT_OPERATION = 61,
+ WLAN_EID_SECONDARY_CHANNEL_OFFSET = 62,
  WLAN_EID_BSS_AVG_ACCESS_DELAY = 63,
  WLAN_EID_ANTENNA_INFO = 64,
  WLAN_EID_RSNI = 65,
  WLAN_EID_MEASUREMENT_PILOT_TX_INFO = 66,
  WLAN_EID_BSS_AVAILABLE_CAPACITY = 67,
  WLAN_EID_BSS_AC_ACCESS_DELAY = 68,
+ WLAN_EID_TIME_ADVERTISEMENT = 69,
  WLAN_EID_RRM_ENABLED_CAPABILITIES = 70,
  WLAN_EID_MULTIPLE_BSSID = 71,
  WLAN_EID_BSS_COEX_2040 = 72,
+ WLAN_EID_BSS_INTOLERANT_CHL_REPORT = 73,
  WLAN_EID_OVERLAP_BSS_SCAN_PARAM = 74,
- WLAN_EID_EXT_CAPABILITY = 127,
-
- WLAN_EID_MOBILITY_DOMAIN = 54,
- WLAN_EID_FAST_BSS_TRANSITION = 55,
- WLAN_EID_TIMEOUT_INTERVAL = 56,
- WLAN_EID_RIC_DATA = 57,
  WLAN_EID_RIC_DESCRIPTOR = 75,
-
- WLAN_EID_DSE_REGISTERED_LOCATION = 58,
- WLAN_EID_SUPPORTED_REGULATORY_CLASSES = 59,
- WLAN_EID_EXT_CHANSWITCH_ANN = 60,
-
- WLAN_EID_VHT_CAPABILITY = 191,
- WLAN_EID_VHT_OPERATION = 192,
- WLAN_EID_OPMODE_NOTIF = 199,
- WLAN_EID_WIDE_BW_CHANNEL_SWITCH = 194,
- WLAN_EID_CHANNEL_SWITCH_WRAPPER = 196,
-
- /* 802.11ad */
+ WLAN_EID_MMIE = 76,
+ WLAN_EID_ASSOC_COMEBACK_TIME = 77,
+ WLAN_EID_EVENT_REQUEST = 78,
+ WLAN_EID_EVENT_REPORT = 79,
+ WLAN_EID_DIAGNOSTIC_REQUEST = 80,
+ WLAN_EID_DIAGNOSTIC_REPORT = 81,
+ WLAN_EID_LOCATION_PARAMS = 82,
  WLAN_EID_NON_TX_BSSID_CAP =  83,
+ WLAN_EID_SSID_LIST = 84,
+ WLAN_EID_MULTI_BSSID_IDX = 85,
+ WLAN_EID_FMS_DESCRIPTOR = 86,
+ WLAN_EID_FMS_REQUEST = 87,
+ WLAN_EID_FMS_RESPONSE = 88,
+ WLAN_EID_QOS_TRAFFIC_CAPA = 89,
+ WLAN_EID_BSS_MAX_IDLE_PERIOD = 90,
+ WLAN_EID_TSF_REQUEST = 91,
+ WLAN_EID_TSF_RESPOSNE = 92,
+ WLAN_EID_WNM_SLEEP_MODE = 93,
+ WLAN_EID_TIM_BCAST_REQ = 94,
+ WLAN_EID_TIM_BCAST_RESP = 95,
+ WLAN_EID_COLL_IF_REPORT = 96,
+ WLAN_EID_CHANNEL_USAGE = 97,
+ WLAN_EID_TIME_ZONE = 98,
+ WLAN_EID_DMS_REQUEST = 99,
+ WLAN_EID_DMS_RESPONSE = 100,
+ WLAN_EID_LINK_ID = 101,
+ WLAN_EID_WAKEUP_SCHEDUL = 102,
+ /* 103 reserved */
+ WLAN_EID_CHAN_SWITCH_TIMING = 104,
+ WLAN_EID_PTI_CONTROL = 105,
+ WLAN_EID_PU_BUFFER_STATUS = 106,
+ WLAN_EID_INTERWORKING = 107,
+ WLAN_EID_ADVERTISEMENT_PROTOCOL = 108,
+ WLAN_EID_EXPEDITED_BW_REQ = 109,
+ WLAN_EID_QOS_MAP_SET = 110,
+ WLAN_EID_ROAMING_CONSORTIUM = 111,
+ WLAN_EID_EMERGENCY_ALERT = 112,
+ WLAN_EID_MESH_CONFIG = 113,
+ WLAN_EID_MESH_ID = 114,
+ WLAN_EID_LINK_METRIC_REPORT = 115,
+ WLAN_EID_CONGESTION_NOTIFICATION = 116,
+ WLAN_EID_PEER_MGMT = 117,
+ WLAN_EID_CHAN_SWITCH_PARAM = 118,
+ WLAN_EID_MESH_AWAKE_WINDOW = 119,
+ WLAN_EID_BEACON_TIMING = 120,
+ WLAN_EID_MCCAOP_SETUP_REQ = 121,
+ WLAN_EID_MCCAOP_SETUP_RESP = 122,
+ WLAN_EID_MCCAOP_ADVERT = 123,
+ WLAN_EID_MCCAOP_TEARDOWN = 124,
+ WLAN_EID_GANN = 125,
+ WLAN_EID_RANN = 126,
+ WLAN_EID_EXT_CAPABILITY = 127,
+ /* 128, 129 reserved for Agere */
+ WLAN_EID_PREQ = 130,
+ WLAN_EID_PREP = 131,
+ WLAN_EID_PERR = 132,
+ /* 133-136 reserved for Cisco */
+ WLAN_EID_PXU = 137,
+ WLAN_EID_PXUC = 138,
+ WLAN_EID_AUTH_MESH_PEER_EXCH = 139,
+ WLAN_EID_MIC = 140,
+ WLAN_EID_DESTINATION_URI = 141,
+ WLAN_EID_UAPSD_COEX = 142,
  WLAN_EID_WAKEUP_SCHEDULE = 143,
  WLAN_EID_EXT_SCHEDULE = 144,
  WLAN_EID_STA_AVAILABILITY = 145,
  WLAN_EID_DMG_TSPEC = 146,
  WLAN_EID_DMG_AT = 147,
  WLAN_EID_DMG_CAP = 148,
+ /* 149-150 reserved for Cisco */
  WLAN_EID_DMG_OPERATION = 151,
  WLAN_EID_DMG_BSS_PARAM_CHANGE = 152,
  WLAN_EID_DMG_BEAM_REFINEMENT = 153,
  WLAN_EID_CHANNEL_MEASURE_FEEDBACK = 154,
+ /* 155-156 reserved for Cisco */
  WLAN_EID_AWAKE_WINDOW = 157,
  WLAN_EID_MULTI_BAND = 158,
  WLAN_EID_ADDBA_EXT = 159,
@@ -1737,11 +1805,34 @@ enum ieee80211_eid {
  WLAN_EID_MULTIPLE_MAC_ADDR = 170,
  WLAN_EID_U_PID = 171,
  WLAN_EID_DMG_LINK_ADAPT_ACK = 172,
+ /* 173 reserved for Symbol */
+ WLAN_EID_MCCAOP_ADV_OVERVIEW = 174,
  WLAN_EID_QUIET_PERIOD_REQ = 175,
+ /* 176 reserved for Symbol */
  WLAN_EID_QUIET_PERIOD_RESP = 177,
+ /* 178-179 reserved for Symbol */
+ /* 180 reserved for ISO/IEC 20011 */
  WLAN_EID_EPAC_POLICY = 182,
  WLAN_EID_CLISTER_TIME_OFF = 183,
+ WLAN_EID_INTER_AC_PRIO = 184,
+ WLAN_EID_SCS_DESCRIPTOR = 185,
+ WLAN_EID_QLOAD_REPORT = 186,
+ WLAN_EID_HCCA_TXOP_UPDATE_COUNT = 187,
+ WLAN_EID_HL_STREAM_ID = 188,
+ WLAN_EID_GCR_GROUP_ADDR = 189,
  WLAN_EID_ANTENNA_SECTOR_ID_PATTERN = 190,
+ WLAN_EID_VHT_CAPABILITY = 191,
+ WLAN_EID_VHT_OPERATION = 192,
+ WLAN_EID_EXTENDED_BSS_LOAD = 193,
+ WLAN_EID_WIDE_BW_CHANNEL_SWITCH = 194,
+ WLAN_EID_VHT_TX_POWER_ENVELOPE = 195,
+ WLAN_EID_CHANNEL_SWITCH_WRAPPER = 196,
+ WLAN_EID_AID = 197,
+ WLAN_EID_QUIET_CHANNEL = 198,
+ WLAN_EID_OPMODE_NOTIF = 199,
+
+ WLAN_EID_VENDOR_SPECIFIC = 221,
+ WLAN_EID_QOS_PARAMETER = 222,
 };
 
 /* Action category code */
@@ -1827,8 +1918,18 @@ enum ieee80211_key_len {
  WLAN_KEY_LEN_CCMP = 16,
  WLAN_KEY_LEN_TKIP = 32,
  WLAN_KEY_LEN_AES_CMAC = 16,
+ WLAN_KEY_LEN_SMS4 = 32,
 };
 
+#define IEEE80211_WEP_IV_LEN  4
+#define IEEE80211_WEP_ICV_LEN  4
+#define IEEE80211_CCMP_HDR_LEN  8
+#define IEEE80211_CCMP_MIC_LEN  8
+#define IEEE80211_CCMP_PN_LEN  6
+#define IEEE80211_TKIP_IV_LEN  8
+#define IEEE80211_TKIP_ICV_LEN  4
+#define IEEE80211_CMAC_PN_LEN  6
+
 /* Public action codes */
 enum ieee80211_pub_actioncode {
  WLAN_PUB_ACTION_EXT_CHANSW_ANN = 4,
@@ -1850,6 +1951,11 @@ enum ieee80211_tdls_actioncode {
  WLAN_TDLS_DISCOVERY_REQUEST = 10,
 };
 
+/* Interworking capabilities are set in 7th bit of 4th byte of the
+ * @WLAN_EID_EXT_CAPABILITY information element
+ */
+#define WLAN_EXT_CAPA4_INTERWORKING_ENABLED BIT(7)
+
 /*
  * TDLS capabililites to be enabled in the 5th byte of the
  * @WLAN_EID_EXT_CAPABILITY information element
@@ -1858,6 +1964,7 @@ enum ieee80211_tdls_actioncode {
 #define WLAN_EXT_CAPA5_TDLS_PROHIBITED BIT(6)
 
 #define WLAN_EXT_CAPA8_OPMODE_NOTIF BIT(6)
+#define WLAN_EXT_CAPA8_TDLS_WIDE_BW_ENABLED BIT(7)
 
 /* TDLS specific payload type in the LLC/SNAP header */
 #define WLAN_TDLS_SNAP_RFTYPE 0x2
@@ -2146,10 +2253,10 @@ static inline u8 *ieee80211_get_DA(struct ieee80211_hdr *hdr)
 }
 
 /**
- * ieee80211_is_robust_mgmt_frame - check if frame is a robust management frame
+ * _ieee80211_is_robust_mgmt_frame - check if frame is a robust management frame
  * @hdr: the frame (buffer must include at least the first octet of payload)
  */
-static inline bool ieee80211_is_robust_mgmt_frame(struct ieee80211_hdr *hdr)
+static inline bool _ieee80211_is_robust_mgmt_frame(struct ieee80211_hdr *hdr)
 {
  if (ieee80211_is_disassoc(hdr->frame_control) ||
      ieee80211_is_deauth(hdr->frame_control))
@@ -2178,6 +2285,17 @@ static inline bool ieee80211_is_robust_mgmt_frame(struct ieee80211_hdr *hdr)
 }
 
 /**
+ * ieee80211_is_robust_mgmt_frame - check if skb contains a robust mgmt frame
+ * @skb: the skb containing the frame, length will be checked
+ */
+static inline bool ieee80211_is_robust_mgmt_frame(struct sk_buff *skb)
+{
+ if (skb->len < 25)
+  return false;
+ return _ieee80211_is_robust_mgmt_frame((void *)skb->data);
+}
+
+/**
  * ieee80211_is_public_action - check if frame is a public action frame
  * @hdr: the frame
  * @len: length of the frame
@@ -2195,42 +2313,6 @@ static inline bool ieee80211_is_public_action(struct ieee80211_hdr *hdr,
 }
 
 /**
- * ieee80211_dsss_chan_to_freq - get channel center frequency
- * @channel: the DSSS channel
- *
- * Convert IEEE802.11 DSSS channel to the center frequency (MHz).
- * Ref IEEE 802.11-2007 section 15.6
- */
-static inline int ieee80211_dsss_chan_to_freq(int channel)
-{
- if ((channel > 0) && (channel < 14))
-  return 2407 + (channel * 5);
- else if (channel == 14)
-  return 2484;
- else
-  return -1;
-}
-
-/**
- * ieee80211_freq_to_dsss_chan - get channel
- * @freq: the frequency
- *
- * Convert frequency (MHz) to IEEE802.11 DSSS channel
- * Ref IEEE 802.11-2007 section 15.6
- *
- * This routine selects the channel with the closest center frequency.
- */
-static inline int ieee80211_freq_to_dsss_chan(int freq)
-{
- if ((freq >= 2410) && (freq < 2475))
-  return (freq - 2405) / 5;
- else if ((freq >= 2482) && (freq < 2487))
-  return 14;
- else
-  return -1;
-}
-
-/**
  * ieee80211_tu_to_usec - convert time units (TU) to microseconds
  * @tu: the TUs
  */
@@ -2269,4 +2351,8 @@ static inline bool ieee80211_check_tim(const struct ieee80211_tim_ie *tim,
  return !!(tim->virtual_map[index] & mask);
 }
 
+/* convert time units */
+#define TU_TO_JIFFIES(x) (usecs_to_jiffies((x) * 1024))
+#define TU_TO_EXP_TIME(x) (jiffies + TU_TO_JIFFIES(x))
+
 #endif /* LINUX_IEEE80211_H */
diff --git a/include/linux/mpls.h b/include/linux/mpls.h
new file mode 100644
index 0000000..9999145
--- /dev/null
+++ b/include/linux/mpls.h
@@ -0,0 +1,6 @@
+#ifndef _LINUX_MPLS_H
+#define _LINUX_MPLS_H
+
+#include <uapi/linux/mpls.h>
+
+#endif  /* _LINUX_MPLS_H */
diff --git a/include/net/cfg80211.h b/include/net/cfg80211.h
index 26b5b69..e46c437 100644
--- a/include/net/cfg80211.h
+++ b/include/net/cfg80211.h
@@ -91,9 +91,8 @@ enum ieee80211_band {
  * Channel flags set by the regulatory control code.
  *
  * @IEEE80211_CHAN_DISABLED: This channel is disabled.
- * @IEEE80211_CHAN_PASSIVE_SCAN: Only passive scanning is permitted
- * on this channel.
- * @IEEE80211_CHAN_NO_IBSS: IBSS is not allowed on this channel.
+ * @IEEE80211_CHAN_NO_IR: do not initiate radiation, this includes
+ *  sending probe requests or beaconing.
  * @IEEE80211_CHAN_RADAR: Radar detection is required on this channel.
  * @IEEE80211_CHAN_NO_HT40PLUS: extension channel above this channel
  *  is not permitted.
@@ -110,17 +109,28 @@ enum ieee80211_band {
  * channel as the control or any of the secondary channels.
  * This may be due to the driver or due to regulatory bandwidth
  * restrictions.
+ * @IEEE80211_CHAN_INDOOR_ONLY: see %NL80211_FREQUENCY_ATTR_INDOOR_ONLY
+ * @IEEE80211_CHAN_GO_CONCURRENT: see %NL80211_FREQUENCY_ATTR_GO_CONCURRENT
+ * @IEEE80211_CHAN_NO_20MHZ: 20 MHz bandwidth is not permitted
+ * on this channel.
+ * @IEEE80211_CHAN_NO_10MHZ: 10 MHz bandwidth is not permitted
+ * on this channel.
+ *
  */
 enum ieee80211_channel_flags {
  IEEE80211_CHAN_DISABLED  = 1<<0,
- IEEE80211_CHAN_PASSIVE_SCAN = 1<<1,
- IEEE80211_CHAN_NO_IBSS  = 1<<2,
+ IEEE80211_CHAN_NO_IR  = 1<<1,
+ /* hole at 1<<2 */
  IEEE80211_CHAN_RADAR  = 1<<3,
  IEEE80211_CHAN_NO_HT40PLUS = 1<<4,
  IEEE80211_CHAN_NO_HT40MINUS = 1<<5,
  IEEE80211_CHAN_NO_OFDM  = 1<<6,
  IEEE80211_CHAN_NO_80MHZ  = 1<<7,
  IEEE80211_CHAN_NO_160MHZ = 1<<8,
+ IEEE80211_CHAN_INDOOR_ONLY = 1<<9,
+ IEEE80211_CHAN_GO_CONCURRENT = 1<<10,
+ IEEE80211_CHAN_NO_20MHZ  = 1<<11,
+ IEEE80211_CHAN_NO_10MHZ  = 1<<12,
 };
 
 #define IEEE80211_CHAN_NO_HT40 \
@@ -152,6 +162,7 @@ enum ieee80211_channel_flags {
  * @dfs_state: current state of this channel. Only relevant if radar is required
  * on this channel.
  * @dfs_state_entered: timestamp (jiffies) when the dfs state was entered.
+ * @dfs_cac_ms: DFS CAC time in milliseconds, this is valid for DFS channels.
  */
 struct ieee80211_channel {
  enum ieee80211_band band;
@@ -166,6 +177,7 @@ struct ieee80211_channel {
  int orig_mag, orig_mpwr;
  enum nl80211_dfs_state dfs_state;
  unsigned long dfs_state_entered;
+ unsigned int dfs_cac_ms;
 };
 
 /**
@@ -188,6 +200,8 @@ struct ieee80211_channel {
  * when used with 802.11g (on the 2.4 GHz band); filled by the
  * core code when registering the wiphy.
  * @IEEE80211_RATE_ERP_G: This is an ERP rate in 802.11g mode.
+ * @IEEE80211_RATE_SUPPORTS_5MHZ: Rate can be used in 5 MHz mode
+ * @IEEE80211_RATE_SUPPORTS_10MHZ: Rate can be used in 10 MHz mode
  */
 enum ieee80211_rate_flags {
  IEEE80211_RATE_SHORT_PREAMBLE = 1<<0,
@@ -195,6 +209,8 @@ enum ieee80211_rate_flags {
  IEEE80211_RATE_MANDATORY_B = 1<<2,
  IEEE80211_RATE_MANDATORY_G = 1<<3,
  IEEE80211_RATE_ERP_G  = 1<<4,
+ IEEE80211_RATE_SUPPORTS_5MHZ = 1<<5,
+ IEEE80211_RATE_SUPPORTS_10MHZ = 1<<6,
 };
 
 /**
@@ -325,8 +341,8 @@ struct vif_params {
  * @seq_len: length of @seq.
  */
 struct key_params {
- u8 *key;
- u8 *seq;
+ const u8 *key;
+ const u8 *seq;
  int key_len;
  int seq_len;
  u32 cipher;
@@ -433,6 +449,69 @@ bool cfg80211_chandef_usable(struct wiphy *wiphy,
         u32 prohibited_flags);
 
 /**
+ * cfg80211_chandef_dfs_required - checks if radar detection is required
+ * @wiphy: the wiphy to validate against
+ * @chandef: the channel definition to check
+ * @iftype: the interface type as specified in &enum nl80211_iftype
+ * Returns:
+ * 1 if radar detection is required, 0 if it is not, < 0 on error
+ */
+int cfg80211_chandef_dfs_required(struct wiphy *wiphy,
+      const struct cfg80211_chan_def *chandef,
+      enum nl80211_iftype iftype);
+
+/**
+ * ieee80211_chandef_rate_flags - returns rate flags for a channel
+ *
+ * In some channel types, not all rates may be used - for example CCK
+ * rates may not be used in 5/10 MHz channels.
+ *
+ * @chandef: channel definition for the channel
+ *
+ * Returns: rate flags which apply for this channel
+ */
+static inline enum ieee80211_rate_flags
+ieee80211_chandef_rate_flags(struct cfg80211_chan_def *chandef)
+{
+ switch (chandef->width) {
+ case NL80211_CHAN_WIDTH_5:
+  return IEEE80211_RATE_SUPPORTS_5MHZ;
+ case NL80211_CHAN_WIDTH_10:
+  return IEEE80211_RATE_SUPPORTS_10MHZ;
+ default:
+  break;
+ }
+ return 0;
+}
+
+/**
+ * ieee80211_chandef_max_power - maximum transmission power for the chandef
+ *
+ * In some regulations, the transmit power may depend on the configured channel
+ * bandwidth which may be defined as dBm/MHz. This function returns the actual
+ * max_power for non-standard (20 MHz) channels.
+ *
+ * @chandef: channel definition for the channel
+ *
+ * Returns: maximum allowed transmission power in dBm for the chandef
+ */
+static inline int
+ieee80211_chandef_max_power(struct cfg80211_chan_def *chandef)
+{
+ switch (chandef->width) {
+ case NL80211_CHAN_WIDTH_5:
+  return min(chandef->chan->max_reg_power - 6,
+      chandef->chan->max_power);
+ case NL80211_CHAN_WIDTH_10:
+  return min(chandef->chan->max_reg_power - 3,
+      chandef->chan->max_power);
+ default:
+  break;
+ }
+ return chandef->chan->max_power;
+}
+
+/**
  * enum survey_info_flags - survey information flags
  *
  * @SURVEY_INFO_NOISE_DBM: noise (in dBm) was filled in
@@ -462,7 +541,7 @@ enum survey_info_flags {
  * @channel: the channel this survey record reports, mandatory
  * @filled: bitflag of flags from &enum survey_info_flags
  * @noise: channel noise in dBm. This and all following fields are
- *     optional
+ * optional
  * @channel_time: amount of time in ms the radio spent on the channel
  * @channel_time_busy: amount of time the primary channel was sensed busy
  * @channel_time_ext_busy: amount of time the extension channel was sensed busy
@@ -518,9 +597,9 @@ struct cfg80211_crypto_settings {
 /**
  * struct cfg80211_beacon_data - beacon data
  * @head: head portion of beacon (before TIM IE)
- *     or %NULL if not changed
+ * or %NULL if not changed
  * @tail: tail portion of beacon (after TIM IE)
- *     or %NULL if not changed
+ * or %NULL if not changed
  * @head_len: length of @head
  * @tail_len: length of @tail
  * @beacon_ies: extra information element(s) to add into Beacon frames or %NULL
@@ -589,7 +668,6 @@ struct cfg80211_acl_data {
  * @p2p_opp_ps: P2P opportunistic PS
  * @acl: ACL configuration used by the drivers which has support for
  * MAC address based access control
- * @radar_required: set if radar detection is required
  */
 struct cfg80211_ap_settings {
  struct cfg80211_chan_def chandef;
@@ -607,7 +685,35 @@ struct cfg80211_ap_settings {
  u8 p2p_ctwindow;
  bool p2p_opp_ps;
  const struct cfg80211_acl_data *acl;
+};
+
+/**
+ * struct cfg80211_csa_settings - channel switch settings
+ *
+ * Used for channel switch
+ *
+ * @chandef: defines the channel to use after the switch
+ * @beacon_csa: beacon data while performing the switch
+ * @counter_offsets_beacon: offsets of the counters within the beacon (tail)
+ * @counter_offsets_presp: offsets of the counters within the probe response
+ * @n_counter_offsets_beacon: number of csa counters the beacon (tail)
+ * @n_counter_offsets_presp: number of csa counters in the probe response
+ * @beacon_after: beacon data to be used on the new channel
+ * @radar_required: whether radar detection is required on the new channel
+ * @block_tx: whether transmissions should be blocked while changing
+ * @count: number of beacons until switch
+ */
+struct cfg80211_csa_settings {
+ struct cfg80211_chan_def chandef;
+ struct cfg80211_beacon_data beacon_csa;
+ const u16 *counter_offsets_beacon;
+ const u16 *counter_offsets_presp;
+ unsigned int n_counter_offsets_beacon;
+ unsigned int n_counter_offsets_presp;
+ struct cfg80211_beacon_data beacon_after;
  bool radar_required;
+ bool block_tx;
+ u8 count;
 };
 
 /**
@@ -656,6 +762,12 @@ enum station_parameters_apply_mask {
  * @capability: station capability
  * @ext_capab: extended capabilities of the station
  * @ext_capab_len: number of extended capabilities
+ * @supported_channels: supported channels in IEEE 802.11 format
+ * @supported_channels_len: number of supported channels
+ * @supported_oper_classes: supported oper classes in IEEE 802.11 format
+ * @supported_oper_classes_len: number of supported operating classes
+ * @opmode_notif: operating mode field from Operating Mode Notification
+ * @opmode_notif_used: information if operating mode field is used
  */
 struct station_parameters {
  const u8 *supported_rates;
@@ -675,6 +787,12 @@ struct station_parameters {
  u16 capability;
  const u8 *ext_capab;
  u8 ext_capab_len;
+ const u8 *supported_channels;
+ u8 supported_channels_len;
+ const u8 *supported_oper_classes;
+ u8 supported_oper_classes_len;
+ u8 opmode_notif;
+ bool opmode_notif_used;
 };
 
 /**
@@ -736,7 +854,7 @@ int cfg80211_check_station_change(struct wiphy *wiphy,
  * @STATION_INFO_PLINK_STATE: @plink_state filled
  * @STATION_INFO_SIGNAL: @signal filled
  * @STATION_INFO_TX_BITRATE: @txrate fields are filled
- *  (tx_bitrate, tx_bitrate_flags and tx_bitrate_mcs)
+ * (tx_bitrate, tx_bitrate_flags and tx_bitrate_mcs)
  * @STATION_INFO_RX_PACKETS: @rx_packets filled with 32-bit value
  * @STATION_INFO_TX_PACKETS: @tx_packets filled with 32-bit value
  * @STATION_INFO_TX_RETRIES: @tx_retries filled
@@ -753,34 +871,40 @@ int cfg80211_check_station_change(struct wiphy *wiphy,
  * @STATION_INFO_LOCAL_PM: @local_pm filled
  * @STATION_INFO_PEER_PM: @peer_pm filled
  * @STATION_INFO_NONPEER_PM: @nonpeer_pm filled
+ * @STATION_INFO_CHAIN_SIGNAL: @chain_signal filled
+ * @STATION_INFO_CHAIN_SIGNAL_AVG: @chain_signal_avg filled
+ * @STATION_INFO_EXPECTED_THROUGHPUT: @expected_throughput filled
  */
 enum station_info_flags {
- STATION_INFO_INACTIVE_TIME = 1<<0,
- STATION_INFO_RX_BYTES  = 1<<1,
- STATION_INFO_TX_BYTES  = 1<<2,
- STATION_INFO_LLID  = 1<<3,
- STATION_INFO_PLID  = 1<<4,
- STATION_INFO_PLINK_STATE = 1<<5,
- STATION_INFO_SIGNAL  = 1<<6,
- STATION_INFO_TX_BITRATE  = 1<<7,
- STATION_INFO_RX_PACKETS  = 1<<8,
- STATION_INFO_TX_PACKETS  = 1<<9,
- STATION_INFO_TX_RETRIES  = 1<<10,
- STATION_INFO_TX_FAILED  = 1<<11,
- STATION_INFO_RX_DROP_MISC = 1<<12,
- STATION_INFO_SIGNAL_AVG  = 1<<13,
- STATION_INFO_RX_BITRATE  = 1<<14,
- STATION_INFO_BSS_PARAM          = 1<<15,
- STATION_INFO_CONNECTED_TIME = 1<<16,
- STATION_INFO_ASSOC_REQ_IES = 1<<17,
- STATION_INFO_STA_FLAGS  = 1<<18,
- STATION_INFO_BEACON_LOSS_COUNT = 1<<19,
- STATION_INFO_T_OFFSET  = 1<<20,
- STATION_INFO_LOCAL_PM  = 1<<21,
- STATION_INFO_PEER_PM  = 1<<22,
- STATION_INFO_NONPEER_PM  = 1<<23,
- STATION_INFO_RX_BYTES64  = 1<<24,
- STATION_INFO_TX_BYTES64  = 1<<25,
+ STATION_INFO_INACTIVE_TIME  = BIT(0),
+ STATION_INFO_RX_BYTES   = BIT(1),
+ STATION_INFO_TX_BYTES   = BIT(2),
+ STATION_INFO_LLID   = BIT(3),
+ STATION_INFO_PLID   = BIT(4),
+ STATION_INFO_PLINK_STATE  = BIT(5),
+ STATION_INFO_SIGNAL   = BIT(6),
+ STATION_INFO_TX_BITRATE   = BIT(7),
+ STATION_INFO_RX_PACKETS   = BIT(8),
+ STATION_INFO_TX_PACKETS   = BIT(9),
+ STATION_INFO_TX_RETRIES   = BIT(10),
+ STATION_INFO_TX_FAILED   = BIT(11),
+ STATION_INFO_RX_DROP_MISC  = BIT(12),
+ STATION_INFO_SIGNAL_AVG   = BIT(13),
+ STATION_INFO_RX_BITRATE   = BIT(14),
+ STATION_INFO_BSS_PARAM   = BIT(15),
+ STATION_INFO_CONNECTED_TIME  = BIT(16),
+ STATION_INFO_ASSOC_REQ_IES  = BIT(17),
+ STATION_INFO_STA_FLAGS   = BIT(18),
+ STATION_INFO_BEACON_LOSS_COUNT  = BIT(19),
+ STATION_INFO_T_OFFSET   = BIT(20),
+ STATION_INFO_LOCAL_PM   = BIT(21),
+ STATION_INFO_PEER_PM   = BIT(22),
+ STATION_INFO_NONPEER_PM   = BIT(23),
+ STATION_INFO_RX_BYTES64   = BIT(24),
+ STATION_INFO_TX_BYTES64   = BIT(25),
+ STATION_INFO_CHAIN_SIGNAL  = BIT(26),
+ STATION_INFO_CHAIN_SIGNAL_AVG  = BIT(27),
+ STATION_INFO_EXPECTED_THROUGHPUT = BIT(28),
 };
 
 /**
@@ -857,6 +981,8 @@ struct sta_bss_parameters {
  u16 beacon_interval;
 };
 
+#define IEEE80211_MAX_CHAINS 4
+
 /**
  * struct station_info - station information
  *
@@ -874,6 +1000,9 @@ struct sta_bss_parameters {
  * For CFG80211_SIGNAL_TYPE_MBM, value is expressed in _dBm_.
  * @signal_avg: Average signal strength, type depends on the wiphy's signal_type.
  * For CFG80211_SIGNAL_TYPE_MBM, value is expressed in _dBm_.
+ * @chains: bitmask for filled values in @chain_signal, @chain_signal_avg
+ * @chain_signal: per-chain signal strength of last received packet in dBm
+ * @chain_signal_avg: per-chain signal strength average in dBm
  * @txrate: current unicast bitrate from this station
  * @rxrate: current unicast bitrate to this station
  * @rx_packets: packets received from this station
@@ -897,6 +1026,8 @@ struct sta_bss_parameters {
  * @local_pm: local mesh STA power save mode
  * @peer_pm: peer mesh STA power save mode
  * @nonpeer_pm: non-peer mesh STA power save mode
+ * @expected_throughput: expected throughput in kbps (including 802.11 headers)
+ * towards this station.
  */
 struct station_info {
  u32 filled;
@@ -909,6 +1040,11 @@ struct station_info {
  u8 plink_state;
  s8 signal;
  s8 signal_avg;
+
+ u8 chains;
+ s8 chain_signal[IEEE80211_MAX_CHAINS];
+ s8 chain_signal_avg[IEEE80211_MAX_CHAINS];
+
  struct rate_info txrate;
  struct rate_info rxrate;
  u32 rx_packets;
@@ -930,6 +1066,8 @@ struct station_info {
  enum nl80211_mesh_power_mode peer_pm;
  enum nl80211_mesh_power_mode nonpeer_pm;
 
+ u32 expected_throughput;
+
  /*
   * Note: Add a new enum station_info_flags value for each new field and
   * use it to check which fields are initialized.
@@ -937,6 +1075,19 @@ struct station_info {
 };
 
 /**
+ * cfg80211_get_station - retrieve information about a given station
+ * @dev: the device where the station is supposed to be connected to
+ * @mac_addr: the mac address of the station of interest
+ * @sinfo: pointer to the structure to fill with the information
+ *
+ * Returns 0 on success and sinfo is filled with the available information
+ * otherwise returns a negative error code and the content of sinfo has to be
+ * considered undefined.
+ */
+int cfg80211_get_station(struct net_device *dev, const u8 *mac_addr,
+    struct station_info *sinfo);
+
+/**
  * enum monitor_flags - monitor flags
  *
  * Monitor interface configuration flags. Note that these must be the bits
@@ -947,6 +1098,7 @@ struct station_info {
  * @MONITOR_FLAG_CONTROL: pass control frames
  * @MONITOR_FLAG_OTHER_BSS: disable BSSID filtering
  * @MONITOR_FLAG_COOK_FRAMES: report frames after processing
+ * @MONITOR_FLAG_ACTIVE: active monitor, ACKs frames on its MAC address
  */
 enum monitor_flags {
  MONITOR_FLAG_FCSFAIL  = 1<<NL80211_MNTR_FLAG_FCSFAIL,
@@ -954,6 +1106,7 @@ enum monitor_flags {
  MONITOR_FLAG_CONTROL  = 1<<NL80211_MNTR_FLAG_CONTROL,
  MONITOR_FLAG_OTHER_BSS  = 1<<NL80211_MNTR_FLAG_OTHER_BSS,
  MONITOR_FLAG_COOK_FRAMES = 1<<NL80211_MNTR_FLAG_COOK_FRAMES,
+ MONITOR_FLAG_ACTIVE  = 1<<NL80211_MNTR_FLAG_ACTIVE,
 };
 
 /**
@@ -1035,7 +1188,7 @@ struct bss_parameters {
  int use_cts_prot;
  int use_short_preamble;
  int use_short_slot_time;
- u8 *basic_rates;
+ const u8 *basic_rates;
  u8 basic_rates_len;
  int ap_isolate;
  int ht_opmode;
@@ -1108,6 +1261,9 @@ struct bss_parameters {
  * setting for new peer links.
  * @dot11MeshAwakeWindowDuration: The duration in TUs the STA will remain awake
  * after transmitting its beacon.
+ * @plink_timeout: If no tx activity is seen from a STA we've established
+ * peering with for longer than this time (in seconds), then remove it
+ * from the STA's list of peers.  Default is 30 minutes.
  */
 struct mesh_config {
  u16 dot11MeshRetryTimeout;
@@ -1137,6 +1293,7 @@ struct mesh_config {
  u16 dot11MeshHWMPconfirmationInterval;
  enum nl80211_mesh_power_mode power_mode;
  u16 dot11MeshAwakeWindowDuration;
+ u32 plink_timeout;
 };
 
 /**
@@ -1147,6 +1304,7 @@ struct mesh_config {
  * @sync_method: which synchronization method to use
  * @path_sel_proto: which path selection protocol to use
  * @path_metric: which metric to use
+ * @auth_id: which authentication method this mesh is using
  * @ie: vendor information elements (optional)
  * @ie_len: length of vendor information elements
  * @is_authenticated: this mesh requires authentication
@@ -1155,6 +1313,7 @@ struct mesh_config {
  * @dtim_period: DTIM period to use
  * @beacon_interval: beacon interval to use
  * @mcast_rate: multicat rate for Mesh Node [6Mbps is the default for 802.11a]
+ * @basic_rates: basic rates to use when creating the mesh
  *
  * These parameters are fixed when the mesh is created.
  */
@@ -1165,6 +1324,7 @@ struct mesh_setup {
  u8 sync_method;
  u8 path_sel_proto;
  u8 path_metric;
+ u8 auth_id;
  const u8 *ie;
  u8 ie_len;
  bool is_authenticated;
@@ -1173,6 +1333,7 @@ struct mesh_setup {
  u8 dtim_period;
  u16 beacon_interval;
  int mcast_rate[IEEE80211_NUM_BANDS];
+ u32 basic_rates;
 };
 
 /**
@@ -1233,6 +1394,7 @@ struct cfg80211_ssid {
  * @n_ssids: number of SSIDs
  * @channels: channels to scan on.
  * @n_channels: total number of channels to scan
+ * @scan_width: channel width for scanning
  * @ie: optional information element(s) to add into Probe Request or %NULL
  * @ie_len: length of ie in octets
  * @flags: bit field of flags controlling operation
@@ -1241,12 +1403,14 @@ struct cfg80211_ssid {
  * @scan_start: time (in jiffies) when the scan started
  * @wdev: the wireless device to scan for
  * @aborted: (internal) scan request was notified as aborted
+ * @notified: (internal) scan request was notified as done or aborted
  * @no_cck: used to send probe requests at non CCK rate in 2GHz band
  */
 struct cfg80211_scan_request {
  struct cfg80211_ssid *ssids;
  int n_ssids;
  u32 n_channels;
+ enum nl80211_bss_scan_width scan_width;
  const u8 *ie;
  size_t ie_len;
  u32 flags;
@@ -1258,7 +1422,7 @@ struct cfg80211_scan_request {
  /* internal */
  struct wiphy *wiphy;
  unsigned long scan_start;
- bool aborted;
+ bool aborted, notified;
  bool no_cck;
 
  /* keep last */
@@ -1268,10 +1432,12 @@ struct cfg80211_scan_request {
 /**
  * struct cfg80211_match_set - sets of attributes to match
  *
- * @ssid: SSID to be matched
+ * @ssid: SSID to be matched; may be zero-length for no match (RSSI only)
+ * @rssi_thold: don't report scan results below this threshold (in s32 dBm)
  */
 struct cfg80211_match_set {
  struct cfg80211_ssid ssid;
+ s32 rssi_thold;
 };
 
 /**
@@ -1280,6 +1446,7 @@ struct cfg80211_match_set {
  * @ssids: SSIDs to scan for (passed in the probe_reqs in active scans)
  * @n_ssids: number of SSIDs
  * @n_channels: total number of channels to scan
+ * @scan_width: channel width for scanning
  * @interval: interval between each scheduled scan cycle
  * @ie: optional information element(s) to add into Probe Request or %NULL
  * @ie_len: length of ie in octets
@@ -1293,19 +1460,21 @@ struct cfg80211_match_set {
  * @dev: the interface
  * @scan_start: start time of the scheduled scan
  * @channels: channels to scan
- * @rssi_thold: don't report scan results below this threshold (in s32 dBm)
+ * @min_rssi_thold: for drivers only supporting a single threshold, this
+ * contains the minimum over all matchsets
  */
 struct cfg80211_sched_scan_request {
  struct cfg80211_ssid *ssids;
  int n_ssids;
  u32 n_channels;
+ enum nl80211_bss_scan_width scan_width;
  u32 interval;
  const u8 *ie;
  size_t ie_len;
  u32 flags;
  struct cfg80211_match_set *match_sets;
  int n_match_sets;
- s32 rssi_thold;
+ s32 min_rssi_thold;
 
  /* internal */
  struct wiphy *wiphy;
@@ -1350,6 +1519,7 @@ struct cfg80211_bss_ies {
  * for use in scan results and similar.
  *
  * @channel: channel this BSS is on
+ * @scan_width: width of the control channel
  * @bssid: BSSID of the BSS
  * @beacon_interval: the beacon interval as from the frame
  * @capability: the capability field in host byte order
@@ -1371,6 +1541,7 @@ struct cfg80211_bss_ies {
  */
 struct cfg80211_bss {
  struct ieee80211_channel *channel;
+ enum nl80211_bss_scan_width scan_width;
 
  const struct cfg80211_bss_ies __rcu *ies;
  const struct cfg80211_bss_ies __rcu *beacon_ies;
@@ -1406,7 +1577,8 @@ const u8 *ieee80211_bss_get_ie(struct cfg80211_bss *bss, u8 ie);
  * This structure provides information needed to complete IEEE 802.11
  * authentication.
  *
- * @bss: The BSS to authenticate with.
+ * @bss: The BSS to authenticate with, the callee must obtain a reference
+ * to it if it needs to keep it.
  * @auth_type: Authentication type (algorithm)
  * @ie: Extra IEs to add to Authentication frame or %NULL
  * @ie_len: Length of ie buffer in octets
@@ -1444,11 +1616,10 @@ enum cfg80211_assoc_req_flags {
  *
  * This structure provides information needed to complete IEEE 802.11
  * (re)association.
- * @bss: The BSS to associate with. If the call is successful the driver
- * is given a reference that it must release, normally via a call to
- * cfg80211_send_rx_assoc(), or, if association timed out, with a
- * call to cfg80211_put_bss() (in addition to calling
- * cfg80211_send_assoc_timeout())
+ * @bss: The BSS to associate with. If the call is successful the driver is
+ * given a reference that it must give back to cfg80211_send_rx_assoc()
+ * or to cfg80211_assoc_timeout(). To ensure proper refcounting, new
+ * association requests while already associating must be rejected.
  * @ie: Extra IEs to add to (Re)Association Request frame or %NULL
  * @ie_len: Length of ie buffer in octets
  * @use_mfp: Use management frame protection (IEEE 802.11w) in this association
@@ -1456,7 +1627,7 @@ enum cfg80211_assoc_req_flags {
  * @prev_bssid: previous BSSID, if not %NULL use reassociate frame
  * @flags:  See &enum cfg80211_assoc_req_flags
  * @ht_capa:  HT Capabilities over-rides.  Values set in ht_capa_mask
- *   will be used in ht_capa.  Un-supported values will be ignored.
+ * will be used in ht_capa.  Un-supported values will be ignored.
  * @ht_capa_mask:  The bits of ht_capa which are to be used.
  * @vht_capa: VHT capability override
  * @vht_capa_mask: VHT capability mask indicating which fields to use
@@ -1537,21 +1708,30 @@ struct cfg80211_disassoc_request {
  * sets/clears %NL80211_STA_FLAG_AUTHORIZED. If true, the driver is
  * required to assume that the port is unauthorized until authorized by
  * user space. Otherwise, port is marked authorized by default.
+ * @userspace_handles_dfs: whether user space controls DFS operation, i.e.
+ * changes the channel when a radar is detected. This is required
+ * to operate on DFS channels.
  * @basic_rates: bitmap of basic rates to use when creating the IBSS
  * @mcast_rate: per-band multicast rate index + 1 (0: disabled)
+ * @ht_capa:  HT Capabilities over-rides.  Values set in ht_capa_mask
+ * will be used in ht_capa.  Un-supported values will be ignored.
+ * @ht_capa_mask:  The bits of ht_capa which are to be used.
  */
 struct cfg80211_ibss_params {
- u8 *ssid;
- u8 *bssid;
+ const u8 *ssid;
+ const u8 *bssid;
  struct cfg80211_chan_def chandef;
- u8 *ie;
+ const u8 *ie;
  u8 ssid_len, ie_len;
  u16 beacon_interval;
  u32 basic_rates;
  bool channel_fixed;
  bool privacy;
  bool control_port;
+ bool userspace_handles_dfs;
  int mcast_rate[IEEE80211_NUM_BANDS];
+ struct ieee80211_ht_cap ht_capa;
+ struct ieee80211_ht_cap ht_capa_mask;
 };
 
 /**
@@ -1562,8 +1742,14 @@ struct cfg80211_ibss_params {
  *
  * @channel: The channel to use or %NULL if not specified (auto-select based
  * on scan results)
+ * @channel_hint: The channel of the recommended BSS for initial connection or
+ * %NULL if not specified
  * @bssid: The AP BSSID or %NULL if not specified (auto-select based on scan
  * results)
+ * @bssid_hint: The recommended AP BSSID for initial connection to the BSS or
+ * %NULL if not specified. Unlike the @bssid parameter, the driver is
+ * allowed to ignore this @bssid_hint if it has knowledge of a better BSS
+ * to use.
  * @ssid: SSID
  * @ssid_len: Length of ssid in octets
  * @auth_type: Authentication type (algorithm)
@@ -1577,20 +1763,22 @@ struct cfg80211_ibss_params {
  * @key: WEP key for shared key authentication
  * @flags:  See &enum cfg80211_assoc_req_flags
  * @bg_scan_period:  Background scan period in seconds
- *   or -1 to indicate that default value is to be used.
+ * or -1 to indicate that default value is to be used.
  * @ht_capa:  HT Capabilities over-rides.  Values set in ht_capa_mask
- *   will be used in ht_capa.  Un-supported values will be ignored.
+ * will be used in ht_capa.  Un-supported values will be ignored.
  * @ht_capa_mask:  The bits of ht_capa which are to be used.
  * @vht_capa:  VHT Capability overrides
  * @vht_capa_mask: The bits of vht_capa which are to be used.
  */
 struct cfg80211_connect_params {
  struct ieee80211_channel *channel;
- u8 *bssid;
- u8 *ssid;
+ struct ieee80211_channel *channel_hint;
+ const u8 *bssid;
+ const u8 *bssid_hint;
+ const u8 *ssid;
  size_t ssid_len;
  enum nl80211_auth_type auth_type;
- u8 *ie;
+ const u8 *ie;
  size_t ie_len;
  bool privacy;
  enum nl80211_mfp mfp;
@@ -1627,7 +1815,9 @@ enum wiphy_params_flags {
 struct cfg80211_bitrate_mask {
  struct {
   u32 legacy;
-  u8 mcs[IEEE80211_HT_MCS_MASK_LEN];
+  u8 ht_mcs[IEEE80211_HT_MCS_MASK_LEN];
+  u16 vht_mcs[NL80211_VHT_NSS_MAX];
+  enum nl80211_txrate_gi gi;
  } control[IEEE80211_NUM_BANDS];
 };
 /**
@@ -1640,12 +1830,12 @@ struct cfg80211_bitrate_mask {
  * @pmkid: The PMK material itself.
  */
 struct cfg80211_pmksa {
- u8 *bssid;
- u8 *pmkid;
+ const u8 *bssid;
+ const u8 *pmkid;
 };
 
 /**
- * struct cfg80211_wowlan_trig_pkt_pattern - packet pattern
+ * struct cfg80211_pkt_pattern - packet pattern
  * @mask: bitmask where to match pattern and where to ignore bytes,
  * one bit per byte, in same format as nl80211
  * @pattern: bytes to match where bitmask is 1
@@ -1655,8 +1845,8 @@ struct cfg80211_pmksa {
  * Internal note: @mask and @pattern are allocated in one chunk of
  * memory, free @mask only!
  */
-struct cfg80211_wowlan_trig_pkt_pattern {
- u8 *mask, *pattern;
+struct cfg80211_pkt_pattern {
+ const u8 *mask, *pattern;
  int pattern_len;
  int pkt_offset;
 };
@@ -1717,12 +1907,41 @@ struct cfg80211_wowlan {
  bool any, disconnect, magic_pkt, gtk_rekey_failure,
       eap_identity_req, four_way_handshake,
       rfkill_release;
- struct cfg80211_wowlan_trig_pkt_pattern *patterns;
+ struct cfg80211_pkt_pattern *patterns;
  struct cfg80211_wowlan_tcp *tcp;
  int n_patterns;
 };
 
 /**
+ * struct cfg80211_coalesce_rules - Coalesce rule parameters
+ *
+ * This structure defines coalesce rule for the device.
+ * @delay: maximum coalescing delay in msecs.
+ * @condition: condition for packet coalescence.
+ * see &enum nl80211_coalesce_condition.
+ * @patterns: array of packet patterns
+ * @n_patterns: number of patterns
+ */
+struct cfg80211_coalesce_rules {
+ int delay;
+ enum nl80211_coalesce_condition condition;
+ struct cfg80211_pkt_pattern *patterns;
+ int n_patterns;
+};
+
+/**
+ * struct cfg80211_coalesce - Packet coalescing settings
+ *
+ * This structure defines coalescing settings.
+ * @rules: array of coalesce rules
+ * @n_rules: number of rules
+ */
+struct cfg80211_coalesce {
+ struct cfg80211_coalesce_rules *rules;
+ int n_rules;
+};
+
+/**
  * struct cfg80211_wowlan_wakeup - wakeup report
  * @disconnect: woke up by getting disconnected
  * @magic_pkt: woke up by receiving magic packet
@@ -1780,6 +1999,77 @@ struct cfg80211_update_ft_ies_params {
 };
 
 /**
+ * struct cfg80211_mgmt_tx_params - mgmt tx parameters
+ *
+ * This structure provides information needed to transmit a mgmt frame
+ *
+ * @chan: channel to use
+ * @offchan: indicates wether off channel operation is required
+ * @wait: duration for ROC
+ * @buf: buffer to transmit
+ * @len: buffer length
+ * @no_cck: don't use cck rates for this frame
+ * @dont_wait_for_ack: tells the low level not to wait for an ack
+ * @n_csa_offsets: length of csa_offsets array
+ * @csa_offsets: array of all the csa offsets in the frame
+ */
+struct cfg80211_mgmt_tx_params {
+ struct ieee80211_channel *chan;
+ bool offchan;
+ unsigned int wait;
+ const u8 *buf;
+ size_t len;
+ bool no_cck;
+ bool dont_wait_for_ack;
+ int n_csa_offsets;
+ const u16 *csa_offsets;
+};
+
+/**
+ * struct cfg80211_dscp_exception - DSCP exception
+ *
+ * @dscp: DSCP value that does not adhere to the user priority range definition
+ * @up: user priority value to which the corresponding DSCP value belongs
+ */
+struct cfg80211_dscp_exception {
+ u8 dscp;
+ u8 up;
+};
+
+/**
+ * struct cfg80211_dscp_range - DSCP range definition for user priority
+ *
+ * @low: lowest DSCP value of this user priority range, inclusive
+ * @high: highest DSCP value of this user priority range, inclusive
+ */
+struct cfg80211_dscp_range {
+ u8 low;
+ u8 high;
+};
+
+/* QoS Map Set element length defined in IEEE Std 802.11-2012, 8.4.2.97 */
+#define IEEE80211_QOS_MAP_MAX_EX 21
+#define IEEE80211_QOS_MAP_LEN_MIN 16
+#define IEEE80211_QOS_MAP_LEN_MAX \
+ (IEEE80211_QOS_MAP_LEN_MIN + 2 * IEEE80211_QOS_MAP_MAX_EX)
+
+/**
+ * struct cfg80211_qos_map - QoS Map Information
+ *
+ * This struct defines the Interworking QoS map setting for DSCP values
+ *
+ * @num_des: number of DSCP exceptions (0..21)
+ * @dscp_exception: optionally up to maximum of 21 DSCP exceptions from
+ * the user priority DSCP range definition
+ * @up: DSCP range definition for a particular user priority
+ */
+struct cfg80211_qos_map {
+ u8 num_des;
+ struct cfg80211_dscp_exception dscp_exception[IEEE80211_QOS_MAP_MAX_EX];
+ struct cfg80211_dscp_range up[8];
+};
+
+/**
  * struct cfg80211_ops - backend description for wireless configuration
  *
  * This struct is registered by fullmac card drivers and/or wireless stacks
@@ -1850,7 +2140,9 @@ struct cfg80211_update_ft_ies_params {
  * @get_mpath: get a mesh path for the given parameters
  * @dump_mpath: dump mesh path callback -- resume dump at index @idx
  * @join_mesh: join the mesh network with the specified parameters
+ * (invoked with the wireless_dev mutex held)
  * @leave_mesh: leave the current mesh network
+ * (invoked with the wireless_dev mutex held)
  *
  * @get_mesh_config: Get the current mesh configuration
  *
@@ -1877,20 +2169,28 @@ struct cfg80211_update_ft_ies_params {
  * the scan/scan_done bracket too.
  *
  * @auth: Request to authenticate with the specified peer
+ * (invoked with the wireless_dev mutex held)
  * @assoc: Request to (re)associate with the specified peer
+ * (invoked with the wireless_dev mutex held)
  * @deauth: Request to deauthenticate from the specified peer
+ * (invoked with the wireless_dev mutex held)
  * @disassoc: Request to disassociate from the specified peer
+ * (invoked with the wireless_dev mutex held)
  *
  * @connect: Connect to the ESS with the specified parameters. When connected,
  * call cfg80211_connect_result() with status code %WLAN_STATUS_SUCCESS.
  * If the connection fails for some reason, call cfg80211_connect_result()
  * with the status from the AP.
+ * (invoked with the wireless_dev mutex held)
  * @disconnect: Disconnect from the BSS/ESS.
+ * (invoked with the wireless_dev mutex held)
  *
  * @join_ibss: Join the specified IBSS (or create if necessary). Once done, call
  * cfg80211_ibss_joined(), also call that function when changing BSSID due
  * to a merge.
+ * (invoked with the wireless_dev mutex held)
  * @leave_ibss: Leave the IBSS.
+ * (invoked with the wireless_dev mutex held)
  *
  * @set_mcast_rate: Set the specified multicast rate (only if vif is in ADHOC or
  * MESH mode)
@@ -1927,7 +2227,7 @@ struct cfg80211_update_ft_ies_params {
  * @mgmt_tx_cancel_wait: Cancel the wait time from transmitting a management
  * frame on another channel
  *
- * @testmode_cmd: run a test mode command
+ * @testmode_cmd: run a test mode command; @wdev may be %NULL
  * @testmode_dump: Implement a test mode dump. The cb->args[2] and up may be
  * used by the function, but 0 and 1 must not be touched. Additionally,
  * return error codes other than -ENOBUFS and -ENOENT will terminate the
@@ -1948,7 +2248,12 @@ struct cfg80211_update_ft_ies_params {
  * @set_cqm_txe_config: Configure connection quality monitor TX error
  * thresholds.
  * @sched_scan_start: Tell the driver to start a scheduled scan.
- * @sched_scan_stop: Tell the driver to stop an ongoing scheduled scan.
+ * @sched_scan_stop: Tell the driver to stop an ongoing scheduled scan. This
+ * call must stop the scheduled scan and be ready for starting a new one
+ * before it returns, i.e. @sched_scan_start may be called immediately
+ * after that again and should not fail in that case. The driver should
+ * not call cfg80211_sched_scan_stopped() for a requested stop (when this
+ * method returns 0.)
  *
  * @mgmt_frame_register: Notify driver that a management frame type was
  * registered. Note that this callback may not sleep, and cannot run
@@ -2008,6 +2313,15 @@ struct cfg80211_update_ft_ies_params {
  * driver can take the most appropriate actions.
  * @crit_proto_stop: Indicates critical protocol no longer needs increased link
  * reliability. This operation can not fail.
+ * @set_coalesce: Set coalesce parameters.
+ *
+ * @channel_switch: initiate channel-switch procedure (with CSA)
+ *
+ * @set_qos_map: Set QoS mapping information to the driver
+ *
+ * @set_ap_chanwidth: Set the AP (including P2P GO) mode channel width for the
+ * given interface This is used e.g. for dynamic HT 20/40 MHz channel width
+ * changes during the lifetime of the BSS.
  */
 struct cfg80211_ops {
  int (*suspend)(struct wiphy *wiphy, struct cfg80211_wowlan *wow);
@@ -2050,28 +2364,29 @@ struct cfg80211_ops {
 
 
  int (*add_station)(struct wiphy *wiphy, struct net_device *dev,
-          u8 *mac, struct station_parameters *params);
+          const u8 *mac,
+          struct station_parameters *params);
  int (*del_station)(struct wiphy *wiphy, struct net_device *dev,
-          u8 *mac);
+          const u8 *mac);
  int (*change_station)(struct wiphy *wiphy, struct net_device *dev,
-      u8 *mac, struct station_parameters *params);
+      const u8 *mac,
+      struct station_parameters *params);
  int (*get_station)(struct wiphy *wiphy, struct net_device *dev,
-          u8 *mac, struct station_info *sinfo);
+          const u8 *mac, struct station_info *sinfo);
  int (*dump_station)(struct wiphy *wiphy, struct net_device *dev,
-          int idx, u8 *mac, struct station_info *sinfo);
+    int idx, u8 *mac, struct station_info *sinfo);
 
  int (*add_mpath)(struct wiphy *wiphy, struct net_device *dev,
-          u8 *dst, u8 *next_hop);
+          const u8 *dst, const u8 *next_hop);
  int (*del_mpath)(struct wiphy *wiphy, struct net_device *dev,
-          u8 *dst);
+          const u8 *dst);
  int (*change_mpath)(struct wiphy *wiphy, struct net_device *dev,
-      u8 *dst, u8 *next_hop);
+      const u8 *dst, const u8 *next_hop);
  int (*get_mpath)(struct wiphy *wiphy, struct net_device *dev,
-          u8 *dst, u8 *next_hop,
-          struct mpath_info *pinfo);
+        u8 *dst, u8 *next_hop, struct mpath_info *pinfo);
  int (*dump_mpath)(struct wiphy *wiphy, struct net_device *dev,
-          int idx, u8 *dst, u8 *next_hop,
-          struct mpath_info *pinfo);
+         int idx, u8 *dst, u8 *next_hop,
+         struct mpath_info *pinfo);
  int (*get_mesh_config)(struct wiphy *wiphy,
     struct net_device *dev,
     struct mesh_config *conf);
@@ -2133,7 +2448,8 @@ struct cfg80211_ops {
  void (*rfkill_poll)(struct wiphy *wiphy);
 
 #ifdef CONFIG_NL80211_TESTMODE
- int (*testmode_cmd)(struct wiphy *wiphy, void *data, int len);
+ int (*testmode_cmd)(struct wiphy *wiphy, struct wireless_dev *wdev,
+    void *data, int len);
  int (*testmode_dump)(struct wiphy *wiphy, struct sk_buff *skb,
      struct netlink_callback *cb,
      void *data, int len);
@@ -2163,9 +2479,8 @@ struct cfg80211_ops {
          u64 cookie);
 
  int (*mgmt_tx)(struct wiphy *wiphy, struct wireless_dev *wdev,
-     struct ieee80211_channel *chan, bool offchan,
-     unsigned int wait, const u8 *buf, size_t len,
-     bool no_cck, bool dont_wait_for_ack, u64 *cookie);
+      struct cfg80211_mgmt_tx_params *params,
+      u64 *cookie);
  int (*mgmt_tx_cancel_wait)(struct wiphy *wiphy,
            struct wireless_dev *wdev,
            u64 cookie);
@@ -2201,10 +2516,11 @@ struct cfg80211_ops {
       struct cfg80211_gtk_rekey_data *data);
 
  int (*tdls_mgmt)(struct wiphy *wiphy, struct net_device *dev,
-        u8 *peer, u8 action_code,  u8 dialog_token,
-        u16 status_code, const u8 *buf, size_t len);
+        const u8 *peer, u8 action_code,  u8 dialog_token,
+        u16 status_code, u32 peer_capability,
+        const u8 *buf, size_t len);
  int (*tdls_oper)(struct wiphy *wiphy, struct net_device *dev,
-        u8 *peer, enum nl80211_tdls_operation oper);
+        const u8 *peer, enum nl80211_tdls_operation oper);
 
  int (*probe_client)(struct wiphy *wiphy, struct net_device *dev,
     const u8 *peer, u64 *cookie);
@@ -2234,7 +2550,8 @@ struct cfg80211_ops {
 
  int (*start_radar_detection)(struct wiphy *wiphy,
       struct net_device *dev,
-      struct cfg80211_chan_def *chandef);
+      struct cfg80211_chan_def *chandef,
+      u32 cac_time_ms);
  int (*update_ft_ies)(struct wiphy *wiphy, struct net_device *dev,
      struct cfg80211_update_ft_ies_params *ftie);
  int (*crit_proto_start)(struct wiphy *wiphy,
@@ -2243,6 +2560,19 @@ struct cfg80211_ops {
         u16 duration);
  void (*crit_proto_stop)(struct wiphy *wiphy,
        struct wireless_dev *wdev);
+ int (*set_coalesce)(struct wiphy *wiphy,
+    struct cfg80211_coalesce *coalesce);
+
+ int (*channel_switch)(struct wiphy *wiphy,
+      struct net_device *dev,
+      struct cfg80211_csa_settings *params);
+
+ int     (*set_qos_map)(struct wiphy *wiphy,
+          struct net_device *dev,
+          struct cfg80211_qos_map *qos_map);
+
+ int (*set_ap_chanwidth)(struct wiphy *wiphy, struct net_device *dev,
+        struct cfg80211_chan_def *chandef);
 };
 
 /*
@@ -2253,27 +2583,6 @@ struct cfg80211_ops {
 /**
  * enum wiphy_flags - wiphy capability flags
  *
- * @WIPHY_FLAG_CUSTOM_REGULATORY:  tells us the driver for this device
- *  has its own custom regulatory domain and cannot identify the
- *  ISO / IEC 3166 alpha2 it belongs to. When this is enabled
- *  we will disregard the first regulatory hint (when the
- *  initiator is %REGDOM_SET_BY_CORE).
- * @WIPHY_FLAG_STRICT_REGULATORY: tells us the driver for this device will
- * ignore regulatory domain settings until it gets its own regulatory
- * domain via its regulatory_hint() unless the regulatory hint is
- * from a country IE. After its gets its own regulatory domain it will
- * only allow further regulatory domain settings to further enhance
- * compliance. For example if channel 13 and 14 are disabled by this
- * regulatory domain no user regulatory domain can enable these channels
- * at a later time. This can be used for devices which do not have
- * calibration information guaranteed for frequencies or settings
- * outside of its regulatory domain. If used in combination with
- * WIPHY_FLAG_CUSTOM_REGULATORY the inspected country IE power settings
- * will be followed.
- * @WIPHY_FLAG_DISABLE_BEACON_HINTS: enable this if your driver needs to ensure
- * that passive scan flags and beaconing flags may not be lifted by
- * cfg80211 due to regulatory beacon hints. For more information on beacon
- * hints read the documenation for regulatory_hint_found_beacon()
  * @WIPHY_FLAG_NETNS_OK: if not set, do not allow changing the netns of this
  * wiphy at all
  * @WIPHY_FLAG_PS_ON_BY_DEFAULT: if set to true, powersave will be enabled
@@ -2307,11 +2616,14 @@ struct cfg80211_ops {
  * responds to probe-requests in hardware.
  * @WIPHY_FLAG_OFFCHAN_TX: Device supports direct off-channel TX.
  * @WIPHY_FLAG_HAS_REMAIN_ON_CHANNEL: Device supports remain-on-channel call.
+ * @WIPHY_FLAG_SUPPORTS_5_10_MHZ: Device supports 5 MHz and 10 MHz channels.
+ * @WIPHY_FLAG_HAS_CHANNEL_SWITCH: Device supports channel switch in
+ * beaconing mode (AP, IBSS, Mesh, ...).
  */
 enum wiphy_flags {
- WIPHY_FLAG_CUSTOM_REGULATORY  = BIT(0),
- WIPHY_FLAG_STRICT_REGULATORY  = BIT(1),
- WIPHY_FLAG_DISABLE_BEACON_HINTS  = BIT(2),
+ /* use hole at 0 */
+ /* use hole at 1 */
+ /* use hole at 2 */
  WIPHY_FLAG_NETNS_OK   = BIT(3),
  WIPHY_FLAG_PS_ON_BY_DEFAULT  = BIT(4),
  WIPHY_FLAG_4ADDR_AP   = BIT(5),
@@ -2330,6 +2642,8 @@ enum wiphy_flags {
  WIPHY_FLAG_AP_PROBE_RESP_OFFLOAD = BIT(19),
  WIPHY_FLAG_OFFCHAN_TX   = BIT(20),
  WIPHY_FLAG_HAS_REMAIN_ON_CHANNEL = BIT(21),
+ WIPHY_FLAG_SUPPORTS_5_10_MHZ  = BIT(22),
+ WIPHY_FLAG_HAS_CHANNEL_SWITCH  = BIT(23),
 };
 
 /**
@@ -2353,10 +2667,14 @@ struct ieee80211_iface_limit {
  * between infrastructure and AP types must match. This is required
  * only in special cases.
  * @radar_detect_widths: bitmap of channel widths supported for radar detection
+ * @radar_detect_regions: bitmap of regions supported for radar detection
+ *
+ * With this structure the driver can describe which interface
+ * combinations it supports concurrently.
  *
- * These examples can be expressed as follows:
+ * Examples:
  *
- * Allow #STA <= 1, #AP <= 1, matching BI, channels = 1, 2 total:
+ * 1. Allow #STA <= 1, #AP <= 1, matching BI, channels = 1, 2 total:
  *
  *  struct ieee80211_iface_limit limits1[] = {
  * { .max = 1, .types = BIT(NL80211_IFTYPE_STATION), },
@@ -2370,7 +2688,7 @@ struct ieee80211_iface_limit {
  *  };
  *
  *
- * Allow #{AP, P2P-GO} <= 8, channels = 1, 8 total:
+ * 2. Allow #{AP, P2P-GO} <= 8, channels = 1, 8 total:
  *
  *  struct ieee80211_iface_limit limits2[] = {
  * { .max = 8, .types = BIT(NL80211_IFTYPE_AP) |
@@ -2384,7 +2702,8 @@ struct ieee80211_iface_limit {
  *  };
  *
  *
- * Allow #STA <= 1, #{P2P-client,P2P-GO} <= 3 on two channels, 4 total.
+ * 3. Allow #STA <= 1, #{P2P-client,P2P-GO} <= 3 on two channels, 4 total.
+ *
  * This allows for an infrastructure connection and three P2P connections.
  *
  *  struct ieee80211_iface_limit limits3[] = {
@@ -2406,6 +2725,7 @@ struct ieee80211_iface_combination {
  u8 n_limits;
  bool beacon_int_infra_match;
  u8 radar_detect_widths;
+ u8 radar_detect_regions;
 };
 
 struct ieee80211_txrx_stypes {
@@ -2467,6 +2787,53 @@ struct wiphy_wowlan_support {
 };
 
 /**
+ * struct wiphy_coalesce_support - coalesce support data
+ * @n_rules: maximum number of coalesce rules
+ * @max_delay: maximum supported coalescing delay in msecs
+ * @n_patterns: number of supported patterns in a rule
+ * (see nl80211.h for the pattern definition)
+ * @pattern_max_len: maximum length of each pattern
+ * @pattern_min_len: minimum length of each pattern
+ * @max_pkt_offset: maximum Rx packet offset
+ */
+struct wiphy_coalesce_support {
+ int n_rules;
+ int max_delay;
+ int n_patterns;
+ int pattern_max_len;
+ int pattern_min_len;
+ int max_pkt_offset;
+};
+
+/**
+ * enum wiphy_vendor_command_flags - validation flags for vendor commands
+ * @WIPHY_VENDOR_CMD_NEED_WDEV: vendor command requires wdev
+ * @WIPHY_VENDOR_CMD_NEED_NETDEV: vendor command requires netdev
+ * @WIPHY_VENDOR_CMD_NEED_RUNNING: interface/wdev must be up & running
+ * (must be combined with %_WDEV or %_NETDEV)
+ */
+enum wiphy_vendor_command_flags {
+ WIPHY_VENDOR_CMD_NEED_WDEV = BIT(0),
+ WIPHY_VENDOR_CMD_NEED_NETDEV = BIT(1),
+ WIPHY_VENDOR_CMD_NEED_RUNNING = BIT(2),
+};
+
+/**
+ * struct wiphy_vendor_command - vendor command definition
+ * @info: vendor command identifying information, as used in nl80211
+ * @flags: flags, see &enum wiphy_vendor_command_flags
+ * @doit: callback for the operation, note that wdev is %NULL if the
+ * flags didn't ask for a wdev and non-%NULL otherwise; the data
+ * pointer may be %NULL if userspace provided no data at all
+ */
+struct wiphy_vendor_command {
+ struct nl80211_vendor_cmd_info info;
+ u32 flags;
+ int (*doit)(struct wiphy *wiphy, struct wireless_dev *wdev,
+      const void *data, int data_len);
+};
+
+/**
  * struct wiphy - wireless hardware description
  * @reg_notifier: the driver's regulatory notification callback,
  * note that if your driver uses wiphy_apply_custom_regulatory()
@@ -2487,7 +2854,7 @@ struct wiphy_wowlan_support {
  * @perm_addr: permanent MAC address of this device
  * @addr_mask: If the device supports multiple MAC addresses by masking,
  * set this to a mask with variable bits set to 1, e.g. if the last
- * four bits are variable then set it to 00:...:00:0f. The actual
+ * four bits are variable then set it to 00-00-00-00-00-0f. The actual
  * variable bits shall be determined by the interfaces added, with
  * interfaces not matching the mask being rejected to be brought up.
  * @n_addresses: number of addresses in @addresses.
@@ -2512,6 +2879,8 @@ struct wiphy_wowlan_support {
  * @software_iftypes: bitmask of software interface types, these are not
  * subject to any restrictions since they are purely managed in SW.
  * @flags: wiphy flags, see &enum wiphy_flags
+ * @regulatory_flags: wiphy regulatory flags, see
+ * &enum ieee80211_regulatory_flags
  * @features: features advertised to nl80211, see &enum nl80211_feature_flags.
  * @bss_priv_size: each BSS struct has private data allocated with it,
  * this variable determines its size
@@ -2556,6 +2925,9 @@ struct wiphy_wowlan_support {
  * may request, if implemented.
  *
  * @wowlan: WoWLAN support information
+ * @wowlan_config: current WoWLAN configuration; this should usually not be
+ * used since access to it is necessarily racy, use the parameter passed
+ * to the suspend() operation instead.
  *
  * @ap_sme_capa: AP SME capabilities, flags from &enum nl80211_ap_sme_features.
  * @ht_capa_mod_mask:  Specify what ht_cap values can be over-ridden.
@@ -2573,6 +2945,28 @@ struct wiphy_wowlan_support {
  * 802.11-2012 8.4.2.29 for the defined fields.
  * @extended_capabilities_mask: mask of the valid values
  * @extended_capabilities_len: length of the extended capabilities
+ * @coalesce: packet coalescing support information
+ *
+ * @vendor_commands: array of vendor commands supported by the hardware
+ * @n_vendor_commands: number of vendor commands
+ * @vendor_events: array of vendor events supported by the hardware
+ * @n_vendor_events: number of vendor events
+ *
+ * @max_ap_assoc_sta: maximum number of associated stations supported in AP mode
+ * (including P2P GO) or 0 to indicate no such limit is advertised. The
+ * driver is allowed to advertise a theoretical limit that it can reach in
+ * some cases, but may not always reach.
+ *
+ * @max_num_csa_counters: Number of supported csa_counters in beacons
+ * and probe responses.  This value should be set if the driver
+ * wishes to limit the number of csa counters. Default (0) means
+ * infinite.
+ * @max_adj_channel_rssi_comp: max offset of between the channel on which the
+ * frame was sent and the channel on which the frame was heard for which
+ * the reported rssi is still valid. If a driver is able to compensate the
+ * low rssi when a frame is heard on different channel, then it should set
+ * this variable to the maximal offset for which it can compensate.
+ * This value should be set in MHz.
  */
 struct wiphy {
  /* assign these fields before you register the wiphy */
@@ -2596,7 +2990,7 @@ struct wiphy {
 
  u16 max_acl_mac_addrs;
 
- u32 flags, features;
+ u32 flags, regulatory_flags, features;
 
  u32 ap_sme_capa;
 
@@ -2622,7 +3016,8 @@ struct wiphy {
  u32 hw_version;
 
 #ifdef CONFIG_PM
- struct wiphy_wowlan_support wowlan;
+ const struct wiphy_wowlan_support *wowlan;
+ struct cfg80211_wowlan *wowlan_config;
 #endif
 
  u16 max_remain_on_channel_duration;
@@ -2681,6 +3076,17 @@ struct wiphy {
  const struct iw_handler_def *wext;
 #endif
 
+ const struct wiphy_coalesce_support *coalesce;
+
+ const struct wiphy_vendor_command *vendor_commands;
+ const struct nl80211_vendor_cmd_info *vendor_events;
+ int n_vendor_commands, n_vendor_events;
+
+ u16 max_ap_assoc_sta;
+
+ u8 max_num_csa_counters;
+ u8 max_adj_channel_rssi_comp;
+
  char priv[0] __aligned(NETDEV_ALIGN);
 };
 
@@ -2772,7 +3178,7 @@ struct wiphy *wiphy_new(const struct cfg80211_ops *ops, int sizeof_priv);
  *
  * Return: A non-negative wiphy index or a negative error code.
  */
-extern int wiphy_register(struct wiphy *wiphy);
+int wiphy_register(struct wiphy *wiphy);
 
 /**
  * wiphy_unregister - deregister a wiphy from cfg80211
@@ -2783,14 +3189,14 @@ extern int wiphy_register(struct wiphy *wiphy);
  * pointer, but the call may sleep to wait for an outstanding
  * request that is being handled.
  */
-extern void wiphy_unregister(struct wiphy *wiphy);
+void wiphy_unregister(struct wiphy *wiphy);
 
 /**
  * wiphy_free - free wiphy
  *
  * @wiphy: The wiphy to free
  */
-extern void wiphy_free(struct wiphy *wiphy);
+void wiphy_free(struct wiphy *wiphy);
 
 /* internal structs */
 struct cfg80211_conn;
@@ -2818,9 +3224,9 @@ struct cfg80211_cached_keys;
  * @identifier: (private) Identifier used in nl80211 to identify this
  * wireless device if it has no netdev
  * @current_bss: (private) Used by the internal configuration code
- * @channel: (private) Used by the internal configuration code to track
- * the user-set AP, monitor and WDS channel
- * @preset_chan: (private) Used by the internal configuration code to
+ * @chandef: (private) Used by the internal configuration code to track
+ * the user-set channel definition.
+ * @preset_chandef: (private) Used by the internal configuration code to
  * track the channel to be used for AP later
  * @bssid: (private) Used by the internal configuration code
  * @ssid: (private) Used by the internal configuration code
@@ -2834,14 +3240,26 @@ struct cfg80211_cached_keys;
  * by cfg80211 on change_interface
  * @mgmt_registrations: list of registrations for management frames
  * @mgmt_registrations_lock: lock for the list
- * @mtx: mutex used to lock data in this struct
- * @cleanup_work: work struct used for cleanup that can't be done directly
+ * @mtx: mutex used to lock data in this struct, may be used by drivers
+ * and some API functions require it held
  * @beacon_interval: beacon interval used on this device for transmitting
  * beacons, 0 when not valid
  * @address: The address for this device, valid only if @netdev is %NULL
  * @p2p_started: true if this is a P2P Device that has been started
  * @cac_started: true if DFS channel availability check has been started
  * @cac_start_time: timestamp (jiffies) when the dfs state was entered.
+ * @cac_time_ms: CAC time in ms
+ * @ps: powersave mode is enabled
+ * @ps_timeout: dynamic powersave timeout
+ * @ap_unexpected_nlportid: (private) netlink port ID of application
+ * registered for unexpected class 3 frames (AP mode)
+ * @conn: (private) cfg80211 software SME connection state machine data
+ * @connect_keys: (private) keys to set after connection is established
+ * @ibss_fixed: (private) IBSS is using fixed BSSID
+ * @ibss_dfs_possible: (private) IBSS may change to a DFS channel
+ * @event_list: (private) list for internal event processing
+ * @event_lock: (private) lock for event list
+ * @owner_nlportid: (private) owner socket port ID
  */
 struct wireless_dev {
  struct wiphy *wiphy;
@@ -2858,8 +3276,6 @@ struct wireless_dev {
 
  struct mutex mtx;
 
- struct work_struct cleanup_work;
-
  bool use_4addr, p2p_started;
 
  u8 address[ETH_ALEN] __aligned(sizeof(u16));
@@ -2867,11 +3283,6 @@ struct wireless_dev {
  /* currently used for IBSS and SME - might be rearranged later */
  u8 ssid[IEEE80211_MAX_SSID_LEN];
  u8 ssid_len, mesh_id_len, mesh_id_up_len;
- enum {
-  CFG80211_SME_IDLE,
-  CFG80211_SME_CONNECTING,
-  CFG80211_SME_CONNECTED,
- } sme_state;
  struct cfg80211_conn *conn;
  struct cfg80211_cached_keys *connect_keys;
 
@@ -2880,11 +3291,10 @@ struct wireless_dev {
 
  struct cfg80211_internal_bss *current_bss; /* associated / joined */
  struct cfg80211_chan_def preset_chandef;
-
- /* for AP and mesh channel tracking */
- struct ieee80211_channel *channel;
+ struct cfg80211_chan_def chandef;
 
  bool ibss_fixed;
+ bool ibss_dfs_possible;
 
  bool ps;
  int ps_timeout;
@@ -2895,6 +3305,9 @@ struct wireless_dev {
 
  bool cac_started;
  unsigned long cac_start_time;
+ unsigned int cac_time_ms;
+
+ u32 owner_nlportid;
 
 #ifdef CONFIG_CFG80211_WEXT
  /* wext data */
@@ -2902,7 +3315,7 @@ struct wireless_dev {
   struct cfg80211_ibss_params ibss;
   struct cfg80211_connect_params connect;
   struct cfg80211_cached_keys *keys;
-  u8 *ie;
+  const u8 *ie;
   size_t ie_len;
   u8 bssid[ETH_ALEN], prev_bssid[ETH_ALEN];
   u8 ssid[IEEE80211_MAX_SSID_LEN];
@@ -2943,14 +3356,14 @@ static inline void *wdev_priv(struct wireless_dev *wdev)
  * @band: band, necessary due to channel number overlap
  * Return: The corresponding frequency (in MHz), or 0 if the conversion failed.
  */
-extern int ieee80211_channel_to_frequency(int chan, enum ieee80211_band band);
+int ieee80211_channel_to_frequency(int chan, enum ieee80211_band band);
 
 /**
  * ieee80211_frequency_to_channel - convert frequency to channel number
  * @freq: center frequency
  * Return: The corresponding channel, or 0 if the conversion failed.
  */
-extern int ieee80211_frequency_to_channel(int freq);
+int ieee80211_frequency_to_channel(int freq);
 
 /*
  * Name indirection necessary because the ieee80211 code also has
@@ -2959,8 +3372,8 @@ extern int ieee80211_frequency_to_channel(int freq);
  * to include both header files you'll (rightfully!) get a symbol
  * clash.
  */
-extern struct ieee80211_channel *__ieee80211_get_channel(struct wiphy *wiphy,
-        int freq);
+struct ieee80211_channel *__ieee80211_get_channel(struct wiphy *wiphy,
+        int freq);
 /**
  * ieee80211_get_channel - get channel struct from wiphy for specified frequency
  * @wiphy: the struct wiphy to get the channel for
@@ -2989,6 +3402,17 @@ struct ieee80211_rate *
 ieee80211_get_response_rate(struct ieee80211_supported_band *sband,
        u32 basic_rates, int bitrate);
 
+/**
+ * ieee80211_mandatory_rates - get mandatory rates for a given band
+ * @sband: the band to look for rates in
+ * @scan_width: width of the control channel
+ *
+ * This function returns a bitmap of the mandatory rates for the given
+ * band, bits are set according to the rate position in the bitrates array.
+ */
+u32 ieee80211_mandatory_rates(struct ieee80211_supported_band *sband,
+         enum nl80211_bss_scan_width scan_width);
+
 /*
  * Radiotap parsing functions -- for controlled injection support
  *
@@ -3061,13 +3485,14 @@ struct ieee80211_radiotap_iterator {
  int _reset_on_ext;
 };
 
-extern int ieee80211_radiotap_iterator_init(
- struct ieee80211_radiotap_iterator *iterator,
- struct ieee80211_radiotap_header *radiotap_header,
- int max_length, const struct ieee80211_radiotap_vendor_namespaces *vns);
+int
+ieee80211_radiotap_iterator_init(struct ieee80211_radiotap_iterator *iterator,
+     struct ieee80211_radiotap_header *radiotap_header,
+     int max_length,
+     const struct ieee80211_radiotap_vendor_namespaces *vns);
 
-extern int ieee80211_radiotap_iterator_next(
- struct ieee80211_radiotap_iterator *iterator);
+int
+ieee80211_radiotap_iterator_next(struct ieee80211_radiotap_iterator *iterator);
 
 
 extern const unsigned char rfc1042_header[6];
@@ -3131,7 +3556,8 @@ int ieee80211_data_to_8023(struct sk_buff *skb, const u8 *addr,
  * Return: 0 on success, or a negative error code.
  */
 int ieee80211_data_from_8023(struct sk_buff *skb, const u8 *addr,
-        enum nl80211_iftype iftype, u8 *bssid, bool qos);
+        enum nl80211_iftype iftype, const u8 *bssid,
+        bool qos);
 
 /**
  * ieee80211_amsdu_to_8023s - decode an IEEE 802.11n A-MSDU frame
@@ -3156,9 +3582,11 @@ void ieee80211_amsdu_to_8023s(struct sk_buff *skb, struct sk_buff_head *list,
 /**
  * cfg80211_classify8021d - determine the 802.1p/1d tag for a data frame
  * @skb: the data frame
+ * @qos_map: Interworking QoS mapping or %NULL if not in use
  * Return: The 802.1p/1d tag.
  */
-unsigned int cfg80211_classify8021d(struct sk_buff *skb);
+unsigned int cfg80211_classify8021d(struct sk_buff *skb,
+        struct cfg80211_qos_map *qos_map);
 
 /**
  * cfg80211_find_ie - find information element in data
@@ -3227,7 +3655,7 @@ const u8 *cfg80211_find_vendor_ie(unsigned int oui, u8 oui_type,
  *
  * Return: 0 on success. -ENOMEM.
  */
-extern int regulatory_hint(struct wiphy *wiphy, const char *alpha2);
+int regulatory_hint(struct wiphy *wiphy, const char *alpha2);
 
 /**
  * wiphy_apply_custom_regulatory - apply a custom driver regulatory domain
@@ -3240,10 +3668,12 @@ extern int regulatory_hint(struct wiphy *wiphy, const char *alpha2);
  * custom regulatory domain will be trusted completely and as such previous
  * default channel settings will be disregarded. If no rule is found for a
  * channel on the regulatory domain the channel will be disabled.
+ * Drivers using this for a wiphy should also set the wiphy flag
+ * REGULATORY_CUSTOM_REG or cfg80211 will set it for the wiphy
+ * that called this helper.
  */
-extern void wiphy_apply_custom_regulatory(
- struct wiphy *wiphy,
- const struct ieee80211_regdomain *regd);
+void wiphy_apply_custom_regulatory(struct wiphy *wiphy,
+       const struct ieee80211_regdomain *regd);
 
 /**
  * freq_reg_info - get regulatory information for the given frequency
@@ -3266,6 +3696,15 @@ extern void wiphy_apply_custom_regulatory(
 const struct ieee80211_reg_rule *freq_reg_info(struct wiphy *wiphy,
             u32 center_freq);
 
+/**
+ * reg_initiator_name - map regulatory request initiator enum to name
+ * @initiator: the regulatory request initiator
+ *
+ * You can use this to map the regulatory request initiator enum to a
+ * proper string representation.
+ */
+const char *reg_initiator_name(enum nl80211_reg_initiator initiator);
+
 /*
  * callbacks for asynchronous cfg80211 methods, notification
  * functions and BSS handling helpers
@@ -3299,10 +3738,23 @@ void cfg80211_sched_scan_results(struct wiphy *wiphy);
 void cfg80211_sched_scan_stopped(struct wiphy *wiphy);
 
 /**
- * cfg80211_inform_bss_frame - inform cfg80211 of a received BSS frame
+ * cfg80211_sched_scan_stopped_rtnl - notify that the scheduled scan has stopped
+ *
+ * @wiphy: the wiphy on which the scheduled scan stopped
+ *
+ * The driver can call this function to inform cfg80211 that the
+ * scheduled scan had to be stopped, for whatever reason.  The driver
+ * is then called back via the sched_scan_stop operation when done.
+ * This function should be called with rtnl locked.
+ */
+void cfg80211_sched_scan_stopped_rtnl(struct wiphy *wiphy);
+
+/**
+ * cfg80211_inform_bss_width_frame - inform cfg80211 of a received BSS frame
  *
  * @wiphy: the wiphy reporting the BSS
- * @channel: The channel the frame was received on
+ * @rx_channel: The channel the frame was received on
+ * @scan_width: width of the control channel
  * @mgmt: the management frame (probe response or beacon)
  * @len: length of the management frame
  * @signal: the signal strength, type depends on the wiphy's signal_type
@@ -3315,16 +3767,29 @@ void cfg80211_sched_scan_stopped(struct wiphy *wiphy);
  * Or %NULL on error.
  */
 struct cfg80211_bss * __must_check
+cfg80211_inform_bss_width_frame(struct wiphy *wiphy,
+    struct ieee80211_channel *rx_channel,
+    enum nl80211_bss_scan_width scan_width,
+    struct ieee80211_mgmt *mgmt, size_t len,
+    s32 signal, gfp_t gfp);
+
+static inline struct cfg80211_bss * __must_check
 cfg80211_inform_bss_frame(struct wiphy *wiphy,
-     struct ieee80211_channel *channel,
+     struct ieee80211_channel *rx_channel,
      struct ieee80211_mgmt *mgmt, size_t len,
-     s32 signal, gfp_t gfp);
+     s32 signal, gfp_t gfp)
+{
+ return cfg80211_inform_bss_width_frame(wiphy, rx_channel,
+            NL80211_BSS_CHAN_WIDTH_20,
+            mgmt, len, signal, gfp);
+}
 
 /**
  * cfg80211_inform_bss - inform cfg80211 of a new BSS
  *
  * @wiphy: the wiphy reporting the BSS
- * @channel: The channel the frame was received on
+ * @rx_channel: The channel the frame was received on
+ * @scan_width: width of the control channel
  * @bssid: the BSSID of the BSS
  * @tsf: the TSF sent by the peer in the beacon/probe response (or 0)
  * @capability: the capability field sent by the peer
@@ -3341,11 +3806,26 @@ cfg80211_inform_bss_frame(struct wiphy *wiphy,
  * Or %NULL on error.
  */
 struct cfg80211_bss * __must_check
+cfg80211_inform_bss_width(struct wiphy *wiphy,
+     struct ieee80211_channel *rx_channel,
+     enum nl80211_bss_scan_width scan_width,
+     const u8 *bssid, u64 tsf, u16 capability,
+     u16 beacon_interval, const u8 *ie, size_t ielen,
+     s32 signal, gfp_t gfp);
+
+static inline struct cfg80211_bss * __must_check
 cfg80211_inform_bss(struct wiphy *wiphy,
-      struct ieee80211_channel *channel,
+      struct ieee80211_channel *rx_channel,
       const u8 *bssid, u64 tsf, u16 capability,
       u16 beacon_interval, const u8 *ie, size_t ielen,
-      s32 signal, gfp_t gfp);
+      s32 signal, gfp_t gfp)
+{
+ return cfg80211_inform_bss_width(wiphy, rx_channel,
+      NL80211_BSS_CHAN_WIDTH_20,
+      bssid, tsf, capability,
+      beacon_interval, ie, ielen, signal,
+      gfp);
+}
 
 struct cfg80211_bss *cfg80211_get_bss(struct wiphy *wiphy,
           struct ieee80211_channel *channel,
@@ -3391,123 +3871,101 @@ void cfg80211_put_bss(struct wiphy *wiphy, struct cfg80211_bss *bss);
  */
 void cfg80211_unlink_bss(struct wiphy *wiphy, struct cfg80211_bss *bss);
 
+static inline enum nl80211_bss_scan_width
+cfg80211_chandef_to_scan_width(const struct cfg80211_chan_def *chandef)
+{
+ switch (chandef->width) {
+ case NL80211_CHAN_WIDTH_5:
+  return NL80211_BSS_CHAN_WIDTH_5;
+ case NL80211_CHAN_WIDTH_10:
+  return NL80211_BSS_CHAN_WIDTH_10;
+ default:
+  return NL80211_BSS_CHAN_WIDTH_20;
+ }
+}
+
 /**
- * cfg80211_send_rx_auth - notification of processed authentication
+ * cfg80211_rx_mlme_mgmt - notification of processed MLME management frame
  * @dev: network device
  * @buf: authentication frame (header + body)
  * @len: length of the frame data
  *
- * This function is called whenever an authentication has been processed in
- * station mode. The driver is required to call either this function or
- * cfg80211_send_auth_timeout() to indicate the result of cfg80211_ops::auth()
- * call. This function may sleep.
+ * This function is called whenever an authentication, disassociation or
+ * deauthentication frame has been received and processed in station mode.
+ * After being asked to authenticate via cfg80211_ops::auth() the driver must
+ * call either this function or cfg80211_auth_timeout().
+ * After being asked to associate via cfg80211_ops::assoc() the driver must
+ * call either this function or cfg80211_auth_timeout().
+ * While connected, the driver must calls this for received and processed
+ * disassociation and deauthentication frames. If the frame couldn't be used
+ * because it was unprotected, the driver must call the function
+ * cfg80211_rx_unprot_mlme_mgmt() instead.
+ *
+ * This function may sleep. The caller must hold the corresponding wdev's mutex.
  */
-void cfg80211_send_rx_auth(struct net_device *dev, const u8 *buf, size_t len);
+void cfg80211_rx_mlme_mgmt(struct net_device *dev, const u8 *buf, size_t len);
 
 /**
- * cfg80211_send_auth_timeout - notification of timed out authentication
+ * cfg80211_auth_timeout - notification of timed out authentication
  * @dev: network device
  * @addr: The MAC address of the device with which the authentication timed out
  *
- * This function may sleep.
+ * This function may sleep. The caller must hold the corresponding wdev's
+ * mutex.
  */
-void cfg80211_send_auth_timeout(struct net_device *dev, const u8 *addr);
+void cfg80211_auth_timeout(struct net_device *dev, const u8 *addr);
 
 /**
- * cfg80211_send_rx_assoc - notification of processed association
+ * cfg80211_rx_assoc_resp - notification of processed association response
  * @dev: network device
- * @bss: the BSS struct association was requested for, the struct reference
- * is owned by cfg80211 after this call
- * @buf: (re)association response frame (header + body)
+ * @bss: the BSS that association was requested with, ownership of the pointer
+ * moves to cfg80211 in this call
+ * @buf: authentication frame (header + body)
  * @len: length of the frame data
  *
- * This function is called whenever a (re)association response has been
- * processed in station mode. The driver is required to call either this
- * function or cfg80211_send_assoc_timeout() to indicate the result of
- * cfg80211_ops::assoc() call. This function may sleep.
+ * After being asked to associate via cfg80211_ops::assoc() the driver must
+ * call either this function or cfg80211_auth_timeout().
+ *
+ * This function may sleep. The caller must hold the corresponding wdev's mutex.
  */
-void cfg80211_send_rx_assoc(struct net_device *dev, struct cfg80211_bss *bss,
+void cfg80211_rx_assoc_resp(struct net_device *dev,
+       struct cfg80211_bss *bss,
        const u8 *buf, size_t len);
 
 /**
- * cfg80211_send_assoc_timeout - notification of timed out association
+ * cfg80211_assoc_timeout - notification of timed out association
  * @dev: network device
- * @addr: The MAC address of the device with which the association timed out
+ * @bss: The BSS entry with which association timed out.
  *
- * This function may sleep.
+ * This function may sleep. The caller must hold the corresponding wdev's mutex.
  */
-void cfg80211_send_assoc_timeout(struct net_device *dev, const u8 *addr);
+void cfg80211_assoc_timeout(struct net_device *dev, struct cfg80211_bss *bss);
 
 /**
- * cfg80211_send_deauth - notification of processed deauthentication
+ * cfg80211_tx_mlme_mgmt - notification of transmitted deauth/disassoc frame
  * @dev: network device
- * @buf: deauthentication frame (header + body)
+ * @buf: 802.11 frame (header + body)
  * @len: length of the frame data
  *
  * This function is called whenever deauthentication has been processed in
  * station mode. This includes both received deauthentication frames and
- * locally generated ones. This function may sleep.
+ * locally generated ones. This function may sleep. The caller must hold the
+ * corresponding wdev's mutex.
  */
-void cfg80211_send_deauth(struct net_device *dev, const u8 *buf, size_t len);
+void cfg80211_tx_mlme_mgmt(struct net_device *dev, const u8 *buf, size_t len);
 
 /**
- * __cfg80211_send_deauth - notification of processed deauthentication
+ * cfg80211_rx_unprot_mlme_mgmt - notification of unprotected mlme mgmt frame
  * @dev: network device
  * @buf: deauthentication frame (header + body)
  * @len: length of the frame data
  *
- * Like cfg80211_send_deauth(), but doesn't take the wdev lock.
- */
-void __cfg80211_send_deauth(struct net_device *dev, const u8 *buf, size_t len);
-
-/**
- * cfg80211_send_disassoc - notification of processed disassociation
- * @dev: network device
- * @buf: disassociation response frame (header + body)
- * @len: length of the frame data
- *
- * This function is called whenever disassociation has been processed in
- * station mode. This includes both received disassociation frames and locally
- * generated ones. This function may sleep.
- */
-void cfg80211_send_disassoc(struct net_device *dev, const u8 *buf, size_t len);
-
-/**
- * __cfg80211_send_disassoc - notification of processed disassociation
- * @dev: network device
- * @buf: disassociation response frame (header + body)
- * @len: length of the frame data
- *
- * Like cfg80211_send_disassoc(), but doesn't take the wdev lock.
- */
-void __cfg80211_send_disassoc(struct net_device *dev, const u8 *buf,
- size_t len);
-
-/**
- * cfg80211_send_unprot_deauth - notification of unprotected deauthentication
- * @dev: network device
- * @buf: deauthentication frame (header + body)
- * @len: length of the frame data
- *
- * This function is called whenever a received Deauthentication frame has been
- * dropped in station mode because of MFP being used but the Deauthentication
+ * This function is called whenever a received deauthentication or dissassoc
+ * frame has been dropped in station mode because of MFP being used but the
  * frame was not protected. This function may sleep.
  */
-void cfg80211_send_unprot_deauth(struct net_device *dev, const u8 *buf,
-     size_t len);
-
-/**
- * cfg80211_send_unprot_disassoc - notification of unprotected disassociation
- * @dev: network device
- * @buf: disassociation frame (header + body)
- * @len: length of the frame data
- *
- * This function is called whenever a received Disassociation frame has been
- * dropped in station mode because of MFP being used but the Disassociation
- * frame was not protected. This function may sleep.
- */
-void cfg80211_send_unprot_disassoc(struct net_device *dev, const u8 *buf,
-       size_t len);
+void cfg80211_rx_unprot_mlme_mgmt(struct net_device *dev,
+      const u8 *buf, size_t len);
 
 /**
  * cfg80211_michael_mic_failure - notification of Michael MIC failure (TKIP)
@@ -3531,6 +3989,7 @@ void cfg80211_michael_mic_failure(struct net_device *dev, const u8 *addr,
  *
  * @dev: network device
  * @bssid: the BSSID of the IBSS joined
+ * @channel: the channel of the IBSS joined
  * @gfp: allocation flags
  *
  * This function notifies cfg80211 that the device joined an IBSS or
@@ -3540,7 +3999,8 @@ void cfg80211_michael_mic_failure(struct net_device *dev, const u8 *addr,
  * with the locally generated beacon -- this guarantees that there is
  * always a scan result for this IBSS. cfg80211 will handle the rest.
  */
-void cfg80211_ibss_joined(struct net_device *dev, const u8 *bssid, gfp_t gfp);
+void cfg80211_ibss_joined(struct net_device *dev, const u8 *bssid,
+     struct ieee80211_channel *channel, gfp_t gfp);
 
 /**
  * cfg80211_notify_new_candidate - notify cfg80211 of a new mesh peer candidate
@@ -3591,6 +4051,121 @@ void wiphy_rfkill_start_polling(struct wiphy *wiphy);
  */
 void wiphy_rfkill_stop_polling(struct wiphy *wiphy);
 
+/**
+ * DOC: Vendor commands
+ *
+ * Occasionally, there are special protocol or firmware features that
+ * can't be implemented very openly. For this and similar cases, the
+ * vendor command functionality allows implementing the features with
+ * (typically closed-source) userspace and firmware, using nl80211 as
+ * the configuration mechanism.
+ *
+ * A driver supporting vendor commands must register them as an array
+ * in struct wiphy, with handlers for each one, each command has an
+ * OUI and sub command ID to identify it.
+ *
+ * Note that this feature should not be (ab)used to implement protocol
+ * features that could openly be shared across drivers. In particular,
+ * it must never be required to use vendor commands to implement any
+ * "normal" functionality that higher-level userspace like connection
+ * managers etc. need.
+ */
+
+struct sk_buff *__cfg80211_alloc_reply_skb(struct wiphy *wiphy,
+        enum nl80211_commands cmd,
+        enum nl80211_attrs attr,
+        int approxlen);
+
+struct sk_buff *__cfg80211_alloc_event_skb(struct wiphy *wiphy,
+        enum nl80211_commands cmd,
+        enum nl80211_attrs attr,
+        int vendor_event_idx,
+        int approxlen, gfp_t gfp);
+
+void __cfg80211_send_event_skb(struct sk_buff *skb, gfp_t gfp);
+
+/**
+ * cfg80211_vendor_cmd_alloc_reply_skb - allocate vendor command reply
+ * @wiphy: the wiphy
+ * @approxlen: an upper bound of the length of the data that will
+ * be put into the skb
+ *
+ * This function allocates and pre-fills an skb for a reply to
+ * a vendor command. Since it is intended for a reply, calling
+ * it outside of a vendor command's doit() operation is invalid.
+ *
+ * The returned skb is pre-filled with some identifying data in
+ * a way that any data that is put into the skb (with skb_put(),
+ * nla_put() or similar) will end up being within the
+ * %NL80211_ATTR_VENDOR_DATA attribute, so all that needs to be done
+ * with the skb is adding data for the corresponding userspace tool
+ * which can then read that data out of the vendor data attribute.
+ * You must not modify the skb in any other way.
+ *
+ * When done, call cfg80211_vendor_cmd_reply() with the skb and return
+ * its error code as the result of the doit() operation.
+ *
+ * Return: An allocated and pre-filled skb. %NULL if any errors happen.
+ */
+static inline struct sk_buff *
+cfg80211_vendor_cmd_alloc_reply_skb(struct wiphy *wiphy, int approxlen)
+{
+ return __cfg80211_alloc_reply_skb(wiphy, NL80211_CMD_VENDOR,
+       NL80211_ATTR_VENDOR_DATA, approxlen);
+}
+
+/**
+ * cfg80211_vendor_cmd_reply - send the reply skb
+ * @skb: The skb, must have been allocated with
+ * cfg80211_vendor_cmd_alloc_reply_skb()
+ *
+ * Since calling this function will usually be the last thing
+ * before returning from the vendor command doit() you should
+ * return the error code.  Note that this function consumes the
+ * skb regardless of the return value.
+ *
+ * Return: An error code or 0 on success.
+ */
+int cfg80211_vendor_cmd_reply(struct sk_buff *skb);
+
+/**
+ * cfg80211_vendor_event_alloc - allocate vendor-specific event skb
+ * @wiphy: the wiphy
+ * @event_idx: index of the vendor event in the wiphy's vendor_events
+ * @approxlen: an upper bound of the length of the data that will
+ * be put into the skb
+ * @gfp: allocation flags
+ *
+ * This function allocates and pre-fills an skb for an event on the
+ * vendor-specific multicast group.
+ *
+ * When done filling the skb, call cfg80211_vendor_event() with the
+ * skb to send the event.
+ *
+ * Return: An allocated and pre-filled skb. %NULL if any errors happen.
+ */
+static inline struct sk_buff *
+cfg80211_vendor_event_alloc(struct wiphy *wiphy, int approxlen,
+       int event_idx, gfp_t gfp)
+{
+ return __cfg80211_alloc_event_skb(wiphy, NL80211_CMD_VENDOR,
+       NL80211_ATTR_VENDOR_DATA,
+       event_idx, approxlen, gfp);
+}
+
+/**
+ * cfg80211_vendor_event - send the event
+ * @skb: The skb, must have been allocated with cfg80211_vendor_event_alloc()
+ * @gfp: allocation flags
+ *
+ * This function sends the given @skb, which must have been allocated
+ * by cfg80211_vendor_event_alloc(), as an event. It always consumes it.
+ */
+static inline void cfg80211_vendor_event(struct sk_buff *skb, gfp_t gfp)
+{
+ __cfg80211_send_event_skb(skb, gfp);
+}
+
 #ifdef CONFIG_NL80211_TESTMODE
 /**
  * DOC: Test mode
@@ -3626,8 +4201,12 @@ void wiphy_rfkill_stop_polling(struct wiphy *wiphy);
  *
  * Return: An allocated and pre-filled skb. %NULL if any errors happen.
  */
-struct sk_buff *cfg80211_testmode_alloc_reply_skb(struct wiphy *wiphy,
-        int approxlen);
+static inline struct sk_buff *
+cfg80211_testmode_alloc_reply_skb(struct wiphy *wiphy, int approxlen)
+{
+ return __cfg80211_alloc_reply_skb(wiphy, NL80211_CMD_TESTMODE,
+       NL80211_ATTR_TESTDATA, approxlen);
+}
 
 /**
  * cfg80211_testmode_reply - send the reply skb
@@ -3641,7 +4220,10 @@ struct sk_buff *cfg80211_testmode_alloc_reply_skb(struct wiphy *wiphy,
  *
  * Return: An error code or 0 on success.
  */
-int cfg80211_testmode_reply(struct sk_buff *skb);
+static inline int cfg80211_testmode_reply(struct sk_buff *skb)
+{
+ return cfg80211_vendor_cmd_reply(skb);
+}
 
 /**
  * cfg80211_testmode_alloc_event_skb - allocate testmode event
@@ -3664,8 +4246,13 @@ int cfg80211_testmode_reply(struct sk_buff *skb);
  *
  * Return: An allocated and pre-filled skb. %NULL if any errors happen.
  */
-struct sk_buff *cfg80211_testmode_alloc_event_skb(struct wiphy *wiphy,
-        int approxlen, gfp_t gfp);
+static inline struct sk_buff *
+cfg80211_testmode_alloc_event_skb(struct wiphy *wiphy, int approxlen, gfp_t gfp)
+{
+ return __cfg80211_alloc_event_skb(wiphy, NL80211_CMD_TESTMODE,
+       NL80211_ATTR_TESTDATA, -1,
+       approxlen, gfp);
+}
 
 /**
  * cfg80211_testmode_event - send the event
@@ -3677,7 +4264,10 @@ struct sk_buff *cfg80211_testmode_alloc_event_skb(struct wiphy *wiphy,
  * by cfg80211_testmode_alloc_event_skb(), as an event. It always
  * consumes it.
  */
-void cfg80211_testmode_event(struct sk_buff *skb, gfp_t gfp);
+static inline void cfg80211_testmode_event(struct sk_buff *skb, gfp_t gfp)
+{
+ __cfg80211_send_event_skb(skb, gfp);
+}
 
 #define CFG80211_TESTMODE_CMD(cmd) .testmode_cmd = (cmd),
 #define CFG80211_TESTMODE_DUMP(cmd) .testmode_dump = (cmd),
@@ -3768,7 +4358,7 @@ void cfg80211_roamed_bss(struct net_device *dev, struct cfg80211_bss *bss,
  * and not try to connect to any AP any more.
  */
 void cfg80211_disconnected(struct net_device *dev, u16 reason,
-      u8 *ie, size_t ie_len, gfp_t gfp);
+      const u8 *ie, size_t ie_len, gfp_t gfp);
 
 /**
  * cfg80211_ready_on_channel - notification of remain_on_channel start
@@ -3841,6 +4431,7 @@ void cfg80211_conn_failed(struct net_device *dev, const u8 *mac_addr,
  * @sig_dbm: signal strength in mBm, or 0 if unknown
  * @buf: Management frame (header + body)
  * @len: length of the frame data
+ * @flags: flags, as defined in enum nl80211_rxmgmt_flags
  * @gfp: context flags
  *
  * This function is called whenever an Action frame is received for a station
@@ -3852,7 +4443,7 @@ void cfg80211_conn_failed(struct net_device *dev, const u8 *mac_addr,
  * driver is responsible for rejecting the frame.
  */
 bool cfg80211_rx_mgmt(struct wireless_dev *wdev, int freq, int sig_dbm,
-        const u8 *buf, size_t len, gfp_t gfp);
+        const u8 *buf, size_t len, u32 flags, gfp_t gfp);
 
 /**
  * cfg80211_mgmt_tx_status - notification of TX status for management frame
@@ -3898,6 +4489,7 @@ void cfg80211_radar_event(struct wiphy *wiphy,
 /**
  * cfg80211_cac_event - Channel availability check (CAC) event
  * @netdev: network device
+ * @chandef: chandef for the current channel
  * @event: type of event
  * @gfp: context flags
  *
@@ -3906,6 +4498,7 @@ void cfg80211_radar_event(struct wiphy *wiphy,
  * also by full-MAC drivers.
  */
 void cfg80211_cac_event(struct net_device *netdev,
+   const struct cfg80211_chan_def *chandef,
    enum nl80211_radar_event event, gfp_t gfp);
 
 
@@ -4019,19 +4612,22 @@ void cfg80211_report_obss_beacon(struct wiphy *wiphy,
  * cfg80211_reg_can_beacon - check if beaconing is allowed
  * @wiphy: the wiphy
  * @chandef: the channel definition
+ * @iftype: interface type
  *
  * Return: %true if there is no secondary channel or the secondary channel(s)
  * can be used for beaconing (i.e. is not a radar channel etc.)
  */
 bool cfg80211_reg_can_beacon(struct wiphy *wiphy,
-        struct cfg80211_chan_def *chandef);
+        struct cfg80211_chan_def *chandef,
+        enum nl80211_iftype iftype);
 
 /*
  * cfg80211_ch_switch_notify - update wdev channel and notify userspace
  * @dev: the device which switched channels
  * @chandef: the new channel definition
  *
- * Acquires wdev_lock, so must only be called from sleepable driver context!
+ * Caller must acquire wdev_lock, therefore must only be called from sleepable
+ * driver context!
  */
 void cfg80211_ch_switch_notify(struct net_device *dev,
           struct cfg80211_chan_def *chandef);
@@ -4153,6 +4749,7 @@ void cfg80211_report_wowlan_wakeup(struct wireless_dev *wdev,
  * cfg80211_crit_proto_stopped() - indicate critical protocol stopped by driver.
  *
  * @wdev: the wireless device for which critical protocol is stopped.
+ * @gfp: allocation flags
  *
  * This function can be called by the driver to indicate it has reverted
  * operation back to normal. One reason could be that the duration given
@@ -4160,6 +4757,92 @@ void cfg80211_report_wowlan_wakeup(struct wireless_dev *wdev,
  */
 void cfg80211_crit_proto_stopped(struct wireless_dev *wdev, gfp_t gfp);
 
+/**
+ * ieee80211_get_num_supported_channels - get number of channels device has
+ * @wiphy: the wiphy
+ *
+ * Return: the number of channels supported by the device.
+ */
+unsigned int ieee80211_get_num_supported_channels(struct wiphy *wiphy);
+
+/**
+ * cfg80211_check_combinations - check interface combinations
+ *
+ * @wiphy: the wiphy
+ * @num_different_channels: the number of different channels we want
+ * to use for verification
+ * @radar_detect: a bitmap where each bit corresponds to a channel
+ * width where radar detection is needed, as in the definition of
+ * &struct ieee80211_iface_combination.@radar_detect_widths
+ * @iftype_num: array with the numbers of interfaces of each interface
+ * type.  The index is the interface type as specified in &enum
+ * nl80211_iftype.
+ *
+ * This function can be called by the driver to check whether a
+ * combination of interfaces and their types are allowed according to
+ * the interface combinations.
+ */
+int cfg80211_check_combinations(struct wiphy *wiphy,
+    const int num_different_channels,
+    const u8 radar_detect,
+    const int iftype_num[NUM_NL80211_IFTYPES]);
+
+/**
+ * cfg80211_iter_combinations - iterate over matching combinations
+ *
+ * @wiphy: the wiphy
+ * @num_different_channels: the number of different channels we want
+ * to use for verification
+ * @radar_detect: a bitmap where each bit corresponds to a channel
+ * width where radar detection is needed, as in the definition of
+ * &struct ieee80211_iface_combination.@radar_detect_widths
+ * @iftype_num: array with the numbers of interfaces of each interface
+ * type.  The index is the interface type as specified in &enum
+ * nl80211_iftype.
+ * @iter: function to call for each matching combination
+ * @data: pointer to pass to iter function
+ *
+ * This function can be called by the driver to check what possible
+ * combinations it fits in at a given moment, e.g. for channel switching
+ * purposes.
+ */
+int cfg80211_iter_combinations(struct wiphy *wiphy,
+          const int num_different_channels,
+          const u8 radar_detect,
+          const int iftype_num[NUM_NL80211_IFTYPES],
+          void (*iter)(const struct ieee80211_iface_combination *c,
+         void *data),
+          void *data);
+
+/*
+ * cfg80211_stop_iface - trigger interface disconnection
+ *
+ * @wiphy: the wiphy
+ * @wdev: wireless device
+ * @gfp: context flags
+ *
+ * Trigger interface to be stopped as if AP was stopped, IBSS/mesh left, STA
+ * disconnected.
+ *
+ * Note: This doesn't need any locks and is asynchronous.
+ */
+void cfg80211_stop_iface(struct wiphy *wiphy, struct wireless_dev *wdev,
+    gfp_t gfp);
+
+/**
+ * cfg80211_shutdown_all_interfaces - shut down all interfaces for a wiphy
+ * @wiphy: the wiphy to shut down
+ *
+ * This function shuts down all interfaces belonging to this wiphy by
+ * calling dev_close() (and treating non-netdev interfaces as needed).
+ * It shouldn't really be used unless there are some fatal device errors
+ * that really can't be recovered in any other way.
+ *
+ * Callers must hold the RTNL and be able to deal with callbacks into
+ * the driver while the function is running.
+ */
+void cfg80211_shutdown_all_interfaces(struct wiphy *wiphy);
+
 /* Logging, debugging and troubleshooting/diagnostic helpers. */
 
 /* wiphy_printk helpers, similar to dev_printk */
diff --git a/include/net/ieee80211_radiotap.h b/include/net/ieee80211_radiotap.h
index c399963..b0fd947 100644
--- a/include/net/ieee80211_radiotap.h
+++ b/include/net/ieee80211_radiotap.h
@@ -230,6 +230,10 @@ enum ieee80211_radiotap_type {
 #define IEEE80211_CHAN_PASSIVE 0x0200 /* Only passive scan allowed */
 #define IEEE80211_CHAN_DYN 0x0400 /* Dynamic CCK-OFDM channel */
 #define IEEE80211_CHAN_GFSK 0x0800 /* GFSK channel (FHSS PHY) */
+#define IEEE80211_CHAN_GSM 0x1000 /* GSM (900 MHz) */
+#define IEEE80211_CHAN_STURBO 0x2000 /* Static Turbo */
+#define IEEE80211_CHAN_HALF 0x4000 /* Half channel (10 MHz wide) */
+#define IEEE80211_CHAN_QUARTER 0x8000 /* Quarter channel (5 MHz wide) */
 
 /* For IEEE80211_RADIOTAP_FLAGS */
 #define IEEE80211_RADIOTAP_F_CFP 0x01 /* sent/received
@@ -269,6 +273,7 @@ enum ieee80211_radiotap_type {
 #define IEEE80211_RADIOTAP_MCS_HAVE_GI  0x04
 #define IEEE80211_RADIOTAP_MCS_HAVE_FMT  0x08
 #define IEEE80211_RADIOTAP_MCS_HAVE_FEC  0x10
+#define IEEE80211_RADIOTAP_MCS_HAVE_STBC 0x20
 
 #define IEEE80211_RADIOTAP_MCS_BW_MASK  0x03
 #define  IEEE80211_RADIOTAP_MCS_BW_20 0
@@ -278,6 +283,12 @@ enum ieee80211_radiotap_type {
 #define IEEE80211_RADIOTAP_MCS_SGI  0x04
 #define IEEE80211_RADIOTAP_MCS_FMT_GF  0x08
 #define IEEE80211_RADIOTAP_MCS_FEC_LDPC  0x10
+#define IEEE80211_RADIOTAP_MCS_STBC_MASK 0x60
+#define  IEEE80211_RADIOTAP_MCS_STBC_1 1
+#define  IEEE80211_RADIOTAP_MCS_STBC_2 2
+#define  IEEE80211_RADIOTAP_MCS_STBC_3 3
+
+#define IEEE80211_RADIOTAP_MCS_STBC_SHIFT 5
 
 /* For IEEE80211_RADIOTAP_AMPDU_STATUS */
 #define IEEE80211_RADIOTAP_AMPDU_REPORT_ZEROLEN  0x0001
@@ -305,6 +316,10 @@ enum ieee80211_radiotap_type {
 #define IEEE80211_RADIOTAP_VHT_FLAG_LDPC_EXTRA_OFDM_SYM  0x10
 #define IEEE80211_RADIOTAP_VHT_FLAG_BEAMFORMED   0x20
 
+#define IEEE80211_RADIOTAP_CODING_LDPC_USER0   0x01
+#define IEEE80211_RADIOTAP_CODING_LDPC_USER1   0x02
+#define IEEE80211_RADIOTAP_CODING_LDPC_USER2   0x04
+#define IEEE80211_RADIOTAP_CODING_LDPC_USER3   0x08
 
 /* helpers */
 static inline int ieee80211_get_radiotap_len(unsigned char *data)
diff --git a/include/net/mac80211.h b/include/net/mac80211.h
index 4e50d36..421b6ec 100644
--- a/include/net/mac80211.h
+++ b/include/net/mac80211.h
@@ -66,10 +66,6 @@
  *
  * Secondly, when the hardware handles fragmentation, the frame handed to
  * the driver from mac80211 is the MSDU, not the MPDU.
- *
- * Finally, for received frames, the driver is able to indicate that it has
- * filled a radiotap header and put that in front of the frame; if it does
- * not do so then mac80211 may add this under certain circumstances.
  */
 
 /**
@@ -152,11 +148,16 @@ struct ieee80211_low_level_stats {
  * @IEEE80211_CHANCTX_CHANGE_WIDTH: The channel width changed
  * @IEEE80211_CHANCTX_CHANGE_RX_CHAINS: The number of RX chains changed
  * @IEEE80211_CHANCTX_CHANGE_RADAR: radar detection flag changed
+ * @IEEE80211_CHANCTX_CHANGE_CHANNEL: switched to another operating channel,
+ * this is used only with channel switching with CSA
+ * @IEEE80211_CHANCTX_CHANGE_MIN_WIDTH: The min required channel width changed
  */
 enum ieee80211_chanctx_change {
  IEEE80211_CHANCTX_CHANGE_WIDTH  = BIT(0),
  IEEE80211_CHANCTX_CHANGE_RX_CHAINS = BIT(1),
  IEEE80211_CHANCTX_CHANGE_RADAR  = BIT(2),
+ IEEE80211_CHANCTX_CHANGE_CHANNEL = BIT(3),
+ IEEE80211_CHANCTX_CHANGE_MIN_WIDTH = BIT(4),
 };
 
 /**
@@ -166,6 +167,7 @@ enum ieee80211_chanctx_change {
  * that contains it is visible in mac80211 only.
  *
  * @def: the channel definition
+ * @min_def: the minimum channel definition currently required.
  * @rx_chains_static: The number of RX chains that must always be
  * active on the channel to receive MIMO transmissions
  * @rx_chains_dynamic: The number of RX chains that must be enabled
@@ -177,6 +179,7 @@ enum ieee80211_chanctx_change {
  */
 struct ieee80211_chanctx_conf {
  struct cfg80211_chan_def def;
+ struct cfg80211_chan_def min_def;
 
  u8 rx_chains_static, rx_chains_dynamic;
 
@@ -186,6 +189,43 @@ struct ieee80211_chanctx_conf {
 };
 
 /**
+ * enum ieee80211_chanctx_switch_mode - channel context switch mode
+ * @CHANCTX_SWMODE_REASSIGN_VIF: Both old and new contexts already
+ * exist (and will continue to exist), but the virtual interface
+ * needs to be switched from one to the other.
+ * @CHANCTX_SWMODE_SWAP_CONTEXTS: The old context exists but will stop
+ *      to exist with this call, the new context doesn't exist but
+ *      will be active after this call, the virtual interface switches
+ *      from the old to the new (note that the driver may of course
+ *      implement this as an on-the-fly chandef switch of the existing
+ *      hardware context, but the mac80211 pointer for the old context
+ *      will cease to exist and only the new one will later be used
+ *      for changes/removal.)
+ */
+enum ieee80211_chanctx_switch_mode {
+ CHANCTX_SWMODE_REASSIGN_VIF,
+ CHANCTX_SWMODE_SWAP_CONTEXTS,
+};
+
+/**
+ * struct ieee80211_vif_chanctx_switch - vif chanctx switch information
+ *
+ * This is structure is used to pass information about a vif that
+ * needs to switch from one chanctx to another.  The
+ * &ieee80211_chanctx_switch_mode defines how the switch should be
+ * done.
+ *
+ * @vif: the vif that should be switched from old_ctx to new_ctx
+ * @old_ctx: the old context to which the vif was assigned
+ * @new_ctx: the new context to which the vif must be assigned
+ */
+struct ieee80211_vif_chanctx_switch {
+ struct ieee80211_vif *vif;
+ struct ieee80211_chanctx_conf *old_ctx;
+ struct ieee80211_chanctx_conf *new_ctx;
+};
+
+/**
  * enum ieee80211_bss_change - BSS change notification flags
  *
  * These flags are used with the bss_info_changed() callback
@@ -217,8 +257,8 @@ struct ieee80211_chanctx_conf {
  * @BSS_CHANGED_TXPOWER: TX power setting changed for this interface
  * @BSS_CHANGED_P2P_PS: P2P powersave settings (CTWindow, opportunistic PS)
  * changed (currently only in P2P client mode, GO mode will be later)
- * @BSS_CHANGED_DTIM_PERIOD: the DTIM period value was changed (set when
- * it becomes valid, managed mode only)
+ * @BSS_CHANGED_BEACON_INFO: Data from the AP's beacon became available:
+ * currently dtim_period only is under consideration.
  * @BSS_CHANGED_BANDWIDTH: The bandwidth used by this interface changed,
  * note that this is only called when it changes after the channel
  * context had been assigned.
@@ -244,7 +284,7 @@ enum ieee80211_bss_change {
  BSS_CHANGED_PS   = 1<<17,
  BSS_CHANGED_TXPOWER  = 1<<18,
  BSS_CHANGED_P2P_PS  = 1<<19,
- BSS_CHANGED_DTIM_PERIOD  = 1<<20,
+ BSS_CHANGED_BEACON_INFO  = 1<<20,
  BSS_CHANGED_BANDWIDTH  = 1<<21,
 
  /* when adding here, make sure to change ieee80211_reconfig */
@@ -288,7 +328,7 @@ enum ieee80211_rssi_event {
  * IEEE80211_HW_2GHZ_SHORT_SLOT_INCAPABLE hardware flag
  * @dtim_period: num of beacons before the next DTIM, for beaconing,
  * valid in station mode only if after the driver was notified
- * with the %BSS_CHANGED_DTIM_PERIOD flag, will be non-zero then.
+ * with the %BSS_CHANGED_BEACON_INFO flag, will be non-zero then.
  * @sync_tsf: last beacon's/probe response's TSF timestamp (could be old
  * as it may have been received during scanning long ago). If the
  * HW flag %IEEE80211_HW_TIMING_BEACON_ONLY is set, then this can
@@ -305,6 +345,7 @@ enum ieee80211_rssi_event {
  * @basic_rates: bitmap of basic rates, each bit stands for an
  * index into the rate table configured by the driver in
  * the current band.
+ * @beacon_rate: associated AP's beacon TX rate
  * @mcast_rate: per-band multicast rate index + 1 (0: disabled)
  * @bssid: The BSSID for this BSS
  * @enable_beacon: whether beaconing should be enabled or not
@@ -352,6 +393,7 @@ struct ieee80211_bss_conf {
  u32 sync_device_ts;
  u8 sync_dtim_count;
  u32 basic_rates;
+ struct ieee80211_rate *beacon_rate;
  int mcast_rate[IEEE80211_NUM_BANDS];
  u16 ht_operation_mode;
  s32 cqm_rssi_thold;
@@ -370,7 +412,7 @@ struct ieee80211_bss_conf {
 };
 
 /**
- * enum mac80211_tx_control_flags - flags to describe transmission information/status
+ * enum mac80211_tx_info_flags - flags to describe transmission information/status
  *
  * These flags are used with the @flags member of &ieee80211_tx_info.
  *
@@ -460,11 +502,13 @@ struct ieee80211_bss_conf {
  * @IEEE80211_TX_CTL_DONTFRAG: Don't fragment this packet even if it
  * would be fragmented by size (this is optional, only used for
  * monitor injection).
+ * @IEEE80211_TX_CTL_PS_RESPONSE: This frame is a response to a poll
+ * frame (PS-Poll or uAPSD).
  *
  * Note: If you have to add new flags to the enumeration, then don't
  *  forget to update %IEEE80211_TX_TEMPORARY_FLAGS when necessary.
  */
-enum mac80211_tx_control_flags {
+enum mac80211_tx_info_flags {
  IEEE80211_TX_CTL_REQ_TX_STATUS  = BIT(0),
  IEEE80211_TX_CTL_ASSIGN_SEQ  = BIT(1),
  IEEE80211_TX_CTL_NO_ACK   = BIT(2),
@@ -495,10 +539,23 @@ enum mac80211_tx_control_flags {
  IEEE80211_TX_STATUS_EOSP  = BIT(28),
  IEEE80211_TX_CTL_USE_MINRATE  = BIT(29),
  IEEE80211_TX_CTL_DONTFRAG  = BIT(30),
+ IEEE80211_TX_CTL_PS_RESPONSE  = BIT(31),
 };
 
 #define IEEE80211_TX_CTL_STBC_SHIFT  23
 
+/**
+ * enum mac80211_tx_control_flags - flags to describe transmit control
+ *
+ * @IEEE80211_TX_CTRL_PORT_CTRL_PROTO: this frame is a port control
+ * protocol frame (e.g. EAP)
+ *
+ * These flags are used in tx_info->control.flags.
+ */
+enum mac80211_tx_control_flags {
+ IEEE80211_TX_CTRL_PORT_CTRL_PROTO = BIT(0),
+};
+
 /*
  * This definition is used as a mask to clear all temporary flags, which are
  * set by the tx handlers for each transmission attempt by the mac80211 stack.
@@ -672,15 +729,16 @@ struct ieee80211_tx_info {
    /* NB: vif can be NULL for injected frames */
    struct ieee80211_vif *vif;
    struct ieee80211_key_conf *hw_key;
-   /* 8 bytes free */
+   u32 flags;
+   /* 4 bytes free */
   } control;
   struct {
    struct ieee80211_tx_rate rates[IEEE80211_TX_MAX_RATES];
-   int ack_signal;
+   s32 ack_signal;
    u8 ampdu_ack_len;
    u8 ampdu_len;
    u8 antenna;
-   /* 21 bytes free */
+   void *status_driver_data[21 / sizeof(void *)];
   } status;
   struct {
    struct ieee80211_tx_rate driver_rates[
@@ -783,9 +841,6 @@ ieee80211_tx_info_clear_status(struct ieee80211_tx_info *info)
  * @RX_FLAG_HT: HT MCS was used and rate_idx is MCS index
  * @RX_FLAG_VHT: VHT MCS was used and rate_index is MCS index
  * @RX_FLAG_40MHZ: HT40 (40 MHz) was used
- * @RX_FLAG_80MHZ: 80 MHz was used
- * @RX_FLAG_80P80MHZ: 80+80 MHz was used
- * @RX_FLAG_160MHZ: 160 MHz was used
  * @RX_FLAG_SHORT_GI: Short guard interval was used
  * @RX_FLAG_NO_SIGNAL_VAL: The signal strength value is not present.
  * Valid only for data frames (mainly A-MPDU)
@@ -805,6 +860,19 @@ ieee80211_tx_info_clear_status(struct ieee80211_tx_info *info)
  * on this subframe
  * @RX_FLAG_AMPDU_DELIM_CRC_KNOWN: The delimiter CRC field is known (the CRC
  * is stored in the @ampdu_delimiter_crc field)
+ * @RX_FLAG_LDPC: LDPC was used
+ * @RX_FLAG_STBC_MASK: STBC 2 bit bitmask. 1 - Nss=1, 2 - Nss=2, 3 - Nss=3
+ * @RX_FLAG_10MHZ: 10 MHz (half channel) was used
+ * @RX_FLAG_5MHZ: 5 MHz (quarter channel) was used
+ * @RX_FLAG_AMSDU_MORE: Some drivers may prefer to report separate A-MSDU
+ * subframes instead of a one huge frame for performance reasons.
+ * All, but the last MSDU from an A-MSDU should have this flag set. E.g.
+ * if an A-MSDU has 3 frames, the first 2 must have the flag set, while
+ * the 3rd (last) one must not have this flag set. The flag is used to
+ * deal with retransmission/duplication recovery properly since A-MSDU
+ * subframes share the same sequence number. Reported subframes can be
+ * either regular MSDU or singly A-MSDUs. Subframes must not be
+ * interleaved with other frames.
  */
 enum mac80211_rx_flags {
  RX_FLAG_MMIC_ERROR  = BIT(0),
@@ -829,9 +897,30 @@ enum mac80211_rx_flags {
  RX_FLAG_AMPDU_DELIM_CRC_KNOWN = BIT(20),
  RX_FLAG_MACTIME_END  = BIT(21),
  RX_FLAG_VHT   = BIT(22),
- RX_FLAG_80MHZ   = BIT(23),
- RX_FLAG_80P80MHZ  = BIT(24),
- RX_FLAG_160MHZ   = BIT(25),
+ RX_FLAG_LDPC   = BIT(23),
+ RX_FLAG_STBC_MASK  = BIT(26) | BIT(27),
+ RX_FLAG_10MHZ   = BIT(28),
+ RX_FLAG_5MHZ   = BIT(29),
+ RX_FLAG_AMSDU_MORE  = BIT(30),
+};
+
+#define RX_FLAG_STBC_SHIFT  26
+
+/**
+ * enum mac80211_rx_vht_flags - receive VHT flags
+ *
+ * These flags are used with the @vht_flag member of
+ * &struct ieee80211_rx_status.
+ * @RX_VHT_FLAG_80MHZ: 80 MHz was used
+ * @RX_VHT_FLAG_80P80MHZ: 80+80 MHz was used
+ * @RX_VHT_FLAG_160MHZ: 160 MHz was used
+ * @RX_VHT_FLAG_BF: packet was beamformed
+ */
+enum mac80211_rx_vht_flags {
+ RX_VHT_FLAG_80MHZ  = BIT(0),
+ RX_VHT_FLAG_80P80MHZ  = BIT(1),
+ RX_VHT_FLAG_160MHZ  = BIT(2),
+ RX_VHT_FLAG_BF   = BIT(3),
 };
 
 /**
@@ -850,41 +939,37 @@ enum mac80211_rx_flags {
  * @signal: signal strength when receiving this frame, either in dBm, in dB or
  * unspecified depending on the hardware capabilities flags
  * @IEEE80211_HW_SIGNAL_*
+ * @chains: bitmask of receive chains for which separate signal strength
+ * values were filled.
+ * @chain_signal: per-chain signal strength, in dBm (unlike @signal, doesn't
+ * support dB or unspecified units)
  * @antenna: antenna used
  * @rate_idx: index of data rate into band's supported rates or MCS index if
  * HT or VHT is used (%RX_FLAG_HT/%RX_FLAG_VHT)
  * @vht_nss: number of streams (VHT only)
  * @flag: %RX_FLAG_*
+ * @vht_flag: %RX_VHT_FLAG_*
  * @rx_flags: internal RX flags for mac80211
  * @ampdu_reference: A-MPDU reference number, must be a different value for
  * each A-MPDU but the same for each subframe within one A-MPDU
  * @ampdu_delimiter_crc: A-MPDU delimiter CRC
- * @vendor_radiotap_bitmap: radiotap vendor namespace presence bitmap
- * @vendor_radiotap_len: radiotap vendor namespace length
- * @vendor_radiotap_align: radiotap vendor namespace alignment. Note
- * that the actual data must be at the start of the SKB data
- * already.
- * @vendor_radiotap_oui: radiotap vendor namespace OUI
- * @vendor_radiotap_subns: radiotap vendor sub namespace
  */
 struct ieee80211_rx_status {
  u64 mactime;
  u32 device_timestamp;
  u32 ampdu_reference;
  u32 flag;
- u32 vendor_radiotap_bitmap;
- u16 vendor_radiotap_len;
  u16 freq;
+ u8 vht_flag;
  u8 rate_idx;
  u8 vht_nss;
  u8 rx_flags;
  u8 band;
  u8 antenna;
  s8 signal;
+ u8 chains;
+ s8 chain_signal[IEEE80211_MAX_CHAINS];
  u8 ampdu_delimiter_crc;
- u8 vendor_radiotap_align;
- u8 vendor_radiotap_oui[3];
- u8 vendor_radiotap_subns;
 };
 
 /**
@@ -989,11 +1074,11 @@ enum ieee80211_smps_mode {
  * @radar_enabled: whether radar detection is enabled
  *
  * @long_frame_max_tx_count: Maximum number of transmissions for a "long" frame
- *    (a frame not RTS protected), called "dot11LongRetryLimit" in 802.11,
- *    but actually means the number of transmissions not the number of retries
+ * (a frame not RTS protected), called "dot11LongRetryLimit" in 802.11,
+ * but actually means the number of transmissions not the number of retries
  * @short_frame_max_tx_count: Maximum number of transmissions for a "short"
- *    frame, called "dot11ShortRetryLimit" in 802.11, but actually means the
- *    number of transmissions not the number of retries
+ * frame, called "dot11ShortRetryLimit" in 802.11, but actually means the
+ * number of transmissions not the number of retries
  *
  * @smps_mode: spatial multiplexing powersave mode; note that
  * %IEEE80211_SMPS_STATIC is used when the device is not
@@ -1065,6 +1150,9 @@ enum ieee80211_vif_flags {
  * @addr: address of this interface
  * @p2p: indicates whether this AP or STA interface is a p2p
  * interface, i.e. a GO or p2p-sta respectively
+ * @csa_active: marks whether a channel switch is going on. Internally it is
+ * write-protected by sdata_lock and local->mtx so holding either is fine
+ * for read access.
  * @driver_flags: flags/capabilities the driver has for this interface,
  * these need to be set (or cleared) when the interface is added
  * or, if supported by the driver, the interface type is changed
@@ -1077,7 +1165,7 @@ enum ieee80211_vif_flags {
  * be off when it is %NULL there can still be races and packets could be
  * processed after it switches back to %NULL.
  * @debugfs_dir: debugfs dentry, can be used by drivers to create own per
- *      interface debug files. Note that it will be NULL for the virtual
+ * interface debug files. Note that it will be NULL for the virtual
  * monitor interface (if that is requested.)
  * @drv_priv: data area for driver use, will always be aligned to
  * sizeof(void *).
@@ -1087,6 +1175,7 @@ struct ieee80211_vif {
  struct ieee80211_bss_conf bss_conf;
  u8 addr[ETH_ALEN];
  bool p2p;
+ bool csa_active;
 
  u8 cab_queue;
  u8 hw_queue[IEEE80211_NUM_ACS];
@@ -1112,6 +1201,19 @@ static inline bool ieee80211_vif_is_mesh(struct ieee80211_vif *vif)
 }
 
 /**
+ * wdev_to_ieee80211_vif - return a vif struct from a wdev
+ * @wdev: the wdev to get the vif for
+ *
+ * This can be used by mac80211 drivers with direct cfg80211 APIs
+ * (like the vendor commands) that get a wdev.
+ *
+ * Note that this function may return %NULL if the given wdev isn't
+ * associated with a vif that the driver knows about (e.g. monitor
+ * or AP_VLAN interfaces.)
+ */
+struct ieee80211_vif *wdev_to_ieee80211_vif(struct wireless_dev *wdev);
+
+/**
  * enum ieee80211_key_flags - key flags
  *
  * These flags are used for communication about keys between the driver
@@ -1139,14 +1241,18 @@ static inline bool ieee80211_vif_is_mesh(struct ieee80211_vif *vif)
  * fall back to software crypto. Note that this flag deals only with
  * RX, if your crypto engine can't deal with TX you can also set the
  * %IEEE80211_KEY_FLAG_SW_MGMT_TX flag to encrypt such frames in SW.
+ * @IEEE80211_KEY_FLAG_GENERATE_IV_MGMT: This flag should be set by the
+ * driver for a CCMP key to indicate that is requires IV generation
+ * only for managment frames (MFP).
  */
 enum ieee80211_key_flags {
- IEEE80211_KEY_FLAG_GENERATE_IV = 1<<1,
- IEEE80211_KEY_FLAG_GENERATE_MMIC= 1<<2,
- IEEE80211_KEY_FLAG_PAIRWISE = 1<<3,
- IEEE80211_KEY_FLAG_SW_MGMT_TX = 1<<4,
- IEEE80211_KEY_FLAG_PUT_IV_SPACE = 1<<5,
- IEEE80211_KEY_FLAG_RX_MGMT = 1<<6,
+ IEEE80211_KEY_FLAG_GENERATE_IV_MGMT = BIT(0),
+ IEEE80211_KEY_FLAG_GENERATE_IV  = BIT(1),
+ IEEE80211_KEY_FLAG_GENERATE_MMIC = BIT(2),
+ IEEE80211_KEY_FLAG_PAIRWISE  = BIT(3),
+ IEEE80211_KEY_FLAG_SW_MGMT_TX  = BIT(4),
+ IEEE80211_KEY_FLAG_PUT_IV_SPACE  = BIT(5),
+ IEEE80211_KEY_FLAG_RX_MGMT  = BIT(6),
 };
 
 /**
@@ -1182,6 +1288,36 @@ struct ieee80211_key_conf {
 };
 
 /**
+ * struct ieee80211_cipher_scheme - cipher scheme
+ *
+ * This structure contains a cipher scheme information defining
+ * the secure packet crypto handling.
+ *
+ * @cipher: a cipher suite selector
+ * @iftype: a cipher iftype bit mask indicating an allowed cipher usage
+ * @hdr_len: a length of a security header used the cipher
+ * @pn_len: a length of a packet number in the security header
+ * @pn_off: an offset of pn from the beginning of the security header
+ * @key_idx_off: an offset of key index byte in the security header
+ * @key_idx_mask: a bit mask of key_idx bits
+ * @key_idx_shift: a bit shift needed to get key_idx
+ *     key_idx value calculation:
+ *      (sec_header_base[key_idx_off] & key_idx_mask) >> key_idx_shift
+ * @mic_len: a mic length in bytes
+ */
+struct ieee80211_cipher_scheme {
+ u32 cipher;
+ u16 iftype;
+ u8 hdr_len;
+ u8 pn_len;
+ u8 pn_off;
+ u8 key_idx_off;
+ u8 key_idx_mask;
+ u8 key_idx_shift;
+ u8 mic_len;
+};
+
+/**
  * enum set_key_cmd - key command
  *
  * Used with the set_key() callback in &struct ieee80211_ops, this
@@ -1235,7 +1371,7 @@ enum ieee80211_sta_rx_bandwidth {
  * struct ieee80211_sta_rates - station rate selection table
  *
  * @rcu_head: RCU head used for freeing the table on update
- * @rates: transmit rates/flags to be used by default.
+ * @rate: transmit rates/flags to be used by default.
  * Overriding entries per-packet is possible by using cb tx control.
  */
 struct ieee80211_sta_rates {
@@ -1276,7 +1412,8 @@ struct ieee80211_sta_rates {
  * notifications and capabilities. The value is only valid after
  * the station moves to associated state.
  * @smps_mode: current SMPS mode (off, static or dynamic)
- * @tx_rates: rate control selection table
+ * @rates: rate control selection table
+ * @tdls: indicates whether the STA is a TDLS peer
  */
 struct ieee80211_sta {
  u32 supp_rates[IEEE80211_NUM_BANDS];
@@ -1291,6 +1428,7 @@ struct ieee80211_sta {
  enum ieee80211_sta_rx_bandwidth bandwidth;
  enum ieee80211_smps_mode smps_mode;
  struct ieee80211_sta_rates __rcu *rates;
+ bool tdls;
 
  /* must be last */
  u8 drv_priv[0] __aligned(sizeof(void *));
@@ -1410,10 +1548,8 @@ struct ieee80211_tx_control {
  * the stack.
  *
  * @IEEE80211_HW_CONNECTION_MONITOR:
- *      The hardware performs its own connection monitoring, including
- *      periodic keep-alives to the AP and probing the AP on beacon loss.
- *      When this flag is set, signaling beacon-loss will cause an immediate
- *      change to disassociated state.
+ * The hardware performs its own connection monitoring, including
+ * periodic keep-alives to the AP and probing the AP on beacon loss.
  *
  * @IEEE80211_HW_NEED_DTIM_BEFORE_ASSOC:
  * This device needs to get data from beacon before association (i.e.
@@ -1455,6 +1591,21 @@ struct ieee80211_tx_control {
  *
  * @IEEE80211_HW_TIMING_BEACON_ONLY: Use sync timing from beacon frames
  * only, to allow getting TBTT of a DTIM beacon.
+ *
+ * @IEEE80211_HW_SUPPORTS_HT_CCK_RATES: Hardware supports mixing HT/CCK rates
+ * and can cope with CCK rates in an aggregation session (e.g. by not
+ * using aggregation for such frames.)
+ *
+ * @IEEE80211_HW_CHANCTX_STA_CSA: Support 802.11h based channel-switch (CSA)
+ * for a single active channel while using channel contexts. When support
+ * is not enabled the default action is to disconnect when getting the
+ * CSA frame.
+ *
+ * @IEEE80211_HW_CHANGE_RUNNING_CHANCTX: The hardware can change a
+ * channel context on-the-fly.  This is needed for channel switch
+ * on single-channel hardware.  It can also be used as an
+ * optimization in certain channel switch cases with
+ * multi-channel.
  */
 enum ieee80211_hw_flags {
  IEEE80211_HW_HAS_RATE_CONTROL   = 1<<0,
@@ -1485,6 +1636,8 @@ enum ieee80211_hw_flags {
  IEEE80211_HW_P2P_DEV_ADDR_FOR_INTF  = 1<<25,
  IEEE80211_HW_TIMING_BEACON_ONLY   = 1<<26,
  IEEE80211_HW_SUPPORTS_HT_CCK_RATES  = 1<<27,
+ IEEE80211_HW_CHANCTX_STA_CSA   = 1<<28,
+ IEEE80211_HW_CHANGE_RUNNING_CHANCTX  = 1<<29,
 };
 
 /**
@@ -1509,13 +1662,14 @@ enum ieee80211_hw_flags {
  * @extra_tx_headroom: headroom to reserve in each transmit skb
  * for use by the driver (e.g. for transmit headers.)
  *
- * @channel_change_time: time (in microseconds) it takes to change channels.
+ * @extra_beacon_tailroom: tailroom to reserve in each beacon tx skb.
+ * Can be used by drivers to add extra IEs.
  *
  * @max_signal: Maximum value for signal (rssi) in RX information, used
- *     only when @IEEE80211_HW_SIGNAL_UNSPEC or @IEEE80211_HW_SIGNAL_DB
+ * only when @IEEE80211_HW_SIGNAL_UNSPEC or @IEEE80211_HW_SIGNAL_DB
  *
  * @max_listen_interval: max listen interval in units of beacon interval
- *     that HW supports
+ * that HW supports
  *
  * @queues: number of available hardware transmit queues for
  * data packets. WMM/QoS requires at least four, these
@@ -1538,10 +1692,6 @@ enum ieee80211_hw_flags {
  * the hw can report back.
  * @max_rate_tries: maximum number of tries for each stage
  *
- * @napi_weight: weight used for NAPI polling.  You must specify an
- * appropriate value here if a napi_poll operation is provided
- * by your driver.
- *
  * @max_rx_aggregation_subframes: maximum buffer size (number of
  * sub-frames) to be used for A-MPDU block ack receiver
  * aggregation.
@@ -1579,6 +1729,10 @@ enum ieee80211_hw_flags {
  * @uapsd_max_sp_len: maximum number of total buffered frames the WMM AP may
  * deliver to a WMM STA during any Service Period triggered by the WMM STA.
  * Use IEEE80211_WMM_IE_STA_QOSINFO_SP_* for correct values.
+ *
+ * @n_cipher_schemes: a size of an array of cipher schemes definitions.
+ * @cipher_schemes: a pointer to an array of cipher scheme definitions
+ * supported by HW.
  */
 struct ieee80211_hw {
  struct ieee80211_conf conf;
@@ -1587,11 +1741,10 @@ struct ieee80211_hw {
  void *priv;
  u32 flags;
  unsigned int extra_tx_headroom;
- int channel_change_time;
+ unsigned int extra_beacon_tailroom;
  int vif_data_size;
  int sta_data_size;
  int chanctx_data_size;
- int napi_weight;
  u16 queues;
  u16 max_listen_interval;
  s8 max_signal;
@@ -1606,6 +1759,8 @@ struct ieee80211_hw {
  netdev_features_t netdev_features;
  u8 uapsd_queues;
  u8 uapsd_max_sp_len;
+ u8 n_cipher_schemes;
+ const struct ieee80211_cipher_scheme *cipher_schemes;
 };
 
 /**
@@ -1784,7 +1939,7 @@ void ieee80211_free_txskb(struct ieee80211_hw *hw, struct sk_buff *skb);
  *
  * Driver informs U-APSD client support by enabling
  * %IEEE80211_HW_SUPPORTS_UAPSD flag. The mode is configured through the
- * uapsd paramater in conf_tx() operation. Hardware needs to send the QoS
+ * uapsd parameter in conf_tx() operation. Hardware needs to send the QoS
  * Nullfunc frames and stay awake until the service period has ended. To
  * utilize U-APSD, dynamic powersave is disabled for voip AC and all frames
  * from that AC are transmitted with powersave enabled.
@@ -1990,7 +2145,7 @@ void ieee80211_free_txskb(struct ieee80211_hw *hw, struct sk_buff *skb);
  * with the number of frames to be released and which TIDs they are
  * to come from. In this case, the driver is responsible for setting
  * the EOSP (for uAPSD) and MORE_DATA bits in the released frames,
- * to help the @more_data paramter is passed to tell the driver if
+ * to help the @more_data parameter is passed to tell the driver if
  * there is more data on other TIDs -- the TIDs to release frames
  * from are ignored since mac80211 doesn't know how many frames the
  * buffers for those TIDs contain.
@@ -2008,6 +2163,11 @@ void ieee80211_free_txskb(struct ieee80211_hw *hw, struct sk_buff *skb);
  * appropriately (only the last frame may have %IEEE80211_TX_STATUS_EOSP)
  * and also take care of the EOSP and MORE_DATA bits in the frame.
  * The driver may also use ieee80211_sta_eosp() in this case.
+ *
+ * Note that if the driver ever buffers frames other than QoS-data
+ * frames, it must take care to never send a non-QoS-data frame as
+ * the last frame in a service period, adding a QoS-nulldata frame
+ * after a non-QoS-data frame if needed.
  */
 
 /**
@@ -2301,9 +2461,6 @@ enum ieee80211_roc_type {
  * See the section "Frame filtering" for more information.
  * This callback must be implemented and can sleep.
  *
- * @set_multicast_list: Configure the device's interface specific RX multicast
- * filter. This callback is optional. This callback must be atomic.
- *
  * @set_tim: Set TIM bit. mac80211 calls this function when a TIM bit
  *  must be set or cleared for a given STA. Must be atomic.
  *
@@ -2357,6 +2514,7 @@ enum ieee80211_roc_type {
  * This process will continue until sched_scan_stop is called.
  *
  * @sched_scan_stop: Tell the hardware to stop an ongoing scheduled scan.
+ * In this case, ieee80211_sched_scan_stopped() must not be called.
  *
  * @sw_scan_start: Notifier function that is called just before a software scan
  * is started. Can be NULL, if the driver doesn't need this notification.
@@ -2388,7 +2546,11 @@ enum ieee80211_roc_type {
  * AP, IBSS/WDS/mesh peer etc. This callback can sleep.
  *
  * @sta_remove: Notifies low level driver about removal of an associated
- * station, AP, IBSS/WDS/mesh peer etc. This callback can sleep.
+ * station, AP, IBSS/WDS/mesh peer etc. Note that after the callback
+ * returns it isn't safe to use the pointer, not even RCU protected;
+ * no RCU grace period is guaranteed between returning here and freeing
+ * the station. See @sta_pre_rcu_remove if needed.
+ * This callback can sleep.
  *
  * @sta_add_debugfs: Drivers can use this callback to add debugfs files
  * when a station is added to mac80211's station list. This callback
@@ -2407,7 +2569,17 @@ enum ieee80211_roc_type {
  * station (which can be the AP, a client, IBSS/WDS/mesh peer etc.)
  * This callback is mutually exclusive with @sta_add/@sta_remove.
  * It must not fail for down transitions but may fail for transitions
- * up the list of states.
+ * up the list of states. Also note that after the callback returns it
+ * isn't safe to use the pointer, not even RCU protected - no RCU grace
+ * period is guaranteed between returning here and freeing the station.
+ * See @sta_pre_rcu_remove if needed.
+ * The callback can sleep.
+ *
+ * @sta_pre_rcu_remove: Notify driver about station removal before RCU
+ * synchronisation. This is useful if a driver needs to have station
+ * pointers protected using RCU, it can then use this call to clear
+ * the pointers instead of waiting for an RCU grace period to elapse
+ * in @sta_state.
  * The callback can sleep.
  *
  * @sta_rc_update: Notifies the driver of changes to the bitrates that can be
@@ -2429,7 +2601,7 @@ enum ieee80211_roc_type {
  * The callback can sleep.
  *
  * @set_tsf: Set the TSF timer to the specified value in the firmware/hardware.
- *      Currently, this is only used for IBSS mode debugging. Is not a
+ * Currently, this is only used for IBSS mode debugging. Is not a
  * required function.
  * The callback can sleep.
  *
@@ -2480,8 +2652,8 @@ enum ieee80211_roc_type {
  * in IEEE 802.11-2007 section 17.3.8.6 and modify ACK timeout
  * accordingly. This callback is not required and may sleep.
  *
- * @testmode_cmd: Implement a cfg80211 test mode command.
- * The callback can sleep.
+ * @testmode_cmd: Implement a cfg80211 test mode command. The passed @vif may
+ * be %NULL. The callback can sleep.
  * @testmode_dump: Implement a cfg80211 test mode dump. The callback can sleep.
  *
  * @flush: Flush all pending frames from the hardware queue, making sure
@@ -2489,6 +2661,7 @@ enum ieee80211_roc_type {
  * of queues to flush, which is useful if different virtual interfaces
  * use different hardware queues; it may also indicate all queues.
  * If the parameter @drop is set to %true, pending frames may be dropped.
+ * Note that vif can be NULL.
  * The callback can sleep.
  *
  * @channel_switch: Drivers that need (or want) to offload the channel
@@ -2496,8 +2669,6 @@ enum ieee80211_roc_type {
  * callback. They must then call ieee80211_chswitch_done() to indicate
  * completion of the channel switch.
  *
- * @napi_poll: Poll Rx queue for incoming data frames.
- *
  * @set_antenna: Set antenna configuration (tx_ant, rx_ant) on the device.
  * Parameters are bitmaps of allowed antennas to use for TX/RX. Drivers may
  * reject TX/RX mask combinations they cannot support by returning -EINVAL
@@ -2535,7 +2706,7 @@ enum ieee80211_roc_type {
  * parameters. In the case where the driver buffers some frames for
  * sleeping stations mac80211 will use this callback to tell the driver
  * to release some frames, either for PS-poll or uAPSD.
- * Note that if the @more_data paramter is %false the driver must check
+ * Note that if the @more_data parameter is %false the driver must check
  * if there are more frames on the given TIDs, and if there are more than
  * the frames being released then it must still set the more-data bit in
  * the frame. If the @more_data parameter is %true, then of course the
@@ -2602,6 +2773,11 @@ enum ieee80211_roc_type {
  * to vif. Possible use is for hw queue remapping.
  * @unassign_vif_chanctx: Notifies device driver about channel context being
  * unbound from vif.
+ * @switch_vif_chanctx: switch a number of vifs from one chanctx to
+ * another, as specified in the list of
+ * @ieee80211_vif_chanctx_switch passed to the driver, according
+ * to the mode defined in &ieee80211_chanctx_switch_mode.
+ *
  * @start_ap: Start operation on the AP interface, this is called after all the
  * information in bss_conf is set and beacon can be retrieved. A channel
  * context is bound before this is called. Note that if the driver uses
@@ -2619,6 +2795,26 @@ enum ieee80211_roc_type {
  * @ipv6_addr_change: IPv6 address assignment on the given interface changed.
  * Currently, this is only called for managed or P2P client interfaces.
  * This callback is optional; it must not sleep.
+ *
+ * @channel_switch_beacon: Starts a channel switch to a new channel.
+ * Beacons are modified to include CSA or ECSA IEs before calling this
+ * function. The corresponding count fields in these IEs must be
+ * decremented, and when they reach 1 the driver must call
+ * ieee80211_csa_finish(). Drivers which use ieee80211_beacon_get()
+ * get the csa counter decremented by mac80211, but must check if it is
+ * 1 using ieee80211_csa_is_complete() after the beacon has been
+ * transmitted and then call ieee80211_csa_finish().
+ * If the CSA count starts as zero or 1, this function will not be called,
+ * since there won't be any time to beacon before the switch anyway.
+ *
+ * @join_ibss: Join an IBSS (on an IBSS interface); this is called after all
+ * information in bss_conf is set up and the beacon can be retrieved. A
+ * channel context is bound before this is called.
+ * @leave_ibss: Leave the IBSS again.
+ *
+ * @get_expected_throughput: extract the expected throughput towards the
+ * specified station. The returned value is expressed in Kbps. It returns 0
+ * if the RC algorithm does not have proper data to provide.
  */
 struct ieee80211_ops {
  void (*tx)(struct ieee80211_hw *hw,
@@ -2653,10 +2849,6 @@ struct ieee80211_ops {
      unsigned int changed_flags,
      unsigned int *total_flags,
      u64 multicast);
- void (*set_multicast_list)(struct ieee80211_hw *hw,
-       struct ieee80211_vif *vif, bool allmulti,
-       struct netdev_hw_addr_list *mc_list);
-
  int (*set_tim)(struct ieee80211_hw *hw, struct ieee80211_sta *sta,
          bool set);
  int (*set_key)(struct ieee80211_hw *hw, enum set_key_cmd cmd,
@@ -2680,7 +2872,7 @@ struct ieee80211_ops {
     struct ieee80211_vif *vif,
     struct cfg80211_sched_scan_request *req,
     struct ieee80211_sched_scan_ies *ies);
- void (*sched_scan_stop)(struct ieee80211_hw *hw,
+ int (*sched_scan_stop)(struct ieee80211_hw *hw,
           struct ieee80211_vif *vif);
  void (*sw_scan_start)(struct ieee80211_hw *hw);
  void (*sw_scan_complete)(struct ieee80211_hw *hw);
@@ -2710,6 +2902,9 @@ struct ieee80211_ops {
     struct ieee80211_sta *sta,
     enum ieee80211_sta_state old_state,
     enum ieee80211_sta_state new_state);
+ void (*sta_pre_rcu_remove)(struct ieee80211_hw *hw,
+       struct ieee80211_vif *vif,
+       struct ieee80211_sta *sta);
  void (*sta_rc_update)(struct ieee80211_hw *hw,
          struct ieee80211_vif *vif,
          struct ieee80211_sta *sta,
@@ -2732,15 +2927,16 @@ struct ieee80211_ops {
  void (*rfkill_poll)(struct ieee80211_hw *hw);
  void (*set_coverage_class)(struct ieee80211_hw *hw, u8 coverage_class);
 #ifdef CONFIG_NL80211_TESTMODE
- int (*testmode_cmd)(struct ieee80211_hw *hw, void *data, int len);
+ int (*testmode_cmd)(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
+       void *data, int len);
  int (*testmode_dump)(struct ieee80211_hw *hw, struct sk_buff *skb,
         struct netlink_callback *cb,
         void *data, int len);
 #endif
- void (*flush)(struct ieee80211_hw *hw, u32 queues, bool drop);
+ void (*flush)(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
+        u32 queues, bool drop);
  void (*channel_switch)(struct ieee80211_hw *hw,
           struct ieee80211_channel_switch *ch_switch);
- int (*napi_poll)(struct ieee80211_hw *hw, int budget);
  int (*set_antenna)(struct ieee80211_hw *hw, u32 tx_ant, u32 rx_ant);
  int (*get_antenna)(struct ieee80211_hw *hw, u32 *tx_ant, u32 *rx_ant);
 
@@ -2798,6 +2994,10 @@ struct ieee80211_ops {
  void (*unassign_vif_chanctx)(struct ieee80211_hw *hw,
          struct ieee80211_vif *vif,
          struct ieee80211_chanctx_conf *ctx);
+ int (*switch_vif_chanctx)(struct ieee80211_hw *hw,
+      struct ieee80211_vif_chanctx_switch *vifs,
+      int n_vifs,
+      enum ieee80211_chanctx_switch_mode mode);
 
  void (*restart_complete)(struct ieee80211_hw *hw);
 
@@ -2806,6 +3006,13 @@ struct ieee80211_ops {
      struct ieee80211_vif *vif,
      struct inet6_dev *idev);
 #endif
+ void (*channel_switch_beacon)(struct ieee80211_hw *hw,
+          struct ieee80211_vif *vif,
+          struct cfg80211_chan_def *chandef);
+
+ int (*join_ibss)(struct ieee80211_hw *hw, struct ieee80211_vif *vif);
+ void (*leave_ibss)(struct ieee80211_hw *hw, struct ieee80211_vif *vif);
+ u32 (*get_expected_throughput)(struct ieee80211_sta *sta);
 };
 
 /**
@@ -2863,14 +3070,14 @@ enum ieee80211_tpt_led_trigger_flags {
 };
 
 #ifdef CONFIG_MAC80211_LEDS
-extern char *__ieee80211_get_tx_led_name(struct ieee80211_hw *hw);
-extern char *__ieee80211_get_rx_led_name(struct ieee80211_hw *hw);
-extern char *__ieee80211_get_assoc_led_name(struct ieee80211_hw *hw);
-extern char *__ieee80211_get_radio_led_name(struct ieee80211_hw *hw);
-extern char *__ieee80211_create_tpt_led_trigger(
-    struct ieee80211_hw *hw, unsigned int flags,
-    const struct ieee80211_tpt_blink *blink_table,
-    unsigned int blink_table_len);
+char *__ieee80211_get_tx_led_name(struct ieee80211_hw *hw);
+char *__ieee80211_get_rx_led_name(struct ieee80211_hw *hw);
+char *__ieee80211_get_assoc_led_name(struct ieee80211_hw *hw);
+char *__ieee80211_get_radio_led_name(struct ieee80211_hw *hw);
+char *__ieee80211_create_tpt_led_trigger(struct ieee80211_hw *hw,
+      unsigned int flags,
+      const struct ieee80211_tpt_blink *blink_table,
+      unsigned int blink_table_len);
 #endif
 /**
  * ieee80211_get_tx_led_name - get name of TX LED
@@ -3016,21 +3223,21 @@ void ieee80211_free_hw(struct ieee80211_hw *hw);
  */
 void ieee80211_restart_hw(struct ieee80211_hw *hw);
 
-/** ieee80211_napi_schedule - schedule NAPI poll
- *
- * Use this function to schedule NAPI polling on a device.
- *
- * @hw: the hardware to start polling
- */
-void ieee80211_napi_schedule(struct ieee80211_hw *hw);
-
-/** ieee80211_napi_complete - complete NAPI polling
- *
- * Use this function to finish NAPI polling on a device.
+/**
+ * ieee80211_napi_add - initialize mac80211 NAPI context
+ * @hw: the hardware to initialize the NAPI context on
+ * @napi: the NAPI context to initialize
+ * @napi_dev: dummy NAPI netdevice, here to not waste the space if the
+ * driver doesn't use NAPI
+ * @poll: poll function
+ * @weight: default weight
  *
- * @hw: the hardware to stop polling
+ * See also netif_napi_add().
  */
-void ieee80211_napi_complete(struct ieee80211_hw *hw);
+void ieee80211_napi_add(struct ieee80211_hw *hw, struct napi_struct *napi,
+   struct net_device *napi_dev,
+   int (*poll)(struct napi_struct *, int),
+   int weight);
 
 /**
  * ieee80211_rx - receive frame
@@ -3255,6 +3462,47 @@ void ieee80211_tx_status_irqsafe(struct ieee80211_hw *hw,
  */
 void ieee80211_report_low_ack(struct ieee80211_sta *sta, u32 num_packets);
 
+#define IEEE80211_MAX_CSA_COUNTERS_NUM 2
+
+/**
+ * struct ieee80211_mutable_offsets - mutable beacon offsets
+ * @tim_offset: position of TIM element
+ * @tim_length: size of TIM element
+ * @csa_counter_offs: array of IEEE80211_MAX_CSA_COUNTERS_NUM offsets
+ * to CSA counters.  This array can contain zero values which
+ * should be ignored.
+ */
+struct ieee80211_mutable_offsets {
+ u16 tim_offset;
+ u16 tim_length;
+
+ u16 csa_counter_offs[IEEE80211_MAX_CSA_COUNTERS_NUM];
+};
+
+/**
+ * ieee80211_beacon_get_template - beacon template generation function
+ * @hw: pointer obtained from ieee80211_alloc_hw().
+ * @vif: &struct ieee80211_vif pointer from the add_interface callback.
+ * @offs: &struct ieee80211_mutable_offsets pointer to struct that will
+ * receive the offsets that may be updated by the driver.
+ *
+ * If the driver implements beaconing modes, it must use this function to
+ * obtain the beacon template.
+ *
+ * This function should be used if the beacon frames are generated by the
+ * device, and then the driver must use the returned beacon as the template
+ * The driver or the device are responsible to update the DTIM and, when
+ * applicable, the CSA count.
+ *
+ * The driver is responsible for freeing the returned skb.
+ *
+ * Return: The beacon template. %NULL on error.
+ */
+struct sk_buff *
+ieee80211_beacon_get_template(struct ieee80211_hw *hw,
+         struct ieee80211_vif *vif,
+         struct ieee80211_mutable_offsets *offs);
+
 /**
  * ieee80211_beacon_get_tim - beacon generation function
  * @hw: pointer obtained from ieee80211_alloc_hw().
@@ -3266,16 +3514,12 @@ void ieee80211_report_low_ack(struct ieee80211_sta *sta, u32 num_packets);
  * Set to 0 if invalid (in non-AP modes).
  *
  * If the driver implements beaconing modes, it must use this function to
- * obtain the beacon frame/template.
+ * obtain the beacon frame.
  *
  * If the beacon frames are generated by the host system (i.e., not in
  * hardware/firmware), the driver uses this function to get each beacon
- * frame from mac80211 -- it is responsible for calling this function
- * before the beacon is needed (e.g. based on hardware interrupt).
- *
- * If the beacon frames are generated by the device, then the driver
- * must use the returned beacon as the template and change the TIM IE
- * according to the current DTIM parameters/TIM bitmap.
+ * frame from mac80211 -- it is responsible for calling this function exactly
+ * once before the beacon is needed (e.g. based on hardware interrupt).
  *
  * The driver is responsible for freeing the returned skb.
  *
@@ -3301,6 +3545,39 @@ static inline struct sk_buff *ieee80211_beacon_get(struct ieee80211_hw *hw,
 }
 
 /**
+ * ieee80211_csa_update_counter - request mac80211 to decrement the csa counter
+ * @vif: &struct ieee80211_vif pointer from the add_interface callback.
+ *
+ * The csa counter should be updated after each beacon transmission.
+ * This function is called implicitly when
+ * ieee80211_beacon_get/ieee80211_beacon_get_tim are called, however if the
+ * beacon frames are generated by the device, the driver should call this
+ * function after each beacon transmission to sync mac80211's csa counters.
+ *
+ * Return: new csa counter value
+ */
+u8 ieee80211_csa_update_counter(struct ieee80211_vif *vif);
+
+/**
+ * ieee80211_csa_finish - notify mac80211 about channel switch
+ * @vif: &struct ieee80211_vif pointer from the add_interface callback.
+ *
+ * After a channel switch announcement was scheduled and the counter in this
+ * announcement hits 1, this function must be called by the driver to
+ * notify mac80211 that the channel can be changed.
+ */
+void ieee80211_csa_finish(struct ieee80211_vif *vif);
+
+/**
+ * ieee80211_csa_is_complete - find out if counters reached 1
+ * @vif: &struct ieee80211_vif pointer from the add_interface callback.
+ *
+ * This function returns whether the channel switch counters reached zero.
+ */
+bool ieee80211_csa_is_complete(struct ieee80211_vif *vif);
+
+
+/**
  * ieee80211_proberesp_get - retrieve a Probe Response template
  * @hw: pointer obtained from ieee80211_alloc_hw().
  * @vif: &struct ieee80211_vif pointer from the add_interface callback.
@@ -3619,6 +3896,89 @@ void ieee80211_get_key_rx_seq(struct ieee80211_key_conf *keyconf,
          int tid, struct ieee80211_key_seq *seq);
 
 /**
+ * ieee80211_set_key_tx_seq - set key TX sequence counter
+ *
+ * @keyconf: the parameter passed with the set key
+ * @seq: new sequence data
+ *
+ * This function allows a driver to set the current TX IV/PNs for the
+ * given key. This is useful when resuming from WoWLAN sleep and the
+ * device may have transmitted frames using the PTK, e.g. replies to
+ * ARP requests.
+ *
+ * Note that this function may only be called when no TX processing
+ * can be done concurrently.
+ */
+void ieee80211_set_key_tx_seq(struct ieee80211_key_conf *keyconf,
+         struct ieee80211_key_seq *seq);
+
+/**
+ * ieee80211_set_key_rx_seq - set key RX sequence counter
+ *
+ * @keyconf: the parameter passed with the set key
+ * @tid: The TID, or -1 for the management frame value (CCMP only);
+ * the value on TID 0 is also used for non-QoS frames. For
+ * CMAC, only TID 0 is valid.
+ * @seq: new sequence data
+ *
+ * This function allows a driver to set the current RX IV/PNs for the
+ * given key. This is useful when resuming from WoWLAN sleep and GTK
+ * rekey may have been done while suspended. It should not be called
+ * if IV checking is done by the device and not by mac80211.
+ *
+ * Note that this function may only be called when no RX processing
+ * can be done concurrently.
+ */
+void ieee80211_set_key_rx_seq(struct ieee80211_key_conf *keyconf,
+         int tid, struct ieee80211_key_seq *seq);
+
+/**
+ * ieee80211_remove_key - remove the given key
+ * @keyconf: the parameter passed with the set key
+ *
+ * Remove the given key. If the key was uploaded to the hardware at the
+ * time this function is called, it is not deleted in the hardware but
+ * instead assumed to have been removed already.
+ *
+ * Note that due to locking considerations this function can (currently)
+ * only be called during key iteration (ieee80211_iter_keys().)
+ */
+void ieee80211_remove_key(struct ieee80211_key_conf *keyconf);
+
+/**
+ * ieee80211_gtk_rekey_add - add a GTK key from rekeying during WoWLAN
+ * @vif: the virtual interface to add the key on
+ * @keyconf: new key data
+ *
+ * When GTK rekeying was done while the system was suspended, (a) new
+ * key(s) will be available. These will be needed by mac80211 for proper
+ * RX processing, so this function allows setting them.
+ *
+ * The function returns the newly allocated key structure, which will
+ * have similar contents to the passed key configuration but point to
+ * mac80211-owned memory. In case of errors, the function returns an
+ * ERR_PTR(), use IS_ERR() etc.
+ *
+ * Note that this function assumes the key isn't added to hardware
+ * acceleration, so no TX will be done with the key. Since it's a GTK
+ * on managed (station) networks, this is true anyway. If the driver
+ * calls this function from the resume callback and subsequently uses
+ * the return code 1 to reconfigure the device, this key will be part
+ * of the reconfiguration.
+ *
+ * Note that the driver should also call ieee80211_set_key_rx_seq()
+ * for the new key for each TID to set up sequence counters properly.
+ *
+ * IMPORTANT: If this replaces a key that is present in the hardware,
+ * then it will attempt to remove it during this call. In many cases
+ * this isn't what you want, so call ieee80211_remove_key() first for
+ * the key that's being replaced.
+ */
+struct ieee80211_key_conf *
+ieee80211_gtk_rekey_add(struct ieee80211_vif *vif,
+   struct ieee80211_key_conf *keyconf);
+
+/**
  * ieee80211_gtk_rekey_notify - notify userspace supplicant of rekeying
  * @vif: virtual interface the rekeying was done on
  * @bssid: The BSSID of the AP, for checking association
@@ -3767,6 +4127,25 @@ void ieee80211_iterate_active_interfaces_atomic(struct ieee80211_hw *hw,
       void *data);
 
 /**
+ * ieee80211_iterate_active_interfaces_rtnl - iterate active interfaces
+ *
+ * This function iterates over the interfaces associated with a given
+ * hardware that are currently active and calls the callback for them.
+ * This version can only be used while holding the RTNL.
+ *
+ * @hw: the hardware struct of which the interfaces should be iterated over
+ * @iter_flags: iteration flags, see &enum ieee80211_interface_iteration_flags
+ * @iterator: the iterator function to call, cannot sleep
+ * @data: first argument of the iterator function
+ */
+void ieee80211_iterate_active_interfaces_rtnl(struct ieee80211_hw *hw,
+           u32 iter_flags,
+           void (*iterator)(void *data,
+      u8 *mac,
+      struct ieee80211_vif *vif),
+           void *data);
+
+/**
  * ieee80211_queue_work - add work onto the mac80211 workqueue
  *
  * Drivers and mac80211 use this to add work onto the mac80211 workqueue.
@@ -4183,15 +4562,16 @@ struct ieee80211_tx_rate_control {
 };
 
 struct rate_control_ops {
- struct module *module;
  const char *name;
  void *(*alloc)(struct ieee80211_hw *hw, struct dentry *debugfsdir);
  void (*free)(void *priv);
 
  void *(*alloc_sta)(void *priv, struct ieee80211_sta *sta, gfp_t gfp);
  void (*rate_init)(void *priv, struct ieee80211_supported_band *sband,
+     struct cfg80211_chan_def *chandef,
      struct ieee80211_sta *sta, void *priv_sta);
  void (*rate_update)(void *priv, struct ieee80211_supported_band *sband,
+       struct cfg80211_chan_def *chandef,
        struct ieee80211_sta *sta, void *priv_sta,
        u32 changed);
  void (*free_sta)(void *priv, struct ieee80211_sta *sta,
@@ -4206,6 +4586,8 @@ struct rate_control_ops {
  void (*add_sta_debugfs)(void *priv, void *priv_sta,
     struct dentry *dir);
  void (*remove_sta_debugfs)(void *priv, void *priv_sta);
+
+ u32 (*get_expected_throughput)(void *priv_sta);
 };
 
 static inline int rate_supported(struct ieee80211_sta *sta,
@@ -4283,8 +4665,8 @@ int rate_control_set_rates(struct ieee80211_hw *hw,
       struct ieee80211_sta *pubsta,
       struct ieee80211_sta_rates *rates);
 
-int ieee80211_rate_control_register(struct rate_control_ops *ops);
-void ieee80211_rate_control_unregister(struct rate_control_ops *ops);
+int ieee80211_rate_control_register(const struct rate_control_ops *ops);
+void ieee80211_rate_control_unregister(const struct rate_control_ops *ops);
 
 static inline bool
 conf_is_ht20(struct ieee80211_conf *conf)
@@ -4315,7 +4697,9 @@ conf_is_ht40(struct ieee80211_conf *conf)
 static inline bool
 conf_is_ht(struct ieee80211_conf *conf)
 {
- return conf->chandef.width != NL80211_CHAN_WIDTH_20_NOHT;
+ return (conf->chandef.width != NL80211_CHAN_WIDTH_5) &&
+  (conf->chandef.width != NL80211_CHAN_WIDTH_10) &&
+  (conf->chandef.width != NL80211_CHAN_WIDTH_20_NOHT);
 }
 
 static inline enum nl80211_iftype
@@ -4370,4 +4754,65 @@ void ieee80211_report_wowlan_wakeup(struct ieee80211_vif *vif,
         struct cfg80211_wowlan_wakeup *wakeup,
         gfp_t gfp);
 
+/**
+ * ieee80211_tx_prepare_skb - prepare an 802.11 skb for transmission
+ * @hw: pointer as obtained from ieee80211_alloc_hw()
+ * @vif: virtual interface
+ * @skb: frame to be sent from within the driver
+ * @band: the band to transmit on
+ * @sta: optional pointer to get the station to send the frame to
+ *
+ * Note: must be called under RCU lock
+ */
+bool ieee80211_tx_prepare_skb(struct ieee80211_hw *hw,
+         struct ieee80211_vif *vif, struct sk_buff *skb,
+         int band, struct ieee80211_sta **sta);
+
+/**
+ * struct ieee80211_noa_data - holds temporary data for tracking P2P NoA state
+ *
+ * @next_tsf: TSF timestamp of the next absent state change
+ * @has_next_tsf: next absent state change event pending
+ *
+ * @absent: descriptor bitmask, set if GO is currently absent
+ *
+ * private:
+ *
+ * @count: count fields from the NoA descriptors
+ * @desc: adjusted data from the NoA
+ */
+struct ieee80211_noa_data {
+ u32 next_tsf;
+ bool has_next_tsf;
+
+ u8 absent;
+
+ u8 count[IEEE80211_P2P_NOA_DESC_MAX];
+ struct {
+  u32 start;
+  u32 duration;
+  u32 interval;
+ } desc[IEEE80211_P2P_NOA_DESC_MAX];
+};
+
+/**
+ * ieee80211_parse_p2p_noa - initialize NoA tracking data from P2P IE
+ *
+ * @attr: P2P NoA IE
+ * @data: NoA tracking data
+ * @tsf: current TSF timestamp
+ *
+ * Return: number of successfully parsed descriptors
+ */
+int ieee80211_parse_p2p_noa(const struct ieee80211_p2p_noa_attr *attr,
+       struct ieee80211_noa_data *data, u32 tsf);
+
+/**
+ * ieee80211_update_p2p_noa - get next pending P2P GO absent state change
+ *
+ * @data: NoA tracking data
+ * @tsf: current TSF timestamp
+ */
+void ieee80211_update_p2p_noa(struct ieee80211_noa_data *data, u32 tsf);
+
 #endif /* MAC80211_H */
diff --git a/include/net/regulatory.h b/include/net/regulatory.h
index f17ed59..2599924 100644
--- a/include/net/regulatory.h
+++ b/include/net/regulatory.h
@@ -38,17 +38,17 @@ enum environment_cap {
  *
  * @rcu_head: RCU head struct used to free the request
  * @wiphy_idx: this is set if this request's initiator is
- *  %REGDOM_SET_BY_COUNTRY_IE or %REGDOM_SET_BY_DRIVER. This
- *  can be used by the wireless core to deal with conflicts
- *  and potentially inform users of which devices specifically
- *  cased the conflicts.
+ * %REGDOM_SET_BY_COUNTRY_IE or %REGDOM_SET_BY_DRIVER. This
+ * can be used by the wireless core to deal with conflicts
+ * and potentially inform users of which devices specifically
+ * cased the conflicts.
  * @initiator: indicates who sent this request, could be any of
- *  of those set in nl80211_reg_initiator (%NL80211_REGDOM_SET_BY_*)
+ * of those set in nl80211_reg_initiator (%NL80211_REGDOM_SET_BY_*)
  * @alpha2: the ISO / IEC 3166 alpha2 country code of the requested
- *  regulatory domain. We have a few special codes:
- *  00 - World regulatory domain
- *  99 - built by driver but a specific alpha2 cannot be determined
- *  98 - result of an intersection between two regulatory domains
+ * regulatory domain. We have a few special codes:
+ * 00 - World regulatory domain
+ * 99 - built by driver but a specific alpha2 cannot be determined
+ * 98 - result of an intersection between two regulatory domains
  * 97 - regulatory domain has not yet been configured
  * @dfs_region: If CRDA responded with a regulatory domain that requires
  * DFS master operation on a known DFS region (NL80211_DFS_*),
@@ -59,8 +59,8 @@ enum environment_cap {
  * of hint passed. This could be any of the %NL80211_USER_REG_HINT_*
  * types.
  * @intersect: indicates whether the wireless core should intersect
- *  the requested regulatory domain with the presently set regulatory
- *  domain.
+ * the requested regulatory domain with the presently set regulatory
+ * domain.
  * @processed: indicates whether or not this requests has already been
  * processed. When the last request is processed it means that the
  * currently regulatory domain set on cfg80211 is updated from
@@ -68,9 +68,9 @@ enum environment_cap {
  * the last request is not yet processed we must yield until it
  * is processed before processing any new requests.
  * @country_ie_checksum: checksum of the last processed and accepted
- *  country IE
+ * country IE
  * @country_ie_env: lets us know if the AP is telling us we are outdoor,
- *  indoor, or if it doesn't matter
+ * indoor, or if it doesn't matter
  * @list: used to insert into the reg_requests_list linked list
  */
 struct regulatory_request {
@@ -79,13 +79,73 @@ struct regulatory_request {
  enum nl80211_reg_initiator initiator;
  enum nl80211_user_reg_hint_type user_reg_hint_type;
  char alpha2[2];
- u8 dfs_region;
+ enum nl80211_dfs_regions dfs_region;
  bool intersect;
  bool processed;
  enum environment_cap country_ie_env;
  struct list_head list;
 };
 
+/**
+ * enum ieee80211_regulatory_flags - device regulatory flags
+ *
+ * @REGULATORY_CUSTOM_REG: tells us the driver for this device
+ * has its own custom regulatory domain and cannot identify the
+ * ISO / IEC 3166 alpha2 it belongs to. When this is enabled
+ * we will disregard the first regulatory hint (when the
+ * initiator is %REGDOM_SET_BY_CORE). Drivers that use
+ * wiphy_apply_custom_regulatory() should have this flag set
+ * or the regulatory core will set it for the wiphy.
+ * If you use regulatory_hint() *after* using
+ * wiphy_apply_custom_regulatory() the wireless core will
+ * clear the REGULATORY_CUSTOM_REG for your wiphy as it would be
+ * implied that the device somehow gained knowledge of its region.
+ * @REGULATORY_STRICT_REG: tells us that the wiphy for this device
+ * has regulatory domain that it wishes to be considered as the
+ * superset for regulatory rules. After this device gets its regulatory
+ * domain programmed further regulatory hints shall only be considered
+ * for this device to enhance regulatory compliance, forcing the
+ * device to only possibly use subsets of the original regulatory
+ * rules. For example if channel 13 and 14 are disabled by this
+ * device's regulatory domain no user specified regulatory hint which
+ * has these channels enabled would enable them for this wiphy,
+ * the device's original regulatory domain will be trusted as the
+ * base. You can program the superset of regulatory rules for this
+ * wiphy with regulatory_hint() for cards programmed with an
+ * ISO3166-alpha2 country code. wiphys that use regulatory_hint()
+ * will have their wiphy->regd programmed once the regulatory
+ * domain is set, and all other regulatory hints will be ignored
+ * until their own regulatory domain gets programmed.
+ * @REGULATORY_DISABLE_BEACON_HINTS: enable this if your driver needs to
+ * ensure that passive scan flags and beaconing flags may not be lifted by
+ * cfg80211 due to regulatory beacon hints. For more information on beacon
+ * hints read the documenation for regulatory_hint_found_beacon()
+ * @REGULATORY_COUNTRY_IE_FOLLOW_POWER:  for devices that have a preference
+ * that even though they may have programmed their own custom power
+ * setting prior to wiphy registration, they want to ensure their channel
+ * power settings are updated for this connection with the power settings
+ * derived from the regulatory domain. The regulatory domain used will be
+ * based on the ISO3166-alpha2 from country IE provided through
+ * regulatory_hint_country_ie()
+ * @REGULATORY_COUNTRY_IE_IGNORE: for devices that have a preference to ignore
+ *  all country IE information processed by the regulatory core. This will
+ *  override %REGULATORY_COUNTRY_IE_FOLLOW_POWER as all country IEs will
+ *  be ignored.
+ * @REGULATORY_ENABLE_RELAX_NO_IR: for devices that wish to allow the
+ *      NO_IR relaxation, which enables transmissions on channels on which
+ *      otherwise initiating radiation is not allowed. This will enable the
+ *      relaxations enabled under the CFG80211_REG_RELAX_NO_IR configuration
+ *      option
+ */
+enum ieee80211_regulatory_flags {
+ REGULATORY_CUSTOM_REG   = BIT(0),
+ REGULATORY_STRICT_REG   = BIT(1),
+ REGULATORY_DISABLE_BEACON_HINTS  = BIT(2),
+ REGULATORY_COUNTRY_IE_FOLLOW_POWER = BIT(3),
+ REGULATORY_COUNTRY_IE_IGNORE  = BIT(4),
+ REGULATORY_ENABLE_RELAX_NO_IR           = BIT(5),
+};
+
 struct ieee80211_freq_range {
  u32 start_freq_khz;
  u32 end_freq_khz;
@@ -101,13 +161,14 @@ struct ieee80211_reg_rule {
  struct ieee80211_freq_range freq_range;
  struct ieee80211_power_rule power_rule;
  u32 flags;
+ u32 dfs_cac_ms;
 };
 
 struct ieee80211_regdomain {
  struct rcu_head rcu_head;
  u32 n_reg_rules;
  char alpha2[2];
- u8 dfs_region;
+ enum nl80211_dfs_regions dfs_region;
  struct ieee80211_reg_rule reg_rules[];
 };
 
@@ -118,14 +179,18 @@ struct ieee80211_regdomain {
 #define DBM_TO_MBM(gain) ((gain) * 100)
 #define MBM_TO_DBM(gain) ((gain) / 100)
 
-#define REG_RULE(start, end, bw, gain, eirp, reg_flags) \
-{       \
- .freq_range.start_freq_khz = MHZ_TO_KHZ(start), \
- .freq_range.end_freq_khz = MHZ_TO_KHZ(end), \
- .freq_range.max_bandwidth_khz = MHZ_TO_KHZ(bw), \
- .power_rule.max_antenna_gain = DBI_TO_MBI(gain),\
- .power_rule.max_eirp = DBM_TO_MBM(eirp), \
- .flags = reg_flags,    \
+#define REG_RULE_EXT(start, end, bw, gain, eirp, dfs_cac, reg_flags) \
+{         \
+ .freq_range.start_freq_khz = MHZ_TO_KHZ(start),   \
+ .freq_range.end_freq_khz = MHZ_TO_KHZ(end),   \
+ .freq_range.max_bandwidth_khz = MHZ_TO_KHZ(bw),   \
+ .power_rule.max_antenna_gain = DBI_TO_MBI(gain),  \
+ .power_rule.max_eirp = DBM_TO_MBM(eirp),   \
+ .flags = reg_flags,      \
+ .dfs_cac_ms = dfs_cac,      \
 }
 
+#define REG_RULE(start, end, bw, gain, eirp, reg_flags) \
+ REG_RULE_EXT(start, end, bw, gain, eirp, 0, reg_flags)
+
 #endif
diff --git a/include/uapi/linux/mpls.h b/include/uapi/linux/mpls.h
new file mode 100644
index 0000000..bc9abfe
--- /dev/null
+++ b/include/uapi/linux/mpls.h
@@ -0,0 +1,34 @@
+#ifndef _UAPI_MPLS_H
+#define _UAPI_MPLS_H
+
+#include <linux/types.h>
+#include <asm/byteorder.h>
+
+/* Reference: RFC 5462, RFC 3032
+ *
+ *  0                   1                   2                   3
+ *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+ * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ * |                Label                  | TC  |S|       TTL     |
+ * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ *
+ * Label:  Label Value, 20 bits
+ * TC:     Traffic Class field, 3 bits
+ * S:      Bottom of Stack, 1 bit
+ * TTL:    Time to Live, 8 bits
+ */
+
+struct mpls_label {
+ __be32 entry;
+};
+
+#define MPLS_LS_LABEL_MASK      0xFFFFF000
+#define MPLS_LS_LABEL_SHIFT     12
+#define MPLS_LS_TC_MASK         0x00000E00
+#define MPLS_LS_TC_SHIFT        9
+#define MPLS_LS_S_MASK          0x00000100
+#define MPLS_LS_S_SHIFT         8
+#define MPLS_LS_TTL_MASK        0x000000FF
+#define MPLS_LS_TTL_SHIFT       0
+
+#endif /* _UAPI_MPLS_H */
diff --git a/include/uapi/linux/nl80211.h b/include/uapi/linux/nl80211.h
index d1e48b5..be9519b 100644
--- a/include/uapi/linux/nl80211.h
+++ b/include/uapi/linux/nl80211.h
@@ -27,6 +27,8 @@
 
 #include <linux/types.h>
 
+#define NL80211_GENL_NAME "nl80211"
+
 /**
  * DOC: Station handling
  *
@@ -124,6 +126,31 @@
  */
 
 /**
+ * DOC: packet coalesce support
+ *
+ * In most cases, host that receives IPv4 and IPv6 multicast/broadcast
+ * packets does not do anything with these packets. Therefore the
+ * reception of these unwanted packets causes unnecessary processing
+ * and power consumption.
+ *
+ * Packet coalesce feature helps to reduce number of received interrupts
+ * to host by buffering these packets in firmware/hardware for some
+ * predefined time. Received interrupt will be generated when one of the
+ * following events occur.
+ * a) Expiration of hardware timer whose expiration time is set to maximum
+ * coalescing delay of matching coalesce rule.
+ * b) Coalescing buffer in hardware reaches it's limit.
+ * c) Packet doesn't match any of the configured coalesce rules.
+ *
+ * User needs to configure following parameters for creating a coalesce
+ * rule.
+ * a) Maximum coalescing delay
+ * b) List of packet patterns which needs to be matched
+ * c) Condition for coalescence. pattern 'match' or 'no match'
+ * Multiple such rules can be created.
+ */
+
+/**
  * enum nl80211_commands - supported nl80211 commands
  *
  * @NL80211_CMD_UNSPEC: unspecified command to catch errors
@@ -276,8 +303,9 @@
  * passed, all channels allowed for the current regulatory domain
  * are used.  Extra IEs can also be passed from the userspace by
  * using the %NL80211_ATTR_IE attribute.
- * @NL80211_CMD_STOP_SCHED_SCAN: stop a scheduled scan.  Returns -ENOENT
- * if scheduled scan is not running.
+ * @NL80211_CMD_STOP_SCHED_SCAN: stop a scheduled scan. Returns -ENOENT if
+ * scheduled scan is not running. The caller may assume that as soon
+ * as the call returns, it is safe to start a new scheduled scan again.
  * @NL80211_CMD_SCHED_SCAN_RESULTS: indicates that there are scheduled scan
  * results available.
  * @NL80211_CMD_SCHED_SCAN_STOPPED: indicates that the scheduled scan has
@@ -391,8 +419,18 @@
  * %NL80211_ATTR_SSID attribute, and can optionally specify the association
  * IEs in %NL80211_ATTR_IE, %NL80211_ATTR_AUTH_TYPE, %NL80211_ATTR_USE_MFP,
  * %NL80211_ATTR_MAC, %NL80211_ATTR_WIPHY_FREQ, %NL80211_ATTR_CONTROL_PORT,
- * %NL80211_ATTR_CONTROL_PORT_ETHERTYPE and
- * %NL80211_ATTR_CONTROL_PORT_NO_ENCRYPT.
+ * %NL80211_ATTR_CONTROL_PORT_ETHERTYPE,
+ * %NL80211_ATTR_CONTROL_PORT_NO_ENCRYPT, %NL80211_ATTR_MAC_HINT, and
+ * %NL80211_ATTR_WIPHY_FREQ_HINT.
+ * If included, %NL80211_ATTR_MAC and %NL80211_ATTR_WIPHY_FREQ are
+ * restrictions on BSS selection, i.e., they effectively prevent roaming
+ * within the ESS. %NL80211_ATTR_MAC_HINT and %NL80211_ATTR_WIPHY_FREQ_HINT
+ * can be included to provide a recommendation of the initial BSS while
+ * allowing the driver to roam to other BSSes within the ESS and also to
+ * ignore this recommendation if the indicated BSS is not ideal. Only one
+ * set of BSSID,frequency parameters is used (i.e., either the enforcing
+ * %NL80211_ATTR_MAC,%NL80211_ATTR_WIPHY_FREQ or the less strict
+ * %NL80211_ATTR_MAC_HINT and %NL80211_ATTR_WIPHY_FREQ_HINT).
  * Background scan period can optionally be
  * specified in %NL80211_ATTR_BG_SCAN_PERIOD,
  * if not specified default background scan configuration
@@ -465,6 +503,9 @@
  * TX status event pertaining to the TX request.
  * %NL80211_ATTR_TX_NO_CCK_RATE is used to decide whether to send the
  * management frames at CCK rate or not in 2GHz band.
+ * %NL80211_ATTR_CSA_C_OFFSETS_TX is an array of offsets to CSA
+ * counters which will be updated to the current value. This attribute
+ * is used during CSA period.
  * @NL80211_CMD_FRAME_WAIT_CANCEL: When an off-channel TX was requested, this
  * command may be used with the corresponding cookie to cancel the wait
  * time if it is known that it is no longer necessary.
@@ -554,7 +595,14 @@
  * operation, %NL80211_ATTR_MAC contains the peer MAC address, and
  * %NL80211_ATTR_REASON_CODE the reason code to be used (only with
  * %NL80211_TDLS_TEARDOWN).
- * @NL80211_CMD_TDLS_MGMT: Send a TDLS management frame.
+ * @NL80211_CMD_TDLS_MGMT: Send a TDLS management frame. The
+ * %NL80211_ATTR_TDLS_ACTION attribute determines the type of frame to be
+ * sent. Public Action codes (802.11-2012 8.1.5.1) will be sent as
+ * 802.11 management frames, while TDLS action codes (802.11-2012
+ * 8.5.13.1) will be encapsulated and sent as data frames. The currently
+ * supported Public Action code is %WLAN_PUB_ACTION_TDLS_DISCOVER_RES
+ * and the currently supported TDLS actions codes are given in
+ * &enum ieee80211_tdls_actioncode.
  *
  * @NL80211_CMD_UNEXPECTED_FRAME: Used by an application controlling an AP
  * (or GO) interface (i.e. hostapd) to ask for unexpected frames to
@@ -646,6 +694,34 @@
  * @NL80211_CMD_CRIT_PROTOCOL_STOP: Indicates the connection reliability can
  * return back to normal.
  *
+ * @NL80211_CMD_GET_COALESCE: Get currently supported coalesce rules.
+ * @NL80211_CMD_SET_COALESCE: Configure coalesce rules or clear existing rules.
+ *
+ * @NL80211_CMD_CHANNEL_SWITCH: Perform a channel switch by announcing the
+ * the new channel information (Channel Switch Announcement - CSA)
+ * in the beacon for some time (as defined in the
+ * %NL80211_ATTR_CH_SWITCH_COUNT parameter) and then change to the
+ * new channel. Userspace provides the new channel information (using
+ * %NL80211_ATTR_WIPHY_FREQ and the attributes determining channel
+ * width). %NL80211_ATTR_CH_SWITCH_BLOCK_TX may be supplied to inform
+ * other station that transmission must be blocked until the channel
+ * switch is complete.
+ *
+ * @NL80211_CMD_VENDOR: Vendor-specified command/event. The command is specified
+ * by the %NL80211_ATTR_VENDOR_ID attribute and a sub-command in
+ * %NL80211_ATTR_VENDOR_SUBCMD. Parameter(s) can be transported in
+ * %NL80211_ATTR_VENDOR_DATA.
+ * For feature advertisement, the %NL80211_ATTR_VENDOR_DATA attribute is
+ * used in the wiphy data as a nested attribute containing descriptions
+ * (&struct nl80211_vendor_cmd_info) of the supported vendor commands.
+ * This may also be sent as an event with the same attributes.
+ *
+ * @NL80211_CMD_SET_QOS_MAP: Set Interworking QoS mapping for IP DSCP values.
+ * The QoS mapping information is included in %NL80211_ATTR_QOS_MAP. If
+ * that attribute is not included, QoS mapping is disabled. Since this
+ * QoS mapping is relevant for IP packets, it is only valid during an
+ * association. This is cleared on disassociation and AP restart.
+ *
  * @NL80211_CMD_MAX: highest used command number
  * @__NL80211_CMD_AFTER_LAST: internal use
  */
@@ -808,6 +884,15 @@ enum nl80211_commands {
  NL80211_CMD_CRIT_PROTOCOL_START,
  NL80211_CMD_CRIT_PROTOCOL_STOP,
 
+ NL80211_CMD_GET_COALESCE,
+ NL80211_CMD_SET_COALESCE,
+
+ NL80211_CMD_CHANNEL_SWITCH,
+
+ NL80211_CMD_VENDOR,
+
+ NL80211_CMD_SET_QOS_MAP,
+
  /* add new commands above here */
 
  /* used to define NL80211_CMD_MAX below */
@@ -943,7 +1028,7 @@ enum nl80211_commands {
  *  to query the CRDA to retrieve one regulatory domain. This attribute can
  *  also be used by userspace to query the kernel for the currently set
  *  regulatory domain. We chose an alpha2 as that is also used by the
- *  IEEE-802.11d country information element to identify a country.
+ *  IEEE-802.11 country information element to identify a country.
  *  Users can also simply ask the wireless core to set regulatory domain
  *  to a specific alpha2.
  * @NL80211_ATTR_REG_RULES: a nested array of regulatory domain regulatory
@@ -1429,6 +1514,83 @@ enum nl80211_commands {
  * @NL80211_ATTR_MAX_CRIT_PROT_DURATION: duration in milliseconds in which
  *      the connection should have increased reliability (u16).
  *
+ * @NL80211_ATTR_PEER_AID: Association ID for the peer TDLS station (u16).
+ * This is similar to @NL80211_ATTR_STA_AID but with a difference of being
+ * allowed to be used with the first @NL80211_CMD_SET_STATION command to
+ * update a TDLS peer STA entry.
+ *
+ * @NL80211_ATTR_COALESCE_RULE: Coalesce rule information.
+ *
+ * @NL80211_ATTR_CH_SWITCH_COUNT: u32 attribute specifying the number of TBTT's
+ * until the channel switch event.
+ * @NL80211_ATTR_CH_SWITCH_BLOCK_TX: flag attribute specifying that transmission
+ * must be blocked on the current channel (before the channel switch
+ * operation).
+ * @NL80211_ATTR_CSA_IES: Nested set of attributes containing the IE information
+ * for the time while performing a channel switch.
+ * @NL80211_ATTR_CSA_C_OFF_BEACON: An array of offsets (u16) to the channel
+ * switch counters in the beacons tail (%NL80211_ATTR_BEACON_TAIL).
+ * @NL80211_ATTR_CSA_C_OFF_PRESP: An array of offsets (u16) to the channel
+ * switch counters in the probe response (%NL80211_ATTR_PROBE_RESP).
+ *
+ * @NL80211_ATTR_RXMGMT_FLAGS: flags for nl80211_send_mgmt(), u32.
+ * As specified in the &enum nl80211_rxmgmt_flags.
+ *
+ * @NL80211_ATTR_STA_SUPPORTED_CHANNELS: array of supported channels.
+ *
+ * @NL80211_ATTR_STA_SUPPORTED_OPER_CLASSES: array of supported
+ *      supported operating classes.
+ *
+ * @NL80211_ATTR_HANDLE_DFS: A flag indicating whether user space
+ * controls DFS operation in IBSS mode. If the flag is included in
+ * %NL80211_CMD_JOIN_IBSS request, the driver will allow use of DFS
+ * channels and reports radar events to userspace. Userspace is required
+ * to react to radar events, e.g. initiate a channel switch or leave the
+ * IBSS network.
+ *
+ * @NL80211_ATTR_SUPPORT_5_MHZ: A flag indicating that the device supports
+ * 5 MHz channel bandwidth.
+ * @NL80211_ATTR_SUPPORT_10_MHZ: A flag indicating that the device supports
+ * 10 MHz channel bandwidth.
+ *
+ * @NL80211_ATTR_OPMODE_NOTIF: Operating mode field from Operating Mode
+ * Notification Element based on association request when used with
+ * %NL80211_CMD_NEW_STATION; u8 attribute.
+ *
+ * @NL80211_ATTR_VENDOR_ID: The vendor ID, either a 24-bit OUI or, if
+ * %NL80211_VENDOR_ID_IS_LINUX is set, a special Linux ID (not used yet)
+ * @NL80211_ATTR_VENDOR_SUBCMD: vendor sub-command
+ * @NL80211_ATTR_VENDOR_DATA: data for the vendor command, if any; this
+ * attribute is also used for vendor command feature advertisement
+ * @NL80211_ATTR_VENDOR_EVENTS: used for event list advertising in the wiphy
+ * info, containing a nested array of possible events
+ *
+ * @NL80211_ATTR_QOS_MAP: IP DSCP mapping for Interworking QoS mapping. This
+ * data is in the format defined for the payload of the QoS Map Set element
+ * in IEEE Std 802.11-2012, 8.4.2.97.
+ *
+ * @NL80211_ATTR_MAC_HINT: MAC address recommendation as initial BSS
+ * @NL80211_ATTR_WIPHY_FREQ_HINT: frequency of the recommended initial BSS
+ *
+ * @NL80211_ATTR_MAX_AP_ASSOC_STA: Device attribute that indicates how many
+ * associated stations are supported in AP mode (including P2P GO); u32.
+ * Since drivers may not have a fixed limit on the maximum number (e.g.,
+ * other concurrent operations may affect this), drivers are allowed to
+ * advertise values that cannot always be met. In such cases, an attempt
+ * to add a new station entry with @NL80211_CMD_NEW_STATION may fail.
+ *
+ * @NL80211_ATTR_CSA_C_OFFSETS_TX: An array of csa counter offsets (u16) which
+ * should be updated when the frame is transmitted.
+ * @NL80211_ATTR_MAX_CSA_COUNTERS: U8 attribute used to advertise the maximum
+ * supported number of csa counters.
+ *
+ * @NL80211_ATTR_TDLS_PEER_CAPABILITY: flags for TDLS peer capabilities, u32.
+ * As specified in the &enum nl80211_tdls_peer_capability.
+ *
+ * @NL80211_ATTR_IFACE_SOCKET_OWNER: flag attribute, if set during interface
+ * creation then the new interface will be owned by the netlink socket
+ * that created it and will be destroyed when the socket is closed
+ *
  * @NL80211_ATTR_MAX: highest attribute number currently defined
  * @__NL80211_ATTR_AFTER_LAST: internal use
  */
@@ -1727,6 +1889,48 @@ enum nl80211_attrs {
  NL80211_ATTR_CRIT_PROT_ID,
  NL80211_ATTR_MAX_CRIT_PROT_DURATION,
 
+ NL80211_ATTR_PEER_AID,
+
+ NL80211_ATTR_COALESCE_RULE,
+
+ NL80211_ATTR_CH_SWITCH_COUNT,
+ NL80211_ATTR_CH_SWITCH_BLOCK_TX,
+ NL80211_ATTR_CSA_IES,
+ NL80211_ATTR_CSA_C_OFF_BEACON,
+ NL80211_ATTR_CSA_C_OFF_PRESP,
+
+ NL80211_ATTR_RXMGMT_FLAGS,
+
+ NL80211_ATTR_STA_SUPPORTED_CHANNELS,
+
+ NL80211_ATTR_STA_SUPPORTED_OPER_CLASSES,
+
+ NL80211_ATTR_HANDLE_DFS,
+
+ NL80211_ATTR_SUPPORT_5_MHZ,
+ NL80211_ATTR_SUPPORT_10_MHZ,
+
+ NL80211_ATTR_OPMODE_NOTIF,
+
+ NL80211_ATTR_VENDOR_ID,
+ NL80211_ATTR_VENDOR_SUBCMD,
+ NL80211_ATTR_VENDOR_DATA,
+ NL80211_ATTR_VENDOR_EVENTS,
+
+ NL80211_ATTR_QOS_MAP,
+
+ NL80211_ATTR_MAC_HINT,
+ NL80211_ATTR_WIPHY_FREQ_HINT,
+
+ NL80211_ATTR_MAX_AP_ASSOC_STA,
+
+ NL80211_ATTR_TDLS_PEER_CAPABILITY,
+
+ NL80211_ATTR_IFACE_SOCKET_OWNER,
+
+ NL80211_ATTR_CSA_C_OFFSETS_TX,
+ NL80211_ATTR_MAX_CSA_COUNTERS,
+
  /* add attributes here, update the policy in nl80211.c */
 
  __NL80211_ATTR_AFTER_LAST,
@@ -1991,6 +2195,12 @@ enum nl80211_sta_bss_param {
  * @NL80211_STA_INFO_PEER_PM: peer mesh STA link-specific power mode
  * @NL80211_STA_INFO_NONPEER_PM: neighbor mesh STA power save mode towards
  * non-peer STA
+ * @NL80211_STA_INFO_CHAIN_SIGNAL: per-chain signal strength of last PPDU
+ * Contains a nested array of signal strength attributes (u8, dBm)
+ * @NL80211_STA_INFO_CHAIN_SIGNAL_AVG: per-chain signal strength average
+ * Same format as NL80211_STA_INFO_CHAIN_SIGNAL.
+ * @NL80211_STA_EXPECTED_THROUGHPUT: expected throughput considering also the
+ * 802.11 header (u32, kbps)
  * @__NL80211_STA_INFO_AFTER_LAST: internal
  * @NL80211_STA_INFO_MAX: highest possible station info attribute
  */
@@ -2020,6 +2230,9 @@ enum nl80211_sta_info {
  NL80211_STA_INFO_NONPEER_PM,
  NL80211_STA_INFO_RX_BYTES64,
  NL80211_STA_INFO_TX_BYTES64,
+ NL80211_STA_INFO_CHAIN_SIGNAL,
+ NL80211_STA_INFO_CHAIN_SIGNAL_AVG,
+ NL80211_STA_INFO_EXPECTED_THROUGHPUT,
 
  /* keep last */
  __NL80211_STA_INFO_AFTER_LAST,
@@ -2121,10 +2334,9 @@ enum nl80211_band_attr {
  * @NL80211_FREQUENCY_ATTR_FREQ: Frequency in MHz
  * @NL80211_FREQUENCY_ATTR_DISABLED: Channel is disabled in current
  * regulatory domain.
- * @NL80211_FREQUENCY_ATTR_PASSIVE_SCAN: Only passive scanning is
- * permitted on this channel in current regulatory domain.
- * @NL80211_FREQUENCY_ATTR_NO_IBSS: IBSS networks are not permitted
- * on this channel in current regulatory domain.
+ * @NL80211_FREQUENCY_ATTR_NO_IR: no mechanisms that initiate radiation
+ *  are permitted on this channel, this includes sending probe
+ *  requests, or modes of operation that require beaconing.
  * @NL80211_FREQUENCY_ATTR_RADAR: Radar detection is mandatory
  * on this channel in current regulatory domain.
  * @NL80211_FREQUENCY_ATTR_MAX_TX_POWER: Maximum transmission power in mBm
@@ -2143,16 +2355,42 @@ enum nl80211_band_attr {
  * @NL80211_FREQUENCY_ATTR_NO_160MHZ: any 160 MHz (but not 80+80) channel
  * using this channel as the primary or any of the secondary channels
  * isn't possible
+ * @NL80211_FREQUENCY_ATTR_DFS_CAC_TIME: DFS CAC time in milliseconds.
+ * @NL80211_FREQUENCY_ATTR_INDOOR_ONLY: Only indoor use is permitted on this
+ * channel. A channel that has the INDOOR_ONLY attribute can only be
+ * used when there is a clear assessment that the device is operating in
+ * an indoor surroundings, i.e., it is connected to AC power (and not
+ * through portable DC inverters) or is under the control of a master
+ * that is acting as an AP and is connected to AC power.
+ * @NL80211_FREQUENCY_ATTR_GO_CONCURRENT: GO operation is allowed on this
+ * channel if it's connected concurrently to a BSS on the same channel on
+ * the 2 GHz band or to a channel in the same UNII band (on the 5 GHz
+ * band), and IEEE80211_CHAN_RADAR is not set. Instantiating a GO on a
+ * channel that has the GO_CONCURRENT attribute set can be done when there
+ * is a clear assessment that the device is operating under the guidance of
+ * an authorized master, i.e., setting up a GO while the device is also
+ * connected to an AP with DFS and radar detection on the UNII band (it is
+ * up to user-space, i.e., wpa_supplicant to perform the required
+ * verifications)
+ * @NL80211_FREQUENCY_ATTR_NO_20MHZ: 20 MHz operation is not allowed
+ * on this channel in current regulatory domain.
+ * @NL80211_FREQUENCY_ATTR_NO_10MHZ: 10 MHz operation is not allowed
+ * on this channel in current regulatory domain.
  * @NL80211_FREQUENCY_ATTR_MAX: highest frequency attribute number
  * currently defined
  * @__NL80211_FREQUENCY_ATTR_AFTER_LAST: internal use
+ *
+ * See https://apps.fcc.gov/eas/comments/GetPublishedDocument.html?id=327&tn=528122
+ * for more information on the FCC description of the relaxations allowed
+ * by NL80211_FREQUENCY_ATTR_INDOOR_ONLY and
+ * NL80211_FREQUENCY_ATTR_GO_CONCURRENT.
  */
 enum nl80211_frequency_attr {
  __NL80211_FREQUENCY_ATTR_INVALID,
  NL80211_FREQUENCY_ATTR_FREQ,
  NL80211_FREQUENCY_ATTR_DISABLED,
- NL80211_FREQUENCY_ATTR_PASSIVE_SCAN,
- NL80211_FREQUENCY_ATTR_NO_IBSS,
+ NL80211_FREQUENCY_ATTR_NO_IR,
+ __NL80211_FREQUENCY_ATTR_NO_IBSS,
  NL80211_FREQUENCY_ATTR_RADAR,
  NL80211_FREQUENCY_ATTR_MAX_TX_POWER,
  NL80211_FREQUENCY_ATTR_DFS_STATE,
@@ -2161,6 +2399,11 @@ enum nl80211_frequency_attr {
  NL80211_FREQUENCY_ATTR_NO_HT40_PLUS,
  NL80211_FREQUENCY_ATTR_NO_80MHZ,
  NL80211_FREQUENCY_ATTR_NO_160MHZ,
+ NL80211_FREQUENCY_ATTR_DFS_CAC_TIME,
+ NL80211_FREQUENCY_ATTR_INDOOR_ONLY,
+ NL80211_FREQUENCY_ATTR_GO_CONCURRENT,
+ NL80211_FREQUENCY_ATTR_NO_20MHZ,
+ NL80211_FREQUENCY_ATTR_NO_10MHZ,
 
  /* keep last */
  __NL80211_FREQUENCY_ATTR_AFTER_LAST,
@@ -2168,6 +2411,9 @@ enum nl80211_frequency_attr {
 };
 
 #define NL80211_FREQUENCY_ATTR_MAX_TX_POWER NL80211_FREQUENCY_ATTR_MAX_TX_POWER
+#define NL80211_FREQUENCY_ATTR_PASSIVE_SCAN NL80211_FREQUENCY_ATTR_NO_IR
+#define NL80211_FREQUENCY_ATTR_NO_IBSS  NL80211_FREQUENCY_ATTR_NO_IR
+#define NL80211_FREQUENCY_ATTR_NO_IR  NL80211_FREQUENCY_ATTR_NO_IR
 
 /**
  * enum nl80211_bitrate_attr - bitrate attributes
@@ -2248,12 +2494,14 @@ enum nl80211_reg_type {
  *  in KHz. This is not a center a frequency but an actual regulatory
  *  band edge.
  * @NL80211_ATTR_FREQ_RANGE_MAX_BW: maximum allowed bandwidth for this
- *  frequency range, in KHz.
+ * frequency range, in KHz.
  * @NL80211_ATTR_POWER_RULE_MAX_ANT_GAIN: the maximum allowed antenna gain
  *  for a given frequency range. The value is in mBi (100 * dBi).
  *  If you don't have one then don't send this.
  * @NL80211_ATTR_POWER_RULE_MAX_EIRP: the maximum allowed EIRP for
  *  a given frequency range. The value is in mBm (100 * dBm).
+ * @NL80211_ATTR_DFS_CAC_TIME: DFS CAC time in milliseconds.
+ * If not present or 0 default CAC time will be used.
  * @NL80211_REG_RULE_ATTR_MAX: highest regulatory rule attribute number
  * currently defined
  * @__NL80211_REG_RULE_ATTR_AFTER_LAST: internal use
@@ -2269,6 +2517,8 @@ enum nl80211_reg_rule_attr {
  NL80211_ATTR_POWER_RULE_MAX_ANT_GAIN,
  NL80211_ATTR_POWER_RULE_MAX_EIRP,
 
+ NL80211_ATTR_DFS_CAC_TIME,
+
  /* keep last */
  __NL80211_REG_RULE_ATTR_AFTER_LAST,
  NL80211_REG_RULE_ATTR_MAX = __NL80211_REG_RULE_ATTR_AFTER_LAST - 1
@@ -2278,9 +2528,15 @@ enum nl80211_reg_rule_attr {
  * enum nl80211_sched_scan_match_attr - scheduled scan match attributes
  * @__NL80211_SCHED_SCAN_MATCH_ATTR_INVALID: attribute number 0 is reserved
  * @NL80211_SCHED_SCAN_MATCH_ATTR_SSID: SSID to be used for matching,
- * only report BSS with matching SSID.
+ * only report BSS with matching SSID.
  * @NL80211_SCHED_SCAN_MATCH_ATTR_RSSI: RSSI threshold (in dBm) for reporting a
- * BSS in scan results. Filtering is turned off if not specified.
+ * BSS in scan results. Filtering is turned off if not specified. Note that
+ * if this attribute is in a match set of its own, then it is treated as
+ * the default value for all matchsets with an SSID, rather than being a
+ * matchset of its own without an RSSI filter. This is due to problems with
+ * how this API was implemented in the past. Also, due to the same problem,
+ * the only way to create a matchset with only an RSSI filter (with this
+ * attribute) is if there's only a single matchset with the RSSI attribute.
  * @NL80211_SCHED_SCAN_MATCH_ATTR_MAX: highest scheduled scan filter
  * attribute number currently defined
  * @__NL80211_SCHED_SCAN_MATCH_ATTR_AFTER_LAST: internal use
@@ -2310,8 +2566,12 @@ enum nl80211_sched_scan_match_attr {
  * @NL80211_RRF_DFS: DFS support is required to be used
  * @NL80211_RRF_PTP_ONLY: this is only for Point To Point links
  * @NL80211_RRF_PTMP_ONLY: this is only for Point To Multi Point links
- * @NL80211_RRF_PASSIVE_SCAN: passive scan is required
- * @NL80211_RRF_NO_IBSS: no IBSS is allowed
+ * @NL80211_RRF_NO_IR: no mechanisms that initiate radiation are allowed,
+ *  this includes probe requests or modes of operation that require
+ *  beaconing.
+ * @NL80211_RRF_AUTO_BW: maximum available bandwidth should be calculated
+ * base on contiguous rules and wider channels will be allowed to cross
+ * multiple contiguous/overlapping frequency ranges.
  */
 enum nl80211_reg_rule_flags {
  NL80211_RRF_NO_OFDM  = 1<<0,
@@ -2321,10 +2581,18 @@ enum nl80211_reg_rule_flags {
  NL80211_RRF_DFS   = 1<<4,
  NL80211_RRF_PTP_ONLY  = 1<<5,
  NL80211_RRF_PTMP_ONLY  = 1<<6,
- NL80211_RRF_PASSIVE_SCAN = 1<<7,
- NL80211_RRF_NO_IBSS  = 1<<8,
+ NL80211_RRF_NO_IR  = 1<<7,
+ __NL80211_RRF_NO_IBSS  = 1<<8,
+ NL80211_RRF_AUTO_BW  = 1<<11,
 };
 
+#define NL80211_RRF_PASSIVE_SCAN NL80211_RRF_NO_IR
+#define NL80211_RRF_NO_IBSS  NL80211_RRF_NO_IR
+#define NL80211_RRF_NO_IR  NL80211_RRF_NO_IR
+
+/* For backport compatibility with older userspace */
+#define NL80211_RRF_NO_IR_ALL  (NL80211_RRF_NO_IR | __NL80211_RRF_NO_IBSS)
+
 /**
  * enum nl80211_dfs_regions - regulatory DFS regions
  *
@@ -2354,10 +2622,13 @@ enum nl80211_dfs_regions {
  * present has been registered with the wireless core that
  * has listed NL80211_FEATURE_CELL_BASE_REG_HINTS as a
  * supported feature.
+ * @NL80211_USER_REG_HINT_INDOOR: a user sent an hint indicating that the
+ * platform is operating in an indoor environment.
  */
 enum nl80211_user_reg_hint_type {
  NL80211_USER_REG_HINT_USER = 0,
  NL80211_USER_REG_HINT_CELL_BASE = 1,
+ NL80211_USER_REG_HINT_INDOOR    = 2,
 };
 
 /**
@@ -2413,6 +2684,8 @@ enum nl80211_survey_info {
  * @NL80211_MNTR_FLAG_OTHER_BSS: disable BSSID filtering
  * @NL80211_MNTR_FLAG_COOK_FRAMES: report frames after processing.
  * overrides all other flags.
+ * @NL80211_MNTR_FLAG_ACTIVE: use the configured MAC address
+ * and ACK incoming unicast packets.
  *
  * @__NL80211_MNTR_FLAG_AFTER_LAST: internal use
  * @NL80211_MNTR_FLAG_MAX: highest possible monitor flag
@@ -2424,6 +2697,7 @@ enum nl80211_mntr_flags {
  NL80211_MNTR_FLAG_CONTROL,
  NL80211_MNTR_FLAG_OTHER_BSS,
  NL80211_MNTR_FLAG_COOK_FRAMES,
+ NL80211_MNTR_FLAG_ACTIVE,
 
  /* keep last */
  __NL80211_MNTR_FLAG_AFTER_LAST,
@@ -2559,6 +2833,10 @@ enum nl80211_mesh_power_mode {
  *
  * @NL80211_MESHCONF_AWAKE_WINDOW: awake window duration (in TUs)
  *
+ * @NL80211_MESHCONF_PLINK_TIMEOUT: If no tx activity is seen from a STA we've
+ * established peering with for longer than this time (in seconds), then
+ * remove it from the STA's list of peers.  Default is 30 minutes.
+ *
  * @__NL80211_MESHCONF_ATTR_AFTER_LAST: internal use
  */
 enum nl80211_meshconf_params {
@@ -2590,6 +2868,7 @@ enum nl80211_meshconf_params {
  NL80211_MESHCONF_HWMP_CONFIRMATION_INTERVAL,
  NL80211_MESHCONF_POWER_MODE,
  NL80211_MESHCONF_AWAKE_WINDOW,
+ NL80211_MESHCONF_PLINK_TIMEOUT,
 
  /* keep last */
  __NL80211_MESHCONF_ATTR_AFTER_LAST,
@@ -2637,6 +2916,10 @@ enum nl80211_meshconf_params {
  * @NL80211_MESH_SETUP_USERSPACE_MPM: Enable this option if userspace will
  * implement an MPM which handles peer allocation and state.
  *
+ * @NL80211_MESH_SETUP_AUTH_PROTOCOL: Inform the kernel of the authentication
+ * method (u8, as defined in IEEE 8.4.2.100.6, e.g. 0x1 for SAE).
+ * Default is no authentication method required.
+ *
  * @NL80211_MESH_SETUP_ATTR_MAX: highest possible mesh setup attribute number
  *
  * @__NL80211_MESH_SETUP_ATTR_AFTER_LAST: Internal use
@@ -2650,6 +2933,7 @@ enum nl80211_mesh_setup_params {
  NL80211_MESH_SETUP_USERSPACE_AMPE,
  NL80211_MESH_SETUP_ENABLE_VENDOR_SYNC,
  NL80211_MESH_SETUP_USERSPACE_MPM,
+ NL80211_MESH_SETUP_AUTH_PROTOCOL,
 
  /* keep last */
  __NL80211_MESH_SETUP_ATTR_AFTER_LAST,
@@ -2730,6 +3014,8 @@ enum nl80211_channel_type {
  * and %NL80211_ATTR_CENTER_FREQ2 attributes must be provided as well
  * @NL80211_CHAN_WIDTH_160: 160 MHz channel, the %NL80211_ATTR_CENTER_FREQ1
  * attribute must be provided as well
+ * @NL80211_CHAN_WIDTH_5: 5 MHz OFDM channel
+ * @NL80211_CHAN_WIDTH_10: 10 MHz OFDM channel
  */
 enum nl80211_chan_width {
  NL80211_CHAN_WIDTH_20_NOHT,
@@ -2738,6 +3024,23 @@ enum nl80211_chan_width {
  NL80211_CHAN_WIDTH_80,
  NL80211_CHAN_WIDTH_80P80,
  NL80211_CHAN_WIDTH_160,
+ NL80211_CHAN_WIDTH_5,
+ NL80211_CHAN_WIDTH_10,
+};
+
+/**
+ * enum nl80211_bss_scan_width - control channel width for a BSS
+ *
+ * These values are used with the %NL80211_BSS_CHAN_WIDTH attribute.
+ *
+ * @NL80211_BSS_CHAN_WIDTH_20: control channel is 20 MHz wide or compatible
+ * @NL80211_BSS_CHAN_WIDTH_10: control channel is 10 MHz wide
+ * @NL80211_BSS_CHAN_WIDTH_5: control channel is 5 MHz wide
+ */
+enum nl80211_bss_scan_width {
+ NL80211_BSS_CHAN_WIDTH_20,
+ NL80211_BSS_CHAN_WIDTH_10,
+ NL80211_BSS_CHAN_WIDTH_5,
 };
 
 /**
@@ -2764,6 +3067,8 @@ enum nl80211_chan_width {
  * @NL80211_BSS_BEACON_IES: binary attribute containing the raw information
  * elements from a Beacon frame (bin); not present if no Beacon frame has
  * yet been received
+ * @NL80211_BSS_CHAN_WIDTH: channel width of the control channel
+ * (u32, enum nl80211_bss_scan_width)
  * @__NL80211_BSS_AFTER_LAST: internal
  * @NL80211_BSS_MAX: highest BSS attribute
  */
@@ -2780,6 +3085,7 @@ enum nl80211_bss {
  NL80211_BSS_STATUS,
  NL80211_BSS_SEEN_MS_AGO,
  NL80211_BSS_BEACON_IES,
+ NL80211_BSS_CHAN_WIDTH,
 
  /* keep last */
  __NL80211_BSS_AFTER_LAST,
@@ -2920,21 +3226,43 @@ enum nl80211_key_attributes {
  * in an array of rates as defined in IEEE 802.11 7.3.2.2 (u8 values with
  * 1 = 500 kbps) but without the IE length restriction (at most
  * %NL80211_MAX_SUPP_RATES in a single array).
- * @NL80211_TXRATE_MCS: HT (MCS) rates allowed for TX rate selection
+ * @NL80211_TXRATE_HT: HT (MCS) rates allowed for TX rate selection
  * in an array of MCS numbers.
+ * @NL80211_TXRATE_VHT: VHT rates allowed for TX rate selection,
+ * see &struct nl80211_txrate_vht
+ * @NL80211_TXRATE_GI: configure GI, see &enum nl80211_txrate_gi
  * @__NL80211_TXRATE_AFTER_LAST: internal
  * @NL80211_TXRATE_MAX: highest TX rate attribute
  */
 enum nl80211_tx_rate_attributes {
  __NL80211_TXRATE_INVALID,
  NL80211_TXRATE_LEGACY,
- NL80211_TXRATE_MCS,
+ NL80211_TXRATE_HT,
+ NL80211_TXRATE_VHT,
+ NL80211_TXRATE_GI,
 
  /* keep last */
  __NL80211_TXRATE_AFTER_LAST,
  NL80211_TXRATE_MAX = __NL80211_TXRATE_AFTER_LAST - 1
 };
 
+#define NL80211_TXRATE_MCS NL80211_TXRATE_HT
+#define NL80211_VHT_NSS_MAX  8
+
+/**
+ * struct nl80211_txrate_vht - VHT MCS/NSS txrate bitmap
+ * @mcs: MCS bitmap table for each NSS (array index 0 for 1 stream, etc.)
+ */
+struct nl80211_txrate_vht {
+ __u16 mcs[NL80211_VHT_NSS_MAX];
+};
+
+enum nl80211_txrate_gi {
+ NL80211_TXRATE_DEFAULT_GI,
+ NL80211_TXRATE_FORCE_SGI,
+ NL80211_TXRATE_FORCE_LGI,
+};
+
 /**
  * enum nl80211_band - Frequency band
  * @NL80211_BAND_2GHZ: 2.4 GHz ISM band
@@ -3028,11 +3356,11 @@ enum nl80211_tx_power_setting {
 };
 
 /**
- * enum nl80211_wowlan_packet_pattern_attr - WoWLAN packet pattern attribute
- * @__NL80211_WOWLAN_PKTPAT_INVALID: invalid number for nested attribute
- * @NL80211_WOWLAN_PKTPAT_PATTERN: the pattern, values where the mask has
+ * enum nl80211_packet_pattern_attr - packet pattern attribute
+ * @__NL80211_PKTPAT_INVALID: invalid number for nested attribute
+ * @NL80211_PKTPAT_PATTERN: the pattern, values where the mask has
  * a zero bit are ignored
- * @NL80211_WOWLAN_PKTPAT_MASK: pattern mask, must be long enough to have
+ * @NL80211_PKTPAT_MASK: pattern mask, must be long enough to have
  * a bit for each byte in the pattern. The lowest-order bit corresponds
  * to the first byte of the pattern, but the bytes of the pattern are
  * in a little-endian-like format, i.e. the 9th byte of the pattern
@@ -3043,39 +3371,50 @@ enum nl80211_tx_power_setting {
  * Note that the pattern matching is done as though frames were not
  * 802.11 frames but 802.3 frames, i.e. the frame is fully unpacked
  * first (including SNAP header unpacking) and then matched.
- * @NL80211_WOWLAN_PKTPAT_OFFSET: packet offset, pattern is matched after
+ * @NL80211_PKTPAT_OFFSET: packet offset, pattern is matched after
  * these fixed number of bytes of received packet
- * @NUM_NL80211_WOWLAN_PKTPAT: number of attributes
- * @MAX_NL80211_WOWLAN_PKTPAT: max attribute number
+ * @NUM_NL80211_PKTPAT: number of attributes
+ * @MAX_NL80211_PKTPAT: max attribute number
  */
-enum nl80211_wowlan_packet_pattern_attr {
- __NL80211_WOWLAN_PKTPAT_INVALID,
- NL80211_WOWLAN_PKTPAT_MASK,
- NL80211_WOWLAN_PKTPAT_PATTERN,
- NL80211_WOWLAN_PKTPAT_OFFSET,
-
- NUM_NL80211_WOWLAN_PKTPAT,
- MAX_NL80211_WOWLAN_PKTPAT = NUM_NL80211_WOWLAN_PKTPAT - 1,
+enum nl80211_packet_pattern_attr {
+ __NL80211_PKTPAT_INVALID,
+ NL80211_PKTPAT_MASK,
+ NL80211_PKTPAT_PATTERN,
+ NL80211_PKTPAT_OFFSET,
+
+ NUM_NL80211_PKTPAT,
+ MAX_NL80211_PKTPAT = NUM_NL80211_PKTPAT - 1,
 };
 
 /**
- * struct nl80211_wowlan_pattern_support - pattern support information
+ * struct nl80211_pattern_support - packet pattern support information
  * @max_patterns: maximum number of patterns supported
  * @min_pattern_len: minimum length of each pattern
  * @max_pattern_len: maximum length of each pattern
  * @max_pkt_offset: maximum Rx packet offset
  *
  * This struct is carried in %NL80211_WOWLAN_TRIG_PKT_PATTERN when
- * that is part of %NL80211_ATTR_WOWLAN_TRIGGERS_SUPPORTED in the
- * capability information given by the kernel to userspace.
+ * that is part of %NL80211_ATTR_WOWLAN_TRIGGERS_SUPPORTED or in
+ * %NL80211_ATTR_COALESCE_RULE_PKT_PATTERN when that is part of
+ * %NL80211_ATTR_COALESCE_RULE in the capability information given
+ * by the kernel to userspace.
  */
-struct nl80211_wowlan_pattern_support {
+struct nl80211_pattern_support {
  __u32 max_patterns;
  __u32 min_pattern_len;
  __u32 max_pattern_len;
  __u32 max_pkt_offset;
 } __attribute__((packed));
 
+/* only for backward compatibility */
+#define __NL80211_WOWLAN_PKTPAT_INVALID __NL80211_PKTPAT_INVALID
+#define NL80211_WOWLAN_PKTPAT_MASK NL80211_PKTPAT_MASK
+#define NL80211_WOWLAN_PKTPAT_PATTERN NL80211_PKTPAT_PATTERN
+#define NL80211_WOWLAN_PKTPAT_OFFSET NL80211_PKTPAT_OFFSET
+#define NUM_NL80211_WOWLAN_PKTPAT NUM_NL80211_PKTPAT
+#define MAX_NL80211_WOWLAN_PKTPAT MAX_NL80211_PKTPAT
+#define nl80211_wowlan_pattern_support nl80211_pattern_support
+
 /**
  * enum nl80211_wowlan_triggers - WoWLAN trigger definitions
  * @__NL80211_WOWLAN_TRIG_INVALID: invalid number for nested attributes
@@ -3095,7 +3434,7 @@ struct nl80211_wowlan_pattern_support {
  * pattern matching is done after the packet is converted to the MSDU.
  *
  * In %NL80211_ATTR_WOWLAN_TRIGGERS_SUPPORTED, it is a binary attribute
- * carrying a &struct nl80211_wowlan_pattern_support.
+ * carrying a &struct nl80211_pattern_support.
  *
  * When reporting wakeup. it is a u32 attribute containing the 0-based
  * index of the pattern that caused the wakeup, in the patterns passed
@@ -3252,7 +3591,7 @@ struct nl80211_wowlan_tcp_data_token_feature {
  * @NL80211_WOWLAN_TCP_WAKE_PAYLOAD: wake packet payload, for advertising a
  * u32 attribute holding the maximum length
  * @NL80211_WOWLAN_TCP_WAKE_MASK: Wake packet payload mask, not used for
- * feature advertising. The mask works like @NL80211_WOWLAN_PKTPAT_MASK
+ * feature advertising. The mask works like @NL80211_PKTPAT_MASK
  * but on the TCP payload only.
  * @NUM_NL80211_WOWLAN_TCP: number of TCP attributes
  * @MAX_NL80211_WOWLAN_TCP: highest attribute number
@@ -3277,6 +3616,55 @@ enum nl80211_wowlan_tcp_attrs {
 };
 
 /**
+ * struct nl80211_coalesce_rule_support - coalesce rule support information
+ * @max_rules: maximum number of rules supported
+ * @pat: packet pattern support information
+ * @max_delay: maximum supported coalescing delay in msecs
+ *
+ * This struct is carried in %NL80211_ATTR_COALESCE_RULE in the
+ * capability information given by the kernel to userspace.
+ */
+struct nl80211_coalesce_rule_support {
+ __u32 max_rules;
+ struct nl80211_pattern_support pat;
+ __u32 max_delay;
+} __attribute__((packed));
+
+/**
+ * enum nl80211_attr_coalesce_rule - coalesce rule attribute
+ * @__NL80211_COALESCE_RULE_INVALID: invalid number for nested attribute
+ * @NL80211_ATTR_COALESCE_RULE_DELAY: delay in msecs used for packet coalescing
+ * @NL80211_ATTR_COALESCE_RULE_CONDITION: condition for packet coalescence,
+ * see &enum nl80211_coalesce_condition.
+ * @NL80211_ATTR_COALESCE_RULE_PKT_PATTERN: packet offset, pattern is matched
+ * after these fixed number of bytes of received packet
+ * @NUM_NL80211_ATTR_COALESCE_RULE: number of attributes
+ * @NL80211_ATTR_COALESCE_RULE_MAX: max attribute number
+ */
+enum nl80211_attr_coalesce_rule {
+ __NL80211_COALESCE_RULE_INVALID,
+ NL80211_ATTR_COALESCE_RULE_DELAY,
+ NL80211_ATTR_COALESCE_RULE_CONDITION,
+ NL80211_ATTR_COALESCE_RULE_PKT_PATTERN,
+
+ /* keep last */
+ NUM_NL80211_ATTR_COALESCE_RULE,
+ NL80211_ATTR_COALESCE_RULE_MAX = NUM_NL80211_ATTR_COALESCE_RULE - 1
+};
+
+/**
+ * enum nl80211_coalesce_condition - coalesce rule conditions
+ * @NL80211_COALESCE_CONDITION_MATCH: coalaesce Rx packets when patterns
+ * in a rule are matched.
+ * @NL80211_COALESCE_CONDITION_NO_MATCH: coalesce Rx packets when patterns
+ * in a rule are not matched.
+ */
+enum nl80211_coalesce_condition {
+ NL80211_COALESCE_CONDITION_MATCH,
+ NL80211_COALESCE_CONDITION_NO_MATCH
+};
+
+/**
  * enum nl80211_iface_limit_attrs - limit attributes
  * @NL80211_IFACE_LIMIT_UNSPEC: (reserved)
  * @NL80211_IFACE_LIMIT_MAX: maximum number of interfaces that
@@ -3314,6 +3702,8 @@ enum nl80211_iface_limit_attrs {
  * different channels may be used within this group.
  * @NL80211_IFACE_COMB_RADAR_DETECT_WIDTHS: u32 attribute containing the bitmap
  * of supported channel widths for radar detection.
+ * @NL80211_IFACE_COMB_RADAR_DETECT_REGIONS: u32 attribute containing the bitmap
+ * of supported regulatory regions for radar detection.
  * @NUM_NL80211_IFACE_COMB: number of attributes
  * @MAX_NL80211_IFACE_COMB: highest attribute number
  *
@@ -3347,6 +3737,7 @@ enum nl80211_if_combination_attrs {
  NL80211_IFACE_COMB_STA_AP_BI_MATCH,
  NL80211_IFACE_COMB_NUM_CHANNELS,
  NL80211_IFACE_COMB_RADAR_DETECT_WIDTHS,
+ NL80211_IFACE_COMB_RADAR_DETECT_REGIONS,
 
  /* keep last */
  NUM_NL80211_IFACE_COMB,
@@ -3520,11 +3911,8 @@ enum nl80211_ap_sme_features {
  * @NL80211_FEATURE_CELL_BASE_REG_HINTS: This driver has been tested
  * to work properly to suppport receiving regulatory hints from
  * cellular base stations.
- * @NL80211_FEATURE_P2P_DEVICE_NEEDS_CHANNEL: If this is set, an active
- * P2P Device (%NL80211_IFTYPE_P2P_DEVICE) requires its own channel
- * in the interface combinations, even when it's only used for scan
- * and remain-on-channel. This could be due to, for example, the
- * remain-on-channel implementation requiring a channel context.
+ * @NL80211_FEATURE_P2P_DEVICE_NEEDS_CHANNEL: (no longer available, only
+ * here to reserve the value for API/ABI compatibility)
  * @NL80211_FEATURE_SAE: This driver supports simultaneous authentication of
  * equals (SAE) with user space SME (NL80211_CMD_AUTHENTICATE) in station
  * mode
@@ -3556,6 +3944,13 @@ enum nl80211_ap_sme_features {
  * Peering Management entity which may be implemented by registering for
  * beacons or NL80211_CMD_NEW_PEER_CANDIDATE events. The mesh beacon is
  * still generated by the driver.
+ * @NL80211_FEATURE_ACTIVE_MONITOR: This driver supports an active monitor
+ * interface. An active monitor interface behaves like a normal monitor
+ * interface, but gets added to the driver. It ensures that incoming
+ * unicast packets directed at the configured interface address get ACKed.
+ * @NL80211_FEATURE_AP_MODE_CHAN_WIDTH_CHANGE: This driver supports dynamic
+ * channel bandwidth change (e.g., HT 20 <-> 40 MHz channel) during the
+ * lifetime of a BSS.
  */
 enum nl80211_feature_flags {
  NL80211_FEATURE_SK_TX_STATUS   = 1 << 0,
@@ -3575,6 +3970,8 @@ enum nl80211_feature_flags {
  NL80211_FEATURE_ADVERTISE_CHAN_LIMITS  = 1 << 14,
  NL80211_FEATURE_FULL_AP_CLIENT_STATE  = 1 << 15,
  NL80211_FEATURE_USERSPACE_MPM   = 1 << 16,
+ NL80211_FEATURE_ACTIVE_MONITOR   = 1 << 17,
+ NL80211_FEATURE_AP_MODE_CHAN_WIDTH_CHANGE = 1 << 18,
 };
 
 /**
@@ -3675,13 +4072,12 @@ enum nl80211_radar_event {
  *
  * Channel states used by the DFS code.
  *
- * @IEEE80211_DFS_USABLE: The channel can be used, but channel availability
+ * @NL80211_DFS_USABLE: The channel can be used, but channel availability
  * check (CAC) must be performed before using it for AP or IBSS.
- * @IEEE80211_DFS_UNAVAILABLE: A radar has been detected on this channel, it
+ * @NL80211_DFS_UNAVAILABLE: A radar has been detected on this channel, it
  * is therefore marked as not available.
- * @IEEE80211_DFS_AVAILABLE: The channel has been CAC checked and is available.
+ * @NL80211_DFS_AVAILABLE: The channel has been CAC checked and is available.
  */
-
 enum nl80211_dfs_state {
  NL80211_DFS_USABLE,
  NL80211_DFS_UNAVAILABLE,
@@ -3721,4 +4117,51 @@ enum nl80211_crit_proto_id {
 /* maximum duration for critical protocol measures */
 #define NL80211_CRIT_PROTO_MAX_DURATION  5000 /* msec */
 
+/**
+ * enum nl80211_rxmgmt_flags - flags for received management frame.
+ *
+ * Used by cfg80211_rx_mgmt()
+ *
+ * @NL80211_RXMGMT_FLAG_ANSWERED: frame was answered by device/driver.
+ */
+enum nl80211_rxmgmt_flags {
+ NL80211_RXMGMT_FLAG_ANSWERED = 1 << 0,
+};
+
+/*
+ * If this flag is unset, the lower 24 bits are an OUI, if set
+ * a Linux nl80211 vendor ID is used (no such IDs are allocated
+ * yet, so that's not valid so far)
+ */
+#define NL80211_VENDOR_ID_IS_LINUX 0x80000000
+
+/**
+ * struct nl80211_vendor_cmd_info - vendor command data
+ * @vendor_id: If the %NL80211_VENDOR_ID_IS_LINUX flag is clear, then the
+ * value is a 24-bit OUI; if it is set then a separately allocated ID
+ * may be used, but no such IDs are allocated yet. New IDs should be
+ * added to this file when needed.
+ * @subcmd: sub-command ID for the command
+ */
+struct nl80211_vendor_cmd_info {
+ __u32 vendor_id;
+ __u32 subcmd;
+};
+
+/**
+ * enum nl80211_tdls_peer_capability - TDLS peer flags.
+ *
+ * Used by tdls_mgmt() to determine which conditional elements need
+ * to be added to TDLS Setup frames.
+ *
+ * @NL80211_TDLS_PEER_HT: TDLS peer is HT capable.
+ * @NL80211_TDLS_PEER_VHT: TDLS peer is VHT capable.
+ * @NL80211_TDLS_PEER_WMM: TDLS peer is WMM capable.
+ */
+enum nl80211_tdls_peer_capability {
+ NL80211_TDLS_PEER_HT = 1<<0,
+ NL80211_TDLS_PEER_VHT = 1<<1,
+ NL80211_TDLS_PEER_WMM = 1<<2,
+};
+
 #endif /* __LINUX_NL80211_H */
diff --git a/net/wireless/Kconfig b/net/wireless/Kconfig
index 16d08b3..405f3c4 100644
--- a/net/wireless/Kconfig
+++ b/net/wireless/Kconfig
@@ -95,6 +95,43 @@ config CFG80211_CERTIFICATION_ONUS
    you are a wireless researcher and are working in a controlled
    and approved environment by your local regulatory agency.
 
+config CFG80211_REG_CELLULAR_HINTS
+ bool "cfg80211 regulatory support for cellular base station hints"
+ depends on CFG80211_CERTIFICATION_ONUS
+ ---help---
+   This option enables support for parsing regulatory hints
+   from cellular base stations. If enabled and at least one driver
+   claims support for parsing cellular base station hints the
+   regulatory core will allow and parse these regulatory hints.
+   The regulatory core will only apply these regulatory hints on
+   drivers that support this feature. You should only enable this
+   feature if you have tested and validated this feature on your
+   systems.
+
+config CFG80211_REG_RELAX_NO_IR
+ bool "cfg80211 support for NO_IR relaxation"
+ depends on CFG80211_CERTIFICATION_ONUS
+ ---help---
+  This option enables support for relaxation of the NO_IR flag for
+  situations that certain regulatory bodies have provided clarifications
+  on how relaxation can occur. This feature has an inherent dependency on
+  userspace features which must have been properly tested and as such is
+  not enabled by default.
+
+  A relaxation feature example is allowing the operation of a P2P group
+  owner (GO) on channels marked with NO_IR if there is an additional BSS
+  interface which associated to an AP which userspace assumes or confirms
+  to be an authorized master, i.e., with radar detection support and DFS
+  capabilities. However, note that in order to not create daisy chain
+  scenarios, this relaxation is not allowed in cases that the BSS client
+  is associated to P2P GO and in addition the P2P GO instantiated on
+  a channel due to this relaxation should not allow connection from
+  non P2P clients.
+
+  The regulatory core will apply these relaxations only for drivers that
+  support this feature by declaring the appropriate channel flags and
+  capabilities in their registration flow.
+
 config CFG80211_DEFAULT_PS
  bool "enable powersave by default"
  depends on CFG80211
diff --git a/net/wireless/ap.c b/net/wireless/ap.c
index 324e8d8..bdad1f9 100644
--- a/net/wireless/ap.c
+++ b/net/wireless/ap.c
@@ -6,8 +6,8 @@
 #include "rdev-ops.h"
 
 
-static int __cfg80211_stop_ap(struct cfg80211_registered_device *rdev,
-         struct net_device *dev)
+int __cfg80211_stop_ap(struct cfg80211_registered_device *rdev,
+         struct net_device *dev, bool notify)
 {
  struct wireless_dev *wdev = dev->ieee80211_ptr;
  int err;
@@ -27,21 +27,24 @@ static int __cfg80211_stop_ap(struct cfg80211_registered_device *rdev,
  err = rdev_stop_ap(rdev, dev);
  if (!err) {
   wdev->beacon_interval = 0;
-  wdev->channel = NULL;
+  memset(&wdev->chandef, 0, sizeof(wdev->chandef));
   wdev->ssid_len = 0;
+  rdev_set_qos_map(rdev, dev, NULL);
+  if (notify)
+   nl80211_send_ap_stopped(wdev);
  }
 
  return err;
 }
 
 int cfg80211_stop_ap(struct cfg80211_registered_device *rdev,
-       struct net_device *dev)
+       struct net_device *dev, bool notify)
 {
  struct wireless_dev *wdev = dev->ieee80211_ptr;
  int err;
 
  wdev_lock(wdev);
- err = __cfg80211_stop_ap(rdev, dev);
+ err = __cfg80211_stop_ap(rdev, dev, notify);
  wdev_unlock(wdev);
 
  return err;
diff --git a/net/wireless/chan.c b/net/wireless/chan.c
index fd556ac..992b340 100644
--- a/net/wireless/chan.c
+++ b/net/wireless/chan.c
@@ -54,6 +54,8 @@ bool cfg80211_chandef_valid(const struct cfg80211_chan_def *chandef)
  control_freq = chandef->chan->center_freq;
 
  switch (chandef->width) {
+ case NL80211_CHAN_WIDTH_5:
+ case NL80211_CHAN_WIDTH_10:
  case NL80211_CHAN_WIDTH_20:
  case NL80211_CHAN_WIDTH_20_NOHT:
   if (chandef->center_freq1 != control_freq)
@@ -152,6 +154,12 @@ static int cfg80211_chandef_get_width(const struct cfg80211_chan_def *c)
  int width;
 
  switch (c->width) {
+ case NL80211_CHAN_WIDTH_5:
+  width = 5;
+  break;
+ case NL80211_CHAN_WIDTH_10:
+  width = 10;
+  break;
  case NL80211_CHAN_WIDTH_20:
  case NL80211_CHAN_WIDTH_20_NOHT:
   width = 20;
@@ -194,6 +202,16 @@ cfg80211_chandef_compatible(const struct cfg80211_chan_def *c1,
  if (c1->width == c2->width)
   return NULL;
 
+ /*
+  * can't be compatible if one of them is 5 or 10 MHz,
+  * but they don't have the same width.
+  */
+ if (c1->width == NL80211_CHAN_WIDTH_5 ||
+     c1->width == NL80211_CHAN_WIDTH_10 ||
+     c2->width == NL80211_CHAN_WIDTH_5 ||
+     c2->width == NL80211_CHAN_WIDTH_10)
+  return NULL;
+
  if (c1->width == NL80211_CHAN_WIDTH_20_NOHT ||
      c1->width == NL80211_CHAN_WIDTH_20)
   return c2;
@@ -259,16 +277,43 @@ void cfg80211_set_dfs_state(struct wiphy *wiphy,
          width, dfs_state);
 }
 
+static u32 cfg80211_get_start_freq(u32 center_freq,
+       u32 bandwidth)
+{
+ u32 start_freq;
+
+ if (bandwidth <= 20)
+  start_freq = center_freq;
+ else
+  start_freq = center_freq - bandwidth/2 + 10;
+
+ return start_freq;
+}
+
+static u32 cfg80211_get_end_freq(u32 center_freq,
+     u32 bandwidth)
+{
+ u32 end_freq;
+
+ if (bandwidth <= 20)
+  end_freq = center_freq;
+ else
+  end_freq = center_freq + bandwidth/2 - 10;
+
+ return end_freq;
+}
+
 static int cfg80211_get_chans_dfs_required(struct wiphy *wiphy,
          u32 center_freq,
          u32 bandwidth)
 {
  struct ieee80211_channel *c;
- u32 freq;
+ u32 freq, start_freq, end_freq;
 
- for (freq = center_freq - bandwidth/2 + 10;
-      freq <= center_freq + bandwidth/2 - 10;
-      freq += 20) {
+ start_freq = cfg80211_get_start_freq(center_freq, bandwidth);
+ end_freq = cfg80211_get_end_freq(center_freq, bandwidth);
+
+ for (freq = start_freq; freq <= end_freq; freq += 20) {
   c = ieee80211_get_channel(wiphy, freq);
   if (!c)
    return -EINVAL;
@@ -281,51 +326,269 @@ static int cfg80211_get_chans_dfs_required(struct wiphy *wiphy,
 
 
 int cfg80211_chandef_dfs_required(struct wiphy *wiphy,
-      const struct cfg80211_chan_def *chandef)
+      const struct cfg80211_chan_def *chandef,
+      enum nl80211_iftype iftype)
 {
  int width;
- int r;
+ int ret;
 
  if (WARN_ON(!cfg80211_chandef_valid(chandef)))
   return -EINVAL;
 
+ switch (iftype) {
+ case NL80211_IFTYPE_ADHOC:
+ case NL80211_IFTYPE_AP:
+ case NL80211_IFTYPE_P2P_GO:
+ case NL80211_IFTYPE_MESH_POINT:
+  width = cfg80211_chandef_get_width(chandef);
+  if (width < 0)
+   return -EINVAL;
+
+  ret = cfg80211_get_chans_dfs_required(wiphy,
+            chandef->center_freq1,
+            width);
+  if (ret < 0)
+   return ret;
+  else if (ret > 0)
+   return BIT(chandef->width);
+
+  if (!chandef->center_freq2)
+   return 0;
+
+  ret = cfg80211_get_chans_dfs_required(wiphy,
+            chandef->center_freq2,
+            width);
+  if (ret < 0)
+   return ret;
+  else if (ret > 0)
+   return BIT(chandef->width);
+
+  break;
+ case NL80211_IFTYPE_STATION:
+ case NL80211_IFTYPE_P2P_CLIENT:
+ case NL80211_IFTYPE_MONITOR:
+ case NL80211_IFTYPE_AP_VLAN:
+ case NL80211_IFTYPE_WDS:
+ case NL80211_IFTYPE_P2P_DEVICE:
+  break;
+ case NL80211_IFTYPE_UNSPECIFIED:
+ case NUM_NL80211_IFTYPES:
+  WARN_ON(1);
+ }
+
+ return 0;
+}
+EXPORT_SYMBOL(cfg80211_chandef_dfs_required);
+
+static int cfg80211_get_chans_dfs_usable(struct wiphy *wiphy,
+      u32 center_freq,
+      u32 bandwidth)
+{
+ struct ieee80211_channel *c;
+ u32 freq, start_freq, end_freq;
+ int count = 0;
+
+ start_freq = cfg80211_get_start_freq(center_freq, bandwidth);
+ end_freq = cfg80211_get_end_freq(center_freq, bandwidth);
+
+ /*
+  * Check entire range of channels for the bandwidth.
+  * Check all channels are DFS channels (DFS_USABLE or
+  * DFS_AVAILABLE). Return number of usable channels
+  * (require CAC). Allow DFS and non-DFS channel mix.
+  */
+ for (freq = start_freq; freq <= end_freq; freq += 20) {
+  c = ieee80211_get_channel(wiphy, freq);
+  if (!c)
+   return -EINVAL;
+
+  if (c->flags & IEEE80211_CHAN_DISABLED)
+   return -EINVAL;
+
+  if (c->flags & IEEE80211_CHAN_RADAR) {
+   if (c->dfs_state == NL80211_DFS_UNAVAILABLE)
+    return -EINVAL;
+
+   if (c->dfs_state == NL80211_DFS_USABLE)
+    count++;
+  }
+ }
+
+ return count;
+}
+
+bool cfg80211_chandef_dfs_usable(struct wiphy *wiphy,
+     const struct cfg80211_chan_def *chandef)
+{
+ int width;
+ int r1, r2 = 0;
+
+ if (WARN_ON(!cfg80211_chandef_valid(chandef)))
+  return false;
+
  width = cfg80211_chandef_get_width(chandef);
  if (width < 0)
-  return -EINVAL;
+  return false;
 
- r = cfg80211_get_chans_dfs_required(wiphy, chandef->center_freq1,
-         width);
- if (r)
-  return r;
+ r1 = cfg80211_get_chans_dfs_usable(wiphy, chandef->center_freq1,
+       width);
 
- if (!chandef->center_freq2)
-  return 0;
+ if (r1 < 0)
+  return false;
 
- return cfg80211_get_chans_dfs_required(wiphy, chandef->center_freq2,
-            width);
+ switch (chandef->width) {
+ case NL80211_CHAN_WIDTH_80P80:
+  WARN_ON(!chandef->center_freq2);
+  r2 = cfg80211_get_chans_dfs_usable(wiphy,
+         chandef->center_freq2,
+         width);
+  if (r2 < 0)
+   return false;
+  break;
+ default:
+  WARN_ON(chandef->center_freq2);
+  break;
+ }
+
+ return (r1 + r2 > 0);
 }
 
-static bool cfg80211_secondary_chans_ok(struct wiphy *wiphy,
-     u32 center_freq, u32 bandwidth,
-     u32 prohibited_flags)
+
+static bool cfg80211_get_chans_dfs_available(struct wiphy *wiphy,
+          u32 center_freq,
+          u32 bandwidth)
 {
  struct ieee80211_channel *c;
- u32 freq;
+ u32 freq, start_freq, end_freq;
 
- for (freq = center_freq - bandwidth/2 + 10;
-      freq <= center_freq + bandwidth/2 - 10;
-      freq += 20) {
+ start_freq = cfg80211_get_start_freq(center_freq, bandwidth);
+ end_freq = cfg80211_get_end_freq(center_freq, bandwidth);
+
+ /*
+  * Check entire range of channels for the bandwidth.
+  * If any channel in between is disabled or has not
+  * had gone through CAC return false
+  */
+ for (freq = start_freq; freq <= end_freq; freq += 20) {
   c = ieee80211_get_channel(wiphy, freq);
   if (!c)
    return false;
 
-  /* check for radar flags */
-  if ((prohibited_flags & c->flags & IEEE80211_CHAN_RADAR) &&
+  if (c->flags & IEEE80211_CHAN_DISABLED)
+   return false;
+
+  if ((c->flags & IEEE80211_CHAN_RADAR)  &&
       (c->dfs_state != NL80211_DFS_AVAILABLE))
    return false;
+ }
+
+ return true;
+}
+
+static bool cfg80211_chandef_dfs_available(struct wiphy *wiphy,
+    const struct cfg80211_chan_def *chandef)
+{
+ int width;
+ int r;
+
+ if (WARN_ON(!cfg80211_chandef_valid(chandef)))
+  return false;
+
+ width = cfg80211_chandef_get_width(chandef);
+ if (width < 0)
+  return false;
+
+ r = cfg80211_get_chans_dfs_available(wiphy, chandef->center_freq1,
+          width);
+
+ /* If any of channels unavailable for cf1 just return */
+ if (!r)
+  return r;
+
+ switch (chandef->width) {
+ case NL80211_CHAN_WIDTH_80P80:
+  WARN_ON(!chandef->center_freq2);
+  r = cfg80211_get_chans_dfs_available(wiphy,
+           chandef->center_freq2,
+           width);
+ default:
+  WARN_ON(chandef->center_freq2);
+  break;
+ }
+
+ return r;
+}
+
+static unsigned int cfg80211_get_chans_dfs_cac_time(struct wiphy *wiphy,
+          u32 center_freq,
+          u32 bandwidth)
+{
+ struct ieee80211_channel *c;
+ u32 start_freq, end_freq, freq;
+ unsigned int dfs_cac_ms = 0;
+
+ start_freq = cfg80211_get_start_freq(center_freq, bandwidth);
+ end_freq = cfg80211_get_end_freq(center_freq, bandwidth);
+
+ for (freq = start_freq; freq <= end_freq; freq += 20) {
+  c = ieee80211_get_channel(wiphy, freq);
+  if (!c)
+   return 0;
+
+  if (c->flags & IEEE80211_CHAN_DISABLED)
+   return 0;
+
+  if (!(c->flags & IEEE80211_CHAN_RADAR))
+   continue;
+
+  if (c->dfs_cac_ms > dfs_cac_ms)
+   dfs_cac_ms = c->dfs_cac_ms;
+ }
+
+ return dfs_cac_ms;
+}
+
+unsigned int
+cfg80211_chandef_dfs_cac_time(struct wiphy *wiphy,
+         const struct cfg80211_chan_def *chandef)
+{
+ int width;
+ unsigned int t1 = 0, t2 = 0;
+
+ if (WARN_ON(!cfg80211_chandef_valid(chandef)))
+  return 0;
+
+ width = cfg80211_chandef_get_width(chandef);
+ if (width < 0)
+  return 0;
+
+ t1 = cfg80211_get_chans_dfs_cac_time(wiphy,
+          chandef->center_freq1,
+          width);
+
+ if (!chandef->center_freq2)
+  return t1;
+
+ t2 = cfg80211_get_chans_dfs_cac_time(wiphy,
+          chandef->center_freq2,
+          width);
+
+ return max(t1, t2);
+}
+
+static bool cfg80211_secondary_chans_ok(struct wiphy *wiphy,
+     u32 center_freq, u32 bandwidth,
+     u32 prohibited_flags)
+{
+ struct ieee80211_channel *c;
+ u32 freq, start_freq, end_freq;
+
+ start_freq = cfg80211_get_start_freq(center_freq, bandwidth);
+ end_freq = cfg80211_get_end_freq(center_freq, bandwidth);
 
-  /* check for the other flags */
-  if (c->flags & prohibited_flags & ~IEEE80211_CHAN_RADAR)
+ for (freq = start_freq; freq <= end_freq; freq += 20) {
+  c = ieee80211_get_channel(wiphy, freq);
+  if (!c || c->flags & prohibited_flags)
    return false;
  }
 
@@ -349,10 +612,18 @@ bool cfg80211_chandef_usable(struct wiphy *wiphy,
  control_freq = chandef->chan->center_freq;
 
  switch (chandef->width) {
+ case NL80211_CHAN_WIDTH_5:
+  width = 5;
+  break;
+ case NL80211_CHAN_WIDTH_10:
+  prohibited_flags |= IEEE80211_CHAN_NO_10MHZ;
+  width = 10;
+  break;
  case NL80211_CHAN_WIDTH_20:
   if (!ht_cap->ht_supported)
    return false;
  case NL80211_CHAN_WIDTH_20_NOHT:
+  prohibited_flags |= IEEE80211_CHAN_NO_20MHZ;
   width = 20;
   break;
  case NL80211_CHAN_WIDTH_40:
@@ -405,6 +676,11 @@ bool cfg80211_chandef_usable(struct wiphy *wiphy,
  if (width > 20)
   prohibited_flags |= IEEE80211_CHAN_NO_OFDM;
 
+ /* 5 and 10 MHz are only defined for the OFDM PHY */
+ if (width < 20)
+  prohibited_flags |= IEEE80211_CHAN_NO_OFDM;
+
+
  if (!cfg80211_secondary_chans_ok(wiphy, chandef->center_freq1,
       width, prohibited_flags))
   return false;
@@ -416,18 +692,117 @@ bool cfg80211_chandef_usable(struct wiphy *wiphy,
 }
 EXPORT_SYMBOL(cfg80211_chandef_usable);
 
+/*
+ * For GO only, check if the channel can be used under permissive conditions
+ * mandated by the some regulatory bodies, i.e., the channel is marked with
+ * IEEE80211_CHAN_GO_CONCURRENT and there is an additional station interface
+ * associated to an AP on the same channel or on the same UNII band
+ * (assuming that the AP is an authorized master).
+ * In addition allow the GO to operate on a channel on which indoor operation is
+ * allowed, iff we are currently operating in an indoor environment.
+ */
+static bool cfg80211_go_permissive_chan(struct cfg80211_registered_device *rdev,
+     struct ieee80211_channel *chan)
+{
+ struct wireless_dev *wdev_iter;
+ struct wiphy *wiphy = wiphy_idx_to_wiphy(rdev->wiphy_idx);
+
+ ASSERT_RTNL();
+
+ if (!config_enabled(CONFIG_CFG80211_REG_RELAX_NO_IR) ||
+     !(wiphy->regulatory_flags & REGULATORY_ENABLE_RELAX_NO_IR))
+  return false;
+
+ if (regulatory_indoor_allowed() &&
+     (chan->flags & IEEE80211_CHAN_INDOOR_ONLY))
+  return true;
+
+ if (!(chan->flags & IEEE80211_CHAN_GO_CONCURRENT))
+  return false;
+
+ /*
+  * Generally, it is possible to rely on another device/driver to allow
+  * the GO concurrent relaxation, however, since the device can further
+  * enforce the relaxation (by doing a similar verifications as this),
+  * and thus fail the GO instantiation, consider only the interfaces of
+  * the current registered device.
+  */
+ list_for_each_entry(wdev_iter, &rdev->wdev_list, list) {
+  struct ieee80211_channel *other_chan = NULL;
+  int r1, r2;
+
+  if (wdev_iter->iftype != NL80211_IFTYPE_STATION ||
+      !netif_running(wdev_iter->netdev))
+   continue;
+
+  wdev_lock(wdev_iter);
+  if (wdev_iter->current_bss)
+   other_chan = wdev_iter->current_bss->pub.channel;
+  wdev_unlock(wdev_iter);
+
+  if (!other_chan)
+   continue;
+
+  if (chan == other_chan)
+   return true;
+
+  if (chan->band != IEEE80211_BAND_5GHZ)
+   continue;
+
+  r1 = cfg80211_get_unii(chan->center_freq);
+  r2 = cfg80211_get_unii(other_chan->center_freq);
+
+  if (r1 != -EINVAL && r1 == r2) {
+   /*
+    * At some locations channels 149-165 are considered a
+    * bundle, but at other locations, e.g., Indonesia,
+    * channels 149-161 are considered a bundle while
+    * channel 165 is left out and considered to be in a
+    * different bundle. Thus, in case that there is a
+    * station interface connected to an AP on channel 165,
+    * it is assumed that channels 149-161 are allowed for
+    * GO operations. However, having a station interface
+    * connected to an AP on channels 149-161, does not
+    * allow GO operation on channel 165.
+    */
+   if (chan->center_freq == 5825 &&
+       other_chan->center_freq != 5825)
+    continue;
+   return true;
+  }
+ }
+
+ return false;
+}
+
 bool cfg80211_reg_can_beacon(struct wiphy *wiphy,
-        struct cfg80211_chan_def *chandef)
+        struct cfg80211_chan_def *chandef,
+        enum nl80211_iftype iftype)
 {
+ struct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);
  bool res;
+ u32 prohibited_flags = IEEE80211_CHAN_DISABLED |
+          IEEE80211_CHAN_RADAR;
 
- trace_cfg80211_reg_can_beacon(wiphy, chandef);
+ trace_cfg80211_reg_can_beacon(wiphy, chandef, iftype);
 
- res = cfg80211_chandef_usable(wiphy, chandef,
-          IEEE80211_CHAN_DISABLED |
-          IEEE80211_CHAN_PASSIVE_SCAN |
-          IEEE80211_CHAN_NO_IBSS |
-          IEEE80211_CHAN_RADAR);
+ /*
+  * Under certain conditions suggested by the some regulatory bodies
+  * a GO can operate on channels marked with IEEE80211_NO_IR
+  * so set this flag only if such relaxations are not enabled and
+  * the conditions are not met.
+  */
+ if (iftype != NL80211_IFTYPE_P2P_GO ||
+     !cfg80211_go_permissive_chan(rdev, chandef->chan))
+  prohibited_flags |= IEEE80211_CHAN_NO_IR;
+
+ if (cfg80211_chandef_dfs_required(wiphy, chandef, iftype) > 0 &&
+     cfg80211_chandef_dfs_available(wiphy, chandef)) {
+  /* We can skip IEEE80211_CHAN_NO_IR if chandef dfs available */
+  prohibited_flags = IEEE80211_CHAN_DISABLED;
+ }
+
+ res = cfg80211_chandef_usable(wiphy, chandef, prohibited_flags);
 
  trace_cfg80211_return_bool(res);
  return res;
@@ -448,8 +823,11 @@ int cfg80211_set_monitor_channel(struct cfg80211_registered_device *rdev,
 void
 cfg80211_get_chan_state(struct wireless_dev *wdev,
           struct ieee80211_channel **chan,
-          enum cfg80211_chan_mode *chanmode)
+          enum cfg80211_chan_mode *chanmode,
+          u8 *radar_detect)
 {
+ int ret;
+
  *chan = NULL;
  *chanmode = CHAN_MODE_UNDEFINED;
 
@@ -462,11 +840,18 @@ cfg80211_get_chan_state(struct wireless_dev *wdev,
  case NL80211_IFTYPE_ADHOC:
   if (wdev->current_bss) {
    *chan = wdev->current_bss->pub.channel;
-   *chanmode = wdev->ibss_fixed
+   *chanmode = (wdev->ibss_fixed &&
+         !wdev->ibss_dfs_possible)
       ? CHAN_MODE_SHARED
       : CHAN_MODE_EXCLUSIVE;
+
+   /* consider worst-case - IBSS can try to return to the
+    * original user-specified channel as creator */
+   if (wdev->ibss_dfs_possible)
+    *radar_detect |= BIT(wdev->chandef.width);
    return;
   }
+  break;
  case NL80211_IFTYPE_STATION:
  case NL80211_IFTYPE_P2P_CLIENT:
   if (wdev->current_bss) {
@@ -478,33 +863,42 @@ cfg80211_get_chan_state(struct wireless_dev *wdev,
  case NL80211_IFTYPE_AP:
  case NL80211_IFTYPE_P2P_GO:
   if (wdev->cac_started) {
-   *chan = wdev->channel;
+   *chan = wdev->chandef.chan;
    *chanmode = CHAN_MODE_SHARED;
+   *radar_detect |= BIT(wdev->chandef.width);
   } else if (wdev->beacon_interval) {
-   *chan = wdev->channel;
+   *chan = wdev->chandef.chan;
    *chanmode = CHAN_MODE_SHARED;
+
+   ret = cfg80211_chandef_dfs_required(wdev->wiphy,
+           &wdev->chandef,
+           wdev->iftype);
+   WARN_ON(ret < 0);
+   if (ret > 0)
+    *radar_detect |= BIT(wdev->chandef.width);
   }
   return;
  case NL80211_IFTYPE_MESH_POINT:
   if (wdev->mesh_id_len) {
-   *chan = wdev->channel;
+   *chan = wdev->chandef.chan;
    *chanmode = CHAN_MODE_SHARED;
+
+   ret = cfg80211_chandef_dfs_required(wdev->wiphy,
+           &wdev->chandef,
+           wdev->iftype);
+   WARN_ON(ret < 0);
+   if (ret > 0)
+    *radar_detect |= BIT(wdev->chandef.width);
   }
   return;
  case NL80211_IFTYPE_MONITOR:
  case NL80211_IFTYPE_AP_VLAN:
  case NL80211_IFTYPE_WDS:
-  /* these interface types don't really have a channel */
-  return;
  case NL80211_IFTYPE_P2P_DEVICE:
-  if (wdev->wiphy->features &
-    NL80211_FEATURE_P2P_DEVICE_NEEDS_CHANNEL)
-   *chanmode = CHAN_MODE_EXCLUSIVE;
+  /* these interface types don't really have a channel */
   return;
  case NL80211_IFTYPE_UNSPECIFIED:
  case NUM_NL80211_IFTYPES:
   WARN_ON(1);
  }
-
- return;
 }
diff --git a/net/wireless/core.c b/net/wireless/core.c
index 64fcbae..b2f7ce0 100644
--- a/net/wireless/core.c
+++ b/net/wireless/core.c
@@ -34,13 +34,12 @@
 MODULE_AUTHOR("Johannes Berg");
 MODULE_LICENSE("GPL");
 MODULE_DESCRIPTION("wireless configuration support");
+MODULE_ALIAS_GENL_FAMILY(NL80211_GENL_NAME);
 
-/* RCU-protected (and cfg80211_mutex for writers) */
+/* RCU-protected (and RTNL for writers) */
 LIST_HEAD(cfg80211_rdev_list);
 int cfg80211_rdev_list_generation;
 
-DEFINE_MUTEX(cfg80211_mutex);
-
 /* for debugfs */
 static struct dentry *ieee80211_debugfs_dir;
 
@@ -52,12 +51,11 @@ module_param(cfg80211_disable_40mhz_24ghz, bool, 0644);
 MODULE_PARM_DESC(cfg80211_disable_40mhz_24ghz,
    "Disable 40MHz support in the 2.4GHz band");
 
-/* requires cfg80211_mutex to be held! */
 struct cfg80211_registered_device *cfg80211_rdev_by_wiphy_idx(int wiphy_idx)
 {
  struct cfg80211_registered_device *result = NULL, *rdev;
 
- assert_cfg80211_lock();
+ ASSERT_RTNL();
 
  list_for_each_entry(rdev, &cfg80211_rdev_list, list) {
   if (rdev->wiphy_idx == wiphy_idx) {
@@ -71,17 +69,16 @@ struct cfg80211_registered_device *cfg80211_rdev_by_wiphy_idx(int wiphy_idx)
 
 int get_wiphy_idx(struct wiphy *wiphy)
 {
- struct cfg80211_registered_device *rdev = wiphy_to_dev(wiphy);
+ struct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);
 
  return rdev->wiphy_idx;
 }
 
-/* requires cfg80211_rdev_mutex to be held! */
 struct wiphy *wiphy_idx_to_wiphy(int wiphy_idx)
 {
  struct cfg80211_registered_device *rdev;
 
- assert_cfg80211_lock();
+ ASSERT_RTNL();
 
  rdev = cfg80211_rdev_by_wiphy_idx(wiphy_idx);
  if (!rdev)
@@ -89,35 +86,13 @@ struct wiphy *wiphy_idx_to_wiphy(int wiphy_idx)
  return &rdev->wiphy;
 }
 
-struct cfg80211_registered_device *
-cfg80211_get_dev_from_ifindex(struct net *net, int ifindex)
-{
- struct cfg80211_registered_device *rdev = ERR_PTR(-ENODEV);
- struct net_device *dev;
-
- mutex_lock(&cfg80211_mutex);
- dev = dev_get_by_index(net, ifindex);
- if (!dev)
-  goto out;
- if (dev->ieee80211_ptr) {
-  rdev = wiphy_to_dev(dev->ieee80211_ptr->wiphy);
-  mutex_lock(&rdev->mtx);
- } else
-  rdev = ERR_PTR(-ENODEV);
- dev_put(dev);
- out:
- mutex_unlock(&cfg80211_mutex);
- return rdev;
-}
-
-/* requires cfg80211_mutex to be held */
 int cfg80211_dev_rename(struct cfg80211_registered_device *rdev,
    char *newname)
 {
  struct cfg80211_registered_device *rdev2;
  int wiphy_idx, taken = -1, result, digits;
 
- assert_cfg80211_lock();
+ ASSERT_RTNL();
 
  /* prohibit calling the thing phy%d when %d is not its number */
  sscanf(newname, PHY_NAME "%d%n", &wiphy_idx, &taken);
@@ -155,7 +130,7 @@ int cfg80211_dev_rename(struct cfg80211_registered_device *rdev,
        newname))
   pr_err("failed to rename debugfs dir to %s!\n", newname);
 
- nl80211_notify_dev_rename(rdev);
+ nl80211_notify_wiphy(rdev, NL80211_CMD_NEW_WIPHY);
 
  return 0;
 }
@@ -215,8 +190,7 @@ static void cfg80211_rfkill_poll(struct rfkill *rfkill, void *data)
 void cfg80211_stop_p2p_device(struct cfg80211_registered_device *rdev,
          struct wireless_dev *wdev)
 {
- lockdep_assert_held(&rdev->devlist_mtx);
- lockdep_assert_held(&rdev->sched_scan_mtx);
+ ASSERT_RTNL();
 
  if (WARN_ON(wdev->iftype != NL80211_IFTYPE_P2P_DEVICE))
   return;
@@ -230,32 +204,18 @@ void cfg80211_stop_p2p_device(struct cfg80211_registered_device *rdev,
  rdev->opencount--;
 
  if (rdev->scan_req && rdev->scan_req->wdev == wdev) {
-  bool busy = work_busy(&rdev->scan_done_wk);
-
-  /*
-   * If the work isn't pending or running (in which case it would
-   * be waiting for the lock we hold) the driver didn't properly
-   * cancel the scan when the interface was removed. In this case
-   * warn and leak the scan request object to not crash later.
-   */
-  WARN_ON(!busy);
-
-  rdev->scan_req->aborted = true;
-  ___cfg80211_scan_done(rdev, !busy);
+  if (WARN_ON(!rdev->scan_req->notified))
+   rdev->scan_req->aborted = true;
+  ___cfg80211_scan_done(rdev, false);
  }
 }
 
-static int cfg80211_rfkill_set_block(void *data, bool blocked)
+void cfg80211_shutdown_all_interfaces(struct wiphy *wiphy)
 {
- struct cfg80211_registered_device *rdev = data;
+ struct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);
  struct wireless_dev *wdev;
 
- if (!blocked)
-  return 0;
-
- rtnl_lock();
-
- /* read-only iteration need not hold the devlist_mtx */
+ ASSERT_RTNL();
 
  list_for_each_entry(wdev, &rdev->wdev_list, list) {
   if (wdev->netdev) {
@@ -265,18 +225,24 @@ static int cfg80211_rfkill_set_block(void *data, bool blocked)
   /* otherwise, check iftype */
   switch (wdev->iftype) {
   case NL80211_IFTYPE_P2P_DEVICE:
-   /* but this requires it */
-   mutex_lock(&rdev->devlist_mtx);
-   mutex_lock(&rdev->sched_scan_mtx);
    cfg80211_stop_p2p_device(rdev, wdev);
-   mutex_unlock(&rdev->sched_scan_mtx);
-   mutex_unlock(&rdev->devlist_mtx);
    break;
   default:
    break;
   }
  }
+}
+EXPORT_SYMBOL_GPL(cfg80211_shutdown_all_interfaces);
 
+static int cfg80211_rfkill_set_block(void *data, bool blocked)
+{
+ struct cfg80211_registered_device *rdev = data;
+
+ if (!blocked)
+  return 0;
+
+ rtnl_lock();
+ cfg80211_shutdown_all_interfaces(&rdev->wiphy);
  rtnl_unlock();
 
  return 0;
@@ -298,10 +264,46 @@ static void cfg80211_event_work(struct work_struct *work)
        event_work);
 
  rtnl_lock();
- cfg80211_lock_rdev(rdev);
-
  cfg80211_process_rdev_events(rdev);
- cfg80211_unlock_rdev(rdev);
+ rtnl_unlock();
+}
+
+void cfg80211_destroy_ifaces(struct cfg80211_registered_device *rdev)
+{
+ struct cfg80211_iface_destroy *item;
+
+ ASSERT_RTNL();
+
+ spin_lock_irq(&rdev->destroy_list_lock);
+ while ((item = list_first_entry_or_null(&rdev->destroy_list,
+      struct cfg80211_iface_destroy,
+      list))) {
+  struct wireless_dev *wdev, *tmp;
+  u32 nlportid = item->nlportid;
+
+  list_del(&item->list);
+  kfree(item);
+  spin_unlock_irq(&rdev->destroy_list_lock);
+
+  list_for_each_entry_safe(wdev, tmp, &rdev->wdev_list, list) {
+   if (nlportid == wdev->owner_nlportid)
+    rdev_del_virtual_intf(rdev, wdev);
+  }
+
+  spin_lock_irq(&rdev->destroy_list_lock);
+ }
+ spin_unlock_irq(&rdev->destroy_list_lock);
+}
+
+static void cfg80211_destroy_iface_wk(struct work_struct *work)
+{
+ struct cfg80211_registered_device *rdev;
+
+ rdev = container_of(work, struct cfg80211_registered_device,
+       destroy_work);
+
+ rtnl_lock();
+ cfg80211_destroy_ifaces(rdev);
  rtnl_unlock();
 }
 
@@ -309,7 +311,7 @@ static void cfg80211_event_work(struct work_struct *work)
 
 struct wiphy *wiphy_new(const struct cfg80211_ops *ops, int sizeof_priv)
 {
- static int wiphy_counter;
+ static atomic_t wiphy_counter = ATOMIC_INIT(0);
 
  struct cfg80211_registered_device *rdev;
  int alloc_size;
@@ -331,26 +333,21 @@ struct wiphy *wiphy_new(const struct cfg80211_ops *ops, int sizeof_priv)
 
  rdev->ops = ops;
 
- mutex_lock(&cfg80211_mutex);
-
- rdev->wiphy_idx = wiphy_counter++;
+ rdev->wiphy_idx = atomic_inc_return(&wiphy_counter);
 
  if (unlikely(rdev->wiphy_idx < 0)) {
-  wiphy_counter--;
-  mutex_unlock(&cfg80211_mutex);
   /* ugh, wrapped! */
+  atomic_dec(&wiphy_counter);
   kfree(rdev);
   return NULL;
  }
 
- mutex_unlock(&cfg80211_mutex);
+ /* atomic_inc_return makes it start at 1, make it start at 0 */
+ rdev->wiphy_idx--;
 
  /* give it a proper name */
  dev_set_name(&rdev->wiphy.dev, PHY_NAME "%d", rdev->wiphy_idx);
 
- mutex_init(&rdev->mtx);
- mutex_init(&rdev->devlist_mtx);
- mutex_init(&rdev->sched_scan_mtx);
  INIT_LIST_HEAD(&rdev->wdev_list);
  INIT_LIST_HEAD(&rdev->beacon_registrations);
  spin_lock_init(&rdev->beacon_registrations_lock);
@@ -368,6 +365,10 @@ struct wiphy *wiphy_new(const struct cfg80211_ops *ops, int sizeof_priv)
  rdev->wiphy.dev.class = &ieee80211_class;
  rdev->wiphy.dev.platform_data = rdev;
 
+ INIT_LIST_HEAD(&rdev->destroy_list);
+ spin_lock_init(&rdev->destroy_list_lock);
+ INIT_WORK(&rdev->destroy_work, cfg80211_destroy_iface_wk);
+
 #ifdef CONFIG_CFG80211_DEFAULT_PS
  rdev->wiphy.flags |= WIPHY_FLAG_PS_ON_BY_DEFAULT;
 #endif
@@ -401,7 +402,7 @@ struct wiphy *wiphy_new(const struct cfg80211_ops *ops, int sizeof_priv)
  rdev->wiphy.rts_threshold = (u32) -1;
  rdev->wiphy.coverage_class = 0;
 
- rdev->wiphy.features = NL80211_FEATURE_SCAN_FLUSH;
+ rdev->wiphy.max_num_csa_counters = 1;
 
  return &rdev->wiphy;
 }
@@ -448,10 +449,7 @@ static int wiphy_verify_combinations(struct wiphy *wiphy)
   for (j = 0; j < c->n_limits; j++) {
    u16 types = c->limits[j].types;
 
-   /*
-    * interface types shouldn't overlap, this is
-    * used in cfg80211_can_change_interface()
-    */
+   /* interface types shouldn't overlap */
    if (WARN_ON(types & all_iftypes))
     return -EINVAL;
    all_iftypes |= types;
@@ -487,7 +485,7 @@ static int wiphy_verify_combinations(struct wiphy *wiphy)
 
 int wiphy_register(struct wiphy *wiphy)
 {
- struct cfg80211_registered_device *rdev = wiphy_to_dev(wiphy);
+ struct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);
  int res;
  enum ieee80211_band band;
  struct ieee80211_supported_band *sband;
@@ -495,12 +493,31 @@ int wiphy_register(struct wiphy *wiphy)
  int i;
  u16 ifmodes = wiphy->interface_modes;
 
+ /*
+  * There are major locking problems in nl80211/mac80211 for CSA,
+  * disable for all drivers until this has been reworked.
+  */
+ wiphy->flags &= ~WIPHY_FLAG_HAS_CHANNEL_SWITCH;
+
 #ifdef CONFIG_PM
- if (WARN_ON((wiphy->wowlan.flags & WIPHY_WOWLAN_GTK_REKEY_FAILURE) &&
-      !(wiphy->wowlan.flags & WIPHY_WOWLAN_SUPPORTS_GTK_REKEY)))
+ if (WARN_ON(wiphy->wowlan &&
+      (wiphy->wowlan->flags & WIPHY_WOWLAN_GTK_REKEY_FAILURE) &&
+      !(wiphy->wowlan->flags & WIPHY_WOWLAN_SUPPORTS_GTK_REKEY)))
+  return -EINVAL;
+ if (WARN_ON(wiphy->wowlan &&
+      !wiphy->wowlan->flags && !wiphy->wowlan->n_patterns &&
+      !wiphy->wowlan->tcp))
   return -EINVAL;
 #endif
 
+ if (WARN_ON(wiphy->coalesce &&
+      (!wiphy->coalesce->n_rules ||
+       !wiphy->coalesce->n_patterns) &&
+      (!wiphy->coalesce->pattern_min_len ||
+       wiphy->coalesce->pattern_min_len >
+   wiphy->coalesce->pattern_max_len)))
+  return -EINVAL;
+
  if (WARN_ON(wiphy->ap_sme_capa &&
       !(wiphy->flags & WIPHY_FLAG_HAVE_AP_SME)))
   return -EINVAL;
@@ -587,22 +604,22 @@ int wiphy_register(struct wiphy *wiphy)
  }
 
 #ifdef CONFIG_PM
- if (rdev->wiphy.wowlan.n_patterns) {
-  if (WARN_ON(!rdev->wiphy.wowlan.pattern_min_len ||
-       rdev->wiphy.wowlan.pattern_min_len >
-       rdev->wiphy.wowlan.pattern_max_len))
-   return -EINVAL;
- }
+ if (WARN_ON(rdev->wiphy.wowlan && rdev->wiphy.wowlan->n_patterns &&
+      (!rdev->wiphy.wowlan->pattern_min_len ||
+       rdev->wiphy.wowlan->pattern_min_len >
+    rdev->wiphy.wowlan->pattern_max_len)))
+  return -EINVAL;
 #endif
 
  /* check and set up bitrates */
  ieee80211_set_bitrate_flags(wiphy);
 
- mutex_lock(&cfg80211_mutex);
+ rdev->wiphy.features |= NL80211_FEATURE_SCAN_FLUSH;
 
+ rtnl_lock();
  res = device_add(&rdev->wiphy.dev);
  if (res) {
-  mutex_unlock(&cfg80211_mutex);
+  rtnl_unlock();
   return res;
  }
 
@@ -619,7 +636,7 @@ int wiphy_register(struct wiphy *wiphy)
  if (IS_ERR(rdev->wiphy.debugfsdir))
   rdev->wiphy.debugfsdir = NULL;
 
- if (wiphy->flags & WIPHY_FLAG_CUSTOM_REGULATORY) {
+ if (wiphy->regulatory_flags & REGULATORY_CUSTOM_REG) {
   struct regulatory_request request;
 
   request.wiphy_idx = get_wiphy_idx(wiphy);
@@ -631,34 +648,27 @@ int wiphy_register(struct wiphy *wiphy)
  }
 
  cfg80211_debugfs_rdev_add(rdev);
- mutex_unlock(&cfg80211_mutex);
 
- /*
-  * due to a locking dependency this has to be outside of the
-  * cfg80211_mutex lock
-  */
+ rdev->wiphy.registered = true;
+ rtnl_unlock();
+
  res = rfkill_register(rdev->rfkill);
  if (res) {
-  device_del(&rdev->wiphy.dev);
-
-  mutex_lock(&cfg80211_mutex);
-  debugfs_remove_recursive(rdev->wiphy.debugfsdir);
-  list_del_rcu(&rdev->list);
-  wiphy_regulatory_deregister(wiphy);
-  mutex_unlock(&cfg80211_mutex);
+  rfkill_destroy(rdev->rfkill);
+  rdev->rfkill = NULL;
+  wiphy_unregister(&rdev->wiphy);
   return res;
  }
 
- rtnl_lock();
- rdev->wiphy.registered = true;
- rtnl_unlock();
+ nl80211_notify_wiphy(rdev, NL80211_CMD_NEW_WIPHY);
+
  return 0;
 }
 EXPORT_SYMBOL(wiphy_register);
 
 void wiphy_rfkill_start_polling(struct wiphy *wiphy)
 {
- struct cfg80211_registered_device *rdev = wiphy_to_dev(wiphy);
+ struct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);
 
  if (!rdev->ops->rfkill_poll)
   return;
@@ -669,7 +679,7 @@ EXPORT_SYMBOL(wiphy_rfkill_start_polling);
 
 void wiphy_rfkill_stop_polling(struct wiphy *wiphy)
 {
- struct cfg80211_registered_device *rdev = wiphy_to_dev(wiphy);
+ struct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);
 
  rfkill_pause_polling(rdev->rfkill);
 }
@@ -677,27 +687,23 @@ EXPORT_SYMBOL(wiphy_rfkill_stop_polling);
 
 void wiphy_unregister(struct wiphy *wiphy)
 {
- struct cfg80211_registered_device *rdev = wiphy_to_dev(wiphy);
-
- rtnl_lock();
- rdev->wiphy.registered = false;
- rtnl_unlock();
-
- rfkill_unregister(rdev->rfkill);
-
- /* protect the device list */
- mutex_lock(&cfg80211_mutex);
+ struct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);
 
  wait_event(rdev->dev_wait, ({
   int __count;
-  mutex_lock(&rdev->devlist_mtx);
+  rtnl_lock();
   __count = rdev->opencount;
-  mutex_unlock(&rdev->devlist_mtx);
+  rtnl_unlock();
   __count == 0; }));
 
- mutex_lock(&rdev->devlist_mtx);
- BUG_ON(!list_empty(&rdev->wdev_list));
- mutex_unlock(&rdev->devlist_mtx);
+ if (rdev->rfkill)
+  rfkill_unregister(rdev->rfkill);
+
+ rtnl_lock();
+ nl80211_notify_wiphy(rdev, NL80211_CMD_DEL_WIPHY);
+ rdev->wiphy.registered = false;
+
+ WARN_ON(!list_empty(&rdev->wdev_list));
 
  /*
   * First remove the hardware from everywhere, this makes
@@ -708,20 +714,6 @@ void wiphy_unregister(struct wiphy *wiphy)
  synchronize_rcu();
 
  /*
-  * Try to grab rdev->mtx. If a command is still in progress,
-  * hopefully the driver will refuse it since it's tearing
-  * down the device already. We wait for this command to complete
-  * before unlinking the item from the list.
-  * Note: as codified by the BUG_ON above we cannot get here if
-  * a virtual interface is still present. Hence, we can only get
-  * to lock contention here if userspace issues a command that
-  * identified the hardware by wiphy index.
-  */
- cfg80211_lock_rdev(rdev);
- /* nothing */
- cfg80211_unlock_rdev(rdev);
-
- /*
   * If this device got a regulatory hint tell core its
   * free to listen now to a new shiny device regulatory hint
   */
@@ -730,16 +722,20 @@ void wiphy_unregister(struct wiphy *wiphy)
  cfg80211_rdev_list_generation++;
  device_del(&rdev->wiphy.dev);
 
- mutex_unlock(&cfg80211_mutex);
+ rtnl_unlock();
 
  flush_work(&rdev->scan_done_wk);
  cancel_work_sync(&rdev->conn_work);
  flush_work(&rdev->event_work);
  cancel_delayed_work_sync(&rdev->dfs_update_channels_wk);
+ flush_work(&rdev->destroy_work);
 
- if (rdev->wowlan && rdev->ops->set_wakeup)
+#ifdef CONFIG_PM
+ if (rdev->wiphy.wowlan_config && rdev->ops->set_wakeup)
   rdev_set_wakeup(rdev, false);
+#endif
  cfg80211_rdev_free_wowlan(rdev);
+ cfg80211_rdev_free_coalesce(rdev);
 }
 EXPORT_SYMBOL(wiphy_unregister);
 
@@ -748,9 +744,6 @@ void cfg80211_dev_free(struct cfg80211_registered_device *rdev)
  struct cfg80211_internal_bss *scan, *tmp;
  struct cfg80211_beacon_registration *reg, *treg;
  rfkill_destroy(rdev->rfkill);
- mutex_destroy(&rdev->mtx);
- mutex_destroy(&rdev->devlist_mtx);
- mutex_destroy(&rdev->sched_scan_mtx);
  list_for_each_entry_safe(reg, treg, &rdev->beacon_registrations, list) {
   list_del(&reg->list);
   kfree(reg);
@@ -768,54 +761,22 @@ EXPORT_SYMBOL(wiphy_free);
 
 void wiphy_rfkill_set_hw_state(struct wiphy *wiphy, bool blocked)
 {
- struct cfg80211_registered_device *rdev = wiphy_to_dev(wiphy);
+ struct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);
 
  if (rfkill_set_hw_state(rdev->rfkill, blocked))
   schedule_work(&rdev->rfkill_sync);
 }
 EXPORT_SYMBOL(wiphy_rfkill_set_hw_state);
 
-static void wdev_cleanup_work(struct work_struct *work)
-{
- struct wireless_dev *wdev;
- struct cfg80211_registered_device *rdev;
-
- wdev = container_of(work, struct wireless_dev, cleanup_work);
- rdev = wiphy_to_dev(wdev->wiphy);
-
- mutex_lock(&rdev->sched_scan_mtx);
-
- if (WARN_ON(rdev->scan_req && rdev->scan_req->wdev == wdev)) {
-  rdev->scan_req->aborted = true;
-  ___cfg80211_scan_done(rdev, true);
- }
-
- if (WARN_ON(rdev->sched_scan_req &&
-      rdev->sched_scan_req->dev == wdev->netdev)) {
-  __cfg80211_stop_sched_scan(rdev, false);
- }
-
- mutex_unlock(&rdev->sched_scan_mtx);
-
- mutex_lock(&rdev->devlist_mtx);
- rdev->opencount--;
- mutex_unlock(&rdev->devlist_mtx);
- wake_up(&rdev->dev_wait);
-
- dev_put(wdev->netdev);
-}
-
 void cfg80211_unregister_wdev(struct wireless_dev *wdev)
 {
- struct cfg80211_registered_device *rdev = wiphy_to_dev(wdev->wiphy);
+ struct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);
 
  ASSERT_RTNL();
 
  if (WARN_ON(wdev->netdev))
   return;
 
- mutex_lock(&rdev->devlist_mtx);
- mutex_lock(&rdev->sched_scan_mtx);
  list_del_rcu(&wdev->list);
  rdev->devlist_generation++;
 
@@ -827,12 +788,10 @@ void cfg80211_unregister_wdev(struct wireless_dev *wdev)
   WARN_ON_ONCE(1);
   break;
  }
- mutex_unlock(&rdev->sched_scan_mtx);
- mutex_unlock(&rdev->devlist_mtx);
 }
 EXPORT_SYMBOL(cfg80211_unregister_wdev);
 
-static struct device_type wiphy_type = {
+static const struct device_type wiphy_type = {
  .name = "wlan",
 };
 
@@ -846,59 +805,89 @@ void cfg80211_update_iface_num(struct cfg80211_registered_device *rdev,
   rdev->num_running_monitor_ifaces += num;
 }
 
-void cfg80211_leave(struct cfg80211_registered_device *rdev,
-     struct wireless_dev *wdev)
+void __cfg80211_leave(struct cfg80211_registered_device *rdev,
+        struct wireless_dev *wdev)
 {
  struct net_device *dev = wdev->netdev;
 
+ ASSERT_RTNL();
+ ASSERT_WDEV_LOCK(wdev);
+
  switch (wdev->iftype) {
  case NL80211_IFTYPE_ADHOC:
-  cfg80211_leave_ibss(rdev, dev, true);
+  __cfg80211_leave_ibss(rdev, dev, true);
   break;
  case NL80211_IFTYPE_P2P_CLIENT:
  case NL80211_IFTYPE_STATION:
-  mutex_lock(&rdev->sched_scan_mtx);
-  __cfg80211_stop_sched_scan(rdev, false);
-  mutex_unlock(&rdev->sched_scan_mtx);
+  if (rdev->sched_scan_req && dev == rdev->sched_scan_req->dev)
+   __cfg80211_stop_sched_scan(rdev, false);
 
-  wdev_lock(wdev);
 #ifdef CONFIG_CFG80211_WEXT
   kfree(wdev->wext.ie);
   wdev->wext.ie = NULL;
   wdev->wext.ie_len = 0;
   wdev->wext.connect.auth_type = NL80211_AUTHTYPE_AUTOMATIC;
 #endif
-  __cfg80211_disconnect(rdev, dev,
-          WLAN_REASON_DEAUTH_LEAVING, true);
-  wdev_unlock(wdev);
+  cfg80211_disconnect(rdev, dev,
+        WLAN_REASON_DEAUTH_LEAVING, true);
   break;
  case NL80211_IFTYPE_MESH_POINT:
-  cfg80211_leave_mesh(rdev, dev);
+  __cfg80211_leave_mesh(rdev, dev);
   break;
  case NL80211_IFTYPE_AP:
  case NL80211_IFTYPE_P2P_GO:
-  cfg80211_stop_ap(rdev, dev);
+  __cfg80211_stop_ap(rdev, dev, true);
   break;
  default:
   break;
  }
+}
+
+void cfg80211_leave(struct cfg80211_registered_device *rdev,
+      struct wireless_dev *wdev)
+{
+ wdev_lock(wdev);
+ __cfg80211_leave(rdev, wdev);
+ wdev_unlock(wdev);
+}
+
+void cfg80211_stop_iface(struct wiphy *wiphy, struct wireless_dev *wdev,
+    gfp_t gfp)
+{
+ struct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);
+ struct cfg80211_event *ev;
+ unsigned long flags;
+
+ trace_cfg80211_stop_iface(wiphy, wdev);
+
+ ev = kzalloc(sizeof(*ev), gfp);
+ if (!ev)
+  return;
 
- wdev->beacon_interval = 0;
+ ev->type = EVENT_STOPPED;
+
+ spin_lock_irqsave(&wdev->event_lock, flags);
+ list_add_tail(&ev->list, &wdev->event_list);
+ spin_unlock_irqrestore(&wdev->event_lock, flags);
+ queue_work(cfg80211_wq, &rdev->event_work);
 }
+EXPORT_SYMBOL(cfg80211_stop_iface);
 
 static int cfg80211_netdev_notifier_call(struct notifier_block *nb,
-      unsigned long state,
-      void *ndev)
+      unsigned long state, void *ptr)
 {
- struct net_device *dev = ndev;
+#if 0 /* Not in RHEL */
+ struct net_device *dev = netdev_notifier_info_to_dev(ptr);
+#else
+ struct net_device *dev = ptr;
+#endif
  struct wireless_dev *wdev = dev->ieee80211_ptr;
  struct cfg80211_registered_device *rdev;
- int ret;
 
  if (!wdev)
   return NOTIFY_DONE;
 
- rdev = wiphy_to_dev(wdev->wiphy);
+ rdev = wiphy_to_rdev(wdev->wiphy);
 
  WARN_ON(wdev->iftype == NL80211_IFTYPE_UNSPECIFIED);
 
@@ -913,13 +902,11 @@ static int cfg80211_netdev_notifier_call(struct notifier_block *nb,
    * are added with nl80211.
    */
   mutex_init(&wdev->mtx);
-  INIT_WORK(&wdev->cleanup_work, wdev_cleanup_work);
   INIT_LIST_HEAD(&wdev->event_list);
   spin_lock_init(&wdev->event_lock);
   INIT_LIST_HEAD(&wdev->mgmt_registrations);
   spin_lock_init(&wdev->mgmt_registrations_lock);
 
-  mutex_lock(&rdev->devlist_mtx);
   wdev->identifier = ++rdev->wdev_id;
   list_add_rcu(&wdev->list, &rdev->wdev_list);
   rdev->devlist_generation++;
@@ -931,8 +918,6 @@ static int cfg80211_netdev_notifier_call(struct notifier_block *nb,
    pr_err("failed to add phy80211 symlink to netdev!\n");
   }
   wdev->netdev = dev;
-  wdev->sme_state = CFG80211_SME_IDLE;
-  mutex_unlock(&rdev->devlist_mtx);
 #ifdef CONFIG_CFG80211_WEXT
   wdev->wext.default_key = -1;
   wdev->wext.default_mgmt_key = -1;
@@ -958,26 +943,22 @@ static int cfg80211_netdev_notifier_call(struct notifier_block *nb,
   break;
  case NETDEV_DOWN:
   cfg80211_update_iface_num(rdev, wdev->iftype, -1);
-  dev_hold(dev);
-  queue_work(cfg80211_wq, &wdev->cleanup_work);
+  if (rdev->scan_req && rdev->scan_req->wdev == wdev) {
+   if (WARN_ON(!rdev->scan_req->notified))
+    rdev->scan_req->aborted = true;
+   ___cfg80211_scan_done(rdev, false);
+  }
+
+  if (WARN_ON(rdev->sched_scan_req &&
+       rdev->sched_scan_req->dev == wdev->netdev)) {
+   __cfg80211_stop_sched_scan(rdev, false);
+  }
+
+  rdev->opencount--;
+  wake_up(&rdev->dev_wait);
   break;
  case NETDEV_UP:
-  /*
-   * If we have a really quick DOWN/UP succession we may
-   * have this work still pending ... cancel it and see
-   * if it was pending, in which case we need to account
-   * for some of the work it would have done.
-   */
-  if (cancel_work_sync(&wdev->cleanup_work)) {
-   mutex_lock(&rdev->devlist_mtx);
-   rdev->opencount--;
-   mutex_unlock(&rdev->devlist_mtx);
-   dev_put(dev);
-  }
   cfg80211_update_iface_num(rdev, wdev->iftype, 1);
-  cfg80211_lock_rdev(rdev);
-  mutex_lock(&rdev->devlist_mtx);
-  mutex_lock(&rdev->sched_scan_mtx);
   wdev_lock(wdev);
   switch (wdev->iftype) {
 #ifdef CONFIG_CFG80211_WEXT
@@ -1009,10 +990,7 @@ static int cfg80211_netdev_notifier_call(struct notifier_block *nb,
    break;
   }
   wdev_unlock(wdev);
-  mutex_unlock(&rdev->sched_scan_mtx);
   rdev->opencount++;
-  mutex_unlock(&rdev->devlist_mtx);
-  cfg80211_unlock_rdev(rdev);
 
   /*
    * Configure power management to the driver here so that its
@@ -1029,12 +1007,6 @@ static int cfg80211_netdev_notifier_call(struct notifier_block *nb,
   break;
  case NETDEV_UNREGISTER:
   /*
-   * NB: cannot take rdev->mtx here because this may be
-   * called within code protected by it when interfaces
-   * are removed with nl80211.
-   */
-  mutex_lock(&rdev->devlist_mtx);
-  /*
    * It is possible to get NETDEV_UNREGISTER
    * multiple times. To detect that, check
    * that the interface is still on the list
@@ -1050,7 +1022,6 @@ static int cfg80211_netdev_notifier_call(struct notifier_block *nb,
    kfree(wdev->wext.keys);
 #endif
   }
-  mutex_unlock(&rdev->devlist_mtx);
   /*
    * synchronise (so that we won't find this netdev
    * from other code any more) and then clear the list
@@ -1064,21 +1035,24 @@ static int cfg80211_netdev_notifier_call(struct notifier_block *nb,
    * freed.
    */
   cfg80211_process_wdev_events(wdev);
+
+  if (WARN_ON(wdev->current_bss)) {
+   cfg80211_unhold_bss(wdev->current_bss);
+   cfg80211_put_bss(wdev->wiphy, &wdev->current_bss->pub);
+   wdev->current_bss = NULL;
+  }
   break;
  case NETDEV_PRE_UP:
   if (!(wdev->wiphy->interface_modes & BIT(wdev->iftype)))
    return notifier_from_errno(-EOPNOTSUPP);
   if (rfkill_blocked(rdev->rfkill))
    return notifier_from_errno(-ERFKILL);
-  mutex_lock(&rdev->devlist_mtx);
-  ret = cfg80211_can_add_interface(rdev, wdev->iftype);
-  mutex_unlock(&rdev->devlist_mtx);
-  if (ret)
-   return notifier_from_errno(ret);
   break;
+ default:
+  return NOTIFY_DONE;
  }
 
- return NOTIFY_DONE;
+ return NOTIFY_OK;
 }
 
 static struct notifier_block cfg80211_netdev_notifier = {
@@ -1090,12 +1064,10 @@ static void __net_exit cfg80211_pernet_exit(struct net *net)
  struct cfg80211_registered_device *rdev;
 
  rtnl_lock();
- mutex_lock(&cfg80211_mutex);
  list_for_each_entry(rdev, &cfg80211_rdev_list, list) {
   if (net_eq(wiphy_net(&rdev->wiphy), net))
    WARN_ON(cfg80211_switch_netns(rdev, &init_net));
  }
- mutex_unlock(&cfg80211_mutex);
  rtnl_unlock();
 }
 
diff --git a/net/wireless/core.h b/net/wireless/core.h
index fd35dae..da2c644 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -5,7 +5,6 @@
  */
 #ifndef __NET_WIRELESS_CORE_H
 #define __NET_WIRELESS_CORE_H
-#include <linux/mutex.h>
 #include <linux/list.h>
 #include <linux/netdevice.h>
 #include <linux/rbtree.h>
@@ -17,17 +16,11 @@
 #include <net/cfg80211.h>
 #include "reg.h"
 
-
 #define WIPHY_IDX_INVALID -1
 
 struct cfg80211_registered_device {
  const struct cfg80211_ops *ops;
  struct list_head list;
- /* we hold this mutex during any call so that
-  * we cannot do multiple calls at once, and also
-  * to avoid the deregister call to proceed while
-  * any call is in progress */
- struct mutex mtx;
 
  /* rfkill support */
  struct rfkill_ops rfkill_ops;
@@ -49,9 +42,7 @@ struct cfg80211_registered_device {
  /* wiphy index, internal only */
  int wiphy_idx;
 
- /* associated wireless interfaces */
- struct mutex devlist_mtx;
- /* protected by devlist_mtx or RCU */
+ /* associated wireless interfaces, protected by rtnl or RCU */
  struct list_head wdev_list;
  int devlist_generation, wdev_id;
  int opencount; /* also protected by devlist_mtx */
@@ -70,34 +61,35 @@ struct cfg80211_registered_device {
  struct rb_root bss_tree;
  u32 bss_generation;
  struct cfg80211_scan_request *scan_req; /* protected by RTNL */
+ struct sk_buff *scan_msg;
  struct cfg80211_sched_scan_request *sched_scan_req;
  unsigned long suspend_at;
  struct work_struct scan_done_wk;
  struct work_struct sched_scan_results_wk;
 
- struct mutex sched_scan_mtx;
-
-#ifdef CONFIG_NL80211_TESTMODE
- struct genl_info *testmode_info;
-#endif
+ struct genl_info *cur_cmd_info;
 
  struct work_struct conn_work;
  struct work_struct event_work;
 
- struct cfg80211_wowlan *wowlan;
-
  struct delayed_work dfs_update_channels_wk;
 
  /* netlink port which started critical protocol (0 means not started) */
  u32 crit_proto_nlportid;
 
+ struct cfg80211_coalesce *coalesce;
+
+ spinlock_t destroy_list_lock;
+ struct list_head destroy_list;
+ struct work_struct destroy_work;
+
  /* must be last because of the way we do wiphy_priv(),
   * and it should at least be aligned to NETDEV_ALIGN */
  struct wiphy wiphy __aligned(NETDEV_ALIGN);
 };
 
 static inline
-struct cfg80211_registered_device *wiphy_to_dev(struct wiphy *wiphy)
+struct cfg80211_registered_device *wiphy_to_rdev(struct wiphy *wiphy)
 {
  BUG_ON(!wiphy);
  return container_of(wiphy, struct cfg80211_registered_device, wiphy);
@@ -106,29 +98,26 @@ struct cfg80211_registered_device *wiphy_to_dev(struct wiphy *wiphy)
 static inline void
 cfg80211_rdev_free_wowlan(struct cfg80211_registered_device *rdev)
 {
+#ifdef CONFIG_PM
  int i;
 
- if (!rdev->wowlan)
+ if (!rdev->wiphy.wowlan_config)
   return;
- for (i = 0; i < rdev->wowlan->n_patterns; i++)
-  kfree(rdev->wowlan->patterns[i].mask);
- kfree(rdev->wowlan->patterns);
- if (rdev->wowlan->tcp && rdev->wowlan->tcp->sock)
-  sock_release(rdev->wowlan->tcp->sock);
- kfree(rdev->wowlan->tcp);
- kfree(rdev->wowlan);
+ for (i = 0; i < rdev->wiphy.wowlan_config->n_patterns; i++)
+  kfree(rdev->wiphy.wowlan_config->patterns[i].mask);
+ kfree(rdev->wiphy.wowlan_config->patterns);
+ if (rdev->wiphy.wowlan_config->tcp &&
+     rdev->wiphy.wowlan_config->tcp->sock)
+  sock_release(rdev->wiphy.wowlan_config->tcp->sock);
+ kfree(rdev->wiphy.wowlan_config->tcp);
+ kfree(rdev->wiphy.wowlan_config);
+#endif
 }
 
 extern struct workqueue_struct *cfg80211_wq;
-extern struct mutex cfg80211_mutex;
 extern struct list_head cfg80211_rdev_list;
 extern int cfg80211_rdev_list_generation;
 
-static inline void assert_cfg80211_lock(void)
-{
- lockdep_assert_held(&cfg80211_mutex);
-}
-
 struct cfg80211_internal_bss {
  struct list_head list;
  struct list_head hidden_list;
@@ -161,27 +150,11 @@ static inline void cfg80211_unhold_bss(struct cfg80211_internal_bss *bss)
 struct cfg80211_registered_device *cfg80211_rdev_by_wiphy_idx(int wiphy_idx);
 int get_wiphy_idx(struct wiphy *wiphy);
 
-/* requires cfg80211_rdev_mutex to be held! */
 struct wiphy *wiphy_idx_to_wiphy(int wiphy_idx);
 
-/* identical to cfg80211_get_dev_from_info but only operate on ifindex */
-extern struct cfg80211_registered_device *
-cfg80211_get_dev_from_ifindex(struct net *net, int ifindex);
-
 int cfg80211_switch_netns(struct cfg80211_registered_device *rdev,
      struct net *net);
 
-static inline void cfg80211_lock_rdev(struct cfg80211_registered_device *rdev)
-{
- mutex_lock(&rdev->mtx);
-}
-
-static inline void cfg80211_unlock_rdev(struct cfg80211_registered_device *rdev)
-{
- BUG_ON(IS_ERR(rdev) || !rdev);
- mutex_unlock(&rdev->mtx);
-}
-
 static inline void wdev_lock(struct wireless_dev *wdev)
  __acquires(wdev)
 {
@@ -196,7 +169,6 @@ static inline void wdev_unlock(struct wireless_dev *wdev)
  mutex_unlock(&wdev->mtx);
 }
 
-#define ASSERT_RDEV_LOCK(rdev) lockdep_assert_held(&(rdev)->mtx)
 #define ASSERT_WDEV_LOCK(wdev) lockdep_assert_held(&(wdev)->mtx)
 
 static inline bool cfg80211_has_monitors_only(struct cfg80211_registered_device *rdev)
@@ -212,6 +184,7 @@ enum cfg80211_event_type {
  EVENT_ROAMED,
  EVENT_DISCONNECTED,
  EVENT_IBSS_JOINED,
+ EVENT_STOPPED,
 };
 
 struct cfg80211_event {
@@ -241,6 +214,7 @@ struct cfg80211_event {
   } dc;
   struct {
    u8 bssid[ETH_ALEN];
+   struct ieee80211_channel *channel;
   } ij;
  };
 };
@@ -262,23 +236,26 @@ struct cfg80211_beacon_registration {
  u32 nlportid;
 };
 
+struct cfg80211_iface_destroy {
+ struct list_head list;
+ u32 nlportid;
+};
+
+void cfg80211_destroy_ifaces(struct cfg80211_registered_device *rdev);
+
 /* free object */
-extern void cfg80211_dev_free(struct cfg80211_registered_device *rdev);
+void cfg80211_dev_free(struct cfg80211_registered_device *rdev);
 
-extern int cfg80211_dev_rename(struct cfg80211_registered_device *rdev,
-          char *newname);
+int cfg80211_dev_rename(struct cfg80211_registered_device *rdev,
+   char *newname);
 
 void ieee80211_set_bitrate_flags(struct wiphy *wiphy);
 
-void cfg80211_bss_expire(struct cfg80211_registered_device *dev);
-void cfg80211_bss_age(struct cfg80211_registered_device *dev,
+void cfg80211_bss_expire(struct cfg80211_registered_device *rdev);
+void cfg80211_bss_age(struct cfg80211_registered_device *rdev,
                       unsigned long age_secs);
 
 /* IBSS */
-int __cfg80211_join_ibss(struct cfg80211_registered_device *rdev,
-    struct net_device *dev,
-    struct cfg80211_ibss_params *params,
-    struct cfg80211_cached_keys *connkeys);
 int cfg80211_join_ibss(struct cfg80211_registered_device *rdev,
          struct net_device *dev,
          struct cfg80211_ibss_params *params,
@@ -288,7 +265,8 @@ int __cfg80211_leave_ibss(struct cfg80211_registered_device *rdev,
      struct net_device *dev, bool nowext);
 int cfg80211_leave_ibss(struct cfg80211_registered_device *rdev,
    struct net_device *dev, bool nowext);
-void __cfg80211_ibss_joined(struct net_device *dev, const u8 *bssid);
+void __cfg80211_ibss_joined(struct net_device *dev, const u8 *bssid,
+       struct ieee80211_channel *channel);
 int cfg80211_ibss_wext_join(struct cfg80211_registered_device *rdev,
        struct wireless_dev *wdev);
 
@@ -303,6 +281,8 @@ int cfg80211_join_mesh(struct cfg80211_registered_device *rdev,
          struct net_device *dev,
          struct mesh_setup *setup,
          const struct mesh_config *conf);
+int __cfg80211_leave_mesh(struct cfg80211_registered_device *rdev,
+     struct net_device *dev);
 int cfg80211_leave_mesh(struct cfg80211_registered_device *rdev,
    struct net_device *dev);
 int cfg80211_set_mesh_channel(struct cfg80211_registered_device *rdev,
@@ -310,42 +290,27 @@ int cfg80211_set_mesh_channel(struct cfg80211_registered_device *rdev,
          struct cfg80211_chan_def *chandef);
 
 /* AP */
+int __cfg80211_stop_ap(struct cfg80211_registered_device *rdev,
+         struct net_device *dev, bool notify);
 int cfg80211_stop_ap(struct cfg80211_registered_device *rdev,
-       struct net_device *dev);
+       struct net_device *dev, bool notify);
 
 /* MLME */
-int __cfg80211_mlme_auth(struct cfg80211_registered_device *rdev,
-    struct net_device *dev,
-    struct ieee80211_channel *chan,
-    enum nl80211_auth_type auth_type,
-    const u8 *bssid,
-    const u8 *ssid, int ssid_len,
-    const u8 *ie, int ie_len,
-    const u8 *key, int key_len, int key_idx,
-    const u8 *sae_data, int sae_data_len);
 int cfg80211_mlme_auth(struct cfg80211_registered_device *rdev,
-         struct net_device *dev, struct ieee80211_channel *chan,
-         enum nl80211_auth_type auth_type, const u8 *bssid,
+         struct net_device *dev,
+         struct ieee80211_channel *chan,
+         enum nl80211_auth_type auth_type,
+         const u8 *bssid,
          const u8 *ssid, int ssid_len,
          const u8 *ie, int ie_len,
          const u8 *key, int key_len, int key_idx,
          const u8 *sae_data, int sae_data_len);
-int __cfg80211_mlme_assoc(struct cfg80211_registered_device *rdev,
-     struct net_device *dev,
-     struct ieee80211_channel *chan,
-     const u8 *bssid,
-     const u8 *ssid, int ssid_len,
-     struct cfg80211_assoc_request *req);
 int cfg80211_mlme_assoc(struct cfg80211_registered_device *rdev,
    struct net_device *dev,
    struct ieee80211_channel *chan,
    const u8 *bssid,
    const u8 *ssid, int ssid_len,
    struct cfg80211_assoc_request *req);
-int __cfg80211_mlme_deauth(struct cfg80211_registered_device *rdev,
-      struct net_device *dev, const u8 *bssid,
-      const u8 *ie, int ie_len, u16 reason,
-      bool local_state_change);
 int cfg80211_mlme_deauth(struct cfg80211_registered_device *rdev,
     struct net_device *dev, const u8 *bssid,
     const u8 *ie, int ie_len, u16 reason,
@@ -356,11 +321,6 @@ int cfg80211_mlme_disassoc(struct cfg80211_registered_device *rdev,
       bool local_state_change);
 void cfg80211_mlme_down(struct cfg80211_registered_device *rdev,
    struct net_device *dev);
-void __cfg80211_connect_result(struct net_device *dev, const u8 *bssid,
-          const u8 *req_ie, size_t req_ie_len,
-          const u8 *resp_ie, size_t resp_ie_len,
-          u16 status, bool wextev,
-          struct cfg80211_bss *bss);
 int cfg80211_mlme_register_mgmt(struct wireless_dev *wdev, u32 snd_pid,
     u16 frame_type, const u8 *match_data,
     int match_len);
@@ -368,27 +328,26 @@ void cfg80211_mlme_unregister_socket(struct wireless_dev *wdev, u32 nlpid);
 void cfg80211_mlme_purge_registrations(struct wireless_dev *wdev);
 int cfg80211_mlme_mgmt_tx(struct cfg80211_registered_device *rdev,
      struct wireless_dev *wdev,
-     struct ieee80211_channel *chan, bool offchan,
-     unsigned int wait, const u8 *buf, size_t len,
-     bool no_cck, bool dont_wait_for_ack, u64 *cookie);
+     struct cfg80211_mgmt_tx_params *params,
+     u64 *cookie);
 void cfg80211_oper_and_ht_capa(struct ieee80211_ht_cap *ht_capa,
           const struct ieee80211_ht_cap *ht_capa_mask);
 void cfg80211_oper_and_vht_capa(struct ieee80211_vht_cap *vht_capa,
     const struct ieee80211_vht_cap *vht_capa_mask);
 
-/* SME */
-int __cfg80211_connect(struct cfg80211_registered_device *rdev,
-         struct net_device *dev,
-         struct cfg80211_connect_params *connect,
-         struct cfg80211_cached_keys *connkeys,
-         const u8 *prev_bssid);
+/* SME events */
 int cfg80211_connect(struct cfg80211_registered_device *rdev,
        struct net_device *dev,
        struct cfg80211_connect_params *connect,
-       struct cfg80211_cached_keys *connkeys);
-int __cfg80211_disconnect(struct cfg80211_registered_device *rdev,
-     struct net_device *dev, u16 reason,
-     bool wextev);
+       struct cfg80211_cached_keys *connkeys,
+       const u8 *prev_bssid);
+void __cfg80211_connect_result(struct net_device *dev, const u8 *bssid,
+          const u8 *req_ie, size_t req_ie_len,
+          const u8 *resp_ie, size_t resp_ie_len,
+          u16 status, bool wextev,
+          struct cfg80211_bss *bss);
+void __cfg80211_disconnected(struct net_device *dev, const u8 *ie,
+        size_t ie_len, u16 reason, bool from_ap);
 int cfg80211_disconnect(struct cfg80211_registered_device *rdev,
    struct net_device *dev, u16 reason,
    bool wextev);
@@ -399,23 +358,24 @@ void __cfg80211_roamed(struct wireless_dev *wdev,
 int cfg80211_mgd_wext_connect(struct cfg80211_registered_device *rdev,
          struct wireless_dev *wdev);
 
+/* SME implementation */
 void cfg80211_conn_work(struct work_struct *work);
-void cfg80211_sme_failed_assoc(struct wireless_dev *wdev);
-bool cfg80211_sme_failed_reassoc(struct wireless_dev *wdev);
+void cfg80211_sme_scan_done(struct net_device *dev);
+bool cfg80211_sme_rx_assoc_resp(struct wireless_dev *wdev, u16 status);
+void cfg80211_sme_rx_auth(struct wireless_dev *wdev, const u8 *buf, size_t len);
+void cfg80211_sme_disassoc(struct wireless_dev *wdev);
+void cfg80211_sme_deauth(struct wireless_dev *wdev);
+void cfg80211_sme_auth_timeout(struct wireless_dev *wdev);
+void cfg80211_sme_assoc_timeout(struct wireless_dev *wdev);
 
 /* internal helpers */
 bool cfg80211_supported_cipher_suite(struct wiphy *wiphy, u32 cipher);
 int cfg80211_validate_key_settings(struct cfg80211_registered_device *rdev,
        struct key_params *params, int key_idx,
        bool pairwise, const u8 *mac_addr);
-void __cfg80211_disconnected(struct net_device *dev, const u8 *ie,
-        size_t ie_len, u16 reason, bool from_ap);
-void cfg80211_sme_scan_done(struct net_device *dev);
-void cfg80211_sme_rx_auth(struct net_device *dev, const u8 *buf, size_t len);
-void cfg80211_sme_disassoc(struct net_device *dev,
-      struct cfg80211_internal_bss *bss);
 void __cfg80211_scan_done(struct work_struct *wk);
-void ___cfg80211_scan_done(struct cfg80211_registered_device *rdev, bool leak);
+void ___cfg80211_scan_done(struct cfg80211_registered_device *rdev,
+      bool send_message);
 void __cfg80211_sched_scan_results(struct work_struct *wk);
 int __cfg80211_stop_sched_scan(struct cfg80211_registered_device *rdev,
           bool driver_initiated);
@@ -434,13 +394,17 @@ int cfg80211_can_use_iftype_chan(struct cfg80211_registered_device *rdev,
      u8 radar_detect);
 
 /**
- * cfg80211_chandef_dfs_required - checks if radar detection is required
+ * cfg80211_chandef_dfs_usable - checks if chandef is DFS usable
  * @wiphy: the wiphy to validate against
  * @chandef: the channel definition to check
- * Return: 1 if radar detection is required, 0 if it is not, < 0 on error
+ *
+ * Checks if chandef is usable and we can/need start CAC on such channel.
+ *
+ * Return: Return true if all channels available and at least
+ *    one channel require CAC (NL80211_DFS_USABLE)
  */
-int cfg80211_chandef_dfs_required(struct wiphy *wiphy,
-      const struct cfg80211_chan_def *c);
+bool cfg80211_chandef_dfs_usable(struct wiphy *wiphy,
+     const struct cfg80211_chan_def *chandef);
 
 void cfg80211_set_dfs_state(struct wiphy *wiphy,
        const struct cfg80211_chan_def *chandef,
@@ -448,32 +412,9 @@ void cfg80211_set_dfs_state(struct wiphy *wiphy,
 
 void cfg80211_dfs_channels_update_work(struct work_struct *work);
 
-
-static inline int
-cfg80211_can_change_interface(struct cfg80211_registered_device *rdev,
-         struct wireless_dev *wdev,
-         enum nl80211_iftype iftype)
-{
- return cfg80211_can_use_iftype_chan(rdev, wdev, iftype, NULL,
-         CHAN_MODE_UNDEFINED, 0);
-}
-
-static inline int
-cfg80211_can_add_interface(struct cfg80211_registered_device *rdev,
-      enum nl80211_iftype iftype)
-{
- return cfg80211_can_change_interface(rdev, NULL, iftype);
-}
-
-static inline int
-cfg80211_can_use_chan(struct cfg80211_registered_device *rdev,
-        struct wireless_dev *wdev,
-        struct ieee80211_channel *chan,
-        enum cfg80211_chan_mode chanmode)
-{
- return cfg80211_can_use_iftype_chan(rdev, wdev, wdev->iftype,
-         chan, chanmode, 0);
-}
+unsigned int
+cfg80211_chandef_dfs_cac_time(struct wiphy *wiphy,
+         const struct cfg80211_chan_def *chandef);
 
 static inline unsigned int elapsed_jiffies_msecs(unsigned long start)
 {
@@ -482,13 +423,14 @@ static inline unsigned int elapsed_jiffies_msecs(unsigned long start)
  if (end >= start)
   return jiffies_to_msecs(end - start);
 
- return jiffies_to_msecs(end + (MAX_JIFFY_OFFSET - start) + 1);
+ return jiffies_to_msecs(end + (ULONG_MAX - start) + 1);
 }
 
 void
 cfg80211_get_chan_state(struct wireless_dev *wdev,
           struct ieee80211_channel **chan,
-          enum cfg80211_chan_mode *chanmode);
+          enum cfg80211_chan_mode *chanmode,
+          u8 *radar_detect);
 
 int cfg80211_set_monitor_channel(struct cfg80211_registered_device *rdev,
      struct cfg80211_chan_def *chandef);
@@ -503,6 +445,8 @@ int cfg80211_validate_beacon_int(struct cfg80211_registered_device *rdev,
 void cfg80211_update_iface_num(struct cfg80211_registered_device *rdev,
           enum nl80211_iftype iftype, int num);
 
+void __cfg80211_leave(struct cfg80211_registered_device *rdev,
+        struct wireless_dev *wdev);
 void cfg80211_leave(struct cfg80211_registered_device *rdev,
       struct wireless_dev *wdev);
 
diff --git a/net/wireless/debugfs.c b/net/wireless/debugfs.c
index 920cabe..4541577 100644
--- a/net/wireless/debugfs.c
+++ b/net/wireless/debugfs.c
@@ -47,17 +47,19 @@ static int ht_print_chan(struct ieee80211_channel *chan,
   return 0;
 
  if (chan->flags & IEEE80211_CHAN_DISABLED)
-  return snprintf(buf + offset,
-    buf_size - offset,
-    "%d Disabled\n",
-    chan->center_freq);
-
- return snprintf(buf + offset,
-   buf_size - offset,
-   "%d HT40 %c%c\n",
-   chan->center_freq,
-   (chan->flags & IEEE80211_CHAN_NO_HT40MINUS) ? ' ' : '-',
-   (chan->flags & IEEE80211_CHAN_NO_HT40PLUS)  ? ' ' : '+');
+  return scnprintf(buf + offset,
+     buf_size - offset,
+     "%d Disabled\n",
+     chan->center_freq);
+
+ return scnprintf(buf + offset,
+    buf_size - offset,
+    "%d HT40 %c%c\n",
+    chan->center_freq,
+    (chan->flags & IEEE80211_CHAN_NO_HT40MINUS) ?
+    ' ' : '-',
+    (chan->flags & IEEE80211_CHAN_NO_HT40PLUS) ?
+    ' ' : '+');
 }
 
 static ssize_t ht40allow_map_read(struct file *file,
@@ -74,7 +76,7 @@ static ssize_t ht40allow_map_read(struct file *file,
  if (!buf)
   return -ENOMEM;
 
- mutex_lock(&cfg80211_mutex);
+ rtnl_lock();
 
  for (band = 0; band < IEEE80211_NUM_BANDS; band++) {
   sband = wiphy->bands[band];
@@ -85,7 +87,7 @@ static ssize_t ht40allow_map_read(struct file *file,
       buf, buf_size, offset);
  }
 
- mutex_unlock(&cfg80211_mutex);
+ rtnl_unlock();
 
  r = simple_read_from_buffer(user_buf, count, ppos, buf, offset);
 
diff --git a/net/wireless/ethtool.c b/net/wireless/ethtool.c
index e37862f..d4860bf 100644
--- a/net/wireless/ethtool.c
+++ b/net/wireless/ethtool.c
@@ -43,7 +43,7 @@ static void cfg80211_get_ringparam(struct net_device *dev,
        struct ethtool_ringparam *rp)
 {
  struct wireless_dev *wdev = dev->ieee80211_ptr;
- struct cfg80211_registered_device *rdev = wiphy_to_dev(wdev->wiphy);
+ struct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);
 
  memset(rp, 0, sizeof(*rp));
 
@@ -56,7 +56,7 @@ static int cfg80211_set_ringparam(struct net_device *dev,
       struct ethtool_ringparam *rp)
 {
  struct wireless_dev *wdev = dev->ieee80211_ptr;
- struct cfg80211_registered_device *rdev = wiphy_to_dev(wdev->wiphy);
+ struct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);
 
  if (rp->rx_mini_pending != 0 || rp->rx_jumbo_pending != 0)
   return -EINVAL;
@@ -70,7 +70,7 @@ static int cfg80211_set_ringparam(struct net_device *dev,
 static int cfg80211_get_sset_count(struct net_device *dev, int sset)
 {
  struct wireless_dev *wdev = dev->ieee80211_ptr;
- struct cfg80211_registered_device *rdev = wiphy_to_dev(wdev->wiphy);
+ struct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);
  if (rdev->ops->get_et_sset_count)
   return rdev_get_et_sset_count(rdev, dev, sset);
  return -EOPNOTSUPP;
@@ -80,7 +80,7 @@ static void cfg80211_get_stats(struct net_device *dev,
           struct ethtool_stats *stats, u64 *data)
 {
  struct wireless_dev *wdev = dev->ieee80211_ptr;
- struct cfg80211_registered_device *rdev = wiphy_to_dev(wdev->wiphy);
+ struct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);
  if (rdev->ops->get_et_stats)
   rdev_get_et_stats(rdev, dev, stats, data);
 }
@@ -88,7 +88,7 @@ static void cfg80211_get_stats(struct net_device *dev,
 static void cfg80211_get_strings(struct net_device *dev, u32 sset, u8 *data)
 {
  struct wireless_dev *wdev = dev->ieee80211_ptr;
- struct cfg80211_registered_device *rdev = wiphy_to_dev(wdev->wiphy);
+ struct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);
  if (rdev->ops->get_et_strings)
   rdev_get_et_strings(rdev, dev, sset, data);
 }
diff --git a/net/wireless/genregdb.awk b/net/wireless/genregdb.awk
index 9392f8c..40c37fc 100644
--- a/net/wireless/genregdb.awk
+++ b/net/wireless/genregdb.awk
@@ -33,25 +33,24 @@ BEGIN {
  regdb = "const struct ieee80211_regdomain *reg_regdb[] = {\n"
 }
 
-/^[ \t]*#/ {
- # Ignore
-}
-
-!active && /^[ \t]*$/ {
- # Ignore
-}
-
-!active && /country/ {
+function parse_country_head() {
  country=$2
  sub(/:/, "", country)
  printf "static const struct ieee80211_regdomain regdom_%s = {\n", country
  printf "\t.alpha2 = \"%s\",\n", country
+ if ($NF ~ /DFS-ETSI/)
+  printf "\t.dfs_region = NL80211_DFS_ETSI,\n"
+ else if ($NF ~ /DFS-FCC/)
+  printf "\t.dfs_region = NL80211_DFS_FCC,\n"
+ else if ($NF ~ /DFS-JP/)
+  printf "\t.dfs_region = NL80211_DFS_JP,\n"
  printf "\t.reg_rules = {\n"
  active = 1
  regdb = regdb "\t&regdom_" country ",\n"
 }
 
-active && /^[ \t]*\(/ {
+function parse_reg_rule()
+{
  start = $1
  sub(/\(/, "", start)
  end = $3
@@ -67,19 +66,15 @@ active && /^[ \t]*\(/ {
  units = $8
  sub(/\)/, "", units)
  sub(/,/, "", units)
+ dfs_cac = $9
  if (units == "mW") {
-  if (power == 100) {
-   power = 20
-  } else if (power == 200) {
-   power = 23
-  } else if (power == 500) {
-   power = 27
-  } else if (power == 1000) {
-   power = 30
-  } else {
-   print "Unknown power value in database!"
-  }
+  power = 10 * log(power)/log(10)
+ } else {
+  dfs_cac = $8
  }
+ sub(/,/, "", dfs_cac)
+ sub(/\(/, "", dfs_cac)
+ sub(/\)/, "", dfs_cac)
  flagstr = ""
  for (i=8; i<=NF; i++)
   flagstr = flagstr $i
@@ -101,17 +96,23 @@ active && /^[ \t]*\(/ {
   } else if (flagarray[arg] == "PTMP-ONLY") {
    flags = flags "\n\t\t\tNL80211_RRF_PTMP_ONLY | "
   } else if (flagarray[arg] == "PASSIVE-SCAN") {
-   flags = flags "\n\t\t\tNL80211_RRF_PASSIVE_SCAN | "
+   flags = flags "\n\t\t\tNL80211_RRF_NO_IR | "
   } else if (flagarray[arg] == "NO-IBSS") {
-   flags = flags "\n\t\t\tNL80211_RRF_NO_IBSS | "
+   flags = flags "\n\t\t\tNL80211_RRF_NO_IR | "
+  } else if (flagarray[arg] == "NO-IR") {
+   flags = flags "\n\t\t\tNL80211_RRF_NO_IR | "
+  } else if (flagarray[arg] == "AUTO-BW") {
+   flags = flags "\n\t\t\tNL80211_RRF_AUTO_BW | "
   }
+
  }
  flags = flags "0"
- printf "\t\tREG_RULE(%d, %d, %d, %d, %d, %s),\n", start, end, bw, gain, power, flags
+ printf "\t\tREG_RULE_EXT(%d, %d, %d, %d, %.0f, %d, %s),\n", start, end, bw, gain, power, dfs_cac, flags
  rules++
 }
 
-active && /^[ \t]*$/ {
+function print_tail_country()
+{
  active = 0
  printf "\t},\n"
  printf "\t.n_reg_rules = %d\n", rules
@@ -119,7 +120,29 @@ active && /^[ \t]*$/ {
  rules = 0;
 }
 
+/^[ \t]*#/ {
+ # Ignore
+}
+
+!active && /^[ \t]*$/ {
+ # Ignore
+}
+
+!active && /country/ {
+ parse_country_head()
+}
+
+active && /^[ \t]*\(/ {
+ parse_reg_rule()
+}
+
+active && /^[ \t]*$/ {
+ print_tail_country()
+}
+
 END {
+ if (active)
+  print_tail_country()
  print regdb "};"
  print ""
  print "int reg_regdb_size = ARRAY_SIZE(reg_regdb);"
diff --git a/net/wireless/ibss.c b/net/wireless/ibss.c
index e62c1ad..8f345da 100644
--- a/net/wireless/ibss.c
+++ b/net/wireless/ibss.c
@@ -14,7 +14,8 @@
 #include "rdev-ops.h"
 
 
-void __cfg80211_ibss_joined(struct net_device *dev, const u8 *bssid)
+void __cfg80211_ibss_joined(struct net_device *dev, const u8 *bssid,
+       struct ieee80211_channel *channel)
 {
  struct wireless_dev *wdev = dev->ieee80211_ptr;
  struct cfg80211_bss *bss;
@@ -28,8 +29,7 @@ void __cfg80211_ibss_joined(struct net_device *dev, const u8 *bssid)
  if (!wdev->ssid_len)
   return;
 
- bss = cfg80211_get_bss(wdev->wiphy, NULL, bssid,
-          wdev->ssid, wdev->ssid_len,
+ bss = cfg80211_get_bss(wdev->wiphy, channel, bssid, NULL, 0,
           WLAN_CAPABILITY_IBSS, WLAN_CAPABILITY_IBSS);
 
  if (WARN_ON(!bss))
@@ -43,10 +43,9 @@ void __cfg80211_ibss_joined(struct net_device *dev, const u8 *bssid)
  cfg80211_hold_bss(bss_from_pub(bss));
  wdev->current_bss = bss_from_pub(bss);
 
- wdev->sme_state = CFG80211_SME_CONNECTED;
  cfg80211_upload_connect_keys(wdev);
 
- nl80211_send_ibss_bssid(wiphy_to_dev(wdev->wiphy), dev, bssid,
+ nl80211_send_ibss_bssid(wiphy_to_rdev(wdev->wiphy), dev, bssid,
     GFP_KERNEL);
 #ifdef CONFIG_CFG80211_WEXT
  memset(&wrqu, 0, sizeof(wrqu));
@@ -55,23 +54,26 @@ void __cfg80211_ibss_joined(struct net_device *dev, const u8 *bssid)
 #endif
 }
 
-void cfg80211_ibss_joined(struct net_device *dev, const u8 *bssid, gfp_t gfp)
+void cfg80211_ibss_joined(struct net_device *dev, const u8 *bssid,
+     struct ieee80211_channel *channel, gfp_t gfp)
 {
  struct wireless_dev *wdev = dev->ieee80211_ptr;
- struct cfg80211_registered_device *rdev = wiphy_to_dev(wdev->wiphy);
+ struct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);
  struct cfg80211_event *ev;
  unsigned long flags;
 
- trace_cfg80211_ibss_joined(dev, bssid);
+ trace_cfg80211_ibss_joined(dev, bssid, channel);
 
- CFG80211_DEV_WARN_ON(wdev->sme_state != CFG80211_SME_CONNECTING);
+ if (WARN_ON(!channel))
+  return;
 
  ev = kzalloc(sizeof(*ev), gfp);
  if (!ev)
   return;
 
  ev->type = EVENT_IBSS_JOINED;
- memcpy(ev->cr.bssid, bssid, ETH_ALEN);
+ memcpy(ev->ij.bssid, bssid, ETH_ALEN);
+ ev->ij.channel = channel;
 
  spin_lock_irqsave(&wdev->event_lock, flags);
  list_add_tail(&ev->list, &wdev->event_list);
@@ -80,10 +82,10 @@ void cfg80211_ibss_joined(struct net_device *dev, const u8 *bssid, gfp_t gfp)
 }
 EXPORT_SYMBOL(cfg80211_ibss_joined);
 
-int __cfg80211_join_ibss(struct cfg80211_registered_device *rdev,
-    struct net_device *dev,
-    struct cfg80211_ibss_params *params,
-    struct cfg80211_cached_keys *connkeys)
+static int __cfg80211_join_ibss(struct cfg80211_registered_device *rdev,
+    struct net_device *dev,
+    struct cfg80211_ibss_params *params,
+    struct cfg80211_cached_keys *connkeys)
 {
  struct wireless_dev *wdev = dev->ieee80211_ptr;
  int err;
@@ -117,24 +119,14 @@ int __cfg80211_join_ibss(struct cfg80211_registered_device *rdev,
  wdev->connect_keys = connkeys;
 
  wdev->ibss_fixed = params->channel_fixed;
+ wdev->ibss_dfs_possible = params->userspace_handles_dfs;
+ wdev->chandef = params->chandef;
 #ifdef CONFIG_CFG80211_WEXT
  wdev->wext.ibss.chandef = params->chandef;
 #endif
- wdev->sme_state = CFG80211_SME_CONNECTING;
-
- err = cfg80211_can_use_chan(rdev, wdev, params->chandef.chan,
-        params->channel_fixed
-        ? CHAN_MODE_SHARED
-        : CHAN_MODE_EXCLUSIVE);
- if (err) {
-  wdev->connect_keys = NULL;
-  return err;
- }
-
  err = rdev_join_ibss(rdev, dev, params);
  if (err) {
   wdev->connect_keys = NULL;
-  wdev->sme_state = CFG80211_SME_IDLE;
   return err;
  }
 
@@ -152,11 +144,11 @@ int cfg80211_join_ibss(struct cfg80211_registered_device *rdev,
  struct wireless_dev *wdev = dev->ieee80211_ptr;
  int err;
 
- mutex_lock(&rdev->devlist_mtx);
+ ASSERT_RTNL();
+
  wdev_lock(wdev);
  err = __cfg80211_join_ibss(rdev, dev, params, connkeys);
  wdev_unlock(wdev);
- mutex_unlock(&rdev->devlist_mtx);
 
  return err;
 }
@@ -164,7 +156,7 @@ int cfg80211_join_ibss(struct cfg80211_registered_device *rdev,
 static void __cfg80211_clear_ibss(struct net_device *dev, bool nowext)
 {
  struct wireless_dev *wdev = dev->ieee80211_ptr;
- struct cfg80211_registered_device *rdev = wiphy_to_dev(wdev->wiphy);
+ struct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);
  int i;
 
  ASSERT_WDEV_LOCK(wdev);
@@ -172,6 +164,8 @@ static void __cfg80211_clear_ibss(struct net_device *dev, bool nowext)
  kfree(wdev->connect_keys);
  wdev->connect_keys = NULL;
 
+ rdev_set_qos_map(rdev, dev, NULL);
+
  /*
   * Delete all the keys ... pairwise keys can't really
   * exist any more anyway, but default keys might.
@@ -186,8 +180,8 @@ static void __cfg80211_clear_ibss(struct net_device *dev, bool nowext)
  }
 
  wdev->current_bss = NULL;
- wdev->sme_state = CFG80211_SME_IDLE;
  wdev->ssid_len = 0;
+ memset(&wdev->chandef, 0, sizeof(wdev->chandef));
 #ifdef CONFIG_CFG80211_WEXT
  if (!nowext)
   wdev->wext.ibss.ssid_len = 0;
@@ -252,7 +246,7 @@ int cfg80211_ibss_wext_join(struct cfg80211_registered_device *rdev,
 
  /* try to find an IBSS channel if none requested ... */
  if (!wdev->wext.ibss.chandef.chan) {
-  wdev->wext.ibss.chandef.width = NL80211_CHAN_WIDTH_20_NOHT;
+  struct ieee80211_channel *new_chan = NULL;
 
   for (band = 0; band < IEEE80211_NUM_BANDS; band++) {
    struct ieee80211_supported_band *sband;
@@ -264,22 +258,23 @@ int cfg80211_ibss_wext_join(struct cfg80211_registered_device *rdev,
 
    for (i = 0; i < sband->n_channels; i++) {
     chan = &sband->channels[i];
-    if (chan->flags & IEEE80211_CHAN_NO_IBSS)
+    if (chan->flags & IEEE80211_CHAN_NO_IR)
      continue;
     if (chan->flags & IEEE80211_CHAN_DISABLED)
      continue;
-    wdev->wext.ibss.chandef.chan = chan;
-    wdev->wext.ibss.chandef.center_freq1 =
-     chan->center_freq;
+    new_chan = chan;
     break;
    }
 
-   if (wdev->wext.ibss.chandef.chan)
+   if (new_chan)
     break;
   }
 
-  if (!wdev->wext.ibss.chandef.chan)
+  if (!new_chan)
    return -EINVAL;
+
+  cfg80211_chandef_create(&wdev->wext.ibss.chandef, new_chan,
+     NL80211_CHAN_NO_HT);
  }
 
  /* don't join -- SSID is not there */
@@ -316,7 +311,7 @@ int cfg80211_ibss_wext_siwfreq(struct net_device *dev,
           struct iw_freq *wextfreq, char *extra)
 {
  struct wireless_dev *wdev = dev->ieee80211_ptr;
- struct cfg80211_registered_device *rdev = wiphy_to_dev(wdev->wiphy);
+ struct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);
  struct ieee80211_channel *chan = NULL;
  int err, freq;
 
@@ -327,7 +322,7 @@ int cfg80211_ibss_wext_siwfreq(struct net_device *dev,
  if (!rdev->ops->join_ibss)
   return -EOPNOTSUPP;
 
- freq = cfg80211_wext_freq(wdev->wiphy, wextfreq);
+ freq = cfg80211_wext_freq(wextfreq);
  if (freq < 0)
   return freq;
 
@@ -335,7 +330,7 @@ int cfg80211_ibss_wext_siwfreq(struct net_device *dev,
   chan = ieee80211_get_channel(wdev->wiphy, freq);
   if (!chan)
    return -EINVAL;
-  if (chan->flags & IEEE80211_CHAN_NO_IBSS ||
+  if (chan->flags & IEEE80211_CHAN_NO_IR ||
       chan->flags & IEEE80211_CHAN_DISABLED)
    return -EINVAL;
  }
@@ -353,20 +348,17 @@ int cfg80211_ibss_wext_siwfreq(struct net_device *dev,
   return err;
 
  if (chan) {
-  wdev->wext.ibss.chandef.chan = chan;
-  wdev->wext.ibss.chandef.width = NL80211_CHAN_WIDTH_20_NOHT;
-  wdev->wext.ibss.chandef.center_freq1 = freq;
+  cfg80211_chandef_create(&wdev->wext.ibss.chandef, chan,
+     NL80211_CHAN_NO_HT);
   wdev->wext.ibss.channel_fixed = true;
  } else {
   /* cfg80211_ibss_wext_join will pick one if needed */
   wdev->wext.ibss.channel_fixed = false;
  }
 
- mutex_lock(&rdev->devlist_mtx);
  wdev_lock(wdev);
  err = cfg80211_ibss_wext_join(rdev, wdev);
  wdev_unlock(wdev);
- mutex_unlock(&rdev->devlist_mtx);
 
  return err;
 }
@@ -404,7 +396,7 @@ int cfg80211_ibss_wext_siwessid(struct net_device *dev,
     struct iw_point *data, char *ssid)
 {
  struct wireless_dev *wdev = dev->ieee80211_ptr;
- struct cfg80211_registered_device *rdev = wiphy_to_dev(wdev->wiphy);
+ struct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);
  size_t len = data->length;
  int err;
 
@@ -428,15 +420,13 @@ int cfg80211_ibss_wext_siwessid(struct net_device *dev,
  if (len > 0 && ssid[len - 1] == '\0')
   len--;
 
+ memcpy(wdev->ssid, ssid, len);
  wdev->wext.ibss.ssid = wdev->ssid;
- memcpy(wdev->wext.ibss.ssid, ssid, len);
  wdev->wext.ibss.ssid_len = len;
 
- mutex_lock(&rdev->devlist_mtx);
  wdev_lock(wdev);
  err = cfg80211_ibss_wext_join(rdev, wdev);
  wdev_unlock(wdev);
- mutex_unlock(&rdev->devlist_mtx);
 
  return err;
 }
@@ -473,7 +463,7 @@ int cfg80211_ibss_wext_siwap(struct net_device *dev,
         struct sockaddr *ap_addr, char *extra)
 {
  struct wireless_dev *wdev = dev->ieee80211_ptr;
- struct cfg80211_registered_device *rdev = wiphy_to_dev(wdev->wiphy);
+ struct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);
  u8 *bssid = ap_addr->sa_data;
  int err;
 
@@ -491,6 +481,9 @@ int cfg80211_ibss_wext_siwap(struct net_device *dev,
  if (is_zero_ether_addr(bssid) || is_broadcast_ether_addr(bssid))
   bssid = NULL;
 
+ if (bssid && !is_valid_ether_addr(bssid))
+  return -EINVAL;
+
  /* both automatic */
  if (!bssid && !wdev->wext.ibss.bssid)
   return 0;
@@ -515,11 +508,9 @@ int cfg80211_ibss_wext_siwap(struct net_device *dev,
  } else
   wdev->wext.ibss.bssid = NULL;
 
- mutex_lock(&rdev->devlist_mtx);
  wdev_lock(wdev);
  err = cfg80211_ibss_wext_join(rdev, wdev);
  wdev_unlock(wdev);
- mutex_unlock(&rdev->devlist_mtx);
 
  return err;
 }
diff --git a/net/wireless/mesh.c b/net/wireless/mesh.c
index 0bb93f3..092300b 100644
--- a/net/wireless/mesh.c
+++ b/net/wireless/mesh.c
@@ -18,6 +18,7 @@
 #define MESH_PATH_TO_ROOT_TIMEOUT      6000
 #define MESH_ROOT_INTERVAL     5000
 #define MESH_ROOT_CONFIRMATION_INTERVAL 2000
+#define MESH_DEFAULT_PLINK_TIMEOUT 1800 /* timeout in seconds */
 
 /*
  * Minimum interval between two consecutive PREQs originated by the same
@@ -75,6 +76,7 @@ const struct mesh_config default_mesh_config = {
  .dot11MeshHWMPconfirmationInterval = MESH_ROOT_CONFIRMATION_INTERVAL,
  .power_mode = NL80211_MESH_POWER_ACTIVE,
  .dot11MeshAwakeWindowDuration = MESH_DEFAULT_AWAKE_WINDOW,
+ .plink_timeout = MESH_DEFAULT_PLINK_TIMEOUT,
 };
 
 const struct mesh_setup default_mesh_setup = {
@@ -82,6 +84,7 @@ const struct mesh_setup default_mesh_setup = {
  .sync_method = IEEE80211_SYNC_METHOD_NEIGHBOR_OFFSET,
  .path_sel_proto = IEEE80211_PATH_PROTOCOL_HWMP,
  .path_metric = IEEE80211_PATH_METRIC_AIRTIME,
+ .auth_id = 0, /* open */
  .ie = NULL,
  .ie_len = 0,
  .is_secure = false,
@@ -138,8 +141,7 @@ int __cfg80211_join_mesh(struct cfg80211_registered_device *rdev,
 
    for (i = 0; i < sband->n_channels; i++) {
     chan = &sband->channels[i];
-    if (chan->flags & (IEEE80211_CHAN_NO_IBSS |
-         IEEE80211_CHAN_PASSIVE_SCAN |
+    if (chan->flags & (IEEE80211_CHAN_NO_IR |
          IEEE80211_CHAN_DISABLED |
          IEEE80211_CHAN_RADAR))
      continue;
@@ -159,19 +161,28 @@ int __cfg80211_join_mesh(struct cfg80211_registered_device *rdev,
   setup->chandef.center_freq1 = setup->chandef.chan->center_freq;
  }
 
- if (!cfg80211_reg_can_beacon(&rdev->wiphy, &setup->chandef))
-  return -EINVAL;
+ /*
+  * check if basic rates are available otherwise use mandatory rates as
+  * basic rates
+  */
+ if (!setup->basic_rates) {
+  enum nl80211_bss_scan_width scan_width;
+  struct ieee80211_supported_band *sband =
+    rdev->wiphy.bands[setup->chandef.chan->band];
+  scan_width = cfg80211_chandef_to_scan_width(&setup->chandef);
+  setup->basic_rates = ieee80211_mandatory_rates(sband,
+              scan_width);
+ }
 
- err = cfg80211_can_use_chan(rdev, wdev, setup->chandef.chan,
-        CHAN_MODE_SHARED);
- if (err)
-  return err;
+ if (!cfg80211_reg_can_beacon(&rdev->wiphy, &setup->chandef,
+         NL80211_IFTYPE_MESH_POINT))
+  return -EINVAL;
 
  err = rdev_join_mesh(rdev, dev, conf, setup);
  if (!err) {
   memcpy(wdev->ssid, setup->mesh_id, setup->mesh_id_len);
   wdev->mesh_id_len = setup->mesh_id_len;
-  wdev->channel = setup->chandef.chan;
+  wdev->chandef = setup->chandef;
  }
 
  return err;
@@ -185,11 +196,9 @@ int cfg80211_join_mesh(struct cfg80211_registered_device *rdev,
  struct wireless_dev *wdev = dev->ieee80211_ptr;
  int err;
 
- mutex_lock(&rdev->devlist_mtx);
  wdev_lock(wdev);
  err = __cfg80211_join_mesh(rdev, dev, setup, conf);
  wdev_unlock(wdev);
- mutex_unlock(&rdev->devlist_mtx);
 
  return err;
 }
@@ -214,15 +223,10 @@ int cfg80211_set_mesh_channel(struct cfg80211_registered_device *rdev,
   if (!netif_running(wdev->netdev))
    return -ENETDOWN;
 
-  err = cfg80211_can_use_chan(rdev, wdev, chandef->chan,
-         CHAN_MODE_SHARED);
-  if (err)
-   return err;
-
   err = rdev_libertas_set_mesh_channel(rdev, wdev->netdev,
            chandef->chan);
   if (!err)
-   wdev->channel = chandef->chan;
+   wdev->chandef = *chandef;
 
   return err;
  }
@@ -234,8 +238,8 @@ int cfg80211_set_mesh_channel(struct cfg80211_registered_device *rdev,
  return 0;
 }
 
-static int __cfg80211_leave_mesh(struct cfg80211_registered_device *rdev,
-     struct net_device *dev)
+int __cfg80211_leave_mesh(struct cfg80211_registered_device *rdev,
+     struct net_device *dev)
 {
  struct wireless_dev *wdev = dev->ieee80211_ptr;
  int err;
@@ -254,7 +258,8 @@ static int __cfg80211_leave_mesh(struct cfg80211_registered_device *rdev,
  err = rdev_leave_mesh(rdev, dev);
  if (!err) {
   wdev->mesh_id_len = 0;
-  wdev->channel = NULL;
+  memset(&wdev->chandef, 0, sizeof(wdev->chandef));
+  rdev_set_qos_map(rdev, dev, NULL);
  }
 
  return err;
diff --git a/net/wireless/mlme.c b/net/wireless/mlme.c
index 0c7b7dd..266766b 100644
--- a/net/wireless/mlme.c
+++ b/net/wireless/mlme.c
@@ -18,37 +18,18 @@
 #include "rdev-ops.h"
 
 
-void cfg80211_send_rx_auth(struct net_device *dev, const u8 *buf, size_t len)
-{
- struct wireless_dev *wdev = dev->ieee80211_ptr;
- struct wiphy *wiphy = wdev->wiphy;
- struct cfg80211_registered_device *rdev = wiphy_to_dev(wiphy);
-
- trace_cfg80211_send_rx_auth(dev);
- wdev_lock(wdev);
-
- nl80211_send_rx_auth(rdev, dev, buf, len, GFP_KERNEL);
- cfg80211_sme_rx_auth(dev, buf, len);
-
- wdev_unlock(wdev);
-}
-EXPORT_SYMBOL(cfg80211_send_rx_auth);
-
-void cfg80211_send_rx_assoc(struct net_device *dev, struct cfg80211_bss *bss,
+void cfg80211_rx_assoc_resp(struct net_device *dev, struct cfg80211_bss *bss,
        const u8 *buf, size_t len)
 {
- u16 status_code;
  struct wireless_dev *wdev = dev->ieee80211_ptr;
  struct wiphy *wiphy = wdev->wiphy;
- struct cfg80211_registered_device *rdev = wiphy_to_dev(wiphy);
+ struct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);
  struct ieee80211_mgmt *mgmt = (struct ieee80211_mgmt *)buf;
  u8 *ie = mgmt->u.assoc_resp.variable;
  int ieoffs = offsetof(struct ieee80211_mgmt, u.assoc_resp.variable);
+ u16 status_code = le16_to_cpu(mgmt->u.assoc_resp.status_code);
 
  trace_cfg80211_send_rx_assoc(dev, bss);
- wdev_lock(wdev);
-
- status_code = le16_to_cpu(mgmt->u.assoc_resp.status_code);
 
  /*
   * This is a bit of a hack, we don't notify userspace of
@@ -56,181 +37,142 @@ void cfg80211_send_rx_assoc(struct net_device *dev, struct cfg80211_bss *bss,
   * and got a reject -- we only try again with an assoc
   * frame instead of reassoc.
   */
- if (status_code != WLAN_STATUS_SUCCESS && wdev->conn &&
-     cfg80211_sme_failed_reassoc(wdev)) {
+ if (cfg80211_sme_rx_assoc_resp(wdev, status_code)) {
+  cfg80211_unhold_bss(bss_from_pub(bss));
   cfg80211_put_bss(wiphy, bss);
-  goto out;
+  return;
  }
 
  nl80211_send_rx_assoc(rdev, dev, buf, len, GFP_KERNEL);
-
- if (status_code != WLAN_STATUS_SUCCESS && wdev->conn) {
-  cfg80211_sme_failed_assoc(wdev);
-  /*
-   * do not call connect_result() now because the
-   * sme will schedule work that does it later.
-   */
-  cfg80211_put_bss(wiphy, bss);
-  goto out;
- }
-
- if (!wdev->conn && wdev->sme_state == CFG80211_SME_IDLE) {
-  /*
-   * This is for the userspace SME, the CONNECTING
-   * state will be changed to CONNECTED by
-   * __cfg80211_connect_result() below.
-   */
-  wdev->sme_state = CFG80211_SME_CONNECTING;
- }
-
- /* this consumes the bss reference */
+ /* update current_bss etc., consumes the bss reference */
  __cfg80211_connect_result(dev, mgmt->bssid, NULL, 0, ie, len - ieoffs,
       status_code,
       status_code == WLAN_STATUS_SUCCESS, bss);
- out:
- wdev_unlock(wdev);
 }
-EXPORT_SYMBOL(cfg80211_send_rx_assoc);
+EXPORT_SYMBOL(cfg80211_rx_assoc_resp);
 
-void __cfg80211_send_deauth(struct net_device *dev,
-       const u8 *buf, size_t len)
+static void cfg80211_process_auth(struct wireless_dev *wdev,
+      const u8 *buf, size_t len)
 {
- struct wireless_dev *wdev = dev->ieee80211_ptr;
- struct wiphy *wiphy = wdev->wiphy;
- struct cfg80211_registered_device *rdev = wiphy_to_dev(wiphy);
- struct ieee80211_mgmt *mgmt = (struct ieee80211_mgmt *)buf;
- const u8 *bssid = mgmt->bssid;
- bool was_current = false;
+ struct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);
 
- trace___cfg80211_send_deauth(dev);
- ASSERT_WDEV_LOCK(wdev);
-
- if (wdev->current_bss &&
-     ether_addr_equal(wdev->current_bss->pub.bssid, bssid)) {
-  cfg80211_unhold_bss(wdev->current_bss);
-  cfg80211_put_bss(wiphy, &wdev->current_bss->pub);
-  wdev->current_bss = NULL;
-  was_current = true;
- }
+ nl80211_send_rx_auth(rdev, wdev->netdev, buf, len, GFP_KERNEL);
+ cfg80211_sme_rx_auth(wdev, buf, len);
+}
 
- nl80211_send_deauth(rdev, dev, buf, len, GFP_KERNEL);
+static void cfg80211_process_deauth(struct wireless_dev *wdev,
+        const u8 *buf, size_t len)
+{
+ struct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);
+ struct ieee80211_mgmt *mgmt = (struct ieee80211_mgmt *)buf;
+ const u8 *bssid = mgmt->bssid;
+ u16 reason_code = le16_to_cpu(mgmt->u.deauth.reason_code);
+ bool from_ap = !ether_addr_equal(mgmt->sa, wdev->netdev->dev_addr);
 
- if (wdev->sme_state == CFG80211_SME_CONNECTED && was_current) {
-  u16 reason_code;
-  bool from_ap;
+ nl80211_send_deauth(rdev, wdev->netdev, buf, len, GFP_KERNEL);
 
-  reason_code = le16_to_cpu(mgmt->u.deauth.reason_code);
+ if (!wdev->current_bss ||
+     !ether_addr_equal(wdev->current_bss->pub.bssid, bssid))
+  return;
 
-  from_ap = !ether_addr_equal(mgmt->sa, dev->dev_addr);
-  __cfg80211_disconnected(dev, NULL, 0, reason_code, from_ap);
- } else if (wdev->sme_state == CFG80211_SME_CONNECTING) {
-  __cfg80211_connect_result(dev, mgmt->bssid, NULL, 0, NULL, 0,
-       WLAN_STATUS_UNSPECIFIED_FAILURE,
-       false, NULL);
- }
+ __cfg80211_disconnected(wdev->netdev, NULL, 0, reason_code, from_ap);
+ cfg80211_sme_deauth(wdev);
 }
-EXPORT_SYMBOL(__cfg80211_send_deauth);
 
-void cfg80211_send_deauth(struct net_device *dev, const u8 *buf, size_t len)
+static void cfg80211_process_disassoc(struct wireless_dev *wdev,
+          const u8 *buf, size_t len)
 {
- struct wireless_dev *wdev = dev->ieee80211_ptr;
+ struct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);
+ struct ieee80211_mgmt *mgmt = (struct ieee80211_mgmt *)buf;
+ const u8 *bssid = mgmt->bssid;
+ u16 reason_code = le16_to_cpu(mgmt->u.disassoc.reason_code);
+ bool from_ap = !ether_addr_equal(mgmt->sa, wdev->netdev->dev_addr);
 
- wdev_lock(wdev);
- __cfg80211_send_deauth(dev, buf, len);
- wdev_unlock(wdev);
+ nl80211_send_disassoc(rdev, wdev->netdev, buf, len, GFP_KERNEL);
+
+ if (WARN_ON(!wdev->current_bss ||
+      !ether_addr_equal(wdev->current_bss->pub.bssid, bssid)))
+  return;
+
+ __cfg80211_disconnected(wdev->netdev, NULL, 0, reason_code, from_ap);
+ cfg80211_sme_disassoc(wdev);
 }
-EXPORT_SYMBOL(cfg80211_send_deauth);
 
-void __cfg80211_send_disassoc(struct net_device *dev,
-         const u8 *buf, size_t len)
+void cfg80211_rx_mlme_mgmt(struct net_device *dev, const u8 *buf, size_t len)
 {
  struct wireless_dev *wdev = dev->ieee80211_ptr;
- struct wiphy *wiphy = wdev->wiphy;
- struct cfg80211_registered_device *rdev = wiphy_to_dev(wiphy);
- struct ieee80211_mgmt *mgmt = (struct ieee80211_mgmt *)buf;
- const u8 *bssid = mgmt->bssid;
- u16 reason_code;
- bool from_ap;
+ struct ieee80211_mgmt *mgmt = (void *)buf;
 
- trace___cfg80211_send_disassoc(dev);
  ASSERT_WDEV_LOCK(wdev);
 
- nl80211_send_disassoc(rdev, dev, buf, len, GFP_KERNEL);
+ trace_cfg80211_rx_mlme_mgmt(dev, buf, len);
 
- if (wdev->sme_state != CFG80211_SME_CONNECTED)
+ if (WARN_ON(len < 2))
   return;
 
- if (wdev->current_bss &&
-     ether_addr_equal(wdev->current_bss->pub.bssid, bssid)) {
-  cfg80211_sme_disassoc(dev, wdev->current_bss);
-  cfg80211_unhold_bss(wdev->current_bss);
-  cfg80211_put_bss(wiphy, &wdev->current_bss->pub);
-  wdev->current_bss = NULL;
- } else
-  WARN_ON(1);
-
-
- reason_code = le16_to_cpu(mgmt->u.disassoc.reason_code);
-
- from_ap = !ether_addr_equal(mgmt->sa, dev->dev_addr);
- __cfg80211_disconnected(dev, NULL, 0, reason_code, from_ap);
+ if (ieee80211_is_auth(mgmt->frame_control))
+  cfg80211_process_auth(wdev, buf, len);
+ else if (ieee80211_is_deauth(mgmt->frame_control))
+  cfg80211_process_deauth(wdev, buf, len);
+ else if (ieee80211_is_disassoc(mgmt->frame_control))
+  cfg80211_process_disassoc(wdev, buf, len);
 }
-EXPORT_SYMBOL(__cfg80211_send_disassoc);
+EXPORT_SYMBOL(cfg80211_rx_mlme_mgmt);
 
-void cfg80211_send_disassoc(struct net_device *dev, const u8 *buf, size_t len)
+void cfg80211_auth_timeout(struct net_device *dev, const u8 *addr)
 {
  struct wireless_dev *wdev = dev->ieee80211_ptr;
+ struct wiphy *wiphy = wdev->wiphy;
+ struct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);
+
+ trace_cfg80211_send_auth_timeout(dev, addr);
 
- wdev_lock(wdev);
- __cfg80211_send_disassoc(dev, buf, len);
- wdev_unlock(wdev);
+ nl80211_send_auth_timeout(rdev, dev, addr, GFP_KERNEL);
+ cfg80211_sme_auth_timeout(wdev);
 }
-EXPORT_SYMBOL(cfg80211_send_disassoc);
+EXPORT_SYMBOL(cfg80211_auth_timeout);
 
-void cfg80211_send_auth_timeout(struct net_device *dev, const u8 *addr)
+void cfg80211_assoc_timeout(struct net_device *dev, struct cfg80211_bss *bss)
 {
  struct wireless_dev *wdev = dev->ieee80211_ptr;
  struct wiphy *wiphy = wdev->wiphy;
- struct cfg80211_registered_device *rdev = wiphy_to_dev(wiphy);
+ struct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);
 
- trace_cfg80211_send_auth_timeout(dev, addr);
- wdev_lock(wdev);
+ trace_cfg80211_send_assoc_timeout(dev, bss->bssid);
 
- nl80211_send_auth_timeout(rdev, dev, addr, GFP_KERNEL);
- if (wdev->sme_state == CFG80211_SME_CONNECTING)
-  __cfg80211_connect_result(dev, addr, NULL, 0, NULL, 0,
-       WLAN_STATUS_UNSPECIFIED_FAILURE,
-       false, NULL);
+ nl80211_send_assoc_timeout(rdev, dev, bss->bssid, GFP_KERNEL);
+ cfg80211_sme_assoc_timeout(wdev);
 
- wdev_unlock(wdev);
+ cfg80211_unhold_bss(bss_from_pub(bss));
+ cfg80211_put_bss(wiphy, bss);
 }
-EXPORT_SYMBOL(cfg80211_send_auth_timeout);
+EXPORT_SYMBOL(cfg80211_assoc_timeout);
 
-void cfg80211_send_assoc_timeout(struct net_device *dev, const u8 *addr)
+void cfg80211_tx_mlme_mgmt(struct net_device *dev, const u8 *buf, size_t len)
 {
  struct wireless_dev *wdev = dev->ieee80211_ptr;
- struct wiphy *wiphy = wdev->wiphy;
- struct cfg80211_registered_device *rdev = wiphy_to_dev(wiphy);
+ struct ieee80211_mgmt *mgmt = (void *)buf;
 
- trace_cfg80211_send_assoc_timeout(dev, addr);
- wdev_lock(wdev);
+ ASSERT_WDEV_LOCK(wdev);
+
+ trace_cfg80211_tx_mlme_mgmt(dev, buf, len);
 
- nl80211_send_assoc_timeout(rdev, dev, addr, GFP_KERNEL);
- if (wdev->sme_state == CFG80211_SME_CONNECTING)
-  __cfg80211_connect_result(dev, addr, NULL, 0, NULL, 0,
-       WLAN_STATUS_UNSPECIFIED_FAILURE,
-       false, NULL);
+ if (WARN_ON(len < 2))
+  return;
 
- wdev_unlock(wdev);
+ if (ieee80211_is_deauth(mgmt->frame_control))
+  cfg80211_process_deauth(wdev, buf, len);
+ else
+  cfg80211_process_disassoc(wdev, buf, len);
 }
-EXPORT_SYMBOL(cfg80211_send_assoc_timeout);
+EXPORT_SYMBOL(cfg80211_tx_mlme_mgmt);
 
 void cfg80211_michael_mic_failure(struct net_device *dev, const u8 *addr,
       enum nl80211_key_type key_type, int key_id,
       const u8 *tsc, gfp_t gfp)
 {
  struct wiphy *wiphy = dev->ieee80211_ptr->wiphy;
- struct cfg80211_registered_device *rdev = wiphy_to_dev(wiphy);
+ struct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);
 #ifdef CONFIG_CFG80211_WEXT
  union iwreq_data wrqu;
  char *buf = kmalloc(128, gfp);
@@ -253,18 +195,27 @@ void cfg80211_michael_mic_failure(struct net_device *dev, const u8 *addr,
 EXPORT_SYMBOL(cfg80211_michael_mic_failure);
 
 /* some MLME handling for userspace SME */
-int __cfg80211_mlme_auth(struct cfg80211_registered_device *rdev,
-    struct net_device *dev,
-    struct ieee80211_channel *chan,
-    enum nl80211_auth_type auth_type,
-    const u8 *bssid,
-    const u8 *ssid, int ssid_len,
-    const u8 *ie, int ie_len,
-    const u8 *key, int key_len, int key_idx,
-    const u8 *sae_data, int sae_data_len)
+int cfg80211_mlme_auth(struct cfg80211_registered_device *rdev,
+         struct net_device *dev,
+         struct ieee80211_channel *chan,
+         enum nl80211_auth_type auth_type,
+         const u8 *bssid,
+         const u8 *ssid, int ssid_len,
+         const u8 *ie, int ie_len,
+         const u8 *key, int key_len, int key_idx,
+         const u8 *sae_data, int sae_data_len)
 {
  struct wireless_dev *wdev = dev->ieee80211_ptr;
- struct cfg80211_auth_request req;
+ struct cfg80211_auth_request req = {
+  .ie = ie,
+  .ie_len = ie_len,
+  .sae_data = sae_data,
+  .sae_data_len = sae_data_len,
+  .auth_type = auth_type,
+  .key = key,
+  .key_len = key_len,
+  .key_idx = key_idx,
+ };
  int err;
 
  ASSERT_WDEV_LOCK(wdev);
@@ -277,55 +228,17 @@ int __cfg80211_mlme_auth(struct cfg80211_registered_device *rdev,
      ether_addr_equal(bssid, wdev->current_bss->pub.bssid))
   return -EALREADY;
 
- memset(&req, 0, sizeof(req));
-
- req.ie = ie;
- req.ie_len = ie_len;
- req.sae_data = sae_data;
- req.sae_data_len = sae_data_len;
- req.auth_type = auth_type;
  req.bss = cfg80211_get_bss(&rdev->wiphy, chan, bssid, ssid, ssid_len,
        WLAN_CAPABILITY_ESS, WLAN_CAPABILITY_ESS);
- req.key = key;
- req.key_len = key_len;
- req.key_idx = key_idx;
  if (!req.bss)
   return -ENOENT;
 
- err = cfg80211_can_use_chan(rdev, wdev, req.bss->channel,
-        CHAN_MODE_SHARED);
- if (err)
-  goto out;
-
  err = rdev_auth(rdev, dev, &req);
 
-out:
  cfg80211_put_bss(&rdev->wiphy, req.bss);
  return err;
 }
 
-int cfg80211_mlme_auth(struct cfg80211_registered_device *rdev,
-         struct net_device *dev, struct ieee80211_channel *chan,
-         enum nl80211_auth_type auth_type, const u8 *bssid,
-         const u8 *ssid, int ssid_len,
-         const u8 *ie, int ie_len,
-         const u8 *key, int key_len, int key_idx,
-         const u8 *sae_data, int sae_data_len)
-{
- int err;
-
- mutex_lock(&rdev->devlist_mtx);
- wdev_lock(dev->ieee80211_ptr);
- err = __cfg80211_mlme_auth(rdev, dev, chan, auth_type, bssid,
-       ssid, ssid_len, ie, ie_len,
-       key, key_len, key_idx,
-       sae_data, sae_data_len);
- wdev_unlock(dev->ieee80211_ptr);
- mutex_unlock(&rdev->devlist_mtx);
-
- return err;
-}
-
 /*  Do a logical ht_capa &= ht_capa_mask.  */
 void cfg80211_oper_and_ht_capa(struct ieee80211_ht_cap *ht_capa,
           const struct ieee80211_ht_cap *ht_capa_mask)
@@ -360,30 +273,21 @@ void cfg80211_oper_and_vht_capa(struct ieee80211_vht_cap *vht_capa,
   p1[i] &= p2[i];
 }
 
-int __cfg80211_mlme_assoc(struct cfg80211_registered_device *rdev,
-     struct net_device *dev,
-     struct ieee80211_channel *chan,
-     const u8 *bssid,
-     const u8 *ssid, int ssid_len,
-     struct cfg80211_assoc_request *req)
+int cfg80211_mlme_assoc(struct cfg80211_registered_device *rdev,
+   struct net_device *dev,
+   struct ieee80211_channel *chan,
+   const u8 *bssid,
+   const u8 *ssid, int ssid_len,
+   struct cfg80211_assoc_request *req)
 {
  struct wireless_dev *wdev = dev->ieee80211_ptr;
  int err;
- bool was_connected = false;
 
  ASSERT_WDEV_LOCK(wdev);
 
- if (wdev->current_bss && req->prev_bssid &&
-     ether_addr_equal(wdev->current_bss->pub.bssid, req->prev_bssid)) {
-  /*
-   * Trying to reassociate: Allow this to proceed and let the old
-   * association to be dropped when the new one is completed.
-   */
-  if (wdev->sme_state == CFG80211_SME_CONNECTED) {
-   was_connected = true;
-   wdev->sme_state = CFG80211_SME_CONNECTING;
-  }
- } else if (wdev->current_bss)
+ if (wdev->current_bss &&
+     (!req->prev_bssid || !ether_addr_equal(wdev->current_bss->pub.bssid,
+         req->prev_bssid)))
   return -EALREADY;
 
  cfg80211_oper_and_ht_capa(&req->ht_capa_mask,
@@ -393,52 +297,22 @@ int __cfg80211_mlme_assoc(struct cfg80211_registered_device *rdev,
 
  req->bss = cfg80211_get_bss(&rdev->wiphy, chan, bssid, ssid, ssid_len,
         WLAN_CAPABILITY_ESS, WLAN_CAPABILITY_ESS);
- if (!req->bss) {
-  if (was_connected)
-   wdev->sme_state = CFG80211_SME_CONNECTED;
+ if (!req->bss)
   return -ENOENT;
- }
-
- err = cfg80211_can_use_chan(rdev, wdev, chan, CHAN_MODE_SHARED);
- if (err)
-  goto out;
 
  err = rdev_assoc(rdev, dev, req);
-
-out:
- if (err) {
-  if (was_connected)
-   wdev->sme_state = CFG80211_SME_CONNECTED;
+ if (!err)
+  cfg80211_hold_bss(bss_from_pub(req->bss));
+ else
   cfg80211_put_bss(&rdev->wiphy, req->bss);
- }
 
  return err;
 }
 
-int cfg80211_mlme_assoc(struct cfg80211_registered_device *rdev,
-   struct net_device *dev,
-   struct ieee80211_channel *chan,
-   const u8 *bssid,
-   const u8 *ssid, int ssid_len,
-   struct cfg80211_assoc_request *req)
-{
- struct wireless_dev *wdev = dev->ieee80211_ptr;
- int err;
-
- mutex_lock(&rdev->devlist_mtx);
- wdev_lock(wdev);
- err = __cfg80211_mlme_assoc(rdev, dev, chan, bssid,
-        ssid, ssid_len, req);
- wdev_unlock(wdev);
- mutex_unlock(&rdev->devlist_mtx);
-
- return err;
-}
-
-int __cfg80211_mlme_deauth(struct cfg80211_registered_device *rdev,
-      struct net_device *dev, const u8 *bssid,
-      const u8 *ie, int ie_len, u16 reason,
-      bool local_state_change)
+int cfg80211_mlme_deauth(struct cfg80211_registered_device *rdev,
+    struct net_device *dev, const u8 *bssid,
+    const u8 *ie, int ie_len, u16 reason,
+    bool local_state_change)
 {
  struct wireless_dev *wdev = dev->ieee80211_ptr;
  struct cfg80211_deauth_request req = {
@@ -451,79 +325,51 @@ int __cfg80211_mlme_deauth(struct cfg80211_registered_device *rdev,
 
  ASSERT_WDEV_LOCK(wdev);
 
- if (local_state_change && (!wdev->current_bss ||
-     !ether_addr_equal(wdev->current_bss->pub.bssid, bssid)))
+ if (local_state_change &&
+     (!wdev->current_bss ||
+      !ether_addr_equal(wdev->current_bss->pub.bssid, bssid)))
   return 0;
 
  return rdev_deauth(rdev, dev, &req);
 }
 
-int cfg80211_mlme_deauth(struct cfg80211_registered_device *rdev,
-    struct net_device *dev, const u8 *bssid,
-    const u8 *ie, int ie_len, u16 reason,
-    bool local_state_change)
+int cfg80211_mlme_disassoc(struct cfg80211_registered_device *rdev,
+      struct net_device *dev, const u8 *bssid,
+      const u8 *ie, int ie_len, u16 reason,
+      bool local_state_change)
 {
  struct wireless_dev *wdev = dev->ieee80211_ptr;
+ struct cfg80211_disassoc_request req = {
+  .reason_code = reason,
+  .local_state_change = local_state_change,
+  .ie = ie,
+  .ie_len = ie_len,
+ };
  int err;
 
- wdev_lock(wdev);
- err = __cfg80211_mlme_deauth(rdev, dev, bssid, ie, ie_len, reason,
-         local_state_change);
- wdev_unlock(wdev);
-
- return err;
-}
-
-static int __cfg80211_mlme_disassoc(struct cfg80211_registered_device *rdev,
-        struct net_device *dev, const u8 *bssid,
-        const u8 *ie, int ie_len, u16 reason,
-        bool local_state_change)
-{
- struct wireless_dev *wdev = dev->ieee80211_ptr;
- struct cfg80211_disassoc_request req;
-
  ASSERT_WDEV_LOCK(wdev);
 
- if (wdev->sme_state != CFG80211_SME_CONNECTED)
-  return -ENOTCONN;
-
- if (WARN(!wdev->current_bss, "sme_state=%d\n", wdev->sme_state))
+ if (!wdev->current_bss)
   return -ENOTCONN;
 
- memset(&req, 0, sizeof(req));
- req.reason_code = reason;
- req.local_state_change = local_state_change;
- req.ie = ie;
- req.ie_len = ie_len;
  if (ether_addr_equal(wdev->current_bss->pub.bssid, bssid))
   req.bss = &wdev->current_bss->pub;
  else
   return -ENOTCONN;
 
- return rdev_disassoc(rdev, dev, &req);
-}
-
-int cfg80211_mlme_disassoc(struct cfg80211_registered_device *rdev,
-      struct net_device *dev, const u8 *bssid,
-      const u8 *ie, int ie_len, u16 reason,
-      bool local_state_change)
-{
- struct wireless_dev *wdev = dev->ieee80211_ptr;
- int err;
-
- wdev_lock(wdev);
- err = __cfg80211_mlme_disassoc(rdev, dev, bssid, ie, ie_len, reason,
-           local_state_change);
- wdev_unlock(wdev);
+ err = rdev_disassoc(rdev, dev, &req);
+ if (err)
+  return err;
 
- return err;
+ /* driver should have reported the disassoc */
+ WARN_ON(wdev->current_bss);
+ return 0;
 }
 
 void cfg80211_mlme_down(struct cfg80211_registered_device *rdev,
    struct net_device *dev)
 {
  struct wireless_dev *wdev = dev->ieee80211_ptr;
- struct cfg80211_deauth_request req;
  u8 bssid[ETH_ALEN];
 
  ASSERT_WDEV_LOCK(wdev);
@@ -531,23 +377,12 @@ void cfg80211_mlme_down(struct cfg80211_registered_device *rdev,
  if (!rdev->ops->deauth)
   return;
 
- memset(&req, 0, sizeof(req));
- req.reason_code = WLAN_REASON_DEAUTH_LEAVING;
- req.ie = NULL;
- req.ie_len = 0;
-
  if (!wdev->current_bss)
   return;
 
  memcpy(bssid, wdev->current_bss->pub.bssid, ETH_ALEN);
- req.bssid = bssid;
- rdev_deauth(rdev, dev, &req);
-
- if (wdev->current_bss) {
-  cfg80211_unhold_bss(wdev->current_bss);
-  cfg80211_put_bss(&rdev->wiphy, &wdev->current_bss->pub);
-  wdev->current_bss = NULL;
- }
+ cfg80211_mlme_deauth(rdev, dev, bssid, NULL, 0,
+        WLAN_REASON_DEAUTH_LEAVING, false);
 }
 
 struct cfg80211_mgmt_registration {
@@ -567,7 +402,7 @@ int cfg80211_mlme_register_mgmt(struct wireless_dev *wdev, u32 snd_portid,
     int match_len)
 {
  struct wiphy *wiphy = wdev->wiphy;
- struct cfg80211_registered_device *rdev = wiphy_to_dev(wiphy);
+ struct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);
  struct cfg80211_mgmt_registration *reg, *nreg;
  int err = 0;
  u16 mgmt_type;
@@ -626,7 +461,7 @@ int cfg80211_mlme_register_mgmt(struct wireless_dev *wdev, u32 snd_portid,
 void cfg80211_mlme_unregister_socket(struct wireless_dev *wdev, u32 nlportid)
 {
  struct wiphy *wiphy = wdev->wiphy;
- struct cfg80211_registered_device *rdev = wiphy_to_dev(wiphy);
+ struct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);
  struct cfg80211_mgmt_registration *reg, *tmp;
 
  spin_lock_bh(&wdev->mgmt_registrations_lock);
@@ -673,9 +508,7 @@ void cfg80211_mlme_purge_registrations(struct wireless_dev *wdev)
 
 int cfg80211_mlme_mgmt_tx(struct cfg80211_registered_device *rdev,
      struct wireless_dev *wdev,
-     struct ieee80211_channel *chan, bool offchan,
-     unsigned int wait, const u8 *buf, size_t len,
-     bool no_cck, bool dont_wait_for_ack, u64 *cookie)
+     struct cfg80211_mgmt_tx_params *params, u64 *cookie)
 {
  const struct ieee80211_mgmt *mgmt;
  u16 stype;
@@ -686,10 +519,10 @@ int cfg80211_mlme_mgmt_tx(struct cfg80211_registered_device *rdev,
  if (!rdev->ops->mgmt_tx)
   return -EOPNOTSUPP;
 
- if (len < 24 + 1)
+ if (params->len < 24 + 1)
   return -EINVAL;
 
- mgmt = (const struct ieee80211_mgmt *) buf;
+ mgmt = (const struct ieee80211_mgmt *)params->buf;
 
  if (!ieee80211_is_mgmt(mgmt->frame_control))
   return -EINVAL;
@@ -768,16 +601,14 @@ int cfg80211_mlme_mgmt_tx(struct cfg80211_registered_device *rdev,
   return -EINVAL;
 
  /* Transmit the Action frame as requested by user space */
- return rdev_mgmt_tx(rdev, wdev, chan, offchan,
-       wait, buf, len, no_cck, dont_wait_for_ack,
-       cookie);
+ return rdev_mgmt_tx(rdev, wdev, params, cookie);
 }
 
 bool cfg80211_rx_mgmt(struct wireless_dev *wdev, int freq, int sig_mbm,
-        const u8 *buf, size_t len, gfp_t gfp)
+        const u8 *buf, size_t len, u32 flags, gfp_t gfp)
 {
  struct wiphy *wiphy = wdev->wiphy;
- struct cfg80211_registered_device *rdev = wiphy_to_dev(wiphy);
+ struct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);
  struct cfg80211_mgmt_registration *reg;
  const struct ieee80211_txrx_stypes *stypes =
   &wiphy->mgmt_stypes[wdev->iftype];
@@ -817,7 +648,7 @@ bool cfg80211_rx_mgmt(struct wireless_dev *wdev, int freq, int sig_mbm,
   /* Indicate the received Action frame to user space */
   if (nl80211_send_mgmt(rdev, wdev, reg->nlportid,
           freq, sig_mbm,
-          buf, len, gfp))
+          buf, len, flags, gfp))
    continue;
 
   result = true;
@@ -848,7 +679,7 @@ void cfg80211_dfs_channels_update_work(struct work_struct *work)
        dfs_update_channels_wk);
  wiphy = &rdev->wiphy;
 
- mutex_lock(&cfg80211_mutex);
+ rtnl_lock();
  for (bandid = 0; bandid < IEEE80211_NUM_BANDS; bandid++) {
   sband = wiphy->bands[bandid];
   if (!sband)
@@ -860,11 +691,13 @@ void cfg80211_dfs_channels_update_work(struct work_struct *work)
    if (c->dfs_state != NL80211_DFS_UNAVAILABLE)
     continue;
 
-   timeout = c->dfs_state_entered +
-      IEEE80211_DFS_MIN_NOP_TIME_MS;
+   timeout = c->dfs_state_entered + msecs_to_jiffies(
+     IEEE80211_DFS_MIN_NOP_TIME_MS);
 
    if (time_after_eq(jiffies, timeout)) {
     c->dfs_state = NL80211_DFS_USABLE;
+    c->dfs_state_entered = jiffies;
+
     cfg80211_chandef_create(&chandef, c,
        NL80211_CHAN_NO_HT);
 
@@ -881,7 +714,7 @@ void cfg80211_dfs_channels_update_work(struct work_struct *work)
    check_again = true;
   }
  }
- mutex_unlock(&cfg80211_mutex);
+ rtnl_unlock();
 
  /* reschedule if there are other channels waiting to be cleared again */
  if (check_again)
@@ -894,7 +727,7 @@ void cfg80211_radar_event(struct wiphy *wiphy,
      struct cfg80211_chan_def *chandef,
      gfp_t gfp)
 {
- struct cfg80211_registered_device *rdev = wiphy_to_dev(wiphy);
+ struct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);
  unsigned long timeout;
 
  trace_cfg80211_radar_event(wiphy, chandef);
@@ -914,12 +747,12 @@ void cfg80211_radar_event(struct wiphy *wiphy,
 EXPORT_SYMBOL(cfg80211_radar_event);
 
 void cfg80211_cac_event(struct net_device *netdev,
+   const struct cfg80211_chan_def *chandef,
    enum nl80211_radar_event event, gfp_t gfp)
 {
  struct wireless_dev *wdev = netdev->ieee80211_ptr;
  struct wiphy *wiphy = wdev->wiphy;
- struct cfg80211_registered_device *rdev = wiphy_to_dev(wiphy);
- struct cfg80211_chan_def chandef;
+ struct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);
  unsigned long timeout;
 
  trace_cfg80211_cac_event(netdev, event);
@@ -927,17 +760,15 @@ void cfg80211_cac_event(struct net_device *netdev,
  if (WARN_ON(!wdev->cac_started))
   return;
 
- if (WARN_ON(!wdev->channel))
+ if (WARN_ON(!wdev->chandef.chan))
   return;
 
- cfg80211_chandef_create(&chandef, wdev->channel, NL80211_CHAN_NO_HT);
-
  switch (event) {
  case NL80211_RADAR_CAC_FINISHED:
   timeout = wdev->cac_start_time +
-     msecs_to_jiffies(IEEE80211_DFS_MIN_CAC_TIME_MS);
+     msecs_to_jiffies(wdev->cac_time_ms);
   WARN_ON(!time_after_eq(jiffies, timeout));
-  cfg80211_set_dfs_state(wiphy, &chandef, NL80211_DFS_AVAILABLE);
+  cfg80211_set_dfs_state(wiphy, chandef, NL80211_DFS_AVAILABLE);
   break;
  case NL80211_RADAR_CAC_ABORTED:
   break;
@@ -947,6 +778,6 @@ void cfg80211_cac_event(struct net_device *netdev,
  }
  wdev->cac_started = false;
 
- nl80211_radar_notify(rdev, &chandef, event, netdev, gfp);
+ nl80211_radar_notify(rdev, chandef, event, netdev, gfp);
 }
 EXPORT_SYMBOL(cfg80211_cac_event);
diff --git a/net/wireless/nl80211.c b/net/wireless/nl80211.c
index 4640645..6668daf 100644
--- a/net/wireless/nl80211.c
+++ b/net/wireless/nl80211.c
@@ -37,10 +37,10 @@ static void nl80211_post_doit(const struct genl_ops *ops, struct sk_buff *skb,
 
 /* the netlink family */
 static struct genl_family nl80211_fam = {
- .id = GENL_ID_GENERATE, /* don't bother with a hardcoded ID */
- .name = "nl80211", /* have users key off the name instead */
- .hdrsize = 0,  /* no private header */
- .version = 1,  /* no particular meaning now */
+ .id = GENL_ID_GENERATE,  /* don't bother with a hardcoded ID */
+ .name = NL80211_GENL_NAME, /* have users key off the name instead */
+ .hdrsize = 0,   /* no private header */
+ .version = 1,   /* no particular meaning now */
  .maxattr = NL80211_ATTR_MAX,
  .netnsok = true,
  .pre_doit = nl80211_pre_doit,
@@ -53,6 +53,7 @@ enum nl80211_multicast_groups {
  NL80211_MCGRP_SCAN,
  NL80211_MCGRP_REGULATORY,
  NL80211_MCGRP_MLME,
+ NL80211_MCGRP_VENDOR,
  NL80211_MCGRP_TESTMODE /* keep last - ifdef! */
 };
 
@@ -61,6 +62,7 @@ static const struct genl_multicast_group nl80211_mcgrps[] = {
  [NL80211_MCGRP_SCAN] = { .name = "scan", },
  [NL80211_MCGRP_REGULATORY] = { .name = "regulatory", },
  [NL80211_MCGRP_MLME] = { .name = "mlme", },
+ [NL80211_MCGRP_VENDOR] = { .name = "vendor", },
 #ifdef CONFIG_NL80211_TESTMODE
  [NL80211_MCGRP_TESTMODE] = { .name = "testmode", }
 #endif
@@ -78,7 +80,7 @@ __cfg80211_wdev_from_attrs(struct net *netns, struct nlattr **attrs)
  int wiphy_idx = -1;
  int ifidx = -1;
 
- assert_cfg80211_lock();
+ ASSERT_RTNL();
 
  if (!have_ifidx && !have_wdev_id)
   return ERR_PTR(-EINVAL);
@@ -99,7 +101,6 @@ __cfg80211_wdev_from_attrs(struct net *netns, struct nlattr **attrs)
   if (have_wdev_id && rdev->wiphy_idx != wiphy_idx)
    continue;
 
-  mutex_lock(&rdev->devlist_mtx);
   list_for_each_entry(wdev, &rdev->wdev_list, list) {
    if (have_ifidx && wdev->netdev &&
        wdev->netdev->ifindex == ifidx) {
@@ -111,7 +112,6 @@ __cfg80211_wdev_from_attrs(struct net *netns, struct nlattr **attrs)
     break;
    }
   }
-  mutex_unlock(&rdev->devlist_mtx);
 
   if (result)
    break;
@@ -128,7 +128,7 @@ __cfg80211_rdev_from_attrs(struct net *netns, struct nlattr **attrs)
  struct cfg80211_registered_device *rdev = NULL, *tmp;
  struct net_device *netdev;
 
- assert_cfg80211_lock();
+ ASSERT_RTNL();
 
  if (!attrs[NL80211_ATTR_WIPHY] &&
      !attrs[NL80211_ATTR_IFINDEX] &&
@@ -147,14 +147,12 @@ __cfg80211_rdev_from_attrs(struct net *netns, struct nlattr **attrs)
   tmp = cfg80211_rdev_by_wiphy_idx(wdev_id >> 32);
   if (tmp) {
    /* make sure wdev exists */
-   mutex_lock(&tmp->devlist_mtx);
    list_for_each_entry(wdev, &tmp->wdev_list, list) {
     if (wdev->identifier != (u32)wdev_id)
      continue;
     found = true;
     break;
    }
-   mutex_unlock(&tmp->devlist_mtx);
 
    if (!found)
     tmp = NULL;
@@ -167,16 +165,14 @@ __cfg80211_rdev_from_attrs(struct net *netns, struct nlattr **attrs)
 
  if (attrs[NL80211_ATTR_IFINDEX]) {
   int ifindex = nla_get_u32(attrs[NL80211_ATTR_IFINDEX]);
-  netdev = dev_get_by_index(netns, ifindex);
+  netdev = __dev_get_by_index(netns, ifindex);
   if (netdev) {
    if (netdev->ieee80211_ptr)
-    tmp = wiphy_to_dev(
-      netdev->ieee80211_ptr->wiphy);
+    tmp = wiphy_to_rdev(
+     netdev->ieee80211_ptr->wiphy);
    else
     tmp = NULL;
 
-   dev_put(netdev);
-
    /* not wireless device -- return error */
    if (!tmp)
     return ERR_PTR(-EINVAL);
@@ -201,19 +197,6 @@ __cfg80211_rdev_from_attrs(struct net *netns, struct nlattr **attrs)
 /*
  * This function returns a pointer to the driver
  * that the genl_info item that is passed refers to.
- * If successful, it returns non-NULL and also locks
- * the driver's mutex!
- *
- * This means that you need to call cfg80211_unlock_rdev()
- * before being allowed to acquire &cfg80211_mutex!
- *
- * This is necessary because we need to lock the global
- * mutex to get an item off the list safely, and then
- * we lock the rdev mutex so it doesn't go away under us.
- *
- * We don't want to keep cfg80211_mutex locked
- * for all the time in order to allow requests on
- * other interfaces to go through at the same time.
  *
  * The result of this can be a PTR_ERR and hence must
  * be checked with IS_ERR() for errors.
@@ -221,20 +204,7 @@ __cfg80211_rdev_from_attrs(struct net *netns, struct nlattr **attrs)
 static struct cfg80211_registered_device *
 cfg80211_get_dev_from_info(struct net *netns, struct genl_info *info)
 {
- struct cfg80211_registered_device *rdev;
-
- mutex_lock(&cfg80211_mutex);
- rdev = __cfg80211_rdev_from_attrs(netns, info->attrs);
-
- /* if it is not an error we grab the lock on
-  * it to assure it won't be going away while
-  * we operate on it */
- if (!IS_ERR(rdev))
-  mutex_lock(&rdev->mtx);
-
- mutex_unlock(&cfg80211_mutex);
-
- return rdev;
+ return __cfg80211_rdev_from_attrs(netns, info->attrs);
 }
 
 /* policy for the attributes */
@@ -397,6 +367,26 @@ static const struct nla_policy nl80211_policy[NL80211_ATTR_MAX+1] = {
  [NL80211_ATTR_MDID] = { .type = NLA_U16 },
  [NL80211_ATTR_IE_RIC] = { .type = NLA_BINARY,
       .len = IEEE80211_MAX_DATA_LEN },
+ [NL80211_ATTR_PEER_AID] = { .type = NLA_U16 },
+ [NL80211_ATTR_CH_SWITCH_COUNT] = { .type = NLA_U32 },
+ [NL80211_ATTR_CH_SWITCH_BLOCK_TX] = { .type = NLA_FLAG },
+ [NL80211_ATTR_CSA_IES] = { .type = NLA_NESTED },
+ [NL80211_ATTR_CSA_C_OFF_BEACON] = { .type = NLA_BINARY },
+ [NL80211_ATTR_CSA_C_OFF_PRESP] = { .type = NLA_BINARY },
+ [NL80211_ATTR_STA_SUPPORTED_CHANNELS] = { .type = NLA_BINARY },
+ [NL80211_ATTR_STA_SUPPORTED_OPER_CLASSES] = { .type = NLA_BINARY },
+ [NL80211_ATTR_HANDLE_DFS] = { .type = NLA_FLAG },
+ [NL80211_ATTR_OPMODE_NOTIF] = { .type = NLA_U8 },
+ [NL80211_ATTR_VENDOR_ID] = { .type = NLA_U32 },
+ [NL80211_ATTR_VENDOR_SUBCMD] = { .type = NLA_U32 },
+ [NL80211_ATTR_VENDOR_DATA] = { .type = NLA_BINARY },
+ [NL80211_ATTR_QOS_MAP] = { .type = NLA_BINARY,
+       .len = IEEE80211_QOS_MAP_LEN_MAX },
+ [NL80211_ATTR_MAC_HINT] = { .len = ETH_ALEN },
+ [NL80211_ATTR_WIPHY_FREQ_HINT] = { .type = NLA_U32 },
+ [NL80211_ATTR_TDLS_PEER_CAPABILITY] = { .type = NLA_U32 },
+ [NL80211_ATTR_IFACE_SOCKET_OWNER] = { .type = NLA_FLAG },
+ [NL80211_ATTR_CSA_C_OFFSETS_TX] = { .type = NLA_BINARY },
 };
 
 /* policy for the key attributes */
@@ -451,6 +441,14 @@ nl80211_wowlan_tcp_policy[NUM_NL80211_WOWLAN_TCP] = {
  [NL80211_WOWLAN_TCP_WAKE_MASK] = { .len = 1 },
 };
 
+/* policy for coalesce rule attributes */
+static const struct nla_policy
+nl80211_coalesce_policy[NUM_NL80211_ATTR_COALESCE_RULE] = {
+ [NL80211_ATTR_COALESCE_RULE_DELAY] = { .type = NLA_U32 },
+ [NL80211_ATTR_COALESCE_RULE_CONDITION] = { .type = NLA_U32 },
+ [NL80211_ATTR_COALESCE_RULE_PKT_PATTERN] = { .type = NLA_NESTED },
+};
+
 /* policy for GTK rekey offload attributes */
 static const struct nla_policy
 nl80211_rekey_policy[NUM_NL80211_REKEY_DATA] = {
@@ -474,7 +472,6 @@ static int nl80211_prepare_wdev_dump(struct sk_buff *skb,
  int err;
 
  rtnl_lock();
- mutex_lock(&cfg80211_mutex);
 
  if (!cb->args[0]) {
   err = nlmsg_parse(cb->nlh, GENL_HDRLEN + nl80211_fam.hdrsize,
@@ -489,7 +486,7 @@ static int nl80211_prepare_wdev_dump(struct sk_buff *skb,
    err = PTR_ERR(*wdev);
    goto out_unlock;
   }
-  *rdev = wiphy_to_dev((*wdev)->wiphy);
+  *rdev = wiphy_to_rdev((*wdev)->wiphy);
   /* 0 is the first index - add 1 to parse only once */
   cb->args[0] = (*rdev)->wiphy_idx + 1;
   cb->args[1] = (*wdev)->identifier;
@@ -502,17 +499,15 @@ static int nl80211_prepare_wdev_dump(struct sk_buff *skb,
    err = -ENODEV;
    goto out_unlock;
   }
-  *rdev = wiphy_to_dev(wiphy);
+  *rdev = wiphy_to_rdev(wiphy);
   *wdev = NULL;
 
-  mutex_lock(&(*rdev)->devlist_mtx);
   list_for_each_entry(tmp, &(*rdev)->wdev_list, list) {
    if (tmp->identifier == cb->args[1]) {
     *wdev = tmp;
     break;
    }
   }
-  mutex_unlock(&(*rdev)->devlist_mtx);
 
   if (!*wdev) {
    err = -ENODEV;
@@ -520,19 +515,14 @@ static int nl80211_prepare_wdev_dump(struct sk_buff *skb,
   }
  }
 
- cfg80211_lock_rdev(*rdev);
-
- mutex_unlock(&cfg80211_mutex);
  return 0;
  out_unlock:
- mutex_unlock(&cfg80211_mutex);
  rtnl_unlock();
  return err;
 }
 
 static void nl80211_finish_wdev_dump(struct cfg80211_registered_device *rdev)
 {
- cfg80211_unlock_rdev(rdev);
  rtnl_unlock();
 }
 
@@ -578,6 +568,13 @@ static int nl80211_msg_put_channel(struct sk_buff *msg,
        struct ieee80211_channel *chan,
        bool large)
 {
+ /* Some channels must be completely excluded from the
+  * list to protect old user-space tools from breaking
+  */
+ if (!large && chan->flags &
+     (IEEE80211_CHAN_NO_10MHZ | IEEE80211_CHAN_NO_20MHZ))
+  return 0;
+
  if (nla_put_u32(msg, NL80211_FREQUENCY_ATTR_FREQ,
    chan->center_freq))
   goto nla_put_failure;
@@ -585,12 +582,12 @@ static int nl80211_msg_put_channel(struct sk_buff *msg,
  if ((chan->flags & IEEE80211_CHAN_DISABLED) &&
      nla_put_flag(msg, NL80211_FREQUENCY_ATTR_DISABLED))
   goto nla_put_failure;
- if ((chan->flags & IEEE80211_CHAN_PASSIVE_SCAN) &&
-     nla_put_flag(msg, NL80211_FREQUENCY_ATTR_PASSIVE_SCAN))
-  goto nla_put_failure;
- if ((chan->flags & IEEE80211_CHAN_NO_IBSS) &&
-     nla_put_flag(msg, NL80211_FREQUENCY_ATTR_NO_IBSS))
-  goto nla_put_failure;
+ if (chan->flags & IEEE80211_CHAN_NO_IR) {
+  if (nla_put_flag(msg, NL80211_FREQUENCY_ATTR_NO_IR))
+   goto nla_put_failure;
+  if (nla_put_flag(msg, __NL80211_FREQUENCY_ATTR_NO_IBSS))
+   goto nla_put_failure;
+ }
  if (chan->flags & IEEE80211_CHAN_RADAR) {
   if (nla_put_flag(msg, NL80211_FREQUENCY_ATTR_RADAR))
    goto nla_put_failure;
@@ -605,6 +602,10 @@ static int nl80211_msg_put_channel(struct sk_buff *msg,
    if (nla_put_u32(msg, NL80211_FREQUENCY_ATTR_DFS_TIME,
      time))
     goto nla_put_failure;
+   if (nla_put_u32(msg,
+     NL80211_FREQUENCY_ATTR_DFS_CAC_TIME,
+     chan->dfs_cac_ms))
+    goto nla_put_failure;
   }
  }
 
@@ -621,6 +622,18 @@ static int nl80211_msg_put_channel(struct sk_buff *msg,
   if ((chan->flags & IEEE80211_CHAN_NO_160MHZ) &&
       nla_put_flag(msg, NL80211_FREQUENCY_ATTR_NO_160MHZ))
    goto nla_put_failure;
+  if ((chan->flags & IEEE80211_CHAN_INDOOR_ONLY) &&
+      nla_put_flag(msg, NL80211_FREQUENCY_ATTR_INDOOR_ONLY))
+   goto nla_put_failure;
+  if ((chan->flags & IEEE80211_CHAN_GO_CONCURRENT) &&
+      nla_put_flag(msg, NL80211_FREQUENCY_ATTR_GO_CONCURRENT))
+   goto nla_put_failure;
+  if ((chan->flags & IEEE80211_CHAN_NO_20MHZ) &&
+      nla_put_flag(msg, NL80211_FREQUENCY_ATTR_NO_20MHZ))
+   goto nla_put_failure;
+  if ((chan->flags & IEEE80211_CHAN_NO_10MHZ) &&
+      nla_put_flag(msg, NL80211_FREQUENCY_ATTR_NO_10MHZ))
+   goto nla_put_failure;
  }
 
  if (nla_put_u32(msg, NL80211_FREQUENCY_ATTR_MAX_TX_POWER,
@@ -858,12 +871,9 @@ static int nl80211_key_allowed(struct wireless_dev *wdev)
  case NL80211_IFTYPE_MESH_POINT:
   break;
  case NL80211_IFTYPE_ADHOC:
-  if (!wdev->current_bss)
-   return -ENOLINK;
-  break;
  case NL80211_IFTYPE_STATION:
  case NL80211_IFTYPE_P2P_CLIENT:
-  if (wdev->sme_state != CFG80211_SME_CONNECTED)
+  if (!wdev->current_bss)
    return -ENOLINK;
   break;
  default:
@@ -873,6 +883,19 @@ static int nl80211_key_allowed(struct wireless_dev *wdev)
  return 0;
 }
 
+static struct ieee80211_channel *nl80211_get_valid_chan(struct wiphy *wiphy,
+       struct nlattr *tb)
+{
+ struct ieee80211_channel *chan;
+
+ if (tb == NULL)
+  return NULL;
+ chan = ieee80211_get_channel(wiphy, nla_get_u32(tb));
+ if (!chan || chan->flags & IEEE80211_CHAN_DISABLED)
+  return NULL;
+ return chan;
+}
+
 static int nl80211_put_iftypes(struct sk_buff *msg, u32 attr, u16 ifmodes)
 {
  struct nlattr *nl_modes = nla_nest_start(msg, attr);
@@ -948,8 +971,10 @@ static int nl80211_put_iface_combinations(struct wiphy *wiphy,
     c->max_interfaces))
    goto nla_put_failure;
   if (large &&
-      nla_put_u32(msg, NL80211_IFACE_COMB_RADAR_DETECT_WIDTHS,
-    c->radar_detect_widths))
+      (nla_put_u32(msg, NL80211_IFACE_COMB_RADAR_DETECT_WIDTHS,
+    c->radar_detect_widths) ||
+       nla_put_u32(msg, NL80211_IFACE_COMB_RADAR_DETECT_REGIONS,
+    c->radar_detect_regions)))
    goto nla_put_failure;
 
   nla_nest_end(msg, nl_combi);
@@ -966,7 +991,7 @@ nla_put_failure:
 static int nl80211_send_wowlan_tcp_caps(struct cfg80211_registered_device *rdev,
      struct sk_buff *msg)
 {
- const struct wiphy_wowlan_tcp_support *tcp = rdev->wiphy.wowlan.tcp;
+ const struct wiphy_wowlan_tcp_support *tcp = rdev->wiphy.wowlan->tcp;
  struct nlattr *nl_tcp;
 
  if (!tcp)
@@ -1004,42 +1029,42 @@ static int nl80211_send_wowlan_tcp_caps(struct cfg80211_registered_device *rdev,
 }
 
 static int nl80211_send_wowlan(struct sk_buff *msg,
-          struct cfg80211_registered_device *dev,
+          struct cfg80211_registered_device *rdev,
           bool large)
 {
  struct nlattr *nl_wowlan;
 
- if (!dev->wiphy.wowlan.flags && !dev->wiphy.wowlan.n_patterns)
+ if (!rdev->wiphy.wowlan)
   return 0;
 
  nl_wowlan = nla_nest_start(msg, NL80211_ATTR_WOWLAN_TRIGGERS_SUPPORTED);
  if (!nl_wowlan)
   return -ENOBUFS;
 
- if (((dev->wiphy.wowlan.flags & WIPHY_WOWLAN_ANY) &&
+ if (((rdev->wiphy.wowlan->flags & WIPHY_WOWLAN_ANY) &&
       nla_put_flag(msg, NL80211_WOWLAN_TRIG_ANY)) ||
-     ((dev->wiphy.wowlan.flags & WIPHY_WOWLAN_DISCONNECT) &&
+     ((rdev->wiphy.wowlan->flags & WIPHY_WOWLAN_DISCONNECT) &&
       nla_put_flag(msg, NL80211_WOWLAN_TRIG_DISCONNECT)) ||
-     ((dev->wiphy.wowlan.flags & WIPHY_WOWLAN_MAGIC_PKT) &&
+     ((rdev->wiphy.wowlan->flags & WIPHY_WOWLAN_MAGIC_PKT) &&
       nla_put_flag(msg, NL80211_WOWLAN_TRIG_MAGIC_PKT)) ||
-     ((dev->wiphy.wowlan.flags & WIPHY_WOWLAN_SUPPORTS_GTK_REKEY) &&
+     ((rdev->wiphy.wowlan->flags & WIPHY_WOWLAN_SUPPORTS_GTK_REKEY) &&
       nla_put_flag(msg, NL80211_WOWLAN_TRIG_GTK_REKEY_SUPPORTED)) ||
-     ((dev->wiphy.wowlan.flags & WIPHY_WOWLAN_GTK_REKEY_FAILURE) &&
+     ((rdev->wiphy.wowlan->flags & WIPHY_WOWLAN_GTK_REKEY_FAILURE) &&
       nla_put_flag(msg, NL80211_WOWLAN_TRIG_GTK_REKEY_FAILURE)) ||
-     ((dev->wiphy.wowlan.flags & WIPHY_WOWLAN_EAP_IDENTITY_REQ) &&
+     ((rdev->wiphy.wowlan->flags & WIPHY_WOWLAN_EAP_IDENTITY_REQ) &&
       nla_put_flag(msg, NL80211_WOWLAN_TRIG_EAP_IDENT_REQUEST)) ||
-     ((dev->wiphy.wowlan.flags & WIPHY_WOWLAN_4WAY_HANDSHAKE) &&
+     ((rdev->wiphy.wowlan->flags & WIPHY_WOWLAN_4WAY_HANDSHAKE) &&
       nla_put_flag(msg, NL80211_WOWLAN_TRIG_4WAY_HANDSHAKE)) ||
-     ((dev->wiphy.wowlan.flags & WIPHY_WOWLAN_RFKILL_RELEASE) &&
+     ((rdev->wiphy.wowlan->flags & WIPHY_WOWLAN_RFKILL_RELEASE) &&
       nla_put_flag(msg, NL80211_WOWLAN_TRIG_RFKILL_RELEASE)))
   return -ENOBUFS;
 
- if (dev->wiphy.wowlan.n_patterns) {
-  struct nl80211_wowlan_pattern_support pat = {
-   .max_patterns = dev->wiphy.wowlan.n_patterns,
-   .min_pattern_len = dev->wiphy.wowlan.pattern_min_len,
-   .max_pattern_len = dev->wiphy.wowlan.pattern_max_len,
-   .max_pkt_offset = dev->wiphy.wowlan.max_pkt_offset,
+ if (rdev->wiphy.wowlan->n_patterns) {
+  struct nl80211_pattern_support pat = {
+   .max_patterns = rdev->wiphy.wowlan->n_patterns,
+   .min_pattern_len = rdev->wiphy.wowlan->pattern_min_len,
+   .max_pattern_len = rdev->wiphy.wowlan->pattern_max_len,
+   .max_pkt_offset = rdev->wiphy.wowlan->max_pkt_offset,
   };
 
   if (nla_put(msg, NL80211_WOWLAN_TRIG_PKT_PATTERN,
@@ -1047,7 +1072,7 @@ static int nl80211_send_wowlan(struct sk_buff *msg,
    return -ENOBUFS;
  }
 
- if (large && nl80211_send_wowlan_tcp_caps(dev, msg))
+ if (large && nl80211_send_wowlan_tcp_caps(rdev, msg))
   return -ENOBUFS;
 
  nla_nest_end(msg, nl_wowlan);
@@ -1056,6 +1081,27 @@ static int nl80211_send_wowlan(struct sk_buff *msg,
 }
 #endif
 
+static int nl80211_send_coalesce(struct sk_buff *msg,
+     struct cfg80211_registered_device *rdev)
+{
+ struct nl80211_coalesce_rule_support rule;
+
+ if (!rdev->wiphy.coalesce)
+  return 0;
+
+ rule.max_rules = rdev->wiphy.coalesce->n_rules;
+ rule.max_delay = rdev->wiphy.coalesce->max_delay;
+ rule.pat.max_patterns = rdev->wiphy.coalesce->n_patterns;
+ rule.pat.min_pattern_len = rdev->wiphy.coalesce->pattern_min_len;
+ rule.pat.max_pattern_len = rdev->wiphy.coalesce->pattern_max_len;
+ rule.pat.max_pkt_offset = rdev->wiphy.coalesce->max_pkt_offset;
+
+ if (nla_put(msg, NL80211_ATTR_COALESCE_RULE, sizeof(rule), &rule))
+  return -ENOBUFS;
+
+ return 0;
+}
+
 static int nl80211_send_band_rateinfo(struct sk_buff *msg,
           struct ieee80211_supported_band *sband)
 {
@@ -1172,10 +1218,17 @@ nl80211_send_mgmt_stypes(struct sk_buff *msg,
  return 0;
 }
 
-static int nl80211_send_wiphy(struct cfg80211_registered_device *dev,
+struct nl80211_dump_wiphy_state {
+ s64 filter_wiphy;
+ long start;
+ long split_start, band_start, chan_start;
+ bool split;
+};
+
+static int nl80211_send_wiphy(struct cfg80211_registered_device *rdev,
+         enum nl80211_commands cmd,
          struct sk_buff *msg, u32 portid, u32 seq,
-         int flags, bool split, long *split_start,
-         long *band_start, long *chan_start)
+         int flags, struct nl80211_dump_wiphy_state *state)
 {
  void *hdr;
  struct nlattr *nl_bands, *nl_band;
@@ -1185,105 +1238,102 @@ static int nl80211_send_wiphy(struct cfg80211_registered_device *dev,
  struct ieee80211_channel *chan;
  int i;
  const struct ieee80211_txrx_stypes *mgmt_stypes =
-    dev->wiphy.mgmt_stypes;
- long start = 0, start_chan = 0, start_band = 0;
+    rdev->wiphy.mgmt_stypes;
  u32 features;
 
- hdr = nl80211hdr_put(msg, portid, seq, flags, NL80211_CMD_NEW_WIPHY);
+ hdr = nl80211hdr_put(msg, portid, seq, flags, cmd);
  if (!hdr)
   return -ENOBUFS;
 
- /* allow always using the variables */
- if (!split) {
-  split_start = &start;
-  band_start = &start_band;
-  chan_start = &start_chan;
- }
+ if (WARN_ON(!state))
+  return -EINVAL;
 
- if (nla_put_u32(msg, NL80211_ATTR_WIPHY, dev->wiphy_idx) ||
+ if (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||
      nla_put_string(msg, NL80211_ATTR_WIPHY_NAME,
-      wiphy_name(&dev->wiphy)) ||
+      wiphy_name(&rdev->wiphy)) ||
      nla_put_u32(msg, NL80211_ATTR_GENERATION,
    cfg80211_rdev_list_generation))
   goto nla_put_failure;
 
- switch (*split_start) {
+ if (cmd != NL80211_CMD_NEW_WIPHY)
+  goto finish;
+
+ switch (state->split_start) {
  case 0:
   if (nla_put_u8(msg, NL80211_ATTR_WIPHY_RETRY_SHORT,
-          dev->wiphy.retry_short) ||
+          rdev->wiphy.retry_short) ||
       nla_put_u8(msg, NL80211_ATTR_WIPHY_RETRY_LONG,
-          dev->wiphy.retry_long) ||
+          rdev->wiphy.retry_long) ||
       nla_put_u32(msg, NL80211_ATTR_WIPHY_FRAG_THRESHOLD,
-    dev->wiphy.frag_threshold) ||
+    rdev->wiphy.frag_threshold) ||
       nla_put_u32(msg, NL80211_ATTR_WIPHY_RTS_THRESHOLD,
-    dev->wiphy.rts_threshold) ||
+    rdev->wiphy.rts_threshold) ||
       nla_put_u8(msg, NL80211_ATTR_WIPHY_COVERAGE_CLASS,
-          dev->wiphy.coverage_class) ||
+          rdev->wiphy.coverage_class) ||
       nla_put_u8(msg, NL80211_ATTR_MAX_NUM_SCAN_SSIDS,
-          dev->wiphy.max_scan_ssids) ||
+          rdev->wiphy.max_scan_ssids) ||
       nla_put_u8(msg, NL80211_ATTR_MAX_NUM_SCHED_SCAN_SSIDS,
-          dev->wiphy.max_sched_scan_ssids) ||
+          rdev->wiphy.max_sched_scan_ssids) ||
       nla_put_u16(msg, NL80211_ATTR_MAX_SCAN_IE_LEN,
-    dev->wiphy.max_scan_ie_len) ||
+    rdev->wiphy.max_scan_ie_len) ||
       nla_put_u16(msg, NL80211_ATTR_MAX_SCHED_SCAN_IE_LEN,
-    dev->wiphy.max_sched_scan_ie_len) ||
+    rdev->wiphy.max_sched_scan_ie_len) ||
       nla_put_u8(msg, NL80211_ATTR_MAX_MATCH_SETS,
-          dev->wiphy.max_match_sets))
+          rdev->wiphy.max_match_sets))
    goto nla_put_failure;
 
-  if ((dev->wiphy.flags & WIPHY_FLAG_IBSS_RSN) &&
+  if ((rdev->wiphy.flags & WIPHY_FLAG_IBSS_RSN) &&
       nla_put_flag(msg, NL80211_ATTR_SUPPORT_IBSS_RSN))
    goto nla_put_failure;
-  if ((dev->wiphy.flags & WIPHY_FLAG_MESH_AUTH) &&
+  if ((rdev->wiphy.flags & WIPHY_FLAG_MESH_AUTH) &&
       nla_put_flag(msg, NL80211_ATTR_SUPPORT_MESH_AUTH))
    goto nla_put_failure;
-  if ((dev->wiphy.flags & WIPHY_FLAG_AP_UAPSD) &&
+  if ((rdev->wiphy.flags & WIPHY_FLAG_AP_UAPSD) &&
       nla_put_flag(msg, NL80211_ATTR_SUPPORT_AP_UAPSD))
    goto nla_put_failure;
-  if ((dev->wiphy.flags & WIPHY_FLAG_SUPPORTS_FW_ROAM) &&
+  if ((rdev->wiphy.flags & WIPHY_FLAG_SUPPORTS_FW_ROAM) &&
       nla_put_flag(msg, NL80211_ATTR_ROAM_SUPPORT))
    goto nla_put_failure;
-  if ((dev->wiphy.flags & WIPHY_FLAG_SUPPORTS_TDLS) &&
+  if ((rdev->wiphy.flags & WIPHY_FLAG_SUPPORTS_TDLS) &&
       nla_put_flag(msg, NL80211_ATTR_TDLS_SUPPORT))
    goto nla_put_failure;
-  if ((dev->wiphy.flags & WIPHY_FLAG_TDLS_EXTERNAL_SETUP) &&
+  if ((rdev->wiphy.flags & WIPHY_FLAG_TDLS_EXTERNAL_SETUP) &&
       nla_put_flag(msg, NL80211_ATTR_TDLS_EXTERNAL_SETUP))
    goto nla_put_failure;
-
-  (*split_start)++;
-  if (split)
+  state->split_start++;
+  if (state->split)
    break;
  case 1:
   if (nla_put(msg, NL80211_ATTR_CIPHER_SUITES,
-       sizeof(u32) * dev->wiphy.n_cipher_suites,
-       dev->wiphy.cipher_suites))
+       sizeof(u32) * rdev->wiphy.n_cipher_suites,
+       rdev->wiphy.cipher_suites))
    goto nla_put_failure;
 
   if (nla_put_u8(msg, NL80211_ATTR_MAX_NUM_PMKIDS,
-          dev->wiphy.max_num_pmkids))
+          rdev->wiphy.max_num_pmkids))
    goto nla_put_failure;
 
-  if ((dev->wiphy.flags & WIPHY_FLAG_CONTROL_PORT_PROTOCOL) &&
+  if ((rdev->wiphy.flags & WIPHY_FLAG_CONTROL_PORT_PROTOCOL) &&
       nla_put_flag(msg, NL80211_ATTR_CONTROL_PORT_ETHERTYPE))
    goto nla_put_failure;
 
   if (nla_put_u32(msg, NL80211_ATTR_WIPHY_ANTENNA_AVAIL_TX,
-    dev->wiphy.available_antennas_tx) ||
+    rdev->wiphy.available_antennas_tx) ||
       nla_put_u32(msg, NL80211_ATTR_WIPHY_ANTENNA_AVAIL_RX,
-    dev->wiphy.available_antennas_rx))
+    rdev->wiphy.available_antennas_rx))
    goto nla_put_failure;
 
-  if ((dev->wiphy.flags & WIPHY_FLAG_AP_PROBE_RESP_OFFLOAD) &&
+  if ((rdev->wiphy.flags & WIPHY_FLAG_AP_PROBE_RESP_OFFLOAD) &&
       nla_put_u32(msg, NL80211_ATTR_PROBE_RESP_OFFLOAD,
-    dev->wiphy.probe_resp_offload))
+    rdev->wiphy.probe_resp_offload))
    goto nla_put_failure;
 
-  if ((dev->wiphy.available_antennas_tx ||
-       dev->wiphy.available_antennas_rx) &&
-      dev->ops->get_antenna) {
+  if ((rdev->wiphy.available_antennas_tx ||
+       rdev->wiphy.available_antennas_rx) &&
+      rdev->ops->get_antenna) {
    u32 tx_ant = 0, rx_ant = 0;
    int res;
-   res = rdev_get_antenna(dev, &tx_ant, &rx_ant);
+   res = rdev_get_antenna(rdev, &tx_ant, &rx_ant);
    if (!res) {
     if (nla_put_u32(msg,
       NL80211_ATTR_WIPHY_ANTENNA_TX,
@@ -1295,25 +1345,26 @@ static int nl80211_send_wiphy(struct cfg80211_registered_device *dev,
    }
   }
 
-  (*split_start)++;
-  if (split)
+  state->split_start++;
+  if (state->split)
    break;
  case 2:
   if (nl80211_put_iftypes(msg, NL80211_ATTR_SUPPORTED_IFTYPES,
-     dev->wiphy.interface_modes))
+     rdev->wiphy.interface_modes))
     goto nla_put_failure;
-  (*split_start)++;
-  if (split)
+  state->split_start++;
+  if (state->split)
    break;
  case 3:
   nl_bands = nla_nest_start(msg, NL80211_ATTR_WIPHY_BANDS);
   if (!nl_bands)
    goto nla_put_failure;
 
-  for (band = *band_start; band < IEEE80211_NUM_BANDS; band++) {
+  for (band = state->band_start;
+       band < IEEE80211_NUM_BANDS; band++) {
    struct ieee80211_supported_band *sband;
 
-   sband = dev->wiphy.bands[band];
+   sband = rdev->wiphy.bands[band];
 
    if (!sband)
     continue;
@@ -1322,12 +1373,12 @@ static int nl80211_send_wiphy(struct cfg80211_registered_device *dev,
    if (!nl_band)
     goto nla_put_failure;
 
-   switch (*chan_start) {
+   switch (state->chan_start) {
    case 0:
     if (nl80211_send_band_rateinfo(msg, sband))
      goto nla_put_failure;
-    (*chan_start)++;
-    if (split)
+    state->chan_start++;
+    if (state->split)
      break;
    default:
     /* add frequencies */
@@ -1336,7 +1387,7 @@ static int nl80211_send_wiphy(struct cfg80211_registered_device *dev,
     if (!nl_freqs)
      goto nla_put_failure;
 
-    for (i = *chan_start - 1;
+    for (i = state->chan_start - 1;
          i < sband->n_channels;
          i++) {
      nl_freq = nla_nest_start(msg, i);
@@ -1345,26 +1396,27 @@ static int nl80211_send_wiphy(struct cfg80211_registered_device *dev,
 
      chan = &sband->channels[i];
 
-     if (nl80211_msg_put_channel(msg, chan,
-            split))
+     if (nl80211_msg_put_channel(
+       msg, chan,
+       state->split))
       goto nla_put_failure;
 
      nla_nest_end(msg, nl_freq);
-     if (split)
+     if (state->split)
       break;
     }
     if (i < sband->n_channels)
-     *chan_start = i + 2;
+     state->chan_start = i + 2;
     else
-     *chan_start = 0;
+     state->chan_start = 0;
     nla_nest_end(msg, nl_freqs);
    }
 
    nla_nest_end(msg, nl_band);
 
-   if (split) {
+   if (state->split) {
     /* start again here */
-    if (*chan_start)
+    if (state->chan_start)
      band--;
     break;
    }
@@ -1372,14 +1424,14 @@ static int nl80211_send_wiphy(struct cfg80211_registered_device *dev,
   nla_nest_end(msg, nl_bands);
 
   if (band < IEEE80211_NUM_BANDS)
-   *band_start = band + 1;
+   state->band_start = band + 1;
   else
-   *band_start = 0;
+   state->band_start = 0;
 
   /* if bands & channels are done, continue outside */
-  if (*band_start == 0 && *chan_start == 0)
-   (*split_start)++;
-  if (split)
+  if (state->band_start == 0 && state->chan_start == 0)
+   state->split_start++;
+  if (state->split)
    break;
  case 4:
   nl_cmds = nla_nest_start(msg, NL80211_ATTR_SUPPORTED_COMMANDS);
@@ -1389,7 +1441,7 @@ static int nl80211_send_wiphy(struct cfg80211_registered_device *dev,
   i = 0;
 #define CMD(op, n)       \
    do {       \
-   if (dev->ops->op) {    \
+   if (rdev->ops->op) {    \
     i++;     \
     if (nla_put_u32(msg, i, NL80211_CMD_ ## n)) \
      goto nla_put_failure;  \
@@ -1413,130 +1465,133 @@ static int nl80211_send_wiphy(struct cfg80211_registered_device *dev,
   CMD(set_pmksa, SET_PMKSA);
   CMD(del_pmksa, DEL_PMKSA);
   CMD(flush_pmksa, FLUSH_PMKSA);
-  if (dev->wiphy.flags & WIPHY_FLAG_HAS_REMAIN_ON_CHANNEL)
+  if (rdev->wiphy.flags & WIPHY_FLAG_HAS_REMAIN_ON_CHANNEL)
    CMD(remain_on_channel, REMAIN_ON_CHANNEL);
   CMD(set_bitrate_mask, SET_TX_BITRATE_MASK);
   CMD(mgmt_tx, FRAME);
   CMD(mgmt_tx_cancel_wait, FRAME_WAIT_CANCEL);
-  if (dev->wiphy.flags & WIPHY_FLAG_NETNS_OK) {
+  if (rdev->wiphy.flags & WIPHY_FLAG_NETNS_OK) {
    i++;
    if (nla_put_u32(msg, i, NL80211_CMD_SET_WIPHY_NETNS))
     goto nla_put_failure;
   }
-  if (dev->ops->set_monitor_channel || dev->ops->start_ap ||
-      dev->ops->join_mesh) {
+  if (rdev->ops->set_monitor_channel || rdev->ops->start_ap ||
+      rdev->ops->join_mesh) {
    i++;
    if (nla_put_u32(msg, i, NL80211_CMD_SET_CHANNEL))
     goto nla_put_failure;
   }
   CMD(set_wds_peer, SET_WDS_PEER);
-  if (dev->wiphy.flags & WIPHY_FLAG_SUPPORTS_TDLS) {
+  if (rdev->wiphy.flags & WIPHY_FLAG_SUPPORTS_TDLS) {
    CMD(tdls_mgmt, TDLS_MGMT);
    CMD(tdls_oper, TDLS_OPER);
   }
-  if (dev->wiphy.flags & WIPHY_FLAG_SUPPORTS_SCHED_SCAN)
+  if (rdev->wiphy.flags & WIPHY_FLAG_SUPPORTS_SCHED_SCAN)
    CMD(sched_scan_start, START_SCHED_SCAN);
   CMD(probe_client, PROBE_CLIENT);
   CMD(set_noack_map, SET_NOACK_MAP);
-  if (dev->wiphy.flags & WIPHY_FLAG_REPORTS_OBSS) {
+  if (rdev->wiphy.flags & WIPHY_FLAG_REPORTS_OBSS) {
    i++;
    if (nla_put_u32(msg, i, NL80211_CMD_REGISTER_BEACONS))
     goto nla_put_failure;
   }
   CMD(start_p2p_device, START_P2P_DEVICE);
   CMD(set_mcast_rate, SET_MCAST_RATE);
-  if (split) {
-   CMD(crit_proto_start, CRIT_PROTOCOL_START);
-   CMD(crit_proto_stop, CRIT_PROTOCOL_STOP);
-  }
-
 #ifdef CONFIG_NL80211_TESTMODE
   CMD(testmode_cmd, TESTMODE);
 #endif
-
+  if (state->split) {
+   CMD(crit_proto_start, CRIT_PROTOCOL_START);
+   CMD(crit_proto_stop, CRIT_PROTOCOL_STOP);
+   if (rdev->wiphy.flags & WIPHY_FLAG_HAS_CHANNEL_SWITCH)
+    CMD(channel_switch, CHANNEL_SWITCH);
+   CMD(set_qos_map, SET_QOS_MAP);
+  }
+  /* add into the if now */
 #undef CMD
 
-  if (dev->ops->connect || dev->ops->auth) {
+  if (rdev->ops->connect || rdev->ops->auth) {
    i++;
    if (nla_put_u32(msg, i, NL80211_CMD_CONNECT))
     goto nla_put_failure;
   }
 
-  if (dev->ops->disconnect || dev->ops->deauth) {
+  if (rdev->ops->disconnect || rdev->ops->deauth) {
    i++;
    if (nla_put_u32(msg, i, NL80211_CMD_DISCONNECT))
     goto nla_put_failure;
   }
 
   nla_nest_end(msg, nl_cmds);
-  (*split_start)++;
-  if (split)
+  state->split_start++;
+  if (state->split)
    break;
  case 5:
-  if (dev->ops->remain_on_channel &&
-      (dev->wiphy.flags & WIPHY_FLAG_HAS_REMAIN_ON_CHANNEL) &&
+  if (rdev->ops->remain_on_channel &&
+      (rdev->wiphy.flags & WIPHY_FLAG_HAS_REMAIN_ON_CHANNEL) &&
       nla_put_u32(msg,
     NL80211_ATTR_MAX_REMAIN_ON_CHANNEL_DURATION,
-    dev->wiphy.max_remain_on_channel_duration))
+    rdev->wiphy.max_remain_on_channel_duration))
    goto nla_put_failure;
 
-  if ((dev->wiphy.flags & WIPHY_FLAG_OFFCHAN_TX) &&
+  if ((rdev->wiphy.flags & WIPHY_FLAG_OFFCHAN_TX) &&
       nla_put_flag(msg, NL80211_ATTR_OFFCHANNEL_TX_OK))
    goto nla_put_failure;
 
   if (nl80211_send_mgmt_stypes(msg, mgmt_stypes))
    goto nla_put_failure;
-  (*split_start)++;
-  if (split)
+  state->split_start++;
+  if (state->split)
    break;
  case 6:
 #ifdef CONFIG_PM
-  if (nl80211_send_wowlan(msg, dev, split))
+  if (nl80211_send_wowlan(msg, rdev, state->split))
    goto nla_put_failure;
-  (*split_start)++;
-  if (split)
+  state->split_start++;
+  if (state->split)
    break;
 #else
-  (*split_start)++;
+  state->split_start++;
 #endif
  case 7:
   if (nl80211_put_iftypes(msg, NL80211_ATTR_SOFTWARE_IFTYPES,
-     dev->wiphy.software_iftypes))
+     rdev->wiphy.software_iftypes))
    goto nla_put_failure;
 
-  if (nl80211_put_iface_combinations(&dev->wiphy, msg, split))
+  if (nl80211_put_iface_combinations(&rdev->wiphy, msg,
+         state->split))
    goto nla_put_failure;
 
-  (*split_start)++;
-  if (split)
+  state->split_start++;
+  if (state->split)
    break;
  case 8:
-  if ((dev->wiphy.flags & WIPHY_FLAG_HAVE_AP_SME) &&
+  if ((rdev->wiphy.flags & WIPHY_FLAG_HAVE_AP_SME) &&
       nla_put_u32(msg, NL80211_ATTR_DEVICE_AP_SME,
-    dev->wiphy.ap_sme_capa))
+    rdev->wiphy.ap_sme_capa))
    goto nla_put_failure;
 
-  features = dev->wiphy.features;
+  features = rdev->wiphy.features;
   /*
    * We can only add the per-channel limit information if the
    * dump is split, otherwise it makes it too big. Therefore
    * only advertise it in that case.
    */
-  if (split)
+  if (state->split)
    features |= NL80211_FEATURE_ADVERTISE_CHAN_LIMITS;
   if (nla_put_u32(msg, NL80211_ATTR_FEATURE_FLAGS, features))
    goto nla_put_failure;
 
-  if (dev->wiphy.ht_capa_mod_mask &&
+  if (rdev->wiphy.ht_capa_mod_mask &&
       nla_put(msg, NL80211_ATTR_HT_CAPABILITY_MASK,
-       sizeof(*dev->wiphy.ht_capa_mod_mask),
-       dev->wiphy.ht_capa_mod_mask))
+       sizeof(*rdev->wiphy.ht_capa_mod_mask),
+       rdev->wiphy.ht_capa_mod_mask))
    goto nla_put_failure;
 
-  if (dev->wiphy.flags & WIPHY_FLAG_HAVE_AP_SME &&
-      dev->wiphy.max_acl_mac_addrs &&
+  if (rdev->wiphy.flags & WIPHY_FLAG_HAVE_AP_SME &&
+      rdev->wiphy.max_acl_mac_addrs &&
       nla_put_u32(msg, NL80211_ATTR_MAC_ACL_MAX,
-    dev->wiphy.max_acl_mac_addrs))
+    rdev->wiphy.max_acl_mac_addrs))
    goto nla_put_failure;
 
   /*
@@ -1549,28 +1604,88 @@ static int nl80211_send_wiphy(struct cfg80211_registered_device *dev,
    * case we'll continue with more data in the next round,
    * but break unconditionally so unsplit data stops here.
    */
-  (*split_start)++;
+  state->split_start++;
   break;
  case 9:
-  if (dev->wiphy.extended_capabilities &&
+  if (rdev->wiphy.extended_capabilities &&
       (nla_put(msg, NL80211_ATTR_EXT_CAPA,
-        dev->wiphy.extended_capabilities_len,
-        dev->wiphy.extended_capabilities) ||
+        rdev->wiphy.extended_capabilities_len,
+        rdev->wiphy.extended_capabilities) ||
        nla_put(msg, NL80211_ATTR_EXT_CAPA_MASK,
-        dev->wiphy.extended_capabilities_len,
-        dev->wiphy.extended_capabilities_mask)))
+        rdev->wiphy.extended_capabilities_len,
+        rdev->wiphy.extended_capabilities_mask)))
    goto nla_put_failure;
 
-  if (dev->wiphy.vht_capa_mod_mask &&
+  if (rdev->wiphy.vht_capa_mod_mask &&
       nla_put(msg, NL80211_ATTR_VHT_CAPABILITY_MASK,
-       sizeof(*dev->wiphy.vht_capa_mod_mask),
-       dev->wiphy.vht_capa_mod_mask))
+       sizeof(*rdev->wiphy.vht_capa_mod_mask),
+       rdev->wiphy.vht_capa_mod_mask))
+   goto nla_put_failure;
+
+  state->split_start++;
+  break;
+ case 10:
+  if (nl80211_send_coalesce(msg, rdev))
+   goto nla_put_failure;
+
+  if ((rdev->wiphy.flags & WIPHY_FLAG_SUPPORTS_5_10_MHZ) &&
+      (nla_put_flag(msg, NL80211_ATTR_SUPPORT_5_MHZ) ||
+       nla_put_flag(msg, NL80211_ATTR_SUPPORT_10_MHZ)))
+   goto nla_put_failure;
+
+  if (rdev->wiphy.max_ap_assoc_sta &&
+      nla_put_u32(msg, NL80211_ATTR_MAX_AP_ASSOC_STA,
+    rdev->wiphy.max_ap_assoc_sta))
+   goto nla_put_failure;
+
+  state->split_start++;
+  break;
+ case 11:
+  if (rdev->wiphy.n_vendor_commands) {
+   const struct nl80211_vendor_cmd_info *info;
+   struct nlattr *nested;
+
+   nested = nla_nest_start(msg, NL80211_ATTR_VENDOR_DATA);
+   if (!nested)
+    goto nla_put_failure;
+
+   for (i = 0; i < rdev->wiphy.n_vendor_commands; i++) {
+    info = &rdev->wiphy.vendor_commands[i].info;
+    if (nla_put(msg, i + 1, sizeof(*info), info))
+     goto nla_put_failure;
+   }
+   nla_nest_end(msg, nested);
+  }
+
+  if (rdev->wiphy.n_vendor_events) {
+   const struct nl80211_vendor_cmd_info *info;
+   struct nlattr *nested;
+
+   nested = nla_nest_start(msg,
+      NL80211_ATTR_VENDOR_EVENTS);
+   if (!nested)
+    goto nla_put_failure;
+
+   for (i = 0; i < rdev->wiphy.n_vendor_events; i++) {
+    info = &rdev->wiphy.vendor_events[i];
+    if (nla_put(msg, i + 1, sizeof(*info), info))
+     goto nla_put_failure;
+   }
+   nla_nest_end(msg, nested);
+  }
+  state->split_start++;
+  break;
+ case 12:
+  if (rdev->wiphy.flags & WIPHY_FLAG_HAS_CHANNEL_SWITCH &&
+      nla_put_u8(msg, NL80211_ATTR_MAX_CSA_COUNTERS,
+          rdev->wiphy.max_num_csa_counters))
    goto nla_put_failure;
 
   /* done */
-  *split_start = 0;
+  state->split_start = 0;
   break;
  }
+ finish:
  return genlmsg_end(msg, hdr);
 
  nla_put_failure:
@@ -1578,66 +1693,78 @@ static int nl80211_send_wiphy(struct cfg80211_registered_device *dev,
  return -EMSGSIZE;
 }
 
+static int nl80211_dump_wiphy_parse(struct sk_buff *skb,
+        struct netlink_callback *cb,
+        struct nl80211_dump_wiphy_state *state)
+{
+ struct nlattr **tb = nl80211_fam.attrbuf;
+ int ret = nlmsg_parse(cb->nlh, GENL_HDRLEN + nl80211_fam.hdrsize,
+         tb, nl80211_fam.maxattr, nl80211_policy);
+ /* ignore parse errors for backward compatibility */
+ if (ret)
+  return 0;
+
+ state->split = tb[NL80211_ATTR_SPLIT_WIPHY_DUMP];
+ if (tb[NL80211_ATTR_WIPHY])
+  state->filter_wiphy = nla_get_u32(tb[NL80211_ATTR_WIPHY]);
+ if (tb[NL80211_ATTR_WDEV])
+  state->filter_wiphy = nla_get_u64(tb[NL80211_ATTR_WDEV]) >> 32;
+ if (tb[NL80211_ATTR_IFINDEX]) {
+  struct net_device *netdev;
+  struct cfg80211_registered_device *rdev;
+  int ifidx = nla_get_u32(tb[NL80211_ATTR_IFINDEX]);
+
+  netdev = __dev_get_by_index(sock_net(skb->sk), ifidx);
+  if (!netdev)
+   return -ENODEV;
+  if (netdev->ieee80211_ptr) {
+   rdev = wiphy_to_rdev(
+    netdev->ieee80211_ptr->wiphy);
+   state->filter_wiphy = rdev->wiphy_idx;
+  }
+ }
+
+ return 0;
+}
+
 static int nl80211_dump_wiphy(struct sk_buff *skb, struct netlink_callback *cb)
 {
  int idx = 0, ret;
- int start = cb->args[0];
- struct cfg80211_registered_device *dev;
- s64 filter_wiphy = -1;
- bool split = false;
- struct nlattr **tb;
- int res;
-
- /* will be zeroed in nlmsg_parse() */
- tb = kmalloc(sizeof(*tb) * (NL80211_ATTR_MAX + 1), GFP_KERNEL);
- if (!tb)
-  return -ENOMEM;
+ struct nl80211_dump_wiphy_state *state = (void *)cb->args[0];
+ struct cfg80211_registered_device *rdev;
 
- mutex_lock(&cfg80211_mutex);
- res = nlmsg_parse(cb->nlh, GENL_HDRLEN + nl80211_fam.hdrsize,
-     tb, NL80211_ATTR_MAX, nl80211_policy);
- if (res == 0) {
-  split = tb[NL80211_ATTR_SPLIT_WIPHY_DUMP];
-  if (tb[NL80211_ATTR_WIPHY])
-   filter_wiphy = nla_get_u32(tb[NL80211_ATTR_WIPHY]);
-  if (tb[NL80211_ATTR_WDEV])
-   filter_wiphy = nla_get_u64(tb[NL80211_ATTR_WDEV]) >> 32;
-  if (tb[NL80211_ATTR_IFINDEX]) {
-   struct net_device *netdev;
-   int ifidx = nla_get_u32(tb[NL80211_ATTR_IFINDEX]);
-
-   netdev = dev_get_by_index(sock_net(skb->sk), ifidx);
-   if (!netdev) {
-    mutex_unlock(&cfg80211_mutex);
-    kfree(tb);
-    return -ENODEV;
-   }
-   if (netdev->ieee80211_ptr) {
-    dev = wiphy_to_dev(
-     netdev->ieee80211_ptr->wiphy);
-    filter_wiphy = dev->wiphy_idx;
-   }
-   dev_put(netdev);
+ rtnl_lock();
+ if (!state) {
+  state = kzalloc(sizeof(*state), GFP_KERNEL);
+  if (!state) {
+   rtnl_unlock();
+   return -ENOMEM;
+  }
+  state->filter_wiphy = -1;
+  ret = nl80211_dump_wiphy_parse(skb, cb, state);
+  if (ret) {
+   kfree(state);
+   rtnl_unlock();
+   return ret;
   }
+  cb->args[0] = (long)state;
  }
- kfree(tb);
 
- list_for_each_entry(dev, &cfg80211_rdev_list, list) {
-  if (!net_eq(wiphy_net(&dev->wiphy), sock_net(skb->sk)))
+ list_for_each_entry(rdev, &cfg80211_rdev_list, list) {
+  if (!net_eq(wiphy_net(&rdev->wiphy), sock_net(skb->sk)))
    continue;
-  if (++idx <= start)
+  if (++idx <= state->start)
    continue;
-  if (filter_wiphy != -1 && dev->wiphy_idx != filter_wiphy)
+  if (state->filter_wiphy != -1 &&
+      state->filter_wiphy != rdev->wiphy_idx)
    continue;
   /* attempt to fit multiple wiphy data chunks into the skb */
   do {
-   ret = nl80211_send_wiphy(dev, skb,
+   ret = nl80211_send_wiphy(rdev, NL80211_CMD_NEW_WIPHY,
+       skb,
        NETLINK_CB(cb->skb).portid,
        cb->nlh->nlmsg_seq,
-       NLM_F_MULTI,
-       split, &cb->args[1],
-       &cb->args[2],
-       &cb->args[3]);
+       NLM_F_MULTI, state);
    if (ret < 0) {
     /*
      * If sending the wiphy data didn't fit (ENOBUFS
@@ -1653,36 +1780,45 @@ static int nl80211_dump_wiphy(struct sk_buff *skb, struct netlink_callback *cb)
      * We can then retry with the larger buffer.
      */
     if ((ret == -ENOBUFS || ret == -EMSGSIZE) &&
-        !skb->len &&
+        !skb->len && !state->split &&
         cb->min_dump_alloc < 4096) {
      cb->min_dump_alloc = 4096;
-     mutex_unlock(&cfg80211_mutex);
+     state->split_start = 0;
+     rtnl_unlock();
      return 1;
     }
     idx--;
     break;
    }
-  } while (cb->args[1] > 0);
+  } while (state->split_start > 0);
   break;
  }
- mutex_unlock(&cfg80211_mutex);
+ rtnl_unlock();
 
- cb->args[0] = idx;
+ state->start = idx;
 
  return skb->len;
 }
 
+static int nl80211_dump_wiphy_done(struct netlink_callback *cb)
+{
+ kfree((void *)cb->args[0]);
+ return 0;
+}
+
 static int nl80211_get_wiphy(struct sk_buff *skb, struct genl_info *info)
 {
  struct sk_buff *msg;
- struct cfg80211_registered_device *dev = info->user_ptr[0];
+ struct cfg80211_registered_device *rdev = info->user_ptr[0];
+ struct nl80211_dump_wiphy_state state = {};
 
  msg = nlmsg_new(4096, GFP_KERNEL);
  if (!msg)
   return -ENOMEM;
 
- if (nl80211_send_wiphy(dev, msg, info->snd_portid, info->snd_seq, 0,
-          false, NULL, NULL, NULL) < 0) {
+ if (nl80211_send_wiphy(rdev, NL80211_CMD_NEW_WIPHY, msg,
+          info->snd_portid, info->snd_seq, 0,
+          &state) < 0) {
   nlmsg_free(msg);
   return -ENOBUFS;
  }
@@ -1799,39 +1935,58 @@ static int nl80211_parse_chandef(struct cfg80211_registered_device *rdev,
          IEEE80211_CHAN_DISABLED))
   return -EINVAL;
 
+ if ((chandef->width == NL80211_CHAN_WIDTH_5 ||
+      chandef->width == NL80211_CHAN_WIDTH_10) &&
+     !(rdev->wiphy.flags & WIPHY_FLAG_SUPPORTS_5_10_MHZ))
+  return -EINVAL;
+
  return 0;
 }
 
 static int __nl80211_set_channel(struct cfg80211_registered_device *rdev,
-     struct wireless_dev *wdev,
+     struct net_device *dev,
      struct genl_info *info)
 {
  struct cfg80211_chan_def chandef;
  int result;
  enum nl80211_iftype iftype = NL80211_IFTYPE_MONITOR;
+ struct wireless_dev *wdev = NULL;
 
- if (wdev)
-  iftype = wdev->iftype;
-
+ if (dev)
+  wdev = dev->ieee80211_ptr;
  if (!nl80211_can_set_dev_channel(wdev))
   return -EOPNOTSUPP;
+ if (wdev)
+  iftype = wdev->iftype;
 
  result = nl80211_parse_chandef(rdev, info, &chandef);
  if (result)
   return result;
 
- mutex_lock(&rdev->devlist_mtx);
  switch (iftype) {
  case NL80211_IFTYPE_AP:
  case NL80211_IFTYPE_P2P_GO:
-  if (wdev->beacon_interval) {
-   result = -EBUSY;
-   break;
-  }
-  if (!cfg80211_reg_can_beacon(&rdev->wiphy, &chandef)) {
+  if (!cfg80211_reg_can_beacon(&rdev->wiphy, &chandef, iftype)) {
    result = -EINVAL;
    break;
   }
+  if (wdev->beacon_interval) {
+   if (!dev || !rdev->ops->set_ap_chanwidth ||
+       !(rdev->wiphy.features &
+         NL80211_FEATURE_AP_MODE_CHAN_WIDTH_CHANGE)) {
+    result = -EBUSY;
+    break;
+   }
+
+   /* Only allow dynamic channel width changes */
+   if (chandef.chan != wdev->preset_chandef.chan) {
+    result = -EBUSY;
+    break;
+   }
+   result = rdev_set_ap_chanwidth(rdev, dev, &chandef);
+   if (result)
+    break;
+  }
   wdev->preset_chandef = chandef;
   result = 0;
   break;
@@ -1844,7 +1999,6 @@ static int __nl80211_set_channel(struct cfg80211_registered_device *rdev,
  default:
   result = -EINVAL;
  }
- mutex_unlock(&rdev->devlist_mtx);
 
  return result;
 }
@@ -1854,7 +2008,7 @@ static int nl80211_set_channel(struct sk_buff *skb, struct genl_info *info)
  struct cfg80211_registered_device *rdev = info->user_ptr[0];
  struct net_device *netdev = info->user_ptr[1];
 
- return __nl80211_set_channel(rdev, netdev->ieee80211_ptr, info);
+ return __nl80211_set_channel(rdev, netdev, info);
 }
 
 static int nl80211_set_wds_peer(struct sk_buff *skb, struct genl_info *info)
@@ -1893,6 +2047,8 @@ static int nl80211_set_wiphy(struct sk_buff *skb, struct genl_info *info)
  u32 frag_threshold = 0, rts_threshold = 0;
  u8 coverage_class = 0;
 
+ ASSERT_RTNL();
+
  /*
   * Try to find the wiphy and netdev. Normally this
   * function shouldn't need the netdev, but this is
@@ -1902,31 +2058,25 @@ static int nl80211_set_wiphy(struct sk_buff *skb, struct genl_info *info)
   * also passed a netdev to set_wiphy, so that it is
   * possible to let that go to the right netdev!
   */
- mutex_lock(&cfg80211_mutex);
 
  if (info->attrs[NL80211_ATTR_IFINDEX]) {
   int ifindex = nla_get_u32(info->attrs[NL80211_ATTR_IFINDEX]);
 
-  netdev = dev_get_by_index(genl_info_net(info), ifindex);
-  if (netdev && netdev->ieee80211_ptr) {
-   rdev = wiphy_to_dev(netdev->ieee80211_ptr->wiphy);
-   mutex_lock(&rdev->mtx);
-  } else
+  netdev = __dev_get_by_index(genl_info_net(info), ifindex);
+  if (netdev && netdev->ieee80211_ptr)
+   rdev = wiphy_to_rdev(netdev->ieee80211_ptr->wiphy);
+  else
    netdev = NULL;
  }
 
  if (!netdev) {
   rdev = __cfg80211_rdev_from_attrs(genl_info_net(info),
         info->attrs);
-  if (IS_ERR(rdev)) {
-   mutex_unlock(&cfg80211_mutex);
+  if (IS_ERR(rdev))
    return PTR_ERR(rdev);
-  }
   wdev = NULL;
   netdev = NULL;
   result = 0;
-
-  mutex_lock(&rdev->mtx);
  } else
   wdev = netdev->ieee80211_ptr;
 
@@ -1939,60 +2089,53 @@ static int nl80211_set_wiphy(struct sk_buff *skb, struct genl_info *info)
   result = cfg80211_dev_rename(
    rdev, nla_data(info->attrs[NL80211_ATTR_WIPHY_NAME]));
 
- mutex_unlock(&cfg80211_mutex);
-
  if (result)
-  goto bad_res;
+  return result;
 
  if (info->attrs[NL80211_ATTR_WIPHY_TXQ_PARAMS]) {
   struct ieee80211_txq_params txq_params;
   struct nlattr *tb[NL80211_TXQ_ATTR_MAX + 1];
 
-  if (!rdev->ops->set_txq_params) {
-   result = -EOPNOTSUPP;
-   goto bad_res;
-  }
+  if (!rdev->ops->set_txq_params)
+   return -EOPNOTSUPP;
 
-  if (!netdev) {
-   result = -EINVAL;
-   goto bad_res;
-  }
+  if (!netdev)
+   return -EINVAL;
 
   if (netdev->ieee80211_ptr->iftype != NL80211_IFTYPE_AP &&
-      netdev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_GO) {
-   result = -EINVAL;
-   goto bad_res;
-  }
+      netdev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_GO)
+   return -EINVAL;
 
-  if (!netif_running(netdev)) {
-   result = -ENETDOWN;
-   goto bad_res;
-  }
+  if (!netif_running(netdev))
+   return -ENETDOWN;
 
   nla_for_each_nested(nl_txq_params,
         info->attrs[NL80211_ATTR_WIPHY_TXQ_PARAMS],
         rem_txq_params) {
-   nla_parse(tb, NL80211_TXQ_ATTR_MAX,
-      nla_data(nl_txq_params),
-      nla_len(nl_txq_params),
-      txq_params_policy);
+   result = nla_parse(tb, NL80211_TXQ_ATTR_MAX,
+        nla_data(nl_txq_params),
+        nla_len(nl_txq_params),
+        txq_params_policy);
+   if (result)
+    return result;
    result = parse_txq_params(tb, &txq_params);
    if (result)
-    goto bad_res;
+    return result;
 
    result = rdev_set_txq_params(rdev, netdev,
            &txq_params);
    if (result)
-    goto bad_res;
+    return result;
   }
  }
 
  if (info->attrs[NL80211_ATTR_WIPHY_FREQ]) {
-  result = __nl80211_set_channel(rdev,
-    nl80211_can_set_dev_channel(wdev) ? wdev : NULL,
-    info);
+  result = __nl80211_set_channel(
+   rdev,
+   nl80211_can_set_dev_channel(wdev) ? netdev : NULL,
+   info);
   if (result)
-   goto bad_res;
+   return result;
  }
 
  if (info->attrs[NL80211_ATTR_WIPHY_TX_POWER_SETTING]) {
@@ -2003,19 +2146,15 @@ static int nl80211_set_wiphy(struct sk_buff *skb, struct genl_info *info)
   if (!(rdev->wiphy.features & NL80211_FEATURE_VIF_TXPOWER))
    txp_wdev = NULL;
 
-  if (!rdev->ops->set_tx_power) {
-   result = -EOPNOTSUPP;
-   goto bad_res;
-  }
+  if (!rdev->ops->set_tx_power)
+   return -EOPNOTSUPP;
 
   idx = NL80211_ATTR_WIPHY_TX_POWER_SETTING;
   type = nla_get_u32(info->attrs[idx]);
 
   if (!info->attrs[NL80211_ATTR_WIPHY_TX_POWER_LEVEL] &&
-      (type != NL80211_TX_POWER_AUTOMATIC)) {
-   result = -EINVAL;
-   goto bad_res;
-  }
+      (type != NL80211_TX_POWER_AUTOMATIC))
+   return -EINVAL;
 
   if (type != NL80211_TX_POWER_AUTOMATIC) {
    idx = NL80211_ATTR_WIPHY_TX_POWER_LEVEL;
@@ -2024,7 +2163,7 @@ static int nl80211_set_wiphy(struct sk_buff *skb, struct genl_info *info)
 
   result = rdev_set_tx_power(rdev, txp_wdev, type, mbm);
   if (result)
-   goto bad_res;
+   return result;
  }
 
  if (info->attrs[NL80211_ATTR_WIPHY_ANTENNA_TX] &&
@@ -2032,10 +2171,8 @@ static int nl80211_set_wiphy(struct sk_buff *skb, struct genl_info *info)
   u32 tx_ant, rx_ant;
   if ((!rdev->wiphy.available_antennas_tx &&
        !rdev->wiphy.available_antennas_rx) ||
-      !rdev->ops->set_antenna) {
-   result = -EOPNOTSUPP;
-   goto bad_res;
-  }
+      !rdev->ops->set_antenna)
+   return -EOPNOTSUPP;
 
   tx_ant = nla_get_u32(info->attrs[NL80211_ATTR_WIPHY_ANTENNA_TX]);
   rx_ant = nla_get_u32(info->attrs[NL80211_ATTR_WIPHY_ANTENNA_RX]);
@@ -2043,17 +2180,15 @@ static int nl80211_set_wiphy(struct sk_buff *skb, struct genl_info *info)
   /* reject antenna configurations which don't match the
    * available antenna masks, except for the "all" mask */
   if ((~tx_ant && (tx_ant & ~rdev->wiphy.available_antennas_tx)) ||
-      (~rx_ant && (rx_ant & ~rdev->wiphy.available_antennas_rx))) {
-   result = -EINVAL;
-   goto bad_res;
-  }
+      (~rx_ant && (rx_ant & ~rdev->wiphy.available_antennas_rx)))
+   return -EINVAL;
 
   tx_ant = tx_ant & rdev->wiphy.available_antennas_tx;
   rx_ant = rx_ant & rdev->wiphy.available_antennas_rx;
 
   result = rdev_set_antenna(rdev, tx_ant, rx_ant);
   if (result)
-   goto bad_res;
+   return result;
  }
 
  changed = 0;
@@ -2061,30 +2196,27 @@ static int nl80211_set_wiphy(struct sk_buff *skb, struct genl_info *info)
  if (info->attrs[NL80211_ATTR_WIPHY_RETRY_SHORT]) {
   retry_short = nla_get_u8(
    info->attrs[NL80211_ATTR_WIPHY_RETRY_SHORT]);
-  if (retry_short == 0) {
-   result = -EINVAL;
-   goto bad_res;
-  }
+  if (retry_short == 0)
+   return -EINVAL;
+
   changed |= WIPHY_PARAM_RETRY_SHORT;
  }
 
  if (info->attrs[NL80211_ATTR_WIPHY_RETRY_LONG]) {
   retry_long = nla_get_u8(
    info->attrs[NL80211_ATTR_WIPHY_RETRY_LONG]);
-  if (retry_long == 0) {
-   result = -EINVAL;
-   goto bad_res;
-  }
+  if (retry_long == 0)
+   return -EINVAL;
+
   changed |= WIPHY_PARAM_RETRY_LONG;
  }
 
  if (info->attrs[NL80211_ATTR_WIPHY_FRAG_THRESHOLD]) {
   frag_threshold = nla_get_u32(
    info->attrs[NL80211_ATTR_WIPHY_FRAG_THRESHOLD]);
-  if (frag_threshold < 256) {
-   result = -EINVAL;
-   goto bad_res;
-  }
+  if (frag_threshold < 256)
+   return -EINVAL;
+
   if (frag_threshold != (u32) -1) {
    /*
     * Fragments (apart from the last one) are required to
@@ -2114,10 +2246,8 @@ static int nl80211_set_wiphy(struct sk_buff *skb, struct genl_info *info)
   u32 old_frag_threshold, old_rts_threshold;
   u8 old_coverage_class;
 
-  if (!rdev->ops->set_wiphy_params) {
-   result = -EOPNOTSUPP;
-   goto bad_res;
-  }
+  if (!rdev->ops->set_wiphy_params)
+   return -EOPNOTSUPP;
 
   old_retry_short = rdev->wiphy.retry_short;
   old_retry_long = rdev->wiphy.retry_long;
@@ -2145,22 +2275,17 @@ static int nl80211_set_wiphy(struct sk_buff *skb, struct genl_info *info)
    rdev->wiphy.coverage_class = old_coverage_class;
   }
  }
-
- bad_res:
- mutex_unlock(&rdev->mtx);
- if (netdev)
-  dev_put(netdev);
- return result;
+ return 0;
 }
 
 static inline u64 wdev_id(struct wireless_dev *wdev)
 {
  return (u64)wdev->identifier |
-        ((u64)wiphy_to_dev(wdev->wiphy)->wiphy_idx << 32);
+        ((u64)wiphy_to_rdev(wdev->wiphy)->wiphy_idx << 32);
 }
 
 static int nl80211_send_chandef(struct sk_buff *msg,
-     struct cfg80211_chan_def *chandef)
+    const struct cfg80211_chan_def *chandef)
 {
  WARN_ON(!cfg80211_chandef_valid(chandef));
 
@@ -2245,7 +2370,7 @@ static int nl80211_dump_interface(struct sk_buff *skb, struct netlink_callback *
  struct cfg80211_registered_device *rdev;
  struct wireless_dev *wdev;
 
- mutex_lock(&cfg80211_mutex);
+ rtnl_lock();
  list_for_each_entry(rdev, &cfg80211_rdev_list, list) {
   if (!net_eq(wiphy_net(&rdev->wiphy), sock_net(skb->sk)))
    continue;
@@ -2255,7 +2380,6 @@ static int nl80211_dump_interface(struct sk_buff *skb, struct netlink_callback *
   }
   if_idx = 0;
 
-  mutex_lock(&rdev->devlist_mtx);
   list_for_each_entry(wdev, &rdev->wdev_list, list) {
    if (if_idx < if_start) {
     if_idx++;
@@ -2264,17 +2388,15 @@ static int nl80211_dump_interface(struct sk_buff *skb, struct netlink_callback *
    if (nl80211_send_iface(skb, NETLINK_CB(cb->skb).portid,
             cb->nlh->nlmsg_seq, NLM_F_MULTI,
             rdev, wdev) < 0) {
-    mutex_unlock(&rdev->devlist_mtx);
     goto out;
    }
    if_idx++;
   }
-  mutex_unlock(&rdev->devlist_mtx);
 
   wp_idx++;
  }
  out:
- mutex_unlock(&cfg80211_mutex);
+ rtnl_unlock();
 
  cb->args[0] = wp_idx;
  cb->args[1] = if_idx;
@@ -2285,7 +2407,7 @@ static int nl80211_dump_interface(struct sk_buff *skb, struct netlink_callback *
 static int nl80211_get_interface(struct sk_buff *skb, struct genl_info *info)
 {
  struct sk_buff *msg;
- struct cfg80211_registered_device *dev = info->user_ptr[0];
+ struct cfg80211_registered_device *rdev = info->user_ptr[0];
  struct wireless_dev *wdev = info->user_ptr[1];
 
  msg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);
@@ -2293,7 +2415,7 @@ static int nl80211_get_interface(struct sk_buff *skb, struct genl_info *info)
   return -ENOMEM;
 
  if (nl80211_send_iface(msg, info->snd_portid, info->snd_seq, 0,
-          dev, wdev) < 0) {
+          rdev, wdev) < 0) {
   nlmsg_free(msg);
   return -ENOBUFS;
  }
@@ -2307,6 +2429,7 @@ static const struct nla_policy mntr_flags_policy[NL80211_MNTR_FLAG_MAX + 1] = {
  [NL80211_MNTR_FLAG_CONTROL] = { .type = NLA_FLAG },
  [NL80211_MNTR_FLAG_OTHER_BSS] = { .type = NLA_FLAG },
  [NL80211_MNTR_FLAG_COOK_FRAMES] = { .type = NLA_FLAG },
+ [NL80211_MNTR_FLAG_ACTIVE] = { .type = NLA_FLAG },
 };
 
 static int parse_monitor_flags(struct nlattr *nla, u32 *mntrflags)
@@ -2418,6 +2541,10 @@ static int nl80211_set_interface(struct sk_buff *skb, struct genl_info *info)
   change = true;
  }
 
+ if (flags && (*flags & MONITOR_FLAG_ACTIVE) &&
+     !(rdev->wiphy.features & NL80211_FEATURE_ACTIVE_MONITOR))
+  return -EOPNOTSUPP;
+
  if (change)
   err = cfg80211_change_iface(rdev, dev, ntype, flags, &params);
  else
@@ -2439,6 +2566,9 @@ static int nl80211_new_interface(struct sk_buff *skb, struct genl_info *info)
  enum nl80211_iftype type = NL80211_IFTYPE_UNSPECIFIED;
  u32 flags;
 
+ /* to avoid failing a new interface creation due to pending removal */
+ cfg80211_destroy_ifaces(rdev);
+
  memset(&params, 0, sizeof(params));
 
  if (!info->attrs[NL80211_ATTR_IFNAME])
@@ -2475,6 +2605,11 @@ static int nl80211_new_interface(struct sk_buff *skb, struct genl_info *info)
  err = parse_monitor_flags(type == NL80211_IFTYPE_MONITOR ?
       info->attrs[NL80211_ATTR_MNTR_FLAGS] : NULL,
       &flags);
+
+ if (!err && (flags & MONITOR_FLAG_ACTIVE) &&
+     !(rdev->wiphy.features & NL80211_FEATURE_ACTIVE_MONITOR))
+  return -EOPNOTSUPP;
+
  wdev = rdev_add_virtual_intf(rdev,
     nla_data(info->attrs[NL80211_ATTR_IFNAME]),
     type, err ? NULL : &flags, &params);
@@ -2483,6 +2618,9 @@ static int nl80211_new_interface(struct sk_buff *skb, struct genl_info *info)
   return PTR_ERR(wdev);
  }
 
+ if (info->attrs[NL80211_ATTR_IFACE_SOCKET_OWNER])
+  wdev->owner_nlportid = info->snd_portid;
+
  switch (type) {
  case NL80211_IFTYPE_MESH_POINT:
   if (!info->attrs[NL80211_ATTR_MESH_ID])
@@ -2507,11 +2645,9 @@ static int nl80211_new_interface(struct sk_buff *skb, struct genl_info *info)
   INIT_LIST_HEAD(&wdev->mgmt_registrations);
   spin_lock_init(&wdev->mgmt_registrations_lock);
 
-  mutex_lock(&rdev->devlist_mtx);
   wdev->identifier = ++rdev->wdev_id;
   list_add_rcu(&wdev->list, &rdev->wdev_list);
   rdev->devlist_generation++;
-  mutex_unlock(&rdev->devlist_mtx);
   break;
  default:
   break;
@@ -2654,8 +2790,8 @@ static int nl80211_get_key(struct sk_buff *skb, struct genl_info *info)
 
  hdr = nl80211hdr_put(msg, info->snd_portid, info->snd_seq, 0,
         NL80211_CMD_NEW_KEY);
- if (IS_ERR(hdr))
-  return PTR_ERR(hdr);
+ if (!hdr)
+  goto nla_put_failure;
 
  cookie.msg = msg;
  cookie.idx = key_idx;
@@ -2954,61 +3090,58 @@ static int nl80211_set_mac_acl(struct sk_buff *skb, struct genl_info *info)
  return err;
 }
 
-static int nl80211_parse_beacon(struct genl_info *info,
+static int nl80211_parse_beacon(struct nlattr *attrs[],
     struct cfg80211_beacon_data *bcn)
 {
  bool haveinfo = false;
 
- if (!is_valid_ie_attr(info->attrs[NL80211_ATTR_BEACON_TAIL]) ||
-     !is_valid_ie_attr(info->attrs[NL80211_ATTR_IE]) ||
-     !is_valid_ie_attr(info->attrs[NL80211_ATTR_IE_PROBE_RESP]) ||
-     !is_valid_ie_attr(info->attrs[NL80211_ATTR_IE_ASSOC_RESP]))
+ if (!is_valid_ie_attr(attrs[NL80211_ATTR_BEACON_TAIL]) ||
+     !is_valid_ie_attr(attrs[NL80211_ATTR_IE]) ||
+     !is_valid_ie_attr(attrs[NL80211_ATTR_IE_PROBE_RESP]) ||
+     !is_valid_ie_attr(attrs[NL80211_ATTR_IE_ASSOC_RESP]))
   return -EINVAL;
 
  memset(bcn, 0, sizeof(*bcn));
 
- if (info->attrs[NL80211_ATTR_BEACON_HEAD]) {
-  bcn->head = nla_data(info->attrs[NL80211_ATTR_BEACON_HEAD]);
-  bcn->head_len = nla_len(info->attrs[NL80211_ATTR_BEACON_HEAD]);
+ if (attrs[NL80211_ATTR_BEACON_HEAD]) {
+  bcn->head = nla_data(attrs[NL80211_ATTR_BEACON_HEAD]);
+  bcn->head_len = nla_len(attrs[NL80211_ATTR_BEACON_HEAD]);
   if (!bcn->head_len)
    return -EINVAL;
   haveinfo = true;
  }
 
- if (info->attrs[NL80211_ATTR_BEACON_TAIL]) {
-  bcn->tail = nla_data(info->attrs[NL80211_ATTR_BEACON_TAIL]);
-  bcn->tail_len =
-      nla_len(info->attrs[NL80211_ATTR_BEACON_TAIL]);
+ if (attrs[NL80211_ATTR_BEACON_TAIL]) {
+  bcn->tail = nla_data(attrs[NL80211_ATTR_BEACON_TAIL]);
+  bcn->tail_len = nla_len(attrs[NL80211_ATTR_BEACON_TAIL]);
   haveinfo = true;
  }
 
  if (!haveinfo)
   return -EINVAL;
 
- if (info->attrs[NL80211_ATTR_IE]) {
-  bcn->beacon_ies = nla_data(info->attrs[NL80211_ATTR_IE]);
-  bcn->beacon_ies_len = nla_len(info->attrs[NL80211_ATTR_IE]);
+ if (attrs[NL80211_ATTR_IE]) {
+  bcn->beacon_ies = nla_data(attrs[NL80211_ATTR_IE]);
+  bcn->beacon_ies_len = nla_len(attrs[NL80211_ATTR_IE]);
  }
 
- if (info->attrs[NL80211_ATTR_IE_PROBE_RESP]) {
+ if (attrs[NL80211_ATTR_IE_PROBE_RESP]) {
   bcn->proberesp_ies =
-   nla_data(info->attrs[NL80211_ATTR_IE_PROBE_RESP]);
+   nla_data(attrs[NL80211_ATTR_IE_PROBE_RESP]);
   bcn->proberesp_ies_len =
-   nla_len(info->attrs[NL80211_ATTR_IE_PROBE_RESP]);
+   nla_len(attrs[NL80211_ATTR_IE_PROBE_RESP]);
  }
 
- if (info->attrs[NL80211_ATTR_IE_ASSOC_RESP]) {
+ if (attrs[NL80211_ATTR_IE_ASSOC_RESP]) {
   bcn->assocresp_ies =
-   nla_data(info->attrs[NL80211_ATTR_IE_ASSOC_RESP]);
+   nla_data(attrs[NL80211_ATTR_IE_ASSOC_RESP]);
   bcn->assocresp_ies_len =
-   nla_len(info->attrs[NL80211_ATTR_IE_ASSOC_RESP]);
+   nla_len(attrs[NL80211_ATTR_IE_ASSOC_RESP]);
  }
 
- if (info->attrs[NL80211_ATTR_PROBE_RESP]) {
-  bcn->probe_resp =
-   nla_data(info->attrs[NL80211_ATTR_PROBE_RESP]);
-  bcn->probe_resp_len =
-   nla_len(info->attrs[NL80211_ATTR_PROBE_RESP]);
+ if (attrs[NL80211_ATTR_PROBE_RESP]) {
+  bcn->probe_resp = nla_data(attrs[NL80211_ATTR_PROBE_RESP]);
+  bcn->probe_resp_len = nla_len(attrs[NL80211_ATTR_PROBE_RESP]);
  }
 
  return 0;
@@ -3020,8 +3153,6 @@ static bool nl80211_get_ap_channel(struct cfg80211_registered_device *rdev,
  struct wireless_dev *wdev;
  bool ret = false;
 
- mutex_lock(&rdev->devlist_mtx);
-
  list_for_each_entry(wdev, &rdev->wdev_list, list) {
   if (wdev->iftype != NL80211_IFTYPE_AP &&
       wdev->iftype != NL80211_IFTYPE_P2P_GO)
@@ -3035,8 +3166,6 @@ static bool nl80211_get_ap_channel(struct cfg80211_registered_device *rdev,
   break;
  }
 
- mutex_unlock(&rdev->devlist_mtx);
-
  return ret;
 }
 
@@ -3071,7 +3200,6 @@ static int nl80211_start_ap(struct sk_buff *skb, struct genl_info *info)
  struct wireless_dev *wdev = dev->ieee80211_ptr;
  struct cfg80211_ap_settings params;
  int err;
- u8 radar_detect_width = 0;
 
  if (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_AP &&
      dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_GO)
@@ -3091,7 +3219,7 @@ static int nl80211_start_ap(struct sk_buff *skb, struct genl_info *info)
      !info->attrs[NL80211_ATTR_BEACON_HEAD])
   return -EINVAL;
 
- err = nl80211_parse_beacon(info, &params.beacon);
+ err = nl80211_parse_beacon(info->attrs, &params.beacon);
  if (err)
   return err;
 
@@ -3187,41 +3315,26 @@ static int nl80211_start_ap(struct sk_buff *skb, struct genl_info *info)
  } else if (!nl80211_get_ap_channel(rdev, &params))
   return -EINVAL;
 
- if (!cfg80211_reg_can_beacon(&rdev->wiphy, &params.chandef))
+ if (!cfg80211_reg_can_beacon(&rdev->wiphy, &params.chandef,
+         wdev->iftype))
   return -EINVAL;
 
- err = cfg80211_chandef_dfs_required(wdev->wiphy, &params.chandef);
- if (err < 0)
-  return err;
- if (err) {
-  radar_detect_width = BIT(params.chandef.width);
-  params.radar_required = true;
- }
-
- mutex_lock(&rdev->devlist_mtx);
- err = cfg80211_can_use_iftype_chan(rdev, wdev, wdev->iftype,
-        params.chandef.chan,
-        CHAN_MODE_SHARED,
-        radar_detect_width);
- mutex_unlock(&rdev->devlist_mtx);
-
- if (err)
-  return err;
-
  if (info->attrs[NL80211_ATTR_ACL_POLICY]) {
   params.acl = parse_acl_data(&rdev->wiphy, info);
   if (IS_ERR(params.acl))
    return PTR_ERR(params.acl);
  }
 
+ wdev_lock(wdev);
  err = rdev_start_ap(rdev, dev, &params);
  if (!err) {
   wdev->preset_chandef = params.chandef;
   wdev->beacon_interval = params.beacon_interval;
-  wdev->channel = params.chandef.chan;
+  wdev->chandef = params.chandef;
   wdev->ssid_len = params.ssid_len;
   memcpy(wdev->ssid, params.ssid, wdev->ssid_len);
  }
+ wdev_unlock(wdev);
 
  kfree(params.acl);
 
@@ -3246,11 +3359,15 @@ static int nl80211_set_beacon(struct sk_buff *skb, struct genl_info *info)
  if (!wdev->beacon_interval)
   return -EINVAL;
 
- err = nl80211_parse_beacon(info, &params);
+ err = nl80211_parse_beacon(info->attrs, &params);
  if (err)
   return err;
 
- return rdev_change_beacon(rdev, dev, &params);
+ wdev_lock(wdev);
+ err = rdev_change_beacon(rdev, dev, &params);
+ wdev_unlock(wdev);
+
+ return err;
 }
 
 static int nl80211_stop_ap(struct sk_buff *skb, struct genl_info *info)
@@ -3258,7 +3375,7 @@ static int nl80211_stop_ap(struct sk_buff *skb, struct genl_info *info)
  struct cfg80211_registered_device *rdev = info->user_ptr[0];
  struct net_device *dev = info->user_ptr[1];
 
- return cfg80211_stop_ap(rdev, dev);
+ return cfg80211_stop_ap(rdev, dev, false);
 }
 
 static const struct nla_policy sta_flags_policy[NL80211_STA_FLAG_MAX + 1] = {
@@ -3404,6 +3521,32 @@ static bool nl80211_put_sta_rate(struct sk_buff *msg, struct rate_info *info,
  return true;
 }
 
+static bool nl80211_put_signal(struct sk_buff *msg, u8 mask, s8 *signal,
+          int id)
+{
+ void *attr;
+ int i = 0;
+
+ if (!mask)
+  return true;
+
+ attr = nla_nest_start(msg, id);
+ if (!attr)
+  return false;
+
+ for (i = 0; i < IEEE80211_MAX_CHAINS; i++) {
+  if (!(mask & BIT(i)))
+   continue;
+
+  if (nla_put_u8(msg, i, signal[i]))
+   return false;
+ }
+
+ nla_nest_end(msg, attr);
+
+ return true;
+}
+
 static int nl80211_send_station(struct sk_buff *msg, u32 portid, u32 seq,
     int flags,
     struct cfg80211_registered_device *rdev,
@@ -3475,6 +3618,18 @@ static int nl80211_send_station(struct sk_buff *msg, u32 portid, u32 seq,
  default:
   break;
  }
+ if (sinfo->filled & STATION_INFO_CHAIN_SIGNAL) {
+  if (!nl80211_put_signal(msg, sinfo->chains,
+     sinfo->chain_signal,
+     NL80211_STA_INFO_CHAIN_SIGNAL))
+   goto nla_put_failure;
+ }
+ if (sinfo->filled & STATION_INFO_CHAIN_SIGNAL_AVG) {
+  if (!nl80211_put_signal(msg, sinfo->chains,
+     sinfo->chain_signal_avg,
+     NL80211_STA_INFO_CHAIN_SIGNAL_AVG))
+   goto nla_put_failure;
+ }
  if (sinfo->filled & STATION_INFO_TX_BITRATE) {
   if (!nl80211_put_sta_rate(msg, &sinfo->txrate,
        NL80211_STA_INFO_TX_BITRATE))
@@ -3501,6 +3656,10 @@ static int nl80211_send_station(struct sk_buff *msg, u32 portid, u32 seq,
      nla_put_u32(msg, NL80211_STA_INFO_TX_FAILED,
    sinfo->tx_failed))
   goto nla_put_failure;
+ if ((sinfo->filled & STATION_INFO_EXPECTED_THROUGHPUT) &&
+     nla_put_u32(msg, NL80211_STA_INFO_EXPECTED_THROUGHPUT,
+   sinfo->expected_throughput))
+  goto nla_put_failure;
  if ((sinfo->filled & STATION_INFO_BEACON_LOSS_COUNT) &&
      nla_put_u32(msg, NL80211_STA_INFO_BEACON_LOSS,
    sinfo->beacon_loss_count))
@@ -3563,13 +3722,13 @@ static int nl80211_dump_station(struct sk_buff *skb,
     struct netlink_callback *cb)
 {
  struct station_info sinfo;
- struct cfg80211_registered_device *dev;
+ struct cfg80211_registered_device *rdev;
  struct wireless_dev *wdev;
  u8 mac_addr[ETH_ALEN];
  int sta_idx = cb->args[2];
  int err;
 
- err = nl80211_prepare_wdev_dump(skb, cb, &dev, &wdev);
+ err = nl80211_prepare_wdev_dump(skb, cb, &rdev, &wdev);
  if (err)
   return err;
 
@@ -3578,14 +3737,14 @@ static int nl80211_dump_station(struct sk_buff *skb,
   goto out_err;
  }
 
- if (!dev->ops->dump_station) {
+ if (!rdev->ops->dump_station) {
   err = -EOPNOTSUPP;
   goto out_err;
  }
 
  while (1) {
   memset(&sinfo, 0, sizeof(sinfo));
-  err = rdev_dump_station(dev, wdev->netdev, sta_idx,
+  err = rdev_dump_station(rdev, wdev->netdev, sta_idx,
      mac_addr, &sinfo);
   if (err == -ENOENT)
    break;
@@ -3595,7 +3754,7 @@ static int nl80211_dump_station(struct sk_buff *skb,
   if (nl80211_send_station(skb,
     NETLINK_CB(cb->skb).portid,
     cb->nlh->nlmsg_seq, NLM_F_MULTI,
-    dev, wdev->netdev, mac_addr,
+    rdev, wdev->netdev, mac_addr,
     &sinfo) < 0)
    goto out;
 
@@ -3607,7 +3766,7 @@ static int nl80211_dump_station(struct sk_buff *skb,
  cb->args[2] = sta_idx;
  err = skb->len;
  out_err:
- nl80211_finish_wdev_dump(dev);
+ nl80211_finish_wdev_dump(rdev);
 
  return err;
 }
@@ -3818,8 +3977,8 @@ static struct net_device *get_vlan(struct genl_info *info,
  return ERR_PTR(ret);
 }
 
-static struct nla_policy
-nl80211_sta_wme_policy[NL80211_STA_WME_MAX + 1] __read_mostly = {
+static const struct nla_policy
+nl80211_sta_wme_policy[NL80211_STA_WME_MAX + 1] = {
  [NL80211_STA_WME_UAPSD_QUEUES] = { .type = NLA_U8 },
  [NL80211_STA_WME_MAX_SP] = { .type = NLA_U8 },
 };
@@ -3858,10 +4017,48 @@ static int nl80211_parse_sta_wme(struct genl_info *info,
  return 0;
 }
 
+static int nl80211_parse_sta_channel_info(struct genl_info *info,
+          struct station_parameters *params)
+{
+ if (info->attrs[NL80211_ATTR_STA_SUPPORTED_CHANNELS]) {
+  params->supported_channels =
+       nla_data(info->attrs[NL80211_ATTR_STA_SUPPORTED_CHANNELS]);
+  params->supported_channels_len =
+       nla_len(info->attrs[NL80211_ATTR_STA_SUPPORTED_CHANNELS]);
+  /*
+   * Need to include at least one (first channel, number of
+   * channels) tuple for each subband, and must have proper
+   * tuples for the rest of the data as well.
+   */
+  if (params->supported_channels_len < 2)
+   return -EINVAL;
+  if (params->supported_channels_len % 2)
+   return -EINVAL;
+ }
+
+ if (info->attrs[NL80211_ATTR_STA_SUPPORTED_OPER_CLASSES]) {
+  params->supported_oper_classes =
+   nla_data(info->attrs[NL80211_ATTR_STA_SUPPORTED_OPER_CLASSES]);
+  params->supported_oper_classes_len =
+    nla_len(info->attrs[NL80211_ATTR_STA_SUPPORTED_OPER_CLASSES]);
+  /*
+   * The value of the Length field of the Supported Operating
+   * Classes element is between 2 and 253.
+   */
+  if (params->supported_oper_classes_len < 2 ||
+      params->supported_oper_classes_len > 253)
+   return -EINVAL;
+ }
+ return 0;
+}
+
 static int nl80211_set_station_tdls(struct genl_info *info,
         struct station_parameters *params)
 {
+ int err;
  /* Dummy STA entry gets updated once the peer capabilities are known */
+ if (info->attrs[NL80211_ATTR_PEER_AID])
+  params->aid = nla_get_u16(info->attrs[NL80211_ATTR_PEER_AID]);
  if (info->attrs[NL80211_ATTR_HT_CAPABILITY])
   params->ht_capa =
    nla_data(info->attrs[NL80211_ATTR_HT_CAPABILITY]);
@@ -3869,6 +4066,10 @@ static int nl80211_set_station_tdls(struct genl_info *info,
   params->vht_capa =
    nla_data(info->attrs[NL80211_ATTR_VHT_CAPABILITY]);
 
+ err = nl80211_parse_sta_channel_info(info, params);
+ if (err)
+  return err;
+
  return nl80211_parse_sta_wme(info, params);
 }
 
@@ -4002,7 +4203,8 @@ static int nl80211_new_station(struct sk_buff *skb, struct genl_info *info)
  if (!info->attrs[NL80211_ATTR_STA_SUPPORTED_RATES])
   return -EINVAL;
 
- if (!info->attrs[NL80211_ATTR_STA_AID])
+ if (!info->attrs[NL80211_ATTR_STA_AID] &&
+     !info->attrs[NL80211_ATTR_PEER_AID])
   return -EINVAL;
 
  mac_addr = nla_data(info->attrs[NL80211_ATTR_MAC]);
@@ -4013,7 +4215,10 @@ static int nl80211_new_station(struct sk_buff *skb, struct genl_info *info)
  params.listen_interval =
   nla_get_u16(info->attrs[NL80211_ATTR_STA_LISTEN_INTERVAL]);
 
- params.aid = nla_get_u16(info->attrs[NL80211_ATTR_STA_AID]);
+ if (info->attrs[NL80211_ATTR_PEER_AID])
+  params.aid = nla_get_u16(info->attrs[NL80211_ATTR_PEER_AID]);
+ else
+  params.aid = nla_get_u16(info->attrs[NL80211_ATTR_STA_AID]);
  if (!params.aid || params.aid > IEEE80211_MAX_AID)
   return -EINVAL;
 
@@ -4038,6 +4243,12 @@ static int nl80211_new_station(struct sk_buff *skb, struct genl_info *info)
   params.vht_capa =
    nla_data(info->attrs[NL80211_ATTR_VHT_CAPABILITY]);
 
+ if (info->attrs[NL80211_ATTR_OPMODE_NOTIF]) {
+  params.opmode_notif_used = true;
+  params.opmode_notif =
+   nla_get_u8(info->attrs[NL80211_ATTR_OPMODE_NOTIF]);
+ }
+
  if (info->attrs[NL80211_ATTR_STA_PLINK_ACTION]) {
   params.plink_action =
    nla_get_u8(info->attrs[NL80211_ATTR_STA_PLINK_ACTION]);
@@ -4045,6 +4256,10 @@ static int nl80211_new_station(struct sk_buff *skb, struct genl_info *info)
    return -EINVAL;
  }
 
+ err = nl80211_parse_sta_channel_info(info, &params);
+ if (err)
+  return err;
+
  err = nl80211_parse_sta_wme(info, &params);
  if (err)
   return err;
@@ -4065,7 +4280,8 @@ static int nl80211_new_station(struct sk_buff *skb, struct genl_info *info)
    params.sta_modify_mask &= ~STATION_PARAM_APPLY_UAPSD;
 
   /* TDLS peers cannot be added */
-  if (params.sta_flags_set & BIT(NL80211_STA_FLAG_TDLS_PEER))
+  if ((params.sta_flags_set & BIT(NL80211_STA_FLAG_TDLS_PEER)) ||
+      info->attrs[NL80211_ATTR_PEER_AID])
    return -EINVAL;
   /* but don't bother the driver with it */
   params.sta_flags_mask &= ~BIT(NL80211_STA_FLAG_TDLS_PEER);
@@ -4091,7 +4307,8 @@ static int nl80211_new_station(struct sk_buff *skb, struct genl_info *info)
   if (params.sta_flags_mask & BIT(NL80211_STA_FLAG_ASSOCIATED))
    return -EINVAL;
   /* TDLS peers cannot be added */
-  if (params.sta_flags_set & BIT(NL80211_STA_FLAG_TDLS_PEER))
+  if ((params.sta_flags_set & BIT(NL80211_STA_FLAG_TDLS_PEER)) ||
+      info->attrs[NL80211_ATTR_PEER_AID])
    return -EINVAL;
   break;
  case NL80211_IFTYPE_STATION:
@@ -4210,18 +4427,18 @@ static int nl80211_dump_mpath(struct sk_buff *skb,
          struct netlink_callback *cb)
 {
  struct mpath_info pinfo;
- struct cfg80211_registered_device *dev;
+ struct cfg80211_registered_device *rdev;
  struct wireless_dev *wdev;
  u8 dst[ETH_ALEN];
  u8 next_hop[ETH_ALEN];
  int path_idx = cb->args[2];
  int err;
 
- err = nl80211_prepare_wdev_dump(skb, cb, &dev, &wdev);
+ err = nl80211_prepare_wdev_dump(skb, cb, &rdev, &wdev);
  if (err)
   return err;
 
- if (!dev->ops->dump_mpath) {
+ if (!rdev->ops->dump_mpath) {
   err = -EOPNOTSUPP;
   goto out_err;
  }
@@ -4232,7 +4449,7 @@ static int nl80211_dump_mpath(struct sk_buff *skb,
  }
 
  while (1) {
-  err = rdev_dump_mpath(dev, wdev->netdev, path_idx, dst,
+  err = rdev_dump_mpath(rdev, wdev->netdev, path_idx, dst,
           next_hop, &pinfo);
   if (err == -ENOENT)
    break;
@@ -4253,7 +4470,7 @@ static int nl80211_dump_mpath(struct sk_buff *skb,
  cb->args[2] = path_idx;
  err = skb->len;
  out_err:
- nl80211_finish_wdev_dump(dev);
+ nl80211_finish_wdev_dump(rdev);
  return err;
 }
 
@@ -4366,7 +4583,9 @@ static int nl80211_set_bss(struct sk_buff *skb, struct genl_info *info)
 {
  struct cfg80211_registered_device *rdev = info->user_ptr[0];
  struct net_device *dev = info->user_ptr[1];
+ struct wireless_dev *wdev = dev->ieee80211_ptr;
  struct bss_parameters params;
+ int err;
 
  memset(&params, 0, sizeof(params));
  /* default to not changing parameters */
@@ -4432,7 +4651,11 @@ static int nl80211_set_bss(struct sk_buff *skb, struct genl_info *info)
      dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_GO)
   return -EOPNOTSUPP;
 
- return rdev_change_bss(rdev, dev, &params);
+ wdev_lock(wdev);
+ err = rdev_change_bss(rdev, dev, &params);
+ wdev_unlock(wdev);
+
+ return err;
 }
 
 static const struct nla_policy reg_rule_policy[NL80211_REG_RULE_ATTR_MAX + 1] = {
@@ -4442,6 +4665,7 @@ static const struct nla_policy reg_rule_policy[NL80211_REG_RULE_ATTR_MAX + 1] =
  [NL80211_ATTR_FREQ_RANGE_MAX_BW] = { .type = NLA_U32 },
  [NL80211_ATTR_POWER_RULE_MAX_ANT_GAIN] = { .type = NLA_U32 },
  [NL80211_ATTR_POWER_RULE_MAX_EIRP] = { .type = NLA_U32 },
+ [NL80211_ATTR_DFS_CAC_TIME]  = { .type = NLA_U32 },
 };
 
 static int parse_reg_rule(struct nlattr *tb[],
@@ -4477,12 +4701,15 @@ static int parse_reg_rule(struct nlattr *tb[],
   power_rule->max_antenna_gain =
    nla_get_u32(tb[NL80211_ATTR_POWER_RULE_MAX_ANT_GAIN]);
 
+ if (tb[NL80211_ATTR_DFS_CAC_TIME])
+  reg_rule->dfs_cac_ms =
+   nla_get_u32(tb[NL80211_ATTR_DFS_CAC_TIME]);
+
  return 0;
 }
 
 static int nl80211_req_set_reg(struct sk_buff *skb, struct genl_info *info)
 {
- int r;
  char *data = NULL;
  enum nl80211_user_reg_hint_type user_reg_hint_type;
 
@@ -4495,11 +4722,6 @@ static int nl80211_req_set_reg(struct sk_buff *skb, struct genl_info *info)
  if (unlikely(!rcu_access_pointer(cfg80211_regdomain)))
   return -EINPROGRESS;
 
- if (!info->attrs[NL80211_ATTR_REG_ALPHA2])
-  return -EINVAL;
-
- data = nla_data(info->attrs[NL80211_ATTR_REG_ALPHA2]);
-
  if (info->attrs[NL80211_ATTR_USER_REG_HINT_TYPE])
   user_reg_hint_type =
     nla_get_u32(info->attrs[NL80211_ATTR_USER_REG_HINT_TYPE]);
@@ -4509,14 +4731,16 @@ static int nl80211_req_set_reg(struct sk_buff *skb, struct genl_info *info)
  switch (user_reg_hint_type) {
  case NL80211_USER_REG_HINT_USER:
  case NL80211_USER_REG_HINT_CELL_BASE:
-  break;
+  if (!info->attrs[NL80211_ATTR_REG_ALPHA2])
+   return -EINVAL;
+
+  data = nla_data(info->attrs[NL80211_ATTR_REG_ALPHA2]);
+  return regulatory_hint_user(data, user_reg_hint_type);
+ case NL80211_USER_REG_HINT_INDOOR:
+  return regulatory_hint_indoor_user();
  default:
   return -EINVAL;
  }
-
- r = regulatory_hint_user(data, user_reg_hint_type);
-
- return r;
 }
 
 static int nl80211_get_mesh_config(struct sk_buff *skb,
@@ -4613,7 +4837,9 @@ static int nl80211_get_mesh_config(struct sk_buff *skb,
      nla_put_u32(msg, NL80211_MESHCONF_POWER_MODE,
    cur_params.power_mode) ||
      nla_put_u16(msg, NL80211_MESHCONF_AWAKE_WINDOW,
-   cur_params.dot11MeshAwakeWindowDuration))
+   cur_params.dot11MeshAwakeWindowDuration) ||
+     nla_put_u32(msg, NL80211_MESHCONF_PLINK_TIMEOUT,
+   cur_params.plink_timeout))
   goto nla_put_failure;
  nla_nest_end(msg, pinfoattr);
  genlmsg_end(msg, hdr);
@@ -4654,6 +4880,7 @@ static const struct nla_policy nl80211_meshconf_params_policy[NL80211_MESHCONF_A
  [NL80211_MESHCONF_HWMP_CONFIRMATION_INTERVAL] = { .type = NLA_U16 },
  [NL80211_MESHCONF_POWER_MODE] = { .type = NLA_U32 },
  [NL80211_MESHCONF_AWAKE_WINDOW] = { .type = NLA_U16 },
+ [NL80211_MESHCONF_PLINK_TIMEOUT] = { .type = NLA_U32 },
 };
 
 static const struct nla_policy
@@ -4662,6 +4889,7 @@ static const struct nla_policy
  [NL80211_MESH_SETUP_ENABLE_VENDOR_PATH_SEL] = { .type = NLA_U8 },
  [NL80211_MESH_SETUP_ENABLE_VENDOR_METRIC] = { .type = NLA_U8 },
  [NL80211_MESH_SETUP_USERSPACE_AUTH] = { .type = NLA_FLAG },
+ [NL80211_MESH_SETUP_AUTH_PROTOCOL] = { .type = NLA_U8 },
  [NL80211_MESH_SETUP_USERSPACE_MPM] = { .type = NLA_FLAG },
  [NL80211_MESH_SETUP_IE] = { .type = NLA_BINARY,
         .len = IEEE80211_MAX_DATA_LEN },
@@ -4764,9 +4992,9 @@ do {             \
  FILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshForwarding, 0, 1,
       mask, NL80211_MESHCONF_FORWARDING,
       nla_get_u8);
- FILL_IN_MESH_PARAM_IF_SET(tb, cfg, rssi_threshold, 1, 255,
+ FILL_IN_MESH_PARAM_IF_SET(tb, cfg, rssi_threshold, -255, 0,
       mask, NL80211_MESHCONF_RSSI_THRESHOLD,
-      nla_get_u32);
+      nla_get_s32);
  FILL_IN_MESH_PARAM_IF_SET(tb, cfg, ht_opmode, 0, 16,
       mask, NL80211_MESHCONF_HT_OPMODE,
       nla_get_u16);
@@ -4790,6 +5018,9 @@ do {             \
  FILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshAwakeWindowDuration,
       0, 65535, mask,
       NL80211_MESHCONF_AWAKE_WINDOW, nla_get_u16);
+ FILL_IN_MESH_PARAM_IF_SET(tb, cfg, plink_timeout, 1, 0xffffffff,
+      mask, NL80211_MESHCONF_PLINK_TIMEOUT,
+      nla_get_u32);
  if (mask_out)
   *mask_out = mask;
 
@@ -4847,6 +5078,13 @@ static int nl80211_parse_mesh_setup(struct genl_info *info,
  if (setup->is_secure)
   setup->user_mpm = true;
 
+ if (tb[NL80211_MESH_SETUP_AUTH_PROTOCOL]) {
+  if (!setup->user_mpm)
+   return -EINVAL;
+  setup->auth_id =
+   nla_get_u8(tb[NL80211_MESH_SETUP_AUTH_PROTOCOL]);
+ }
+
  return 0;
 }
 
@@ -4889,18 +5127,13 @@ static int nl80211_get_reg(struct sk_buff *skb, struct genl_info *info)
  void *hdr = NULL;
  struct nlattr *nl_reg_rules;
  unsigned int i;
- int err = -EINVAL;
-
- mutex_lock(&cfg80211_mutex);
 
  if (!cfg80211_regdomain)
-  goto out;
+  return -EINVAL;
 
  msg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);
- if (!msg) {
-  err = -ENOBUFS;
-  goto out;
- }
+ if (!msg)
+  return -ENOBUFS;
 
  hdr = nl80211hdr_put(msg, info->snd_portid, info->snd_seq, 0,
         NL80211_CMD_GET_REG);
@@ -4929,6 +5162,7 @@ static int nl80211_get_reg(struct sk_buff *skb, struct genl_info *info)
   const struct ieee80211_reg_rule *reg_rule;
   const struct ieee80211_freq_range *freq_range;
   const struct ieee80211_power_rule *power_rule;
+  unsigned int max_bandwidth_khz;
 
   reg_rule = &regdom->reg_rules[i];
   freq_range = &reg_rule->freq_range;
@@ -4938,6 +5172,11 @@ static int nl80211_get_reg(struct sk_buff *skb, struct genl_info *info)
   if (!nl_reg_rule)
    goto nla_put_failure_rcu;
 
+  max_bandwidth_khz = freq_range->max_bandwidth_khz;
+  if (!max_bandwidth_khz)
+   max_bandwidth_khz = reg_get_max_bandwidth(regdom,
+          reg_rule);
+
   if (nla_put_u32(msg, NL80211_ATTR_REG_RULE_FLAGS,
     reg_rule->flags) ||
       nla_put_u32(msg, NL80211_ATTR_FREQ_RANGE_START,
@@ -4945,11 +5184,13 @@ static int nl80211_get_reg(struct sk_buff *skb, struct genl_info *info)
       nla_put_u32(msg, NL80211_ATTR_FREQ_RANGE_END,
     freq_range->end_freq_khz) ||
       nla_put_u32(msg, NL80211_ATTR_FREQ_RANGE_MAX_BW,
-    freq_range->max_bandwidth_khz) ||
+    max_bandwidth_khz) ||
       nla_put_u32(msg, NL80211_ATTR_POWER_RULE_MAX_ANT_GAIN,
     power_rule->max_antenna_gain) ||
       nla_put_u32(msg, NL80211_ATTR_POWER_RULE_MAX_EIRP,
-    power_rule->max_eirp))
+    power_rule->max_eirp) ||
+      nla_put_u32(msg, NL80211_ATTR_DFS_CAC_TIME,
+    reg_rule->dfs_cac_ms))
    goto nla_put_failure_rcu;
 
   nla_nest_end(msg, nl_reg_rule);
@@ -4959,8 +5200,7 @@ static int nl80211_get_reg(struct sk_buff *skb, struct genl_info *info)
  nla_nest_end(msg, nl_reg_rules);
 
  genlmsg_end(msg, hdr);
- err = genlmsg_reply(msg, info);
- goto out;
+ return genlmsg_reply(msg, info);
 
 nla_put_failure_rcu:
  rcu_read_unlock();
@@ -4968,10 +5208,7 @@ nla_put_failure:
  genlmsg_cancel(msg, hdr);
 put_failure:
  nlmsg_free(msg);
- err = -EMSGSIZE;
-out:
- mutex_unlock(&cfg80211_mutex);
- return err;
+ return -EMSGSIZE;
 }
 
 static int nl80211_set_reg(struct sk_buff *skb, struct genl_info *info)
@@ -4981,7 +5218,7 @@ static int nl80211_set_reg(struct sk_buff *skb, struct genl_info *info)
  char *alpha2 = NULL;
  int rem_reg_rules = 0, r = 0;
  u32 num_rules = 0, rule_idx = 0, size_of_regd;
- u8 dfs_region = 0;
+ enum nl80211_dfs_regions dfs_region = NL80211_DFS_UNSET;
  struct ieee80211_regdomain *rd = NULL;
 
  if (!info->attrs[NL80211_ATTR_REG_ALPHA2])
@@ -5002,6 +5239,9 @@ static int nl80211_set_reg(struct sk_buff *skb, struct genl_info *info)
    return -EINVAL;
  }
 
+ if (!reg_is_valid_request(alpha2))
+  return -EINVAL;
+
  size_of_regd = sizeof(struct ieee80211_regdomain) +
          num_rules * sizeof(struct ieee80211_reg_rule);
 
@@ -5022,9 +5262,11 @@ static int nl80211_set_reg(struct sk_buff *skb, struct genl_info *info)
 
  nla_for_each_nested(nl_reg_rule, info->attrs[NL80211_ATTR_REG_RULES],
        rem_reg_rules) {
-  nla_parse(tb, NL80211_REG_RULE_ATTR_MAX,
-     nla_data(nl_reg_rule), nla_len(nl_reg_rule),
-     reg_rule_policy);
+  r = nla_parse(tb, NL80211_REG_RULE_ATTR_MAX,
+         nla_data(nl_reg_rule), nla_len(nl_reg_rule),
+         reg_rule_policy);
+  if (r)
+   goto bad_reg;
   r = parse_reg_rule(tb, &rd->reg_rules[rule_idx]);
   if (r)
    goto bad_reg;
@@ -5037,12 +5279,9 @@ static int nl80211_set_reg(struct sk_buff *skb, struct genl_info *info)
   }
  }
 
- mutex_lock(&cfg80211_mutex);
-
  r = set_regdom(rd);
  /* set_regdom took ownership */
  rd = NULL;
- mutex_unlock(&cfg80211_mutex);
 
  bad_reg:
  kfree(rd);
@@ -5092,8 +5331,7 @@ static int nl80211_trigger_scan(struct sk_buff *skb, struct genl_info *info)
  if (!rdev->ops->scan)
   return -EOPNOTSUPP;
 
- mutex_lock(&rdev->sched_scan_mtx);
- if (rdev->scan_req) {
+ if (rdev->scan_req || rdev->scan_msg) {
   err = -EBUSY;
   goto unlock;
  }
@@ -5106,12 +5344,7 @@ static int nl80211_trigger_scan(struct sk_buff *skb, struct genl_info *info)
    goto unlock;
   }
  } else {
-  enum ieee80211_band band;
-  n_channels = 0;
-
-  for (band = 0; band < IEEE80211_NUM_BANDS; band++)
-   if (wiphy->bands[band])
-    n_channels += wiphy->bands[band]->n_channels;
+  n_channels = ieee80211_get_num_supported_channels(wiphy);
  }
 
  if (info->attrs[NL80211_ATTR_SCAN_SSIDS])
@@ -5236,6 +5469,10 @@ static int nl80211_trigger_scan(struct sk_buff *skb, struct genl_info *info)
     err = -EINVAL;
     goto out_free;
    }
+
+   if (!wiphy->bands[band])
+    continue;
+
    err = ieee80211_get_ratemask(wiphy->bands[band],
            nla_data(attr),
            nla_len(attr),
@@ -5248,10 +5485,8 @@ static int nl80211_trigger_scan(struct sk_buff *skb, struct genl_info *info)
  if (info->attrs[NL80211_ATTR_SCAN_FLAGS]) {
   request->flags = nla_get_u32(
    info->attrs[NL80211_ATTR_SCAN_FLAGS]);
-  if (((request->flags & NL80211_SCAN_FLAG_LOW_PRIORITY) &&
-       !(wiphy->features & NL80211_FEATURE_LOW_PRIORITY_SCAN)) ||
-      ((request->flags & NL80211_SCAN_FLAG_FLUSH) &&
-       !(wiphy->features & NL80211_FEATURE_SCAN_FLUSH))) {
+  if ((request->flags & NL80211_SCAN_FLAG_LOW_PRIORITY) &&
+      !(wiphy->features & NL80211_FEATURE_LOW_PRIORITY_SCAN)) {
    err = -EOPNOTSUPP;
    goto out_free;
   }
@@ -5278,7 +5513,6 @@ static int nl80211_trigger_scan(struct sk_buff *skb, struct genl_info *info)
  }
 
  unlock:
- mutex_unlock(&rdev->sched_scan_mtx);
  return err;
 }
 
@@ -5295,6 +5529,7 @@ static int nl80211_start_sched_scan(struct sk_buff *skb,
  enum ieee80211_band band;
  size_t ie_len;
  struct nlattr *tb[NL80211_SCHED_SCAN_MATCH_ATTR_MAX + 1];
+ s32 default_match_rssi = NL80211_SCAN_RSSI_THOLD_OFF;
 
  if (!(rdev->wiphy.flags & WIPHY_FLAG_SUPPORTS_SCHED_SCAN) ||
      !rdev->ops->sched_scan_start)
@@ -5318,11 +5553,7 @@ static int nl80211_start_sched_scan(struct sk_buff *skb,
   if (!n_channels)
    return -EINVAL;
  } else {
-  n_channels = 0;
-
-  for (band = 0; band < IEEE80211_NUM_BANDS; band++)
-   if (wiphy->bands[band])
-    n_channels += wiphy->bands[band]->n_channels;
+  n_channels = ieee80211_get_num_supported_channels(wiphy);
  }
 
  if (info->attrs[NL80211_ATTR_SCAN_SSIDS])
@@ -5333,11 +5564,40 @@ static int nl80211_start_sched_scan(struct sk_buff *skb,
  if (n_ssids > wiphy->max_sched_scan_ssids)
   return -EINVAL;
 
- if (info->attrs[NL80211_ATTR_SCHED_SCAN_MATCH])
+ /*
+  * First, count the number of 'real' matchsets. Due to an issue with
+  * the old implementation, matchsets containing only the RSSI attribute
+  * (NL80211_SCHED_SCAN_MATCH_ATTR_RSSI) are considered as the 'default'
+  * RSSI for all matchsets, rather than their own matchset for reporting
+  * all APs with a strong RSSI. This is needed to be compatible with
+  * older userspace that treated a matchset with only the RSSI as the
+  * global RSSI for all other matchsets - if there are other matchsets.
+  */
+ if (info->attrs[NL80211_ATTR_SCHED_SCAN_MATCH]) {
   nla_for_each_nested(attr,
         info->attrs[NL80211_ATTR_SCHED_SCAN_MATCH],
-        tmp)
-   n_match_sets++;
+        tmp) {
+   struct nlattr *rssi;
+
+   err = nla_parse(tb, NL80211_SCHED_SCAN_MATCH_ATTR_MAX,
+     nla_data(attr), nla_len(attr),
+     nl80211_match_policy);
+   if (err)
+    return err;
+   /* add other standalone attributes here */
+   if (tb[NL80211_SCHED_SCAN_MATCH_ATTR_SSID]) {
+    n_match_sets++;
+    continue;
+   }
+   rssi = tb[NL80211_SCHED_SCAN_MATCH_ATTR_RSSI];
+   if (rssi)
+    default_match_rssi = nla_get_s32(rssi);
+  }
+ }
+
+ /* However, if there's no other matchset, add the RSSI one */
+ if (!n_match_sets && default_match_rssi != NL80211_SCAN_RSSI_THOLD_OFF)
+  n_match_sets = 1;
 
  if (n_match_sets > wiphy->max_match_sets)
   return -EINVAL;
@@ -5350,8 +5610,6 @@ static int nl80211_start_sched_scan(struct sk_buff *skb,
  if (ie_len > wiphy->max_sched_scan_ie_len)
   return -EINVAL;
 
- mutex_lock(&rdev->sched_scan_mtx);
-
  if (rdev->sched_scan_req) {
   err = -EINPROGRESS;
   goto out;
@@ -5460,11 +5718,22 @@ static int nl80211_start_sched_scan(struct sk_buff *skb,
         tmp) {
    struct nlattr *ssid, *rssi;
 
-   nla_parse(tb, NL80211_SCHED_SCAN_MATCH_ATTR_MAX,
-      nla_data(attr), nla_len(attr),
-      nl80211_match_policy);
+   err = nla_parse(tb, NL80211_SCHED_SCAN_MATCH_ATTR_MAX,
+     nla_data(attr), nla_len(attr),
+     nl80211_match_policy);
+   if (err)
+    goto out_free;
    ssid = tb[NL80211_SCHED_SCAN_MATCH_ATTR_SSID];
    if (ssid) {
+    if (WARN_ON(i >= n_match_sets)) {
+     /* this indicates a programming error,
+      * the loop above should have verified
+      * things properly
+      */
+     err = -EINVAL;
+     goto out_free;
+    }
+
     if (nla_len(ssid) > IEEE80211_MAX_SSID_LEN) {
      err = -EINVAL;
      goto out_free;
@@ -5473,19 +5742,32 @@ static int nl80211_start_sched_scan(struct sk_buff *skb,
            nla_data(ssid), nla_len(ssid));
     request->match_sets[i].ssid.ssid_len =
      nla_len(ssid);
+    /* special attribute - old implemenation w/a */
+    request->match_sets[i].rssi_thold =
+     default_match_rssi;
+    rssi = tb[NL80211_SCHED_SCAN_MATCH_ATTR_RSSI];
+    if (rssi)
+     request->match_sets[i].rssi_thold =
+      nla_get_s32(rssi);
    }
-   rssi = tb[NL80211_SCHED_SCAN_MATCH_ATTR_RSSI];
-   if (rssi)
-    request->rssi_thold = nla_get_u32(rssi);
-   else
-    request->rssi_thold =
-         NL80211_SCAN_RSSI_THOLD_OFF;
    i++;
   }
+
+  /* there was no other matchset, so the RSSI one is alone */
+  if (i == 0)
+   request->match_sets[0].rssi_thold = default_match_rssi;
+
+  request->min_rssi_thold = INT_MAX;
+  for (i = 0; i < n_match_sets; i++)
+   request->min_rssi_thold =
+    min(request->match_sets[i].rssi_thold,
+        request->min_rssi_thold);
+ } else {
+  request->min_rssi_thold = NL80211_SCAN_RSSI_THOLD_OFF;
  }
 
- if (info->attrs[NL80211_ATTR_IE]) {
-  request->ie_len = nla_len(info->attrs[NL80211_ATTR_IE]);
+ if (ie_len) {
+  request->ie_len = ie_len;
   memcpy((void *)request->ie,
          nla_data(info->attrs[NL80211_ATTR_IE]),
          request->ie_len);
@@ -5494,10 +5776,8 @@ static int nl80211_start_sched_scan(struct sk_buff *skb,
  if (info->attrs[NL80211_ATTR_SCAN_FLAGS]) {
   request->flags = nla_get_u32(
    info->attrs[NL80211_ATTR_SCAN_FLAGS]);
-  if (((request->flags & NL80211_SCAN_FLAG_LOW_PRIORITY) &&
-       !(wiphy->features & NL80211_FEATURE_LOW_PRIORITY_SCAN)) ||
-      ((request->flags & NL80211_SCAN_FLAG_FLUSH) &&
-       !(wiphy->features & NL80211_FEATURE_SCAN_FLUSH))) {
+  if ((request->flags & NL80211_SCAN_FLAG_LOW_PRIORITY) &&
+      !(wiphy->features & NL80211_FEATURE_LOW_PRIORITY_SCAN)) {
    err = -EOPNOTSUPP;
    goto out_free;
   }
@@ -5519,7 +5799,6 @@ static int nl80211_start_sched_scan(struct sk_buff *skb,
 out_free:
  kfree(request);
 out:
- mutex_unlock(&rdev->sched_scan_mtx);
  return err;
 }
 
@@ -5527,17 +5806,12 @@ static int nl80211_stop_sched_scan(struct sk_buff *skb,
        struct genl_info *info)
 {
  struct cfg80211_registered_device *rdev = info->user_ptr[0];
- int err;
 
  if (!(rdev->wiphy.flags & WIPHY_FLAG_SUPPORTS_SCHED_SCAN) ||
      !rdev->ops->sched_scan_stop)
   return -EOPNOTSUPP;
 
- mutex_lock(&rdev->sched_scan_mtx);
- err = __cfg80211_stop_sched_scan(rdev, false);
- mutex_unlock(&rdev->sched_scan_mtx);
-
- return err;
+ return __cfg80211_stop_sched_scan(rdev, false);
 }
 
 static int nl80211_start_radar_detection(struct sk_buff *skb,
@@ -5547,43 +5821,213 @@ static int nl80211_start_radar_detection(struct sk_buff *skb,
  struct net_device *dev = info->user_ptr[1];
  struct wireless_dev *wdev = dev->ieee80211_ptr;
  struct cfg80211_chan_def chandef;
+ enum nl80211_dfs_regions dfs_region;
+ unsigned int cac_time_ms;
  int err;
 
+ dfs_region = reg_get_dfs_region(wdev->wiphy);
+ if (dfs_region == NL80211_DFS_UNSET)
+  return -EINVAL;
+
  err = nl80211_parse_chandef(rdev, info, &chandef);
  if (err)
   return err;
 
+ if (netif_carrier_ok(dev))
+  return -EBUSY;
+
  if (wdev->cac_started)
   return -EBUSY;
 
- err = cfg80211_chandef_dfs_required(wdev->wiphy, &chandef);
+ err = cfg80211_chandef_dfs_required(wdev->wiphy, &chandef,
+         wdev->iftype);
  if (err < 0)
   return err;
 
  if (err == 0)
   return -EINVAL;
 
- if (chandef.chan->dfs_state != NL80211_DFS_USABLE)
+ if (!cfg80211_chandef_dfs_usable(wdev->wiphy, &chandef))
   return -EINVAL;
 
  if (!rdev->ops->start_radar_detection)
   return -EOPNOTSUPP;
 
- mutex_lock(&rdev->devlist_mtx);
- err = cfg80211_can_use_iftype_chan(rdev, wdev, wdev->iftype,
-        chandef.chan, CHAN_MODE_SHARED,
-        BIT(chandef.width));
- if (err)
-  goto err_locked;
+ cac_time_ms = cfg80211_chandef_dfs_cac_time(&rdev->wiphy, &chandef);
+ if (WARN_ON(!cac_time_ms))
+  cac_time_ms = IEEE80211_DFS_MIN_CAC_TIME_MS;
 
- err = rdev->ops->start_radar_detection(&rdev->wiphy, dev, &chandef);
+ err = rdev->ops->start_radar_detection(&rdev->wiphy, dev, &chandef,
+            cac_time_ms);
  if (!err) {
-  wdev->channel = chandef.chan;
+  wdev->chandef = chandef;
   wdev->cac_started = true;
   wdev->cac_start_time = jiffies;
+  wdev->cac_time_ms = cac_time_ms;
+ }
+ return err;
+}
+
+static int nl80211_channel_switch(struct sk_buff *skb, struct genl_info *info)
+{
+ struct cfg80211_registered_device *rdev = info->user_ptr[0];
+ struct net_device *dev = info->user_ptr[1];
+ struct wireless_dev *wdev = dev->ieee80211_ptr;
+ struct cfg80211_csa_settings params;
+ /* csa_attrs is defined static to avoid waste of stack size - this
+  * function is called under RTNL lock, so this should not be a problem.
+  */
+ static struct nlattr *csa_attrs[NL80211_ATTR_MAX+1];
+ u8 radar_detect_width = 0;
+ int err;
+ bool need_new_beacon = false;
+ int len, i;
+
+ if (!rdev->ops->channel_switch ||
+     !(rdev->wiphy.flags & WIPHY_FLAG_HAS_CHANNEL_SWITCH))
+  return -EOPNOTSUPP;
+
+ switch (dev->ieee80211_ptr->iftype) {
+ case NL80211_IFTYPE_AP:
+ case NL80211_IFTYPE_P2P_GO:
+  need_new_beacon = true;
+
+  /* useless if AP is not running */
+  if (!wdev->beacon_interval)
+   return -ENOTCONN;
+  break;
+ case NL80211_IFTYPE_ADHOC:
+  if (!wdev->ssid_len)
+   return -ENOTCONN;
+  break;
+ case NL80211_IFTYPE_MESH_POINT:
+  if (!wdev->mesh_id_len)
+   return -ENOTCONN;
+  break;
+ default:
+  return -EOPNOTSUPP;
+ }
+
+ memset(&params, 0, sizeof(params));
+
+ if (!info->attrs[NL80211_ATTR_WIPHY_FREQ] ||
+     !info->attrs[NL80211_ATTR_CH_SWITCH_COUNT])
+  return -EINVAL;
+
+ /* only important for AP, IBSS and mesh create IEs internally */
+ if (need_new_beacon && !info->attrs[NL80211_ATTR_CSA_IES])
+  return -EINVAL;
+
+ params.count = nla_get_u32(info->attrs[NL80211_ATTR_CH_SWITCH_COUNT]);
+
+ if (!need_new_beacon)
+  goto skip_beacons;
+
+ err = nl80211_parse_beacon(info->attrs, &params.beacon_after);
+ if (err)
+  return err;
+
+ err = nla_parse_nested(csa_attrs, NL80211_ATTR_MAX,
+          info->attrs[NL80211_ATTR_CSA_IES],
+          nl80211_policy);
+ if (err)
+  return err;
+
+ err = nl80211_parse_beacon(csa_attrs, &params.beacon_csa);
+ if (err)
+  return err;
+
+ if (!csa_attrs[NL80211_ATTR_CSA_C_OFF_BEACON])
+  return -EINVAL;
+
+ len = nla_len(csa_attrs[NL80211_ATTR_CSA_C_OFF_BEACON]);
+ if (!len || (len % sizeof(u16)))
+  return -EINVAL;
+
+ params.n_counter_offsets_beacon = len / sizeof(u16);
+ if (rdev->wiphy.max_num_csa_counters &&
+     (params.n_counter_offsets_beacon >
+      rdev->wiphy.max_num_csa_counters))
+  return -EINVAL;
+
+ params.counter_offsets_beacon =
+  nla_data(csa_attrs[NL80211_ATTR_CSA_C_OFF_BEACON]);
+
+ /* sanity checks - counters should fit and be the same */
+ for (i = 0; i < params.n_counter_offsets_beacon; i++) {
+  u16 offset = params.counter_offsets_beacon[i];
+
+  if (offset >= params.beacon_csa.tail_len)
+   return -EINVAL;
+
+  if (params.beacon_csa.tail[offset] != params.count)
+   return -EINVAL;
+ }
+
+ if (csa_attrs[NL80211_ATTR_CSA_C_OFF_PRESP]) {
+  len = nla_len(csa_attrs[NL80211_ATTR_CSA_C_OFF_PRESP]);
+  if (!len || (len % sizeof(u16)))
+   return -EINVAL;
+
+  params.n_counter_offsets_presp = len / sizeof(u16);
+  if (rdev->wiphy.max_num_csa_counters &&
+      (params.n_counter_offsets_beacon >
+       rdev->wiphy.max_num_csa_counters))
+   return -EINVAL;
+
+  params.counter_offsets_presp =
+   nla_data(csa_attrs[NL80211_ATTR_CSA_C_OFF_PRESP]);
+
+  /* sanity checks - counters should fit and be the same */
+  for (i = 0; i < params.n_counter_offsets_presp; i++) {
+   u16 offset = params.counter_offsets_presp[i];
+
+   if (offset >= params.beacon_csa.probe_resp_len)
+    return -EINVAL;
+
+   if (params.beacon_csa.probe_resp[offset] !=
+       params.count)
+    return -EINVAL;
+  }
  }
-err_locked:
- mutex_unlock(&rdev->devlist_mtx);
+
+skip_beacons:
+ err = nl80211_parse_chandef(rdev, info, &params.chandef);
+ if (err)
+  return err;
+
+ if (!cfg80211_reg_can_beacon(&rdev->wiphy, &params.chandef,
+         wdev->iftype))
+  return -EINVAL;
+
+ err = cfg80211_chandef_dfs_required(wdev->wiphy,
+         &params.chandef,
+         wdev->iftype);
+ if (err < 0)
+  return err;
+
+ if (err > 0) {
+  radar_detect_width = BIT(params.chandef.width);
+  params.radar_required = true;
+ }
+
+ /* TODO: I left this here for now.  With channel switch, the
+  * verification is a bit more complicated, because we only do
+  * it later when the channel switch really happens.
+  */
+ err = cfg80211_can_use_iftype_chan(rdev, wdev, wdev->iftype,
+        params.chandef.chan,
+        CHAN_MODE_SHARED,
+        radar_detect_width);
+ if (err)
+  return err;
+
+ if (info->attrs[NL80211_ATTR_CH_SWITCH_BLOCK_TX])
+  params.block_tx = true;
+
+ wdev_lock(wdev);
+ err = rdev_channel_switch(rdev, dev, &params);
+ wdev_unlock(wdev);
 
  return err;
 }
@@ -5649,6 +6093,7 @@ static int nl80211_send_bss(struct sk_buff *msg, struct netlink_callback *cb,
   goto nla_put_failure;
  if (nla_put_u16(msg, NL80211_BSS_CAPABILITY, res->capability) ||
      nla_put_u32(msg, NL80211_BSS_FREQUENCY, res->channel->center_freq) ||
+     nla_put_u32(msg, NL80211_BSS_CHAN_WIDTH, res->scan_width) ||
      nla_put_u32(msg, NL80211_BSS_SEEN_MS_AGO,
    jiffies_to_msecs(jiffies - intbss->ts)))
   goto nla_put_failure;
@@ -5796,12 +6241,12 @@ static int nl80211_dump_survey(struct sk_buff *skb,
    struct netlink_callback *cb)
 {
  struct survey_info survey;
- struct cfg80211_registered_device *dev;
+ struct cfg80211_registered_device *rdev;
  struct wireless_dev *wdev;
  int survey_idx = cb->args[2];
  int res;
 
- res = nl80211_prepare_wdev_dump(skb, cb, &dev, &wdev);
+ res = nl80211_prepare_wdev_dump(skb, cb, &rdev, &wdev);
  if (res)
   return res;
 
@@ -5810,7 +6255,7 @@ static int nl80211_dump_survey(struct sk_buff *skb,
   goto out_err;
  }
 
- if (!dev->ops->dump_survey) {
+ if (!rdev->ops->dump_survey) {
   res = -EOPNOTSUPP;
   goto out_err;
  }
@@ -5818,7 +6263,7 @@ static int nl80211_dump_survey(struct sk_buff *skb,
  while (1) {
   struct ieee80211_channel *chan;
 
-  res = rdev_dump_survey(dev, wdev->netdev, survey_idx, &survey);
+  res = rdev_dump_survey(rdev, wdev->netdev, survey_idx, &survey);
   if (res == -ENOENT)
    break;
   if (res)
@@ -5830,7 +6275,7 @@ static int nl80211_dump_survey(struct sk_buff *skb,
    goto out;
   }
 
-  chan = ieee80211_get_channel(&dev->wiphy,
+  chan = ieee80211_get_channel(&rdev->wiphy,
           survey.channel->center_freq);
   if (!chan || chan->flags & IEEE80211_CHAN_DISABLED) {
    survey_idx++;
@@ -5849,7 +6294,7 @@ static int nl80211_dump_survey(struct sk_buff *skb,
  cb->args[2] = survey_idx;
  res = skb->len;
  out_err:
- nl80211_finish_wdev_dump(dev);
+ nl80211_finish_wdev_dump(rdev);
  return res;
 }
 
@@ -5927,9 +6372,9 @@ static int nl80211_authenticate(struct sk_buff *skb, struct genl_info *info)
   return -EOPNOTSUPP;
 
  bssid = nla_data(info->attrs[NL80211_ATTR_MAC]);
- chan = ieee80211_get_channel(&rdev->wiphy,
-  nla_get_u32(info->attrs[NL80211_ATTR_WIPHY_FREQ]));
- if (!chan || (chan->flags & IEEE80211_CHAN_DISABLED))
+ chan = nl80211_get_valid_chan(&rdev->wiphy,
+          info->attrs[NL80211_ATTR_WIPHY_FREQ]);
+ if (!chan)
   return -EINVAL;
 
  ssid = nla_data(info->attrs[NL80211_ATTR_SSID]);
@@ -5967,10 +6412,13 @@ static int nl80211_authenticate(struct sk_buff *skb, struct genl_info *info)
  if (local_state_change)
   return 0;
 
- return cfg80211_mlme_auth(rdev, dev, chan, auth_type, bssid,
-      ssid, ssid_len, ie, ie_len,
-      key.p.key, key.p.key_len, key.idx,
-      sae_data, sae_data_len);
+ wdev_lock(dev->ieee80211_ptr);
+ err = cfg80211_mlme_auth(rdev, dev, chan, auth_type, bssid,
+     ssid, ssid_len, ie, ie_len,
+     key.p.key, key.p.key_len, key.idx,
+     sae_data, sae_data_len);
+ wdev_unlock(dev->ieee80211_ptr);
+ return err;
 }
 
 static int nl80211_crypto_settings(struct cfg80211_registered_device *rdev,
@@ -6079,9 +6527,9 @@ static int nl80211_associate(struct sk_buff *skb, struct genl_info *info)
 
  bssid = nla_data(info->attrs[NL80211_ATTR_MAC]);
 
- chan = ieee80211_get_channel(&rdev->wiphy,
-  nla_get_u32(info->attrs[NL80211_ATTR_WIPHY_FREQ]));
- if (!chan || (chan->flags & IEEE80211_CHAN_DISABLED))
+ chan = nl80211_get_valid_chan(&rdev->wiphy,
+          info->attrs[NL80211_ATTR_WIPHY_FREQ]);
+ if (!chan)
   return -EINVAL;
 
  ssid = nla_data(info->attrs[NL80211_ATTR_SSID]);
@@ -6137,9 +6585,12 @@ static int nl80211_associate(struct sk_buff *skb, struct genl_info *info)
  }
 
  err = nl80211_crypto_settings(rdev, info, &req.crypto, 1);
- if (!err)
+ if (!err) {
+  wdev_lock(dev->ieee80211_ptr);
   err = cfg80211_mlme_assoc(rdev, dev, chan, bssid,
        ssid, ssid_len, &req);
+  wdev_unlock(dev->ieee80211_ptr);
+ }
 
  return err;
 }
@@ -6149,7 +6600,7 @@ static int nl80211_deauthenticate(struct sk_buff *skb, struct genl_info *info)
  struct cfg80211_registered_device *rdev = info->user_ptr[0];
  struct net_device *dev = info->user_ptr[1];
  const u8 *ie = NULL, *bssid;
- int ie_len = 0;
+ int ie_len = 0, err;
  u16 reason_code;
  bool local_state_change;
 
@@ -6184,8 +6635,11 @@ static int nl80211_deauthenticate(struct sk_buff *skb, struct genl_info *info)
 
  local_state_change = !!info->attrs[NL80211_ATTR_LOCAL_STATE_CHANGE];
 
- return cfg80211_mlme_deauth(rdev, dev, bssid, ie, ie_len, reason_code,
-        local_state_change);
+ wdev_lock(dev->ieee80211_ptr);
+ err = cfg80211_mlme_deauth(rdev, dev, bssid, ie, ie_len, reason_code,
+       local_state_change);
+ wdev_unlock(dev->ieee80211_ptr);
+ return err;
 }
 
 static int nl80211_disassociate(struct sk_buff *skb, struct genl_info *info)
@@ -6193,7 +6647,7 @@ static int nl80211_disassociate(struct sk_buff *skb, struct genl_info *info)
  struct cfg80211_registered_device *rdev = info->user_ptr[0];
  struct net_device *dev = info->user_ptr[1];
  const u8 *ie = NULL, *bssid;
- int ie_len = 0;
+ int ie_len = 0, err;
  u16 reason_code;
  bool local_state_change;
 
@@ -6228,8 +6682,11 @@ static int nl80211_disassociate(struct sk_buff *skb, struct genl_info *info)
 
  local_state_change = !!info->attrs[NL80211_ATTR_LOCAL_STATE_CHANGE];
 
- return cfg80211_mlme_disassoc(rdev, dev, bssid, ie, ie_len, reason_code,
-          local_state_change);
+ wdev_lock(dev->ieee80211_ptr);
+ err = cfg80211_mlme_disassoc(rdev, dev, bssid, ie, ie_len, reason_code,
+         local_state_change);
+ wdev_unlock(dev->ieee80211_ptr);
+ return err;
 }
 
 static bool
@@ -6313,14 +6770,22 @@ static int nl80211_join_ibss(struct sk_buff *skb, struct genl_info *info)
  if (err)
   return err;
 
- if (!cfg80211_reg_can_beacon(&rdev->wiphy, &ibss.chandef))
+ if (!cfg80211_reg_can_beacon(&rdev->wiphy, &ibss.chandef,
+         NL80211_IFTYPE_ADHOC))
   return -EINVAL;
 
- if (ibss.chandef.width > NL80211_CHAN_WIDTH_40)
-  return -EINVAL;
- if (ibss.chandef.width != NL80211_CHAN_WIDTH_20_NOHT &&
-     !(rdev->wiphy.features & NL80211_FEATURE_HT_IBSS))
+ switch (ibss.chandef.width) {
+ case NL80211_CHAN_WIDTH_5:
+ case NL80211_CHAN_WIDTH_10:
+ case NL80211_CHAN_WIDTH_20_NOHT:
+  break;
+ case NL80211_CHAN_WIDTH_20:
+ case NL80211_CHAN_WIDTH_40:
+  if (rdev->wiphy.features & NL80211_FEATURE_HT_IBSS)
+   break;
+ default:
   return -EINVAL;
+ }
 
  ibss.channel_fixed = !!info->attrs[NL80211_ATTR_FREQ_FIXED];
  ibss.privacy = !!info->attrs[NL80211_ATTR_PRIVACY];
@@ -6339,6 +6804,19 @@ static int nl80211_join_ibss(struct sk_buff *skb, struct genl_info *info)
    return err;
  }
 
+ if (info->attrs[NL80211_ATTR_HT_CAPABILITY_MASK])
+  memcpy(&ibss.ht_capa_mask,
+         nla_data(info->attrs[NL80211_ATTR_HT_CAPABILITY_MASK]),
+         sizeof(ibss.ht_capa_mask));
+
+ if (info->attrs[NL80211_ATTR_HT_CAPABILITY]) {
+  if (!info->attrs[NL80211_ATTR_HT_CAPABILITY_MASK])
+   return -EINVAL;
+  memcpy(&ibss.ht_capa,
+         nla_data(info->attrs[NL80211_ATTR_HT_CAPABILITY]),
+         sizeof(ibss.ht_capa));
+ }
+
  if (info->attrs[NL80211_ATTR_MCAST_RATE] &&
      !nl80211_parse_mcast_rate(rdev, ibss.mcast_rate,
    nla_get_u32(info->attrs[NL80211_ATTR_MCAST_RATE])))
@@ -6363,6 +6841,9 @@ static int nl80211_join_ibss(struct sk_buff *skb, struct genl_info *info)
  ibss.control_port =
   nla_get_flag(info->attrs[NL80211_ATTR_CONTROL_PORT]);
 
+ ibss.userspace_handles_dfs =
+  nla_get_flag(info->attrs[NL80211_ATTR_HANDLE_DFS]);
+
  err = cfg80211_join_ibss(rdev, dev, &ibss, connkeys);
  if (err)
   kfree(connkeys);
@@ -6412,24 +6893,130 @@ static int nl80211_set_mcast_rate(struct sk_buff *skb, struct genl_info *info)
  return err;
 }
 
+static struct sk_buff *
+__cfg80211_alloc_vendor_skb(struct cfg80211_registered_device *rdev,
+       int approxlen, u32 portid, u32 seq,
+       enum nl80211_commands cmd,
+       enum nl80211_attrs attr,
+       const struct nl80211_vendor_cmd_info *info,
+       gfp_t gfp)
+{
+ struct sk_buff *skb;
+ void *hdr;
+ struct nlattr *data;
+
+ skb = nlmsg_new(approxlen + 100, gfp);
+ if (!skb)
+  return NULL;
+
+ hdr = nl80211hdr_put(skb, portid, seq, 0, cmd);
+ if (!hdr) {
+  kfree_skb(skb);
+  return NULL;
+ }
+
+ if (nla_put_u32(skb, NL80211_ATTR_WIPHY, rdev->wiphy_idx))
+  goto nla_put_failure;
+
+ if (info) {
+  if (nla_put_u32(skb, NL80211_ATTR_VENDOR_ID,
+    info->vendor_id))
+   goto nla_put_failure;
+  if (nla_put_u32(skb, NL80211_ATTR_VENDOR_SUBCMD,
+    info->subcmd))
+   goto nla_put_failure;
+ }
+
+ data = nla_nest_start(skb, attr);
+
+ ((void **)skb->cb)[0] = rdev;
+ ((void **)skb->cb)[1] = hdr;
+ ((void **)skb->cb)[2] = data;
+
+ return skb;
+
+ nla_put_failure:
+ kfree_skb(skb);
+ return NULL;
+}
+
+struct sk_buff *__cfg80211_alloc_event_skb(struct wiphy *wiphy,
+        enum nl80211_commands cmd,
+        enum nl80211_attrs attr,
+        int vendor_event_idx,
+        int approxlen, gfp_t gfp)
+{
+ struct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);
+ const struct nl80211_vendor_cmd_info *info;
+
+ switch (cmd) {
+ case NL80211_CMD_TESTMODE:
+  if (WARN_ON(vendor_event_idx != -1))
+   return NULL;
+  info = NULL;
+  break;
+ case NL80211_CMD_VENDOR:
+  if (WARN_ON(vendor_event_idx < 0 ||
+       vendor_event_idx >= wiphy->n_vendor_events))
+   return NULL;
+  info = &wiphy->vendor_events[vendor_event_idx];
+  break;
+ default:
+  WARN_ON(1);
+  return NULL;
+ }
+
+ return __cfg80211_alloc_vendor_skb(rdev, approxlen, 0, 0,
+        cmd, attr, info, gfp);
+}
+EXPORT_SYMBOL(__cfg80211_alloc_event_skb);
+
+void __cfg80211_send_event_skb(struct sk_buff *skb, gfp_t gfp)
+{
+ struct cfg80211_registered_device *rdev = ((void **)skb->cb)[0];
+ void *hdr = ((void **)skb->cb)[1];
+ struct nlattr *data = ((void **)skb->cb)[2];
+ enum nl80211_multicast_groups mcgrp = NL80211_MCGRP_TESTMODE;
+
+ nla_nest_end(skb, data);
+ genlmsg_end(skb, hdr);
+
+ if (data->nla_type == NL80211_ATTR_VENDOR_DATA)
+  mcgrp = NL80211_MCGRP_VENDOR;
+
+ genlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), skb, 0,
+    mcgrp, gfp);
+}
+EXPORT_SYMBOL(__cfg80211_send_event_skb);
 
 #ifdef CONFIG_NL80211_TESTMODE
 static int nl80211_testmode_do(struct sk_buff *skb, struct genl_info *info)
 {
  struct cfg80211_registered_device *rdev = info->user_ptr[0];
+ struct wireless_dev *wdev =
+  __cfg80211_wdev_from_attrs(genl_info_net(info), info->attrs);
  int err;
 
+ if (!rdev->ops->testmode_cmd)
+  return -EOPNOTSUPP;
+
+ if (IS_ERR(wdev)) {
+  err = PTR_ERR(wdev);
+  if (err != -EINVAL)
+   return err;
+  wdev = NULL;
+ } else if (wdev->wiphy != &rdev->wiphy) {
+  return -EINVAL;
+ }
+
  if (!info->attrs[NL80211_ATTR_TESTDATA])
   return -EINVAL;
 
- err = -EOPNOTSUPP;
- if (rdev->ops->testmode_cmd) {
-  rdev->testmode_info = info;
-  err = rdev_testmode_cmd(rdev,
+ rdev->cur_cmd_info = info;
+ err = rdev_testmode_cmd(rdev, wdev,
     nla_data(info->attrs[NL80211_ATTR_TESTDATA]),
     nla_len(info->attrs[NL80211_ATTR_TESTDATA]));
-  rdev->testmode_info = NULL;
- }
+ rdev->cur_cmd_info = NULL;
 
  return err;
 }
@@ -6443,6 +7030,8 @@ static int nl80211_testmode_dump(struct sk_buff *skb,
  void *data = NULL;
  int data_len = 0;
 
+ rtnl_lock();
+
  if (cb->args[0]) {
   /*
    * 0 is a valid index, but not valid for args[0],
@@ -6454,18 +7043,16 @@ static int nl80211_testmode_dump(struct sk_buff *skb,
       nl80211_fam.attrbuf, nl80211_fam.maxattr,
       nl80211_policy);
   if (err)
-   return err;
+   goto out_err;
 
-  mutex_lock(&cfg80211_mutex);
   rdev = __cfg80211_rdev_from_attrs(sock_net(skb->sk),
         nl80211_fam.attrbuf);
   if (IS_ERR(rdev)) {
-   mutex_unlock(&cfg80211_mutex);
-   return PTR_ERR(rdev);
+   err = PTR_ERR(rdev);
+   goto out_err;
   }
   phy_idx = rdev->wiphy_idx;
   rdev = NULL;
-  mutex_unlock(&cfg80211_mutex);
 
   if (nl80211_fam.attrbuf[NL80211_ATTR_TESTDATA])
    cb->args[1] =
@@ -6477,14 +7064,11 @@ static int nl80211_testmode_dump(struct sk_buff *skb,
   data_len = nla_len((void *)cb->args[1]);
  }
 
- mutex_lock(&cfg80211_mutex);
  rdev = cfg80211_rdev_by_wiphy_idx(phy_idx);
  if (!rdev) {
-  mutex_unlock(&cfg80211_mutex);
-  return -ENOENT;
+  err = -ENOENT;
+  goto out_err;
  }
- cfg80211_lock_rdev(rdev);
- mutex_unlock(&cfg80211_mutex);
 
  if (!rdev->ops->testmode_dump) {
   err = -EOPNOTSUPP;
@@ -6497,6 +7081,9 @@ static int nl80211_testmode_dump(struct sk_buff *skb,
         NL80211_CMD_TESTMODE);
   struct nlattr *tmdata;
 
+  if (!hdr)
+   break;
+
   if (nla_put_u32(skb, NL80211_ATTR_WIPHY, phy_idx)) {
    genlmsg_cancel(skb, hdr);
    break;
@@ -6525,96 +7112,9 @@ static int nl80211_testmode_dump(struct sk_buff *skb,
  /* see above */
  cb->args[0] = phy_idx + 1;
  out_err:
- cfg80211_unlock_rdev(rdev);
+ rtnl_unlock();
  return err;
 }
-
-static struct sk_buff *
-__cfg80211_testmode_alloc_skb(struct cfg80211_registered_device *rdev,
-         int approxlen, u32 portid, u32 seq, gfp_t gfp)
-{
- struct sk_buff *skb;
- void *hdr;
- struct nlattr *data;
-
- skb = nlmsg_new(approxlen + 100, gfp);
- if (!skb)
-  return NULL;
-
- hdr = nl80211hdr_put(skb, portid, seq, 0, NL80211_CMD_TESTMODE);
- if (!hdr) {
-  kfree_skb(skb);
-  return NULL;
- }
-
- if (nla_put_u32(skb, NL80211_ATTR_WIPHY, rdev->wiphy_idx))
-  goto nla_put_failure;
- data = nla_nest_start(skb, NL80211_ATTR_TESTDATA);
-
- ((void **)skb->cb)[0] = rdev;
- ((void **)skb->cb)[1] = hdr;
- ((void **)skb->cb)[2] = data;
-
- return skb;
-
- nla_put_failure:
- kfree_skb(skb);
- return NULL;
-}
-
-struct sk_buff *cfg80211_testmode_alloc_reply_skb(struct wiphy *wiphy,
-        int approxlen)
-{
- struct cfg80211_registered_device *rdev = wiphy_to_dev(wiphy);
-
- if (WARN_ON(!rdev->testmode_info))
-  return NULL;
-
- return __cfg80211_testmode_alloc_skb(rdev, approxlen,
-    rdev->testmode_info->snd_portid,
-    rdev->testmode_info->snd_seq,
-    GFP_KERNEL);
-}
-EXPORT_SYMBOL(cfg80211_testmode_alloc_reply_skb);
-
-int cfg80211_testmode_reply(struct sk_buff *skb)
-{
- struct cfg80211_registered_device *rdev = ((void **)skb->cb)[0];
- void *hdr = ((void **)skb->cb)[1];
- struct nlattr *data = ((void **)skb->cb)[2];
-
- if (WARN_ON(!rdev->testmode_info)) {
-  kfree_skb(skb);
-  return -EINVAL;
- }
-
- nla_nest_end(skb, data);
- genlmsg_end(skb, hdr);
- return genlmsg_reply(skb, rdev->testmode_info);
-}
-EXPORT_SYMBOL(cfg80211_testmode_reply);
-
-struct sk_buff *cfg80211_testmode_alloc_event_skb(struct wiphy *wiphy,
-        int approxlen, gfp_t gfp)
-{
- struct cfg80211_registered_device *rdev = wiphy_to_dev(wiphy);
-
- return __cfg80211_testmode_alloc_skb(rdev, approxlen, 0, 0, gfp);
-}
-EXPORT_SYMBOL(cfg80211_testmode_alloc_event_skb);
-
-void cfg80211_testmode_event(struct sk_buff *skb, gfp_t gfp)
-{
- struct cfg80211_registered_device *rdev = ((void **)skb->cb)[0];
- void *hdr = ((void **)skb->cb)[1];
- struct nlattr *data = ((void **)skb->cb)[2];
-
- nla_nest_end(skb, data);
- genlmsg_end(skb, hdr);
- genlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), skb, 0,
-    NL80211_MCGRP_TESTMODE, gfp);
-}
-EXPORT_SYMBOL(cfg80211_testmode_event);
 #endif
 
 static int nl80211_connect(struct sk_buff *skb, struct genl_info *info)
@@ -6666,6 +7166,9 @@ static int nl80211_connect(struct sk_buff *skb, struct genl_info *info)
 
  if (info->attrs[NL80211_ATTR_MAC])
   connect.bssid = nla_data(info->attrs[NL80211_ATTR_MAC]);
+ else if (info->attrs[NL80211_ATTR_MAC_HINT])
+  connect.bssid_hint =
+   nla_data(info->attrs[NL80211_ATTR_MAC_HINT]);
  connect.ssid = nla_data(info->attrs[NL80211_ATTR_SSID]);
  connect.ssid_len = nla_len(info->attrs[NL80211_ATTR_SSID]);
 
@@ -6684,11 +7187,14 @@ static int nl80211_connect(struct sk_buff *skb, struct genl_info *info)
  }
 
  if (info->attrs[NL80211_ATTR_WIPHY_FREQ]) {
-  connect.channel =
-   ieee80211_get_channel(wiphy,
-       nla_get_u32(info->attrs[NL80211_ATTR_WIPHY_FREQ]));
-  if (!connect.channel ||
-      connect.channel->flags & IEEE80211_CHAN_DISABLED)
+  connect.channel = nl80211_get_valid_chan(
+   wiphy, info->attrs[NL80211_ATTR_WIPHY_FREQ]);
+  if (!connect.channel)
+   return -EINVAL;
+ } else if (info->attrs[NL80211_ATTR_WIPHY_FREQ_HINT]) {
+  connect.channel_hint = nl80211_get_valid_chan(
+   wiphy, info->attrs[NL80211_ATTR_WIPHY_FREQ_HINT]);
+  if (!connect.channel_hint)
    return -EINVAL;
  }
 
@@ -6735,7 +7241,9 @@ static int nl80211_connect(struct sk_buff *skb, struct genl_info *info)
          sizeof(connect.vht_capa));
  }
 
- err = cfg80211_connect(rdev, dev, &connect, connkeys);
+ wdev_lock(dev->ieee80211_ptr);
+ err = cfg80211_connect(rdev, dev, &connect, connkeys, NULL);
+ wdev_unlock(dev->ieee80211_ptr);
  if (err)
   kfree(connkeys);
  return err;
@@ -6746,6 +7254,7 @@ static int nl80211_disconnect(struct sk_buff *skb, struct genl_info *info)
  struct cfg80211_registered_device *rdev = info->user_ptr[0];
  struct net_device *dev = info->user_ptr[1];
  u16 reason;
+ int ret;
 
  if (!info->attrs[NL80211_ATTR_REASON_CODE])
   reason = WLAN_REASON_DEAUTH_LEAVING;
@@ -6759,7 +7268,10 @@ static int nl80211_disconnect(struct sk_buff *skb, struct genl_info *info)
      dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_CLIENT)
   return -EOPNOTSUPP;
 
- return cfg80211_disconnect(rdev, dev, reason, true);
+ wdev_lock(dev->ieee80211_ptr);
+ ret = cfg80211_disconnect(rdev, dev, reason, true);
+ wdev_unlock(dev->ieee80211_ptr);
+ return ret;
 }
 
 static int nl80211_wiphy_netns(struct sk_buff *skb, struct genl_info *info)
@@ -6849,6 +7361,7 @@ static int nl80211_tdls_mgmt(struct sk_buff *skb, struct genl_info *info)
  struct cfg80211_registered_device *rdev = info->user_ptr[0];
  struct net_device *dev = info->user_ptr[1];
  u8 action_code, dialog_token;
+ u32 peer_capability = 0;
  u16 status_code;
  u8 *peer;
 
@@ -6867,9 +7380,12 @@ static int nl80211_tdls_mgmt(struct sk_buff *skb, struct genl_info *info)
  action_code = nla_get_u8(info->attrs[NL80211_ATTR_TDLS_ACTION]);
  status_code = nla_get_u16(info->attrs[NL80211_ATTR_STATUS_CODE]);
  dialog_token = nla_get_u8(info->attrs[NL80211_ATTR_TDLS_DIALOG_TOKEN]);
+ if (info->attrs[NL80211_ATTR_TDLS_PEER_CAPABILITY])
+  peer_capability =
+   nla_get_u32(info->attrs[NL80211_ATTR_TDLS_PEER_CAPABILITY]);
 
  return rdev_tdls_mgmt(rdev, dev, peer, action_code,
-         dialog_token, status_code,
+         dialog_token, status_code, peer_capability,
          nla_data(info->attrs[NL80211_ATTR_IE]),
          nla_len(info->attrs[NL80211_ATTR_IE]));
 }
@@ -6935,9 +7451,8 @@ static int nl80211_remain_on_channel(struct sk_buff *skb,
 
  hdr = nl80211hdr_put(msg, info->snd_portid, info->snd_seq, 0,
         NL80211_CMD_REMAIN_ON_CHANNEL);
-
- if (IS_ERR(hdr)) {
-  err = PTR_ERR(hdr);
+ if (!hdr) {
+  err = -ENOBUFS;
   goto free_msg;
  }
 
@@ -7031,11 +7546,73 @@ static bool ht_rateset_to_mask(struct ieee80211_supported_band *sband,
  return true;
 }
 
+static u16 vht_mcs_map_to_mcs_mask(u8 vht_mcs_map)
+{
+ u16 mcs_mask = 0;
+
+ switch (vht_mcs_map) {
+ case IEEE80211_VHT_MCS_NOT_SUPPORTED:
+  break;
+ case IEEE80211_VHT_MCS_SUPPORT_0_7:
+  mcs_mask = 0x00FF;
+  break;
+ case IEEE80211_VHT_MCS_SUPPORT_0_8:
+  mcs_mask = 0x01FF;
+  break;
+ case IEEE80211_VHT_MCS_SUPPORT_0_9:
+  mcs_mask = 0x03FF;
+  break;
+ default:
+  break;
+ }
+
+ return mcs_mask;
+}
+
+static void vht_build_mcs_mask(u16 vht_mcs_map,
+          u16 vht_mcs_mask[NL80211_VHT_NSS_MAX])
+{
+ u8 nss;
+
+ for (nss = 0; nss < NL80211_VHT_NSS_MAX; nss++) {
+  vht_mcs_mask[nss] = vht_mcs_map_to_mcs_mask(vht_mcs_map & 0x03);
+  vht_mcs_map >>= 2;
+ }
+}
+
+static bool vht_set_mcs_mask(struct ieee80211_supported_band *sband,
+        struct nl80211_txrate_vht *txrate,
+        u16 mcs[NL80211_VHT_NSS_MAX])
+{
+ u16 tx_mcs_map = le16_to_cpu(sband->vht_cap.vht_mcs.tx_mcs_map);
+ u16 tx_mcs_mask[NL80211_VHT_NSS_MAX] = {};
+ u8 i;
+
+ if (!sband->vht_cap.vht_supported)
+  return false;
+
+ memset(mcs, 0, sizeof(u16) * NL80211_VHT_NSS_MAX);
+
+ /* Build vht_mcs_mask from VHT capabilities */
+ vht_build_mcs_mask(tx_mcs_map, tx_mcs_mask);
+
+ for (i = 0; i < NL80211_VHT_NSS_MAX; i++) {
+  if ((tx_mcs_mask[i] & txrate->mcs[i]) == txrate->mcs[i])
+   mcs[i] = txrate->mcs[i];
+  else
+   return false;
+ }
+
+ return true;
+}
+
 static const struct nla_policy nl80211_txattr_policy[NL80211_TXRATE_MAX + 1] = {
  [NL80211_TXRATE_LEGACY] = { .type = NLA_BINARY,
         .len = NL80211_MAX_SUPP_RATES },
- [NL80211_TXRATE_MCS] = { .type = NLA_BINARY,
-     .len = NL80211_MAX_SUPP_HT_RATES },
+ [NL80211_TXRATE_HT] = { .type = NLA_BINARY,
+    .len = NL80211_MAX_SUPP_HT_RATES },
+ [NL80211_TXRATE_VHT] = { .len = sizeof(struct nl80211_txrate_vht)},
+ [NL80211_TXRATE_GI] = { .type = NLA_U8 },
 };
 
 static int nl80211_set_tx_bitrate_mask(struct sk_buff *skb,
@@ -7048,9 +7625,7 @@ static int nl80211_set_tx_bitrate_mask(struct sk_buff *skb,
  struct net_device *dev = info->user_ptr[1];
  struct nlattr *tx_rates;
  struct ieee80211_supported_band *sband;
-
- if (info->attrs[NL80211_ATTR_TX_RATES] == NULL)
-  return -EINVAL;
+ u16 vht_tx_mcs_map;
 
  if (!rdev->ops->set_bitrate_mask)
   return -EOPNOTSUPP;
@@ -7059,32 +7634,44 @@ static int nl80211_set_tx_bitrate_mask(struct sk_buff *skb,
  /* Default to all rates enabled */
  for (i = 0; i < IEEE80211_NUM_BANDS; i++) {
   sband = rdev->wiphy.bands[i];
-  mask.control[i].legacy =
-   sband ? (1 << sband->n_bitrates) - 1 : 0;
-  if (sband)
-   memcpy(mask.control[i].mcs,
-          sband->ht_cap.mcs.rx_mask,
-          sizeof(mask.control[i].mcs));
-  else
-   memset(mask.control[i].mcs, 0,
-          sizeof(mask.control[i].mcs));
+
+  if (!sband)
+   continue;
+
+  mask.control[i].legacy = (1 << sband->n_bitrates) - 1;
+  memcpy(mask.control[i].ht_mcs,
+         sband->ht_cap.mcs.rx_mask,
+         sizeof(mask.control[i].ht_mcs));
+
+  if (!sband->vht_cap.vht_supported)
+   continue;
+
+  vht_tx_mcs_map = le16_to_cpu(sband->vht_cap.vht_mcs.tx_mcs_map);
+  vht_build_mcs_mask(vht_tx_mcs_map, mask.control[i].vht_mcs);
  }
 
+ /* if no rates are given set it back to the defaults */
+ if (!info->attrs[NL80211_ATTR_TX_RATES])
+  goto out;
+
  /*
   * The nested attribute uses enum nl80211_band as the index. This maps
   * directly to the enum ieee80211_band values used in cfg80211.
   */
  BUILD_BUG_ON(NL80211_MAX_SUPP_HT_RATES > IEEE80211_HT_MCS_MASK_LEN * 8);
- nla_for_each_nested(tx_rates, info->attrs[NL80211_ATTR_TX_RATES], rem)
- {
+ nla_for_each_nested(tx_rates, info->attrs[NL80211_ATTR_TX_RATES], rem) {
   enum ieee80211_band band = nla_type(tx_rates);
+  int err;
+
   if (band < 0 || band >= IEEE80211_NUM_BANDS)
    return -EINVAL;
   sband = rdev->wiphy.bands[band];
   if (sband == NULL)
    return -EINVAL;
-  nla_parse(tb, NL80211_TXRATE_MAX, nla_data(tx_rates),
-     nla_len(tx_rates), nl80211_txattr_policy);
+  err = nla_parse(tb, NL80211_TXRATE_MAX, nla_data(tx_rates),
+    nla_len(tx_rates), nl80211_txattr_policy);
+  if (err)
+   return err;
   if (tb[NL80211_TXRATE_LEGACY]) {
    mask.control[band].legacy = rateset_to_mask(
     sband,
@@ -7094,31 +7681,50 @@ static int nl80211_set_tx_bitrate_mask(struct sk_buff *skb,
        nla_len(tb[NL80211_TXRATE_LEGACY]))
     return -EINVAL;
   }
-  if (tb[NL80211_TXRATE_MCS]) {
+  if (tb[NL80211_TXRATE_HT]) {
    if (!ht_rateset_to_mask(
      sband,
-     nla_data(tb[NL80211_TXRATE_MCS]),
-     nla_len(tb[NL80211_TXRATE_MCS]),
-     mask.control[band].mcs))
+     nla_data(tb[NL80211_TXRATE_HT]),
+     nla_len(tb[NL80211_TXRATE_HT]),
+     mask.control[band].ht_mcs))
+    return -EINVAL;
+  }
+  if (tb[NL80211_TXRATE_VHT]) {
+   if (!vht_set_mcs_mask(
+     sband,
+     nla_data(tb[NL80211_TXRATE_VHT]),
+     mask.control[band].vht_mcs))
+    return -EINVAL;
+  }
+  if (tb[NL80211_TXRATE_GI]) {
+   mask.control[band].gi =
+    nla_get_u8(tb[NL80211_TXRATE_GI]);
+   if (mask.control[band].gi > NL80211_TXRATE_FORCE_LGI)
     return -EINVAL;
   }
 
   if (mask.control[band].legacy == 0) {
-   /* don't allow empty legacy rates if HT
-    * is not even supported. */
-   if (!rdev->wiphy.bands[band]->ht_cap.ht_supported)
+   /* don't allow empty legacy rates if HT or VHT
+    * are not even supported.
+    */
+   if (!(rdev->wiphy.bands[band]->ht_cap.ht_supported ||
+         rdev->wiphy.bands[band]->vht_cap.vht_supported))
     return -EINVAL;
 
    for (i = 0; i < IEEE80211_HT_MCS_MASK_LEN; i++)
-    if (mask.control[band].mcs[i])
-     break;
+    if (mask.control[band].ht_mcs[i])
+     goto out;
+
+   for (i = 0; i < NL80211_VHT_NSS_MAX; i++)
+    if (mask.control[band].vht_mcs[i])
+     goto out;
 
    /* legacy and mcs rates may not be both empty */
-   if (i == IEEE80211_HT_MCS_MASK_LEN)
-    return -EINVAL;
+   return -EINVAL;
   }
  }
 
+out:
  return rdev_set_bitrate_mask(rdev, dev, NULL, &mask);
 }
 
@@ -7166,10 +7772,10 @@ static int nl80211_tx_mgmt(struct sk_buff *skb, struct genl_info *info)
  void *hdr = NULL;
  u64 cookie;
  struct sk_buff *msg = NULL;
- unsigned int wait = 0;
- bool offchan, no_cck, dont_wait_for_ack;
-
- dont_wait_for_ack = info->attrs[NL80211_ATTR_DONT_WAIT_FOR_ACK];
+ struct cfg80211_mgmt_tx_params params = {
+  .dont_wait_for_ack =
+   info->attrs[NL80211_ATTR_DONT_WAIT_FOR_ACK],
+ };
 
  if (!info->attrs[NL80211_ATTR_FRAME])
   return -EINVAL;
@@ -7178,6 +7784,9 @@ static int nl80211_tx_mgmt(struct sk_buff *skb, struct genl_info *info)
   return -EOPNOTSUPP;
 
  switch (wdev->iftype) {
+ case NL80211_IFTYPE_P2P_DEVICE:
+  if (!info->attrs[NL80211_ATTR_WIPHY_FREQ])
+   return -EINVAL;
  case NL80211_IFTYPE_STATION:
  case NL80211_IFTYPE_ADHOC:
  case NL80211_IFTYPE_P2P_CLIENT:
@@ -7185,7 +7794,6 @@ static int nl80211_tx_mgmt(struct sk_buff *skb, struct genl_info *info)
  case NL80211_IFTYPE_AP_VLAN:
  case NL80211_IFTYPE_MESH_POINT:
  case NL80211_IFTYPE_P2P_GO:
- case NL80211_IFTYPE_P2P_DEVICE:
   break;
  default:
   return -EOPNOTSUPP;
@@ -7194,47 +7802,74 @@ static int nl80211_tx_mgmt(struct sk_buff *skb, struct genl_info *info)
  if (info->attrs[NL80211_ATTR_DURATION]) {
   if (!(rdev->wiphy.flags & WIPHY_FLAG_OFFCHAN_TX))
    return -EINVAL;
-  wait = nla_get_u32(info->attrs[NL80211_ATTR_DURATION]);
+  params.wait = nla_get_u32(info->attrs[NL80211_ATTR_DURATION]);
 
   /*
    * We should wait on the channel for at least a minimum amount
    * of time (10ms) but no longer than the driver supports.
    */
-  if (wait < NL80211_MIN_REMAIN_ON_CHANNEL_TIME ||
-      wait > rdev->wiphy.max_remain_on_channel_duration)
+  if (params.wait < NL80211_MIN_REMAIN_ON_CHANNEL_TIME ||
+      params.wait > rdev->wiphy.max_remain_on_channel_duration)
    return -EINVAL;
 
  }
 
- offchan = info->attrs[NL80211_ATTR_OFFCHANNEL_TX_OK];
+ params.offchan = info->attrs[NL80211_ATTR_OFFCHANNEL_TX_OK];
 
- if (offchan && !(rdev->wiphy.flags & WIPHY_FLAG_OFFCHAN_TX))
+ if (params.offchan && !(rdev->wiphy.flags & WIPHY_FLAG_OFFCHAN_TX))
   return -EINVAL;
 
- no_cck = nla_get_flag(info->attrs[NL80211_ATTR_TX_NO_CCK_RATE]);
+ params.no_cck = nla_get_flag(info->attrs[NL80211_ATTR_TX_NO_CCK_RATE]);
 
- err = nl80211_parse_chandef(rdev, info, &chandef);
- if (err)
-  return err;
+ /* get the channel if any has been specified, otherwise pass NULL to
+  * the driver. The latter will use the current one
+  */
+ chandef.chan = NULL;
+ if (info->attrs[NL80211_ATTR_WIPHY_FREQ]) {
+  err = nl80211_parse_chandef(rdev, info, &chandef);
+  if (err)
+   return err;
+ }
+
+ if (!chandef.chan && params.offchan)
+  return -EINVAL;
+
+ params.buf = nla_data(info->attrs[NL80211_ATTR_FRAME]);
+ params.len = nla_len(info->attrs[NL80211_ATTR_FRAME]);
+
+ if (info->attrs[NL80211_ATTR_CSA_C_OFFSETS_TX]) {
+  int len = nla_len(info->attrs[NL80211_ATTR_CSA_C_OFFSETS_TX]);
+  int i;
+
+  if (len % sizeof(u16))
+   return -EINVAL;
+
+  params.n_csa_offsets = len / sizeof(u16);
+  params.csa_offsets =
+   nla_data(info->attrs[NL80211_ATTR_CSA_C_OFFSETS_TX]);
 
- if (!dont_wait_for_ack) {
+  /* check that all the offsets fit the frame */
+  for (i = 0; i < params.n_csa_offsets; i++) {
+   if (params.csa_offsets[i] >= params.len)
+    return -EINVAL;
+  }
+ }
+
+ if (!params.dont_wait_for_ack) {
   msg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);
   if (!msg)
    return -ENOMEM;
 
   hdr = nl80211hdr_put(msg, info->snd_portid, info->snd_seq, 0,
          NL80211_CMD_FRAME);
-
-  if (IS_ERR(hdr)) {
-   err = PTR_ERR(hdr);
+  if (!hdr) {
+   err = -ENOBUFS;
    goto free_msg;
   }
  }
 
- err = cfg80211_mlme_mgmt_tx(rdev, wdev, chandef.chan, offchan, wait,
-        nla_data(info->attrs[NL80211_ATTR_FRAME]),
-        nla_len(info->attrs[NL80211_ATTR_FRAME]),
-        no_cck, dont_wait_for_ack, &cookie);
+ params.chan = chandef.chan;
+ err = cfg80211_mlme_mgmt_tx(rdev, wdev, &params, &cookie);
  if (err)
   goto free_msg;
 
@@ -7362,8 +7997,8 @@ static int nl80211_get_power_save(struct sk_buff *skb, struct genl_info *info)
  return err;
 }
 
-static struct nla_policy
-nl80211_attr_cqm_policy[NL80211_ATTR_CQM_MAX + 1] __read_mostly = {
+static const struct nla_policy
+nl80211_attr_cqm_policy[NL80211_ATTR_CQM_MAX + 1] = {
  [NL80211_ATTR_CQM_RSSI_THOLD] = { .type = NLA_U32 },
  [NL80211_ATTR_CQM_RSSI_HYST] = { .type = NLA_U32 },
  [NL80211_ATTR_CQM_RSSI_THRESHOLD_EVENT] = { .type = NLA_U32 },
@@ -7376,14 +8011,12 @@ static int nl80211_set_cqm_txe(struct genl_info *info,
           u32 rate, u32 pkts, u32 intvl)
 {
  struct cfg80211_registered_device *rdev = info->user_ptr[0];
- struct wireless_dev *wdev;
  struct net_device *dev = info->user_ptr[1];
+ struct wireless_dev *wdev = dev->ieee80211_ptr;
 
  if (rate > 100 || intvl > NL80211_CQM_TXE_MAX_INTVL)
   return -EINVAL;
 
- wdev = dev->ieee80211_ptr;
-
  if (!rdev->ops->set_cqm_txe_config)
   return -EOPNOTSUPP;
 
@@ -7398,13 +8031,15 @@ static int nl80211_set_cqm_rssi(struct genl_info *info,
     s32 threshold, u32 hysteresis)
 {
  struct cfg80211_registered_device *rdev = info->user_ptr[0];
- struct wireless_dev *wdev;
  struct net_device *dev = info->user_ptr[1];
+ struct wireless_dev *wdev = dev->ieee80211_ptr;
 
  if (threshold > 0)
   return -EINVAL;
 
- wdev = dev->ieee80211_ptr;
+ /* disabling - hysteresis should also be zero then */
+ if (threshold == 0)
+  hysteresis = 0;
 
  if (!rdev->ops->set_cqm_rssi_config)
   return -EOPNOTSUPP;
@@ -7423,36 +8058,33 @@ static int nl80211_set_cqm(struct sk_buff *skb, struct genl_info *info)
  int err;
 
  cqm = info->attrs[NL80211_ATTR_CQM];
- if (!cqm) {
-  err = -EINVAL;
-  goto out;
- }
+ if (!cqm)
+  return -EINVAL;
 
  err = nla_parse_nested(attrs, NL80211_ATTR_CQM_MAX, cqm,
           nl80211_attr_cqm_policy);
  if (err)
-  goto out;
+  return err;
 
  if (attrs[NL80211_ATTR_CQM_RSSI_THOLD] &&
      attrs[NL80211_ATTR_CQM_RSSI_HYST]) {
-  s32 threshold;
-  u32 hysteresis;
-  threshold = nla_get_u32(attrs[NL80211_ATTR_CQM_RSSI_THOLD]);
-  hysteresis = nla_get_u32(attrs[NL80211_ATTR_CQM_RSSI_HYST]);
-  err = nl80211_set_cqm_rssi(info, threshold, hysteresis);
- } else if (attrs[NL80211_ATTR_CQM_TXE_RATE] &&
-     attrs[NL80211_ATTR_CQM_TXE_PKTS] &&
-     attrs[NL80211_ATTR_CQM_TXE_INTVL]) {
-  u32 rate, pkts, intvl;
-  rate = nla_get_u32(attrs[NL80211_ATTR_CQM_TXE_RATE]);
-  pkts = nla_get_u32(attrs[NL80211_ATTR_CQM_TXE_PKTS]);
-  intvl = nla_get_u32(attrs[NL80211_ATTR_CQM_TXE_INTVL]);
-  err = nl80211_set_cqm_txe(info, rate, pkts, intvl);
- } else
-  err = -EINVAL;
+  s32 threshold = nla_get_s32(attrs[NL80211_ATTR_CQM_RSSI_THOLD]);
+  u32 hysteresis = nla_get_u32(attrs[NL80211_ATTR_CQM_RSSI_HYST]);
 
-out:
- return err;
+  return nl80211_set_cqm_rssi(info, threshold, hysteresis);
+ }
+
+ if (attrs[NL80211_ATTR_CQM_TXE_RATE] &&
+     attrs[NL80211_ATTR_CQM_TXE_PKTS] &&
+     attrs[NL80211_ATTR_CQM_TXE_INTVL]) {
+  u32 rate = nla_get_u32(attrs[NL80211_ATTR_CQM_TXE_RATE]);
+  u32 pkts = nla_get_u32(attrs[NL80211_ATTR_CQM_TXE_PKTS]);
+  u32 intvl = nla_get_u32(attrs[NL80211_ATTR_CQM_TXE_INTVL]);
+
+  return nl80211_set_cqm_txe(info, rate, pkts, intvl);
+ }
+
+ return -EINVAL;
 }
 
 static int nl80211_join_mesh(struct sk_buff *skb, struct genl_info *info)
@@ -7520,6 +8152,23 @@ static int nl80211_join_mesh(struct sk_buff *skb, struct genl_info *info)
   setup.chandef.chan = NULL;
  }
 
+ if (info->attrs[NL80211_ATTR_BSS_BASIC_RATES]) {
+  u8 *rates = nla_data(info->attrs[NL80211_ATTR_BSS_BASIC_RATES]);
+  int n_rates =
+   nla_len(info->attrs[NL80211_ATTR_BSS_BASIC_RATES]);
+  struct ieee80211_supported_band *sband;
+
+  if (!setup.chandef.chan)
+   return -EINVAL;
+
+  sband = rdev->wiphy.bands[setup.chandef.chan->band];
+
+  err = ieee80211_get_ratemask(sband, rates, n_rates,
+          &setup.basic_rates);
+  if (err)
+   return err;
+ }
+
  return cfg80211_join_mesh(rdev, dev, &setup, &cfg);
 }
 
@@ -7535,28 +8184,28 @@ static int nl80211_leave_mesh(struct sk_buff *skb, struct genl_info *info)
 static int nl80211_send_wowlan_patterns(struct sk_buff *msg,
      struct cfg80211_registered_device *rdev)
 {
+ struct cfg80211_wowlan *wowlan = rdev->wiphy.wowlan_config;
  struct nlattr *nl_pats, *nl_pat;
  int i, pat_len;
 
- if (!rdev->wowlan->n_patterns)
+ if (!wowlan->n_patterns)
   return 0;
 
  nl_pats = nla_nest_start(msg, NL80211_WOWLAN_TRIG_PKT_PATTERN);
  if (!nl_pats)
   return -ENOBUFS;
 
- for (i = 0; i < rdev->wowlan->n_patterns; i++) {
+ for (i = 0; i < wowlan->n_patterns; i++) {
   nl_pat = nla_nest_start(msg, i + 1);
   if (!nl_pat)
    return -ENOBUFS;
-  pat_len = rdev->wowlan->patterns[i].pattern_len;
-  if (nla_put(msg, NL80211_WOWLAN_PKTPAT_MASK,
-       DIV_ROUND_UP(pat_len, 8),
-       rdev->wowlan->patterns[i].mask) ||
-      nla_put(msg, NL80211_WOWLAN_PKTPAT_PATTERN,
-       pat_len, rdev->wowlan->patterns[i].pattern) ||
-      nla_put_u32(msg, NL80211_WOWLAN_PKTPAT_OFFSET,
-    rdev->wowlan->patterns[i].pkt_offset))
+  pat_len = wowlan->patterns[i].pattern_len;
+  if (nla_put(msg, NL80211_PKTPAT_MASK, DIV_ROUND_UP(pat_len, 8),
+       wowlan->patterns[i].mask) ||
+      nla_put(msg, NL80211_PKTPAT_PATTERN, pat_len,
+       wowlan->patterns[i].pattern) ||
+      nla_put_u32(msg, NL80211_PKTPAT_OFFSET,
+    wowlan->patterns[i].pkt_offset))
    return -ENOBUFS;
   nla_nest_end(msg, nl_pat);
  }
@@ -7615,16 +8264,15 @@ static int nl80211_get_wowlan(struct sk_buff *skb, struct genl_info *info)
  void *hdr;
  u32 size = NLMSG_DEFAULT_SIZE;
 
- if (!rdev->wiphy.wowlan.flags && !rdev->wiphy.wowlan.n_patterns &&
-     !rdev->wiphy.wowlan.tcp)
+ if (!rdev->wiphy.wowlan)
   return -EOPNOTSUPP;
 
- if (rdev->wowlan && rdev->wowlan->tcp) {
+ if (rdev->wiphy.wowlan_config && rdev->wiphy.wowlan_config->tcp) {
   /* adjust size to have room for all the data */
-  size += rdev->wowlan->tcp->tokens_size +
-   rdev->wowlan->tcp->payload_len +
-   rdev->wowlan->tcp->wake_len +
-   rdev->wowlan->tcp->wake_len / 8;
+  size += rdev->wiphy.wowlan_config->tcp->tokens_size +
+   rdev->wiphy.wowlan_config->tcp->payload_len +
+   rdev->wiphy.wowlan_config->tcp->wake_len +
+   rdev->wiphy.wowlan_config->tcp->wake_len / 8;
  }
 
  msg = nlmsg_new(size, GFP_KERNEL);
@@ -7636,33 +8284,34 @@ static int nl80211_get_wowlan(struct sk_buff *skb, struct genl_info *info)
  if (!hdr)
   goto nla_put_failure;
 
- if (rdev->wowlan) {
+ if (rdev->wiphy.wowlan_config) {
   struct nlattr *nl_wowlan;
 
   nl_wowlan = nla_nest_start(msg, NL80211_ATTR_WOWLAN_TRIGGERS);
   if (!nl_wowlan)
    goto nla_put_failure;
 
-  if ((rdev->wowlan->any &&
+  if ((rdev->wiphy.wowlan_config->any &&
        nla_put_flag(msg, NL80211_WOWLAN_TRIG_ANY)) ||
-      (rdev->wowlan->disconnect &&
+      (rdev->wiphy.wowlan_config->disconnect &&
        nla_put_flag(msg, NL80211_WOWLAN_TRIG_DISCONNECT)) ||
-      (rdev->wowlan->magic_pkt &&
+      (rdev->wiphy.wowlan_config->magic_pkt &&
        nla_put_flag(msg, NL80211_WOWLAN_TRIG_MAGIC_PKT)) ||
-      (rdev->wowlan->gtk_rekey_failure &&
+      (rdev->wiphy.wowlan_config->gtk_rekey_failure &&
        nla_put_flag(msg, NL80211_WOWLAN_TRIG_GTK_REKEY_FAILURE)) ||
-      (rdev->wowlan->eap_identity_req &&
+      (rdev->wiphy.wowlan_config->eap_identity_req &&
        nla_put_flag(msg, NL80211_WOWLAN_TRIG_EAP_IDENT_REQUEST)) ||
-      (rdev->wowlan->four_way_handshake &&
+      (rdev->wiphy.wowlan_config->four_way_handshake &&
        nla_put_flag(msg, NL80211_WOWLAN_TRIG_4WAY_HANDSHAKE)) ||
-      (rdev->wowlan->rfkill_release &&
+      (rdev->wiphy.wowlan_config->rfkill_release &&
        nla_put_flag(msg, NL80211_WOWLAN_TRIG_RFKILL_RELEASE)))
    goto nla_put_failure;
 
   if (nl80211_send_wowlan_patterns(msg, rdev))
    goto nla_put_failure;
 
-  if (nl80211_send_wowlan_tcp(msg, rdev->wowlan->tcp))
+  if (nl80211_send_wowlan_tcp(msg,
+         rdev->wiphy.wowlan_config->tcp))
    goto nla_put_failure;
 
   nla_nest_end(msg, nl_wowlan);
@@ -7688,7 +8337,7 @@ static int nl80211_parse_wowlan_tcp(struct cfg80211_registered_device *rdev,
  u32 data_size, wake_size, tokens_size = 0, wake_mask_size;
  int err, port;
 
- if (!rdev->wiphy.wowlan.tcp)
+ if (!rdev->wiphy.wowlan->tcp)
   return -EINVAL;
 
  err = nla_parse(tb, MAX_NL80211_WOWLAN_TCP,
@@ -7708,16 +8357,16 @@ static int nl80211_parse_wowlan_tcp(struct cfg80211_registered_device *rdev,
   return -EINVAL;
 
  data_size = nla_len(tb[NL80211_WOWLAN_TCP_DATA_PAYLOAD]);
- if (data_size > rdev->wiphy.wowlan.tcp->data_payload_max)
+ if (data_size > rdev->wiphy.wowlan->tcp->data_payload_max)
   return -EINVAL;
 
  if (nla_get_u32(tb[NL80211_WOWLAN_TCP_DATA_INTERVAL]) >
-   rdev->wiphy.wowlan.tcp->data_interval_max ||
+   rdev->wiphy.wowlan->tcp->data_interval_max ||
      nla_get_u32(tb[NL80211_WOWLAN_TCP_DATA_INTERVAL]) == 0)
   return -EINVAL;
 
  wake_size = nla_len(tb[NL80211_WOWLAN_TCP_WAKE_PAYLOAD]);
- if (wake_size > rdev->wiphy.wowlan.tcp->wake_payload_max)
+ if (wake_size > rdev->wiphy.wowlan->tcp->wake_payload_max)
   return -EINVAL;
 
  wake_mask_size = nla_len(tb[NL80211_WOWLAN_TCP_WAKE_MASK]);
@@ -7732,13 +8381,13 @@ static int nl80211_parse_wowlan_tcp(struct cfg80211_registered_device *rdev,
 
   if (!tok->len || tokens_size % tok->len)
    return -EINVAL;
-  if (!rdev->wiphy.wowlan.tcp->tok)
+  if (!rdev->wiphy.wowlan->tcp->tok)
    return -EINVAL;
-  if (tok->len > rdev->wiphy.wowlan.tcp->tok->max_len)
+  if (tok->len > rdev->wiphy.wowlan->tcp->tok->max_len)
    return -EINVAL;
-  if (tok->len < rdev->wiphy.wowlan.tcp->tok->min_len)
+  if (tok->len < rdev->wiphy.wowlan->tcp->tok->min_len)
    return -EINVAL;
-  if (tokens_size > rdev->wiphy.wowlan.tcp->tok->bufsize)
+  if (tokens_size > rdev->wiphy.wowlan->tcp->tok->bufsize)
    return -EINVAL;
   if (tok->offset + tok->len > data_size)
    return -EINVAL;
@@ -7746,7 +8395,7 @@ static int nl80211_parse_wowlan_tcp(struct cfg80211_registered_device *rdev,
 
  if (tb[NL80211_WOWLAN_TCP_DATA_PAYLOAD_SEQ]) {
   seq = nla_data(tb[NL80211_WOWLAN_TCP_DATA_PAYLOAD_SEQ]);
-  if (!rdev->wiphy.wowlan.tcp->seq)
+  if (!rdev->wiphy.wowlan->tcp->seq)
    return -EINVAL;
   if (seq->len == 0 || seq->len > 4)
    return -EINVAL;
@@ -7827,17 +8476,16 @@ static int nl80211_set_wowlan(struct sk_buff *skb, struct genl_info *info)
  struct nlattr *tb[NUM_NL80211_WOWLAN_TRIG];
  struct cfg80211_wowlan new_triggers = {};
  struct cfg80211_wowlan *ntrig;
- struct wiphy_wowlan_support *wowlan = &rdev->wiphy.wowlan;
+ const struct wiphy_wowlan_support *wowlan = rdev->wiphy.wowlan;
  int err, i;
- bool prev_enabled = rdev->wowlan;
+ bool prev_enabled = rdev->wiphy.wowlan_config;
 
- if (!rdev->wiphy.wowlan.flags && !rdev->wiphy.wowlan.n_patterns &&
-     !rdev->wiphy.wowlan.tcp)
+ if (!wowlan)
   return -EOPNOTSUPP;
 
  if (!info->attrs[NL80211_ATTR_WOWLAN_TRIGGERS]) {
   cfg80211_rdev_free_wowlan(rdev);
-  rdev->wowlan = NULL;
+  rdev->wiphy.wowlan_config = NULL;
   goto set_wakeup;
  }
 
@@ -7897,7 +8545,7 @@ static int nl80211_set_wowlan(struct sk_buff *skb, struct genl_info *info)
   struct nlattr *pat;
   int n_patterns = 0;
   int rem, pat_len, mask_len, pkt_offset;
-  struct nlattr *pat_tb[NUM_NL80211_WOWLAN_PKTPAT];
+  struct nlattr *pat_tb[NUM_NL80211_PKTPAT];
 
   nla_for_each_nested(pat, tb[NL80211_WOWLAN_TRIG_PKT_PATTERN],
         rem)
@@ -7916,44 +8564,44 @@ static int nl80211_set_wowlan(struct sk_buff *skb, struct genl_info *info)
 
   nla_for_each_nested(pat, tb[NL80211_WOWLAN_TRIG_PKT_PATTERN],
         rem) {
-   nla_parse(pat_tb, MAX_NL80211_WOWLAN_PKTPAT,
-      nla_data(pat), nla_len(pat), NULL);
+   u8 *mask_pat;
+
+   nla_parse(pat_tb, MAX_NL80211_PKTPAT, nla_data(pat),
+      nla_len(pat), NULL);
    err = -EINVAL;
-   if (!pat_tb[NL80211_WOWLAN_PKTPAT_MASK] ||
-       !pat_tb[NL80211_WOWLAN_PKTPAT_PATTERN])
+   if (!pat_tb[NL80211_PKTPAT_MASK] ||
+       !pat_tb[NL80211_PKTPAT_PATTERN])
     goto error;
-   pat_len = nla_len(pat_tb[NL80211_WOWLAN_PKTPAT_PATTERN]);
+   pat_len = nla_len(pat_tb[NL80211_PKTPAT_PATTERN]);
    mask_len = DIV_ROUND_UP(pat_len, 8);
-   if (nla_len(pat_tb[NL80211_WOWLAN_PKTPAT_MASK]) !=
-       mask_len)
+   if (nla_len(pat_tb[NL80211_PKTPAT_MASK]) != mask_len)
     goto error;
    if (pat_len > wowlan->pattern_max_len ||
        pat_len < wowlan->pattern_min_len)
     goto error;
 
-   if (!pat_tb[NL80211_WOWLAN_PKTPAT_OFFSET])
+   if (!pat_tb[NL80211_PKTPAT_OFFSET])
     pkt_offset = 0;
    else
     pkt_offset = nla_get_u32(
-     pat_tb[NL80211_WOWLAN_PKTPAT_OFFSET]);
+     pat_tb[NL80211_PKTPAT_OFFSET]);
    if (pkt_offset > wowlan->max_pkt_offset)
     goto error;
    new_triggers.patterns[i].pkt_offset = pkt_offset;
 
-   new_triggers.patterns[i].mask =
-    kmalloc(mask_len + pat_len, GFP_KERNEL);
-   if (!new_triggers.patterns[i].mask) {
+   mask_pat = kmalloc(mask_len + pat_len, GFP_KERNEL);
+   if (!mask_pat) {
     err = -ENOMEM;
     goto error;
    }
-   new_triggers.patterns[i].pattern =
-    new_triggers.patterns[i].mask + mask_len;
-   memcpy(new_triggers.patterns[i].mask,
-          nla_data(pat_tb[NL80211_WOWLAN_PKTPAT_MASK]),
+   new_triggers.patterns[i].mask = mask_pat;
+   memcpy(mask_pat, nla_data(pat_tb[NL80211_PKTPAT_MASK]),
           mask_len);
+   mask_pat += mask_len;
+   new_triggers.patterns[i].pattern = mask_pat;
    new_triggers.patterns[i].pattern_len = pat_len;
-   memcpy(new_triggers.patterns[i].pattern,
-          nla_data(pat_tb[NL80211_WOWLAN_PKTPAT_PATTERN]),
+   memcpy(mask_pat,
+          nla_data(pat_tb[NL80211_PKTPAT_PATTERN]),
           pat_len);
    i++;
   }
@@ -7973,11 +8621,12 @@ static int nl80211_set_wowlan(struct sk_buff *skb, struct genl_info *info)
   goto error;
  }
  cfg80211_rdev_free_wowlan(rdev);
- rdev->wowlan = ntrig;
+ rdev->wiphy.wowlan_config = ntrig;
 
  set_wakeup:
- if (rdev->ops->set_wakeup && prev_enabled != !!rdev->wowlan)
-  rdev_set_wakeup(rdev, rdev->wowlan);
+ if (rdev->ops->set_wakeup &&
+     prev_enabled != !!rdev->wiphy.wowlan_config)
+  rdev_set_wakeup(rdev, rdev->wiphy.wowlan_config);
 
  return 0;
  error:
@@ -7991,6 +8640,268 @@ static int nl80211_set_wowlan(struct sk_buff *skb, struct genl_info *info)
 }
 #endif
 
+static int nl80211_send_coalesce_rules(struct sk_buff *msg,
+           struct cfg80211_registered_device *rdev)
+{
+ struct nlattr *nl_pats, *nl_pat, *nl_rule, *nl_rules;
+ int i, j, pat_len;
+ struct cfg80211_coalesce_rules *rule;
+
+ if (!rdev->coalesce->n_rules)
+  return 0;
+
+ nl_rules = nla_nest_start(msg, NL80211_ATTR_COALESCE_RULE);
+ if (!nl_rules)
+  return -ENOBUFS;
+
+ for (i = 0; i < rdev->coalesce->n_rules; i++) {
+  nl_rule = nla_nest_start(msg, i + 1);
+  if (!nl_rule)
+   return -ENOBUFS;
+
+  rule = &rdev->coalesce->rules[i];
+  if (nla_put_u32(msg, NL80211_ATTR_COALESCE_RULE_DELAY,
+    rule->delay))
+   return -ENOBUFS;
+
+  if (nla_put_u32(msg, NL80211_ATTR_COALESCE_RULE_CONDITION,
+    rule->condition))
+   return -ENOBUFS;
+
+  nl_pats = nla_nest_start(msg,
+    NL80211_ATTR_COALESCE_RULE_PKT_PATTERN);
+  if (!nl_pats)
+   return -ENOBUFS;
+
+  for (j = 0; j < rule->n_patterns; j++) {
+   nl_pat = nla_nest_start(msg, j + 1);
+   if (!nl_pat)
+    return -ENOBUFS;
+   pat_len = rule->patterns[j].pattern_len;
+   if (nla_put(msg, NL80211_PKTPAT_MASK,
+        DIV_ROUND_UP(pat_len, 8),
+        rule->patterns[j].mask) ||
+       nla_put(msg, NL80211_PKTPAT_PATTERN, pat_len,
+        rule->patterns[j].pattern) ||
+       nla_put_u32(msg, NL80211_PKTPAT_OFFSET,
+     rule->patterns[j].pkt_offset))
+    return -ENOBUFS;
+   nla_nest_end(msg, nl_pat);
+  }
+  nla_nest_end(msg, nl_pats);
+  nla_nest_end(msg, nl_rule);
+ }
+ nla_nest_end(msg, nl_rules);
+
+ return 0;
+}
+
+static int nl80211_get_coalesce(struct sk_buff *skb, struct genl_info *info)
+{
+ struct cfg80211_registered_device *rdev = info->user_ptr[0];
+ struct sk_buff *msg;
+ void *hdr;
+
+ if (!rdev->wiphy.coalesce)
+  return -EOPNOTSUPP;
+
+ msg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);
+ if (!msg)
+  return -ENOMEM;
+
+ hdr = nl80211hdr_put(msg, info->snd_portid, info->snd_seq, 0,
+        NL80211_CMD_GET_COALESCE);
+ if (!hdr)
+  goto nla_put_failure;
+
+ if (rdev->coalesce && nl80211_send_coalesce_rules(msg, rdev))
+  goto nla_put_failure;
+
+ genlmsg_end(msg, hdr);
+ return genlmsg_reply(msg, info);
+
+nla_put_failure:
+ nlmsg_free(msg);
+ return -ENOBUFS;
+}
+
+void cfg80211_rdev_free_coalesce(struct cfg80211_registered_device *rdev)
+{
+ struct cfg80211_coalesce *coalesce = rdev->coalesce;
+ int i, j;
+ struct cfg80211_coalesce_rules *rule;
+
+ if (!coalesce)
+  return;
+
+ for (i = 0; i < coalesce->n_rules; i++) {
+  rule = &coalesce->rules[i];
+  for (j = 0; j < rule->n_patterns; j++)
+   kfree(rule->patterns[j].mask);
+  kfree(rule->patterns);
+ }
+ kfree(coalesce->rules);
+ kfree(coalesce);
+ rdev->coalesce = NULL;
+}
+
+static int nl80211_parse_coalesce_rule(struct cfg80211_registered_device *rdev,
+           struct nlattr *rule,
+           struct cfg80211_coalesce_rules *new_rule)
+{
+ int err, i;
+ const struct wiphy_coalesce_support *coalesce = rdev->wiphy.coalesce;
+ struct nlattr *tb[NUM_NL80211_ATTR_COALESCE_RULE], *pat;
+ int rem, pat_len, mask_len, pkt_offset, n_patterns = 0;
+ struct nlattr *pat_tb[NUM_NL80211_PKTPAT];
+
+ err = nla_parse(tb, NL80211_ATTR_COALESCE_RULE_MAX, nla_data(rule),
+   nla_len(rule), nl80211_coalesce_policy);
+ if (err)
+  return err;
+
+ if (tb[NL80211_ATTR_COALESCE_RULE_DELAY])
+  new_rule->delay =
+   nla_get_u32(tb[NL80211_ATTR_COALESCE_RULE_DELAY]);
+ if (new_rule->delay > coalesce->max_delay)
+  return -EINVAL;
+
+ if (tb[NL80211_ATTR_COALESCE_RULE_CONDITION])
+  new_rule->condition =
+   nla_get_u32(tb[NL80211_ATTR_COALESCE_RULE_CONDITION]);
+ if (new_rule->condition != NL80211_COALESCE_CONDITION_MATCH &&
+     new_rule->condition != NL80211_COALESCE_CONDITION_NO_MATCH)
+  return -EINVAL;
+
+ if (!tb[NL80211_ATTR_COALESCE_RULE_PKT_PATTERN])
+  return -EINVAL;
+
+ nla_for_each_nested(pat, tb[NL80211_ATTR_COALESCE_RULE_PKT_PATTERN],
+       rem)
+  n_patterns++;
+ if (n_patterns > coalesce->n_patterns)
+  return -EINVAL;
+
+ new_rule->patterns = kcalloc(n_patterns, sizeof(new_rule->patterns[0]),
+         GFP_KERNEL);
+ if (!new_rule->patterns)
+  return -ENOMEM;
+
+ new_rule->n_patterns = n_patterns;
+ i = 0;
+
+ nla_for_each_nested(pat, tb[NL80211_ATTR_COALESCE_RULE_PKT_PATTERN],
+       rem) {
+  u8 *mask_pat;
+
+  nla_parse(pat_tb, MAX_NL80211_PKTPAT, nla_data(pat),
+     nla_len(pat), NULL);
+  if (!pat_tb[NL80211_PKTPAT_MASK] ||
+      !pat_tb[NL80211_PKTPAT_PATTERN])
+   return -EINVAL;
+  pat_len = nla_len(pat_tb[NL80211_PKTPAT_PATTERN]);
+  mask_len = DIV_ROUND_UP(pat_len, 8);
+  if (nla_len(pat_tb[NL80211_PKTPAT_MASK]) != mask_len)
+   return -EINVAL;
+  if (pat_len > coalesce->pattern_max_len ||
+      pat_len < coalesce->pattern_min_len)
+   return -EINVAL;
+
+  if (!pat_tb[NL80211_PKTPAT_OFFSET])
+   pkt_offset = 0;
+  else
+   pkt_offset = nla_get_u32(pat_tb[NL80211_PKTPAT_OFFSET]);
+  if (pkt_offset > coalesce->max_pkt_offset)
+   return -EINVAL;
+  new_rule->patterns[i].pkt_offset = pkt_offset;
+
+  mask_pat = kmalloc(mask_len + pat_len, GFP_KERNEL);
+  if (!mask_pat)
+   return -ENOMEM;
+
+  new_rule->patterns[i].mask = mask_pat;
+  memcpy(mask_pat, nla_data(pat_tb[NL80211_PKTPAT_MASK]),
+         mask_len);
+
+  mask_pat += mask_len;
+  new_rule->patterns[i].pattern = mask_pat;
+  new_rule->patterns[i].pattern_len = pat_len;
+  memcpy(mask_pat, nla_data(pat_tb[NL80211_PKTPAT_PATTERN]),
+         pat_len);
+  i++;
+ }
+
+ return 0;
+}
+
+static int nl80211_set_coalesce(struct sk_buff *skb, struct genl_info *info)
+{
+ struct cfg80211_registered_device *rdev = info->user_ptr[0];
+ const struct wiphy_coalesce_support *coalesce = rdev->wiphy.coalesce;
+ struct cfg80211_coalesce new_coalesce = {};
+ struct cfg80211_coalesce *n_coalesce;
+ int err, rem_rule, n_rules = 0, i, j;
+ struct nlattr *rule;
+ struct cfg80211_coalesce_rules *tmp_rule;
+
+ if (!rdev->wiphy.coalesce || !rdev->ops->set_coalesce)
+  return -EOPNOTSUPP;
+
+ if (!info->attrs[NL80211_ATTR_COALESCE_RULE]) {
+  cfg80211_rdev_free_coalesce(rdev);
+  rdev->ops->set_coalesce(&rdev->wiphy, NULL);
+  return 0;
+ }
+
+ nla_for_each_nested(rule, info->attrs[NL80211_ATTR_COALESCE_RULE],
+       rem_rule)
+  n_rules++;
+ if (n_rules > coalesce->n_rules)
+  return -EINVAL;
+
+ new_coalesce.rules = kcalloc(n_rules, sizeof(new_coalesce.rules[0]),
+         GFP_KERNEL);
+ if (!new_coalesce.rules)
+  return -ENOMEM;
+
+ new_coalesce.n_rules = n_rules;
+ i = 0;
+
+ nla_for_each_nested(rule, info->attrs[NL80211_ATTR_COALESCE_RULE],
+       rem_rule) {
+  err = nl80211_parse_coalesce_rule(rdev, rule,
+        &new_coalesce.rules[i]);
+  if (err)
+   goto error;
+
+  i++;
+ }
+
+ err = rdev->ops->set_coalesce(&rdev->wiphy, &new_coalesce);
+ if (err)
+  goto error;
+
+ n_coalesce = kmemdup(&new_coalesce, sizeof(new_coalesce), GFP_KERNEL);
+ if (!n_coalesce) {
+  err = -ENOMEM;
+  goto error;
+ }
+ cfg80211_rdev_free_coalesce(rdev);
+ rdev->coalesce = n_coalesce;
+
+ return 0;
+error:
+ for (i = 0; i < new_coalesce.n_rules; i++) {
+  tmp_rule = &new_coalesce.rules[i];
+  for (j = 0; j < tmp_rule->n_patterns; j++)
+   kfree(tmp_rule->patterns[j].mask);
+  kfree(tmp_rule->patterns);
+ }
+ kfree(new_coalesce.rules);
+
+ return err;
+}
+
 static int nl80211_set_rekey_data(struct sk_buff *skb, struct genl_info *info)
 {
  struct cfg80211_registered_device *rdev = info->user_ptr[0];
@@ -8087,9 +8998,8 @@ static int nl80211_probe_client(struct sk_buff *skb,
 
  hdr = nl80211hdr_put(msg, info->snd_portid, info->snd_seq, 0,
         NL80211_CMD_PROBE_CLIENT);
-
- if (IS_ERR(hdr)) {
-  err = PTR_ERR(hdr);
+ if (!hdr) {
+  err = -ENOBUFS;
   goto free_msg;
  }
 
@@ -8162,20 +9072,15 @@ static int nl80211_start_p2p_device(struct sk_buff *skb, struct genl_info *info)
  if (wdev->p2p_started)
   return 0;
 
- mutex_lock(&rdev->devlist_mtx);
- err = cfg80211_can_add_interface(rdev, wdev->iftype);
- mutex_unlock(&rdev->devlist_mtx);
- if (err)
-  return err;
+ if (rfkill_blocked(rdev->rfkill))
+  return -ERFKILL;
 
  err = rdev_start_p2p_device(rdev, wdev);
  if (err)
   return err;
 
  wdev->p2p_started = true;
- mutex_lock(&rdev->devlist_mtx);
  rdev->opencount++;
- mutex_unlock(&rdev->devlist_mtx);
 
  return 0;
 }
@@ -8191,11 +9096,7 @@ static int nl80211_stop_p2p_device(struct sk_buff *skb, struct genl_info *info)
  if (!rdev->ops->stop_p2p_device)
   return -EOPNOTSUPP;
 
- mutex_lock(&rdev->devlist_mtx);
- mutex_lock(&rdev->sched_scan_mtx);
  cfg80211_stop_p2p_device(rdev, wdev);
- mutex_unlock(&rdev->sched_scan_mtx);
- mutex_unlock(&rdev->devlist_mtx);
 
  return 0;
 }
@@ -8306,6 +9207,162 @@ static int nl80211_crit_protocol_stop(struct sk_buff *skb,
  return 0;
 }
 
+static int nl80211_vendor_cmd(struct sk_buff *skb, struct genl_info *info)
+{
+ struct cfg80211_registered_device *rdev = info->user_ptr[0];
+ struct wireless_dev *wdev =
+  __cfg80211_wdev_from_attrs(genl_info_net(info), info->attrs);
+ int i, err;
+ u32 vid, subcmd;
+
+ if (!rdev->wiphy.vendor_commands)
+  return -EOPNOTSUPP;
+
+ if (IS_ERR(wdev)) {
+  err = PTR_ERR(wdev);
+  if (err != -EINVAL)
+   return err;
+  wdev = NULL;
+ } else if (wdev->wiphy != &rdev->wiphy) {
+  return -EINVAL;
+ }
+
+ if (!info->attrs[NL80211_ATTR_VENDOR_ID] ||
+     !info->attrs[NL80211_ATTR_VENDOR_SUBCMD])
+  return -EINVAL;
+
+ vid = nla_get_u32(info->attrs[NL80211_ATTR_VENDOR_ID]);
+ subcmd = nla_get_u32(info->attrs[NL80211_ATTR_VENDOR_SUBCMD]);
+ for (i = 0; i < rdev->wiphy.n_vendor_commands; i++) {
+  const struct wiphy_vendor_command *vcmd;
+  void *data = NULL;
+  int len = 0;
+
+  vcmd = &rdev->wiphy.vendor_commands[i];
+
+  if (vcmd->info.vendor_id != vid || vcmd->info.subcmd != subcmd)
+   continue;
+
+  if (vcmd->flags & (WIPHY_VENDOR_CMD_NEED_WDEV |
+       WIPHY_VENDOR_CMD_NEED_NETDEV)) {
+   if (!wdev)
+    return -EINVAL;
+   if (vcmd->flags & WIPHY_VENDOR_CMD_NEED_NETDEV &&
+       !wdev->netdev)
+    return -EINVAL;
+
+   if (vcmd->flags & WIPHY_VENDOR_CMD_NEED_RUNNING) {
+    if (wdev->netdev &&
+        !netif_running(wdev->netdev))
+     return -ENETDOWN;
+    if (!wdev->netdev && !wdev->p2p_started)
+     return -ENETDOWN;
+   }
+  } else {
+   wdev = NULL;
+  }
+
+  if (info->attrs[NL80211_ATTR_VENDOR_DATA]) {
+   data = nla_data(info->attrs[NL80211_ATTR_VENDOR_DATA]);
+   len = nla_len(info->attrs[NL80211_ATTR_VENDOR_DATA]);
+  }
+
+  rdev->cur_cmd_info = info;
+  err = rdev->wiphy.vendor_commands[i].doit(&rdev->wiphy, wdev,
+         data, len);
+  rdev->cur_cmd_info = NULL;
+  return err;
+ }
+
+ return -EOPNOTSUPP;
+}
+
+struct sk_buff *__cfg80211_alloc_reply_skb(struct wiphy *wiphy,
+        enum nl80211_commands cmd,
+        enum nl80211_attrs attr,
+        int approxlen)
+{
+ struct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);
+
+ if (WARN_ON(!rdev->cur_cmd_info))
+  return NULL;
+
+ return __cfg80211_alloc_vendor_skb(rdev, approxlen,
+        rdev->cur_cmd_info->snd_portid,
+        rdev->cur_cmd_info->snd_seq,
+        cmd, attr, NULL, GFP_KERNEL);
+}
+EXPORT_SYMBOL(__cfg80211_alloc_reply_skb);
+
+int cfg80211_vendor_cmd_reply(struct sk_buff *skb)
+{
+ struct cfg80211_registered_device *rdev = ((void **)skb->cb)[0];
+ void *hdr = ((void **)skb->cb)[1];
+ struct nlattr *data = ((void **)skb->cb)[2];
+
+ if (WARN_ON(!rdev->cur_cmd_info)) {
+  kfree_skb(skb);
+  return -EINVAL;
+ }
+
+ nla_nest_end(skb, data);
+ genlmsg_end(skb, hdr);
+ return genlmsg_reply(skb, rdev->cur_cmd_info);
+}
+EXPORT_SYMBOL_GPL(cfg80211_vendor_cmd_reply);
+
+
+static int nl80211_set_qos_map(struct sk_buff *skb,
+          struct genl_info *info)
+{
+ struct cfg80211_registered_device *rdev = info->user_ptr[0];
+ struct cfg80211_qos_map *qos_map = NULL;
+ struct net_device *dev = info->user_ptr[1];
+ u8 *pos, len, num_des, des_len, des;
+ int ret;
+
+ if (!rdev->ops->set_qos_map)
+  return -EOPNOTSUPP;
+
+ if (info->attrs[NL80211_ATTR_QOS_MAP]) {
+  pos = nla_data(info->attrs[NL80211_ATTR_QOS_MAP]);
+  len = nla_len(info->attrs[NL80211_ATTR_QOS_MAP]);
+
+  if (len % 2 || len < IEEE80211_QOS_MAP_LEN_MIN ||
+      len > IEEE80211_QOS_MAP_LEN_MAX)
+   return -EINVAL;
+
+  qos_map = kzalloc(sizeof(struct cfg80211_qos_map), GFP_KERNEL);
+  if (!qos_map)
+   return -ENOMEM;
+
+  num_des = (len - IEEE80211_QOS_MAP_LEN_MIN) >> 1;
+  if (num_des) {
+   des_len = num_des *
+    sizeof(struct cfg80211_dscp_exception);
+   memcpy(qos_map->dscp_exception, pos, des_len);
+   qos_map->num_des = num_des;
+   for (des = 0; des < num_des; des++) {
+    if (qos_map->dscp_exception[des].up > 7) {
+     kfree(qos_map);
+     return -EINVAL;
+    }
+   }
+   pos += des_len;
+  }
+  memcpy(qos_map->up, pos, IEEE80211_QOS_MAP_LEN_MIN);
+ }
+
+ wdev_lock(dev->ieee80211_ptr);
+ ret = nl80211_key_allowed(dev->ieee80211_ptr);
+ if (!ret)
+  ret = rdev_set_qos_map(rdev, dev, qos_map);
+ wdev_unlock(dev->ieee80211_ptr);
+
+ kfree(qos_map);
+ return ret;
+}
+
 #define NL80211_FLAG_NEED_WIPHY  0x01
 #define NL80211_FLAG_NEED_NETDEV 0x02
 #define NL80211_FLAG_NEED_RTNL  0x04
@@ -8338,22 +9395,21 @@ static int nl80211_pre_doit(const struct genl_ops *ops, struct sk_buff *skb,
   info->user_ptr[0] = rdev;
  } else if (ops->internal_flags & NL80211_FLAG_NEED_NETDEV ||
      ops->internal_flags & NL80211_FLAG_NEED_WDEV) {
-  mutex_lock(&cfg80211_mutex);
+  ASSERT_RTNL();
+
   wdev = __cfg80211_wdev_from_attrs(genl_info_net(info),
         info->attrs);
   if (IS_ERR(wdev)) {
-   mutex_unlock(&cfg80211_mutex);
    if (rtnl)
     rtnl_unlock();
    return PTR_ERR(wdev);
   }
 
   dev = wdev->netdev;
-  rdev = wiphy_to_dev(wdev->wiphy);
+  rdev = wiphy_to_rdev(wdev->wiphy);
 
   if (ops->internal_flags & NL80211_FLAG_NEED_NETDEV) {
    if (!dev) {
-    mutex_unlock(&cfg80211_mutex);
     if (rtnl)
      rtnl_unlock();
     return -EINVAL;
@@ -8367,7 +9423,6 @@ static int nl80211_pre_doit(const struct genl_ops *ops, struct sk_buff *skb,
   if (dev) {
    if (ops->internal_flags & NL80211_FLAG_CHECK_NETDEV_UP &&
        !netif_running(dev)) {
-    mutex_unlock(&cfg80211_mutex);
     if (rtnl)
      rtnl_unlock();
     return -ENETDOWN;
@@ -8376,17 +9431,12 @@ static int nl80211_pre_doit(const struct genl_ops *ops, struct sk_buff *skb,
    dev_hold(dev);
   } else if (ops->internal_flags & NL80211_FLAG_CHECK_NETDEV_UP) {
    if (!wdev->p2p_started) {
-    mutex_unlock(&cfg80211_mutex);
     if (rtnl)
      rtnl_unlock();
     return -ENETDOWN;
    }
   }
 
-  cfg80211_lock_rdev(rdev);
-
-  mutex_unlock(&cfg80211_mutex);
-
   info->user_ptr[0] = rdev;
  }
 
@@ -8396,8 +9446,6 @@ static int nl80211_pre_doit(const struct genl_ops *ops, struct sk_buff *skb,
 static void nl80211_post_doit(const struct genl_ops *ops, struct sk_buff *skb,
          struct genl_info *info)
 {
- if (info->user_ptr[0])
-  cfg80211_unlock_rdev(info->user_ptr[0]);
  if (info->user_ptr[1]) {
   if (ops->internal_flags & NL80211_FLAG_NEED_WDEV) {
    struct wireless_dev *wdev = info->user_ptr[1];
@@ -8417,9 +9465,11 @@ static const struct genl_ops nl80211_ops[] = {
   .cmd = NL80211_CMD_GET_WIPHY,
   .doit = nl80211_get_wiphy,
   .dumpit = nl80211_dump_wiphy,
+  .done = nl80211_dump_wiphy_done,
   .policy = nl80211_policy,
   /* can be retrieved by unprivileged users */
-  .internal_flags = NL80211_FLAG_NEED_WIPHY,
+  .internal_flags = NL80211_FLAG_NEED_WIPHY |
+      NL80211_FLAG_NEED_RTNL,
  },
  {
   .cmd = NL80211_CMD_SET_WIPHY,
@@ -8434,7 +9484,8 @@ static const struct genl_ops nl80211_ops[] = {
   .dumpit = nl80211_dump_interface,
   .policy = nl80211_policy,
   /* can be retrieved by unprivileged users */
-  .internal_flags = NL80211_FLAG_NEED_WDEV,
+  .internal_flags = NL80211_FLAG_NEED_WDEV |
+      NL80211_FLAG_NEED_RTNL,
  },
  {
   .cmd = NL80211_CMD_SET_INTERFACE,
@@ -8593,6 +9644,7 @@ static const struct genl_ops nl80211_ops[] = {
   .cmd = NL80211_CMD_GET_REG,
   .doit = nl80211_get_reg,
   .policy = nl80211_policy,
+  .internal_flags = NL80211_FLAG_NEED_RTNL,
   /* can be retrieved by unprivileged users */
  },
  {
@@ -8600,6 +9652,7 @@ static const struct genl_ops nl80211_ops[] = {
   .doit = nl80211_set_reg,
   .policy = nl80211_policy,
   .flags = GENL_ADMIN_PERM,
+  .internal_flags = NL80211_FLAG_NEED_RTNL,
  },
  {
   .cmd = NL80211_CMD_REQ_SET_REG,
@@ -9010,21 +10063,64 @@ static const struct genl_ops nl80211_ops[] = {
   .flags = GENL_ADMIN_PERM,
   .internal_flags = NL80211_FLAG_NEED_WDEV_UP |
       NL80211_FLAG_NEED_RTNL,
- }
+ },
+ {
+  .cmd = NL80211_CMD_GET_COALESCE,
+  .doit = nl80211_get_coalesce,
+  .policy = nl80211_policy,
+  .internal_flags = NL80211_FLAG_NEED_WIPHY |
+      NL80211_FLAG_NEED_RTNL,
+ },
+ {
+  .cmd = NL80211_CMD_SET_COALESCE,
+  .doit = nl80211_set_coalesce,
+  .policy = nl80211_policy,
+  .flags = GENL_ADMIN_PERM,
+  .internal_flags = NL80211_FLAG_NEED_WIPHY |
+      NL80211_FLAG_NEED_RTNL,
+ },
+ {
+  .cmd = NL80211_CMD_CHANNEL_SWITCH,
+  .doit = nl80211_channel_switch,
+  .policy = nl80211_policy,
+  .flags = GENL_ADMIN_PERM,
+  .internal_flags = NL80211_FLAG_NEED_NETDEV_UP |
+      NL80211_FLAG_NEED_RTNL,
+ },
+ {
+  .cmd = NL80211_CMD_VENDOR,
+  .doit = nl80211_vendor_cmd,
+  .policy = nl80211_policy,
+  .flags = GENL_ADMIN_PERM,
+  .internal_flags = NL80211_FLAG_NEED_WIPHY |
+      NL80211_FLAG_NEED_RTNL,
+ },
+ {
+  .cmd = NL80211_CMD_SET_QOS_MAP,
+  .doit = nl80211_set_qos_map,
+  .policy = nl80211_policy,
+  .flags = GENL_ADMIN_PERM,
+  .internal_flags = NL80211_FLAG_NEED_NETDEV_UP |
+      NL80211_FLAG_NEED_RTNL,
+ },
 };
 
 /* notification functions */
 
-void nl80211_notify_dev_rename(struct cfg80211_registered_device *rdev)
+void nl80211_notify_wiphy(struct cfg80211_registered_device *rdev,
+     enum nl80211_commands cmd)
 {
  struct sk_buff *msg;
+ struct nl80211_dump_wiphy_state state = {};
+
+ WARN_ON(cmd != NL80211_CMD_NEW_WIPHY &&
+  cmd != NL80211_CMD_DEL_WIPHY);
 
  msg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);
  if (!msg)
   return;
 
- if (nl80211_send_wiphy(rdev, msg, 0, 0, 0,
-          false, NULL, NULL, NULL) < 0) {
+ if (nl80211_send_wiphy(rdev, cmd, msg, 0, 0, 0, &state) < 0) {
   nlmsg_free(msg);
   return;
  }
@@ -9040,8 +10136,6 @@ static int nl80211_add_scan_req(struct sk_buff *msg,
  struct nlattr *nest;
  int i;
 
- lockdep_assert_held(&rdev->sched_scan_mtx);
-
  if (WARN_ON(!req))
   return 0;
 
@@ -9067,8 +10161,9 @@ static int nl80211_add_scan_req(struct sk_buff *msg,
      nla_put(msg, NL80211_ATTR_IE, req->ie_len, req->ie))
   goto nla_put_failure;
 
- if (req->flags)
-  nla_put_u32(msg, NL80211_ATTR_SCAN_FLAGS, req->flags);
+ if (req->flags &&
+     nla_put_u32(msg, NL80211_ATTR_SCAN_FLAGS, req->flags))
+  goto nla_put_failure;
 
  return 0;
  nla_put_failure:
@@ -9145,40 +10240,31 @@ void nl80211_send_scan_start(struct cfg80211_registered_device *rdev,
     NL80211_MCGRP_SCAN, GFP_KERNEL);
 }
 
-void nl80211_send_scan_done(struct cfg80211_registered_device *rdev,
-       struct wireless_dev *wdev)
+struct sk_buff *nl80211_build_scan_msg(struct cfg80211_registered_device *rdev,
+           struct wireless_dev *wdev, bool aborted)
 {
  struct sk_buff *msg;
 
  msg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);
  if (!msg)
-  return;
+  return NULL;
 
  if (nl80211_send_scan_msg(msg, rdev, wdev, 0, 0, 0,
-      NL80211_CMD_NEW_SCAN_RESULTS) < 0) {
+      aborted ? NL80211_CMD_SCAN_ABORTED :
+         NL80211_CMD_NEW_SCAN_RESULTS) < 0) {
   nlmsg_free(msg);
-  return;
+  return NULL;
  }
 
- genlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,
-    NL80211_MCGRP_SCAN, GFP_KERNEL);
+ return msg;
 }
 
-void nl80211_send_scan_aborted(struct cfg80211_registered_device *rdev,
-          struct wireless_dev *wdev)
+void nl80211_send_scan_result(struct cfg80211_registered_device *rdev,
+         struct sk_buff *msg)
 {
- struct sk_buff *msg;
-
- msg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);
  if (!msg)
   return;
 
- if (nl80211_send_scan_msg(msg, rdev, wdev, 0, 0, 0,
-      NL80211_CMD_SCAN_ABORTED) < 0) {
-  nlmsg_free(msg);
-  return;
- }
-
  genlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,
     NL80211_MCGRP_SCAN, GFP_KERNEL);
 }
@@ -9348,31 +10434,27 @@ void nl80211_send_disassoc(struct cfg80211_registered_device *rdev,
     NL80211_CMD_DISASSOCIATE, gfp);
 }
 
-void cfg80211_send_unprot_deauth(struct net_device *dev, const u8 *buf,
-     size_t len)
+void cfg80211_rx_unprot_mlme_mgmt(struct net_device *dev, const u8 *buf,
+      size_t len)
 {
  struct wireless_dev *wdev = dev->ieee80211_ptr;
  struct wiphy *wiphy = wdev->wiphy;
- struct cfg80211_registered_device *rdev = wiphy_to_dev(wiphy);
+ struct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);
+ const struct ieee80211_mgmt *mgmt = (void *)buf;
+ u32 cmd;
 
- trace_cfg80211_send_unprot_deauth(dev);
- nl80211_send_mlme_event(rdev, dev, buf, len,
-    NL80211_CMD_UNPROT_DEAUTHENTICATE, GFP_ATOMIC);
-}
-EXPORT_SYMBOL(cfg80211_send_unprot_deauth);
+ if (WARN_ON(len < 2))
+  return;
 
-void cfg80211_send_unprot_disassoc(struct net_device *dev, const u8 *buf,
-       size_t len)
-{
- struct wireless_dev *wdev = dev->ieee80211_ptr;
- struct wiphy *wiphy = wdev->wiphy;
- struct cfg80211_registered_device *rdev = wiphy_to_dev(wiphy);
+ if (ieee80211_is_deauth(mgmt->frame_control))
+  cmd = NL80211_CMD_UNPROT_DEAUTHENTICATE;
+ else
+  cmd = NL80211_CMD_UNPROT_DISASSOCIATE;
 
- trace_cfg80211_send_unprot_disassoc(dev);
- nl80211_send_mlme_event(rdev, dev, buf, len,
-    NL80211_CMD_UNPROT_DISASSOCIATE, GFP_ATOMIC);
+ trace_cfg80211_rx_unprot_mlme_mgmt(dev, buf, len);
+ nl80211_send_mlme_event(rdev, dev, buf, len, cmd, GFP_ATOMIC);
 }
-EXPORT_SYMBOL(cfg80211_send_unprot_disassoc);
+EXPORT_SYMBOL(cfg80211_rx_unprot_mlme_mgmt);
 
 static void nl80211_send_mlme_timeout(struct cfg80211_registered_device *rdev,
           struct net_device *netdev, int cmd,
@@ -9579,7 +10661,7 @@ void cfg80211_notify_new_peer_candidate(struct net_device *dev, const u8 *addr,
      const u8* ie, u8 ie_len, gfp_t gfp)
 {
  struct wireless_dev *wdev = dev->ieee80211_ptr;
- struct cfg80211_registered_device *rdev = wiphy_to_dev(wdev->wiphy);
+ struct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);
  struct sk_buff *msg;
  void *hdr;
 
@@ -9759,7 +10841,7 @@ void cfg80211_ready_on_channel(struct wireless_dev *wdev, u64 cookie,
           unsigned int duration, gfp_t gfp)
 {
  struct wiphy *wiphy = wdev->wiphy;
- struct cfg80211_registered_device *rdev = wiphy_to_dev(wiphy);
+ struct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);
 
  trace_cfg80211_ready_on_channel(wdev, cookie, chan, duration);
  nl80211_send_remain_on_chan_event(NL80211_CMD_REMAIN_ON_CHANNEL,
@@ -9773,7 +10855,7 @@ void cfg80211_remain_on_channel_expired(struct wireless_dev *wdev, u64 cookie,
      gfp_t gfp)
 {
  struct wiphy *wiphy = wdev->wiphy;
- struct cfg80211_registered_device *rdev = wiphy_to_dev(wiphy);
+ struct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);
 
  trace_cfg80211_ready_on_channel_expired(wdev, cookie, chan);
  nl80211_send_remain_on_chan_event(NL80211_CMD_CANCEL_REMAIN_ON_CHANNEL,
@@ -9785,7 +10867,7 @@ void cfg80211_new_sta(struct net_device *dev, const u8 *mac_addr,
         struct station_info *sinfo, gfp_t gfp)
 {
  struct wiphy *wiphy = dev->ieee80211_ptr->wiphy;
- struct cfg80211_registered_device *rdev = wiphy_to_dev(wiphy);
+ struct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);
  struct sk_buff *msg;
 
  trace_cfg80211_new_sta(dev, mac_addr, sinfo);
@@ -9808,7 +10890,7 @@ EXPORT_SYMBOL(cfg80211_new_sta);
 void cfg80211_del_sta(struct net_device *dev, const u8 *mac_addr, gfp_t gfp)
 {
  struct wiphy *wiphy = dev->ieee80211_ptr->wiphy;
- struct cfg80211_registered_device *rdev = wiphy_to_dev(wiphy);
+ struct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);
  struct sk_buff *msg;
  void *hdr;
 
@@ -9845,7 +10927,7 @@ void cfg80211_conn_failed(struct net_device *dev, const u8 *mac_addr,
      gfp_t gfp)
 {
  struct wiphy *wiphy = dev->ieee80211_ptr->wiphy;
- struct cfg80211_registered_device *rdev = wiphy_to_dev(wiphy);
+ struct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);
  struct sk_buff *msg;
  void *hdr;
 
@@ -9880,10 +10962,9 @@ static bool __nl80211_unexpected_frame(struct net_device *dev, u8 cmd,
            const u8 *addr, gfp_t gfp)
 {
  struct wireless_dev *wdev = dev->ieee80211_ptr;
- struct cfg80211_registered_device *rdev = wiphy_to_dev(wdev->wiphy);
+ struct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);
  struct sk_buff *msg;
  void *hdr;
- int err;
  u32 nlportid = ACCESS_ONCE(wdev->ap_unexpected_nlportid);
 
  if (!nlportid)
@@ -9904,12 +10985,7 @@ static bool __nl80211_unexpected_frame(struct net_device *dev, u8 cmd,
      nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, addr))
   goto nla_put_failure;
 
- err = genlmsg_end(msg, hdr);
- if (err < 0) {
-  nlmsg_free(msg);
-  return true;
- }
-
+ genlmsg_end(msg, hdr);
  genlmsg_unicast(wiphy_net(&rdev->wiphy), msg, nlportid);
  return true;
 
@@ -9964,7 +11040,7 @@ EXPORT_SYMBOL(cfg80211_rx_unexpected_4addr_frame);
 int nl80211_send_mgmt(struct cfg80211_registered_device *rdev,
         struct wireless_dev *wdev, u32 nlportid,
         int freq, int sig_dbm,
-        const u8 *buf, size_t len, gfp_t gfp)
+        const u8 *buf, size_t len, u32 flags, gfp_t gfp)
 {
  struct net_device *netdev = wdev->netdev;
  struct sk_buff *msg;
@@ -9987,7 +11063,9 @@ int nl80211_send_mgmt(struct cfg80211_registered_device *rdev,
      nla_put_u32(msg, NL80211_ATTR_WIPHY_FREQ, freq) ||
      (sig_dbm &&
       nla_put_u32(msg, NL80211_ATTR_RX_SIGNAL_DBM, sig_dbm)) ||
-     nla_put(msg, NL80211_ATTR_FRAME, len, buf))
+     nla_put(msg, NL80211_ATTR_FRAME, len, buf) ||
+     (flags &&
+      nla_put_u32(msg, NL80211_ATTR_RXMGMT_FLAGS, flags)))
   goto nla_put_failure;
 
  genlmsg_end(msg, hdr);
@@ -10004,7 +11082,7 @@ void cfg80211_mgmt_tx_status(struct wireless_dev *wdev, u64 cookie,
         const u8 *buf, size_t len, bool ack, gfp_t gfp)
 {
  struct wiphy *wiphy = wdev->wiphy;
- struct cfg80211_registered_device *rdev = wiphy_to_dev(wiphy);
+ struct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);
  struct net_device *netdev = wdev->netdev;
  struct sk_buff *msg;
  void *hdr;
@@ -10048,7 +11126,7 @@ void cfg80211_cqm_rssi_notify(struct net_device *dev,
 {
  struct wireless_dev *wdev = dev->ieee80211_ptr;
  struct wiphy *wiphy = wdev->wiphy;
- struct cfg80211_registered_device *rdev = wiphy_to_dev(wiphy);
+ struct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);
  struct sk_buff *msg;
  struct nlattr *pinfoattr;
  void *hdr;
@@ -10140,7 +11218,7 @@ void cfg80211_gtk_rekey_notify(struct net_device *dev, const u8 *bssid,
 {
  struct wireless_dev *wdev = dev->ieee80211_ptr;
  struct wiphy *wiphy = wdev->wiphy;
- struct cfg80211_registered_device *rdev = wiphy_to_dev(wiphy);
+ struct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);
 
  trace_cfg80211_gtk_rekey_notify(dev, bssid);
  nl80211_gtk_rekey_notify(rdev, dev, bssid, replay_ctr, gfp);
@@ -10198,7 +11276,7 @@ void cfg80211_pmksa_candidate_notify(struct net_device *dev, int index,
 {
  struct wireless_dev *wdev = dev->ieee80211_ptr;
  struct wiphy *wiphy = wdev->wiphy;
- struct cfg80211_registered_device *rdev = wiphy_to_dev(wiphy);
+ struct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);
 
  trace_cfg80211_pmksa_candidate_notify(dev, index, bssid, preauth);
  nl80211_pmksa_candidate_notify(rdev, dev, index, bssid, preauth, gfp);
@@ -10245,21 +11323,21 @@ void cfg80211_ch_switch_notify(struct net_device *dev,
 {
  struct wireless_dev *wdev = dev->ieee80211_ptr;
  struct wiphy *wiphy = wdev->wiphy;
- struct cfg80211_registered_device *rdev = wiphy_to_dev(wiphy);
+ struct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);
 
- trace_cfg80211_ch_switch_notify(dev, chandef);
+ ASSERT_WDEV_LOCK(wdev);
 
- wdev_lock(wdev);
+ trace_cfg80211_ch_switch_notify(dev, chandef);
 
  if (WARN_ON(wdev->iftype != NL80211_IFTYPE_AP &&
-      wdev->iftype != NL80211_IFTYPE_P2P_GO))
-  goto out;
+      wdev->iftype != NL80211_IFTYPE_P2P_GO &&
+      wdev->iftype != NL80211_IFTYPE_ADHOC &&
+      wdev->iftype != NL80211_IFTYPE_MESH_POINT))
+  return;
 
- wdev->channel = chandef->chan;
+ wdev->chandef = *chandef;
+ wdev->preset_chandef = *chandef;
  nl80211_ch_switch_notify(rdev, dev, chandef, GFP_KERNEL);
-out:
- wdev_unlock(wdev);
- return;
 }
 EXPORT_SYMBOL(cfg80211_ch_switch_notify);
 
@@ -10269,7 +11347,7 @@ void cfg80211_cqm_txe_notify(struct net_device *dev,
 {
  struct wireless_dev *wdev = dev->ieee80211_ptr;
  struct wiphy *wiphy = wdev->wiphy;
- struct cfg80211_registered_device *rdev = wiphy_to_dev(wiphy);
+ struct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);
  struct sk_buff *msg;
  struct nlattr *pinfoattr;
  void *hdr;
@@ -10318,7 +11396,7 @@ EXPORT_SYMBOL(cfg80211_cqm_txe_notify);
 
 void
 nl80211_radar_notify(struct cfg80211_registered_device *rdev,
-       struct cfg80211_chan_def *chandef,
+       const struct cfg80211_chan_def *chandef,
        enum nl80211_radar_event event,
        struct net_device *netdev, gfp_t gfp)
 {
@@ -10353,10 +11431,7 @@ nl80211_radar_notify(struct cfg80211_registered_device *rdev,
  if (nl80211_send_chandef(msg, chandef))
   goto nla_put_failure;
 
- if (genlmsg_end(msg, hdr) < 0) {
-  nlmsg_free(msg);
-  return;
- }
+ genlmsg_end(msg, hdr);
 
  genlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,
     NL80211_MCGRP_MLME, gfp);
@@ -10372,7 +11447,7 @@ void cfg80211_cqm_pktloss_notify(struct net_device *dev,
 {
  struct wireless_dev *wdev = dev->ieee80211_ptr;
  struct wiphy *wiphy = wdev->wiphy;
- struct cfg80211_registered_device *rdev = wiphy_to_dev(wiphy);
+ struct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);
  struct sk_buff *msg;
  struct nlattr *pinfoattr;
  void *hdr;
@@ -10419,10 +11494,9 @@ void cfg80211_probe_status(struct net_device *dev, const u8 *addr,
       u64 cookie, bool acked, gfp_t gfp)
 {
  struct wireless_dev *wdev = dev->ieee80211_ptr;
- struct cfg80211_registered_device *rdev = wiphy_to_dev(wdev->wiphy);
+ struct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);
  struct sk_buff *msg;
  void *hdr;
- int err;
 
  trace_cfg80211_probe_status(dev, addr, cookie, acked);
 
@@ -10444,11 +11518,7 @@ void cfg80211_probe_status(struct net_device *dev, const u8 *addr,
      (acked && nla_put_flag(msg, NL80211_ATTR_ACK)))
   goto nla_put_failure;
 
- err = genlmsg_end(msg, hdr);
- if (err < 0) {
-  nlmsg_free(msg);
-  return;
- }
+ genlmsg_end(msg, hdr);
 
  genlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,
     NL80211_MCGRP_MLME, gfp);
@@ -10464,7 +11534,7 @@ void cfg80211_report_obss_beacon(struct wiphy *wiphy,
      const u8 *frame, size_t len,
      int freq, int sig_dbm)
 {
- struct cfg80211_registered_device *rdev = wiphy_to_dev(wiphy);
+ struct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);
  struct sk_buff *msg;
  void *hdr;
  struct cfg80211_beacon_registration *reg;
@@ -10511,10 +11581,10 @@ void cfg80211_report_wowlan_wakeup(struct wireless_dev *wdev,
        struct cfg80211_wowlan_wakeup *wakeup,
        gfp_t gfp)
 {
- struct cfg80211_registered_device *rdev = wiphy_to_dev(wdev->wiphy);
+ struct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);
  struct sk_buff *msg;
  void *hdr;
- int err, size = 200;
+ int size = 200;
 
  trace_cfg80211_report_wowlan_wakeup(wdev->wiphy, wdev, wakeup);
 
@@ -10541,6 +11611,8 @@ void cfg80211_report_wowlan_wakeup(struct wireless_dev *wdev,
   struct nlattr *reasons;
 
   reasons = nla_nest_start(msg, NL80211_ATTR_WOWLAN_TRIGGERS);
+  if (!reasons)
+   goto free_msg;
 
   if (wakeup->disconnect &&
       nla_put_flag(msg, NL80211_WOWLAN_TRIG_DISCONNECT))
@@ -10566,16 +11638,18 @@ void cfg80211_report_wowlan_wakeup(struct wireless_dev *wdev,
     wakeup->pattern_idx))
    goto free_msg;
 
-  if (wakeup->tcp_match)
-   nla_put_flag(msg, NL80211_WOWLAN_TRIG_WAKEUP_TCP_MATCH);
+  if (wakeup->tcp_match &&
+      nla_put_flag(msg, NL80211_WOWLAN_TRIG_WAKEUP_TCP_MATCH))
+   goto free_msg;
 
-  if (wakeup->tcp_connlost)
-   nla_put_flag(msg,
-         NL80211_WOWLAN_TRIG_WAKEUP_TCP_CONNLOST);
+  if (wakeup->tcp_connlost &&
+      nla_put_flag(msg, NL80211_WOWLAN_TRIG_WAKEUP_TCP_CONNLOST))
+   goto free_msg;
 
-  if (wakeup->tcp_nomoretokens)
-   nla_put_flag(msg,
-    NL80211_WOWLAN_TRIG_WAKEUP_TCP_NOMORETOKENS);
+  if (wakeup->tcp_nomoretokens &&
+      nla_put_flag(msg,
+     NL80211_WOWLAN_TRIG_WAKEUP_TCP_NOMORETOKENS))
+   goto free_msg;
 
   if (wakeup->packet) {
    u32 pkt_attr = NL80211_WOWLAN_TRIG_WAKEUP_PKT_80211;
@@ -10600,9 +11674,7 @@ void cfg80211_report_wowlan_wakeup(struct wireless_dev *wdev,
   nla_nest_end(msg, reasons);
  }
 
- err = genlmsg_end(msg, hdr);
- if (err < 0)
-  goto free_msg;
+ genlmsg_end(msg, hdr);
 
  genlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,
     NL80211_MCGRP_MLME, gfp);
@@ -10619,10 +11691,9 @@ void cfg80211_tdls_oper_request(struct net_device *dev, const u8 *peer,
     u16 reason_code, gfp_t gfp)
 {
  struct wireless_dev *wdev = dev->ieee80211_ptr;
- struct cfg80211_registered_device *rdev = wiphy_to_dev(wdev->wiphy);
+ struct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);
  struct sk_buff *msg;
  void *hdr;
- int err;
 
  trace_cfg80211_tdls_oper_request(wdev->wiphy, dev, peer, oper,
       reason_code);
@@ -10645,11 +11716,7 @@ void cfg80211_tdls_oper_request(struct net_device *dev, const u8 *peer,
       nla_put_u16(msg, NL80211_ATTR_REASON_CODE, reason_code)))
   goto nla_put_failure;
 
- err = genlmsg_end(msg, hdr);
- if (err < 0) {
-  nlmsg_free(msg);
-  return;
- }
+ genlmsg_end(msg, hdr);
 
  genlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,
     NL80211_MCGRP_MLME, gfp);
@@ -10676,9 +11743,15 @@ static int nl80211_netlink_notify(struct notifier_block * nb,
  rcu_read_lock();
 
  list_for_each_entry_rcu(rdev, &cfg80211_rdev_list, list) {
-  list_for_each_entry_rcu(wdev, &rdev->wdev_list, list)
+  bool schedule_destroy_work = false;
+
+  list_for_each_entry_rcu(wdev, &rdev->wdev_list, list) {
    cfg80211_mlme_unregister_socket(wdev, notify->portid);
 
+   if (wdev->owner_nlportid == notify->portid)
+    schedule_destroy_work = true;
+  }
+
   spin_lock_bh(&rdev->beacon_registrations_lock);
   list_for_each_entry_safe(reg, tmp, &rdev->beacon_registrations,
       list) {
@@ -10689,11 +11762,24 @@ static int nl80211_netlink_notify(struct notifier_block * nb,
    }
   }
   spin_unlock_bh(&rdev->beacon_registrations_lock);
+
+  if (schedule_destroy_work) {
+   struct cfg80211_iface_destroy *destroy;
+
+   destroy = kzalloc(sizeof(*destroy), GFP_ATOMIC);
+   if (destroy) {
+    destroy->nlportid = notify->portid;
+    spin_lock(&rdev->destroy_list_lock);
+    list_add(&destroy->list, &rdev->destroy_list);
+    spin_unlock(&rdev->destroy_list_lock);
+    schedule_work(&rdev->destroy_work);
+   }
+  }
  }
 
  rcu_read_unlock();
 
- return NOTIFY_DONE;
+ return NOTIFY_OK;
 }
 
 static struct notifier_block nl80211_netlink_notifier = {
@@ -10704,10 +11790,9 @@ void cfg80211_ft_event(struct net_device *netdev,
          struct cfg80211_ft_event_params *ft_event)
 {
  struct wiphy *wiphy = netdev->ieee80211_ptr->wiphy;
- struct cfg80211_registered_device *rdev = wiphy_to_dev(wiphy);
+ struct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);
  struct sk_buff *msg;
  void *hdr;
- int err;
 
  trace_cfg80211_ft_event(wiphy, netdev, ft_event);
 
@@ -10719,28 +11804,29 @@ void cfg80211_ft_event(struct net_device *netdev,
   return;
 
  hdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_FT_EVENT);
- if (!hdr) {
-  nlmsg_free(msg);
-  return;
- }
+ if (!hdr)
+  goto out;
 
- nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx);
- nla_put_u32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex);
- nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, ft_event->target_ap);
- if (ft_event->ies)
-  nla_put(msg, NL80211_ATTR_IE, ft_event->ies_len, ft_event->ies);
- if (ft_event->ric_ies)
-  nla_put(msg, NL80211_ATTR_IE_RIC, ft_event->ric_ies_len,
-   ft_event->ric_ies);
+ if (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||
+     nla_put_u32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex) ||
+     nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, ft_event->target_ap))
+  goto out;
 
- err = genlmsg_end(msg, hdr);
- if (err < 0) {
-  nlmsg_free(msg);
-  return;
- }
+ if (ft_event->ies &&
+     nla_put(msg, NL80211_ATTR_IE, ft_event->ies_len, ft_event->ies))
+  goto out;
+ if (ft_event->ric_ies &&
+     nla_put(msg, NL80211_ATTR_IE_RIC, ft_event->ric_ies_len,
+      ft_event->ric_ies))
+  goto out;
+
+ genlmsg_end(msg, hdr);
 
  genlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,
     NL80211_MCGRP_MLME, GFP_KERNEL);
+ return;
+ out:
+ nlmsg_free(msg);
 }
 EXPORT_SYMBOL(cfg80211_ft_event);
 
@@ -10751,7 +11837,7 @@ void cfg80211_crit_proto_stopped(struct wireless_dev *wdev, gfp_t gfp)
  void *hdr;
  u32 nlportid;
 
- rdev = wiphy_to_dev(wdev->wiphy);
+ rdev = wiphy_to_rdev(wdev->wiphy);
  if (!rdev->crit_proto_nlportid)
   return;
 
@@ -10783,6 +11869,35 @@ void cfg80211_crit_proto_stopped(struct wireless_dev *wdev, gfp_t gfp)
 }
 EXPORT_SYMBOL(cfg80211_crit_proto_stopped);
 
+void nl80211_send_ap_stopped(struct wireless_dev *wdev)
+{
+ struct wiphy *wiphy = wdev->wiphy;
+ struct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);
+ struct sk_buff *msg;
+ void *hdr;
+
+ msg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);
+ if (!msg)
+  return;
+
+ hdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_STOP_AP);
+ if (!hdr)
+  goto out;
+
+ if (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||
+     nla_put_u32(msg, NL80211_ATTR_IFINDEX, wdev->netdev->ifindex) ||
+     nla_put_u64(msg, NL80211_ATTR_WDEV, wdev_id(wdev)))
+  goto out;
+
+ genlmsg_end(msg, hdr);
+
+ genlmsg_multicast_netns(&nl80211_fam, wiphy_net(wiphy), msg, 0,
+    NL80211_MCGRP_MLME, GFP_KERNEL);
+ return;
+ out:
+ nlmsg_free(msg);
+}
+
 /* initialisation/exit functions */
 
 int nl80211_init(void)
diff --git a/net/wireless/nl80211.h b/net/wireless/nl80211.h
index a4073e8..49c9a48 100644
--- a/net/wireless/nl80211.h
+++ b/net/wireless/nl80211.h
@@ -5,13 +5,14 @@
 
 int nl80211_init(void);
 void nl80211_exit(void);
-void nl80211_notify_dev_rename(struct cfg80211_registered_device *rdev);
+void nl80211_notify_wiphy(struct cfg80211_registered_device *rdev,
+     enum nl80211_commands cmd);
 void nl80211_send_scan_start(struct cfg80211_registered_device *rdev,
         struct wireless_dev *wdev);
-void nl80211_send_scan_done(struct cfg80211_registered_device *rdev,
-       struct wireless_dev *wdev);
-void nl80211_send_scan_aborted(struct cfg80211_registered_device *rdev,
-          struct wireless_dev *wdev);
+struct sk_buff *nl80211_build_scan_msg(struct cfg80211_registered_device *rdev,
+           struct wireless_dev *wdev, bool aborted);
+void nl80211_send_scan_result(struct cfg80211_registered_device *rdev,
+         struct sk_buff *msg);
 void nl80211_send_sched_scan(struct cfg80211_registered_device *rdev,
         struct net_device *netdev, u32 cmd);
 void nl80211_send_sched_scan_results(struct cfg80211_registered_device *rdev,
@@ -66,12 +67,16 @@ void nl80211_send_ibss_bssid(struct cfg80211_registered_device *rdev,
 int nl80211_send_mgmt(struct cfg80211_registered_device *rdev,
         struct wireless_dev *wdev, u32 nlpid,
         int freq, int sig_dbm,
-        const u8 *buf, size_t len, gfp_t gfp);
+        const u8 *buf, size_t len, u32 flags, gfp_t gfp);
 
 void
 nl80211_radar_notify(struct cfg80211_registered_device *rdev,
-       struct cfg80211_chan_def *chandef,
+       const struct cfg80211_chan_def *chandef,
        enum nl80211_radar_event event,
        struct net_device *netdev, gfp_t gfp);
 
+void nl80211_send_ap_stopped(struct wireless_dev *wdev);
+
+void cfg80211_rdev_free_coalesce(struct cfg80211_registered_device *rdev);
+
 #endif /* __NET_WIRELESS_NL80211_H */
diff --git a/net/wireless/radiotap.c b/net/wireless/radiotap.c
index a271c27..722da61 100644
--- a/net/wireless/radiotap.c
+++ b/net/wireless/radiotap.c
@@ -124,6 +124,10 @@ int ieee80211_radiotap_iterator_init(
  /* find payload start allowing for extended bitmap(s) */
 
  if (iterator->_bitmap_shifter & (1<<IEEE80211_RADIOTAP_EXT)) {
+  if ((unsigned long)iterator->_arg -
+      (unsigned long)iterator->_rtheader + sizeof(uint32_t) >
+      (unsigned long)iterator->_max_length)
+   return -EINVAL;
   while (get_unaligned_le32(iterator->_arg) &
      (1 << IEEE80211_RADIOTAP_EXT)) {
    iterator->_arg += sizeof(uint32_t);
diff --git a/net/wireless/rdev-ops.h b/net/wireless/rdev-ops.h
index 9f15f0a..d95bbe3 100644
--- a/net/wireless/rdev-ops.h
+++ b/net/wireless/rdev-ops.h
@@ -199,7 +199,7 @@ static inline int rdev_change_station(struct cfg80211_registered_device *rdev,
 }
 
 static inline int rdev_get_station(struct cfg80211_registered_device *rdev,
-       struct net_device *dev, u8 *mac,
+       struct net_device *dev, const u8 *mac,
        struct station_info *sinfo)
 {
  int ret;
@@ -516,11 +516,12 @@ static inline void rdev_rfkill_poll(struct cfg80211_registered_device *rdev)
 
 #ifdef CONFIG_NL80211_TESTMODE
 static inline int rdev_testmode_cmd(struct cfg80211_registered_device *rdev,
+        struct wireless_dev *wdev,
         void *data, int len)
 {
  int ret;
- trace_rdev_testmode_cmd(&rdev->wiphy);
- ret = rdev->ops->testmode_cmd(&rdev->wiphy, data, len);
+ trace_rdev_testmode_cmd(&rdev->wiphy, wdev);
+ ret = rdev->ops->testmode_cmd(&rdev->wiphy, wdev, data, len);
  trace_rdev_return_int(&rdev->wiphy, ret);
  return ret;
 }
@@ -623,16 +624,12 @@ rdev_cancel_remain_on_channel(struct cfg80211_registered_device *rdev,
 
 static inline int rdev_mgmt_tx(struct cfg80211_registered_device *rdev,
           struct wireless_dev *wdev,
-          struct ieee80211_channel *chan, bool offchan,
-          unsigned int wait, const u8 *buf, size_t len,
-          bool no_cck, bool dont_wait_for_ack, u64 *cookie)
+          struct cfg80211_mgmt_tx_params *params,
+          u64 *cookie)
 {
  int ret;
- trace_rdev_mgmt_tx(&rdev->wiphy, wdev, chan, offchan,
-      wait, no_cck, dont_wait_for_ack);
- ret = rdev->ops->mgmt_tx(&rdev->wiphy, wdev, chan, offchan,
-      wait, buf, len, no_cck,
-      dont_wait_for_ack, cookie);
+ trace_rdev_mgmt_tx(&rdev->wiphy, wdev, params);
+ ret = rdev->ops->mgmt_tx(&rdev->wiphy, wdev, params, cookie);
  trace_rdev_return_int_cookie(&rdev->wiphy, ret, *cookie);
  return ret;
 }
@@ -772,13 +769,16 @@ static inline int rdev_set_rekey_data(struct cfg80211_registered_device *rdev,
 static inline int rdev_tdls_mgmt(struct cfg80211_registered_device *rdev,
      struct net_device *dev, u8 *peer,
      u8 action_code, u8 dialog_token,
-     u16 status_code, const u8 *buf, size_t len)
+     u16 status_code, u32 peer_capability,
+     const u8 *buf, size_t len)
 {
  int ret;
  trace_rdev_tdls_mgmt(&rdev->wiphy, dev, peer, action_code,
-        dialog_token, status_code, buf, len);
+        dialog_token, status_code, peer_capability,
+        buf, len);
  ret = rdev->ops->tdls_mgmt(&rdev->wiphy, dev, peer, action_code,
-       dialog_token, status_code, buf, len);
+       dialog_token, status_code, peer_capability,
+       buf, len);
  trace_rdev_return_int(&rdev->wiphy, ret);
  return ret;
 }
@@ -923,4 +923,44 @@ static inline void rdev_crit_proto_stop(struct cfg80211_registered_device *rdev,
  trace_rdev_return_void(&rdev->wiphy);
 }
 
+static inline int rdev_channel_switch(struct cfg80211_registered_device *rdev,
+          struct net_device *dev,
+          struct cfg80211_csa_settings *params)
+{
+ int ret;
+
+ trace_rdev_channel_switch(&rdev->wiphy, dev, params);
+ ret = rdev->ops->channel_switch(&rdev->wiphy, dev, params);
+ trace_rdev_return_int(&rdev->wiphy, ret);
+ return ret;
+}
+
+static inline int rdev_set_qos_map(struct cfg80211_registered_device *rdev,
+       struct net_device *dev,
+       struct cfg80211_qos_map *qos_map)
+{
+ int ret = -EOPNOTSUPP;
+
+ if (rdev->ops->set_qos_map) {
+  trace_rdev_set_qos_map(&rdev->wiphy, dev, qos_map);
+  ret = rdev->ops->set_qos_map(&rdev->wiphy, dev, qos_map);
+  trace_rdev_return_int(&rdev->wiphy, ret);
+ }
+
+ return ret;
+}
+
+static inline int
+rdev_set_ap_chanwidth(struct cfg80211_registered_device *rdev,
+        struct net_device *dev, struct cfg80211_chan_def *chandef)
+{
+ int ret;
+
+ trace_rdev_set_ap_chanwidth(&rdev->wiphy, dev, chandef);
+ ret = rdev->ops->set_ap_chanwidth(&rdev->wiphy, dev, chandef);
+ trace_rdev_return_int(&rdev->wiphy, ret);
+
+ return ret;
+}
+
 #endif /* __CFG80211_RDEV_OPS */
diff --git a/net/wireless/reg.c b/net/wireless/reg.c
index cc35fba..14c86b4 100644
--- a/net/wireless/reg.c
+++ b/net/wireless/reg.c
@@ -65,11 +65,26 @@
 #define REG_DBG_PRINT(args...)
 #endif
 
+/**
+ * enum reg_request_treatment - regulatory request treatment
+ *
+ * @REG_REQ_OK: continue processing the regulatory request
+ * @REG_REQ_IGNORE: ignore the regulatory request
+ * @REG_REQ_INTERSECT: the regulatory domain resulting from this request should
+ * be intersected with the current one.
+ * @REG_REQ_ALREADY_SET: the regulatory request will not change the current
+ * regulatory settings, and no further processing is required.
+ * @REG_REQ_USER_HINT_HANDLED: a non alpha2  user hint was handled and no
+ * further processing is required, i.e., not need to update last_request
+ * etc. This should be used for user hints that do not provide an alpha2
+ * but some other type of regulatory hint, i.e., indoor operation.
+ */
 enum reg_request_treatment {
  REG_REQ_OK,
  REG_REQ_IGNORE,
  REG_REQ_INTERSECT,
  REG_REQ_ALREADY_SET,
+ REG_REQ_USER_HINT_HANDLED,
 };
 
 static struct regulatory_request core_request_world = {
@@ -81,54 +96,89 @@ static struct regulatory_request core_request_world = {
  .country_ie_env = ENVIRON_ANY,
 };
 
-/* Receipt of information from last regulatory request */
+/*
+ * Receipt of information from last regulatory request,
+ * protected by RTNL (and can be accessed with RCU protection)
+ */
 static struct regulatory_request __rcu *last_request =
  (void __rcu *)&core_request_world;
 
 /* To trigger userspace events */
 static struct platform_device *reg_pdev;
 
-static struct device_type reg_device_type = {
- .uevent = reg_device_uevent,
-};
-
 /*
  * Central wireless core regulatory domains, we only need two,
  * the current one and a world regulatory domain in case we have no
  * information to give us an alpha2.
+ * (protected by RTNL, can be read under RCU)
  */
 const struct ieee80211_regdomain __rcu *cfg80211_regdomain;
 
 /*
- * Protects static reg.c components:
- * - cfg80211_regdomain (if not used with RCU)
- * - cfg80211_world_regdom
- * - last_request (if not used with RCU)
- * - reg_num_devs_support_basehint
- */
-static DEFINE_MUTEX(reg_mutex);
-
-/*
  * Number of devices that registered to the core
  * that support cellular base station regulatory hints
+ * (protected by RTNL)
  */
 static int reg_num_devs_support_basehint;
 
-static inline void assert_reg_lock(void)
-{
- lockdep_assert_held(&reg_mutex);
-}
+/*
+ * State variable indicating if the platform on which the devices
+ * are attached is operating in an indoor environment. The state variable
+ * is relevant for all registered devices.
+ * (protected by RTNL)
+ */
+static bool reg_is_indoor;
 
 static const struct ieee80211_regdomain *get_cfg80211_regdom(void)
 {
- return rcu_dereference_protected(cfg80211_regdomain,
-      lockdep_is_held(&reg_mutex));
+ return rtnl_dereference(cfg80211_regdomain);
 }
 
 static const struct ieee80211_regdomain *get_wiphy_regdom(struct wiphy *wiphy)
 {
- return rcu_dereference_protected(wiphy->regd,
-      lockdep_is_held(&reg_mutex));
+ return rtnl_dereference(wiphy->regd);
+}
+
+static const char *reg_dfs_region_str(enum nl80211_dfs_regions dfs_region)
+{
+ switch (dfs_region) {
+ case NL80211_DFS_UNSET:
+  return "unset";
+ case NL80211_DFS_FCC:
+  return "FCC";
+ case NL80211_DFS_ETSI:
+  return "ETSI";
+ case NL80211_DFS_JP:
+  return "JP";
+ }
+ return "Unknown";
+}
+
+enum nl80211_dfs_regions reg_get_dfs_region(struct wiphy *wiphy)
+{
+ const struct ieee80211_regdomain *regd = NULL;
+ const struct ieee80211_regdomain *wiphy_regd = NULL;
+
+ regd = get_cfg80211_regdom();
+ if (!wiphy)
+  goto out;
+
+ wiphy_regd = get_wiphy_regdom(wiphy);
+ if (!wiphy_regd)
+  goto out;
+
+ if (wiphy_regd->dfs_region == regd->dfs_region)
+  goto out;
+
+ REG_DBG_PRINT("%s: device specific dfs_region "
+        "(%s) disagrees with cfg80211's "
+        "central dfs_region (%s)\n",
+        dev_name(&wiphy->dev),
+        reg_dfs_region_str(wiphy_regd->dfs_region),
+        reg_dfs_region_str(regd->dfs_region));
+
+out:
+ return regd->dfs_region;
 }
 
 static void rcu_free_regdom(const struct ieee80211_regdomain *r)
@@ -140,8 +190,7 @@ static void rcu_free_regdom(const struct ieee80211_regdomain *r)
 
 static struct regulatory_request *get_last_request(void)
 {
- return rcu_dereference_check(last_request,
-         lockdep_is_held(&reg_mutex));
+ return rcu_dereference_rtnl(last_request);
 }
 
 /* Used to queue up regulatory hints */
@@ -175,31 +224,36 @@ static const struct ieee80211_regdomain world_regdom = {
   REG_RULE(2412-10, 2462+10, 40, 6, 20, 0),
   /* IEEE 802.11b/g, channels 12..13. */
   REG_RULE(2467-10, 2472+10, 40, 6, 20,
-   NL80211_RRF_PASSIVE_SCAN |
-   NL80211_RRF_NO_IBSS),
+   NL80211_RRF_NO_IR),
   /* IEEE 802.11 channel 14 - Only JP enables
    * this and for 802.11b only */
   REG_RULE(2484-10, 2484+10, 20, 6, 20,
-   NL80211_RRF_PASSIVE_SCAN |
-   NL80211_RRF_NO_IBSS |
+   NL80211_RRF_NO_IR |
    NL80211_RRF_NO_OFDM),
   /* IEEE 802.11a, channel 36..48 */
-  REG_RULE(5180-10, 5240+10, 80, 6, 20,
-                        NL80211_RRF_PASSIVE_SCAN |
-                        NL80211_RRF_NO_IBSS),
+  REG_RULE(5180-10, 5240+10, 160, 6, 20,
+                        NL80211_RRF_NO_IR),
+
+  /* IEEE 802.11a, channel 52..64 - DFS required */
+  REG_RULE(5260-10, 5320+10, 160, 6, 20,
+   NL80211_RRF_NO_IR |
+   NL80211_RRF_DFS),
 
-  /* NB: 5260 MHz - 5700 MHz requires DFS */
+  /* IEEE 802.11a, channel 100..144 - DFS required */
+  REG_RULE(5500-10, 5720+10, 160, 6, 20,
+   NL80211_RRF_NO_IR |
+   NL80211_RRF_DFS),
 
   /* IEEE 802.11a, channel 149..165 */
   REG_RULE(5745-10, 5825+10, 80, 6, 20,
-   NL80211_RRF_PASSIVE_SCAN |
-   NL80211_RRF_NO_IBSS),
+   NL80211_RRF_NO_IR),
 
   /* IEEE 802.11ad (60gHz), channels 1..3 */
   REG_RULE(56160+2160*1-1080, 56160+2160*3+1080, 2160, 0, 0, 0),
  }
 };
 
+/* protected by RTNL */
 static const struct ieee80211_regdomain *cfg80211_world_regdom =
  &world_regdom;
 
@@ -209,13 +263,38 @@ static char user_alpha2[2];
 module_param(ieee80211_regdom, charp, 0444);
 MODULE_PARM_DESC(ieee80211_regdom, "IEEE 802.11 regulatory domain code");
 
+static void reg_free_request(struct regulatory_request *request)
+{
+ if (request != get_last_request())
+  kfree(request);
+}
+
+static void reg_free_last_request(void)
+{
+ struct regulatory_request *lr = get_last_request();
+
+ if (lr != &core_request_world && lr)
+  kfree_rcu(lr, rcu_head);
+}
+
+static void reg_update_last_request(struct regulatory_request *request)
+{
+ struct regulatory_request *lr;
+
+ lr = get_last_request();
+ if (lr == request)
+  return;
+
+ reg_free_last_request();
+ rcu_assign_pointer(last_request, request);
+}
+
 static void reset_regdomains(bool full_reset,
         const struct ieee80211_regdomain *new_regdom)
 {
  const struct ieee80211_regdomain *r;
- struct regulatory_request *lr;
 
- assert_reg_lock();
+ ASSERT_RTNL();
 
  r = get_cfg80211_regdom();
 
@@ -236,10 +315,7 @@ static void reset_regdomains(bool full_reset,
  if (!full_reset)
   return;
 
- lr = get_last_request();
- if (lr != &core_request_world && lr)
-  kfree_rcu(lr, rcu_head);
- rcu_assign_pointer(last_request, &core_request_world);
+ reg_update_last_request(&core_request_world);
 }
 
 /*
@@ -377,7 +453,7 @@ static void reg_regdb_search(struct work_struct *work)
  const struct ieee80211_regdomain *curdom, *regdom = NULL;
  int i;
 
- mutex_lock(&cfg80211_mutex);
+ rtnl_lock();
 
  mutex_lock(&reg_regdb_search_mutex);
  while (!list_empty(&reg_regdb_search_list)) {
@@ -402,7 +478,7 @@ static void reg_regdb_search(struct work_struct *work)
  if (!IS_ERR_OR_NULL(regdom))
   set_regdom(regdom);
 
- mutex_unlock(&cfg80211_mutex);
+ rtnl_unlock();
 }
 
 static DECLARE_WORK(reg_regdb_work, reg_regdb_search);
@@ -440,11 +516,16 @@ static inline void reg_regdb_query(const char *alpha2) {}
 
 /*
  * This lets us keep regulatory code which is updated on a regulatory
- * basis in userspace. Country information is filled in by
- * reg_device_uevent
+ * basis in userspace.
  */
 static int call_crda(const char *alpha2)
 {
+ char country[12];
+ char *env[] = { country, NULL };
+
+ snprintf(country, sizeof(country), "COUNTRY=%c%c",
+   alpha2[0], alpha2[1]);
+
  if (!is_world_regdom((char *) alpha2))
   pr_info("Calling CRDA for country: %c%c\n",
    alpha2[0], alpha2[1]);
@@ -454,10 +535,18 @@ static int call_crda(const char *alpha2)
  /* query internal regulatory database (if it exists) */
  reg_regdb_query(alpha2);
 
- return kobject_uevent(&reg_pdev->dev.kobj, KOBJ_CHANGE);
+ return kobject_uevent_env(&reg_pdev->dev.kobj, KOBJ_CHANGE, env);
+}
+
+static enum reg_request_treatment
+reg_call_crda(struct regulatory_request *request)
+{
+ if (call_crda(request->alpha2))
+  return REG_REQ_IGNORE;
+ return REG_REQ_OK;
 }
 
-static bool reg_is_valid_request(const char *alpha2)
+bool reg_is_valid_request(const char *alpha2)
 {
  struct regulatory_request *lr = get_last_request();
 
@@ -467,6 +556,71 @@ static bool reg_is_valid_request(const char *alpha2)
  return alpha2_equal(lr->alpha2, alpha2);
 }
 
+static const struct ieee80211_regdomain *reg_get_regdomain(struct wiphy *wiphy)
+{
+ struct regulatory_request *lr = get_last_request();
+
+ /*
+  * Follow the driver's regulatory domain, if present, unless a country
+  * IE has been processed or a user wants to help complaince further
+  */
+ if (lr->initiator != NL80211_REGDOM_SET_BY_COUNTRY_IE &&
+     lr->initiator != NL80211_REGDOM_SET_BY_USER &&
+     wiphy->regd)
+  return get_wiphy_regdom(wiphy);
+
+ return get_cfg80211_regdom();
+}
+
+unsigned int reg_get_max_bandwidth(const struct ieee80211_regdomain *rd,
+       const struct ieee80211_reg_rule *rule)
+{
+ const struct ieee80211_freq_range *freq_range = &rule->freq_range;
+ const struct ieee80211_freq_range *freq_range_tmp;
+ const struct ieee80211_reg_rule *tmp;
+ u32 start_freq, end_freq, idx, no;
+
+ for (idx = 0; idx < rd->n_reg_rules; idx++)
+  if (rule == &rd->reg_rules[idx])
+   break;
+
+ if (idx == rd->n_reg_rules)
+  return 0;
+
+ /* get start_freq */
+ no = idx;
+
+ while (no) {
+  tmp = &rd->reg_rules[--no];
+  freq_range_tmp = &tmp->freq_range;
+
+  if (freq_range_tmp->end_freq_khz < freq_range->start_freq_khz)
+   break;
+
+  freq_range = freq_range_tmp;
+ }
+
+ start_freq = freq_range->start_freq_khz;
+
+ /* get end_freq */
+ freq_range = &rule->freq_range;
+ no = idx;
+
+ while (no < rd->n_reg_rules - 1) {
+  tmp = &rd->reg_rules[++no];
+  freq_range_tmp = &tmp->freq_range;
+
+  if (freq_range_tmp->start_freq_khz > freq_range->end_freq_khz)
+   break;
+
+  freq_range = freq_range_tmp;
+ }
+
+ end_freq = freq_range->end_freq_khz;
+
+ return end_freq - start_freq;
+}
+
 /* Sanity check on a regulatory rule */
 static bool is_valid_reg_rule(const struct ieee80211_reg_rule *rule)
 {
@@ -558,10 +712,26 @@ static bool freq_in_rule_band(const struct ieee80211_freq_range *freq_range,
 }
 
 /*
+ * Later on we can perhaps use the more restrictive DFS
+ * region but we don't have information for that yet so
+ * for now simply disallow conflicts.
+ */
+static enum nl80211_dfs_regions
+reg_intersect_dfs_region(const enum nl80211_dfs_regions dfs_region1,
+    const enum nl80211_dfs_regions dfs_region2)
+{
+ if (dfs_region1 != dfs_region2)
+  return NL80211_DFS_UNSET;
+ return dfs_region1;
+}
+
+/*
  * Helper for regdom_intersect(), this does the real
  * mathematical intersection fun
  */
-static int reg_rules_intersect(const struct ieee80211_reg_rule *rule1,
+static int reg_rules_intersect(const struct ieee80211_regdomain *rd1,
+          const struct ieee80211_regdomain *rd2,
+          const struct ieee80211_reg_rule *rule1,
           const struct ieee80211_reg_rule *rule2,
           struct ieee80211_reg_rule *intersected_rule)
 {
@@ -569,7 +739,7 @@ static int reg_rules_intersect(const struct ieee80211_reg_rule *rule1,
  struct ieee80211_freq_range *freq_range;
  const struct ieee80211_power_rule *power_rule1, *power_rule2;
  struct ieee80211_power_rule *power_rule;
- u32 freq_diff;
+ u32 freq_diff, max_bandwidth1, max_bandwidth2;
 
  freq_range1 = &rule1->freq_range;
  freq_range2 = &rule2->freq_range;
@@ -583,8 +753,32 @@ static int reg_rules_intersect(const struct ieee80211_reg_rule *rule1,
       freq_range2->start_freq_khz);
  freq_range->end_freq_khz = min(freq_range1->end_freq_khz,
            freq_range2->end_freq_khz);
- freq_range->max_bandwidth_khz = min(freq_range1->max_bandwidth_khz,
-         freq_range2->max_bandwidth_khz);
+
+ max_bandwidth1 = freq_range1->max_bandwidth_khz;
+ max_bandwidth2 = freq_range2->max_bandwidth_khz;
+
+ if (rule1->flags & NL80211_RRF_AUTO_BW)
+  max_bandwidth1 = reg_get_max_bandwidth(rd1, rule1);
+ if (rule2->flags & NL80211_RRF_AUTO_BW)
+  max_bandwidth2 = reg_get_max_bandwidth(rd2, rule2);
+
+ freq_range->max_bandwidth_khz = min(max_bandwidth1, max_bandwidth2);
+
+ intersected_rule->flags = rule1->flags | rule2->flags;
+
+ /*
+  * In case NL80211_RRF_AUTO_BW requested for both rules
+  * set AUTO_BW in intersected rule also. Next we will
+  * calculate BW correctly in handle_channel function.
+  * In other case remove AUTO_BW flag while we calculate
+  * maximum bandwidth correctly and auto calculation is
+  * not required.
+  */
+ if ((rule1->flags & NL80211_RRF_AUTO_BW) &&
+     (rule2->flags & NL80211_RRF_AUTO_BW))
+  intersected_rule->flags |= NL80211_RRF_AUTO_BW;
+ else
+  intersected_rule->flags &= ~NL80211_RRF_AUTO_BW;
 
  freq_diff = freq_range->end_freq_khz - freq_range->start_freq_khz;
  if (freq_range->max_bandwidth_khz > freq_diff)
@@ -595,7 +789,8 @@ static int reg_rules_intersect(const struct ieee80211_reg_rule *rule1,
  power_rule->max_antenna_gain = min(power_rule1->max_antenna_gain,
   power_rule2->max_antenna_gain);
 
- intersected_rule->flags = rule1->flags | rule2->flags;
+ intersected_rule->dfs_cac_ms = max(rule1->dfs_cac_ms,
+        rule2->dfs_cac_ms);
 
  if (!is_valid_reg_rule(intersected_rule))
   return -EINVAL;
@@ -644,7 +839,8 @@ regdom_intersect(const struct ieee80211_regdomain *rd1,
   rule1 = &rd1->reg_rules[x];
   for (y = 0; y < rd2->n_reg_rules; y++) {
    rule2 = &rd2->reg_rules[y];
-   if (!reg_rules_intersect(rule1, rule2, &dummy_rule))
+   if (!reg_rules_intersect(rd1, rd2, rule1, rule2,
+       &dummy_rule))
     num_rules++;
   }
  }
@@ -669,7 +865,8 @@ regdom_intersect(const struct ieee80211_regdomain *rd1,
     * a memcpy()
     */
    intersected_rule = &rd->reg_rules[rule_idx];
-   r = reg_rules_intersect(rule1, rule2, intersected_rule);
+   r = reg_rules_intersect(rd1, rd2, rule1, rule2,
+      intersected_rule);
    /*
     * No need to memset here the intersected rule here as
     * we're not using the stack anymore
@@ -688,6 +885,8 @@ regdom_intersect(const struct ieee80211_regdomain *rd1,
  rd->n_reg_rules = num_rules;
  rd->alpha2[0] = '9';
  rd->alpha2[1] = '8';
+ rd->dfs_region = reg_intersect_dfs_region(rd1->dfs_region,
+        rd2->dfs_region);
 
  return rd;
 }
@@ -699,14 +898,14 @@ regdom_intersect(const struct ieee80211_regdomain *rd1,
 static u32 map_regdom_flags(u32 rd_flags)
 {
  u32 channel_flags = 0;
- if (rd_flags & NL80211_RRF_PASSIVE_SCAN)
-  channel_flags |= IEEE80211_CHAN_PASSIVE_SCAN;
- if (rd_flags & NL80211_RRF_NO_IBSS)
-  channel_flags |= IEEE80211_CHAN_NO_IBSS;
+ if (rd_flags & NL80211_RRF_NO_IR_ALL)
+  channel_flags |= IEEE80211_CHAN_NO_IR;
  if (rd_flags & NL80211_RRF_DFS)
   channel_flags |= IEEE80211_CHAN_RADAR;
  if (rd_flags & NL80211_RRF_NO_OFDM)
   channel_flags |= IEEE80211_CHAN_NO_OFDM;
+ if (rd_flags & NL80211_RRF_NO_OUTDOOR)
+  channel_flags |= IEEE80211_CHAN_INDOOR_ONLY;
  return channel_flags;
 }
 
@@ -752,66 +951,68 @@ const struct ieee80211_reg_rule *freq_reg_info(struct wiphy *wiphy,
             u32 center_freq)
 {
  const struct ieee80211_regdomain *regd;
- struct regulatory_request *lr = get_last_request();
 
- /*
-  * Follow the driver's regulatory domain, if present, unless a country
-  * IE has been processed or a user wants to help complaince further
-  */
- if (lr->initiator != NL80211_REGDOM_SET_BY_COUNTRY_IE &&
-     lr->initiator != NL80211_REGDOM_SET_BY_USER &&
-     wiphy->regd)
-  regd = get_wiphy_regdom(wiphy);
- else
-  regd = get_cfg80211_regdom();
+ regd = reg_get_regdomain(wiphy);
 
  return freq_reg_info_regd(wiphy, center_freq, regd);
 }
 EXPORT_SYMBOL(freq_reg_info);
 
-#ifdef CONFIG_CFG80211_REG_DEBUG
-static const char *reg_initiator_name(enum nl80211_reg_initiator initiator)
+const char *reg_initiator_name(enum nl80211_reg_initiator initiator)
 {
  switch (initiator) {
  case NL80211_REGDOM_SET_BY_CORE:
-  return "Set by core";
+  return "core";
  case NL80211_REGDOM_SET_BY_USER:
-  return "Set by user";
+  return "user";
  case NL80211_REGDOM_SET_BY_DRIVER:
-  return "Set by driver";
+  return "driver";
  case NL80211_REGDOM_SET_BY_COUNTRY_IE:
-  return "Set by country IE";
+  return "country IE";
  default:
   WARN_ON(1);
-  return "Set by bug";
+  return "bug";
  }
 }
+EXPORT_SYMBOL(reg_initiator_name);
 
-static void chan_reg_rule_print_dbg(struct ieee80211_channel *chan,
+#ifdef CONFIG_CFG80211_REG_DEBUG
+static void chan_reg_rule_print_dbg(const struct ieee80211_regdomain *regd,
+        struct ieee80211_channel *chan,
         const struct ieee80211_reg_rule *reg_rule)
 {
  const struct ieee80211_power_rule *power_rule;
  const struct ieee80211_freq_range *freq_range;
- char max_antenna_gain[32];
+ char max_antenna_gain[32], bw[32];
 
  power_rule = &reg_rule->power_rule;
  freq_range = &reg_rule->freq_range;
 
  if (!power_rule->max_antenna_gain)
-  snprintf(max_antenna_gain, 32, "N/A");
+  snprintf(max_antenna_gain, sizeof(max_antenna_gain), "N/A");
+ else
+  snprintf(max_antenna_gain, sizeof(max_antenna_gain), "%d",
+    power_rule->max_antenna_gain);
+
+ if (reg_rule->flags & NL80211_RRF_AUTO_BW)
+  snprintf(bw, sizeof(bw), "%d KHz, %d KHz AUTO",
+    freq_range->max_bandwidth_khz,
+    reg_get_max_bandwidth(regd, reg_rule));
  else
-  snprintf(max_antenna_gain, 32, "%d", power_rule->max_antenna_gain);
+  snprintf(bw, sizeof(bw), "%d KHz",
+    freq_range->max_bandwidth_khz);
 
  REG_DBG_PRINT("Updating information on frequency %d MHz with regulatory rule:\n",
         chan->center_freq);
 
- REG_DBG_PRINT("%d KHz - %d KHz @ %d KHz), (%s mBi, %d mBm)\n",
+ REG_DBG_PRINT("%d KHz - %d KHz @ %s), (%s mBi, %d mBm)\n",
         freq_range->start_freq_khz, freq_range->end_freq_khz,
-        freq_range->max_bandwidth_khz, max_antenna_gain,
+        bw, max_antenna_gain,
         power_rule->max_eirp);
 }
 #else
-static void chan_reg_rule_print_dbg(struct ieee80211_channel *chan,
+static void chan_reg_rule_print_dbg(const struct ieee80211_regdomain *regd,
+        struct ieee80211_channel *chan,
         const struct ieee80211_reg_rule *reg_rule)
 {
  return;
@@ -833,6 +1034,8 @@ static void handle_channel(struct wiphy *wiphy,
  const struct ieee80211_freq_range *freq_range = NULL;
  struct wiphy *request_wiphy = NULL;
  struct regulatory_request *lr = get_last_request();
+ const struct ieee80211_regdomain *regd;
+ u32 max_bandwidth_khz;
 
  request_wiphy = wiphy_idx_to_wiphy(lr->wiphy_idx);
 
@@ -854,26 +1057,42 @@ static void handle_channel(struct wiphy *wiphy,
       PTR_ERR(reg_rule) == -ERANGE)
    return;
 
-  REG_DBG_PRINT("Disabling freq %d MHz\n", chan->center_freq);
-  chan->flags |= IEEE80211_CHAN_DISABLED;
+  if (lr->initiator == NL80211_REGDOM_SET_BY_DRIVER &&
+      request_wiphy && request_wiphy == wiphy &&
+      request_wiphy->regulatory_flags & REGULATORY_STRICT_REG) {
+   REG_DBG_PRINT("Disabling freq %d MHz for good\n",
+          chan->center_freq);
+   chan->orig_flags |= IEEE80211_CHAN_DISABLED;
+   chan->flags = chan->orig_flags;
+  } else {
+   REG_DBG_PRINT("Disabling freq %d MHz\n",
+          chan->center_freq);
+   chan->flags |= IEEE80211_CHAN_DISABLED;
+  }
   return;
  }
 
- chan_reg_rule_print_dbg(chan, reg_rule);
+ regd = reg_get_regdomain(wiphy);
+ chan_reg_rule_print_dbg(regd, chan, reg_rule);
 
  power_rule = &reg_rule->power_rule;
  freq_range = &reg_rule->freq_range;
 
- if (freq_range->max_bandwidth_khz < MHZ_TO_KHZ(40))
+ max_bandwidth_khz = freq_range->max_bandwidth_khz;
+ /* Check if auto calculation requested */
+ if (reg_rule->flags & NL80211_RRF_AUTO_BW)
+  max_bandwidth_khz = reg_get_max_bandwidth(regd, reg_rule);
+
+ if (max_bandwidth_khz < MHZ_TO_KHZ(40))
   bw_flags = IEEE80211_CHAN_NO_HT40;
- if (freq_range->max_bandwidth_khz < MHZ_TO_KHZ(80))
+ if (max_bandwidth_khz < MHZ_TO_KHZ(80))
   bw_flags |= IEEE80211_CHAN_NO_80MHZ;
- if (freq_range->max_bandwidth_khz < MHZ_TO_KHZ(160))
+ if (max_bandwidth_khz < MHZ_TO_KHZ(160))
   bw_flags |= IEEE80211_CHAN_NO_160MHZ;
 
  if (lr->initiator == NL80211_REGDOM_SET_BY_DRIVER &&
      request_wiphy && request_wiphy == wiphy &&
-     request_wiphy->flags & WIPHY_FLAG_STRICT_REGULATORY) {
+     request_wiphy->regulatory_flags & REGULATORY_STRICT_REG) {
   /*
    * This guarantees the driver's requested regulatory domain
    * will always be used as a base for further regulatory
@@ -885,6 +1104,13 @@ static void handle_channel(struct wiphy *wiphy,
    (int) MBI_TO_DBI(power_rule->max_antenna_gain);
   chan->max_reg_power = chan->max_power = chan->orig_mpwr =
    (int) MBM_TO_DBM(power_rule->max_eirp);
+
+  if (chan->flags & IEEE80211_CHAN_RADAR) {
+   chan->dfs_cac_ms = IEEE80211_DFS_MIN_CAC_TIME_MS;
+   if (reg_rule->dfs_cac_ms)
+    chan->dfs_cac_ms = reg_rule->dfs_cac_ms;
+  }
+
   return;
  }
 
@@ -897,15 +1123,21 @@ static void handle_channel(struct wiphy *wiphy,
   min_t(int, chan->orig_mag,
         MBI_TO_DBI(power_rule->max_antenna_gain));
  chan->max_reg_power = (int) MBM_TO_DBM(power_rule->max_eirp);
+
+ if (chan->flags & IEEE80211_CHAN_RADAR) {
+  if (reg_rule->dfs_cac_ms)
+   chan->dfs_cac_ms = reg_rule->dfs_cac_ms;
+  else
+   chan->dfs_cac_ms = IEEE80211_DFS_MIN_CAC_TIME_MS;
+ }
+
  if (chan->orig_mpwr) {
   /*
-   * Devices that have their own custom regulatory domain
-   * but also use WIPHY_FLAG_STRICT_REGULATORY will follow the
-   * passed country IE power settings.
+   * Devices that use REGULATORY_COUNTRY_IE_FOLLOW_POWER
+   * will always follow the passed country IE power settings.
    */
   if (initiator == NL80211_REGDOM_SET_BY_COUNTRY_IE &&
-      wiphy->flags & WIPHY_FLAG_CUSTOM_REGULATORY &&
-      wiphy->flags & WIPHY_FLAG_STRICT_REGULATORY)
+      wiphy->regulatory_flags & REGULATORY_COUNTRY_IE_FOLLOW_POWER)
    chan->max_power = chan->max_reg_power;
   else
    chan->max_power = min(chan->orig_mpwr,
@@ -934,18 +1166,19 @@ static bool reg_request_cell_base(struct regulatory_request *request)
  return request->user_reg_hint_type == NL80211_USER_REG_HINT_CELL_BASE;
 }
 
-bool reg_last_request_cell_base(void)
+static bool reg_request_indoor(struct regulatory_request *request)
 {
- bool val;
-
- mutex_lock(&reg_mutex);
- val = reg_request_cell_base(get_last_request());
- mutex_unlock(&reg_mutex);
+ if (request->initiator != NL80211_REGDOM_SET_BY_USER)
+  return false;
+ return request->user_reg_hint_type == NL80211_USER_REG_HINT_INDOOR;
+}
 
- return val;
+bool reg_last_request_cell_base(void)
+{
+ return reg_request_cell_base(get_last_request());
 }
 
-#ifdef CONFIG_CFG80211_CERTIFICATION_ONUS
+#ifdef CONFIG_CFG80211_REG_CELLULAR_HINTS
 /* Core specific check */
 static enum reg_request_treatment
 reg_ignore_cell_hint(struct regulatory_request *pending_request)
@@ -979,6 +1212,13 @@ static bool reg_dev_ignore_cell_hint(struct wiphy *wiphy)
 }
 #endif
 
+static bool wiphy_strict_alpha2_regd(struct wiphy *wiphy)
+{
+ if (wiphy->regulatory_flags & REGULATORY_STRICT_REG &&
+     !(wiphy->regulatory_flags & REGULATORY_CUSTOM_REG))
+  return true;
+ return false;
+}
 
 static bool ignore_reg_update(struct wiphy *wiphy,
          enum nl80211_reg_initiator initiator)
@@ -986,14 +1226,17 @@ static bool ignore_reg_update(struct wiphy *wiphy,
  struct regulatory_request *lr = get_last_request();
 
  if (!lr) {
-  REG_DBG_PRINT("Ignoring regulatory request %s since last_request is not set\n",
+  REG_DBG_PRINT("Ignoring regulatory request set by %s "
+         "since last_request is not set\n",
          reg_initiator_name(initiator));
   return true;
  }
 
  if (initiator == NL80211_REGDOM_SET_BY_CORE &&
-     wiphy->flags & WIPHY_FLAG_CUSTOM_REGULATORY) {
-  REG_DBG_PRINT("Ignoring regulatory request %s since the driver uses its own custom regulatory domain\n",
+     wiphy->regulatory_flags & REGULATORY_CUSTOM_REG) {
+  REG_DBG_PRINT("Ignoring regulatory request set by %s "
+         "since the driver uses its own custom "
+         "regulatory domain\n",
          reg_initiator_name(initiator));
   return true;
  }
@@ -1002,10 +1245,12 @@ static bool ignore_reg_update(struct wiphy *wiphy,
   * wiphy->regd will be set once the device has its own
   * desired regulatory domain set
   */
- if (wiphy->flags & WIPHY_FLAG_STRICT_REGULATORY && !wiphy->regd &&
+ if (wiphy_strict_alpha2_regd(wiphy) && !wiphy->regd &&
      initiator != NL80211_REGDOM_SET_BY_COUNTRY_IE &&
      !is_world_regdom(lr->alpha2)) {
-  REG_DBG_PRINT("Ignoring regulatory request %s since the driver requires its own regulatory domain to be set first\n",
+  REG_DBG_PRINT("Ignoring regulatory request set by %s "
+         "since the driver requires its own regulatory "
+         "domain to be set first\n",
          reg_initiator_name(initiator));
   return true;
  }
@@ -1026,7 +1271,7 @@ static bool reg_is_world_roaming(struct wiphy *wiphy)
   return true;
 
  if (lr && lr->initiator != NL80211_REGDOM_SET_BY_COUNTRY_IE &&
-     wiphy->flags & WIPHY_FLAG_CUSTOM_REGULATORY)
+     wiphy->regulatory_flags & REGULATORY_CUSTOM_REG)
   return true;
 
  return false;
@@ -1054,19 +1299,14 @@ static void handle_reg_beacon(struct wiphy *wiphy, unsigned int chan_idx,
  if (!reg_is_world_roaming(wiphy))
   return;
 
- if (wiphy->flags & WIPHY_FLAG_DISABLE_BEACON_HINTS)
+ if (wiphy->regulatory_flags & REGULATORY_DISABLE_BEACON_HINTS)
   return;
 
  chan_before.center_freq = chan->center_freq;
  chan_before.flags = chan->flags;
 
- if (chan->flags & IEEE80211_CHAN_PASSIVE_SCAN) {
-  chan->flags &= ~IEEE80211_CHAN_PASSIVE_SCAN;
-  channel_changed = true;
- }
-
- if (chan->flags & IEEE80211_CHAN_NO_IBSS) {
-  chan->flags &= ~IEEE80211_CHAN_NO_IBSS;
+ if (chan->flags & IEEE80211_CHAN_NO_IR) {
+  chan->flags &= ~IEEE80211_CHAN_NO_IR;
   channel_changed = true;
  }
 
@@ -1199,14 +1439,30 @@ static void reg_process_ht_flags(struct wiphy *wiphy)
   reg_process_ht_flags_band(wiphy, wiphy->bands[band]);
 }
 
+static void reg_call_notifier(struct wiphy *wiphy,
+         struct regulatory_request *request)
+{
+ if (wiphy->reg_notifier)
+  wiphy->reg_notifier(wiphy, request);
+}
+
 static void wiphy_update_regulatory(struct wiphy *wiphy,
         enum nl80211_reg_initiator initiator)
 {
  enum ieee80211_band band;
  struct regulatory_request *lr = get_last_request();
 
- if (ignore_reg_update(wiphy, initiator))
+ if (ignore_reg_update(wiphy, initiator)) {
+  /*
+   * Regulatory updates set by CORE are ignored for custom
+   * regulatory cards. Let us notify the changes to the driver,
+   * as some drivers used this to restore its orig_* reg domain.
+   */
+  if (initiator == NL80211_REGDOM_SET_BY_CORE &&
+      wiphy->regulatory_flags & REGULATORY_CUSTOM_REG)
+   reg_call_notifier(wiphy, lr);
   return;
+ }
 
  lr->dfs_region = get_cfg80211_regdom()->dfs_region;
 
@@ -1215,9 +1471,7 @@ static void wiphy_update_regulatory(struct wiphy *wiphy,
 
  reg_process_beacons(wiphy);
  reg_process_ht_flags(wiphy);
-
- if (wiphy->reg_notifier)
-  wiphy->reg_notifier(wiphy, lr);
+ reg_call_notifier(wiphy, lr);
 }
 
 static void update_all_wiphy_regulatory(enum nl80211_reg_initiator initiator)
@@ -1225,20 +1479,11 @@ static void update_all_wiphy_regulatory(enum nl80211_reg_initiator initiator)
  struct cfg80211_registered_device *rdev;
  struct wiphy *wiphy;
 
- assert_cfg80211_lock();
+ ASSERT_RTNL();
 
  list_for_each_entry(rdev, &cfg80211_rdev_list, list) {
   wiphy = &rdev->wiphy;
   wiphy_update_regulatory(wiphy, initiator);
-  /*
-   * Regulatory updates set by CORE are ignored for custom
-   * regulatory cards. Let us notify the changes to the driver,
-   * as some drivers used this to restore its orig_* reg domain.
-   */
-  if (initiator == NL80211_REGDOM_SET_BY_CORE &&
-      wiphy->flags & WIPHY_FLAG_CUSTOM_REGULATORY &&
-      wiphy->reg_notifier)
-   wiphy->reg_notifier(wiphy, get_last_request());
  }
 }
 
@@ -1250,6 +1495,7 @@ static void handle_channel_custom(struct wiphy *wiphy,
  const struct ieee80211_reg_rule *reg_rule = NULL;
  const struct ieee80211_power_rule *power_rule = NULL;
  const struct ieee80211_freq_range *freq_range = NULL;
+ u32 max_bandwidth_khz;
 
  reg_rule = freq_reg_info_regd(wiphy, MHZ_TO_KHZ(chan->center_freq),
           regd);
@@ -1257,20 +1503,26 @@ static void handle_channel_custom(struct wiphy *wiphy,
  if (IS_ERR(reg_rule)) {
   REG_DBG_PRINT("Disabling freq %d MHz as custom regd has no rule that fits it\n",
          chan->center_freq);
-  chan->flags = IEEE80211_CHAN_DISABLED;
+  chan->orig_flags |= IEEE80211_CHAN_DISABLED;
+  chan->flags = chan->orig_flags;
   return;
  }
 
- chan_reg_rule_print_dbg(chan, reg_rule);
+ chan_reg_rule_print_dbg(regd, chan, reg_rule);
 
  power_rule = &reg_rule->power_rule;
  freq_range = &reg_rule->freq_range;
 
- if (freq_range->max_bandwidth_khz < MHZ_TO_KHZ(40))
+ max_bandwidth_khz = freq_range->max_bandwidth_khz;
+ /* Check if auto calculation requested */
+ if (reg_rule->flags & NL80211_RRF_AUTO_BW)
+  max_bandwidth_khz = reg_get_max_bandwidth(regd, reg_rule);
+
+ if (max_bandwidth_khz < MHZ_TO_KHZ(40))
   bw_flags = IEEE80211_CHAN_NO_HT40;
- if (freq_range->max_bandwidth_khz < MHZ_TO_KHZ(80))
+ if (max_bandwidth_khz < MHZ_TO_KHZ(80))
   bw_flags |= IEEE80211_CHAN_NO_80MHZ;
- if (freq_range->max_bandwidth_khz < MHZ_TO_KHZ(160))
+ if (max_bandwidth_khz < MHZ_TO_KHZ(160))
   bw_flags |= IEEE80211_CHAN_NO_160MHZ;
 
  chan->flags |= map_regdom_flags(reg_rule->flags) | bw_flags;
@@ -1299,6 +1551,10 @@ void wiphy_apply_custom_regulatory(struct wiphy *wiphy,
  enum ieee80211_band band;
  unsigned int bands_set = 0;
 
+ WARN(!(wiphy->regulatory_flags & REGULATORY_CUSTOM_REG),
+      "wiphy should have REGULATORY_CUSTOM_REG\n");
+ wiphy->regulatory_flags |= REGULATORY_CUSTOM_REG;
+
  for (band = 0; band < IEEE80211_NUM_BANDS; band++) {
   if (!wiphy->bands[band])
    continue;
@@ -1314,251 +1570,338 @@ void wiphy_apply_custom_regulatory(struct wiphy *wiphy,
 }
 EXPORT_SYMBOL(wiphy_apply_custom_regulatory);
 
-/* This has the logic which determines when a new request
- * should be ignored. */
-static enum reg_request_treatment
-get_reg_request_treatment(struct wiphy *wiphy,
-     struct regulatory_request *pending_request)
+static void reg_set_request_processed(void)
 {
- struct wiphy *last_wiphy = NULL;
+ bool need_more_processing = false;
  struct regulatory_request *lr = get_last_request();
 
- /* All initial requests are respected */
- if (!lr)
-  return REG_REQ_OK;
+ lr->processed = true;
 
- switch (pending_request->initiator) {
- case NL80211_REGDOM_SET_BY_CORE:
-  return REG_REQ_OK;
- case NL80211_REGDOM_SET_BY_COUNTRY_IE:
-  if (reg_request_cell_base(lr)) {
-   /* Trust a Cell base station over the AP's country IE */
-   if (regdom_changes(pending_request->alpha2))
-    return REG_REQ_IGNORE;
-   return REG_REQ_ALREADY_SET;
-  }
+ spin_lock(&reg_requests_lock);
+ if (!list_empty(&reg_requests_list))
+  need_more_processing = true;
+ spin_unlock(&reg_requests_lock);
 
-  last_wiphy = wiphy_idx_to_wiphy(lr->wiphy_idx);
+ if (lr->initiator == NL80211_REGDOM_SET_BY_USER)
+  cancel_delayed_work(&reg_timeout);
 
-  if (unlikely(!is_an_alpha2(pending_request->alpha2)))
-   return -EINVAL;
-  if (lr->initiator == NL80211_REGDOM_SET_BY_COUNTRY_IE) {
-   if (last_wiphy != wiphy) {
-    /*
-     * Two cards with two APs claiming different
-     * Country IE alpha2s. We could
-     * intersect them, but that seems unlikely
-     * to be correct. Reject second one for now.
-     */
-    if (regdom_changes(pending_request->alpha2))
-     return REG_REQ_IGNORE;
-    return REG_REQ_ALREADY_SET;
-   }
-   /*
-    * Two consecutive Country IE hints on the same wiphy.
-    * This should be picked up early by the driver/stack
-    */
-   if (WARN_ON(regdom_changes(pending_request->alpha2)))
-    return REG_REQ_OK;
-   return REG_REQ_ALREADY_SET;
-  }
-  return 0;
- case NL80211_REGDOM_SET_BY_DRIVER:
-  if (lr->initiator == NL80211_REGDOM_SET_BY_CORE) {
-   if (regdom_changes(pending_request->alpha2))
-    return REG_REQ_OK;
-   return REG_REQ_ALREADY_SET;
-  }
+ if (need_more_processing)
+  schedule_work(&reg_work);
+}
 
-  /*
-   * This would happen if you unplug and plug your card
-   * back in or if you add a new device for which the previously
-   * loaded card also agrees on the regulatory domain.
-   */
-  if (lr->initiator == NL80211_REGDOM_SET_BY_DRIVER &&
-      !regdom_changes(pending_request->alpha2))
-   return REG_REQ_ALREADY_SET;
+/**
+ * reg_process_hint_core - process core regulatory requests
+ * @pending_request: a pending core regulatory request
+ *
+ * The wireless subsystem can use this function to process
+ * a regulatory request issued by the regulatory core.
+ *
+ * Returns one of the different reg request treatment values.
+ */
+static enum reg_request_treatment
+reg_process_hint_core(struct regulatory_request *core_request)
+{
+
+ core_request->intersect = false;
+ core_request->processed = false;
+
+ reg_update_last_request(core_request);
 
+ return reg_call_crda(core_request);
+}
+
+static enum reg_request_treatment
+__reg_process_hint_user(struct regulatory_request *user_request)
+{
+ struct regulatory_request *lr = get_last_request();
+
+ if (reg_request_indoor(user_request)) {
+  reg_is_indoor = true;
+  return REG_REQ_USER_HINT_HANDLED;
+ }
+
+ if (reg_request_cell_base(user_request))
+  return reg_ignore_cell_hint(user_request);
+
+ if (reg_request_cell_base(lr))
+  return REG_REQ_IGNORE;
+
+ if (lr->initiator == NL80211_REGDOM_SET_BY_COUNTRY_IE)
   return REG_REQ_INTERSECT;
- case NL80211_REGDOM_SET_BY_USER:
-  if (reg_request_cell_base(pending_request))
-   return reg_ignore_cell_hint(pending_request);
+ /*
+  * If the user knows better the user should set the regdom
+  * to their country before the IE is picked up
+  */
+ if (lr->initiator == NL80211_REGDOM_SET_BY_USER &&
+     lr->intersect)
+  return REG_REQ_IGNORE;
+ /*
+  * Process user requests only after previous user/driver/core
+  * requests have been processed
+  */
+ if ((lr->initiator == NL80211_REGDOM_SET_BY_CORE ||
+      lr->initiator == NL80211_REGDOM_SET_BY_DRIVER ||
+      lr->initiator == NL80211_REGDOM_SET_BY_USER) &&
+     regdom_changes(lr->alpha2))
+  return REG_REQ_IGNORE;
 
-  if (reg_request_cell_base(lr))
-   return REG_REQ_IGNORE;
+ if (!regdom_changes(user_request->alpha2))
+  return REG_REQ_ALREADY_SET;
 
-  if (lr->initiator == NL80211_REGDOM_SET_BY_COUNTRY_IE)
-   return REG_REQ_INTERSECT;
-  /*
-   * If the user knows better the user should set the regdom
-   * to their country before the IE is picked up
-   */
-  if (lr->initiator == NL80211_REGDOM_SET_BY_USER &&
-      lr->intersect)
-   return REG_REQ_IGNORE;
-  /*
-   * Process user requests only after previous user/driver/core
-   * requests have been processed
-   */
-  if ((lr->initiator == NL80211_REGDOM_SET_BY_CORE ||
-       lr->initiator == NL80211_REGDOM_SET_BY_DRIVER ||
-       lr->initiator == NL80211_REGDOM_SET_BY_USER) &&
-      regdom_changes(lr->alpha2))
-   return REG_REQ_IGNORE;
+ return REG_REQ_OK;
+}
 
-  if (!regdom_changes(pending_request->alpha2))
-   return REG_REQ_ALREADY_SET;
+/**
+ * reg_process_hint_user - process user regulatory requests
+ * @user_request: a pending user regulatory request
+ *
+ * The wireless subsystem can use this function to process
+ * a regulatory request initiated by userspace.
+ *
+ * Returns one of the different reg request treatment values.
+ */
+static enum reg_request_treatment
+reg_process_hint_user(struct regulatory_request *user_request)
+{
+ enum reg_request_treatment treatment;
 
-  return REG_REQ_OK;
+ treatment = __reg_process_hint_user(user_request);
+ if (treatment == REG_REQ_IGNORE ||
+     treatment == REG_REQ_ALREADY_SET ||
+     treatment == REG_REQ_USER_HINT_HANDLED) {
+  reg_free_request(user_request);
+  return treatment;
  }
 
- return REG_REQ_IGNORE;
+ user_request->intersect = treatment == REG_REQ_INTERSECT;
+ user_request->processed = false;
+
+ reg_update_last_request(user_request);
+
+ user_alpha2[0] = user_request->alpha2[0];
+ user_alpha2[1] = user_request->alpha2[1];
+
+ return reg_call_crda(user_request);
 }
 
-static void reg_set_request_processed(void)
+static enum reg_request_treatment
+__reg_process_hint_driver(struct regulatory_request *driver_request)
 {
- bool need_more_processing = false;
  struct regulatory_request *lr = get_last_request();
 
- lr->processed = true;
-
- spin_lock(&reg_requests_lock);
- if (!list_empty(&reg_requests_list))
-  need_more_processing = true;
- spin_unlock(&reg_requests_lock);
+ if (lr->initiator == NL80211_REGDOM_SET_BY_CORE) {
+  if (regdom_changes(driver_request->alpha2))
+   return REG_REQ_OK;
+  return REG_REQ_ALREADY_SET;
+ }
 
- if (lr->initiator == NL80211_REGDOM_SET_BY_USER)
-  cancel_delayed_work(&reg_timeout);
+ /*
+  * This would happen if you unplug and plug your card
+  * back in or if you add a new device for which the previously
+  * loaded card also agrees on the regulatory domain.
+  */
+ if (lr->initiator == NL80211_REGDOM_SET_BY_DRIVER &&
+     !regdom_changes(driver_request->alpha2))
+  return REG_REQ_ALREADY_SET;
 
- if (need_more_processing)
-  schedule_work(&reg_work);
+ return REG_REQ_INTERSECT;
 }
 
 /**
- * __regulatory_hint - hint to the wireless core a regulatory domain
- * @wiphy: if the hint comes from country information from an AP, this
- * is required to be set to the wiphy that received the information
- * @pending_request: the regulatory request currently being processed
+ * reg_process_hint_driver - process driver regulatory requests
+ * @driver_request: a pending driver regulatory request
  *
- * The Wireless subsystem can use this function to hint to the wireless core
- * what it believes should be the current regulatory domain.
+ * The wireless subsystem can use this function to process
+ * a regulatory request issued by an 802.11 driver.
  *
  * Returns one of the different reg request treatment values.
- *
- * Caller must hold &reg_mutex
  */
 static enum reg_request_treatment
-__regulatory_hint(struct wiphy *wiphy,
-    struct regulatory_request *pending_request)
+reg_process_hint_driver(struct wiphy *wiphy,
+   struct regulatory_request *driver_request)
 {
  const struct ieee80211_regdomain *regd;
- bool intersect = false;
  enum reg_request_treatment treatment;
- struct regulatory_request *lr;
 
- treatment = get_reg_request_treatment(wiphy, pending_request);
+ treatment = __reg_process_hint_driver(driver_request);
 
  switch (treatment) {
- case REG_REQ_INTERSECT:
-  if (pending_request->initiator ==
-      NL80211_REGDOM_SET_BY_DRIVER) {
-   regd = reg_copy_regd(get_cfg80211_regdom());
-   if (IS_ERR(regd)) {
-    kfree(pending_request);
-    return PTR_ERR(regd);
-   }
-   rcu_assign_pointer(wiphy->regd, regd);
-  }
-  intersect = true;
-  break;
  case REG_REQ_OK:
   break;
- default:
-  /*
-   * If the regulatory domain being requested by the
-   * driver has already been set just copy it to the
-   * wiphy
-   */
-  if (treatment == REG_REQ_ALREADY_SET &&
-      pending_request->initiator == NL80211_REGDOM_SET_BY_DRIVER) {
-   regd = reg_copy_regd(get_cfg80211_regdom());
-   if (IS_ERR(regd)) {
-    kfree(pending_request);
-    return REG_REQ_IGNORE;
-   }
-   treatment = REG_REQ_ALREADY_SET;
-   rcu_assign_pointer(wiphy->regd, regd);
-   goto new_request;
-  }
-  kfree(pending_request);
+ case REG_REQ_IGNORE:
+ case REG_REQ_USER_HINT_HANDLED:
+  reg_free_request(driver_request);
   return treatment;
+ case REG_REQ_INTERSECT:
+  /* fall through */
+ case REG_REQ_ALREADY_SET:
+  regd = reg_copy_regd(get_cfg80211_regdom());
+  if (IS_ERR(regd)) {
+   reg_free_request(driver_request);
+   return REG_REQ_IGNORE;
+  }
+  rcu_assign_pointer(wiphy->regd, regd);
  }
 
-new_request:
- lr = get_last_request();
- if (lr != &core_request_world && lr)
-  kfree_rcu(lr, rcu_head);
 
- pending_request->intersect = intersect;
- pending_request->processed = false;
- rcu_assign_pointer(last_request, pending_request);
- lr = pending_request;
+ driver_request->intersect = treatment == REG_REQ_INTERSECT;
+ driver_request->processed = false;
 
- pending_request = NULL;
+ reg_update_last_request(driver_request);
 
- if (lr->initiator == NL80211_REGDOM_SET_BY_USER) {
-  user_alpha2[0] = lr->alpha2[0];
-  user_alpha2[1] = lr->alpha2[1];
+ /*
+  * Since CRDA will not be called in this case as we already
+  * have applied the requested regulatory domain before we just
+  * inform userspace we have processed the request
+  */
+ if (treatment == REG_REQ_ALREADY_SET) {
+  nl80211_send_reg_change_event(driver_request);
+  reg_set_request_processed();
+  return treatment;
  }
 
- /* When r == REG_REQ_INTERSECT we do need to call CRDA */
- if (treatment != REG_REQ_OK && treatment != REG_REQ_INTERSECT) {
+ return reg_call_crda(driver_request);
+}
+
+static enum reg_request_treatment
+__reg_process_hint_country_ie(struct wiphy *wiphy,
+         struct regulatory_request *country_ie_request)
+{
+ struct wiphy *last_wiphy = NULL;
+ struct regulatory_request *lr = get_last_request();
+
+ if (reg_request_cell_base(lr)) {
+  /* Trust a Cell base station over the AP's country IE */
+  if (regdom_changes(country_ie_request->alpha2))
+   return REG_REQ_IGNORE;
+  return REG_REQ_ALREADY_SET;
+ } else {
+  if (wiphy->regulatory_flags & REGULATORY_COUNTRY_IE_IGNORE)
+   return REG_REQ_IGNORE;
+ }
+
+ if (unlikely(!is_an_alpha2(country_ie_request->alpha2)))
+  return -EINVAL;
+
+ if (lr->initiator != NL80211_REGDOM_SET_BY_COUNTRY_IE)
+  return REG_REQ_OK;
+
+ last_wiphy = wiphy_idx_to_wiphy(lr->wiphy_idx);
+
+ if (last_wiphy != wiphy) {
   /*
-   * Since CRDA will not be called in this case as we already
-   * have applied the requested regulatory domain before we just
-   * inform userspace we have processed the request
+   * Two cards with two APs claiming different
+   * Country IE alpha2s. We could
+   * intersect them, but that seems unlikely
+   * to be correct. Reject second one for now.
    */
-  if (treatment == REG_REQ_ALREADY_SET) {
-   nl80211_send_reg_change_event(lr);
-   reg_set_request_processed();
-  }
-  return treatment;
+  if (regdom_changes(country_ie_request->alpha2))
+   return REG_REQ_IGNORE;
+  return REG_REQ_ALREADY_SET;
  }
+ /*
+  * Two consecutive Country IE hints on the same wiphy.
+  * This should be picked up early by the driver/stack
+  */
+ if (WARN_ON(regdom_changes(country_ie_request->alpha2)))
+  return REG_REQ_OK;
+ return REG_REQ_ALREADY_SET;
+}
+
+/**
+ * reg_process_hint_country_ie - process regulatory requests from country IEs
+ * @country_ie_request: a regulatory request from a country IE
+ *
+ * The wireless subsystem can use this function to process
+ * a regulatory request issued by a country Information Element.
+ *
+ * Returns one of the different reg request treatment values.
+ */
+static enum reg_request_treatment
+reg_process_hint_country_ie(struct wiphy *wiphy,
+       struct regulatory_request *country_ie_request)
+{
+ enum reg_request_treatment treatment;
+
+ treatment = __reg_process_hint_country_ie(wiphy, country_ie_request);
 
- if (call_crda(lr->alpha2))
+ switch (treatment) {
+ case REG_REQ_OK:
+  break;
+ case REG_REQ_IGNORE:
+ case REG_REQ_USER_HINT_HANDLED:
+  /* fall through */
+ case REG_REQ_ALREADY_SET:
+  reg_free_request(country_ie_request);
+  return treatment;
+ case REG_REQ_INTERSECT:
+  reg_free_request(country_ie_request);
+  /*
+   * This doesn't happen yet, not sure we
+   * ever want to support it for this case.
+   */
+  WARN_ONCE(1, "Unexpected intersection for country IEs");
   return REG_REQ_IGNORE;
- return REG_REQ_OK;
+ }
+
+ country_ie_request->intersect = false;
+ country_ie_request->processed = false;
+
+ reg_update_last_request(country_ie_request);
+
+ return reg_call_crda(country_ie_request);
 }
 
 /* This processes *all* regulatory hints */
-static void reg_process_hint(struct regulatory_request *reg_request,
-        enum nl80211_reg_initiator reg_initiator)
+static void reg_process_hint(struct regulatory_request *reg_request)
 {
  struct wiphy *wiphy = NULL;
-
- if (WARN_ON(!reg_request->alpha2))
-  return;
+ enum reg_request_treatment treatment;
 
  if (reg_request->wiphy_idx != WIPHY_IDX_INVALID)
   wiphy = wiphy_idx_to_wiphy(reg_request->wiphy_idx);
 
- if (reg_initiator == NL80211_REGDOM_SET_BY_DRIVER && !wiphy) {
-  kfree(reg_request);
+ switch (reg_request->initiator) {
+ case NL80211_REGDOM_SET_BY_CORE:
+  reg_process_hint_core(reg_request);
   return;
- }
-
- switch (__regulatory_hint(wiphy, reg_request)) {
- case REG_REQ_ALREADY_SET:
-  /* This is required so that the orig_* parameters are saved */
-  if (wiphy && wiphy->flags & WIPHY_FLAG_STRICT_REGULATORY)
-   wiphy_update_regulatory(wiphy, reg_initiator);
+ case NL80211_REGDOM_SET_BY_USER:
+  treatment = reg_process_hint_user(reg_request);
+  if (treatment == REG_REQ_IGNORE ||
+      treatment == REG_REQ_ALREADY_SET ||
+      treatment == REG_REQ_USER_HINT_HANDLED)
+   return;
+#if 0 /* Not in RHEL */
+  queue_delayed_work(system_power_efficient_wq,
+#else
+  queue_delayed_work(system_wq,
+#endif
+       &reg_timeout, msecs_to_jiffies(3142));
+  return;
+ case NL80211_REGDOM_SET_BY_DRIVER:
+  if (!wiphy)
+   goto out_free;
+  treatment = reg_process_hint_driver(wiphy, reg_request);
   break;
- default:
-  if (reg_initiator == NL80211_REGDOM_SET_BY_USER)
-   schedule_delayed_work(&reg_timeout,
-           msecs_to_jiffies(3142));
+ case NL80211_REGDOM_SET_BY_COUNTRY_IE:
+  if (!wiphy)
+   goto out_free;
+  treatment = reg_process_hint_country_ie(wiphy, reg_request);
   break;
+ default:
+  WARN(1, "invalid initiator %d\n", reg_request->initiator);
+  goto out_free;
  }
+
+ /* This is required so that the orig_* parameters are saved */
+ if (treatment == REG_REQ_ALREADY_SET && wiphy &&
+     wiphy->regulatory_flags & REGULATORY_STRICT_REG)
+  wiphy_update_regulatory(wiphy, reg_request->initiator);
+
+ return;
+
+out_free:
+ reg_free_request(reg_request);
 }
 
 /*
@@ -1570,21 +1913,19 @@ static void reg_process_pending_hints(void)
 {
  struct regulatory_request *reg_request, *lr;
 
- mutex_lock(&cfg80211_mutex);
- mutex_lock(&reg_mutex);
  lr = get_last_request();
 
  /* When last_request->processed becomes true this will be rescheduled */
  if (lr && !lr->processed) {
-  REG_DBG_PRINT("Pending regulatory request, waiting for it to be processed...\n");
-  goto out;
+  reg_process_hint(lr);
+  return;
  }
 
  spin_lock(&reg_requests_lock);
 
  if (list_empty(&reg_requests_list)) {
   spin_unlock(&reg_requests_lock);
-  goto out;
+  return;
  }
 
  reg_request = list_first_entry(&reg_requests_list,
@@ -1594,11 +1935,7 @@ static void reg_process_pending_hints(void)
 
  spin_unlock(&reg_requests_lock);
 
- reg_process_hint(reg_request, reg_request->initiator);
-
-out:
- mutex_unlock(&reg_mutex);
- mutex_unlock(&cfg80211_mutex);
+ reg_process_hint(reg_request);
 }
 
 /* Processes beacon hints -- this has nothing to do with country IEs */
@@ -1607,9 +1944,6 @@ static void reg_process_pending_beacon_hints(void)
  struct cfg80211_registered_device *rdev;
  struct reg_beacon *pending_beacon, *tmp;
 
- mutex_lock(&cfg80211_mutex);
- mutex_lock(&reg_mutex);
-
  /* This goes through the _pending_ beacon list */
  spin_lock_bh(&reg_pending_beacons_lock);
 
@@ -1626,14 +1960,14 @@ static void reg_process_pending_beacon_hints(void)
  }
 
  spin_unlock_bh(&reg_pending_beacons_lock);
- mutex_unlock(&reg_mutex);
- mutex_unlock(&cfg80211_mutex);
 }
 
 static void reg_todo(struct work_struct *work)
 {
+ rtnl_lock();
  reg_process_pending_hints();
  reg_process_pending_beacon_hints();
+ rtnl_unlock();
 }
 
 static void queue_regulatory_request(struct regulatory_request *request)
@@ -1693,6 +2027,22 @@ int regulatory_hint_user(const char *alpha2,
  return 0;
 }
 
+int regulatory_hint_indoor_user(void)
+{
+ struct regulatory_request *request;
+
+ request = kzalloc(sizeof(struct regulatory_request), GFP_KERNEL);
+ if (!request)
+  return -ENOMEM;
+
+ request->wiphy_idx = WIPHY_IDX_INVALID;
+ request->initiator = NL80211_REGDOM_SET_BY_USER;
+ request->user_reg_hint_type = NL80211_USER_REG_HINT_INDOOR;
+ queue_regulatory_request(request);
+
+ return 0;
+}
+
 /* Driver hints */
 int regulatory_hint(struct wiphy *wiphy, const char *alpha2)
 {
@@ -1701,6 +2051,8 @@ int regulatory_hint(struct wiphy *wiphy, const char *alpha2)
  if (WARN_ON(!alpha2 || !wiphy))
   return -EINVAL;
 
+ wiphy->regulatory_flags &= ~REGULATORY_CUSTOM_REG;
+
  request = kzalloc(sizeof(struct regulatory_request), GFP_KERNEL);
  if (!request)
   return -ENOMEM;
@@ -1717,29 +2069,23 @@ int regulatory_hint(struct wiphy *wiphy, const char *alpha2)
 }
 EXPORT_SYMBOL(regulatory_hint);
 
-/*
- * We hold wdev_lock() here so we cannot hold cfg80211_mutex() and
- * therefore cannot iterate over the rdev list here.
- */
-void regulatory_hint_11d(struct wiphy *wiphy, enum ieee80211_band band,
-    const u8 *country_ie, u8 country_ie_len)
+void regulatory_hint_country_ie(struct wiphy *wiphy, enum ieee80211_band band,
+    const u8 *country_ie, u8 country_ie_len)
 {
  char alpha2[2];
  enum environment_cap env = ENVIRON_ANY;
- struct regulatory_request *request, *lr;
-
- mutex_lock(&reg_mutex);
- lr = get_last_request();
-
- if (unlikely(!lr))
-  goto out;
+ struct regulatory_request *request = NULL, *lr;
 
  /* IE len must be evenly divisible by 2 */
  if (country_ie_len & 0x01)
-  goto out;
+  return;
 
  if (country_ie_len < IEEE80211_COUNTRY_IE_MIN_LEN)
-  goto out;
+  return;
+
+ request = kzalloc(sizeof(*request), GFP_KERNEL);
+ if (!request)
+  return;
 
  alpha2[0] = country_ie[0];
  alpha2[1] = country_ie[1];
@@ -1749,19 +2095,21 @@ void regulatory_hint_11d(struct wiphy *wiphy, enum ieee80211_band band,
  else if (country_ie[2] == 'O')
   env = ENVIRON_OUTDOOR;
 
+ rcu_read_lock();
+ lr = get_last_request();
+
+ if (unlikely(!lr))
+  goto out;
+
  /*
   * We will run this only upon a successful connection on cfg80211.
   * We leave conflict resolution to the workqueue, where can hold
-  * cfg80211_mutex.
+  * the RTNL.
   */
  if (lr->initiator == NL80211_REGDOM_SET_BY_COUNTRY_IE &&
      lr->wiphy_idx != WIPHY_IDX_INVALID)
   goto out;
 
- request = kzalloc(sizeof(struct regulatory_request), GFP_KERNEL);
- if (!request)
-  goto out;
-
  request->wiphy_idx = get_wiphy_idx(wiphy);
  request->alpha2[0] = alpha2[0];
  request->alpha2[1] = alpha2[1];
@@ -1769,8 +2117,10 @@ void regulatory_hint_11d(struct wiphy *wiphy, enum ieee80211_band band,
  request->country_ie_env = env;
 
  queue_regulatory_request(request);
+ request = NULL;
 out:
- mutex_unlock(&reg_mutex);
+ kfree(request);
+ rcu_read_unlock();
 }
 
 static void restore_alpha2(char *alpha2, bool reset_user)
@@ -1858,8 +2208,9 @@ static void restore_regulatory_settings(bool reset_user)
  LIST_HEAD(tmp_reg_req_list);
  struct cfg80211_registered_device *rdev;
 
- mutex_lock(&cfg80211_mutex);
- mutex_lock(&reg_mutex);
+ ASSERT_RTNL();
+
+ reg_is_indoor = false;
 
  reset_regdomains(true, &world_regdom);
  restore_alpha2(alpha2, reset_user);
@@ -1896,7 +2247,7 @@ static void restore_regulatory_settings(bool reset_user)
  world_alpha2[1] = cfg80211_world_regdom->alpha2[1];
 
  list_for_each_entry(rdev, &cfg80211_rdev_list, list) {
-  if (rdev->wiphy.flags & WIPHY_FLAG_CUSTOM_REGULATORY)
+  if (rdev->wiphy.regulatory_flags & REGULATORY_CUSTOM_REG)
    restore_custom_reg_settings(&rdev->wiphy);
  }
 
@@ -1914,9 +2265,6 @@ static void restore_regulatory_settings(bool reset_user)
  list_splice_tail_init(&tmp_reg_req_list, &reg_requests_list);
  spin_unlock(&reg_requests_lock);
 
- mutex_unlock(&reg_mutex);
- mutex_unlock(&cfg80211_mutex);
-
  REG_DBG_PRINT("Kicking the queue\n");
 
  schedule_work(&reg_work);
@@ -1999,35 +2347,53 @@ static void print_rd_rules(const struct ieee80211_regdomain *rd)
  const struct ieee80211_reg_rule *reg_rule = NULL;
  const struct ieee80211_freq_range *freq_range = NULL;
  const struct ieee80211_power_rule *power_rule = NULL;
+ char bw[32], cac_time[32];
 
- pr_info("  (start_freq - end_freq @ bandwidth), (max_antenna_gain, max_eirp)\n");
+ pr_info("  (start_freq - end_freq @ bandwidth), (max_antenna_gain, max_eirp), (dfs_cac_time)\n");
 
  for (i = 0; i < rd->n_reg_rules; i++) {
   reg_rule = &rd->reg_rules[i];
   freq_range = &reg_rule->freq_range;
   power_rule = &reg_rule->power_rule;
 
+  if (reg_rule->flags & NL80211_RRF_AUTO_BW)
+   snprintf(bw, sizeof(bw), "%d KHz, %d KHz AUTO",
+     freq_range->max_bandwidth_khz,
+     reg_get_max_bandwidth(rd, reg_rule));
+  else
+   snprintf(bw, sizeof(bw), "%d KHz",
+     freq_range->max_bandwidth_khz);
+
+  if (reg_rule->flags & NL80211_RRF_DFS)
+   scnprintf(cac_time, sizeof(cac_time), "%u s",
+      reg_rule->dfs_cac_ms/1000);
+  else
+   scnprintf(cac_time, sizeof(cac_time), "N/A");
+
+
   /*
    * There may not be documentation for max antenna gain
    * in certain regions
    */
   if (power_rule->max_antenna_gain)
-   pr_info("  (%d KHz - %d KHz @ %d KHz), (%d mBi, %d mBm)\n",
+   pr_info("  (%d KHz - %d KHz @ %s), (%d mBi, %d mBm), (%s)\n",
     freq_range->start_freq_khz,
     freq_range->end_freq_khz,
-    freq_range->max_bandwidth_khz,
+    bw,
     power_rule->max_antenna_gain,
-    power_rule->max_eirp);
+    power_rule->max_eirp,
+    cac_time);
   else
-   pr_info("  (%d KHz - %d KHz @ %d KHz), (N/A, %d mBm)\n",
+   pr_info("  (%d KHz - %d KHz @ %s), (N/A, %d mBm), (%s)\n",
     freq_range->start_freq_khz,
     freq_range->end_freq_khz,
-    freq_range->max_bandwidth_khz,
-    power_rule->max_eirp);
+    bw,
+    power_rule->max_eirp,
+    cac_time);
  }
 }
 
-bool reg_supported_dfs_region(u8 dfs_region)
+bool reg_supported_dfs_region(enum nl80211_dfs_regions dfs_region)
 {
  switch (dfs_region) {
  case NL80211_DFS_UNSET:
@@ -2042,27 +2408,6 @@ bool reg_supported_dfs_region(u8 dfs_region)
  }
 }
 
-static void print_dfs_region(u8 dfs_region)
-{
- if (!dfs_region)
-  return;
-
- switch (dfs_region) {
- case NL80211_DFS_FCC:
-  pr_info(" DFS Master region FCC");
-  break;
- case NL80211_DFS_ETSI:
-  pr_info(" DFS Master region ETSI");
-  break;
- case NL80211_DFS_JP:
-  pr_info(" DFS Master region JP");
-  break;
- default:
-  pr_info(" DFS Master region Unknown");
-  break;
- }
-}
-
 static void print_regdomain(const struct ieee80211_regdomain *rd)
 {
  struct regulatory_request *lr = get_last_request();
@@ -2094,7 +2439,7 @@ static void print_regdomain(const struct ieee80211_regdomain *rd)
   }
  }
 
- print_dfs_region(rd->dfs_region);
+ pr_info(" DFS Master region: %s", reg_dfs_region_str(rd->dfs_region));
  print_rd_rules(rd);
 }
 
@@ -2104,48 +2449,57 @@ static void print_regdomain_info(const struct ieee80211_regdomain *rd)
  print_rd_rules(rd);
 }
 
-/* Takes ownership of rd only if it doesn't fail */
-static int __set_regdom(const struct ieee80211_regdomain *rd)
+static int reg_set_rd_core(const struct ieee80211_regdomain *rd)
+{
+ if (!is_world_regdom(rd->alpha2))
+  return -EINVAL;
+ update_world_regdomain(rd);
+ return 0;
+}
+
+static int reg_set_rd_user(const struct ieee80211_regdomain *rd,
+      struct regulatory_request *user_request)
 {
- const struct ieee80211_regdomain *regd;
  const struct ieee80211_regdomain *intersected_rd = NULL;
- struct wiphy *request_wiphy;
- struct regulatory_request *lr = get_last_request();
 
- /* Some basic sanity checks first */
+ if (!regdom_changes(rd->alpha2))
+  return -EALREADY;
 
- if (!reg_is_valid_request(rd->alpha2))
+ if (!is_valid_rd(rd)) {
+  pr_err("Invalid regulatory domain detected:\n");
+  print_regdomain_info(rd);
   return -EINVAL;
+ }
 
- if (is_world_regdom(rd->alpha2)) {
-  update_world_regdomain(rd);
+ if (!user_request->intersect) {
+  reset_regdomains(false, rd);
   return 0;
  }
 
- if (!is_alpha2_set(rd->alpha2) && !is_an_alpha2(rd->alpha2) &&
-     !is_unknown_alpha2(rd->alpha2))
+ intersected_rd = regdom_intersect(rd, get_cfg80211_regdom());
+ if (!intersected_rd)
   return -EINVAL;
 
- /*
-  * Lets only bother proceeding on the same alpha2 if the current
-  * rd is non static (it means CRDA was present and was used last)
-  * and the pending request came in from a country IE
-  */
- if (lr->initiator != NL80211_REGDOM_SET_BY_COUNTRY_IE) {
-  /*
-   * If someone else asked us to change the rd lets only bother
-   * checking if the alpha2 changes if CRDA was already called
-   */
-  if (!regdom_changes(rd->alpha2))
-   return -EALREADY;
- }
+ kfree(rd);
+ rd = NULL;
+ reset_regdomains(false, intersected_rd);
 
- /*
-  * Now lets set the regulatory domain, update all driver channels
-  * and finally inform them of what we have done, in case they want
-  * to review or adjust their own settings based on their own
-  * internal EEPROM data
-  */
+ return 0;
+}
+
+static int reg_set_rd_driver(const struct ieee80211_regdomain *rd,
+        struct regulatory_request *driver_request)
+{
+ const struct ieee80211_regdomain *regd;
+ const struct ieee80211_regdomain *intersected_rd = NULL;
+ const struct ieee80211_regdomain *tmp;
+ struct wiphy *request_wiphy;
+
+ if (is_world_regdom(rd->alpha2))
+  return -EINVAL;
+
+ if (!regdom_changes(rd->alpha2))
+  return -EALREADY;
 
  if (!is_valid_rd(rd)) {
   pr_err("Invalid regulatory domain detected:\n");
@@ -2153,29 +2507,18 @@ static int __set_regdom(const struct ieee80211_regdomain *rd)
   return -EINVAL;
  }
 
- request_wiphy = wiphy_idx_to_wiphy(lr->wiphy_idx);
- if (!request_wiphy &&
-     (lr->initiator == NL80211_REGDOM_SET_BY_DRIVER ||
-      lr->initiator == NL80211_REGDOM_SET_BY_COUNTRY_IE)) {
-  schedule_delayed_work(&reg_timeout, 0);
+ request_wiphy = wiphy_idx_to_wiphy(driver_request->wiphy_idx);
+ if (!request_wiphy) {
+#if 0 /* Not in RHEL */
+  queue_delayed_work(system_power_efficient_wq,
+#else
+  queue_delayed_work(system_wq,
+#endif
+       &reg_timeout, 0);
   return -ENODEV;
  }
 
- if (!lr->intersect) {
-  if (lr->initiator != NL80211_REGDOM_SET_BY_DRIVER) {
-   reset_regdomains(false, rd);
-   return 0;
-  }
-
-  /*
-   * For a driver hint, lets copy the regulatory domain the
-   * driver wanted to the wiphy to deal with conflicts
-   */
-
-  /*
-   * Userspace could have sent two replies with only
-   * one kernel request.
-   */
+ if (!driver_request->intersect) {
   if (request_wiphy->regd)
    return -EALREADY;
 
@@ -2188,38 +2531,64 @@ static int __set_regdom(const struct ieee80211_regdomain *rd)
   return 0;
  }
 
- /* Intersection requires a bit more work */
+ intersected_rd = regdom_intersect(rd, get_cfg80211_regdom());
+ if (!intersected_rd)
+  return -EINVAL;
+
+ /*
+  * We can trash what CRDA provided now.
+  * However if a driver requested this specific regulatory
+  * domain we keep it for its private use
+  */
+ tmp = get_wiphy_regdom(request_wiphy);
+ rcu_assign_pointer(request_wiphy->regd, rd);
+ rcu_free_regdom(tmp);
 
- if (lr->initiator != NL80211_REGDOM_SET_BY_COUNTRY_IE) {
-  intersected_rd = regdom_intersect(rd, get_cfg80211_regdom());
-  if (!intersected_rd)
-   return -EINVAL;
+ rd = NULL;
 
-  /*
-   * We can trash what CRDA provided now.
-   * However if a driver requested this specific regulatory
-   * domain we keep it for its private use
-   */
-  if (lr->initiator == NL80211_REGDOM_SET_BY_DRIVER) {
-   const struct ieee80211_regdomain *tmp;
+ reset_regdomains(false, intersected_rd);
 
-   tmp = get_wiphy_regdom(request_wiphy);
-   rcu_assign_pointer(request_wiphy->regd, rd);
-   rcu_free_regdom(tmp);
-  } else {
-   kfree(rd);
-  }
+ return 0;
+}
 
-  rd = NULL;
+static int reg_set_rd_country_ie(const struct ieee80211_regdomain *rd,
+     struct regulatory_request *country_ie_request)
+{
+ struct wiphy *request_wiphy;
 
-  reset_regdomains(false, intersected_rd);
+ if (!is_alpha2_set(rd->alpha2) && !is_an_alpha2(rd->alpha2) &&
+     !is_unknown_alpha2(rd->alpha2))
+  return -EINVAL;
 
-  return 0;
+ /*
+  * Lets only bother proceeding on the same alpha2 if the current
+  * rd is non static (it means CRDA was present and was used last)
+  * and the pending request came in from a country IE
+  */
+
+ if (!is_valid_rd(rd)) {
+  pr_err("Invalid regulatory domain detected:\n");
+  print_regdomain_info(rd);
+  return -EINVAL;
  }
 
- return -EINVAL;
-}
+ request_wiphy = wiphy_idx_to_wiphy(country_ie_request->wiphy_idx);
+ if (!request_wiphy) {
+#if 0 /* Not in RHEL */
+  queue_delayed_work(system_power_efficient_wq,
+#else
+  queue_delayed_work(system_wq,
+#endif
+       &reg_timeout, 0);
+  return -ENODEV;
+ }
 
+ if (country_ie_request->intersect)
+  return -EINVAL;
+
+ reset_regdomains(false, rd);
+ return 0;
+}
 
 /*
  * Use this call to set the current regulatory domain. Conflicts with
@@ -2229,26 +2598,53 @@ static int __set_regdom(const struct ieee80211_regdomain *rd)
 int set_regdom(const struct ieee80211_regdomain *rd)
 {
  struct regulatory_request *lr;
+ bool user_reset = false;
  int r;
 
- mutex_lock(&reg_mutex);
+ if (!reg_is_valid_request(rd->alpha2)) {
+  kfree(rd);
+  return -EINVAL;
+ }
+
  lr = get_last_request();
 
  /* Note that this doesn't update the wiphys, this is done below */
- r = __set_regdom(rd);
+ switch (lr->initiator) {
+ case NL80211_REGDOM_SET_BY_CORE:
+  r = reg_set_rd_core(rd);
+  break;
+ case NL80211_REGDOM_SET_BY_USER:
+  r = reg_set_rd_user(rd, lr);
+  user_reset = true;
+  break;
+ case NL80211_REGDOM_SET_BY_DRIVER:
+  r = reg_set_rd_driver(rd, lr);
+  break;
+ case NL80211_REGDOM_SET_BY_COUNTRY_IE:
+  r = reg_set_rd_country_ie(rd, lr);
+  break;
+ default:
+  WARN(1, "invalid initiator %d\n", lr->initiator);
+  return -EINVAL;
+ }
+
  if (r) {
-  if (r == -EALREADY)
+  switch (r) {
+  case -EALREADY:
    reg_set_request_processed();
+   break;
+  default:
+   /* Back to world regulatory in case of errors */
+   restore_regulatory_settings(user_reset);
+  }
 
   kfree(rd);
-  goto out;
+  return r;
  }
 
  /* This would make this whole thing pointless */
- if (WARN_ON(!lr->intersect && rd != get_cfg80211_regdom())) {
-  r = -EINVAL;
-  goto out;
- }
+ if (WARN_ON(!lr->intersect && rd != get_cfg80211_regdom()))
+  return -EINVAL;
 
  /* update all wiphys now with the new established regulatory domain */
  update_all_wiphy_regulatory(lr->initiator);
@@ -2259,75 +2655,83 @@ int set_regdom(const struct ieee80211_regdomain *rd)
 
  reg_set_request_processed();
 
- out:
- mutex_unlock(&reg_mutex);
-
- return r;
-}
-
-int reg_device_uevent(struct device *dev, struct kobj_uevent_env *env)
-{
- struct regulatory_request *lr;
- u8 alpha2[2];
- bool add = false;
-
- rcu_read_lock();
- lr = get_last_request();
- if (lr && !lr->processed) {
-  memcpy(alpha2, lr->alpha2, 2);
-  add = true;
- }
- rcu_read_unlock();
-
- if (add)
-  return add_uevent_var(env, "COUNTRY=%c%c",
-          alpha2[0], alpha2[1]);
  return 0;
 }
 
 void wiphy_regulatory_register(struct wiphy *wiphy)
 {
- mutex_lock(&reg_mutex);
+ struct regulatory_request *lr;
 
  if (!reg_dev_ignore_cell_hint(wiphy))
   reg_num_devs_support_basehint++;
 
- wiphy_update_regulatory(wiphy, NL80211_REGDOM_SET_BY_CORE);
-
- mutex_unlock(&reg_mutex);
+ lr = get_last_request();
+ wiphy_update_regulatory(wiphy, lr->initiator);
 }
 
-/* Caller must hold cfg80211_mutex */
 void wiphy_regulatory_deregister(struct wiphy *wiphy)
 {
  struct wiphy *request_wiphy = NULL;
  struct regulatory_request *lr;
 
- mutex_lock(&reg_mutex);
  lr = get_last_request();
 
  if (!reg_dev_ignore_cell_hint(wiphy))
   reg_num_devs_support_basehint--;
 
  rcu_free_regdom(get_wiphy_regdom(wiphy));
- rcu_assign_pointer(wiphy->regd, NULL);
+ RCU_INIT_POINTER(wiphy->regd, NULL);
 
  if (lr)
   request_wiphy = wiphy_idx_to_wiphy(lr->wiphy_idx);
 
  if (!request_wiphy || request_wiphy != wiphy)
-  goto out;
+  return;
 
  lr->wiphy_idx = WIPHY_IDX_INVALID;
  lr->country_ie_env = ENVIRON_ANY;
-out:
- mutex_unlock(&reg_mutex);
 }
 
 static void reg_timeout_work(struct work_struct *work)
 {
  REG_DBG_PRINT("Timeout while waiting for CRDA to reply, restoring regulatory settings\n");
+ rtnl_lock();
  restore_regulatory_settings(true);
+ rtnl_unlock();
+}
+
+/*
+ * See http://www.fcc.gov/document/5-ghz-unlicensed-spectrum-unii, for
+ * UNII band definitions
+ */
+int cfg80211_get_unii(int freq)
+{
+ /* UNII-1 */
+ if (freq >= 5150 && freq <= 5250)
+  return 0;
+
+ /* UNII-2A */
+ if (freq > 5250 && freq <= 5350)
+  return 1;
+
+ /* UNII-2B */
+ if (freq > 5350 && freq <= 5470)
+  return 2;
+
+ /* UNII-2C */
+ if (freq > 5470 && freq <= 5725)
+  return 3;
+
+ /* UNII-3 */
+ if (freq > 5725 && freq <= 5825)
+  return 4;
+
+ return -EINVAL;
+}
+
+bool regulatory_indoor_allowed(void)
+{
+ return reg_is_indoor;
 }
 
 int __init regulatory_init(void)
@@ -2338,8 +2742,6 @@ int __init regulatory_init(void)
  if (IS_ERR(reg_pdev))
   return PTR_ERR(reg_pdev);
 
- reg_pdev->dev.type = &reg_device_type;
-
  spin_lock_init(&reg_requests_lock);
  spin_lock_init(&reg_pending_beacons_lock);
 
@@ -2385,9 +2787,9 @@ void regulatory_exit(void)
  cancel_delayed_work_sync(&reg_timeout);
 
  /* Lock to suppress warnings */
- mutex_lock(&reg_mutex);
+ rtnl_lock();
  reset_regdomains(true, NULL);
- mutex_unlock(&reg_mutex);
+ rtnl_unlock();
 
  dev_set_uevent_suppress(&reg_pdev->dev, true);
 
diff --git a/net/wireless/reg.h b/net/wireless/reg.h
index af2d5f8..5e48031 100644
--- a/net/wireless/reg.h
+++ b/net/wireless/reg.h
@@ -18,13 +18,15 @@
 
 extern const struct ieee80211_regdomain __rcu *cfg80211_regdomain;
 
+bool reg_is_valid_request(const char *alpha2);
 bool is_world_regdom(const char *alpha2);
-bool reg_supported_dfs_region(u8 dfs_region);
+bool reg_supported_dfs_region(enum nl80211_dfs_regions dfs_region);
+enum nl80211_dfs_regions reg_get_dfs_region(struct wiphy *wiphy);
 
 int regulatory_hint_user(const char *alpha2,
     enum nl80211_user_reg_hint_type user_reg_hint_type);
+int regulatory_hint_indoor_user(void);
 
-int reg_device_uevent(struct device *dev, struct kobj_uevent_env *env);
 void wiphy_regulatory_register(struct wiphy *wiphy);
 void wiphy_regulatory_deregister(struct wiphy *wiphy);
 
@@ -32,6 +34,8 @@ int __init regulatory_init(void);
 void regulatory_exit(void);
 
 int set_regdom(const struct ieee80211_regdomain *rd);
+unsigned int reg_get_max_bandwidth(const struct ieee80211_regdomain *rd,
+       const struct ieee80211_reg_rule *rule);
 
 bool reg_last_request_cell_base(void);
 
@@ -58,7 +62,7 @@ int regulatory_hint_found_beacon(struct wiphy *wiphy,
      gfp_t gfp);
 
 /**
- * regulatory_hint_11d - hints a country IE as a regulatory domain
+ * regulatory_hint_country_ie - hints a country IE as a regulatory domain
  * @wiphy: the wireless device giving the hint (used only for reporting
  * conflicts)
  * @band: the band on which the country IE was received on. This determines
@@ -78,7 +82,7 @@ int regulatory_hint_found_beacon(struct wiphy *wiphy,
  * not observed. For this reason if a triplet is seen with channel
  * information for a band the BSS is not present in it will be ignored.
  */
-void regulatory_hint_11d(struct wiphy *wiphy,
+void regulatory_hint_country_ie(struct wiphy *wiphy,
     enum ieee80211_band band,
     const u8 *country_ie,
     u8 country_ie_len);
@@ -101,4 +105,21 @@ void regulatory_hint_11d(struct wiphy *wiphy,
  */
 void regulatory_hint_disconnect(void);
 
+/**
+ * cfg80211_get_unii - get the U-NII band for the frequency
+ * @freq: the frequency for which we want to get the UNII band.
+
+ * Get a value specifying the U-NII band frequency belongs to.
+ * U-NII bands are defined by the FCC in C.F.R 47 part 15.
+ *
+ * Returns -EINVAL if freq is invalid, 0 for UNII-1, 1 for UNII-2A,
+ * 2 for UNII-2B, 3 for UNII-2C and 4 for UNII-3.
+ */
+int cfg80211_get_unii(int freq);
+
+/**
+ * regulatory_indoor_allowed - is indoor operation allowed
+ */
+bool regulatory_indoor_allowed(void);
+
 #endif  /* __NET_WIRELESS_REG_H */
diff --git a/net/wireless/scan.c b/net/wireless/scan.c
index 81019ee..0798c62 100644
--- a/net/wireless/scan.c
+++ b/net/wireless/scan.c
@@ -81,10 +81,10 @@ static void bss_free(struct cfg80211_internal_bss *bss)
  kfree(bss);
 }
 
-static inline void bss_ref_get(struct cfg80211_registered_device *dev,
+static inline void bss_ref_get(struct cfg80211_registered_device *rdev,
           struct cfg80211_internal_bss *bss)
 {
- lockdep_assert_held(&dev->bss_lock);
+ lockdep_assert_held(&rdev->bss_lock);
 
  bss->refcount++;
  if (bss->pub.hidden_beacon_bss) {
@@ -95,10 +95,10 @@ static inline void bss_ref_get(struct cfg80211_registered_device *dev,
  }
 }
 
-static inline void bss_ref_put(struct cfg80211_registered_device *dev,
+static inline void bss_ref_put(struct cfg80211_registered_device *rdev,
           struct cfg80211_internal_bss *bss)
 {
- lockdep_assert_held(&dev->bss_lock);
+ lockdep_assert_held(&rdev->bss_lock);
 
  if (bss->pub.hidden_beacon_bss) {
   struct cfg80211_internal_bss *hbss;
@@ -114,10 +114,10 @@ static inline void bss_ref_put(struct cfg80211_registered_device *dev,
   bss_free(bss);
 }
 
-static bool __cfg80211_unlink_bss(struct cfg80211_registered_device *dev,
+static bool __cfg80211_unlink_bss(struct cfg80211_registered_device *rdev,
       struct cfg80211_internal_bss *bss)
 {
- lockdep_assert_held(&dev->bss_lock);
+ lockdep_assert_held(&rdev->bss_lock);
 
  if (!list_empty(&bss->hidden_list)) {
   /*
@@ -134,45 +134,52 @@ static bool __cfg80211_unlink_bss(struct cfg80211_registered_device *dev,
  }
 
  list_del_init(&bss->list);
- rb_erase(&bss->rbn, &dev->bss_tree);
- bss_ref_put(dev, bss);
+ rb_erase(&bss->rbn, &rdev->bss_tree);
+ bss_ref_put(rdev, bss);
  return true;
 }
 
-static void __cfg80211_bss_expire(struct cfg80211_registered_device *dev,
+static void __cfg80211_bss_expire(struct cfg80211_registered_device *rdev,
       unsigned long expire_time)
 {
  struct cfg80211_internal_bss *bss, *tmp;
  bool expired = false;
 
- lockdep_assert_held(&dev->bss_lock);
+ lockdep_assert_held(&rdev->bss_lock);
 
- list_for_each_entry_safe(bss, tmp, &dev->bss_list, list) {
+ list_for_each_entry_safe(bss, tmp, &rdev->bss_list, list) {
   if (atomic_read(&bss->hold))
    continue;
   if (!time_after(expire_time, bss->ts))
    continue;
 
-  if (__cfg80211_unlink_bss(dev, bss))
+  if (__cfg80211_unlink_bss(rdev, bss))
    expired = true;
  }
 
  if (expired)
-  dev->bss_generation++;
+  rdev->bss_generation++;
 }
 
-void ___cfg80211_scan_done(struct cfg80211_registered_device *rdev, bool leak)
+void ___cfg80211_scan_done(struct cfg80211_registered_device *rdev,
+      bool send_message)
 {
  struct cfg80211_scan_request *request;
  struct wireless_dev *wdev;
+ struct sk_buff *msg;
 #ifdef CONFIG_CFG80211_WEXT
  union iwreq_data wrqu;
 #endif
 
- lockdep_assert_held(&rdev->sched_scan_mtx);
+ ASSERT_RTNL();
 
- request = rdev->scan_req;
+ if (rdev->scan_msg) {
+  nl80211_send_scan_result(rdev, rdev->scan_msg);
+  rdev->scan_msg = NULL;
+  return;
+ }
 
+ request = rdev->scan_req;
  if (!request)
   return;
 
@@ -186,18 +193,16 @@ void ___cfg80211_scan_done(struct cfg80211_registered_device *rdev, bool leak)
  if (wdev->netdev)
   cfg80211_sme_scan_done(wdev->netdev);
 
- if (request->aborted) {
-  nl80211_send_scan_aborted(rdev, wdev);
- } else {
-  if (request->flags & NL80211_SCAN_FLAG_FLUSH) {
-   /* flush entries from previous scans */
-   spin_lock_bh(&rdev->bss_lock);
-   __cfg80211_bss_expire(rdev, request->scan_start);
-   spin_unlock_bh(&rdev->bss_lock);
-  }
-  nl80211_send_scan_done(rdev, wdev);
+ if (!request->aborted &&
+     request->flags & NL80211_SCAN_FLAG_FLUSH) {
+  /* flush entries from previous scans */
+  spin_lock_bh(&rdev->bss_lock);
+  __cfg80211_bss_expire(rdev, request->scan_start);
+  spin_unlock_bh(&rdev->bss_lock);
  }
 
+ msg = nl80211_build_scan_msg(rdev, wdev, request->aborted);
+
 #ifdef CONFIG_CFG80211_WEXT
  if (wdev->netdev && !request->aborted) {
   memset(&wrqu, 0, sizeof(wrqu));
@@ -210,17 +215,12 @@ void ___cfg80211_scan_done(struct cfg80211_registered_device *rdev, bool leak)
   dev_put(wdev->netdev);
 
  rdev->scan_req = NULL;
+ kfree(request);
 
- /*
-  * OK. If this is invoked with "leak" then we can't
-  * free this ... but we've cleaned it up anyway. The
-  * driver failed to call the scan_done callback, so
-  * all bets are off, it might still be trying to use
-  * the scan request or not ... if it accesses the dev
-  * in there (it shouldn't anyway) then it may crash.
-  */
- if (!leak)
-  kfree(request);
+ if (!send_message)
+  rdev->scan_msg = msg;
+ else
+  nl80211_send_scan_result(rdev, msg);
 }
 
 void __cfg80211_scan_done(struct work_struct *wk)
@@ -230,18 +230,19 @@ void __cfg80211_scan_done(struct work_struct *wk)
  rdev = container_of(wk, struct cfg80211_registered_device,
        scan_done_wk);
 
- mutex_lock(&rdev->sched_scan_mtx);
- ___cfg80211_scan_done(rdev, false);
- mutex_unlock(&rdev->sched_scan_mtx);
+ rtnl_lock();
+ ___cfg80211_scan_done(rdev, true);
+ rtnl_unlock();
 }
 
 void cfg80211_scan_done(struct cfg80211_scan_request *request, bool aborted)
 {
  trace_cfg80211_scan_done(request, aborted);
- WARN_ON(request != wiphy_to_dev(request->wiphy)->scan_req);
+ WARN_ON(request != wiphy_to_rdev(request->wiphy)->scan_req);
 
  request->aborted = aborted;
- queue_work(cfg80211_wq, &wiphy_to_dev(request->wiphy)->scan_done_wk);
+ request->notified = true;
+ queue_work(cfg80211_wq, &wiphy_to_rdev(request->wiphy)->scan_done_wk);
 }
 EXPORT_SYMBOL(cfg80211_scan_done);
 
@@ -253,7 +254,7 @@ void __cfg80211_sched_scan_results(struct work_struct *wk)
  rdev = container_of(wk, struct cfg80211_registered_device,
        sched_scan_results_wk);
 
- mutex_lock(&rdev->sched_scan_mtx);
+ rtnl_lock();
 
  request = rdev->sched_scan_req;
 
@@ -270,28 +271,36 @@ void __cfg80211_sched_scan_results(struct work_struct *wk)
   nl80211_send_sched_scan_results(rdev, request->dev);
  }
 
- mutex_unlock(&rdev->sched_scan_mtx);
+ rtnl_unlock();
 }
 
 void cfg80211_sched_scan_results(struct wiphy *wiphy)
 {
  trace_cfg80211_sched_scan_results(wiphy);
  /* ignore if we're not scanning */
- if (wiphy_to_dev(wiphy)->sched_scan_req)
+ if (wiphy_to_rdev(wiphy)->sched_scan_req)
   queue_work(cfg80211_wq,
-      &wiphy_to_dev(wiphy)->sched_scan_results_wk);
+      &wiphy_to_rdev(wiphy)->sched_scan_results_wk);
 }
 EXPORT_SYMBOL(cfg80211_sched_scan_results);
 
-void cfg80211_sched_scan_stopped(struct wiphy *wiphy)
+void cfg80211_sched_scan_stopped_rtnl(struct wiphy *wiphy)
 {
- struct cfg80211_registered_device *rdev = wiphy_to_dev(wiphy);
+ struct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);
+
+ ASSERT_RTNL();
 
  trace_cfg80211_sched_scan_stopped(wiphy);
 
- mutex_lock(&rdev->sched_scan_mtx);
  __cfg80211_stop_sched_scan(rdev, true);
- mutex_unlock(&rdev->sched_scan_mtx);
+}
+EXPORT_SYMBOL(cfg80211_sched_scan_stopped_rtnl);
+
+void cfg80211_sched_scan_stopped(struct wiphy *wiphy)
+{
+ rtnl_lock();
+ cfg80211_sched_scan_stopped_rtnl(wiphy);
+ rtnl_unlock();
 }
 EXPORT_SYMBOL(cfg80211_sched_scan_stopped);
 
@@ -300,7 +309,7 @@ int __cfg80211_stop_sched_scan(struct cfg80211_registered_device *rdev,
 {
  struct net_device *dev;
 
- lockdep_assert_held(&rdev->sched_scan_mtx);
+ ASSERT_RTNL();
 
  if (!rdev->sched_scan_req)
   return -ENOENT;
@@ -321,21 +330,21 @@ int __cfg80211_stop_sched_scan(struct cfg80211_registered_device *rdev,
  return 0;
 }
 
-void cfg80211_bss_age(struct cfg80211_registered_device *dev,
+void cfg80211_bss_age(struct cfg80211_registered_device *rdev,
                       unsigned long age_secs)
 {
  struct cfg80211_internal_bss *bss;
  unsigned long age_jiffies = msecs_to_jiffies(age_secs * MSEC_PER_SEC);
 
- spin_lock_bh(&dev->bss_lock);
- list_for_each_entry(bss, &dev->bss_list, list)
+ spin_lock_bh(&rdev->bss_lock);
+ list_for_each_entry(bss, &rdev->bss_list, list)
   bss->ts -= age_jiffies;
- spin_unlock_bh(&dev->bss_lock);
+ spin_unlock_bh(&rdev->bss_lock);
 }
 
-void cfg80211_bss_expire(struct cfg80211_registered_device *dev)
+void cfg80211_bss_expire(struct cfg80211_registered_device *rdev)
 {
- __cfg80211_bss_expire(dev, jiffies - IEEE80211_SCAN_RESULT_EXPIRE);
+ __cfg80211_bss_expire(rdev, jiffies - IEEE80211_SCAN_RESULT_EXPIRE);
 }
 
 const u8 *cfg80211_find_ie(u8 eid, const u8 *ies, int len)
@@ -464,10 +473,6 @@ static int cmp_bss(struct cfg80211_bss *a,
   }
  }
 
- /*
-  * we can't use compare_ether_addr here since we need a < > operator.
-  * The binary return value of compare_ether_addr isn't enough
-  */
  r = memcmp(a->bssid, b->bssid, sizeof(a->bssid));
  if (r)
   return r;
@@ -522,38 +527,41 @@ static int cmp_bss(struct cfg80211_bss *a,
  }
 }
 
+/* Returned bss is reference counted and must be cleaned up appropriately. */
 struct cfg80211_bss *cfg80211_get_bss(struct wiphy *wiphy,
           struct ieee80211_channel *channel,
           const u8 *bssid,
           const u8 *ssid, size_t ssid_len,
           u16 capa_mask, u16 capa_val)
 {
- struct cfg80211_registered_device *dev = wiphy_to_dev(wiphy);
+ struct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);
  struct cfg80211_internal_bss *bss, *res = NULL;
  unsigned long now = jiffies;
 
  trace_cfg80211_get_bss(wiphy, channel, bssid, ssid, ssid_len, capa_mask,
           capa_val);
 
- spin_lock_bh(&dev->bss_lock);
+ spin_lock_bh(&rdev->bss_lock);
 
- list_for_each_entry(bss, &dev->bss_list, list) {
+ list_for_each_entry(bss, &rdev->bss_list, list) {
   if ((bss->pub.capability & capa_mask) != capa_val)
    continue;
   if (channel && bss->pub.channel != channel)
    continue;
+  if (!is_valid_ether_addr(bss->pub.bssid))
+   continue;
   /* Don't get expired BSS structs */
   if (time_after(now, bss->ts + IEEE80211_SCAN_RESULT_EXPIRE) &&
       !atomic_read(&bss->hold))
    continue;
   if (is_bss(&bss->pub, bssid, ssid, ssid_len)) {
    res = bss;
-   bss_ref_get(dev, res);
+   bss_ref_get(rdev, res);
    break;
   }
  }
 
- spin_unlock_bh(&dev->bss_lock);
+ spin_unlock_bh(&rdev->bss_lock);
  if (!res)
   return NULL;
  trace_cfg80211_return_bss(&res->pub);
@@ -561,10 +569,10 @@ struct cfg80211_bss *cfg80211_get_bss(struct wiphy *wiphy,
 }
 EXPORT_SYMBOL(cfg80211_get_bss);
 
-static void rb_insert_bss(struct cfg80211_registered_device *dev,
+static void rb_insert_bss(struct cfg80211_registered_device *rdev,
      struct cfg80211_internal_bss *bss)
 {
- struct rb_node **p = &dev->bss_tree.rb_node;
+ struct rb_node **p = &rdev->bss_tree.rb_node;
  struct rb_node *parent = NULL;
  struct cfg80211_internal_bss *tbss;
  int cmp;
@@ -587,15 +595,15 @@ static void rb_insert_bss(struct cfg80211_registered_device *dev,
  }
 
  rb_link_node(&bss->rbn, parent, p);
- rb_insert_color(&bss->rbn, &dev->bss_tree);
+ rb_insert_color(&bss->rbn, &rdev->bss_tree);
 }
 
 static struct cfg80211_internal_bss *
-rb_find_bss(struct cfg80211_registered_device *dev,
+rb_find_bss(struct cfg80211_registered_device *rdev,
      struct cfg80211_internal_bss *res,
      enum bss_compare_mode mode)
 {
- struct rb_node *n = dev->bss_tree.rb_node;
+ struct rb_node *n = rdev->bss_tree.rb_node;
  struct cfg80211_internal_bss *bss;
  int r;
 
@@ -614,7 +622,7 @@ rb_find_bss(struct cfg80211_registered_device *dev,
  return NULL;
 }
 
-static bool cfg80211_combine_bsses(struct cfg80211_registered_device *dev,
+static bool cfg80211_combine_bsses(struct cfg80211_registered_device *rdev,
        struct cfg80211_internal_bss *new)
 {
  const struct cfg80211_bss_ies *ies;
@@ -644,11 +652,13 @@ static bool cfg80211_combine_bsses(struct cfg80211_registered_device *dev,
 
  /* This is the bad part ... */
 
- list_for_each_entry(bss, &dev->bss_list, list) {
+ list_for_each_entry(bss, &rdev->bss_list, list) {
   if (!ether_addr_equal(bss->pub.bssid, new->pub.bssid))
    continue;
   if (bss->pub.channel != new->pub.channel)
    continue;
+  if (bss->pub.scan_width != new->pub.scan_width)
+   continue;
   if (rcu_access_pointer(bss->pub.beacon_ies))
    continue;
   ies = rcu_access_pointer(bss->pub.ies);
@@ -659,9 +669,6 @@ static bool cfg80211_combine_bsses(struct cfg80211_registered_device *dev,
    continue;
   if (ssidlen && ie[1] != ssidlen)
    continue;
-  /* that would be odd ... */
-  if (bss->pub.beacon_ies)
-   continue;
   if (WARN_ON_ONCE(bss->pub.hidden_beacon_bss))
    continue;
   if (WARN_ON_ONCE(!list_empty(&bss->hidden_list)))
@@ -677,9 +684,11 @@ static bool cfg80211_combine_bsses(struct cfg80211_registered_device *dev,
  return true;
 }
 
+/* Returned bss is reference counted and must be cleaned up appropriately. */
 static struct cfg80211_internal_bss *
-cfg80211_bss_update(struct cfg80211_registered_device *dev,
-      struct cfg80211_internal_bss *tmp)
+cfg80211_bss_update(struct cfg80211_registered_device *rdev,
+      struct cfg80211_internal_bss *tmp,
+      bool signal_valid)
 {
  struct cfg80211_internal_bss *found = NULL;
 
@@ -688,14 +697,14 @@ cfg80211_bss_update(struct cfg80211_registered_device *dev,
 
  tmp->ts = jiffies;
 
- spin_lock_bh(&dev->bss_lock);
+ spin_lock_bh(&rdev->bss_lock);
 
  if (WARN_ON(!rcu_access_pointer(tmp->pub.ies))) {
-  spin_unlock_bh(&dev->bss_lock);
+  spin_unlock_bh(&rdev->bss_lock);
   return NULL;
  }
 
- found = rb_find_bss(dev, tmp, BSS_CMP_REGULAR);
+ found = rb_find_bss(rdev, tmp, BSS_CMP_REGULAR);
 
  if (found) {
   /* Update IEs */
@@ -764,7 +773,12 @@ cfg80211_bss_update(struct cfg80211_registered_device *dev,
   }
 
   found->pub.beacon_interval = tmp->pub.beacon_interval;
-  found->pub.signal = tmp->pub.signal;
+  /*
+   * don't update the signal if beacon was heard on
+   * adjacent channel.
+   */
+  if (signal_valid)
+   found->pub.signal = tmp->pub.signal;
   found->pub.capability = tmp->pub.capability;
   found->ts = tmp->ts;
  } else {
@@ -777,7 +791,7 @@ cfg80211_bss_update(struct cfg80211_registered_device *dev,
    * is allocated on the stack since it's not needed in the
    * more common case of an update
    */
-  new = kzalloc(sizeof(*new) + dev->wiphy.bss_priv_size,
+  new = kzalloc(sizeof(*new) + rdev->wiphy.bss_priv_size,
          GFP_ATOMIC);
   if (!new) {
    ies = (void *)rcu_dereference(tmp->pub.beacon_ies);
@@ -793,9 +807,9 @@ cfg80211_bss_update(struct cfg80211_registered_device *dev,
   INIT_LIST_HEAD(&new->hidden_list);
 
   if (rcu_access_pointer(tmp->pub.proberesp_ies)) {
-   hidden = rb_find_bss(dev, tmp, BSS_CMP_HIDE_ZLEN);
+   hidden = rb_find_bss(rdev, tmp, BSS_CMP_HIDE_ZLEN);
    if (!hidden)
-    hidden = rb_find_bss(dev, tmp,
+    hidden = rb_find_bss(rdev, tmp,
            BSS_CMP_HIDE_NUL);
    if (hidden) {
     new->pub.hidden_beacon_bss = &hidden->pub;
@@ -812,24 +826,24 @@ cfg80211_bss_update(struct cfg80211_registered_device *dev,
     * expensive search for any probe responses that should
     * be grouped with this beacon for updates ...
     */
-   if (!cfg80211_combine_bsses(dev, new)) {
+   if (!cfg80211_combine_bsses(rdev, new)) {
     kfree(new);
     goto drop;
    }
   }
 
-  list_add_tail(&new->list, &dev->bss_list);
-  rb_insert_bss(dev, new);
+  list_add_tail(&new->list, &rdev->bss_list);
+  rb_insert_bss(rdev, new);
   found = new;
  }
 
- dev->bss_generation++;
- bss_ref_get(dev, found);
- spin_unlock_bh(&dev->bss_lock);
+ rdev->bss_generation++;
+ bss_ref_get(rdev, found);
+ spin_unlock_bh(&rdev->bss_lock);
 
  return found;
  drop:
- spin_unlock_bh(&dev->bss_lock);
+ spin_unlock_bh(&rdev->bss_lock);
  return NULL;
 }
 
@@ -865,15 +879,19 @@ cfg80211_get_bss_channel(struct wiphy *wiphy, const u8 *ie, size_t ielen,
  return channel;
 }
 
+/* Returned bss is reference counted and must be cleaned up appropriately. */
 struct cfg80211_bss*
-cfg80211_inform_bss(struct wiphy *wiphy,
-      struct ieee80211_channel *channel,
-      const u8 *bssid, u64 tsf, u16 capability,
-      u16 beacon_interval, const u8 *ie, size_t ielen,
-      s32 signal, gfp_t gfp)
+cfg80211_inform_bss_width(struct wiphy *wiphy,
+     struct ieee80211_channel *rx_channel,
+     enum nl80211_bss_scan_width scan_width,
+     const u8 *bssid, u64 tsf, u16 capability,
+     u16 beacon_interval, const u8 *ie, size_t ielen,
+     s32 signal, gfp_t gfp)
 {
  struct cfg80211_bss_ies *ies;
+ struct ieee80211_channel *channel;
  struct cfg80211_internal_bss tmp = {}, *res;
+ bool signal_valid;
 
  if (WARN_ON(!wiphy))
   return NULL;
@@ -882,12 +900,13 @@ cfg80211_inform_bss(struct wiphy *wiphy,
    (signal < 0 || signal > 100)))
   return NULL;
 
- channel = cfg80211_get_bss_channel(wiphy, ie, ielen, channel);
+ channel = cfg80211_get_bss_channel(wiphy, ie, ielen, rx_channel);
  if (!channel)
   return NULL;
 
  memcpy(tmp.pub.bssid, bssid, ETH_ALEN);
  tmp.pub.channel = channel;
+ tmp.pub.scan_width = scan_width;
  tmp.pub.signal = signal;
  tmp.pub.beacon_interval = beacon_interval;
  tmp.pub.capability = capability;
@@ -909,7 +928,9 @@ cfg80211_inform_bss(struct wiphy *wiphy,
  rcu_assign_pointer(tmp.pub.beacon_ies, ies);
  rcu_assign_pointer(tmp.pub.ies, ies);
 
- res = cfg80211_bss_update(wiphy_to_dev(wiphy), &tmp);
+ signal_valid = abs(rx_channel->center_freq - channel->center_freq) <=
+  wiphy->max_adj_channel_rssi_comp;
+ res = cfg80211_bss_update(wiphy_to_rdev(wiphy), &tmp, signal_valid);
  if (!res)
   return NULL;
 
@@ -920,23 +941,28 @@ cfg80211_inform_bss(struct wiphy *wiphy,
  /* cfg80211_bss_update gives us a referenced result */
  return &res->pub;
 }
-EXPORT_SYMBOL(cfg80211_inform_bss);
+EXPORT_SYMBOL(cfg80211_inform_bss_width);
 
+/* Returned bss is reference counted and must be cleaned up appropriately. */
 struct cfg80211_bss *
-cfg80211_inform_bss_frame(struct wiphy *wiphy,
-     struct ieee80211_channel *channel,
-     struct ieee80211_mgmt *mgmt, size_t len,
-     s32 signal, gfp_t gfp)
+cfg80211_inform_bss_width_frame(struct wiphy *wiphy,
+    struct ieee80211_channel *rx_channel,
+    enum nl80211_bss_scan_width scan_width,
+    struct ieee80211_mgmt *mgmt, size_t len,
+    s32 signal, gfp_t gfp)
 {
  struct cfg80211_internal_bss tmp = {}, *res;
  struct cfg80211_bss_ies *ies;
+ struct ieee80211_channel *channel;
+ bool signal_valid;
  size_t ielen = len - offsetof(struct ieee80211_mgmt,
           u.probe_resp.variable);
 
  BUILD_BUG_ON(offsetof(struct ieee80211_mgmt, u.probe_resp.variable) !=
    offsetof(struct ieee80211_mgmt, u.beacon.variable));
 
- trace_cfg80211_inform_bss_frame(wiphy, channel, mgmt, len, signal);
+ trace_cfg80211_inform_bss_width_frame(wiphy, rx_channel, scan_width, mgmt,
+           len, signal);
 
  if (WARN_ON(!mgmt))
   return NULL;
@@ -952,7 +978,7 @@ cfg80211_inform_bss_frame(struct wiphy *wiphy,
   return NULL;
 
  channel = cfg80211_get_bss_channel(wiphy, mgmt->u.beacon.variable,
-        ielen, channel);
+        ielen, rx_channel);
  if (!channel)
   return NULL;
 
@@ -971,11 +997,14 @@ cfg80211_inform_bss_frame(struct wiphy *wiphy,
  
  memcpy(tmp.pub.bssid, mgmt->bssid, ETH_ALEN);
  tmp.pub.channel = channel;
+ tmp.pub.scan_width = scan_width;
  tmp.pub.signal = signal;
  tmp.pub.beacon_interval = le16_to_cpu(mgmt->u.probe_resp.beacon_int);
  tmp.pub.capability = le16_to_cpu(mgmt->u.probe_resp.capab_info);
 
- res = cfg80211_bss_update(wiphy_to_dev(wiphy), &tmp);
+ signal_valid = abs(rx_channel->center_freq - channel->center_freq) <=
+  wiphy->max_adj_channel_rssi_comp;
+ res = cfg80211_bss_update(wiphy_to_rdev(wiphy), &tmp, signal_valid);
  if (!res)
   return NULL;
 
@@ -986,11 +1015,11 @@ cfg80211_inform_bss_frame(struct wiphy *wiphy,
  /* cfg80211_bss_update gives us a referenced result */
  return &res->pub;
 }
-EXPORT_SYMBOL(cfg80211_inform_bss_frame);
+EXPORT_SYMBOL(cfg80211_inform_bss_width_frame);
 
 void cfg80211_ref_bss(struct wiphy *wiphy, struct cfg80211_bss *pub)
 {
- struct cfg80211_registered_device *dev = wiphy_to_dev(wiphy);
+ struct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);
  struct cfg80211_internal_bss *bss;
 
  if (!pub)
@@ -998,15 +1027,15 @@ void cfg80211_ref_bss(struct wiphy *wiphy, struct cfg80211_bss *pub)
 
  bss = container_of(pub, struct cfg80211_internal_bss, pub);
 
- spin_lock_bh(&dev->bss_lock);
- bss_ref_get(dev, bss);
- spin_unlock_bh(&dev->bss_lock);
+ spin_lock_bh(&rdev->bss_lock);
+ bss_ref_get(rdev, bss);
+ spin_unlock_bh(&rdev->bss_lock);
 }
 EXPORT_SYMBOL(cfg80211_ref_bss);
 
 void cfg80211_put_bss(struct wiphy *wiphy, struct cfg80211_bss *pub)
 {
- struct cfg80211_registered_device *dev = wiphy_to_dev(wiphy);
+ struct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);
  struct cfg80211_internal_bss *bss;
 
  if (!pub)
@@ -1014,15 +1043,15 @@ void cfg80211_put_bss(struct wiphy *wiphy, struct cfg80211_bss *pub)
 
  bss = container_of(pub, struct cfg80211_internal_bss, pub);
 
- spin_lock_bh(&dev->bss_lock);
- bss_ref_put(dev, bss);
- spin_unlock_bh(&dev->bss_lock);
+ spin_lock_bh(&rdev->bss_lock);
+ bss_ref_put(rdev, bss);
+ spin_unlock_bh(&rdev->bss_lock);
 }
 EXPORT_SYMBOL(cfg80211_put_bss);
 
 void cfg80211_unlink_bss(struct wiphy *wiphy, struct cfg80211_bss *pub)
 {
- struct cfg80211_registered_device *dev = wiphy_to_dev(wiphy);
+ struct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);
  struct cfg80211_internal_bss *bss;
 
  if (WARN_ON(!pub))
@@ -1030,16 +1059,35 @@ void cfg80211_unlink_bss(struct wiphy *wiphy, struct cfg80211_bss *pub)
 
  bss = container_of(pub, struct cfg80211_internal_bss, pub);
 
- spin_lock_bh(&dev->bss_lock);
+ spin_lock_bh(&rdev->bss_lock);
  if (!list_empty(&bss->list)) {
-  if (__cfg80211_unlink_bss(dev, bss))
-   dev->bss_generation++;
+  if (__cfg80211_unlink_bss(rdev, bss))
+   rdev->bss_generation++;
  }
- spin_unlock_bh(&dev->bss_lock);
+ spin_unlock_bh(&rdev->bss_lock);
 }
 EXPORT_SYMBOL(cfg80211_unlink_bss);
 
 #ifdef CONFIG_CFG80211_WEXT
+static struct cfg80211_registered_device *
+cfg80211_get_dev_from_ifindex(struct net *net, int ifindex)
+{
+ struct cfg80211_registered_device *rdev;
+ struct net_device *dev;
+
+ ASSERT_RTNL();
+
+ dev = dev_get_by_index(net, ifindex);
+ if (!dev)
+  return ERR_PTR(-ENODEV);
+ if (dev->ieee80211_ptr)
+  rdev = wiphy_to_rdev(dev->ieee80211_ptr->wiphy);
+ else
+  rdev = ERR_PTR(-ENODEV);
+ dev_put(dev);
+ return rdev;
+}
+
 int cfg80211_wext_siwscan(struct net_device *dev,
      struct iw_request_info *info,
      union iwreq_data *wrqu, char *extra)
@@ -1062,8 +1110,7 @@ int cfg80211_wext_siwscan(struct net_device *dev,
  if (IS_ERR(rdev))
   return PTR_ERR(rdev);
 
- mutex_lock(&rdev->sched_scan_mtx);
- if (rdev->scan_req) {
+ if (rdev->scan_req || rdev->scan_msg) {
   err = -EBUSY;
   goto out;
  }
@@ -1073,11 +1120,8 @@ int cfg80211_wext_siwscan(struct net_device *dev,
  /* Determine number of channels, needed to allocate creq */
  if (wreq && wreq->num_channels)
   n_channels = wreq->num_channels;
- else {
-  for (band = 0; band < IEEE80211_NUM_BANDS; band++)
-   if (wiphy->bands[band])
-    n_channels += wiphy->bands[band]->n_channels;
- }
+ else
+  n_channels = ieee80211_get_num_supported_channels(wiphy);
 
  creq = kzalloc(sizeof(*creq) + sizeof(struct cfg80211_ssid) +
          n_channels * sizeof(void *),
@@ -1117,7 +1161,11 @@ int cfg80211_wext_siwscan(struct net_device *dev,
     int k;
     int wiphy_freq = wiphy->bands[band]->channels[j].center_freq;
     for (k = 0; k < wreq->num_channels; k++) {
-     int wext_freq = cfg80211_wext_freq(wiphy, &wreq->channel_list[k]);
+     struct iw_freq *freq =
+      &wreq->channel_list[k];
+     int wext_freq =
+      cfg80211_wext_freq(freq);
+
      if (wext_freq == wiphy_freq)
       goto wext_freq_found;
     }
@@ -1169,9 +1217,7 @@ int cfg80211_wext_siwscan(struct net_device *dev,
   dev_hold(dev);
  }
  out:
- mutex_unlock(&rdev->sched_scan_mtx);
  kfree(creq);
- cfg80211_unlock_rdev(rdev);
  return err;
 }
 EXPORT_SYMBOL_GPL(cfg80211_wext_siwscan);
@@ -1431,7 +1477,7 @@ ieee80211_bss(struct wiphy *wiphy, struct iw_request_info *info,
 }
 
 
-static int ieee80211_scan_results(struct cfg80211_registered_device *dev,
+static int ieee80211_scan_results(struct cfg80211_registered_device *rdev,
       struct iw_request_info *info,
       char *buf, size_t len)
 {
@@ -1439,18 +1485,18 @@ static int ieee80211_scan_results(struct cfg80211_registered_device *dev,
  char *end_buf = buf + len;
  struct cfg80211_internal_bss *bss;
 
- spin_lock_bh(&dev->bss_lock);
- cfg80211_bss_expire(dev);
+ spin_lock_bh(&rdev->bss_lock);
+ cfg80211_bss_expire(rdev);
 
- list_for_each_entry(bss, &dev->bss_list, list) {
+ list_for_each_entry(bss, &rdev->bss_list, list) {
   if (buf + len - current_ev <= IW_EV_ADDR_LEN) {
-   spin_unlock_bh(&dev->bss_lock);
+   spin_unlock_bh(&rdev->bss_lock);
    return -E2BIG;
   }
-  current_ev = ieee80211_bss(&dev->wiphy, info, bss,
+  current_ev = ieee80211_bss(&rdev->wiphy, info, bss,
         current_ev, end_buf);
  }
- spin_unlock_bh(&dev->bss_lock);
+ spin_unlock_bh(&rdev->bss_lock);
  return current_ev - buf;
 }
 
@@ -1470,10 +1516,8 @@ int cfg80211_wext_giwscan(struct net_device *dev,
  if (IS_ERR(rdev))
   return PTR_ERR(rdev);
 
- if (rdev->scan_req) {
-  res = -EAGAIN;
-  goto out;
- }
+ if (rdev->scan_req || rdev->scan_msg)
+  return -EAGAIN;
 
  res = ieee80211_scan_results(rdev, info, extra, data->length);
  data->length = 0;
@@ -1482,8 +1526,6 @@ int cfg80211_wext_giwscan(struct net_device *dev,
   res = 0;
  }
 
- out:
- cfg80211_unlock_rdev(rdev);
  return res;
 }
 EXPORT_SYMBOL_GPL(cfg80211_wext_giwscan);
diff --git a/net/wireless/sme.c b/net/wireless/sme.c
index 3ed35c3..8bbeeb3 100644
--- a/net/wireless/sme.c
+++ b/net/wireless/sme.c
@@ -1,5 +1,7 @@
 /*
- * SME code for cfg80211's connect emulation.
+ * SME code for cfg80211
+ * both driver SME event handling and the SME implementation
+ * (for nl80211's connect() and wext)
  *
  * Copyright 2009 Johannes Berg <johannes@sipsolutions.net>
  * Copyright (C) 2009   Intel Corporation. All rights reserved.
@@ -18,18 +20,26 @@
 #include "reg.h"
 #include "rdev-ops.h"
 
+/*
+ * Software SME in cfg80211, using auth/assoc/deauth calls to the
+ * driver. This is is for implementing nl80211's connect/disconnect
+ * and wireless extensions (if configured.)
+ */
+
 struct cfg80211_conn {
  struct cfg80211_connect_params params;
  /* these are sub-states of the _CONNECTING sme_state */
  enum {
-  CFG80211_CONN_IDLE,
   CFG80211_CONN_SCANNING,
   CFG80211_CONN_SCAN_AGAIN,
   CFG80211_CONN_AUTHENTICATE_NEXT,
   CFG80211_CONN_AUTHENTICATING,
+  CFG80211_CONN_AUTH_FAILED,
   CFG80211_CONN_ASSOCIATE_NEXT,
   CFG80211_CONN_ASSOCIATING,
-  CFG80211_CONN_DEAUTH_ASSOC_FAIL,
+  CFG80211_CONN_ASSOC_FAILED,
+  CFG80211_CONN_DEAUTH,
+  CFG80211_CONN_CONNECTED,
  } state;
  u8 bssid[ETH_ALEN], prev_bssid[ETH_ALEN];
  u8 *ie;
@@ -37,71 +47,33 @@ struct cfg80211_conn {
  bool auto_auth, prev_bssid_valid;
 };
 
-static bool cfg80211_is_all_idle(void)
+static void cfg80211_sme_free(struct wireless_dev *wdev)
 {
- struct cfg80211_registered_device *rdev;
- struct wireless_dev *wdev;
- bool is_all_idle = true;
-
- mutex_lock(&cfg80211_mutex);
-
- /*
-  * All devices must be idle as otherwise if you are actively
-  * scanning some new beacon hints could be learned and would
-  * count as new regulatory hints.
-  */
- list_for_each_entry(rdev, &cfg80211_rdev_list, list) {
-  cfg80211_lock_rdev(rdev);
-  list_for_each_entry(wdev, &rdev->wdev_list, list) {
-   wdev_lock(wdev);
-   if (wdev->sme_state != CFG80211_SME_IDLE)
-    is_all_idle = false;
-   wdev_unlock(wdev);
-  }
-  cfg80211_unlock_rdev(rdev);
- }
-
- mutex_unlock(&cfg80211_mutex);
-
- return is_all_idle;
-}
-
-static void disconnect_work(struct work_struct *work)
-{
- if (!cfg80211_is_all_idle())
+ if (!wdev->conn)
   return;
 
- regulatory_hint_disconnect();
+ kfree(wdev->conn->ie);
+ kfree(wdev->conn);
+ wdev->conn = NULL;
 }
 
-static DECLARE_WORK(cfg80211_disconnect_work, disconnect_work);
-
 static int cfg80211_conn_scan(struct wireless_dev *wdev)
 {
- struct cfg80211_registered_device *rdev = wiphy_to_dev(wdev->wiphy);
+ struct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);
  struct cfg80211_scan_request *request;
  int n_channels, err;
 
  ASSERT_RTNL();
- ASSERT_RDEV_LOCK(rdev);
  ASSERT_WDEV_LOCK(wdev);
- lockdep_assert_held(&rdev->sched_scan_mtx);
 
- if (rdev->scan_req)
+ if (rdev->scan_req || rdev->scan_msg)
   return -EBUSY;
 
- if (wdev->conn->params.channel) {
+ if (wdev->conn->params.channel)
   n_channels = 1;
- } else {
-  enum ieee80211_band band;
-  n_channels = 0;
+ else
+  n_channels = ieee80211_get_num_supported_channels(wdev->wiphy);
 
-  for (band = 0; band < IEEE80211_NUM_BANDS; band++) {
-   if (!wdev->wiphy->bands[band])
-    continue;
-   n_channels += wdev->wiphy->bands[band]->n_channels;
-  }
- }
  request = kzalloc(sizeof(*request) + sizeof(request->ssids[0]) +
      sizeof(request->channels[0]) * n_channels,
      GFP_KERNEL);
@@ -158,7 +130,7 @@ static int cfg80211_conn_scan(struct wireless_dev *wdev)
 
 static int cfg80211_conn_do_work(struct wireless_dev *wdev)
 {
- struct cfg80211_registered_device *rdev = wiphy_to_dev(wdev->wiphy);
+ struct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);
  struct cfg80211_connect_params *params;
  struct cfg80211_assoc_request req = {};
  int err;
@@ -171,20 +143,27 @@ static int cfg80211_conn_do_work(struct wireless_dev *wdev)
  params = &wdev->conn->params;
 
  switch (wdev->conn->state) {
+ case CFG80211_CONN_SCANNING:
+  /* didn't find it during scan ... */
+  return -ENOENT;
  case CFG80211_CONN_SCAN_AGAIN:
   return cfg80211_conn_scan(wdev);
  case CFG80211_CONN_AUTHENTICATE_NEXT:
-  BUG_ON(!rdev->ops->auth);
+  if (WARN_ON(!rdev->ops->auth))
+   return -EOPNOTSUPP;
   wdev->conn->state = CFG80211_CONN_AUTHENTICATING;
-  return __cfg80211_mlme_auth(rdev, wdev->netdev,
-         params->channel, params->auth_type,
-         params->bssid,
-         params->ssid, params->ssid_len,
-         NULL, 0,
-         params->key, params->key_len,
-         params->key_idx, NULL, 0);
+  return cfg80211_mlme_auth(rdev, wdev->netdev,
+       params->channel, params->auth_type,
+       params->bssid,
+       params->ssid, params->ssid_len,
+       NULL, 0,
+       params->key, params->key_len,
+       params->key_idx, NULL, 0);
+ case CFG80211_CONN_AUTH_FAILED:
+  return -ENOTCONN;
  case CFG80211_CONN_ASSOCIATE_NEXT:
-  BUG_ON(!rdev->ops->assoc);
+  if (WARN_ON(!rdev->ops->assoc))
+   return -EOPNOTSUPP;
   wdev->conn->state = CFG80211_CONN_ASSOCIATING;
   if (wdev->conn->prev_bssid_valid)
    req.prev_bssid = wdev->conn->prev_bssid;
@@ -198,21 +177,27 @@ static int cfg80211_conn_do_work(struct wireless_dev *wdev)
   req.vht_capa = params->vht_capa;
   req.vht_capa_mask = params->vht_capa_mask;
 
-  err = __cfg80211_mlme_assoc(rdev, wdev->netdev, params->channel,
-         params->bssid, params->ssid,
-         params->ssid_len, &req);
+  err = cfg80211_mlme_assoc(rdev, wdev->netdev, params->channel,
+       params->bssid, params->ssid,
+       params->ssid_len, &req);
   if (err)
-   __cfg80211_mlme_deauth(rdev, wdev->netdev, params->bssid,
-            NULL, 0,
-            WLAN_REASON_DEAUTH_LEAVING,
-            false);
+   cfg80211_mlme_deauth(rdev, wdev->netdev, params->bssid,
+          NULL, 0,
+          WLAN_REASON_DEAUTH_LEAVING,
+          false);
   return err;
- case CFG80211_CONN_DEAUTH_ASSOC_FAIL:
-  __cfg80211_mlme_deauth(rdev, wdev->netdev, params->bssid,
-           NULL, 0,
-           WLAN_REASON_DEAUTH_LEAVING, false);
-  /* return an error so that we call __cfg80211_connect_result() */
-  return -EINVAL;
+ case CFG80211_CONN_ASSOC_FAILED:
+  cfg80211_mlme_deauth(rdev, wdev->netdev, params->bssid,
+         NULL, 0,
+         WLAN_REASON_DEAUTH_LEAVING, false);
+  return -ENOTCONN;
+ case CFG80211_CONN_DEAUTH:
+  cfg80211_mlme_deauth(rdev, wdev->netdev, params->bssid,
+         NULL, 0,
+         WLAN_REASON_DEAUTH_LEAVING, false);
+  /* free directly, disconnected event already sent */
+  cfg80211_sme_free(wdev);
+  return 0;
  default:
   return 0;
  }
@@ -226,9 +211,6 @@ void cfg80211_conn_work(struct work_struct *work)
  u8 bssid_buf[ETH_ALEN], *bssid = NULL;
 
  rtnl_lock();
- cfg80211_lock_rdev(rdev);
- mutex_lock(&rdev->devlist_mtx);
- mutex_lock(&rdev->sched_scan_mtx);
 
  list_for_each_entry(wdev, &rdev->wdev_list, list) {
   if (!wdev->netdev)
@@ -239,7 +221,8 @@ void cfg80211_conn_work(struct work_struct *work)
    wdev_unlock(wdev);
    continue;
   }
-  if (wdev->sme_state != CFG80211_SME_CONNECTING || !wdev->conn) {
+  if (!wdev->conn ||
+      wdev->conn->state == CFG80211_CONN_CONNECTED) {
    wdev_unlock(wdev);
    continue;
   }
@@ -247,24 +230,23 @@ void cfg80211_conn_work(struct work_struct *work)
    memcpy(bssid_buf, wdev->conn->params.bssid, ETH_ALEN);
    bssid = bssid_buf;
   }
-  if (cfg80211_conn_do_work(wdev))
+  if (cfg80211_conn_do_work(wdev)) {
    __cfg80211_connect_result(
      wdev->netdev, bssid,
      NULL, 0, NULL, 0,
      WLAN_STATUS_UNSPECIFIED_FAILURE,
      false, NULL);
+  }
   wdev_unlock(wdev);
  }
 
- mutex_unlock(&rdev->sched_scan_mtx);
- mutex_unlock(&rdev->devlist_mtx);
- cfg80211_unlock_rdev(rdev);
  rtnl_unlock();
 }
 
+/* Returned bss is reference counted and must be cleaned up appropriately. */
 static struct cfg80211_bss *cfg80211_get_conn_bss(struct wireless_dev *wdev)
 {
- struct cfg80211_registered_device *rdev = wiphy_to_dev(wdev->wiphy);
+ struct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);
  struct cfg80211_bss *bss;
  u16 capa = WLAN_CAPABILITY_ESS;
 
@@ -294,14 +276,11 @@ static struct cfg80211_bss *cfg80211_get_conn_bss(struct wireless_dev *wdev)
 static void __cfg80211_sme_scan_done(struct net_device *dev)
 {
  struct wireless_dev *wdev = dev->ieee80211_ptr;
- struct cfg80211_registered_device *rdev = wiphy_to_dev(wdev->wiphy);
+ struct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);
  struct cfg80211_bss *bss;
 
  ASSERT_WDEV_LOCK(wdev);
 
- if (wdev->sme_state != CFG80211_SME_CONNECTING)
-  return;
-
  if (!wdev->conn)
   return;
 
@@ -310,20 +289,10 @@ static void __cfg80211_sme_scan_done(struct net_device *dev)
   return;
 
  bss = cfg80211_get_conn_bss(wdev);
- if (bss) {
+ if (bss)
   cfg80211_put_bss(&rdev->wiphy, bss);
- } else {
-  /* not found */
-  if (wdev->conn->state == CFG80211_CONN_SCAN_AGAIN)
-   schedule_work(&rdev->conn_work);
-  else
-   __cfg80211_connect_result(
-     wdev->netdev,
-     wdev->conn->params.bssid,
-     NULL, 0, NULL, 0,
-     WLAN_STATUS_UNSPECIFIED_FAILURE,
-     false, NULL);
- }
+ else
+  schedule_work(&rdev->conn_work);
 }
 
 void cfg80211_sme_scan_done(struct net_device *dev)
@@ -335,22 +304,16 @@ void cfg80211_sme_scan_done(struct net_device *dev)
  wdev_unlock(wdev);
 }
 
-void cfg80211_sme_rx_auth(struct net_device *dev,
-     const u8 *buf, size_t len)
+void cfg80211_sme_rx_auth(struct wireless_dev *wdev, const u8 *buf, size_t len)
 {
- struct wireless_dev *wdev = dev->ieee80211_ptr;
  struct wiphy *wiphy = wdev->wiphy;
- struct cfg80211_registered_device *rdev = wiphy_to_dev(wiphy);
+ struct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);
  struct ieee80211_mgmt *mgmt = (struct ieee80211_mgmt *)buf;
  u16 status_code = le16_to_cpu(mgmt->u.auth.status_code);
 
  ASSERT_WDEV_LOCK(wdev);
 
- /* should only RX auth frames when connecting */
- if (wdev->sme_state != CFG80211_SME_CONNECTING)
-  return;
-
- if (WARN_ON(!wdev->conn))
+ if (!wdev->conn || wdev->conn->state == CFG80211_CONN_CONNECTED)
   return;
 
  if (status_code == WLAN_STATUS_NOT_SUPPORTED_AUTH_ALG &&
@@ -379,46 +342,238 @@ void cfg80211_sme_rx_auth(struct net_device *dev,
   wdev->conn->state = CFG80211_CONN_AUTHENTICATE_NEXT;
   schedule_work(&rdev->conn_work);
  } else if (status_code != WLAN_STATUS_SUCCESS) {
-  __cfg80211_connect_result(dev, mgmt->bssid, NULL, 0, NULL, 0,
+  __cfg80211_connect_result(wdev->netdev, mgmt->bssid,
+       NULL, 0, NULL, 0,
        status_code, false, NULL);
- } else if (wdev->sme_state == CFG80211_SME_CONNECTING &&
-   wdev->conn->state == CFG80211_CONN_AUTHENTICATING) {
+ } else if (wdev->conn->state == CFG80211_CONN_AUTHENTICATING) {
   wdev->conn->state = CFG80211_CONN_ASSOCIATE_NEXT;
   schedule_work(&rdev->conn_work);
  }
 }
 
-bool cfg80211_sme_failed_reassoc(struct wireless_dev *wdev)
+bool cfg80211_sme_rx_assoc_resp(struct wireless_dev *wdev, u16 status)
 {
- struct wiphy *wiphy = wdev->wiphy;
- struct cfg80211_registered_device *rdev = wiphy_to_dev(wiphy);
+ struct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);
 
- if (WARN_ON(!wdev->conn))
+ if (!wdev->conn)
   return false;
 
- if (!wdev->conn->prev_bssid_valid)
+ if (status == WLAN_STATUS_SUCCESS) {
+  wdev->conn->state = CFG80211_CONN_CONNECTED;
   return false;
+ }
 
- /*
-  * Some stupid APs don't accept reassoc, so we
-  * need to fall back to trying regular assoc.
-  */
- wdev->conn->prev_bssid_valid = false;
- wdev->conn->state = CFG80211_CONN_ASSOCIATE_NEXT;
+ if (wdev->conn->prev_bssid_valid) {
+  /*
+   * Some stupid APs don't accept reassoc, so we
+   * need to fall back to trying regular assoc;
+   * return true so no event is sent to userspace.
+   */
+  wdev->conn->prev_bssid_valid = false;
+  wdev->conn->state = CFG80211_CONN_ASSOCIATE_NEXT;
+  schedule_work(&rdev->conn_work);
+  return true;
+ }
+
+ wdev->conn->state = CFG80211_CONN_ASSOC_FAILED;
  schedule_work(&rdev->conn_work);
+ return false;
+}
 
- return true;
+void cfg80211_sme_deauth(struct wireless_dev *wdev)
+{
+ cfg80211_sme_free(wdev);
 }
 
-void cfg80211_sme_failed_assoc(struct wireless_dev *wdev)
+void cfg80211_sme_auth_timeout(struct wireless_dev *wdev)
 {
- struct wiphy *wiphy = wdev->wiphy;
- struct cfg80211_registered_device *rdev = wiphy_to_dev(wiphy);
+ struct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);
 
- wdev->conn->state = CFG80211_CONN_DEAUTH_ASSOC_FAIL;
+ if (!wdev->conn)
+  return;
+
+ wdev->conn->state = CFG80211_CONN_AUTH_FAILED;
  schedule_work(&rdev->conn_work);
 }
 
+void cfg80211_sme_disassoc(struct wireless_dev *wdev)
+{
+ struct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);
+
+ if (!wdev->conn)
+  return;
+
+ wdev->conn->state = CFG80211_CONN_DEAUTH;
+ schedule_work(&rdev->conn_work);
+}
+
+void cfg80211_sme_assoc_timeout(struct wireless_dev *wdev)
+{
+ struct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);
+
+ if (!wdev->conn)
+  return;
+
+ wdev->conn->state = CFG80211_CONN_ASSOC_FAILED;
+ schedule_work(&rdev->conn_work);
+}
+
+static int cfg80211_sme_connect(struct wireless_dev *wdev,
+    struct cfg80211_connect_params *connect,
+    const u8 *prev_bssid)
+{
+ struct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);
+ struct cfg80211_bss *bss;
+ int err;
+
+ if (!rdev->ops->auth || !rdev->ops->assoc)
+  return -EOPNOTSUPP;
+
+ if (wdev->current_bss)
+  return -EALREADY;
+
+ if (WARN_ON(wdev->conn))
+  return -EINPROGRESS;
+
+ wdev->conn = kzalloc(sizeof(*wdev->conn), GFP_KERNEL);
+ if (!wdev->conn)
+  return -ENOMEM;
+
+ /*
+  * Copy all parameters, and treat explicitly IEs, BSSID, SSID.
+  */
+ memcpy(&wdev->conn->params, connect, sizeof(*connect));
+ if (connect->bssid) {
+  wdev->conn->params.bssid = wdev->conn->bssid;
+  memcpy(wdev->conn->bssid, connect->bssid, ETH_ALEN);
+ }
+
+ if (connect->ie) {
+  wdev->conn->ie = kmemdup(connect->ie, connect->ie_len,
+     GFP_KERNEL);
+  wdev->conn->params.ie = wdev->conn->ie;
+  if (!wdev->conn->ie) {
+   kfree(wdev->conn);
+   wdev->conn = NULL;
+   return -ENOMEM;
+  }
+ }
+
+ if (connect->auth_type == NL80211_AUTHTYPE_AUTOMATIC) {
+  wdev->conn->auto_auth = true;
+  /* start with open system ... should mostly work */
+  wdev->conn->params.auth_type =
+   NL80211_AUTHTYPE_OPEN_SYSTEM;
+ } else {
+  wdev->conn->auto_auth = false;
+ }
+
+ wdev->conn->params.ssid = wdev->ssid;
+ wdev->conn->params.ssid_len = wdev->ssid_len;
+
+ /* see if we have the bss already */
+ bss = cfg80211_get_conn_bss(wdev);
+
+ if (prev_bssid) {
+  memcpy(wdev->conn->prev_bssid, prev_bssid, ETH_ALEN);
+  wdev->conn->prev_bssid_valid = true;
+ }
+
+ /* we're good if we have a matching bss struct */
+ if (bss) {
+  err = cfg80211_conn_do_work(wdev);
+  cfg80211_put_bss(wdev->wiphy, bss);
+ } else {
+  /* otherwise we'll need to scan for the AP first */
+  err = cfg80211_conn_scan(wdev);
+
+  /*
+   * If we can't scan right now, then we need to scan again
+   * after the current scan finished, since the parameters
+   * changed (unless we find a good AP anyway).
+   */
+  if (err == -EBUSY) {
+   err = 0;
+   wdev->conn->state = CFG80211_CONN_SCAN_AGAIN;
+  }
+ }
+
+ if (err)
+  cfg80211_sme_free(wdev);
+
+ return err;
+}
+
+static int cfg80211_sme_disconnect(struct wireless_dev *wdev, u16 reason)
+{
+ struct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);
+ int err;
+
+ if (!wdev->conn)
+  return 0;
+
+ if (!rdev->ops->deauth)
+  return -EOPNOTSUPP;
+
+ if (wdev->conn->state == CFG80211_CONN_SCANNING ||
+     wdev->conn->state == CFG80211_CONN_SCAN_AGAIN) {
+  err = 0;
+  goto out;
+ }
+
+ /* wdev->conn->params.bssid must be set if > SCANNING */
+ err = cfg80211_mlme_deauth(rdev, wdev->netdev,
+       wdev->conn->params.bssid,
+       NULL, 0, reason, false);
+ out:
+ cfg80211_sme_free(wdev);
+ return err;
+}
+
+/*
+ * code shared for in-device and software SME
+ */
+
+static bool cfg80211_is_all_idle(void)
+{
+ struct cfg80211_registered_device *rdev;
+ struct wireless_dev *wdev;
+ bool is_all_idle = true;
+
+ /*
+  * All devices must be idle as otherwise if you are actively
+  * scanning some new beacon hints could be learned and would
+  * count as new regulatory hints.
+  */
+ list_for_each_entry(rdev, &cfg80211_rdev_list, list) {
+  list_for_each_entry(wdev, &rdev->wdev_list, list) {
+   wdev_lock(wdev);
+   if (wdev->conn || wdev->current_bss)
+    is_all_idle = false;
+   wdev_unlock(wdev);
+  }
+ }
+
+ return is_all_idle;
+}
+
+static void disconnect_work(struct work_struct *work)
+{
+ rtnl_lock();
+ if (cfg80211_is_all_idle())
+  regulatory_hint_disconnect();
+ rtnl_unlock();
+}
+
+static DECLARE_WORK(cfg80211_disconnect_work, disconnect_work);
+
+
+/*
+ * API calls for drivers implementing connect/disconnect and
+ * SME event handling
+ */
+
+/* This method must consume bss one way or another */
 void __cfg80211_connect_result(struct net_device *dev, const u8 *bssid,
           const u8 *req_ie, size_t req_ie_len,
           const u8 *resp_ie, size_t resp_ie_len,
@@ -434,13 +589,12 @@ void __cfg80211_connect_result(struct net_device *dev, const u8 *bssid,
  ASSERT_WDEV_LOCK(wdev);
 
  if (WARN_ON(wdev->iftype != NL80211_IFTYPE_STATION &&
-      wdev->iftype != NL80211_IFTYPE_P2P_CLIENT))
-  return;
-
- if (wdev->sme_state != CFG80211_SME_CONNECTING)
+      wdev->iftype != NL80211_IFTYPE_P2P_CLIENT)) {
+  cfg80211_put_bss(wdev->wiphy, bss);
   return;
+ }
 
- nl80211_send_connect_result(wiphy_to_dev(wdev->wiphy), dev,
+ nl80211_send_connect_result(wiphy_to_rdev(wdev->wiphy), dev,
         bssid, req_ie, req_ie_len,
         resp_ie, resp_ie_len,
         status, GFP_KERNEL);
@@ -470,44 +624,39 @@ void __cfg80211_connect_result(struct net_device *dev, const u8 *bssid,
  }
 #endif
 
+ if (!bss && (status == WLAN_STATUS_SUCCESS)) {
+  WARN_ON_ONCE(!wiphy_to_rdev(wdev->wiphy)->ops->connect);
+  bss = cfg80211_get_bss(wdev->wiphy, NULL, bssid,
+           wdev->ssid, wdev->ssid_len,
+           WLAN_CAPABILITY_ESS,
+           WLAN_CAPABILITY_ESS);
+  if (bss)
+   cfg80211_hold_bss(bss_from_pub(bss));
+ }
+
  if (wdev->current_bss) {
   cfg80211_unhold_bss(wdev->current_bss);
   cfg80211_put_bss(wdev->wiphy, &wdev->current_bss->pub);
   wdev->current_bss = NULL;
  }
 
- if (wdev->conn)
-  wdev->conn->state = CFG80211_CONN_IDLE;
-
  if (status != WLAN_STATUS_SUCCESS) {
-  wdev->sme_state = CFG80211_SME_IDLE;
-  if (wdev->conn)
-   kfree(wdev->conn->ie);
-  kfree(wdev->conn);
-  wdev->conn = NULL;
   kfree(wdev->connect_keys);
   wdev->connect_keys = NULL;
   wdev->ssid_len = 0;
-  cfg80211_put_bss(wdev->wiphy, bss);
+  if (bss) {
+   cfg80211_unhold_bss(bss_from_pub(bss));
+   cfg80211_put_bss(wdev->wiphy, bss);
+  }
+  cfg80211_sme_free(wdev);
   return;
  }
 
- if (!bss)
-  bss = cfg80211_get_bss(wdev->wiphy,
-           wdev->conn ? wdev->conn->params.channel :
-           NULL,
-           bssid,
-           wdev->ssid, wdev->ssid_len,
-           WLAN_CAPABILITY_ESS,
-           WLAN_CAPABILITY_ESS);
-
  if (WARN_ON(!bss))
   return;
 
- cfg80211_hold_bss(bss_from_pub(bss));
  wdev->current_bss = bss_from_pub(bss);
 
- wdev->sme_state = CFG80211_SME_CONNECTED;
  cfg80211_upload_connect_keys(wdev);
 
  rcu_read_lock();
@@ -528,8 +677,8 @@ void __cfg80211_connect_result(struct net_device *dev, const u8 *bssid,
   * - country_ie + 2, the start of the country ie data, and
   * - and country_ie[1] which is the IE length
   */
- regulatory_hint_11d(wdev->wiphy, bss->channel->band,
-       country_ie + 2, country_ie[1]);
+ regulatory_hint_country_ie(wdev->wiphy, bss->channel->band,
+       country_ie + 2, country_ie[1]);
  kfree(country_ie);
 }
 
@@ -539,12 +688,10 @@ void cfg80211_connect_result(struct net_device *dev, const u8 *bssid,
         u16 status, gfp_t gfp)
 {
  struct wireless_dev *wdev = dev->ieee80211_ptr;
- struct cfg80211_registered_device *rdev = wiphy_to_dev(wdev->wiphy);
+ struct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);
  struct cfg80211_event *ev;
  unsigned long flags;
 
- CFG80211_DEV_WARN_ON(wdev->sme_state != CFG80211_SME_CONNECTING);
-
  ev = kzalloc(sizeof(*ev) + req_ie_len + resp_ie_len, gfp);
  if (!ev)
   return;
@@ -571,6 +718,7 @@ void cfg80211_connect_result(struct net_device *dev, const u8 *bssid,
 }
 EXPORT_SYMBOL(cfg80211_connect_result);
 
+/* Consumes bss object one way or another */
 void __cfg80211_roamed(struct wireless_dev *wdev,
          struct cfg80211_bss *bss,
          const u8 *req_ie, size_t req_ie_len,
@@ -585,13 +733,8 @@ void __cfg80211_roamed(struct wireless_dev *wdev,
       wdev->iftype != NL80211_IFTYPE_P2P_CLIENT))
   goto out;
 
- if (wdev->sme_state != CFG80211_SME_CONNECTED)
-  goto out;
-
- /* internal error -- how did we get to CONNECTED w/o BSS? */
- if (WARN_ON(!wdev->current_bss)) {
+ if (WARN_ON(!wdev->current_bss))
   goto out;
- }
 
  cfg80211_unhold_bss(wdev->current_bss);
  cfg80211_put_bss(wdev->wiphy, &wdev->current_bss->pub);
@@ -600,7 +743,8 @@ void __cfg80211_roamed(struct wireless_dev *wdev,
  cfg80211_hold_bss(bss_from_pub(bss));
  wdev->current_bss = bss_from_pub(bss);
 
- nl80211_send_roamed(wiphy_to_dev(wdev->wiphy), wdev->netdev, bss->bssid,
+ nl80211_send_roamed(wiphy_to_rdev(wdev->wiphy),
+       wdev->netdev, bss->bssid,
        req_ie, req_ie_len, resp_ie, resp_ie_len,
        GFP_KERNEL);
 
@@ -641,8 +785,6 @@ void cfg80211_roamed(struct net_device *dev,
  struct wireless_dev *wdev = dev->ieee80211_ptr;
  struct cfg80211_bss *bss;
 
- CFG80211_DEV_WARN_ON(wdev->sme_state != CFG80211_SME_CONNECTED);
-
  bss = cfg80211_get_bss(wdev->wiphy, channel, bssid, wdev->ssid,
           wdev->ssid_len, WLAN_CAPABILITY_ESS,
           WLAN_CAPABILITY_ESS);
@@ -654,18 +796,17 @@ void cfg80211_roamed(struct net_device *dev,
 }
 EXPORT_SYMBOL(cfg80211_roamed);
 
+/* Consumes bss object one way or another */
 void cfg80211_roamed_bss(struct net_device *dev,
     struct cfg80211_bss *bss, const u8 *req_ie,
     size_t req_ie_len, const u8 *resp_ie,
     size_t resp_ie_len, gfp_t gfp)
 {
  struct wireless_dev *wdev = dev->ieee80211_ptr;
- struct cfg80211_registered_device *rdev = wiphy_to_dev(wdev->wiphy);
+ struct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);
  struct cfg80211_event *ev;
  unsigned long flags;
 
- CFG80211_DEV_WARN_ON(wdev->sme_state != CFG80211_SME_CONNECTED);
-
  if (WARN_ON(!bss))
   return;
 
@@ -695,7 +836,7 @@ void __cfg80211_disconnected(struct net_device *dev, const u8 *ie,
         size_t ie_len, u16 reason, bool from_ap)
 {
  struct wireless_dev *wdev = dev->ieee80211_ptr;
- struct cfg80211_registered_device *rdev = wiphy_to_dev(wdev->wiphy);
+ struct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);
  int i;
 #ifdef CONFIG_CFG80211_WEXT
  union iwreq_data wrqu;
@@ -707,25 +848,14 @@ void __cfg80211_disconnected(struct net_device *dev, const u8 *ie,
       wdev->iftype != NL80211_IFTYPE_P2P_CLIENT))
   return;
 
- if (wdev->sme_state != CFG80211_SME_CONNECTED)
-  return;
-
  if (wdev->current_bss) {
   cfg80211_unhold_bss(wdev->current_bss);
   cfg80211_put_bss(wdev->wiphy, &wdev->current_bss->pub);
  }
 
  wdev->current_bss = NULL;
- wdev->sme_state = CFG80211_SME_IDLE;
  wdev->ssid_len = 0;
 
- if (wdev->conn) {
-  kfree(wdev->conn->ie);
-  wdev->conn->ie = NULL;
-  kfree(wdev->conn);
-  wdev->conn = NULL;
- }
-
  nl80211_send_disconnected(rdev, dev, reason, ie, ie_len, from_ap);
 
  /*
@@ -736,6 +866,8 @@ void __cfg80211_disconnected(struct net_device *dev, const u8 *ie,
   for (i = 0; i < 6; i++)
    rdev_del_key(rdev, dev, i, false, NULL);
 
+ rdev_set_qos_map(rdev, dev, NULL);
+
 #ifdef CONFIG_CFG80211_WEXT
  memset(&wrqu, 0, sizeof(wrqu));
  wrqu.ap_addr.sa_family = ARPHRD_ETHER;
@@ -747,15 +879,13 @@ void __cfg80211_disconnected(struct net_device *dev, const u8 *ie,
 }
 
 void cfg80211_disconnected(struct net_device *dev, u16 reason,
-      u8 *ie, size_t ie_len, gfp_t gfp)
+      const u8 *ie, size_t ie_len, gfp_t gfp)
 {
  struct wireless_dev *wdev = dev->ieee80211_ptr;
- struct cfg80211_registered_device *rdev = wiphy_to_dev(wdev->wiphy);
+ struct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);
  struct cfg80211_event *ev;
  unsigned long flags;
 
- CFG80211_DEV_WARN_ON(wdev->sme_state != CFG80211_SME_CONNECTED);
-
  ev = kzalloc(sizeof(*ev) + ie_len, gfp);
  if (!ev)
   return;
@@ -773,21 +903,20 @@ void cfg80211_disconnected(struct net_device *dev, u16 reason,
 }
 EXPORT_SYMBOL(cfg80211_disconnected);
 
-int __cfg80211_connect(struct cfg80211_registered_device *rdev,
-         struct net_device *dev,
-         struct cfg80211_connect_params *connect,
-         struct cfg80211_cached_keys *connkeys,
-         const u8 *prev_bssid)
+/*
+ * API calls for nl80211/wext compatibility code
+ */
+int cfg80211_connect(struct cfg80211_registered_device *rdev,
+       struct net_device *dev,
+       struct cfg80211_connect_params *connect,
+       struct cfg80211_cached_keys *connkeys,
+       const u8 *prev_bssid)
 {
  struct wireless_dev *wdev = dev->ieee80211_ptr;
- struct cfg80211_bss *bss = NULL;
  int err;
 
  ASSERT_WDEV_LOCK(wdev);
 
- if (wdev->sme_state != CFG80211_SME_IDLE)
-  return -EALREADY;
-
  if (WARN_ON(wdev->connect_keys)) {
   kfree(wdev->connect_keys);
   wdev->connect_keys = NULL;
@@ -823,219 +952,41 @@ int __cfg80211_connect(struct cfg80211_registered_device *rdev,
   }
  }
 
- if (!rdev->ops->connect) {
-  if (!rdev->ops->auth || !rdev->ops->assoc)
-   return -EOPNOTSUPP;
+ wdev->connect_keys = connkeys;
+ memcpy(wdev->ssid, connect->ssid, connect->ssid_len);
+ wdev->ssid_len = connect->ssid_len;
 
-  if (WARN_ON(wdev->conn))
-   return -EINPROGRESS;
-
-  wdev->conn = kzalloc(sizeof(*wdev->conn), GFP_KERNEL);
-  if (!wdev->conn)
-   return -ENOMEM;
-
-  /*
-   * Copy all parameters, and treat explicitly IEs, BSSID, SSID.
-   */
-  memcpy(&wdev->conn->params, connect, sizeof(*connect));
-  if (connect->bssid) {
-   wdev->conn->params.bssid = wdev->conn->bssid;
-   memcpy(wdev->conn->bssid, connect->bssid, ETH_ALEN);
-  }
-
-  if (connect->ie) {
-   wdev->conn->ie = kmemdup(connect->ie, connect->ie_len,
-      GFP_KERNEL);
-   wdev->conn->params.ie = wdev->conn->ie;
-   if (!wdev->conn->ie) {
-    kfree(wdev->conn);
-    wdev->conn = NULL;
-    return -ENOMEM;
-   }
-  }
-
-  if (connect->auth_type == NL80211_AUTHTYPE_AUTOMATIC) {
-   wdev->conn->auto_auth = true;
-   /* start with open system ... should mostly work */
-   wdev->conn->params.auth_type =
-    NL80211_AUTHTYPE_OPEN_SYSTEM;
-  } else {
-   wdev->conn->auto_auth = false;
-  }
-
-  memcpy(wdev->ssid, connect->ssid, connect->ssid_len);
-  wdev->ssid_len = connect->ssid_len;
-  wdev->conn->params.ssid = wdev->ssid;
-  wdev->conn->params.ssid_len = connect->ssid_len;
-
-  /* see if we have the bss already */
-  bss = cfg80211_get_conn_bss(wdev);
-
-  wdev->sme_state = CFG80211_SME_CONNECTING;
-  wdev->connect_keys = connkeys;
-
-  if (prev_bssid) {
-   memcpy(wdev->conn->prev_bssid, prev_bssid, ETH_ALEN);
-   wdev->conn->prev_bssid_valid = true;
-  }
-
-  /* we're good if we have a matching bss struct */
-  if (bss) {
-   wdev->conn->state = CFG80211_CONN_AUTHENTICATE_NEXT;
-   err = cfg80211_conn_do_work(wdev);
-   cfg80211_put_bss(wdev->wiphy, bss);
-  } else {
-   /* otherwise we'll need to scan for the AP first */
-   err = cfg80211_conn_scan(wdev);
-   /*
-    * If we can't scan right now, then we need to scan again
-    * after the current scan finished, since the parameters
-    * changed (unless we find a good AP anyway).
-    */
-   if (err == -EBUSY) {
-    err = 0;
-    wdev->conn->state = CFG80211_CONN_SCAN_AGAIN;
-   }
-  }
-  if (err) {
-   kfree(wdev->conn->ie);
-   kfree(wdev->conn);
-   wdev->conn = NULL;
-   wdev->sme_state = CFG80211_SME_IDLE;
-   wdev->connect_keys = NULL;
-   wdev->ssid_len = 0;
-  }
-
-  return err;
- } else {
-  wdev->sme_state = CFG80211_SME_CONNECTING;
-  wdev->connect_keys = connkeys;
+ if (!rdev->ops->connect)
+  err = cfg80211_sme_connect(wdev, connect, prev_bssid);
+ else
   err = rdev_connect(rdev, dev, connect);
-  if (err) {
-   wdev->connect_keys = NULL;
-   wdev->sme_state = CFG80211_SME_IDLE;
-   return err;
-  }
-
-  memcpy(wdev->ssid, connect->ssid, connect->ssid_len);
-  wdev->ssid_len = connect->ssid_len;
 
-  return 0;
+ if (err) {
+  wdev->connect_keys = NULL;
+  wdev->ssid_len = 0;
+  return err;
  }
-}
 
-int cfg80211_connect(struct cfg80211_registered_device *rdev,
-       struct net_device *dev,
-       struct cfg80211_connect_params *connect,
-       struct cfg80211_cached_keys *connkeys)
-{
- int err;
-
- mutex_lock(&rdev->devlist_mtx);
- /* might request scan - scan_mtx -> wdev_mtx dependency */
- mutex_lock(&rdev->sched_scan_mtx);
- wdev_lock(dev->ieee80211_ptr);
- err = __cfg80211_connect(rdev, dev, connect, connkeys, NULL);
- wdev_unlock(dev->ieee80211_ptr);
- mutex_unlock(&rdev->sched_scan_mtx);
- mutex_unlock(&rdev->devlist_mtx);
-
- return err;
+ return 0;
 }
 
-int __cfg80211_disconnect(struct cfg80211_registered_device *rdev,
-     struct net_device *dev, u16 reason, bool wextev)
+int cfg80211_disconnect(struct cfg80211_registered_device *rdev,
+   struct net_device *dev, u16 reason, bool wextev)
 {
  struct wireless_dev *wdev = dev->ieee80211_ptr;
- int err;
+ int err = 0;
 
  ASSERT_WDEV_LOCK(wdev);
 
- if (wdev->sme_state == CFG80211_SME_IDLE)
-  return -EINVAL;
-
  kfree(wdev->connect_keys);
  wdev->connect_keys = NULL;
 
- if (!rdev->ops->disconnect) {
-  if (!rdev->ops->deauth)
-   return -EOPNOTSUPP;
-
-  /* was it connected by userspace SME? */
-  if (!wdev->conn) {
-   cfg80211_mlme_down(rdev, dev);
-   goto disconnect;
-  }
-
-  if (wdev->sme_state == CFG80211_SME_CONNECTING &&
-      (wdev->conn->state == CFG80211_CONN_SCANNING ||
-       wdev->conn->state == CFG80211_CONN_SCAN_AGAIN)) {
-   wdev->sme_state = CFG80211_SME_IDLE;
-   kfree(wdev->conn->ie);
-   kfree(wdev->conn);
-   wdev->conn = NULL;
-   wdev->ssid_len = 0;
-   return 0;
-  }
-
-  /* wdev->conn->params.bssid must be set if > SCANNING */
-  err = __cfg80211_mlme_deauth(rdev, dev,
-          wdev->conn->params.bssid,
-          NULL, 0, reason, false);
-  if (err)
-   return err;
- } else {
+ if (wdev->conn)
+  err = cfg80211_sme_disconnect(wdev, reason);
+ else if (!rdev->ops->disconnect)
+  cfg80211_mlme_down(rdev, dev);
+ else if (wdev->current_bss)
   err = rdev_disconnect(rdev, dev, reason);
-  if (err)
-   return err;
- }
-
- disconnect:
- if (wdev->sme_state == CFG80211_SME_CONNECTED)
-  __cfg80211_disconnected(dev, NULL, 0, 0, false);
- else if (wdev->sme_state == CFG80211_SME_CONNECTING)
-  __cfg80211_connect_result(dev, NULL, NULL, 0, NULL, 0,
-       WLAN_STATUS_UNSPECIFIED_FAILURE,
-       wextev, NULL);
-
- return 0;
-}
-
-int cfg80211_disconnect(struct cfg80211_registered_device *rdev,
-   struct net_device *dev,
-   u16 reason, bool wextev)
-{
- int err;
-
- wdev_lock(dev->ieee80211_ptr);
- err = __cfg80211_disconnect(rdev, dev, reason, wextev);
- wdev_unlock(dev->ieee80211_ptr);
 
  return err;
 }
-
-void cfg80211_sme_disassoc(struct net_device *dev,
-      struct cfg80211_internal_bss *bss)
-{
- struct wireless_dev *wdev = dev->ieee80211_ptr;
- struct cfg80211_registered_device *rdev = wiphy_to_dev(wdev->wiphy);
- u8 bssid[ETH_ALEN];
-
- ASSERT_WDEV_LOCK(wdev);
-
- if (!wdev->conn)
-  return;
-
- if (wdev->conn->state == CFG80211_CONN_IDLE)
-  return;
-
- /*
-  * Ok, so the association was made by this SME -- we don't
-  * want it any more so deauthenticate too.
-  */
-
- memcpy(bssid, bss->pub.bssid, ETH_ALEN);
-
- __cfg80211_mlme_deauth(rdev, dev, bssid, NULL, 0,
-          WLAN_REASON_DEAUTH_LEAVING, false);
-}
diff --git a/net/wireless/sysfs.c b/net/wireless/sysfs.c
index 8f28b9f..9ee6bc1 100644
--- a/net/wireless/sysfs.c
+++ b/net/wireless/sysfs.c
@@ -30,7 +30,8 @@ static ssize_t name ## _show(struct device *dev,   \
          char *buf)    \
 {         \
  return sprintf(buf, fmt "\n", dev_to_rdev(dev)->member); \
-}
+}         \
+static DEVICE_ATTR_RO(name)
 
 SHOW_FMT(index, "%d", wiphy_idx);
 SHOW_FMT(macaddress, "%pM", wiphy.perm_addr);
@@ -42,7 +43,7 @@ static ssize_t name_show(struct device *dev,
  struct wiphy *wiphy = &dev_to_rdev(dev)->wiphy;
  return sprintf(buf, "%s\n", dev_name(&wiphy->dev));
 }
-
+static DEVICE_ATTR_RO(name);
 
 static ssize_t addresses_show(struct device *dev,
          struct device_attribute *attr,
@@ -60,15 +61,17 @@ static ssize_t addresses_show(struct device *dev,
 
  return buf - start;
 }
-
-static struct device_attribute ieee80211_dev_attrs[] = {
- __ATTR_RO(index),
- __ATTR_RO(macaddress),
- __ATTR_RO(address_mask),
- __ATTR_RO(addresses),
- __ATTR_RO(name),
- {}
+static DEVICE_ATTR_RO(addresses);
+
+static struct attribute *ieee80211_attrs[] = {
+ &dev_attr_index.attr,
+ &dev_attr_macaddress.attr,
+ &dev_attr_address_mask.attr,
+ &dev_attr_addresses.attr,
+ &dev_attr_name.attr,
+ NULL,
 };
+ATTRIBUTE_GROUPS(ieee80211);
 
 static void wiphy_dev_release(struct device *dev)
 {
@@ -83,6 +86,7 @@ static int wiphy_uevent(struct device *dev, struct kobj_uevent_env *env)
  return 0;
 }
 
+#ifdef CONFIG_PM
 static void cfg80211_leave_all(struct cfg80211_registered_device *rdev)
 {
  struct wireless_dev *wdev;
@@ -100,10 +104,10 @@ static int wiphy_suspend(struct device *dev, pm_message_t state)
 
  rtnl_lock();
  if (rdev->wiphy.registered) {
-  if (!rdev->wowlan)
+  if (!rdev->wiphy.wowlan_config)
    cfg80211_leave_all(rdev);
   if (rdev->ops->suspend)
-   ret = rdev_suspend(rdev, rdev->wowlan);
+   ret = rdev_suspend(rdev, rdev->wiphy.wowlan_config);
   if (ret == 1) {
    /* Driver refuse to configure wowlan */
    cfg80211_leave_all(rdev);
@@ -132,6 +136,7 @@ static int wiphy_resume(struct device *dev)
 
  return ret;
 }
+#endif
 
 static const void *wiphy_namespace(struct device *d)
 {
@@ -144,10 +149,12 @@ struct class ieee80211_class = {
  .name = "ieee80211",
  .owner = THIS_MODULE,
  .dev_release = wiphy_dev_release,
- .dev_attrs = ieee80211_dev_attrs,
+ .dev_groups = ieee80211_groups,
  .dev_uevent = wiphy_uevent,
+#ifdef CONFIG_PM
  .suspend = wiphy_suspend,
  .resume = wiphy_resume,
+#endif
  .ns_type = &net_ns_type_operations,
  .namespace = wiphy_namespace,
 };
diff --git a/net/wireless/sysfs.h b/net/wireless/sysfs.h
index 65acbeb..b533ed7 100644
--- a/net/wireless/sysfs.h
+++ b/net/wireless/sysfs.h
@@ -1,8 +1,8 @@
 #ifndef __WIRELESS_SYSFS_H
 #define __WIRELESS_SYSFS_H
 
-extern int wiphy_sysfs_init(void);
-extern void wiphy_sysfs_exit(void);
+int wiphy_sysfs_init(void);
+void wiphy_sysfs_exit(void);
 
 extern struct class ieee80211_class;
 
diff --git a/net/wireless/trace.h b/net/wireless/trace.h
index 5755bc1..7cc887f 100644
--- a/net/wireless/trace.h
+++ b/net/wireless/trace.h
@@ -186,6 +186,28 @@
 
 #define BOOL_TO_STR(bo) (bo) ? "true" : "false"
 
+#define QOS_MAP_ENTRY __field(u8, num_des)   \
+        __array(u8, dscp_exception,  \
+         2 * IEEE80211_QOS_MAP_MAX_EX) \
+        __array(u8, up, IEEE80211_QOS_MAP_LEN_MIN)
+#define QOS_MAP_ASSIGN(qos_map)     \
+ do {       \
+  if ((qos_map)) {    \
+   __entry->num_des = (qos_map)->num_des; \
+   memcpy(__entry->dscp_exception,  \
+          &(qos_map)->dscp_exception, \
+          2 * IEEE80211_QOS_MAP_MAX_EX); \
+   memcpy(__entry->up, &(qos_map)->up, \
+          IEEE80211_QOS_MAP_LEN_MIN); \
+  } else {     \
+   __entry->num_des = 0;   \
+   memset(__entry->dscp_exception, 0, \
+          2 * IEEE80211_QOS_MAP_MAX_EX); \
+   memset(__entry->up, 0,   \
+          IEEE80211_QOS_MAP_LEN_MIN); \
+  }      \
+ } while (0)
+
 /*************************************************************
  *   rdev->ops traces       *
  *************************************************************/
@@ -1293,15 +1315,17 @@ TRACE_EVENT(rdev_return_int_int,
 
 #ifdef CONFIG_NL80211_TESTMODE
 TRACE_EVENT(rdev_testmode_cmd,
- TP_PROTO(struct wiphy *wiphy),
- TP_ARGS(wiphy),
+ TP_PROTO(struct wiphy *wiphy, struct wireless_dev *wdev),
+ TP_ARGS(wiphy, wdev),
  TP_STRUCT__entry(
   WIPHY_ENTRY
+  WDEV_ENTRY
  ),
  TP_fast_assign(
   WIPHY_ASSIGN;
+  WDEV_ASSIGN;
  ),
- TP_printk(WIPHY_PR_FMT, WIPHY_PR_ARG)
+ TP_printk(WIPHY_PR_FMT WDEV_PR_FMT, WIPHY_PR_ARG, WDEV_PR_ARG)
 );
 
 TRACE_EVENT(rdev_testmode_dump,
@@ -1444,9 +1468,10 @@ TRACE_EVENT(rdev_sched_scan_start,
 TRACE_EVENT(rdev_tdls_mgmt,
  TP_PROTO(struct wiphy *wiphy, struct net_device *netdev,
    u8 *peer, u8 action_code, u8 dialog_token,
-   u16 status_code, const u8 *buf, size_t len),
+   u16 status_code, u32 peer_capability,
+   const u8 *buf, size_t len),
  TP_ARGS(wiphy, netdev, peer, action_code, dialog_token, status_code,
-  buf, len),
+  peer_capability, buf, len),
  TP_STRUCT__entry(
   WIPHY_ENTRY
   NETDEV_ENTRY
@@ -1454,6 +1479,7 @@ TRACE_EVENT(rdev_tdls_mgmt,
   __field(u8, action_code)
   __field(u8, dialog_token)
   __field(u16, status_code)
+  __field(u32, peer_capability)
   __dynamic_array(u8, buf, len)
  ),
  TP_fast_assign(
@@ -1463,13 +1489,15 @@ TRACE_EVENT(rdev_tdls_mgmt,
   __entry->action_code = action_code;
   __entry->dialog_token = dialog_token;
   __entry->status_code = status_code;
+  __entry->peer_capability = peer_capability;
   memcpy(__get_dynamic_array(buf), buf, len);
  ),
  TP_printk(WIPHY_PR_FMT ", " NETDEV_PR_FMT ", " MAC_PR_FMT ", action_code: %u, "
-    "dialog_token: %u, status_code: %u, buf: %#.2x ",
+    "dialog_token: %u, status_code: %u, peer_capability: %u buf: %#.2x ",
     WIPHY_PR_ARG, NETDEV_PR_ARG, MAC_PR_ARG(peer),
     __entry->action_code, __entry->dialog_token,
-    __entry->status_code, ((u8 *)__get_dynamic_array(buf))[0])
+    __entry->status_code, __entry->peer_capability,
+    ((u8 *)__get_dynamic_array(buf))[0])
 );
 
 TRACE_EVENT(rdev_dump_survey,
@@ -1651,9 +1679,8 @@ TRACE_EVENT(rdev_cancel_remain_on_channel,
 
 TRACE_EVENT(rdev_mgmt_tx,
  TP_PROTO(struct wiphy *wiphy, struct wireless_dev *wdev,
-   struct ieee80211_channel *chan, bool offchan,
-   unsigned int wait, bool no_cck, bool dont_wait_for_ack),
- TP_ARGS(wiphy, wdev, chan, offchan, wait, no_cck, dont_wait_for_ack),
+   struct cfg80211_mgmt_tx_params *params),
+ TP_ARGS(wiphy, wdev, params),
  TP_STRUCT__entry(
   WIPHY_ENTRY
   WDEV_ENTRY
@@ -1666,11 +1693,11 @@ TRACE_EVENT(rdev_mgmt_tx,
  TP_fast_assign(
   WIPHY_ASSIGN;
   WDEV_ASSIGN;
-  CHAN_ASSIGN(chan);
-  __entry->offchan = offchan;
-  __entry->wait = wait;
-  __entry->no_cck = no_cck;
-  __entry->dont_wait_for_ack = dont_wait_for_ack;
+  CHAN_ASSIGN(params->chan);
+  __entry->offchan = params->offchan;
+  __entry->wait = params->wait;
+  __entry->no_cck = params->no_cck;
+  __entry->dont_wait_for_ack = params->dont_wait_for_ack;
  ),
  TP_printk(WIPHY_PR_FMT ", " WDEV_PR_FMT ", " CHAN_PR_FMT ", offchan: %s,"
     " wait: %u, no cck: %s, dont wait for ack: %s",
@@ -1841,6 +1868,79 @@ TRACE_EVENT(rdev_crit_proto_stop,
     WIPHY_PR_ARG, WDEV_PR_ARG)
 );
 
+TRACE_EVENT(rdev_channel_switch,
+ TP_PROTO(struct wiphy *wiphy, struct net_device *netdev,
+   struct cfg80211_csa_settings *params),
+ TP_ARGS(wiphy, netdev, params),
+ TP_STRUCT__entry(
+  WIPHY_ENTRY
+  NETDEV_ENTRY
+  CHAN_DEF_ENTRY
+  __field(bool, radar_required)
+  __field(bool, block_tx)
+  __field(u8, count)
+  __dynamic_array(u16, bcn_ofs, params->n_counter_offsets_beacon)
+  __dynamic_array(u16, pres_ofs, params->n_counter_offsets_presp)
+ ),
+ TP_fast_assign(
+  WIPHY_ASSIGN;
+  NETDEV_ASSIGN;
+  CHAN_DEF_ASSIGN(&params->chandef);
+  __entry->radar_required = params->radar_required;
+  __entry->block_tx = params->block_tx;
+  __entry->count = params->count;
+  memcpy(__get_dynamic_array(bcn_ofs),
+         params->counter_offsets_beacon,
+         params->n_counter_offsets_beacon * sizeof(u16));
+
+  /* probe response offsets are optional */
+  if (params->n_counter_offsets_presp)
+   memcpy(__get_dynamic_array(pres_ofs),
+          params->counter_offsets_presp,
+          params->n_counter_offsets_presp * sizeof(u16));
+ ),
+ TP_printk(WIPHY_PR_FMT ", " NETDEV_PR_FMT ", " CHAN_DEF_PR_FMT
+    ", block_tx: %d, count: %u, radar_required: %d",
+    WIPHY_PR_ARG, NETDEV_PR_ARG, CHAN_DEF_PR_ARG,
+    __entry->block_tx, __entry->count, __entry->radar_required)
+);
+
+TRACE_EVENT(rdev_set_qos_map,
+ TP_PROTO(struct wiphy *wiphy, struct net_device *netdev,
+   struct cfg80211_qos_map *qos_map),
+ TP_ARGS(wiphy, netdev, qos_map),
+ TP_STRUCT__entry(
+  WIPHY_ENTRY
+  NETDEV_ENTRY
+  QOS_MAP_ENTRY
+ ),
+ TP_fast_assign(
+  WIPHY_ASSIGN;
+  NETDEV_ASSIGN;
+  QOS_MAP_ASSIGN(qos_map);
+ ),
+ TP_printk(WIPHY_PR_FMT ", " NETDEV_PR_FMT ", num_des: %u",
+    WIPHY_PR_ARG, NETDEV_PR_ARG, __entry->num_des)
+);
+
+TRACE_EVENT(rdev_set_ap_chanwidth,
+ TP_PROTO(struct wiphy *wiphy, struct net_device *netdev,
+   struct cfg80211_chan_def *chandef),
+ TP_ARGS(wiphy, netdev, chandef),
+ TP_STRUCT__entry(
+  WIPHY_ENTRY
+  NETDEV_ENTRY
+  CHAN_DEF_ENTRY
+ ),
+ TP_fast_assign(
+  WIPHY_ASSIGN;
+  NETDEV_ASSIGN;
+  CHAN_DEF_ASSIGN(chandef);
+ ),
+ TP_printk(WIPHY_PR_FMT ", " NETDEV_PR_FMT ", " CHAN_DEF_PR_FMT,
+    WIPHY_PR_ARG, NETDEV_PR_ARG, CHAN_DEF_PR_ARG)
+);
+
 /*************************************************************
  *      cfg80211 exported functions traces       *
  *************************************************************/
@@ -1911,24 +2011,46 @@ TRACE_EVENT(cfg80211_send_rx_assoc,
     NETDEV_PR_ARG, MAC_PR_ARG(bssid), CHAN_PR_ARG)
 );
 
-DEFINE_EVENT(netdev_evt_only, __cfg80211_send_deauth,
- TP_PROTO(struct net_device *netdev),
- TP_ARGS(netdev)
+DECLARE_EVENT_CLASS(netdev_frame_event,
+ TP_PROTO(struct net_device *netdev, const u8 *buf, int len),
+ TP_ARGS(netdev, buf, len),
+ TP_STRUCT__entry(
+  NETDEV_ENTRY
+  __dynamic_array(u8, frame, len)
+ ),
+ TP_fast_assign(
+  NETDEV_ASSIGN;
+  memcpy(__get_dynamic_array(frame), buf, len);
+ ),
+ TP_printk(NETDEV_PR_FMT ", ftype:0x%.2x",
+    NETDEV_PR_ARG,
+    le16_to_cpup((__le16 *)__get_dynamic_array(frame)))
 );
 
-DEFINE_EVENT(netdev_evt_only, __cfg80211_send_disassoc,
- TP_PROTO(struct net_device *netdev),
- TP_ARGS(netdev)
+DEFINE_EVENT(netdev_frame_event, cfg80211_rx_unprot_mlme_mgmt,
+ TP_PROTO(struct net_device *netdev, const u8 *buf, int len),
+ TP_ARGS(netdev, buf, len)
 );
 
-DEFINE_EVENT(netdev_evt_only, cfg80211_send_unprot_deauth,
- TP_PROTO(struct net_device *netdev),
- TP_ARGS(netdev)
+DEFINE_EVENT(netdev_frame_event, cfg80211_rx_mlme_mgmt,
+ TP_PROTO(struct net_device *netdev, const u8 *buf, int len),
+ TP_ARGS(netdev, buf, len)
 );
 
-DEFINE_EVENT(netdev_evt_only, cfg80211_send_unprot_disassoc,
- TP_PROTO(struct net_device *netdev),
- TP_ARGS(netdev)
+TRACE_EVENT(cfg80211_tx_mlme_mgmt,
+ TP_PROTO(struct net_device *netdev, const u8 *buf, int len),
+ TP_ARGS(netdev, buf, len),
+ TP_STRUCT__entry(
+  NETDEV_ENTRY
+  __dynamic_array(u8, frame, len)
+ ),
+ TP_fast_assign(
+  NETDEV_ASSIGN;
+  memcpy(__get_dynamic_array(frame), buf, len);
+ ),
+ TP_printk(NETDEV_PR_FMT ", ftype:0x%.2x",
+    NETDEV_PR_ARG,
+    le16_to_cpup((__le16 *)__get_dynamic_array(frame)))
 );
 
 DECLARE_EVENT_CLASS(netdev_mac_evt,
@@ -1972,7 +2094,8 @@ TRACE_EVENT(cfg80211_michael_mic_failure,
   MAC_ASSIGN(addr, addr);
   __entry->key_type = key_type;
   __entry->key_id = key_id;
-  memcpy(__entry->tsc, tsc, 6);
+  if (tsc)
+   memcpy(__entry->tsc, tsc, 6);
  ),
  TP_printk(NETDEV_PR_FMT ", " MAC_PR_FMT ", key type: %d, key id: %d, tsc: %pm",
     NETDEV_PR_ARG, MAC_PR_ARG(addr), __entry->key_type,
@@ -2093,18 +2216,21 @@ TRACE_EVENT(cfg80211_cqm_rssi_notify,
 );
 
 TRACE_EVENT(cfg80211_reg_can_beacon,
- TP_PROTO(struct wiphy *wiphy, struct cfg80211_chan_def *chandef),
- TP_ARGS(wiphy, chandef),
+ TP_PROTO(struct wiphy *wiphy, struct cfg80211_chan_def *chandef,
+   enum nl80211_iftype iftype),
+ TP_ARGS(wiphy, chandef, iftype),
  TP_STRUCT__entry(
   WIPHY_ENTRY
   CHAN_DEF_ENTRY
+  __field(enum nl80211_iftype, iftype)
  ),
  TP_fast_assign(
   WIPHY_ASSIGN;
   CHAN_DEF_ASSIGN(chandef);
+  __entry->iftype = iftype;
  ),
- TP_printk(WIPHY_PR_FMT ", " CHAN_DEF_PR_FMT,
-    WIPHY_PR_ARG, CHAN_DEF_PR_ARG)
+ TP_printk(WIPHY_PR_FMT ", " CHAN_DEF_PR_FMT ", iftype=%d",
+    WIPHY_PR_ARG, CHAN_DEF_PR_ARG, __entry->iftype)
 );
 
 TRACE_EVENT(cfg80211_chandef_dfs_required,
@@ -2182,11 +2308,6 @@ DECLARE_EVENT_CLASS(cfg80211_rx_evt,
  TP_printk(NETDEV_PR_FMT ", " MAC_PR_FMT, NETDEV_PR_ARG, MAC_PR_ARG(addr))
 );
 
-DEFINE_EVENT(cfg80211_rx_evt, cfg80211_ibss_joined,
- TP_PROTO(struct net_device *netdev, const u8 *addr),
- TP_ARGS(netdev, addr)
-);
-
 DEFINE_EVENT(cfg80211_rx_evt, cfg80211_rx_spurious_frame,
  TP_PROTO(struct net_device *netdev, const u8 *addr),
  TP_ARGS(netdev, addr)
@@ -2197,6 +2318,24 @@ DEFINE_EVENT(cfg80211_rx_evt, cfg80211_rx_unexpected_4addr_frame,
  TP_ARGS(netdev, addr)
 );
 
+TRACE_EVENT(cfg80211_ibss_joined,
+ TP_PROTO(struct net_device *netdev, const u8 *bssid,
+   struct ieee80211_channel *channel),
+ TP_ARGS(netdev, bssid, channel),
+ TP_STRUCT__entry(
+  NETDEV_ENTRY
+  MAC_ENTRY(bssid)
+  CHAN_ENTRY
+ ),
+ TP_fast_assign(
+  NETDEV_ASSIGN;
+  MAC_ASSIGN(bssid, bssid);
+  CHAN_ASSIGN(channel);
+ ),
+ TP_printk(NETDEV_PR_FMT ", bssid: " MAC_PR_FMT ", " CHAN_PR_FMT,
+    NETDEV_PR_ARG, MAC_PR_ARG(bssid), CHAN_PR_ARG)
+);
+
 TRACE_EVENT(cfg80211_probe_status,
  TP_PROTO(struct net_device *netdev, const u8 *addr, u64 cookie,
    bool acked),
@@ -2369,26 +2508,30 @@ TRACE_EVENT(cfg80211_get_bss,
     __entry->capa_mask, __entry->capa_val)
 );
 
-TRACE_EVENT(cfg80211_inform_bss_frame,
+TRACE_EVENT(cfg80211_inform_bss_width_frame,
  TP_PROTO(struct wiphy *wiphy, struct ieee80211_channel *channel,
+   enum nl80211_bss_scan_width scan_width,
    struct ieee80211_mgmt *mgmt, size_t len,
    s32 signal),
- TP_ARGS(wiphy, channel, mgmt, len, signal),
+ TP_ARGS(wiphy, channel, scan_width, mgmt, len, signal),
  TP_STRUCT__entry(
   WIPHY_ENTRY
   CHAN_ENTRY
+  __field(enum nl80211_bss_scan_width, scan_width)
   __dynamic_array(u8, mgmt, len)
   __field(s32, signal)
  ),
  TP_fast_assign(
   WIPHY_ASSIGN;
   CHAN_ASSIGN(channel);
+  __entry->scan_width = scan_width;
   if (mgmt)
    memcpy(__get_dynamic_array(mgmt), mgmt, len);
   __entry->signal = signal;
  ),
- TP_printk(WIPHY_PR_FMT ", " CHAN_PR_FMT "signal: %d",
-    WIPHY_PR_ARG, CHAN_PR_ARG, __entry->signal)
+ TP_printk(WIPHY_PR_FMT ", " CHAN_PR_FMT "(scan_width: %d) signal: %d",
+    WIPHY_PR_ARG, CHAN_PR_ARG, __entry->scan_width,
+    __entry->signal)
 );
 
 DECLARE_EVENT_CLASS(cfg80211_bss_evt,
@@ -2498,6 +2641,21 @@ TRACE_EVENT(cfg80211_ft_event,
     WIPHY_PR_ARG, NETDEV_PR_ARG, MAC_PR_ARG(target_ap))
 );
 
+TRACE_EVENT(cfg80211_stop_iface,
+ TP_PROTO(struct wiphy *wiphy, struct wireless_dev *wdev),
+ TP_ARGS(wiphy, wdev),
+ TP_STRUCT__entry(
+  WIPHY_ENTRY
+  WDEV_ENTRY
+ ),
+ TP_fast_assign(
+  WIPHY_ASSIGN;
+  WDEV_ASSIGN;
+ ),
+ TP_printk(WIPHY_PR_FMT ", " WDEV_PR_FMT,
+    WIPHY_PR_ARG, WDEV_PR_ARG)
+);
+
 #endif /* !__RDEV_OPS_TRACE || TRACE_HEADER_MULTI_READ */
 
 #undef TRACE_INCLUDE_PATH
diff --git a/net/wireless/util.c b/net/wireless/util.c
index f5ad4d9..728f1c0 100644
--- a/net/wireless/util.c
+++ b/net/wireless/util.c
@@ -10,6 +10,8 @@
 #include <net/cfg80211.h>
 #include <net/ip.h>
 #include <net/dsfield.h>
+#include <linux/if_vlan.h>
+#include <linux/mpls.h>
 #include "core.h"
 #include "rdev-ops.h"
 
@@ -33,6 +35,35 @@ ieee80211_get_response_rate(struct ieee80211_supported_band *sband,
 }
 EXPORT_SYMBOL(ieee80211_get_response_rate);
 
+u32 ieee80211_mandatory_rates(struct ieee80211_supported_band *sband,
+         enum nl80211_bss_scan_width scan_width)
+{
+ struct ieee80211_rate *bitrates;
+ u32 mandatory_rates = 0;
+ enum ieee80211_rate_flags mandatory_flag;
+ int i;
+
+ if (WARN_ON(!sband))
+  return 1;
+
+ if (sband->band == IEEE80211_BAND_2GHZ) {
+  if (scan_width == NL80211_BSS_CHAN_WIDTH_5 ||
+      scan_width == NL80211_BSS_CHAN_WIDTH_10)
+   mandatory_flag = IEEE80211_RATE_MANDATORY_G;
+  else
+   mandatory_flag = IEEE80211_RATE_MANDATORY_B;
+ } else {
+  mandatory_flag = IEEE80211_RATE_MANDATORY_A;
+ }
+
+ bitrates = sband->bitrates;
+ for (i = 0; i < sband->n_bitrates; i++)
+  if (bitrates[i].flags & mandatory_flag)
+   mandatory_rates |= BIT(i);
+ return mandatory_rates;
+}
+EXPORT_SYMBOL(ieee80211_mandatory_rates);
+
 int ieee80211_channel_to_frequency(int chan, enum ieee80211_band band)
 {
  /* see 802.11 17.3.8.3.2 and Annex J
@@ -445,7 +476,8 @@ int ieee80211_data_to_8023(struct sk_buff *skb, const u8 *addr,
 EXPORT_SYMBOL(ieee80211_data_to_8023);
 
 int ieee80211_data_from_8023(struct sk_buff *skb, const u8 *addr,
-        enum nl80211_iftype iftype, u8 *bssid, bool qos)
+        enum nl80211_iftype iftype,
+        const u8 *bssid, bool qos)
 {
  struct ieee80211_hdr hdr;
  u16 hdrlen, ethertype;
@@ -659,9 +691,11 @@ void ieee80211_amsdu_to_8023s(struct sk_buff *skb, struct sk_buff_head *list,
 EXPORT_SYMBOL(ieee80211_amsdu_to_8023s);
 
 /* Given a data frame determine the 802.1p/1d tag to use. */
-unsigned int cfg80211_classify8021d(struct sk_buff *skb)
+unsigned int cfg80211_classify8021d(struct sk_buff *skb,
+        struct cfg80211_qos_map *qos_map)
 {
  unsigned int dscp;
+ unsigned char vlan_priority;
 
  /* skb->priority values from 256->263 are magic values to
   * directly indicate a specific 802.1d priority.  This is used
@@ -671,6 +705,13 @@ unsigned int cfg80211_classify8021d(struct sk_buff *skb)
  if (skb->priority >= 256 && skb->priority <= 263)
   return skb->priority - 256;
 
+ if (vlan_tx_tag_present(skb)) {
+  vlan_priority = (vlan_tx_tag_get(skb) & VLAN_PRIO_MASK)
+   >> VLAN_PRIO_SHIFT;
+  if (vlan_priority > 0)
+   return vlan_priority;
+ }
+
  switch (skb->protocol) {
  case htons(ETH_P_IP):
   dscp = ipv4_get_dsfield(ip_hdr(skb)) & 0xfc;
@@ -678,10 +719,40 @@ unsigned int cfg80211_classify8021d(struct sk_buff *skb)
  case htons(ETH_P_IPV6):
   dscp = ipv6_get_dsfield(ipv6_hdr(skb)) & 0xfc;
   break;
+ case htons(ETH_P_MPLS_UC):
+ case htons(ETH_P_MPLS_MC): {
+  struct mpls_label mpls_tmp, *mpls;
+
+  mpls = skb_header_pointer(skb, sizeof(struct ethhdr),
+       sizeof(*mpls), &mpls_tmp);
+  if (!mpls)
+   return 0;
+
+  return (ntohl(mpls->entry) & MPLS_LS_TC_MASK)
+   >> MPLS_LS_TC_SHIFT;
+ }
+ case htons(ETH_P_80221):
+  /* 802.21 is always network control traffic */
+  return 7;
  default:
   return 0;
  }
 
+ if (qos_map) {
+  unsigned int i, tmp_dscp = dscp >> 2;
+
+  for (i = 0; i < qos_map->num_des; i++) {
+   if (tmp_dscp == qos_map->dscp_exception[i].dscp)
+    return qos_map->dscp_exception[i].up;
+  }
+
+  for (i = 0; i < 8; i++) {
+   if (tmp_dscp >= qos_map->up[i].low &&
+       tmp_dscp <= qos_map->up[i].high)
+    return i;
+  }
+ }
+
  return dscp >> 5;
 }
 EXPORT_SYMBOL(cfg80211_classify8021d);
@@ -700,7 +771,7 @@ EXPORT_SYMBOL(ieee80211_bss_get_ie);
 
 void cfg80211_upload_connect_keys(struct wireless_dev *wdev)
 {
- struct cfg80211_registered_device *rdev = wiphy_to_dev(wdev->wiphy);
+ struct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);
  struct net_device *dev = wdev->netdev;
  int i;
 
@@ -766,7 +837,11 @@ void cfg80211_process_wdev_events(struct wireless_dev *wdev)
       ev->dc.reason, true);
    break;
   case EVENT_IBSS_JOINED:
-   __cfg80211_ibss_joined(wdev->netdev, ev->ij.bssid);
+   __cfg80211_ibss_joined(wdev->netdev, ev->ij.bssid,
+            ev->ij.channel);
+   break;
+  case EVENT_STOPPED:
+   __cfg80211_leave(wiphy_to_rdev(wdev->wiphy), wdev);
    break;
   }
   wdev_unlock(wdev);
@@ -783,14 +858,9 @@ void cfg80211_process_rdev_events(struct cfg80211_registered_device *rdev)
  struct wireless_dev *wdev;
 
  ASSERT_RTNL();
- ASSERT_RDEV_LOCK(rdev);
-
- mutex_lock(&rdev->devlist_mtx);
 
  list_for_each_entry(wdev, &rdev->wdev_list, list)
   cfg80211_process_wdev_events(wdev);
-
- mutex_unlock(&rdev->devlist_mtx);
 }
 
 int cfg80211_change_iface(struct cfg80211_registered_device *rdev,
@@ -800,7 +870,7 @@ int cfg80211_change_iface(struct cfg80211_registered_device *rdev,
  int err;
  enum nl80211_iftype otype = dev->ieee80211_ptr->iftype;
 
- ASSERT_RDEV_LOCK(rdev);
+ ASSERT_RTNL();
 
  /* don't support changing VLANs, you just re-create them */
  if (otype == NL80211_IFTYPE_AP_VLAN)
@@ -822,27 +892,25 @@ int cfg80211_change_iface(struct cfg80211_registered_device *rdev,
   return -EBUSY;
 
  if (ntype != otype && netif_running(dev)) {
-  mutex_lock(&rdev->devlist_mtx);
-  err = cfg80211_can_change_interface(rdev, dev->ieee80211_ptr,
-          ntype);
-  mutex_unlock(&rdev->devlist_mtx);
-  if (err)
-   return err;
-
   dev->ieee80211_ptr->use_4addr = false;
   dev->ieee80211_ptr->mesh_id_up_len = 0;
+  wdev_lock(dev->ieee80211_ptr);
+  rdev_set_qos_map(rdev, dev, NULL);
+  wdev_unlock(dev->ieee80211_ptr);
 
   switch (otype) {
   case NL80211_IFTYPE_AP:
-   cfg80211_stop_ap(rdev, dev);
+   cfg80211_stop_ap(rdev, dev, true);
    break;
   case NL80211_IFTYPE_ADHOC:
    cfg80211_leave_ibss(rdev, dev, false);
    break;
   case NL80211_IFTYPE_STATION:
   case NL80211_IFTYPE_P2P_CLIENT:
+   wdev_lock(dev->ieee80211_ptr);
    cfg80211_disconnect(rdev, dev,
          WLAN_REASON_DEAUTH_LEAVING, true);
+   wdev_unlock(dev->ieee80211_ptr);
    break;
   case NL80211_IFTYPE_MESH_POINT:
    /* mesh should be handled? */
@@ -1169,6 +1237,9 @@ bool ieee80211_operating_class_to_band(u8 operating_class,
  case 84:
   *band = IEEE80211_BAND_2GHZ;
   return true;
+ case 180:
+  *band = IEEE80211_BAND_60GHZ;
+  return true;
  }
 
  return false;
@@ -1184,8 +1255,6 @@ int cfg80211_validate_beacon_int(struct cfg80211_registered_device *rdev,
  if (!beacon_int)
   return -EINVAL;
 
- mutex_lock(&rdev->devlist_mtx);
-
  list_for_each_entry(wdev, &rdev->wdev_list, list) {
   if (!wdev->beacon_interval)
    continue;
@@ -1195,11 +1264,123 @@ int cfg80211_validate_beacon_int(struct cfg80211_registered_device *rdev,
   }
  }
 
- mutex_unlock(&rdev->devlist_mtx);
-
  return res;
 }
 
+int cfg80211_iter_combinations(struct wiphy *wiphy,
+          const int num_different_channels,
+          const u8 radar_detect,
+          const int iftype_num[NUM_NL80211_IFTYPES],
+          void (*iter)(const struct ieee80211_iface_combination *c,
+         void *data),
+          void *data)
+{
+ const struct ieee80211_regdomain *regdom;
+ enum nl80211_dfs_regions region = 0;
+ int i, j, iftype;
+ int num_interfaces = 0;
+ u32 used_iftypes = 0;
+
+ if (radar_detect) {
+  rcu_read_lock();
+  regdom = rcu_dereference(cfg80211_regdomain);
+  if (regdom)
+   region = regdom->dfs_region;
+  rcu_read_unlock();
+ }
+
+ for (iftype = 0; iftype < NUM_NL80211_IFTYPES; iftype++) {
+  num_interfaces += iftype_num[iftype];
+  if (iftype_num[iftype] > 0 &&
+      !(wiphy->software_iftypes & BIT(iftype)))
+   used_iftypes |= BIT(iftype);
+ }
+
+ for (i = 0; i < wiphy->n_iface_combinations; i++) {
+  const struct ieee80211_iface_combination *c;
+  struct ieee80211_iface_limit *limits;
+  u32 all_iftypes = 0;
+
+  c = &wiphy->iface_combinations[i];
+
+  if (num_interfaces > c->max_interfaces)
+   continue;
+  if (num_different_channels > c->num_different_channels)
+   continue;
+
+  limits = kmemdup(c->limits, sizeof(limits[0]) * c->n_limits,
+     GFP_KERNEL);
+  if (!limits)
+   return -ENOMEM;
+
+  for (iftype = 0; iftype < NUM_NL80211_IFTYPES; iftype++) {
+   if (wiphy->software_iftypes & BIT(iftype))
+    continue;
+   for (j = 0; j < c->n_limits; j++) {
+    all_iftypes |= limits[j].types;
+    if (!(limits[j].types & BIT(iftype)))
+     continue;
+    if (limits[j].max < iftype_num[iftype])
+     goto cont;
+    limits[j].max -= iftype_num[iftype];
+   }
+  }
+
+  if (radar_detect != (c->radar_detect_widths & radar_detect))
+   goto cont;
+
+  if (radar_detect && c->radar_detect_regions &&
+      !(c->radar_detect_regions & BIT(region)))
+   goto cont;
+
+  /* Finally check that all iftypes that we're currently
+   * using are actually part of this combination. If they
+   * aren't then we can't use this combination and have
+   * to continue to the next.
+   */
+  if ((all_iftypes & used_iftypes) != used_iftypes)
+   goto cont;
+
+  /* This combination covered all interface types and
+   * supported the requested numbers, so we're good.
+   */
+
+  (*iter)(c, data);
+ cont:
+  kfree(limits);
+ }
+
+ return 0;
+}
+EXPORT_SYMBOL(cfg80211_iter_combinations);
+
+static void
+cfg80211_iter_sum_ifcombs(const struct ieee80211_iface_combination *c,
+     void *data)
+{
+ int *num = data;
+ (*num)++;
+}
+
+int cfg80211_check_combinations(struct wiphy *wiphy,
+    const int num_different_channels,
+    const u8 radar_detect,
+    const int iftype_num[NUM_NL80211_IFTYPES])
+{
+ int err, num = 0;
+
+ err = cfg80211_iter_combinations(wiphy, num_different_channels,
+      radar_detect, iftype_num,
+      cfg80211_iter_sum_ifcombs, &num);
+ if (err)
+  return err;
+ if (num == 0)
+  return -EBUSY;
+
+ return 0;
+}
+EXPORT_SYMBOL(cfg80211_check_combinations);
+
 int cfg80211_can_use_iftype_chan(struct cfg80211_registered_device *rdev,
      struct wireless_dev *wdev,
      enum nl80211_iftype iftype,
@@ -1208,7 +1389,6 @@ int cfg80211_can_use_iftype_chan(struct cfg80211_registered_device *rdev,
      u8 radar_detect)
 {
  struct wireless_dev *wdev_iter;
- u32 used_iftypes = BIT(iftype);
  int num[NUM_NL80211_IFTYPES];
  struct ieee80211_channel
    *used_channels[CFG80211_MAX_NUM_DIFFERENT_CHANNELS];
@@ -1216,38 +1396,14 @@ int cfg80211_can_use_iftype_chan(struct cfg80211_registered_device *rdev,
  enum cfg80211_chan_mode chmode;
  int num_different_channels = 0;
  int total = 1;
- bool radar_required;
- int i, j;
+ int i;
 
  ASSERT_RTNL();
- lockdep_assert_held(&rdev->devlist_mtx);
 
  if (WARN_ON(hweight32(radar_detect) > 1))
   return -EINVAL;
 
- switch (iftype) {
- case NL80211_IFTYPE_ADHOC:
- case NL80211_IFTYPE_AP:
- case NL80211_IFTYPE_AP_VLAN:
- case NL80211_IFTYPE_MESH_POINT:
- case NL80211_IFTYPE_P2P_GO:
- case NL80211_IFTYPE_WDS:
-  radar_required = !!(chan &&
-        (chan->flags & IEEE80211_CHAN_RADAR));
-  break;
- case NL80211_IFTYPE_P2P_CLIENT:
- case NL80211_IFTYPE_STATION:
- case NL80211_IFTYPE_P2P_DEVICE:
- case NL80211_IFTYPE_MONITOR:
-  radar_required = false;
-  break;
- case NUM_NL80211_IFTYPES:
- case NL80211_IFTYPE_UNSPECIFIED:
- default:
-  return -EINVAL;
- }
-
- if (radar_required && !radar_detect)
+ if (WARN_ON(iftype >= NUM_NL80211_IFTYPES))
   return -EINVAL;
 
  /* Always allow software iftypes */
@@ -1262,6 +1418,11 @@ int cfg80211_can_use_iftype_chan(struct cfg80211_registered_device *rdev,
 
  num[iftype] = 1;
 
+ /* TODO: We'll probably not need this anymore, since this
+  * should only be called with CHAN_MODE_UNDEFINED. There are
+  * still a couple of pending calls where other chanmodes are
+  * used, but we should get rid of them.
+  */
  switch (chanmode) {
  case CHAN_MODE_UNDEFINED:
   break;
@@ -1299,7 +1460,7 @@ int cfg80211_can_use_iftype_chan(struct cfg80211_registered_device *rdev,
    */
   mutex_lock_nested(&wdev_iter->mtx, 1);
   __acquire(wdev_iter->mtx);
-  cfg80211_get_chan_state(wdev_iter, &ch, &chmode);
+  cfg80211_get_chan_state(wdev_iter, &ch, &chmode, &radar_detect);
   wdev_unlock(wdev_iter);
 
   switch (chmode) {
@@ -1325,65 +1486,13 @@ int cfg80211_can_use_iftype_chan(struct cfg80211_registered_device *rdev,
 
   num[wdev_iter->iftype]++;
   total++;
-  used_iftypes |= BIT(wdev_iter->iftype);
  }
 
  if (total == 1 && !radar_detect)
   return 0;
 
- for (i = 0; i < rdev->wiphy.n_iface_combinations; i++) {
-  const struct ieee80211_iface_combination *c;
-  struct ieee80211_iface_limit *limits;
-  u32 all_iftypes = 0;
-
-  c = &rdev->wiphy.iface_combinations[i];
-
-  if (total > c->max_interfaces)
-   continue;
-  if (num_different_channels > c->num_different_channels)
-   continue;
-
-  limits = kmemdup(c->limits, sizeof(limits[0]) * c->n_limits,
-     GFP_KERNEL);
-  if (!limits)
-   return -ENOMEM;
-
-  for (iftype = 0; iftype < NUM_NL80211_IFTYPES; iftype++) {
-   if (rdev->wiphy.software_iftypes & BIT(iftype))
-    continue;
-   for (j = 0; j < c->n_limits; j++) {
-    all_iftypes |= limits[j].types;
-    if (!(limits[j].types & BIT(iftype)))
-     continue;
-    if (limits[j].max < num[iftype])
-     goto cont;
-    limits[j].max -= num[iftype];
-   }
-  }
-
-  if (radar_detect && !(c->radar_detect_widths & radar_detect))
-   goto cont;
-
-  /*
-   * Finally check that all iftypes that we're currently
-   * using are actually part of this combination. If they
-   * aren't then we can't use this combination and have
-   * to continue to the next.
-   */
-  if ((all_iftypes & used_iftypes) != used_iftypes)
-   goto cont;
-
-  /*
-   * This combination covered all interface types and
-   * supported the requested numbers, so we're good.
-   */
-  kfree(limits);
-  return 0;
- cont:
-  kfree(limits);
- }
-
- return -EBUSY;
+ return cfg80211_check_combinations(&rdev->wiphy, num_different_channels,
+        radar_detect, num);
 }
 
 int ieee80211_get_ratemask(struct ieee80211_supported_band *sband,
@@ -1424,6 +1533,37 @@ int ieee80211_get_ratemask(struct ieee80211_supported_band *sband,
  return 0;
 }
 
+unsigned int ieee80211_get_num_supported_channels(struct wiphy *wiphy)
+{
+ enum ieee80211_band band;
+ unsigned int n_channels = 0;
+
+ for (band = 0; band < IEEE80211_NUM_BANDS; band++)
+  if (wiphy->bands[band])
+   n_channels += wiphy->bands[band]->n_channels;
+
+ return n_channels;
+}
+EXPORT_SYMBOL(ieee80211_get_num_supported_channels);
+
+int cfg80211_get_station(struct net_device *dev, const u8 *mac_addr,
+    struct station_info *sinfo)
+{
+ struct cfg80211_registered_device *rdev;
+ struct wireless_dev *wdev;
+
+ wdev = dev->ieee80211_ptr;
+ if (!wdev)
+  return -EOPNOTSUPP;
+
+ rdev = wiphy_to_rdev(wdev->wiphy);
+ if (!rdev->ops->get_station)
+  return -EOPNOTSUPP;
+
+ return rdev_get_station(rdev, dev, mac_addr, sinfo);
+}
+EXPORT_SYMBOL(cfg80211_get_station);
+
 /* See IEEE 802.1H for LLC/SNAP encapsulation/decapsulation */
 /* Ethernet-II snap header (RFC1042 for most EtherTypes) */
 const unsigned char rfc1042_header[] __aligned(2) =
diff --git a/net/wireless/wext-compat.c b/net/wireless/wext-compat.c
index d997d0f..11120bb 100644
--- a/net/wireless/wext-compat.c
+++ b/net/wireless/wext-compat.c
@@ -72,9 +72,8 @@ int cfg80211_wext_siwmode(struct net_device *dev, struct iw_request_info *info,
  struct cfg80211_registered_device *rdev;
  struct vif_params vifparams;
  enum nl80211_iftype type;
- int ret;
 
- rdev = wiphy_to_dev(wdev->wiphy);
+ rdev = wiphy_to_rdev(wdev->wiphy);
 
  switch (*mode) {
  case IW_MODE_INFRA:
@@ -98,11 +97,7 @@ int cfg80211_wext_siwmode(struct net_device *dev, struct iw_request_info *info,
 
  memset(&vifparams, 0, sizeof(vifparams));
 
- cfg80211_lock_rdev(rdev);
- ret = cfg80211_change_iface(rdev, dev, type, NULL, &vifparams);
- cfg80211_unlock_rdev(rdev);
-
- return ret;
+ return cfg80211_change_iface(rdev, dev, type, NULL, &vifparams);
 }
 EXPORT_SYMBOL_GPL(cfg80211_wext_siwmode);
 
@@ -258,12 +253,12 @@ EXPORT_SYMBOL_GPL(cfg80211_wext_giwrange);
 
 /**
  * cfg80211_wext_freq - get wext frequency for non-"auto"
- * @wiphy: the wiphy
+ * @dev: the net device
  * @freq: the wext freq encoding
  *
  * Returns a frequency, or a negative error code, or 0 for auto.
  */
-int cfg80211_wext_freq(struct wiphy *wiphy, struct iw_freq *freq)
+int cfg80211_wext_freq(struct iw_freq *freq)
 {
  /*
   * Parse frequency - return 0 for auto and
@@ -291,7 +286,7 @@ int cfg80211_wext_siwrts(struct net_device *dev,
     struct iw_param *rts, char *extra)
 {
  struct wireless_dev *wdev = dev->ieee80211_ptr;
- struct cfg80211_registered_device *rdev = wiphy_to_dev(wdev->wiphy);
+ struct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);
  u32 orts = wdev->wiphy->rts_threshold;
  int err;
 
@@ -329,7 +324,7 @@ int cfg80211_wext_siwfrag(struct net_device *dev,
      struct iw_param *frag, char *extra)
 {
  struct wireless_dev *wdev = dev->ieee80211_ptr;
- struct cfg80211_registered_device *rdev = wiphy_to_dev(wdev->wiphy);
+ struct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);
  u32 ofrag = wdev->wiphy->frag_threshold;
  int err;
 
@@ -369,13 +364,13 @@ static int cfg80211_wext_siwretry(struct net_device *dev,
       struct iw_param *retry, char *extra)
 {
  struct wireless_dev *wdev = dev->ieee80211_ptr;
- struct cfg80211_registered_device *rdev = wiphy_to_dev(wdev->wiphy);
+ struct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);
  u32 changed = 0;
  u8 olong = wdev->wiphy->retry_long;
  u8 oshort = wdev->wiphy->retry_short;
  int err;
 
- if (retry->disabled ||
+ if (retry->disabled || retry->value < 1 || retry->value > 255 ||
      (retry->flags & IW_RETRY_TYPE) != IW_RETRY_LIMIT)
   return -EINVAL;
 
@@ -417,9 +412,9 @@ int cfg80211_wext_giwretry(struct net_device *dev,
    * First return short value, iwconfig will ask long value
    * later if needed
    */
-  retry->flags |= IW_RETRY_LIMIT;
+  retry->flags |= IW_RETRY_LIMIT | IW_RETRY_SHORT;
   retry->value = wdev->wiphy->retry_short;
-  if (wdev->wiphy->retry_long != wdev->wiphy->retry_short)
+  if (wdev->wiphy->retry_long == wdev->wiphy->retry_short)
    retry->flags |= IW_RETRY_LONG;
 
   return 0;
@@ -579,13 +574,10 @@ static int cfg80211_set_encryption(struct cfg80211_registered_device *rdev,
 {
  int err;
 
- /* devlist mutex needed for possible IBSS re-join */
- mutex_lock(&rdev->devlist_mtx);
  wdev_lock(dev->ieee80211_ptr);
  err = __cfg80211_set_encryption(rdev, dev, pairwise, addr,
      remove, tx_key, idx, params);
  wdev_unlock(dev->ieee80211_ptr);
- mutex_unlock(&rdev->devlist_mtx);
 
  return err;
 }
@@ -595,7 +587,7 @@ static int cfg80211_wext_siwencode(struct net_device *dev,
        struct iw_point *erq, char *keybuf)
 {
  struct wireless_dev *wdev = dev->ieee80211_ptr;
- struct cfg80211_registered_device *rdev = wiphy_to_dev(wdev->wiphy);
+ struct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);
  int idx, err;
  bool remove = false;
  struct key_params params;
@@ -655,7 +647,7 @@ static int cfg80211_wext_siwencodeext(struct net_device *dev,
           struct iw_point *erq, char *extra)
 {
  struct wireless_dev *wdev = dev->ieee80211_ptr;
- struct cfg80211_registered_device *rdev = wiphy_to_dev(wdev->wiphy);
+ struct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);
  struct iw_encode_ext *ext = (struct iw_encode_ext *) extra;
  const u8 *addr;
  int idx;
@@ -783,11 +775,11 @@ static int cfg80211_wext_siwfreq(struct net_device *dev,
      struct iw_freq *wextfreq, char *extra)
 {
  struct wireless_dev *wdev = dev->ieee80211_ptr;
- struct cfg80211_registered_device *rdev = wiphy_to_dev(wdev->wiphy);
+ struct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);
  struct cfg80211_chan_def chandef = {
   .width = NL80211_CHAN_WIDTH_20_NOHT,
  };
- int freq, err;
+ int freq;
 
  switch (wdev->iftype) {
  case NL80211_IFTYPE_STATION:
@@ -795,7 +787,7 @@ static int cfg80211_wext_siwfreq(struct net_device *dev,
  case NL80211_IFTYPE_ADHOC:
   return cfg80211_ibss_wext_siwfreq(dev, info, wextfreq, extra);
  case NL80211_IFTYPE_MONITOR:
-  freq = cfg80211_wext_freq(wdev->wiphy, wextfreq);
+  freq = cfg80211_wext_freq(wextfreq);
   if (freq < 0)
    return freq;
   if (freq == 0)
@@ -804,12 +796,9 @@ static int cfg80211_wext_siwfreq(struct net_device *dev,
   chandef.chan = ieee80211_get_channel(&rdev->wiphy, freq);
   if (!chandef.chan)
    return -EINVAL;
-  mutex_lock(&rdev->devlist_mtx);
-  err = cfg80211_set_monitor_channel(rdev, &chandef);
-  mutex_unlock(&rdev->devlist_mtx);
-  return err;
+  return cfg80211_set_monitor_channel(rdev, &chandef);
  case NL80211_IFTYPE_MESH_POINT:
-  freq = cfg80211_wext_freq(wdev->wiphy, wextfreq);
+  freq = cfg80211_wext_freq(wextfreq);
   if (freq < 0)
    return freq;
   if (freq == 0)
@@ -818,10 +807,7 @@ static int cfg80211_wext_siwfreq(struct net_device *dev,
   chandef.chan = ieee80211_get_channel(&rdev->wiphy, freq);
   if (!chandef.chan)
    return -EINVAL;
-  mutex_lock(&rdev->devlist_mtx);
-  err = cfg80211_set_mesh_channel(rdev, wdev, &chandef);
-  mutex_unlock(&rdev->devlist_mtx);
-  return err;
+  return cfg80211_set_mesh_channel(rdev, wdev, &chandef);
  default:
   return -EOPNOTSUPP;
  }
@@ -832,7 +818,7 @@ static int cfg80211_wext_giwfreq(struct net_device *dev,
      struct iw_freq *freq, char *extra)
 {
  struct wireless_dev *wdev = dev->ieee80211_ptr;
- struct cfg80211_registered_device *rdev = wiphy_to_dev(wdev->wiphy);
+ struct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);
  struct cfg80211_chan_def chandef;
  int ret;
 
@@ -861,7 +847,7 @@ static int cfg80211_wext_siwtxpower(struct net_device *dev,
         union iwreq_data *data, char *extra)
 {
  struct wireless_dev *wdev = dev->ieee80211_ptr;
- struct cfg80211_registered_device *rdev = wiphy_to_dev(wdev->wiphy);
+ struct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);
  enum nl80211_tx_power_setting type;
  int dbm = 0;
 
@@ -913,7 +899,7 @@ static int cfg80211_wext_giwtxpower(struct net_device *dev,
         union iwreq_data *data, char *extra)
 {
  struct wireless_dev *wdev = dev->ieee80211_ptr;
- struct cfg80211_registered_device *rdev = wiphy_to_dev(wdev->wiphy);
+ struct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);
  int err, val;
 
  if ((data->txpower.flags & IW_TXPOW_TYPE) != IW_TXPOW_DBM)
@@ -1133,7 +1119,7 @@ static int cfg80211_wext_siwpower(struct net_device *dev,
       struct iw_param *wrq, char *extra)
 {
  struct wireless_dev *wdev = dev->ieee80211_ptr;
- struct cfg80211_registered_device *rdev = wiphy_to_dev(wdev->wiphy);
+ struct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);
  bool ps = wdev->ps;
  int timeout = wdev->ps_timeout;
  int err;
@@ -1191,7 +1177,7 @@ static int cfg80211_wds_wext_siwap(struct net_device *dev,
        struct sockaddr *addr, char *extra)
 {
  struct wireless_dev *wdev = dev->ieee80211_ptr;
- struct cfg80211_registered_device *rdev = wiphy_to_dev(wdev->wiphy);
+ struct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);
  int err;
 
  if (WARN_ON(wdev->iftype != NL80211_IFTYPE_WDS))
@@ -1235,7 +1221,7 @@ static int cfg80211_wext_siwrate(struct net_device *dev,
      struct iw_param *rate, char *extra)
 {
  struct wireless_dev *wdev = dev->ieee80211_ptr;
- struct cfg80211_registered_device *rdev = wiphy_to_dev(wdev->wiphy);
+ struct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);
  struct cfg80211_bitrate_mask mask;
  u32 fixed, maxrate;
  struct ieee80211_supported_band *sband;
@@ -1286,7 +1272,7 @@ static int cfg80211_wext_giwrate(struct net_device *dev,
      struct iw_param *rate, char *extra)
 {
  struct wireless_dev *wdev = dev->ieee80211_ptr;
- struct cfg80211_registered_device *rdev = wiphy_to_dev(wdev->wiphy);
+ struct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);
  /* we are under RTNL - globally locked - so can use a static struct */
  static struct station_info sinfo;
  u8 addr[ETH_ALEN];
@@ -1324,7 +1310,7 @@ static int cfg80211_wext_giwrate(struct net_device *dev,
 static struct iw_statistics *cfg80211_wireless_stats(struct net_device *dev)
 {
  struct wireless_dev *wdev = dev->ieee80211_ptr;
- struct cfg80211_registered_device *rdev = wiphy_to_dev(wdev->wiphy);
+ struct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);
  /* we are under RTNL - globally locked - so can use static structs */
  static struct iw_statistics wstats;
  static struct station_info sinfo;
@@ -1463,7 +1449,7 @@ static int cfg80211_wext_siwpmksa(struct net_device *dev,
       struct iw_point *data, char *extra)
 {
  struct wireless_dev *wdev = dev->ieee80211_ptr;
- struct cfg80211_registered_device *rdev = wiphy_to_dev(wdev->wiphy);
+ struct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);
  struct cfg80211_pmksa cfg_pmksa;
  struct iw_pmksa *pmksa = (struct iw_pmksa *)extra;
 
diff --git a/net/wireless/wext-compat.h b/net/wireless/wext-compat.h
index 5d766b0..ebcacca 100644
--- a/net/wireless/wext-compat.h
+++ b/net/wireless/wext-compat.h
@@ -50,7 +50,7 @@ int cfg80211_wext_siwgenie(struct net_device *dev,
       struct iw_point *data, char *extra);
 
 
-int cfg80211_wext_freq(struct wiphy *wiphy, struct iw_freq *freq);
+int cfg80211_wext_freq(struct iw_freq *freq);
 
 
 extern const struct iw_handler_def cfg80211_wext_handler;
diff --git a/net/wireless/wext-sme.c b/net/wireless/wext-sme.c
index e79cb5c..c7e5c8e 100644
--- a/net/wireless/wext-sme.c
+++ b/net/wireless/wext-sme.c
@@ -21,7 +21,7 @@ int cfg80211_mgd_wext_connect(struct cfg80211_registered_device *rdev,
  const u8 *prev_bssid = NULL;
  int err, i;
 
- ASSERT_RDEV_LOCK(rdev);
+ ASSERT_RTNL();
  ASSERT_WDEV_LOCK(wdev);
 
  if (!netif_running(wdev->netdev))
@@ -54,8 +54,8 @@ int cfg80211_mgd_wext_connect(struct cfg80211_registered_device *rdev,
  if (wdev->wext.prev_bssid_valid)
   prev_bssid = wdev->wext.prev_bssid;
 
- err = __cfg80211_connect(rdev, wdev->netdev,
-     &wdev->wext.connect, ck, prev_bssid);
+ err = cfg80211_connect(rdev, wdev->netdev,
+          &wdev->wext.connect, ck, prev_bssid);
  if (err)
   kfree(ck);
 
@@ -67,7 +67,7 @@ int cfg80211_mgd_wext_siwfreq(struct net_device *dev,
          struct iw_freq *wextfreq, char *extra)
 {
  struct wireless_dev *wdev = dev->ieee80211_ptr;
- struct cfg80211_registered_device *rdev = wiphy_to_dev(wdev->wiphy);
+ struct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);
  struct ieee80211_channel *chan = NULL;
  int err, freq;
 
@@ -75,7 +75,7 @@ int cfg80211_mgd_wext_siwfreq(struct net_device *dev,
  if (WARN_ON(wdev->iftype != NL80211_IFTYPE_STATION))
   return -EINVAL;
 
- freq = cfg80211_wext_freq(wdev->wiphy, wextfreq);
+ freq = cfg80211_wext_freq(wextfreq);
  if (freq < 0)
   return freq;
 
@@ -87,12 +87,9 @@ int cfg80211_mgd_wext_siwfreq(struct net_device *dev,
    return -EINVAL;
  }
 
- cfg80211_lock_rdev(rdev);
- mutex_lock(&rdev->devlist_mtx);
- mutex_lock(&rdev->sched_scan_mtx);
  wdev_lock(wdev);
 
- if (wdev->sme_state != CFG80211_SME_IDLE) {
+ if (wdev->conn) {
   bool event = true;
 
   if (wdev->wext.connect.channel == chan) {
@@ -103,8 +100,8 @@ int cfg80211_mgd_wext_siwfreq(struct net_device *dev,
   /* if SSID set, we'll try right again, avoid event */
   if (wdev->wext.connect.ssid_len)
    event = false;
-  err = __cfg80211_disconnect(rdev, dev,
-         WLAN_REASON_DEAUTH_LEAVING, event);
+  err = cfg80211_disconnect(rdev, dev,
+       WLAN_REASON_DEAUTH_LEAVING, event);
   if (err)
    goto out;
  }
@@ -136,9 +133,6 @@ int cfg80211_mgd_wext_siwfreq(struct net_device *dev,
  err = cfg80211_mgd_wext_connect(rdev, wdev);
  out:
  wdev_unlock(wdev);
- mutex_unlock(&rdev->sched_scan_mtx);
- mutex_unlock(&rdev->devlist_mtx);
- cfg80211_unlock_rdev(rdev);
  return err;
 }
 
@@ -175,7 +169,7 @@ int cfg80211_mgd_wext_siwessid(struct net_device *dev,
           struct iw_point *data, char *ssid)
 {
  struct wireless_dev *wdev = dev->ieee80211_ptr;
- struct cfg80211_registered_device *rdev = wiphy_to_dev(wdev->wiphy);
+ struct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);
  size_t len = data->length;
  int err;
 
@@ -190,14 +184,11 @@ int cfg80211_mgd_wext_siwessid(struct net_device *dev,
  if (len > 0 && ssid[len - 1] == '\0')
   len--;
 
- cfg80211_lock_rdev(rdev);
- mutex_lock(&rdev->devlist_mtx);
- mutex_lock(&rdev->sched_scan_mtx);
  wdev_lock(wdev);
 
  err = 0;
 
- if (wdev->sme_state != CFG80211_SME_IDLE) {
+ if (wdev->conn) {
   bool event = true;
 
   if (wdev->wext.connect.ssid && len &&
@@ -208,8 +199,8 @@ int cfg80211_mgd_wext_siwessid(struct net_device *dev,
   /* if SSID set now, we'll try to connect, avoid event */
   if (len)
    event = false;
-  err = __cfg80211_disconnect(rdev, dev,
-         WLAN_REASON_DEAUTH_LEAVING, event);
+  err = cfg80211_disconnect(rdev, dev,
+       WLAN_REASON_DEAUTH_LEAVING, event);
   if (err)
    goto out;
  }
@@ -226,9 +217,6 @@ int cfg80211_mgd_wext_siwessid(struct net_device *dev,
  err = cfg80211_mgd_wext_connect(rdev, wdev);
  out:
  wdev_unlock(wdev);
- mutex_unlock(&rdev->sched_scan_mtx);
- mutex_unlock(&rdev->devlist_mtx);
- cfg80211_unlock_rdev(rdev);
  return err;
 }
 
@@ -272,7 +260,7 @@ int cfg80211_mgd_wext_siwap(struct net_device *dev,
        struct sockaddr *ap_addr, char *extra)
 {
  struct wireless_dev *wdev = dev->ieee80211_ptr;
- struct cfg80211_registered_device *rdev = wiphy_to_dev(wdev->wiphy);
+ struct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);
  u8 *bssid = ap_addr->sa_data;
  int err;
 
@@ -287,12 +275,9 @@ int cfg80211_mgd_wext_siwap(struct net_device *dev,
  if (is_zero_ether_addr(bssid) || is_broadcast_ether_addr(bssid))
   bssid = NULL;
 
- cfg80211_lock_rdev(rdev);
- mutex_lock(&rdev->devlist_mtx);
- mutex_lock(&rdev->sched_scan_mtx);
  wdev_lock(wdev);
 
- if (wdev->sme_state != CFG80211_SME_IDLE) {
+ if (wdev->conn) {
   err = 0;
   /* both automatic */
   if (!bssid && !wdev->wext.connect.bssid)
@@ -303,8 +288,8 @@ int cfg80211_mgd_wext_siwap(struct net_device *dev,
       ether_addr_equal(bssid, wdev->wext.connect.bssid))
    goto out;
 
-  err = __cfg80211_disconnect(rdev, dev,
-         WLAN_REASON_DEAUTH_LEAVING, false);
+  err = cfg80211_disconnect(rdev, dev,
+       WLAN_REASON_DEAUTH_LEAVING, false);
   if (err)
    goto out;
  }
@@ -318,9 +303,6 @@ int cfg80211_mgd_wext_siwap(struct net_device *dev,
  err = cfg80211_mgd_wext_connect(rdev, wdev);
  out:
  wdev_unlock(wdev);
- mutex_unlock(&rdev->sched_scan_mtx);
- mutex_unlock(&rdev->devlist_mtx);
- cfg80211_unlock_rdev(rdev);
  return err;
 }
 
@@ -351,7 +333,7 @@ int cfg80211_wext_siwgenie(struct net_device *dev,
       struct iw_point *data, char *extra)
 {
  struct wireless_dev *wdev = dev->ieee80211_ptr;
- struct cfg80211_registered_device *rdev = wiphy_to_dev(wdev->wiphy);
+ struct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);
  u8 *ie = extra;
  int ie_len = data->length, err;
 
@@ -382,9 +364,9 @@ int cfg80211_wext_siwgenie(struct net_device *dev,
  wdev->wext.ie = ie;
  wdev->wext.ie_len = ie_len;
 
- if (wdev->sme_state != CFG80211_SME_IDLE) {
-  err = __cfg80211_disconnect(rdev, dev,
-         WLAN_REASON_DEAUTH_LEAVING, false);
+ if (wdev->conn) {
+  err = cfg80211_disconnect(rdev, dev,
+       WLAN_REASON_DEAUTH_LEAVING, false);
   if (err)
    goto out;
  }
@@ -408,7 +390,7 @@ int cfg80211_wext_siwmlme(struct net_device *dev,
  if (!wdev)
   return -EOPNOTSUPP;
 
- rdev = wiphy_to_dev(wdev->wiphy);
+ rdev = wiphy_to_rdev(wdev->wiphy);
 
  if (wdev->iftype != NL80211_IFTYPE_STATION)
   return -EINVAL;
@@ -420,8 +402,7 @@ int cfg80211_wext_siwmlme(struct net_device *dev,
  switch (mlme->cmd) {
  case IW_MLME_DEAUTH:
  case IW_MLME_DISASSOC:
-  err = __cfg80211_disconnect(rdev, dev, mlme->reason_code,
-         true);
+  err = cfg80211_disconnect(rdev, dev, mlme->reason_code, true);
   break;
  default:
   err = -EOPNOTSUPP;
-- 
1.7.1