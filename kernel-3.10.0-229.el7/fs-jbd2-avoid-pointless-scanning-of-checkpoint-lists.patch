From 7a8a34d972be03b6a65b3c489a8e38d221b98c0a Mon Sep 17 00:00:00 2001
From: Lukas Czerner <lczerner@redhat.com>
Date: Wed, 29 Oct 2014 16:34:31 -0400
Subject: [fs] jbd2: avoid pointless scanning of checkpoint lists

Message-id: <1414600485-1929-42-git-send-email-lczerner@redhat.com>
Patchwork-id: 98545
O-Subject: [RHEL 7.1 PATCH v2 41/55] jbd2: avoid pointless scanning of checkpoint lists
Bugzilla: 1156096
RH-Acked-by: Eric Sandeen <sandeen@redhat.com>

From: Jan Kara <jack@suse.cz>

BZ 1156096
https://bugzilla.redhat.com/show_bug.cgi?id=1156096

BREW 8169722
https://brewweb.devel.redhat.com/taskinfo?taskID=8169722

Upstream commit cc97f1a7c7eed970e674b84be0e68f479c80228d

 Yuanhan has reported that when he is running fsync(2) heavy workload
 creating new files over ramdisk, significant amount of time is spent in
 __jbd2_journal_clean_checkpoint_list() trying to clean old transactions
 (but they cannot be cleaned up because flusher hasn't yet checkpointed
 those buffers). The workload can be generated by:
   fs_mark -d /fs/ram0/1 -D 2 -N 2560 -n 1000000 -L 1 -S 1 -s 4096

 Reduce the amount of scanning by stopping to scan the transaction list
 once we find a transaction that cannot be checkpointed. Note that this
 way of cleaning is still enough to keep freeing space in the journal
 after fully checkpointed transactions.

 Reported-and-tested-by: Yuanhan Liu <yuanhan.liu@linux.intel.com>
 Signed-off-by: Jan Kara <jack@suse.cz>
 Signed-off-by: Theodore Ts'o <tytso@mit.edu>
---

Signed-off-by: Jarod Wilson <jarod@redhat.com>

diff --git a/fs/jbd2/checkpoint.c b/fs/jbd2/checkpoint.c
index 9b84795..dd8a8a2 100644
--- a/fs/jbd2/checkpoint.c
+++ b/fs/jbd2/checkpoint.c
@@ -480,7 +480,6 @@ int jbd2_cleanup_journal_tail(journal_t *journal)
  * Find all the written-back checkpoint buffers in the given list and
  * release them.
  *
- * Called with the journal locked.
  * Called with j_list_lock held.
  * Returns number of buffers reaped (for debug)
  */
@@ -500,12 +499,12 @@ static int journal_clean_one_cp_list(struct journal_head *jh, int *released)
   jh = next_jh;
   next_jh = jh->b_cpnext;
   ret = __try_to_free_cp_buf(jh);
-  if (ret) {
-   freed++;
-   if (ret == 2) {
-    *released = 1;
-    return freed;
-   }
+  if (!ret)
+   return freed;
+  freed++;
+  if (ret == 2) {
+   *released = 1;
+   return freed;
   }
   /*
    * This function only frees up some memory
@@ -525,7 +524,6 @@ static int journal_clean_one_cp_list(struct journal_head *jh, int *released)
  *
  * Find all the written-back checkpoint buffers in the journal and release them.
  *
- * Called with the journal locked.
  * Called with j_list_lock held.
  * Returns number of buffers reaped (for debug)
  */
@@ -533,7 +531,8 @@ static int journal_clean_one_cp_list(struct journal_head *jh, int *released)
 int __jbd2_journal_clean_checkpoint_list(journal_t *journal)
 {
  transaction_t *transaction, *last_transaction, *next_transaction;
- int ret = 0;
+ int ret;
+ int freed = 0;
  int released;
 
  transaction = journal->j_checkpoint_transactions;
@@ -545,17 +544,21 @@ int __jbd2_journal_clean_checkpoint_list(journal_t *journal)
  do {
   transaction = next_transaction;
   next_transaction = transaction->t_cpnext;
-  ret += journal_clean_one_cp_list(transaction->
+  ret = journal_clean_one_cp_list(transaction->
     t_checkpoint_list, &released);
   /*
    * This function only frees up some memory if possible so we
    * dont have an obligation to finish processing. Bail out if
    * preemption requested:
    */
-  if (need_resched())
+  if (need_resched()) {
+   freed += ret;
    goto out;
-  if (released)
+  }
+  if (released) {
+   freed += ret;
    continue;
+  }
   /*
    * It is essential that we are as careful as in the case of
    * t_checkpoint_list with removing the buffer from the list as
@@ -563,11 +566,12 @@ int __jbd2_journal_clean_checkpoint_list(journal_t *journal)
    */
   ret += journal_clean_one_cp_list(transaction->
     t_checkpoint_io_list, &released);
-  if (need_resched())
+  freed += ret;
+  if (need_resched() || !ret)
    goto out;
  } while (transaction != last_transaction);
 out:
- return ret;
+ return freed;
 }
 
 /*
-- 
1.7.1