From e9f8487ce12842406ca7ad7e7777ec095fb1b85f Mon Sep 17 00:00:00 2001
From: Jaroslav Kysela <jkysela@redhat.com>
Date: Wed, 3 Sep 2014 07:21:37 -0400
Subject: [alsa] hda: Replace with standard printk

Message-id: <140972823573-146-patchset-jkysela@redhat.com>
Patchwork-id: 90846
O-Subject: [RHEL 7.1 PATCH 145/442] ALSA: hda - Replace with standard printk
Bugzilla: 1112200
RH-Acked-by: John Linville <linville@redhat.com>
RH-Acked-by: Prarit Bhargava <prarit@redhat.com>
RH-Acked-by: Ivan Vecera <ivecera@redhat.com>

Use dev_err() and co for messages from HD-audio controller and codec
drivers.  The codec drivers are mostly bound with codec objects, so
some helper macros, codec_err(), codec_info(), etc, are provided.
They merely wrap the corresponding dev_xxx().

There are a few places still calling snd_printk() and its variants
as they are called without the codec or device context.

Signed-off-by: Takashi Iwai <tiwai@suse.de>

(picked from kernel: 4e76a8833fac8dc1735aa5be7d1b3c92c65e209e)
rhbz#1112200
Signed-off-by: Jaroslav Kysela <jkysela@redhat.com>
---

Signed-off-by: Jarod Wilson <jarod@redhat.com>

diff --git a/sound/pci/hda/hda_auto_parser.c b/sound/pci/hda/hda_auto_parser.c
index 47ad31c..8de7cfa 100644
--- a/sound/pci/hda/hda_auto_parser.c
+++ b/sound/pci/hda/hda_auto_parser.c
@@ -313,9 +313,9 @@ int snd_hda_parse_pin_defcfg(struct hda_codec *codec,
   }
 
   if (hsmic)
-   snd_printdd("Told to look for a headset mic, but didn't find any.\n");
+   codec_dbg(codec, "Told to look for a headset mic, but didn't find any.\n");
   if (hpmic)
-   snd_printdd("Told to look for a headphone mic, but didn't find any.\n");
+   codec_dbg(codec, "Told to look for a headphone mic, but didn't find any.\n");
  }
 
  /* FIX-UP:
@@ -384,33 +384,33 @@ int snd_hda_parse_pin_defcfg(struct hda_codec *codec,
  /*
   * debug prints of the parsed results
   */
- snd_printd("autoconfig: line_outs=%d (0x%x/0x%x/0x%x/0x%x/0x%x) type:%s\n",
+ codec_info(codec, "autoconfig: line_outs=%d (0x%x/0x%x/0x%x/0x%x/0x%x) type:%s\n",
      cfg->line_outs, cfg->line_out_pins[0], cfg->line_out_pins[1],
      cfg->line_out_pins[2], cfg->line_out_pins[3],
      cfg->line_out_pins[4],
      cfg->line_out_type == AUTO_PIN_HP_OUT ? "hp" :
      (cfg->line_out_type == AUTO_PIN_SPEAKER_OUT ?
       "speaker" : "line"));
- snd_printd("   speaker_outs=%d (0x%x/0x%x/0x%x/0x%x/0x%x)\n",
+ codec_info(codec, "   speaker_outs=%d (0x%x/0x%x/0x%x/0x%x/0x%x)\n",
      cfg->speaker_outs, cfg->speaker_pins[0],
      cfg->speaker_pins[1], cfg->speaker_pins[2],
      cfg->speaker_pins[3], cfg->speaker_pins[4]);
- snd_printd("   hp_outs=%d (0x%x/0x%x/0x%x/0x%x/0x%x)\n",
+ codec_info(codec, "   hp_outs=%d (0x%x/0x%x/0x%x/0x%x/0x%x)\n",
      cfg->hp_outs, cfg->hp_pins[0],
      cfg->hp_pins[1], cfg->hp_pins[2],
      cfg->hp_pins[3], cfg->hp_pins[4]);
- snd_printd("   mono: mono_out=0x%x\n", cfg->mono_out_pin);
+ codec_info(codec, "   mono: mono_out=0x%x\n", cfg->mono_out_pin);
  if (cfg->dig_outs)
-  snd_printd("   dig-out=0x%x/0x%x\n",
+  codec_info(codec, "   dig-out=0x%x/0x%x\n",
       cfg->dig_out_pins[0], cfg->dig_out_pins[1]);
- snd_printd("   inputs:\n");
+ codec_info(codec, "   inputs:\n");
  for (i = 0; i < cfg->num_inputs; i++) {
-  snd_printd("     %s=0x%x\n",
+  codec_info(codec, "     %s=0x%x\n",
        hda_get_autocfg_input_label(codec, cfg, i),
        cfg->inputs[i].pin);
  }
  if (cfg->dig_in_pin)
-  snd_printd("   dig-in=0x%x\n", cfg->dig_in_pin);
+  codec_info(codec, "   dig-in=0x%x\n", cfg->dig_in_pin);
 
  return 0;
 }
@@ -774,38 +774,33 @@ static void apply_fixup(struct hda_codec *codec, int id, int action, int depth)
   case HDA_FIXUP_PINS:
    if (action != HDA_FIXUP_ACT_PRE_PROBE || !fix->v.pins)
     break;
-   snd_printdd(KERN_INFO SFX
-        "%s: Apply pincfg for %s\n",
+   codec_dbg(codec, "%s: Apply pincfg for %s\n",
         codec->chip_name, modelname);
    snd_hda_apply_pincfgs(codec, fix->v.pins);
    break;
   case HDA_FIXUP_VERBS:
    if (action != HDA_FIXUP_ACT_PROBE || !fix->v.verbs)
     break;
-   snd_printdd(KERN_INFO SFX
-        "%s: Apply fix-verbs for %s\n",
+   codec_dbg(codec, "%s: Apply fix-verbs for %s\n",
         codec->chip_name, modelname);
    snd_hda_add_verbs(codec, fix->v.verbs);
    break;
   case HDA_FIXUP_FUNC:
    if (!fix->v.func)
     break;
-   snd_printdd(KERN_INFO SFX
-        "%s: Apply fix-func for %s\n",
+   codec_dbg(codec, "%s: Apply fix-func for %s\n",
         codec->chip_name, modelname);
    fix->v.func(codec, fix, action);
    break;
   case HDA_FIXUP_PINCTLS:
    if (action != HDA_FIXUP_ACT_PROBE || !fix->v.pins)
     break;
-   snd_printdd(KERN_INFO SFX
-        "%s: Apply pinctl for %s\n",
+   codec_dbg(codec, "%s: Apply pinctl for %s\n",
         codec->chip_name, modelname);
    set_pin_targets(codec, fix->v.pins);
    break;
   default:
-   snd_printk(KERN_ERR SFX
-       "%s: Invalid fixup type %d\n",
+   codec_err(codec, "%s: Invalid fixup type %d\n",
        codec->chip_name, fix->type);
    break;
   }
diff --git a/sound/pci/hda/hda_beep.c b/sound/pci/hda/hda_beep.c
index d8c437a..d403981 100644
--- a/sound/pci/hda/hda_beep.c
+++ b/sound/pci/hda/hda_beep.c
@@ -172,7 +172,7 @@ static int snd_hda_do_attach(struct hda_beep *beep)
  err = input_register_device(input_dev);
  if (err < 0) {
   input_free_device(input_dev);
-  printk(KERN_INFO "hda_beep: unable to register input device\n");
+  codec_err(codec, "hda_beep: unable to register input device\n");
   return err;
  }
  beep->dev = input_dev;
diff --git a/sound/pci/hda/hda_codec.c b/sound/pci/hda/hda_codec.c
index 2cba4dc..6db2dbc 100644
--- a/sound/pci/hda/hda_codec.c
+++ b/sound/pci/hda/hda_codec.c
@@ -201,7 +201,7 @@ make_codec_cmd(struct hda_codec *codec, hda_nid_t nid, int flags,
 
  if ((codec->addr & ~0xf) || (nid & ~0x7f) ||
      (verb & ~0xfff) || (parm & ~0xffff)) {
-  printk(KERN_ERR "hda-codec: out of range cmd %x:%x:%x:%x\n",
+  codec_err(codec, "hda-codec: out of range cmd %x:%x:%x:%x\n",
          codec->addr, nid, verb, parm);
   return ~0;
  }
@@ -249,8 +249,8 @@ static int codec_exec_verb(struct hda_codec *codec, unsigned int cmd,
  snd_hda_power_down(codec);
  if (!codec_in_pm(codec) && res && *res == -1 && bus->rirb_error) {
   if (bus->response_reset) {
-   snd_printd("hda_codec: resetting BUS due to "
-       "fatal communication error\n");
+   codec_dbg(codec,
+      "resetting BUS due to fatal communication error\n");
    trace_hda_bus_reset(bus);
    bus->ops.bus_reset(bus);
   }
@@ -475,8 +475,7 @@ int snd_hda_get_connections(struct hda_codec *codec, hda_nid_t nid,
 
  if (len > 0 && conn_list) {
   if (len > max_conns) {
-   snd_printk(KERN_ERR "hda_codec: "
-       "Too many connections %d for NID 0x%x\n",
+   codec_err(codec, "Too many connections %d for NID 0x%x\n",
        len, nid);
    return -EINVAL;
   }
@@ -574,8 +573,8 @@ int snd_hda_get_raw_connections(struct hda_codec *codec, hda_nid_t nid,
   range_val = !!(parm & (1 << (shift-1))); /* ranges */
   val = parm & mask;
   if (val == 0 && null_count++) {  /* no second chance */
-   snd_printdd("hda_codec: "
-       "invalid CONNECT_LIST verb %x[%i]:%x\n",
+   codec_dbg(codec,
+      "invalid CONNECT_LIST verb %x[%i]:%x\n",
         nid, i, parm);
    return 0;
   }
@@ -583,7 +582,7 @@ int snd_hda_get_raw_connections(struct hda_codec *codec, hda_nid_t nid,
   if (range_val) {
    /* ranges between the previous and this one */
    if (!prev_nid || prev_nid >= val) {
-    snd_printk(KERN_WARNING "hda_codec: "
+    codec_warn(codec,
         "invalid dep_range_val %x:%x\n",
         prev_nid, val);
     continue;
@@ -660,7 +659,7 @@ int snd_hda_get_conn_index(struct hda_codec *codec, hda_nid_t mux,
  if (!recursive)
   return -1;
  if (recursive > 10) {
-  snd_printd("hda_codec: too deep connection for 0x%x\n", nid);
+  codec_dbg(codec, "too deep connection for 0x%x\n", nid);
   return -1;
  }
  recursive++;
@@ -808,8 +807,7 @@ static int init_unsol_queue(struct hda_bus *bus)
 
  unsol = kzalloc(sizeof(*unsol), GFP_KERNEL);
  if (!unsol) {
-  snd_printk(KERN_ERR "hda_codec: "
-      "can't allocate unsolicited queue\n");
+  dev_err(bus->card->dev, "can't allocate unsolicited queue\n");
   return -ENOMEM;
  }
  INIT_WORK(&unsol->work, process_unsol_events);
@@ -881,7 +879,7 @@ int snd_hda_bus_new(struct snd_card *card,
 
  bus = kzalloc(sizeof(*bus), GFP_KERNEL);
  if (bus == NULL) {
-  snd_printk(KERN_ERR "can't allocate struct hda_bus\n");
+  dev_err(card->dev, "can't allocate struct hda_bus\n");
   return -ENOMEM;
  }
 
@@ -900,7 +898,7 @@ int snd_hda_bus_new(struct snd_card *card,
    "hd-audio%d", card->number);
  bus->workq = create_singlethread_workqueue(bus->workq_name);
  if (!bus->workq) {
-  snd_printk(KERN_ERR "cannot create workqueue %s\n",
+  dev_err(card->dev, "cannot create workqueue %s\n",
       bus->workq_name);
   kfree(bus);
   return -ENOMEM;
@@ -944,7 +942,7 @@ find_codec_preset(struct hda_codec *codec)
  mutex_lock(&preset_mutex);
  list_for_each_entry(tbl, &hda_preset_tables, list) {
   if (!try_module_get(tbl->owner)) {
-   snd_printk(KERN_ERR "hda_codec: cannot module_get\n");
+   codec_err(codec, "cannot module_get\n");
    continue;
   }
   for (preset = tbl->preset; preset->id; preset++) {
@@ -1433,14 +1431,15 @@ int snd_hda_codec_new(struct hda_bus *bus,
   return -EINVAL;
 
  if (bus->caddr_tbl[codec_addr]) {
-  snd_printk(KERN_ERR "hda_codec: "
-      "address 0x%x is already occupied\n", codec_addr);
+  dev_err(bus->card->dev,
+   "address 0x%x is already occupied\n",
+   codec_addr);
   return -EBUSY;
  }
 
  codec = kzalloc(sizeof(*codec), GFP_KERNEL);
  if (codec == NULL) {
-  snd_printk(KERN_ERR "can't allocate struct hda_codec\n");
+  dev_err(bus->card->dev, "can't allocate struct hda_codec\n");
   return -ENOMEM;
  }
 
@@ -1513,7 +1512,7 @@ int snd_hda_codec_new(struct hda_bus *bus,
 
  setup_fg_nodes(codec);
  if (!codec->afg && !codec->mfg) {
-  snd_printdd("hda_codec: no AFG or MFG node found\n");
+  dev_err(bus->card->dev, "no AFG or MFG node found\n");
   err = -ENODEV;
   goto error;
  }
@@ -1521,7 +1520,7 @@ int snd_hda_codec_new(struct hda_bus *bus,
  fg = codec->afg ? codec->afg : codec->mfg;
  err = read_widget_caps(codec, fg);
  if (err < 0) {
-  snd_printk(KERN_ERR "hda_codec: cannot malloc\n");
+  dev_err(bus->card->dev, "cannot malloc\n");
   goto error;
  }
  err = read_pin_defaults(codec);
@@ -1583,7 +1582,7 @@ int snd_hda_codec_update_widgets(struct hda_codec *codec)
  fg = codec->afg ? codec->afg : codec->mfg;
  err = read_widget_caps(codec, fg);
  if (err < 0) {
-  snd_printk(KERN_ERR "hda_codec: cannot malloc\n");
+  codec_err(codec, "cannot malloc\n");
   return err;
  }
 
@@ -1660,7 +1659,7 @@ int snd_hda_codec_configure(struct hda_codec *codec)
 #endif
   }
   if (!patch) {
-   printk(KERN_ERR "hda-codec: No codec parser is available\n");
+   codec_err(codec, "No codec parser is available\n");
    return -ENODEV;
   }
  }
@@ -1744,9 +1743,9 @@ void snd_hda_codec_setup_stream(struct hda_codec *codec, hda_nid_t nid,
  if (!nid)
   return;
 
- snd_printdd("hda_codec_setup_stream: "
-      "NID=0x%x, stream=0x%x, channel=%d, format=0x%x\n",
-      nid, stream_tag, channel_id, format);
+ codec_dbg(codec,
+    "hda_codec_setup_stream: NID=0x%x, stream=0x%x, channel=%d, format=0x%x\n",
+    nid, stream_tag, channel_id, format);
  p = get_hda_cvt_setup(codec, nid);
  if (!p)
   return;
@@ -1793,7 +1792,7 @@ void __snd_hda_codec_cleanup_stream(struct hda_codec *codec, hda_nid_t nid,
  if (codec->no_sticky_stream)
   do_now = 1;
 
- snd_printdd("hda_codec_cleanup_stream: NID=0x%x\n", nid);
+ codec_dbg(codec, "hda_codec_cleanup_stream: NID=0x%x\n", nid);
  p = get_hda_cvt_setup(codec, nid);
  if (p) {
   /* here we just clear the active flag when do_now isn't set;
@@ -2315,9 +2314,9 @@ int snd_hda_mixer_amp_volume_info(struct snd_kcontrol *kcontrol,
  uinfo->value.integer.min = 0;
  uinfo->value.integer.max = get_amp_max_value(codec, nid, dir, ofs);
  if (!uinfo->value.integer.max) {
-  printk(KERN_WARNING "hda_codec: "
-         "num_steps = 0 for NID=0x%x (ctl = %s)\n", nid,
-         kcontrol->id.name);
+  codec_warn(codec,
+      "num_steps = 0 for NID=0x%x (ctl = %s)\n",
+      nid, kcontrol->id.name);
   return -EINVAL;
  }
  return 0;
@@ -2591,8 +2590,8 @@ int snd_hda_add_nid(struct hda_codec *codec, struct snd_kcontrol *kctl,
   item->nid = nid;
   return 0;
  }
- printk(KERN_ERR "hda-codec: no NID for mapping control %s:%d:%d\n",
-        kctl->id.name, kctl->id.index, index);
+ codec_err(codec, "no NID for mapping control %s:%d:%d\n",
+    kctl->id.name, kctl->id.index, index);
  return -EINVAL;
 }
 EXPORT_SYMBOL_GPL(snd_hda_add_nid);
@@ -2784,7 +2783,7 @@ static int get_kctl_0dB_offset(struct snd_kcontrol *kctl, int *step_to_check)
    return -1;
   if (*step_to_check && *step_to_check != step) {
    snd_printk(KERN_ERR "hda_codec: Mismatching dB step for vmaster slave (%d!=%d)\n",
-       *step_to_check, step);
+-       *step_to_check, step);
    return -1;
   }
   *step_to_check = step;
@@ -2854,7 +2853,7 @@ int __snd_hda_add_vmaster(struct hda_codec *codec, char *name,
 
  err = map_slaves(codec, slaves, suffix, check_slave_present, NULL);
  if (err != 1) {
-  snd_printdd("No slave found for %s\n", name);
+  codec_dbg(codec, "No slave found for %s\n", name);
   return 0;
  }
  kctl = snd_ctl_make_virtual_master(name, tlv);
@@ -3520,7 +3519,7 @@ int snd_hda_create_dig_out_ctls(struct hda_codec *codec,
 
  idx = find_empty_mixer_ctl_idx(codec, "IEC958 Playback Switch", idx);
  if (idx < 0) {
-  printk(KERN_ERR "hda_codec: too many IEC958 outputs\n");
+  codec_err(codec, "too many IEC958 outputs\n");
   return -EBUSY;
  }
  spdif = snd_array_new(&codec->spdif_out);
@@ -3724,7 +3723,7 @@ int snd_hda_create_spdif_in_ctls(struct hda_codec *codec, hda_nid_t nid)
 
  idx = find_empty_mixer_ctl_idx(codec, "IEC958 Capture Switch", 0);
  if (idx < 0) {
-  printk(KERN_ERR "hda_codec: too many IEC958 inputs\n");
+  codec_err(codec, "too many IEC958 inputs\n");
   return -EBUSY;
  }
  for (dig_mix = dig_in_ctls; dig_mix->name; dig_mix++) {
@@ -4151,12 +4150,13 @@ int snd_hda_build_controls(struct hda_bus *bus)
  list_for_each_entry(codec, &bus->codec_list, list) {
   int err = snd_hda_codec_build_controls(codec);
   if (err < 0) {
-   printk(KERN_ERR "hda_codec: cannot build controls "
-          "for #%d (error %d)\n", codec->addr, err);
+   codec_err(codec,
+      "cannot build controls for #%d (error %d)\n",
+      codec->addr, err);
    err = snd_hda_codec_reset(codec);
    if (err < 0) {
-    printk(KERN_ERR
-           "hda_codec: cannot revert codec\n");
+    codec_err(codec,
+       "cannot revert codec\n");
     return err;
    }
   }
@@ -4327,7 +4327,7 @@ unsigned int snd_hda_calc_stream_format(unsigned int rate,
   break;
  default:
   snd_printdd("invalid format width %d\n",
-       snd_pcm_format_width(format));
+     snd_pcm_format_width(format));
   return 0;
  }
 
@@ -4403,10 +4403,10 @@ int snd_hda_query_supported_pcm(struct hda_codec *codec, hda_nid_t nid,
     rates |= rate_bits[i].alsa_bits;
   }
   if (rates == 0) {
-   snd_printk(KERN_ERR "hda_codec: rates == 0 "
-       "(nid=0x%x, val=0x%x, ovrd=%i)\n",
-     nid, val,
-     (wcaps & AC_WCAP_FORMAT_OVRD) ? 1 : 0);
+   codec_err(codec,
+      "rates == 0 (nid=0x%x, val=0x%x, ovrd=%i)\n",
+      nid, val,
+      (wcaps & AC_WCAP_FORMAT_OVRD) ? 1 : 0);
    return -EIO;
   }
   *ratesp = rates;
@@ -4466,12 +4466,11 @@ int snd_hda_query_supported_pcm(struct hda_codec *codec, hda_nid_t nid,
    bps = 8;
   }
   if (formats == 0) {
-   snd_printk(KERN_ERR "hda_codec: formats == 0 "
-       "(nid=0x%x, val=0x%x, ovrd=%i, "
-       "streams=0x%x)\n",
-     nid, val,
-     (wcaps & AC_WCAP_FORMAT_OVRD) ? 1 : 0,
-     streams);
+   codec_err(codec,
+      "formats == 0 (nid=0x%x, val=0x%x, ovrd=%i, streams=0x%x)\n",
+      nid, val,
+      (wcaps & AC_WCAP_FORMAT_OVRD) ? 1 : 0,
+      streams);
    return -EIO;
   }
   if (formatsp)
@@ -4662,7 +4661,7 @@ static int get_empty_pcm_device(struct hda_bus *bus, unsigned int type)
  int i;
 
  if (type >= HDA_PCM_NTYPES) {
-  snd_printk(KERN_WARNING "Invalid PCM type %d\n", type);
+  dev_err(bus->card->dev, "Invalid PCM type %d\n", type);
   return -EINVAL;
  }
 
@@ -4683,10 +4682,11 @@ static int get_empty_pcm_device(struct hda_bus *bus, unsigned int type)
  }
 #endif
 
- snd_printk(KERN_WARNING "Too many %s devices\n",
+ dev_warn(bus->card->dev, "Too many %s devices\n",
   snd_hda_pcm_type_name[type]);
 #ifndef CONFIG_SND_DYNAMIC_MINORS
- snd_printk(KERN_WARNING "Consider building the kernel with CONFIG_SND_DYNAMIC_MINORS=y\n");
+ dev_warn(bus->card->dev,
+   "Consider building the kernel with CONFIG_SND_DYNAMIC_MINORS=y\n");
 #endif
  return -EAGAIN;
 }
@@ -4724,12 +4724,13 @@ int snd_hda_codec_build_pcms(struct hda_codec *codec)
    return 0;
   err = codec->patch_ops.build_pcms(codec);
   if (err < 0) {
-   printk(KERN_ERR "hda_codec: cannot build PCMs"
-          "for #%d (error %d)\n", codec->addr, err);
+   codec_err(codec,
+      "cannot build PCMs for #%d (error %d)\n",
+      codec->addr, err);
    err = snd_hda_codec_reset(codec);
    if (err < 0) {
-    printk(KERN_ERR
-           "hda_codec: cannot revert codec\n");
+    codec_err(codec,
+       "cannot revert codec\n");
     return err;
    }
   }
@@ -4748,9 +4749,9 @@ int snd_hda_codec_build_pcms(struct hda_codec *codec)
    cpcm->device = dev;
    err = snd_hda_attach_pcm(codec, cpcm);
    if (err < 0) {
-    printk(KERN_ERR "hda_codec: cannot attach "
-           "PCM stream %d for codec #%d\n",
-           dev, codec->addr);
+    codec_err(codec,
+       "cannot attach PCM stream %d for codec #%d\n",
+       dev, codec->addr);
     continue; /* no fatal error */
    }
   }
@@ -4819,8 +4820,8 @@ int snd_hda_check_board_config(struct hda_codec *codec,
   for (i = 0; i < num_configs; i++) {
    if (models[i] &&
        !strcmp(codec->modelname, models[i])) {
-    snd_printd(KERN_INFO "hda_codec: model '%s' is "
-        "selected\n", models[i]);
+    codec_info(codec, "model '%s' is selected\n",
+        models[i]);
     return i;
    }
   }
@@ -4842,10 +4843,9 @@ int snd_hda_check_board_config(struct hda_codec *codec,
    sprintf(tmp, "#%d", tbl->value);
    model = tmp;
   }
-  snd_printdd(KERN_INFO "hda_codec: model '%s' is selected "
-       "for config %x:%x (%s)\n",
-       model, tbl->subvendor, tbl->subdevice,
-       (tbl->name ? tbl->name : "Unknown device"));
+  codec_info(codec, "model '%s' is selected for config %x:%x (%s)\n",
+      model, tbl->subvendor, tbl->subdevice,
+      (tbl->name ? tbl->name : "Unknown device"));
 #endif
   return tbl->value;
  }
@@ -4903,10 +4903,9 @@ int snd_hda_check_board_codec_sid_config(struct hda_codec *codec,
    sprintf(tmp, "#%d", tbl->value);
    model = tmp;
   }
-  snd_printdd(KERN_INFO "hda_codec: model '%s' is selected "
-       "for config %x:%x (%s)\n",
-       model, tbl->subvendor, tbl->subdevice,
-       (tbl->name ? tbl->name : "Unknown device"));
+  codec_info(codec, "model '%s' is selected for config %x:%x (%s)\n",
+      model, tbl->subvendor, tbl->subdevice,
+      (tbl->name ? tbl->name : "Unknown device"));
 #endif
   return tbl->value;
  }
diff --git a/sound/pci/hda/hda_eld.c b/sound/pci/hda/hda_eld.c
index 79ca80f..46690a7 100644
--- a/sound/pci/hda/hda_eld.c
+++ b/sound/pci/hda/hda_eld.c
@@ -153,7 +153,7 @@ static unsigned int hdmi_get_eld_data(struct hda_codec *codec, hda_nid_t nid,
  val = snd_hda_codec_read(codec, nid, 0,
      AC_VERB_GET_HDMI_ELDD, byte_index);
 #ifdef BE_PARANOID
- printk(KERN_INFO "HDMI: ELD data byte %d: 0x%x\n", byte_index, val);
+ codec_info(codec, "HDMI: ELD data byte %d: 0x%x\n", byte_index, val);
 #endif
  return val;
 }
@@ -332,11 +332,11 @@ int snd_hdmi_get_eld(struct hda_codec *codec, hda_nid_t nid,
  size = snd_hdmi_get_eld_size(codec, nid);
  if (size == 0) {
   /* wfg: workaround for ASUS P5E-VM HDMI board */
-  snd_printd(KERN_INFO "HDMI: ELD buf size is 0, force 128\n");
+  codec_info(codec, "HDMI: ELD buf size is 0, force 128\n");
   size = 128;
  }
  if (size < ELD_FIXED_BYTES || size > ELD_MAX_SIZE) {
-  snd_printd(KERN_INFO "HDMI: invalid ELD buf size %d\n", size);
+  codec_info(codec, "HDMI: invalid ELD buf size %d\n", size);
   return -ERANGE;
  }
 
@@ -348,8 +348,7 @@ int snd_hdmi_get_eld(struct hda_codec *codec, hda_nid_t nid,
    * Just abort. The caller will repoll after a while.
    */
   if (!(val & AC_ELDD_ELD_VALID)) {
-   snd_printd(KERN_INFO
-      "HDMI: invalid ELD data byte %d\n", i);
+   codec_info(codec, "HDMI: invalid ELD data byte %d\n", i);
    ret = -EINVAL;
    goto error;
   }
@@ -361,7 +360,7 @@ int snd_hdmi_get_eld(struct hda_codec *codec, hda_nid_t nid,
    * correctly writes ELD content before setting ELD_valid bit.
    */
   if (!val && !i) {
-   snd_printdd(KERN_INFO "HDMI: 0 ELD data\n");
+   codec_dbg(codec, "HDMI: 0 ELD data\n");
    ret = -EINVAL;
    goto error;
   }
@@ -681,7 +680,7 @@ int snd_hdmi_get_eld_ati(struct hda_codec *codec, hda_nid_t nid,
  spkalloc = snd_hda_codec_read(codec, nid, 0, ATI_VERB_GET_SPEAKER_ALLOCATION, 0);
 
  if (spkalloc <= 0) {
-  snd_printd(KERN_INFO "HDMI ATI/AMD: no speaker allocation for ELD\n");
+  codec_info(codec, "HDMI ATI/AMD: no speaker allocation for ELD\n");
   return -EINVAL;
  }
 
@@ -722,7 +721,7 @@ int snd_hdmi_get_eld_ati(struct hda_codec *codec, hda_nid_t nid,
   sink_desc_len = snd_hda_codec_read(codec, nid, 0, ATI_VERB_GET_SINK_INFO_DATA, 0);
 
   if (sink_desc_len > ELD_MAX_MNL) {
-   snd_printd(KERN_INFO "HDMI ATI/AMD: Truncating HDMI sink description with length %d\n",
+   codec_info(codec, "HDMI ATI/AMD: Truncating HDMI sink description with length %d\n",
        sink_desc_len);
    sink_desc_len = ELD_MAX_MNL;
   }
@@ -764,7 +763,7 @@ int snd_hdmi_get_eld_ati(struct hda_codec *codec, hda_nid_t nid,
  }
 
  if (pos == ELD_FIXED_BYTES + sink_desc_len) {
-  snd_printd(KERN_INFO "HDMI ATI/AMD: no audio descriptors for ELD\n");
+  codec_info(codec, "HDMI ATI/AMD: no audio descriptors for ELD\n");
   return -EINVAL;
  }
 
diff --git a/sound/pci/hda/hda_generic.c b/sound/pci/hda/hda_generic.c
index bcd9c71..9e0609a 100644
--- a/sound/pci/hda/hda_generic.c
+++ b/sound/pci/hda/hda_generic.c
@@ -346,7 +346,8 @@ static bool is_ctl_associated(struct hda_codec *codec, hda_nid_t nid,
  return is_ctl_used(codec, val, type);
 }
 
-static void print_nid_path(const char *pfx, struct nid_path *path)
+static void print_nid_path(struct hda_codec *codec,
+      const char *pfx, struct nid_path *path)
 {
  char buf[40];
  int i;
@@ -358,7 +359,7 @@ static void print_nid_path(const char *pfx, struct nid_path *path)
   sprintf(tmp, ":%02x", path->path[i]);
   strlcat(buf, tmp, sizeof(buf));
  }
- snd_printdd("%s path: depth=%d %s\n", pfx, path->depth, buf);
+ codec_dbg(codec, "%s path: depth=%d %s\n", pfx, path->depth, buf);
 }
 
 /* called recursively */
@@ -1260,7 +1261,7 @@ static int try_assign_dacs(struct hda_codec *codec, int num_outs,
    dac = dacs[i] = 0;
    badness += bad->no_dac;
   } else {
-   /* print_nid_path("output", path); */
+   /* print_nid_path(codec, "output", path); */
    path->active = true;
    path_idx[i] = snd_hda_get_path_idx(codec, path);
    badness += assign_out_path_ctls(codec, path);
@@ -1387,7 +1388,7 @@ static int fill_multi_ios(struct hda_codec *codec,
     badness++;
     continue;
    }
-   /* print_nid_path("multiio", path); */
+   /* print_nid_path(codec, "multiio", path); */
    spec->multi_io[spec->multi_ios].pin = nid;
    spec->multi_io[spec->multi_ios].dac = dac;
    spec->out_paths[cfg->line_outs + spec->multi_ios] =
@@ -1444,7 +1445,7 @@ static bool map_singles(struct hda_codec *codec, int outs,
   if (path) {
    dacs[i] = dac;
    found = true;
-   /* print_nid_path("output", path); */
+   /* print_nid_path(codec, "output", path); */
    path->active = true;
    path_idx[i] = snd_hda_get_path_idx(codec, path);
   }
@@ -1482,7 +1483,7 @@ static int check_aamix_out_path(struct hda_codec *codec, int path_idx)
  }
  if (!path)
   return 0;
- /* print_nid_path("output-aamix", path); */
+ /* print_nid_path(codec, "output-aamix", path); */
  path->active = false; /* unused as default */
  return snd_hda_get_path_idx(codec, path);
 }
@@ -1699,7 +1700,7 @@ static int fill_and_eval_dacs(struct hda_codec *codec,
 #define DEBUG_BADNESS
 
 #ifdef DEBUG_BADNESS
-#define debug_badness snd_printdd
+#define debug_badness(fmt, args...) codec_dbg(codec, fmt, ##args)
 #else
 #define debug_badness(...)
 #endif
@@ -1712,7 +1713,7 @@ static inline void print_nid_path_idx(struct hda_codec *codec,
 
  path = snd_hda_get_path_from_idx(codec, idx);
  if (path)
-  print_nid_path(pfx, path);
+  print_nid_path(codec, pfx, path);
 }
 
 static void debug_show_configs(struct hda_codec *codec,
@@ -1780,7 +1781,7 @@ static void fill_all_dac_nids(struct hda_codec *codec)
   if (get_wcaps_type(get_wcaps(codec, nid)) != AC_WID_AUD_OUT)
    continue;
   if (spec->num_all_dacs >= ARRAY_SIZE(spec->all_dacs)) {
-   snd_printk(KERN_ERR "hda: Too many DACs!\n");
+   codec_err(codec, "Too many DACs!\n");
    break;
   }
   spec->all_dacs[spec->num_all_dacs++] = nid;
@@ -2429,7 +2430,7 @@ static int create_hp_mic(struct hda_codec *codec)
  spec->hp_mic_pin = nid;
  /* we can't handle auto-mic together with HP-mic */
  spec->suppress_auto_mic = 1;
- snd_printdd("hda-codec: Enable shared I/O jack on NID 0x%x\n", nid);
+ codec_dbg(codec, "Enable shared I/O jack on NID 0x%x\n", nid);
  return 0;
 }
 
@@ -2883,7 +2884,7 @@ static int new_analog_input(struct hda_codec *codec, int input_idx,
  path = snd_hda_add_new_path(codec, pin, mix_nid, 0);
  if (!path)
   return -EINVAL;
- print_nid_path("loopback", path);
+ print_nid_path(codec, "loopback", path);
  spec->loopback_paths[input_idx] = snd_hda_get_path_idx(codec, path);
 
  idx = path->idx[path->depth - 1];
@@ -2911,7 +2912,7 @@ static int new_analog_input(struct hda_codec *codec, int input_idx,
   path = snd_hda_add_new_path(codec, spec->mixer_nid,
          spec->mixer_merge_nid, 0);
   if (path) {
-   print_nid_path("loopback-merge", path);
+   print_nid_path(codec, "loopback-merge", path);
    path->active = true;
    spec->loopback_merge_path =
     snd_hda_get_path_idx(codec, path);
@@ -2990,7 +2991,7 @@ static int check_dyn_adc_switch(struct hda_codec *codec)
    }
   }
 
-  snd_printdd("hda-codec: enabling ADC switching\n");
+  codec_dbg(codec, "enabling ADC switching\n");
   spec->dyn_adc_switch = 1;
  } else if (nums != spec->num_adc_nids) {
   /* shrink the invalid adcs and input paths */
@@ -3014,7 +3015,7 @@ static int check_dyn_adc_switch(struct hda_codec *codec)
 
  if (imux->num_items == 1 ||
      (imux->num_items == 2 && spec->hp_mic)) {
-  snd_printdd("hda-codec: reducing to a single ADC\n");
+  codec_dbg(codec, "reducing to a single ADC\n");
   spec->num_adc_nids = 1; /* reduce to a single ADC */
  }
 
@@ -3045,7 +3046,7 @@ static int parse_capture_source(struct hda_codec *codec, hda_nid_t pin,
   path = snd_hda_add_new_path(codec, pin, adc, anchor);
   if (!path)
    continue;
-  print_nid_path("input", path);
+  print_nid_path(codec, "input", path);
   spec->input_paths[imux_idx][c] =
    snd_hda_get_path_idx(codec, path);
 
@@ -3711,7 +3712,7 @@ static void parse_digital(struct hda_codec *codec)
   path = snd_hda_add_new_path(codec, dig_nid, pin, 0);
   if (!path)
    continue;
-  print_nid_path("digout", path);
+  print_nid_path(codec, "digout", path);
   path->active = true;
   spec->digout_paths[i] = snd_hda_get_path_idx(codec, path);
   set_pin_target(codec, pin, PIN_OUT, false);
@@ -3738,7 +3739,7 @@ static void parse_digital(struct hda_codec *codec)
     continue;
    path = snd_hda_add_new_path(codec, pin, dig_nid, 0);
    if (path) {
-    print_nid_path("digin", path);
+    print_nid_path(codec, "digin", path);
     path->active = true;
     spec->dig_in_nid = dig_nid;
     spec->digin_path = snd_hda_get_path_idx(codec, path);
@@ -4169,8 +4170,7 @@ static int check_auto_mute_availability(struct hda_codec *codec)
   hda_nid_t nid = cfg->hp_pins[i];
   if (!is_jack_detectable(codec, nid))
    continue;
-  snd_printdd("hda-codec: Enable HP auto-muting on NID 0x%x\n",
-       nid);
+  codec_dbg(codec, "Enable HP auto-muting on NID 0x%x\n", nid);
   snd_hda_jack_detect_enable_callback(codec, nid, HDA_GEN_HP_EVENT,
           call_hp_automute);
   spec->detect_hp = 1;
@@ -4182,7 +4182,7 @@ static int check_auto_mute_availability(struct hda_codec *codec)
     hda_nid_t nid = cfg->line_out_pins[i];
     if (!is_jack_detectable(codec, nid))
      continue;
-    snd_printdd("hda-codec: Enable Line-Out auto-muting on NID 0x%x\n", nid);
+    codec_dbg(codec, "Enable Line-Out auto-muting on NID 0x%x\n", nid);
     snd_hda_jack_detect_enable_callback(codec, nid,
             HDA_GEN_FRONT_EVENT,
             call_line_automute);
@@ -4302,7 +4302,7 @@ static int check_auto_mic_availability(struct hda_codec *codec)
  spec->auto_mic = 1;
  spec->num_adc_nids = 1;
  spec->cur_mux[0] = spec->am_entry[0].idx;
- snd_printdd("hda-codec: Enable auto-mic switch on NID 0x%x/0x%x/0x%x\n",
+ codec_dbg(codec, "Enable auto-mic switch on NID 0x%x/0x%x/0x%x\n",
       spec->am_entry[0].pin,
       spec->am_entry[1].pin,
       spec->am_entry[2].pin);
diff --git a/sound/pci/hda/hda_i915.c b/sound/pci/hda/hda_i915.c
index 8f6fa30..b0fe879 100644
--- a/sound/pci/hda/hda_i915.c
+++ b/sound/pci/hda/hda_i915.c
@@ -30,7 +30,7 @@ void hda_display_power(bool enable)
  if (!get_power || !put_power)
   return;
 
- snd_printdd("HDA display power %s \n",
+ pr_debug("HDA display power %s \n",
    enable ? "Enable" : "Disable");
  if (enable)
   get_power();
@@ -44,7 +44,7 @@ int hda_i915_init(void)
 
  get_power = symbol_request(i915_request_power_well);
  if (!get_power) {
-  snd_printk(KERN_WARNING "hda-i915: get_power symbol get fail\n");
+  pr_warn("hda-i915: get_power symbol get fail\n");
   return -ENODEV;
  }
 
@@ -55,7 +55,7 @@ int hda_i915_init(void)
   return -ENODEV;
  }
 
- snd_printd("HDA driver get symbol successfully from i915 module\n");
+ pr_debug("HDA driver get symbol successfully from i915 module\n");
 
  return err;
 }
diff --git a/sound/pci/hda/hda_intel.c b/sound/pci/hda/hda_intel.c
index 5a3d4e2..14b0a49 100644
--- a/sound/pci/hda/hda_intel.c
+++ b/sound/pci/hda/hda_intel.c
@@ -191,12 +191,6 @@ MODULE_SUPPORTED_DEVICE("{{Intel, ICH6},"
     "{ULI, M5461}}");
 MODULE_DESCRIPTION("Intel HDA driver");
 
-#ifdef CONFIG_SND_VERBOSE_PRINTK
-#define SFX /* nop */
-#else
-#define SFX "hda-intel "
-#endif
-
 #if defined(CONFIG_PM) && defined(CONFIG_VGA_SWITCHEROO)
 #if IS_ENABLED(CONFIG_SND_HDA_CODEC_HDMI)
 #define SUPPORT_VGA_SWITCHEROO
@@ -766,7 +760,7 @@ static int azx_alloc_cmd_io(struct azx *chip)
       snd_dma_pci_data(chip->pci),
       PAGE_SIZE, &chip->rb);
  if (err < 0) {
-  snd_printk(KERN_ERR SFX "%s: cannot allocate CORB/RIRB\n", pci_name(chip->pci));
+  dev_err(chip->card->dev, "cannot allocate CORB/RIRB\n");
   return err;
  }
  mark_pages_wc(chip, &chip->rb, true);
@@ -897,10 +891,9 @@ static void azx_update_rirb(struct azx *chip)
   res = le32_to_cpu(chip->rirb.buf[rp]);
   addr = res_ex & 0xf;
   if ((addr >= AZX_MAX_CODECS) || !(chip->codec_mask & (1 << addr))) {
-   snd_printk(KERN_ERR SFX "%s: spurious response %#x:%#x, rp = %d, wp = %d",
-       pci_name(chip->pci),
-       res, res_ex,
-       chip->rirb.rp, wp);
+   dev_err(chip->card->dev, "spurious response %#x:%#x, rp = %d, wp = %d",
+    res, res_ex,
+    chip->rirb.rp, wp);
    snd_BUG();
   }
   else if (res_ex & ICH6_RIRB_EX_UNSOL_EV)
@@ -910,10 +903,9 @@ static void azx_update_rirb(struct azx *chip)
    smp_wmb();
    chip->rirb.cmds[addr]--;
   } else if (printk_ratelimit()) {
-   snd_printk(KERN_ERR SFX "%s: spurious response %#x:%#x, last cmd=%#08x\n",
-       pci_name(chip->pci),
-       res, res_ex,
-       chip->last_cmd[addr]);
+   dev_err(chip->card->dev, "spurious response %#x:%#x, last cmd=%#08x\n",
+    res, res_ex,
+    chip->last_cmd[addr]);
   }
  }
 }
@@ -958,9 +950,9 @@ static unsigned int azx_rirb_get_response(struct hda_bus *bus,
   return -1;
 
  if (!chip->polling_mode && chip->poll_count < 2) {
-  snd_printdd(SFX "%s: azx_get_response timeout, "
-      "polling the codec once: last cmd=0x%08x\n",
-      pci_name(chip->pci), chip->last_cmd[addr]);
+  dev_dbg(chip->card->dev,
+   "azx_get_response timeout, polling the codec once: last cmd=0x%08x\n",
+   chip->last_cmd[addr]);
   do_poll = 1;
   chip->poll_count++;
   goto again;
@@ -968,17 +960,17 @@ static unsigned int azx_rirb_get_response(struct hda_bus *bus,
 
 
  if (!chip->polling_mode) {
-  snd_printk(KERN_WARNING SFX "%s: azx_get_response timeout, "
-      "switching to polling mode: last cmd=0x%08x\n",
-      pci_name(chip->pci), chip->last_cmd[addr]);
+  dev_warn(chip->card->dev,
+    "azx_get_response timeout, switching to polling mode: last cmd=0x%08x\n",
+    chip->last_cmd[addr]);
   chip->polling_mode = 1;
   goto again;
  }
 
  if (chip->msi) {
-  snd_printk(KERN_WARNING SFX "%s: No response from codec, "
-      "disabling MSI: last cmd=0x%08x\n",
-      pci_name(chip->pci), chip->last_cmd[addr]);
+  dev_warn(chip->card->dev,
+    "No response from codec, disabling MSI: last cmd=0x%08x\n",
+    chip->last_cmd[addr]);
   free_irq(chip->irq, chip);
   chip->irq = -1;
   pci_disable_msi(chip->pci);
@@ -1007,9 +999,9 @@ static unsigned int azx_rirb_get_response(struct hda_bus *bus,
   return -1; /* give a chance to retry */
  }
 
- snd_printk(KERN_ERR "hda_intel: azx_get_response timeout, "
-     "switching to single_cmd mode: last cmd=0x%08x\n",
-     chip->last_cmd[addr]);
+ dev_err(chip->card->dev,
+  "azx_get_response timeout, switching to single_cmd mode: last cmd=0x%08x\n",
+  chip->last_cmd[addr]);
  chip->single_cmd = 1;
  bus->response_reset = 0;
  /* release CORB/RIRB */
@@ -1044,8 +1036,8 @@ static int azx_single_wait_for_response(struct azx *chip, unsigned int addr)
   udelay(1);
  }
  if (printk_ratelimit())
-  snd_printd(SFX "%s: get_response timeout: IRS=0x%x\n",
-      pci_name(chip->pci), azx_readw(chip, IRS));
+  dev_dbg(chip->card->dev, "get_response timeout: IRS=0x%x\n",
+   azx_readw(chip, IRS));
  chip->rirb.res[addr] = -1;
  return -EIO;
 }
@@ -1072,8 +1064,9 @@ static int azx_single_send_cmd(struct hda_bus *bus, u32 val)
   udelay(1);
  }
  if (printk_ratelimit())
-  snd_printd(SFX "%s: send_cmd timeout: IRS=0x%x, val=0x%x\n",
-      pci_name(chip->pci), azx_readw(chip, IRS), val);
+  dev_dbg(chip->card->dev,
+   "send_cmd timeout: IRS=0x%x, val=0x%x\n",
+   azx_readw(chip, IRS), val);
  return -EIO;
 }
 
@@ -1185,7 +1178,7 @@ static int azx_reset(struct azx *chip, int full_reset)
       __skip:
  /* check to see if controller is ready */
  if (!azx_readb(chip, GCTL)) {
-  snd_printd(SFX "%s: azx_reset: controller not ready!\n", pci_name(chip->pci));
+  dev_dbg(chip->card->dev, "azx_reset: controller not ready!\n");
   return -EBUSY;
  }
 
@@ -1197,7 +1190,8 @@ static int azx_reset(struct azx *chip, int full_reset)
  /* detect codecs */
  if (!chip->codec_mask) {
   chip->codec_mask = azx_readw(chip, STATESTS);
-  snd_printdd(SFX "%s: codec_mask = 0x%x\n", pci_name(chip->pci), chip->codec_mask);
+  dev_dbg(chip->card->dev, "codec_mask = 0x%x\n",
+   chip->codec_mask);
  }
 
  return 0;
@@ -1341,7 +1335,7 @@ static void azx_init_pci(struct azx *chip)
   * The PCI register TCSEL is defined in the Intel manuals.
   */
  if (!(chip->driver_caps & AZX_DCAPS_NO_TCSEL)) {
-  snd_printdd(SFX "%s: Clearing TCSEL\n", pci_name(chip->pci));
+  dev_dbg(chip->card->dev, "Clearing TCSEL\n");
   update_pci_byte(chip->pci, ICH6_PCIREG_TCSEL, 0x07, 0);
  }
 
@@ -1349,7 +1343,8 @@ static void azx_init_pci(struct azx *chip)
   * we need to enable snoop.
   */
  if (chip->driver_caps & AZX_DCAPS_ATI_SNOOP) {
-  snd_printdd(SFX "%s: Setting ATI snoop: %d\n", pci_name(chip->pci), azx_snoop(chip));
+  dev_dbg(chip->card->dev, "Setting ATI snoop: %d\n",
+   azx_snoop(chip));
   update_pci_byte(chip->pci,
     ATI_SB450_HDAUDIO_MISC_CNTR2_ADDR, 0x07,
     azx_snoop(chip) ? ATI_SB450_HDAUDIO_ENABLE_SNOOP : 0);
@@ -1357,7 +1352,8 @@ static void azx_init_pci(struct azx *chip)
 
  /* For NVIDIA HDA, enable snoop */
  if (chip->driver_caps & AZX_DCAPS_NVIDIA_SNOOP) {
-  snd_printdd(SFX "%s: Setting Nvidia snoop: %d\n", pci_name(chip->pci), azx_snoop(chip));
+  dev_dbg(chip->card->dev, "Setting Nvidia snoop: %d\n",
+   azx_snoop(chip));
   update_pci_byte(chip->pci,
     NVIDIA_HDA_TRANSREG_ADDR,
     0x0f, NVIDIA_HDA_ENABLE_COHBITS);
@@ -1382,9 +1378,9 @@ static void azx_init_pci(struct azx *chip)
    pci_read_config_word(chip->pci,
     INTEL_SCH_HDA_DEVC, &snoop);
   }
-  snd_printdd(SFX "%s: SCH snoop: %s\n",
-    pci_name(chip->pci), (snoop & INTEL_SCH_HDA_DEVC_NOSNOOP)
-    ? "Disabled" : "Enabled");
+  dev_dbg(chip->card->dev, "SCH snoop: %s\n",
+   (snoop & INTEL_SCH_HDA_DEVC_NOSNOOP) ?
+   "Disabled" : "Enabled");
         }
 }
 
@@ -1544,8 +1540,8 @@ static int azx_setup_periods(struct azx *chip,
     pos_align;
   pos_adj = frames_to_bytes(runtime, pos_adj);
   if (pos_adj >= period_bytes) {
-   snd_printk(KERN_WARNING SFX "%s: Too big adjustment %d\n",
-       pci_name(chip->pci), bdl_pos_adj[chip->dev_index]);
+   dev_warn(chip->card->dev,"Too big adjustment %d\n",
+     bdl_pos_adj[chip->dev_index]);
    pos_adj = 0;
   } else {
    ofs = setup_bdle(chip, snd_pcm_get_dma_buf(substream),
@@ -1572,8 +1568,8 @@ static int azx_setup_periods(struct azx *chip,
  return 0;
 
  error:
- snd_printk(KERN_ERR SFX "%s: Too many BDL entries: buffer=%d, period=%d\n",
-     pci_name(chip->pci), azx_dev->bufsize, period_bytes);
+ dev_err(chip->card->dev, "Too many BDL entries: buffer=%d, period=%d\n",
+  azx_dev->bufsize, period_bytes);
  return -EINVAL;
 }
 
@@ -1670,7 +1666,7 @@ static int probe_codec(struct azx *chip, int addr)
  mutex_unlock(&chip->bus->cmd_mutex);
  if (res == -1)
   return -EIO;
- snd_printdd(SFX "%s: codec #%d probed OK\n", pci_name(chip->pci), addr);
+ dev_dbg(chip->card->dev, "codec #%d probed OK\n", addr);
  return 0;
 }
 
@@ -1708,8 +1704,8 @@ static int get_jackpoll_interval(struct azx *chip)
  else
   j = msecs_to_jiffies(i);
  if (j == 0)
-  snd_printk(KERN_WARNING SFX
-      "jackpoll_ms value out of range: %d\n", i);
+  dev_warn(chip->card->dev,
+    "jackpoll_ms value out of range: %d\n", i);
  return j;
 }
 
@@ -1752,7 +1748,7 @@ static int azx_codec_create(struct azx *chip, const char *model)
   return err;
 
  if (chip->driver_caps & AZX_DCAPS_RIRB_DELAY) {
-  snd_printd(SFX "%s: Enable delay in RIRB handling\n", pci_name(chip->pci));
+  dev_dbg(chip->card->dev, "Enable delay in RIRB handling\n");
   chip->bus->needs_damn_long_delay = 1;
  }
 
@@ -1768,9 +1764,8 @@ static int azx_codec_create(struct azx *chip, const char *model)
     /* Some BIOSen give you wrong codec addresses
      * that don't exist
      */
-    snd_printk(KERN_WARNING SFX
-        "%s: Codec #%d probe error; "
-        "disabling it...\n", pci_name(chip->pci), c);
+    dev_warn(chip->card->dev,
+      "Codec #%d probe error; disabling it...\n", c);
     chip->codec_mask &= ~(1 << c);
     /* More badly, accessing to a non-existing
      * codec often screws up the controller chip,
@@ -1790,8 +1785,7 @@ static int azx_codec_create(struct azx *chip, const char *model)
   * access works around the stall.  Grrr...
   */
  if (chip->driver_caps & AZX_DCAPS_SYNC_WRITE) {
-  snd_printd(SFX "%s: Enable sync_write for stable communication\n",
-   pci_name(chip->pci));
+  dev_dbg(chip->card->dev, "Enable sync_write for stable communication\n");
   chip->bus->sync_write = 1;
   chip->bus->allow_bus_reset = 1;
  }
@@ -1809,7 +1803,7 @@ static int azx_codec_create(struct azx *chip, const char *model)
   }
  }
  if (!codecs) {
-  snd_printk(KERN_ERR SFX "%s: no codecs initialized\n", pci_name(chip->pci));
+  dev_err(chip->card->dev, "no codecs initialized\n");
   return -ENXIO;
  }
  return 0;
@@ -2166,9 +2160,9 @@ static int azx_pcm_prepare(struct snd_pcm_substream *substream)
       hinfo->maxbps,
       ctls);
  if (!format_val) {
-  snd_printk(KERN_ERR SFX
-      "%s: invalid format_val, rate=%d, ch=%d, format=%d\n",
-      pci_name(chip->pci), runtime->rate, runtime->channels, runtime->format);
+  dev_err(chip->card->dev,
+   "invalid format_val, rate=%d, ch=%d, format=%d\n",
+   runtime->rate, runtime->channels, runtime->format);
   err = -EINVAL;
   goto unlock;
  }
@@ -2176,8 +2170,8 @@ static int azx_pcm_prepare(struct snd_pcm_substream *substream)
  bufsize = snd_pcm_lib_buffer_bytes(substream);
  period_bytes = snd_pcm_lib_period_bytes(substream);
 
- snd_printdd(SFX "%s: azx_pcm_prepare: bufsize=0x%x, format=0x%x\n",
-      pci_name(chip->pci), bufsize, format_val);
+ dev_dbg(chip->card->dev, "azx_pcm_prepare: bufsize=0x%x, format=0x%x\n",
+  bufsize, format_val);
 
  if (bufsize != azx_dev->bufsize ||
      period_bytes != azx_dev->period_bytes ||
@@ -2430,9 +2424,8 @@ static unsigned int azx_get_position(struct azx *chip,
   pos = le32_to_cpu(*azx_dev->posbuf);
   if (with_check && chip->position_fix[stream] == POS_FIX_AUTO) {
    if (!pos || pos == (u32)-1) {
-    printk(KERN_WARNING
-           "hda-intel: Invalid position buffer, "
-           "using LPIB read method instead.\n");
+    dev_info(chip->card->dev,
+      "Invalid position buffer, using LPIB read method instead.\n");
     chip->position_fix[stream] = POS_FIX_LPIB;
     pos = azx_sd_readl(azx_dev, SD_LPIB);
    } else
@@ -2460,10 +2453,9 @@ static unsigned int azx_get_position(struct azx *chip,
     delay += azx_dev->bufsize;
   }
   if (delay >= azx_dev->period_bytes) {
-   snd_printk(KERN_WARNING SFX
-       "%s: Unstable LPIB (%d >= %d); "
-       "disabling LPIB delay counting\n",
-       pci_name(chip->pci), delay, azx_dev->period_bytes);
+   dev_info(chip->card->dev,
+     "Unstable LPIB (%d >= %d); disabling LPIB delay counting\n",
+     delay, azx_dev->period_bytes);
    delay = 0;
    chip->driver_caps &= ~AZX_DCAPS_COUNT_LPIB_DELAY;
   }
@@ -2530,10 +2522,9 @@ static void azx_irq_pending_work(struct work_struct *work)
  int i, pending, ok;
 
  if (!chip->irq_pending_warned) {
-  printk(KERN_WARNING
-         "hda-intel: IRQ timing workaround is activated "
-         "for card #%d. Suggest a bigger bdl_pos_adj.\n",
-         chip->card->number);
+  dev_info(chip->card->dev,
+    "IRQ timing workaround is activated for card #%d. Suggest a bigger bdl_pos_adj.\n",
+    chip->card->number);
   chip->irq_pending_warned = 1;
  }
 
@@ -2627,8 +2618,8 @@ azx_attach_pcm_stream(struct hda_bus *bus, struct hda_codec *codec,
 
  list_for_each_entry(apcm, &chip->pcm_list, list) {
   if (apcm->pcm->device == pcm_dev) {
-   snd_printk(KERN_ERR SFX "%s: PCM %d already exists\n",
-       pci_name(chip->pci), pcm_dev);
+   dev_err(chip->card->dev, "PCM %d already exists\n",
+    pcm_dev);
    return -EBUSY;
   }
  }
@@ -2708,8 +2699,9 @@ static int azx_acquire_irq(struct azx *chip, int do_disconnect)
  if (request_irq(chip->pci->irq, azx_interrupt,
    chip->msi ? 0 : IRQF_SHARED,
    KBUILD_MODNAME, chip)) {
-  printk(KERN_ERR "hda-intel: unable to grab IRQ %d, "
-         "disabling device\n", chip->pci->irq);
+  dev_err(chip->card->dev,
+   "unable to grab IRQ %d, disabling device\n",
+   chip->pci->irq);
   if (do_disconnect)
    snd_card_disconnect(chip->card);
   return -1;
@@ -2966,8 +2958,8 @@ static int azx_resume(struct device *dev)
  pci_set_power_state(pci, PCI_D0);
  pci_restore_state(pci);
  if (pci_enable_device(pci) < 0) {
-  printk(KERN_ERR "hda-intel: pci_enable_device failed, "
-         "disabling device\n");
+  dev_err(chip->card->dev,
+   "pci_enable_device failed, disabling device\n");
   snd_card_disconnect(card);
   return -EIO;
  }
@@ -3124,20 +3116,16 @@ static void azx_vs_set_state(struct pci_dev *pci,
  if (!chip->bus) {
   chip->disabled = disabled;
   if (!disabled) {
-   snd_printk(KERN_INFO SFX
-       "%s: Start delayed initialization\n",
-       pci_name(chip->pci));
+   dev_info(chip->card->dev,
+     "Start delayed initialization\n");
    if (azx_probe_continue(chip) < 0) {
-    snd_printk(KERN_ERR SFX
-        "%s: initialization error\n",
-        pci_name(chip->pci));
+    dev_err(chip->card->dev, "initialization error\n");
     chip->init_failed = true;
    }
   }
  } else {
-  snd_printk(KERN_INFO SFX
-      "%s: %s via VGA-switcheroo\n", pci_name(chip->pci),
-      disabled ? "Disabling" : "Enabling");
+  dev_info(chip->card->dev, "%s via VGA-switcheroo\n",
+    disabled ? "Disabling" : "Enabling");
   if (disabled) {
    pm_runtime_put_sync_suspend(&pci->dev);
    azx_suspend(&pci->dev);
@@ -3147,8 +3135,8 @@ static void azx_vs_set_state(struct pci_dev *pci,
    pci->current_state = PCI_D3cold;
    chip->disabled = true;
    if (snd_hda_lock_devices(chip->bus))
-    snd_printk(KERN_WARNING SFX "%s: Cannot lock devices!\n",
-        pci_name(chip->pci));
+    dev_warn(chip->card->dev,
+      "Cannot lock devices!\n");
   } else {
    snd_hda_unlock_devices(chip->bus);
    pm_runtime_get_noresume(&pci->dev);
@@ -3178,9 +3166,8 @@ static void init_vga_switcheroo(struct azx *chip)
 {
  struct pci_dev *p = get_bound_vga(chip->pci);
  if (p) {
-  snd_printk(KERN_INFO SFX
-      "%s: Handle VGA-switcheroo audio client\n",
-      pci_name(chip->pci));
+  dev_info(chip->card->dev,
+    "Handle VGA-switcheroo audio client\n");
   chip->use_vga_switcheroo = 1;
   pci_dev_put(p);
  }
@@ -3371,20 +3358,19 @@ static int check_position_fix(struct azx *chip, int fix)
 
  q = snd_pci_quirk_lookup(chip->pci, position_fix_list);
  if (q) {
-  printk(KERN_INFO
-         "hda_intel: position_fix set to %d "
-         "for device %04x:%04x\n",
-         q->value, q->subvendor, q->subdevice);
+  dev_info(chip->card->dev,
+    "position_fix set to %d for device %04x:%04x\n",
+    q->value, q->subvendor, q->subdevice);
   return q->value;
  }
 
  /* Check VIA/ATI HD Audio Controller exist */
  if (chip->driver_caps & AZX_DCAPS_POSFIX_VIA) {
-  snd_printd(SFX "%s: Using VIACOMBO position fix\n", pci_name(chip->pci));
+  dev_dbg(chip->card->dev, "Using VIACOMBO position fix\n");
   return POS_FIX_VIACOMBO;
  }
  if (chip->driver_caps & AZX_DCAPS_POSFIX_LPIB) {
-  snd_printd(SFX "%s: Using LPIB position fix\n", pci_name(chip->pci));
+  dev_dbg(chip->card->dev, "Using LPIB position fix\n");
   return POS_FIX_LPIB;
  }
  return POS_FIX_AUTO;
@@ -3422,10 +3408,9 @@ static void check_probe_mask(struct azx *chip, int dev)
  if (chip->codec_probe_mask == -1) {
   q = snd_pci_quirk_lookup(chip->pci, probe_mask_list);
   if (q) {
-   printk(KERN_INFO
-          "hda_intel: probe_mask set to 0x%x "
-          "for device %04x:%04x\n",
-          q->value, q->subvendor, q->subdevice);
+   dev_info(chip->card->dev,
+     "probe_mask set to 0x%x for device %04x:%04x\n",
+     q->value, q->subvendor, q->subdevice);
    chip->codec_probe_mask = q->value;
   }
  }
@@ -3434,8 +3419,8 @@ static void check_probe_mask(struct azx *chip, int dev)
  if (chip->codec_probe_mask != -1 &&
      (chip->codec_probe_mask & AZX_FORCE_CODEC_MASK)) {
   chip->codec_mask = chip->codec_probe_mask & 0xff;
-  printk(KERN_INFO "hda_intel: codec_mask forced to 0x%x\n",
-         chip->codec_mask);
+  dev_info(chip->card->dev, "codec_mask forced to 0x%x\n",
+    chip->codec_mask);
  }
 }
 
@@ -3467,16 +3452,16 @@ static void check_msi(struct azx *chip)
  chip->msi = 1; /* enable MSI as default */
  q = snd_pci_quirk_lookup(chip->pci, msi_black_list);
  if (q) {
-  printk(KERN_INFO
-         "hda_intel: msi for device %04x:%04x set to %d\n",
-         q->subvendor, q->subdevice, q->value);
+  dev_info(chip->card->dev,
+    "msi for device %04x:%04x set to %d\n",
+    q->subvendor, q->subdevice, q->value);
   chip->msi = q->value;
   return;
  }
 
  /* NVidia chipsets seem to cause troubles with MSI */
  if (chip->driver_caps & AZX_DCAPS_NO_MSI) {
-  printk(KERN_INFO "hda_intel: Disabling MSI\n");
+  dev_info(chip->card->dev, "Disabling MSI\n");
   chip->msi = 0;
  }
 }
@@ -3508,8 +3493,8 @@ static void azx_check_snoop_available(struct azx *chip)
  }
 
  if (snoop != chip->snoop) {
-  snd_printk(KERN_INFO SFX "%s: Force to %s mode\n",
-      pci_name(chip->pci), snoop ? "snoop" : "non-snoop");
+  dev_info(chip->card->dev, "Force to %s mode\n",
+    snoop ? "snoop" : "non-snoop");
   chip->snoop = snoop;
  }
 }
@@ -3540,7 +3525,7 @@ static int azx_create(struct snd_card *card, struct pci_dev *pci,
 
  chip = kzalloc(sizeof(*chip), GFP_KERNEL);
  if (!chip) {
-  snd_printk(KERN_ERR SFX "%s: Cannot allocate chip\n", pci_name(pci));
+  dev_err(card->dev, "Cannot allocate chip\n");
   pci_disable_device(pci);
   return -ENOMEM;
  }
@@ -3588,8 +3573,7 @@ static int azx_create(struct snd_card *card, struct pci_dev *pci,
 
  err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &ops);
  if (err < 0) {
-  snd_printk(KERN_ERR SFX "%s: Error creating device [card]!\n",
-     pci_name(chip->pci));
+  dev_err(card->dev, "Error creating device [card]!\n");
   azx_free(chip);
   return err;
  }
@@ -3628,7 +3612,7 @@ static int azx_first_init(struct azx *chip)
  chip->addr = pci_resource_start(pci, 0);
  chip->remap_addr = pci_ioremap_bar(pci, 0);
  if (chip->remap_addr == NULL) {
-  snd_printk(KERN_ERR SFX "%s: ioremap error\n", pci_name(chip->pci));
+  dev_err(card->dev, "ioremap error\n");
   return -ENXIO;
  }
 
@@ -3643,7 +3627,7 @@ static int azx_first_init(struct azx *chip)
  synchronize_irq(chip->irq);
 
  gcap = azx_readw(chip, GCAP);
- snd_printdd(SFX "%s: chipset global capabilities = 0x%x\n", pci_name(chip->pci), gcap);
+ dev_dbg(card->dev, "chipset global capabilities = 0x%x\n", gcap);
 
  /* disable SB600 64bit support for safety */
  if (chip->pci->vendor == PCI_VENDOR_ID_ATI) {
@@ -3660,7 +3644,7 @@ static int azx_first_init(struct azx *chip)
 
  /* disable 64bit DMA address on some devices */
  if (chip->driver_caps & AZX_DCAPS_NO_64BIT) {
-  snd_printd(SFX "%s: Disabling 64bit DMA\n", pci_name(chip->pci));
+  dev_dbg(card->dev, "Disabling 64bit DMA\n");
   gcap &= ~ICH6_GCAP_64OK;
  }
 
@@ -3715,7 +3699,7 @@ static int azx_first_init(struct azx *chip)
  chip->azx_dev = kcalloc(chip->num_streams, sizeof(*chip->azx_dev),
     GFP_KERNEL);
  if (!chip->azx_dev) {
-  snd_printk(KERN_ERR SFX "%s: cannot malloc azx_dev\n", pci_name(chip->pci));
+  dev_err(card->dev, "cannot malloc azx_dev\n");
   return -ENOMEM;
  }
 
@@ -3726,7 +3710,7 @@ static int azx_first_init(struct azx *chip)
        snd_dma_pci_data(chip->pci),
        BDL_SIZE, &chip->azx_dev[i].bdl);
   if (err < 0) {
-   snd_printk(KERN_ERR SFX "%s: cannot allocate BDL\n", pci_name(chip->pci));
+   dev_err(card->dev, "cannot allocate BDL\n");
    return -ENOMEM;
   }
   mark_pages_wc(chip, &chip->azx_dev[i].bdl, true);
@@ -3736,7 +3720,7 @@ static int azx_first_init(struct azx *chip)
       snd_dma_pci_data(chip->pci),
       chip->num_streams * 8, &chip->posbuf);
  if (err < 0) {
-  snd_printk(KERN_ERR SFX "%s: cannot allocate posbuf\n", pci_name(chip->pci));
+  dev_err(card->dev, "cannot allocate posbuf\n");
   return -ENOMEM;
  }
  mark_pages_wc(chip, &chip->posbuf, true);
@@ -3754,7 +3738,7 @@ static int azx_first_init(struct azx *chip)
 
  /* codec detection */
  if (!chip->codec_mask) {
-  snd_printk(KERN_ERR SFX "%s: no codecs found!\n", pci_name(chip->pci));
+  dev_err(card->dev, "no codecs found!\n");
   return -ENODEV;
  }
 
@@ -3790,8 +3774,7 @@ static void azx_firmware_cb(const struct firmware *fw, void *context)
  struct pci_dev *pci = chip->pci;
 
  if (!fw) {
-  snd_printk(KERN_ERR SFX "%s: Cannot load firmware, aborting\n",
-      pci_name(chip->pci));
+  dev_err(card->dev, "Cannot load firmware, aborting\n");
   goto error;
  }
 
@@ -3828,7 +3811,7 @@ static int azx_probe(struct pci_dev *pci,
  err = snd_card_new(&pci->dev, index[dev], id[dev], THIS_MODULE,
       0, &card);
  if (err < 0) {
-  snd_printk(KERN_ERR "hda-intel: Error creating card!\n");
+  dev_err(&pci->dev, "Error creating card!\n");
   return err;
  }
 
@@ -3841,15 +3824,13 @@ static int azx_probe(struct pci_dev *pci,
 
  err = register_vga_switcheroo(chip);
  if (err < 0) {
-  snd_printk(KERN_ERR SFX
-      "%s: Error registering VGA-switcheroo client\n", pci_name(pci));
+  dev_err(card->dev, "Error registering VGA-switcheroo client\n");
   goto out_free;
  }
 
  if (check_hdmi_disabled(pci)) {
-  snd_printk(KERN_INFO SFX "%s: VGA controller is disabled\n",
-      pci_name(pci));
-  snd_printk(KERN_INFO SFX "%s: Delaying initialization\n", pci_name(pci));
+  dev_info(card->dev, "VGA controller is disabled\n");
+  dev_info(card->dev, "Delaying initialization\n");
   chip->disabled = true;
  }
 
@@ -3857,8 +3838,8 @@ static int azx_probe(struct pci_dev *pci,
 
 #ifdef CONFIG_SND_HDA_PATCH_LOADER
  if (patch[dev] && *patch[dev]) {
-  snd_printk(KERN_ERR SFX "%s: Applying patch firmware '%s'\n",
-      pci_name(pci), patch[dev]);
+  dev_info(card->dev, "Applying patch firmware '%s'\n",
+    patch[dev]);
   err = request_firmware_nowait(THIS_MODULE, true, patch[dev],
            &pci->dev, GFP_KERNEL, card,
            azx_firmware_cb);
@@ -3870,7 +3851,7 @@ static int azx_probe(struct pci_dev *pci,
 
 #ifndef CONFIG_SND_HDA_I915
  if (chip->driver_caps & AZX_DCAPS_I915_POWERWELL)
-  snd_printk(KERN_ERR SFX "Haswell must build in CONFIG_SND_HDA_I915\n");
+  dev_err(card->dev, "Haswell must build in CONFIG_SND_HDA_I915\n");
 #endif
 
  if (schedule_probe)
@@ -3897,7 +3878,8 @@ static int azx_probe_continue(struct azx *chip)
 #ifdef CONFIG_SND_HDA_I915
   err = hda_i915_init();
   if (err < 0) {
-   snd_printk(KERN_ERR SFX "Error request power-well from i915\n");
+   dev_err(chip->card->dev,
+    "Error request power-well from i915\n");
    goto out_free;
   }
 #endif
diff --git a/sound/pci/hda/hda_local.h b/sound/pci/hda/hda_local.h
index a489243..e51d155 100644
--- a/sound/pci/hda/hda_local.h
+++ b/sound/pci/hda/hda_local.h
@@ -758,4 +758,11 @@ void snd_hdmi_write_eld_info(struct hdmi_eld *eld,
 #define SND_PRINT_CHANNEL_ALLOCATION_ADVISED_BUFSIZE 80
 void snd_print_channel_allocation(int spk_alloc, char *buf, int buflen);
 
+/*
+ */
+#define codec_err(codec, fmt, args...) dev_err(&(codec)->dev, fmt, ##args)
+#define codec_warn(codec, fmt, args...) dev_warn(&(codec)->dev, fmt, ##args)
+#define codec_info(codec, fmt, args...) dev_info(&(codec)->dev, fmt, ##args)
+#define codec_dbg(codec, fmt, args...) dev_dbg(&(codec)->dev, fmt, ##args)
+
 #endif /* __SOUND_HDA_LOCAL_H */
diff --git a/sound/pci/hda/hda_sysfs.c b/sound/pci/hda/hda_sysfs.c
index da0f514..e207909 100644
--- a/sound/pci/hda/hda_sysfs.c
+++ b/sound/pci/hda/hda_sysfs.c
@@ -119,7 +119,7 @@ static int clear_codec(struct hda_codec *codec)
 
  err = snd_hda_codec_reset(codec);
  if (err < 0) {
-  snd_printk(KERN_ERR "The codec is being used, can't free.\n");
+  codec_err(codec, "The codec is being used, can't free.\n");
   return err;
  }
  snd_hda_sysfs_clear(codec);
@@ -131,10 +131,10 @@ static int reconfig_codec(struct hda_codec *codec)
  int err;
 
  snd_hda_power_up(codec);
- snd_printk(KERN_INFO "hda-codec: reconfiguring\n");
+ codec_info(codec, "hda-codec: reconfiguring\n");
  err = snd_hda_codec_reset(codec);
  if (err < 0) {
-  snd_printk(KERN_ERR
+  codec_err(codec,
       "The codec is being used, can't reconfigure.\n");
   goto error;
  }
diff --git a/sound/pci/hda/patch_ca0132.c b/sound/pci/hda/patch_ca0132.c
index c7ea40f..092f2bd 100644
--- a/sound/pci/hda/patch_ca0132.c
+++ b/sound/pci/hda/patch_ca0132.c
@@ -867,7 +867,7 @@ static int chipio_write_data_multiple(struct hda_codec *codec,
  int status = 0;
 
  if (data == NULL) {
-  snd_printdd(KERN_ERR "chipio_write_data null ptr\n");
+  codec_dbg(codec, "chipio_write_data null ptr\n");
   return -EINVAL;
  }
 
@@ -1406,12 +1406,12 @@ static int dspio_scp(struct hda_codec *codec,
   return -EINVAL;
 
  if (dir == SCP_GET && reply == NULL) {
-  snd_printdd(KERN_ERR "dspio_scp get but has no buffer\n");
+  codec_dbg(codec, "dspio_scp get but has no buffer\n");
   return -EINVAL;
  }
 
  if (reply != NULL && (reply_len == NULL || (*reply_len == 0))) {
-  snd_printdd(KERN_ERR "dspio_scp bad resp buf len parms\n");
+  codec_dbg(codec, "dspio_scp bad resp buf len parms\n");
   return -EINVAL;
  }
 
@@ -1429,7 +1429,7 @@ static int dspio_scp(struct hda_codec *codec,
      sizeof(scp_reply), &ret_bytes);
 
  if (status < 0) {
-  snd_printdd(KERN_ERR "dspio_scp: send scp msg failed\n");
+  codec_dbg(codec, "dspio_scp: send scp msg failed\n");
   return status;
  }
 
@@ -1448,17 +1448,17 @@ static int dspio_scp(struct hda_codec *codec,
      / sizeof(unsigned int);
 
   if (*reply_len < ret_size*sizeof(unsigned int)) {
-   snd_printdd(KERN_ERR "reply too long for buf\n");
+   codec_dbg(codec, "reply too long for buf\n");
    return -EINVAL;
   } else if (ret_size != reply_data_size) {
-   snd_printdd(KERN_ERR "RetLen and HdrLen .NE.\n");
+   codec_dbg(codec, "RetLen and HdrLen .NE.\n");
    return -EINVAL;
   } else {
    *reply_len = ret_size*sizeof(unsigned int);
    memcpy(reply, scp_reply.data, *reply_len);
   }
  } else {
-  snd_printdd(KERN_ERR "reply ill-formed or errflag set\n");
+  codec_dbg(codec, "reply ill-formed or errflag set\n");
   return -EIO;
  }
 
@@ -1488,22 +1488,22 @@ static int dspio_alloc_dma_chan(struct hda_codec *codec, unsigned int *dma_chan)
  int status = 0;
  unsigned int size = sizeof(dma_chan);
 
- snd_printdd(KERN_INFO "     dspio_alloc_dma_chan() -- begin\n");
+ codec_dbg(codec, "     dspio_alloc_dma_chan() -- begin\n");
  status = dspio_scp(codec, MASTERCONTROL, MASTERCONTROL_ALLOC_DMA_CHAN,
    SCP_GET, NULL, 0, dma_chan, &size);
 
  if (status < 0) {
-  snd_printdd(KERN_INFO "dspio_alloc_dma_chan: SCP Failed\n");
+  codec_dbg(codec, "dspio_alloc_dma_chan: SCP Failed\n");
   return status;
  }
 
  if ((*dma_chan + 1) == 0) {
-  snd_printdd(KERN_INFO "no free dma channels to allocate\n");
+  codec_dbg(codec, "no free dma channels to allocate\n");
   return -EBUSY;
  }
 
- snd_printdd("dspio_alloc_dma_chan: chan=%d\n", *dma_chan);
- snd_printdd(KERN_INFO "     dspio_alloc_dma_chan() -- complete\n");
+ codec_dbg(codec, "dspio_alloc_dma_chan: chan=%d\n", *dma_chan);
+ codec_dbg(codec, "     dspio_alloc_dma_chan() -- complete\n");
 
  return status;
 }
@@ -1516,18 +1516,18 @@ static int dspio_free_dma_chan(struct hda_codec *codec, unsigned int dma_chan)
  int status = 0;
  unsigned int dummy = 0;
 
- snd_printdd(KERN_INFO "     dspio_free_dma_chan() -- begin\n");
- snd_printdd("dspio_free_dma_chan: chan=%d\n", dma_chan);
+ codec_dbg(codec, "     dspio_free_dma_chan() -- begin\n");
+ codec_dbg(codec, "dspio_free_dma_chan: chan=%d\n", dma_chan);
 
  status = dspio_scp(codec, MASTERCONTROL, MASTERCONTROL_ALLOC_DMA_CHAN,
       SCP_SET, &dma_chan, sizeof(dma_chan), NULL, &dummy);
 
  if (status < 0) {
-  snd_printdd(KERN_INFO "dspio_free_dma_chan: SCP Failed\n");
+  codec_dbg(codec, "dspio_free_dma_chan: SCP Failed\n");
   return status;
  }
 
- snd_printdd(KERN_INFO "     dspio_free_dma_chan() -- complete\n");
+ codec_dbg(codec, "     dspio_free_dma_chan() -- complete\n");
 
  return status;
 }
@@ -1575,14 +1575,14 @@ static int dsp_reset(struct hda_codec *codec)
  unsigned int res;
  int retry = 20;
 
- snd_printdd("dsp_reset\n");
+ codec_dbg(codec, "dsp_reset\n");
  do {
   res = dspio_send(codec, VENDOR_DSPIO_DSP_INIT, 0);
   retry--;
  } while (res == -EIO && retry);
 
  if (!retry) {
-  snd_printdd("dsp_reset timeout\n");
+  codec_dbg(codec, "dsp_reset timeout\n");
   return -EIO;
  }
 
@@ -1635,39 +1635,39 @@ static int dsp_dma_setup_common(struct hda_codec *codec,
  unsigned int active;
  bool code, yram;
 
- snd_printdd(KERN_INFO "-- dsp_dma_setup_common() -- Begin ---------\n");
+ codec_dbg(codec, "-- dsp_dma_setup_common() -- Begin ---------\n");
 
  if (dma_chan >= DSPDMAC_DMA_CFG_CHANNEL_COUNT) {
-  snd_printdd(KERN_ERR "dma chan num invalid\n");
+  codec_dbg(codec, "dma chan num invalid\n");
   return -EINVAL;
  }
 
  if (dsp_is_dma_active(codec, dma_chan)) {
-  snd_printdd(KERN_ERR "dma already active\n");
+  codec_dbg(codec, "dma already active\n");
   return -EBUSY;
  }
 
  dsp_addx = dsp_chip_to_dsp_addx(chip_addx, &code, &yram);
 
  if (dsp_addx == INVALID_CHIP_ADDRESS) {
-  snd_printdd(KERN_ERR "invalid chip addr\n");
+  codec_dbg(codec, "invalid chip addr\n");
   return -ENXIO;
  }
 
  chnl_prop = DSPDMAC_CHNLPROP_AC_MASK;
  active = 0;
 
- snd_printdd(KERN_INFO "   dsp_dma_setup_common()    start reg pgm\n");
+ codec_dbg(codec, "   dsp_dma_setup_common()    start reg pgm\n");
 
  if (ovly) {
   status = chipio_read(codec, DSPDMAC_CHNLPROP_INST_OFFSET,
          &chnl_prop);
 
   if (status < 0) {
-   snd_printdd(KERN_ERR "read CHNLPROP Reg fail\n");
+   codec_dbg(codec, "read CHNLPROP Reg fail\n");
    return status;
   }
-  snd_printdd(KERN_INFO "dsp_dma_setup_common() Read CHNLPROP\n");
+  codec_dbg(codec, "dsp_dma_setup_common() Read CHNLPROP\n");
  }
 
  if (!code)
@@ -1679,20 +1679,20 @@ static int dsp_dma_setup_common(struct hda_codec *codec,
 
  status = chipio_write(codec, DSPDMAC_CHNLPROP_INST_OFFSET, chnl_prop);
  if (status < 0) {
-  snd_printdd(KERN_ERR "write CHNLPROP Reg fail\n");
+  codec_dbg(codec, "write CHNLPROP Reg fail\n");
   return status;
  }
- snd_printdd(KERN_INFO "   dsp_dma_setup_common()    Write CHNLPROP\n");
+ codec_dbg(codec, "   dsp_dma_setup_common()    Write CHNLPROP\n");
 
  if (ovly) {
   status = chipio_read(codec, DSPDMAC_ACTIVE_INST_OFFSET,
          &active);
 
   if (status < 0) {
-   snd_printdd(KERN_ERR "read ACTIVE Reg fail\n");
+   codec_dbg(codec, "read ACTIVE Reg fail\n");
    return status;
   }
-  snd_printdd(KERN_INFO "dsp_dma_setup_common() Read ACTIVE\n");
+  codec_dbg(codec, "dsp_dma_setup_common() Read ACTIVE\n");
  }
 
  active &= (~(1 << (DSPDMAC_ACTIVE_AAR_LOBIT + dma_chan))) &
@@ -1700,35 +1700,35 @@ static int dsp_dma_setup_common(struct hda_codec *codec,
 
  status = chipio_write(codec, DSPDMAC_ACTIVE_INST_OFFSET, active);
  if (status < 0) {
-  snd_printdd(KERN_ERR "write ACTIVE Reg fail\n");
+  codec_dbg(codec, "write ACTIVE Reg fail\n");
   return status;
  }
 
- snd_printdd(KERN_INFO "   dsp_dma_setup_common()    Write ACTIVE\n");
+ codec_dbg(codec, "   dsp_dma_setup_common()    Write ACTIVE\n");
 
  status = chipio_write(codec, DSPDMAC_AUDCHSEL_INST_OFFSET(dma_chan),
          port_map_mask);
  if (status < 0) {
-  snd_printdd(KERN_ERR "write AUDCHSEL Reg fail\n");
+  codec_dbg(codec, "write AUDCHSEL Reg fail\n");
   return status;
  }
- snd_printdd(KERN_INFO "   dsp_dma_setup_common()    Write AUDCHSEL\n");
+ codec_dbg(codec, "   dsp_dma_setup_common()    Write AUDCHSEL\n");
 
  status = chipio_write(codec, DSPDMAC_IRQCNT_INST_OFFSET(dma_chan),
    DSPDMAC_IRQCNT_BICNT_MASK | DSPDMAC_IRQCNT_CICNT_MASK);
  if (status < 0) {
-  snd_printdd(KERN_ERR "write IRQCNT Reg fail\n");
+  codec_dbg(codec, "write IRQCNT Reg fail\n");
   return status;
  }
- snd_printdd(KERN_INFO "   dsp_dma_setup_common()    Write IRQCNT\n");
+ codec_dbg(codec, "   dsp_dma_setup_common()    Write IRQCNT\n");
 
- snd_printdd(
+ codec_dbg(codec,
      "ChipA=0x%x,DspA=0x%x,dmaCh=%u, "
      "CHSEL=0x%x,CHPROP=0x%x,Active=0x%x\n",
      chip_addx, dsp_addx, dma_chan,
      port_map_mask, chnl_prop, active);
 
- snd_printdd(KERN_INFO "-- dsp_dma_setup_common() -- Complete ------\n");
+ codec_dbg(codec, "-- dsp_dma_setup_common() -- Complete ------\n");
 
  return 0;
 }
@@ -1754,20 +1754,20 @@ static int dsp_dma_setup(struct hda_codec *codec,
  const unsigned int max_dma_count = 1 << (DSPDMAC_XFRCNT_BCNT_HIBIT -
       DSPDMAC_XFRCNT_BCNT_LOBIT + 1);
 
- snd_printdd(KERN_INFO "-- dsp_dma_setup() -- Begin ---------\n");
+ codec_dbg(codec, "-- dsp_dma_setup() -- Begin ---------\n");
 
  if (count > max_dma_count) {
-  snd_printdd(KERN_ERR "count too big\n");
+  codec_dbg(codec, "count too big\n");
   return -EINVAL;
  }
 
  dsp_addx = dsp_chip_to_dsp_addx(chip_addx, &code, &yram);
  if (dsp_addx == INVALID_CHIP_ADDRESS) {
-  snd_printdd(KERN_ERR "invalid chip addr\n");
+  codec_dbg(codec, "invalid chip addr\n");
   return -ENXIO;
  }
 
- snd_printdd(KERN_INFO "   dsp_dma_setup()    start reg pgm\n");
+ codec_dbg(codec, "   dsp_dma_setup()    start reg pgm\n");
 
  addr_field = dsp_addx << DSPDMAC_DMACFG_DBADR_LOBIT;
  incr_field   = 0;
@@ -1784,10 +1784,10 @@ static int dsp_dma_setup(struct hda_codec *codec,
  status = chipio_write(codec, DSPDMAC_DMACFG_INST_OFFSET(dma_chan),
     dma_cfg);
  if (status < 0) {
-  snd_printdd(KERN_ERR "write DMACFG Reg fail\n");
+  codec_dbg(codec, "write DMACFG Reg fail\n");
   return status;
  }
- snd_printdd(KERN_INFO "   dsp_dma_setup()    Write DMACFG\n");
+ codec_dbg(codec, "   dsp_dma_setup()    Write DMACFG\n");
 
  adr_ofs = (count - 1) << (DSPDMAC_DSPADROFS_BOFS_LOBIT +
        (code ? 0 : 1));
@@ -1795,10 +1795,10 @@ static int dsp_dma_setup(struct hda_codec *codec,
  status = chipio_write(codec, DSPDMAC_DSPADROFS_INST_OFFSET(dma_chan),
     adr_ofs);
  if (status < 0) {
-  snd_printdd(KERN_ERR "write DSPADROFS Reg fail\n");
+  codec_dbg(codec, "write DSPADROFS Reg fail\n");
   return status;
  }
- snd_printdd(KERN_INFO "   dsp_dma_setup()    Write DSPADROFS\n");
+ codec_dbg(codec, "   dsp_dma_setup()    Write DSPADROFS\n");
 
  base_cnt = (count - 1) << DSPDMAC_XFRCNT_BCNT_LOBIT;
 
@@ -1809,17 +1809,17 @@ static int dsp_dma_setup(struct hda_codec *codec,
  status = chipio_write(codec,
     DSPDMAC_XFRCNT_INST_OFFSET(dma_chan), xfr_cnt);
  if (status < 0) {
-  snd_printdd(KERN_ERR "write XFRCNT Reg fail\n");
+  codec_dbg(codec, "write XFRCNT Reg fail\n");
   return status;
  }
- snd_printdd(KERN_INFO "   dsp_dma_setup()    Write XFRCNT\n");
+ codec_dbg(codec, "   dsp_dma_setup()    Write XFRCNT\n");
 
- snd_printdd(
+ codec_dbg(codec,
      "ChipA=0x%x, cnt=0x%x, DMACFG=0x%x, "
      "ADROFS=0x%x, XFRCNT=0x%x\n",
      chip_addx, count, dma_cfg, adr_ofs, xfr_cnt);
 
- snd_printdd(KERN_INFO "-- dsp_dma_setup() -- Complete ---------\n");
+ codec_dbg(codec, "-- dsp_dma_setup() -- Complete ---------\n");
 
  return 0;
 }
@@ -1833,17 +1833,17 @@ static int dsp_dma_start(struct hda_codec *codec,
  unsigned int reg = 0;
  int status = 0;
 
- snd_printdd(KERN_INFO "-- dsp_dma_start() -- Begin ---------\n");
+ codec_dbg(codec, "-- dsp_dma_start() -- Begin ---------\n");
 
  if (ovly) {
   status = chipio_read(codec,
          DSPDMAC_CHNLSTART_INST_OFFSET, &reg);
 
   if (status < 0) {
-   snd_printdd(KERN_ERR "read CHNLSTART reg fail\n");
+   codec_dbg(codec, "read CHNLSTART reg fail\n");
    return status;
   }
-  snd_printdd(KERN_INFO "-- dsp_dma_start()    Read CHNLSTART\n");
+  codec_dbg(codec, "-- dsp_dma_start()    Read CHNLSTART\n");
 
   reg &= ~(DSPDMAC_CHNLSTART_EN_MASK |
     DSPDMAC_CHNLSTART_DIS_MASK);
@@ -1852,10 +1852,10 @@ static int dsp_dma_start(struct hda_codec *codec,
  status = chipio_write(codec, DSPDMAC_CHNLSTART_INST_OFFSET,
    reg | (1 << (dma_chan + DSPDMAC_CHNLSTART_EN_LOBIT)));
  if (status < 0) {
-  snd_printdd(KERN_ERR "write CHNLSTART reg fail\n");
+  codec_dbg(codec, "write CHNLSTART reg fail\n");
   return status;
  }
- snd_printdd(KERN_INFO "-- dsp_dma_start() -- Complete ---------\n");
+ codec_dbg(codec, "-- dsp_dma_start() -- Complete ---------\n");
 
  return status;
 }
@@ -1869,17 +1869,17 @@ static int dsp_dma_stop(struct hda_codec *codec,
  unsigned int reg = 0;
  int status = 0;
 
- snd_printdd(KERN_INFO "-- dsp_dma_stop() -- Begin ---------\n");
+ codec_dbg(codec, "-- dsp_dma_stop() -- Begin ---------\n");
 
  if (ovly) {
   status = chipio_read(codec,
          DSPDMAC_CHNLSTART_INST_OFFSET, &reg);
 
   if (status < 0) {
-   snd_printdd(KERN_ERR "read CHNLSTART reg fail\n");
+   codec_dbg(codec, "read CHNLSTART reg fail\n");
    return status;
   }
-  snd_printdd(KERN_INFO "-- dsp_dma_stop()    Read CHNLSTART\n");
+  codec_dbg(codec, "-- dsp_dma_stop()    Read CHNLSTART\n");
   reg &= ~(DSPDMAC_CHNLSTART_EN_MASK |
     DSPDMAC_CHNLSTART_DIS_MASK);
  }
@@ -1887,10 +1887,10 @@ static int dsp_dma_stop(struct hda_codec *codec,
  status = chipio_write(codec, DSPDMAC_CHNLSTART_INST_OFFSET,
    reg | (1 << (dma_chan + DSPDMAC_CHNLSTART_DIS_LOBIT)));
  if (status < 0) {
-  snd_printdd(KERN_ERR "write CHNLSTART reg fail\n");
+  codec_dbg(codec, "write CHNLSTART reg fail\n");
   return status;
  }
- snd_printdd(KERN_INFO "-- dsp_dma_stop() -- Complete ---------\n");
+ codec_dbg(codec, "-- dsp_dma_stop() -- Complete ---------\n");
 
  return status;
 }
@@ -1973,17 +1973,17 @@ static int dsp_allocate_ports(struct hda_codec *codec,
 {
  int status;
 
- snd_printdd(KERN_INFO "     dsp_allocate_ports() -- begin\n");
+ codec_dbg(codec, "     dsp_allocate_ports() -- begin\n");
 
  if ((rate_multi != 1) && (rate_multi != 2) && (rate_multi != 4)) {
-  snd_printdd(KERN_ERR "bad rate multiple\n");
+  codec_dbg(codec, "bad rate multiple\n");
   return -EINVAL;
  }
 
  status = dsp_allocate_router_ports(codec, num_chans,
         rate_multi, 0, port_map);
 
- snd_printdd(KERN_INFO "     dsp_allocate_ports() -- complete\n");
+ codec_dbg(codec, "     dsp_allocate_ports() -- complete\n");
 
  return status;
 }
@@ -2000,7 +2000,7 @@ static int dsp_allocate_ports_format(struct hda_codec *codec,
  unsigned int rate_multi = sample_rate_mul / sample_rate_div;
 
  if ((rate_multi != 1) && (rate_multi != 2) && (rate_multi != 4)) {
-  snd_printdd(KERN_ERR "bad rate multiple\n");
+  codec_dbg(codec, "bad rate multiple\n");
   return -EINVAL;
  }
 
@@ -2018,14 +2018,14 @@ static int dsp_free_ports(struct hda_codec *codec)
 {
  int status;
 
- snd_printdd(KERN_INFO "     dsp_free_ports() -- begin\n");
+ codec_dbg(codec, "     dsp_free_ports() -- begin\n");
 
  status = dsp_free_router_ports(codec);
  if (status < 0) {
-  snd_printdd(KERN_ERR "free router ports fail\n");
+  codec_dbg(codec, "free router ports fail\n");
   return status;
  }
- snd_printdd(KERN_INFO "     dsp_free_ports() -- complete\n");
+ codec_dbg(codec, "     dsp_free_ports() -- complete\n");
 
  return status;
 }
@@ -2091,8 +2091,6 @@ static int dma_set_state(struct dma_engine *dma, enum dma_state state)
 {
  bool cmd;
 
- snd_printdd("dma_set_state state=%d\n", state);
-
  switch (state) {
  case DMA_STATE_STOP:
   cmd = false;
@@ -2195,7 +2193,7 @@ static int dspxfr_hci_write(struct hda_codec *codec,
  unsigned int count;
 
  if (fls == NULL || fls->chip_addr != g_chip_addr_magic_value) {
-  snd_printdd(KERN_ERR "hci_write invalid params\n");
+  codec_dbg(codec, "hci_write invalid params\n");
   return -EINVAL;
  }
 
@@ -2204,7 +2202,7 @@ static int dspxfr_hci_write(struct hda_codec *codec,
  while (count >= 2) {
   status = chipio_write(codec, data[0], data[1]);
   if (status < 0) {
-   snd_printdd(KERN_ERR "hci_write chipio failed\n");
+   codec_dbg(codec, "hci_write chipio failed\n");
    return status;
   }
   count -= 2;
@@ -2264,12 +2262,12 @@ static int dspxfr_one_seg(struct hda_codec *codec,
  }
 
  if (hci_write && (!fls || is_last(fls))) {
-  snd_printdd("hci_write\n");
+  codec_dbg(codec, "hci_write\n");
   return dspxfr_hci_write(codec, hci_write);
  }
 
  if (fls == NULL || dma_engine == NULL || port_map_mask == 0) {
-  snd_printdd("Invalid Params\n");
+  codec_dbg(codec, "Invalid Params\n");
   return -EINVAL;
  }
 
@@ -2285,7 +2283,7 @@ static int dspxfr_one_seg(struct hda_codec *codec,
  if (!UC_RANGE(chip_addx, words_to_write) &&
      !X_RANGE_ALL(chip_addx, words_to_write) &&
      !Y_RANGE_ALL(chip_addx, words_to_write)) {
-  snd_printdd("Invalid chip_addx Params\n");
+  codec_dbg(codec, "Invalid chip_addx Params\n");
   return -EINVAL;
  }
 
@@ -2295,7 +2293,7 @@ static int dspxfr_one_seg(struct hda_codec *codec,
  buffer_addx = dma_get_buffer_addr(dma_engine);
 
  if (buffer_addx == NULL) {
-  snd_printdd(KERN_ERR "dma_engine buffer NULL\n");
+  codec_dbg(codec, "dma_engine buffer NULL\n");
   return -EINVAL;
  }
 
@@ -2308,7 +2306,7 @@ static int dspxfr_one_seg(struct hda_codec *codec,
    (num_chans * sample_rate_mul / sample_rate_div));
 
  if (hda_frame_size_words == 0) {
-  snd_printdd(KERN_ERR "frmsz zero\n");
+  codec_dbg(codec, "frmsz zero\n");
   return -EINVAL;
  }
 
@@ -2316,14 +2314,14 @@ static int dspxfr_one_seg(struct hda_codec *codec,
     (unsigned int)(UC_RANGE(chip_addx, 1) ?
     65536 : 32768));
  buffer_size_words -= buffer_size_words % hda_frame_size_words;
- snd_printdd(
+ codec_dbg(codec,
      "chpadr=0x%08x frmsz=%u nchan=%u "
      "rate_mul=%u div=%u bufsz=%u\n",
      chip_addx, hda_frame_size_words, num_chans,
      sample_rate_mul, sample_rate_div, buffer_size_words);
 
  if (buffer_size_words < hda_frame_size_words) {
-  snd_printdd(KERN_ERR "dspxfr_one_seg:failed\n");
+  codec_dbg(codec, "dspxfr_one_seg:failed\n");
   return -EINVAL;
  }
 
@@ -2337,7 +2335,7 @@ static int dspxfr_one_seg(struct hda_codec *codec,
 
  while (words_to_write != 0) {
   run_size_words = min(buffer_size_words, words_to_write);
-  snd_printdd("dspxfr (seg loop)cnt=%u rs=%u remainder=%u\n",
+  codec_dbg(codec, "dspxfr (seg loop)cnt=%u rs=%u remainder=%u\n",
        words_to_write, run_size_words, remainder_words);
   dma_xfer(dma_engine, data, run_size_words*sizeof(u32));
   if (!comm_dma_setup_done) {
@@ -2359,7 +2357,7 @@ static int dspxfr_one_seg(struct hda_codec *codec,
   if (status < 0)
    return status;
   if (!dsp_is_dma_active(codec, dma_chan)) {
-   snd_printdd(KERN_ERR "dspxfr:DMA did not start\n");
+   codec_dbg(codec, "dspxfr:DMA did not start\n");
    return -EIO;
   }
   status = dma_set_state(dma_engine, DMA_STATE_RUN);
@@ -2391,7 +2389,7 @@ static int dspxfr_one_seg(struct hda_codec *codec,
   if (dma_active)
    break;
 
-  snd_printdd(KERN_INFO "+++++ DMA complete\n");
+  codec_dbg(codec, "+++++ DMA complete\n");
   dma_set_state(dma_engine, DMA_STATE_STOP);
   status = dma_reset(dma_engine);
 
@@ -2465,7 +2463,7 @@ static int dspxfr_image(struct hda_codec *codec,
      hda_format, &response);
 
  if (status < 0) {
-  snd_printdd(KERN_ERR "set converter format fail\n");
+  codec_dbg(codec, "set converter format fail\n");
   goto exit;
  }
 
@@ -2480,7 +2478,7 @@ static int dspxfr_image(struct hda_codec *codec,
  if (ovly) {
   status = dspio_alloc_dma_chan(codec, &dma_chan);
   if (status < 0) {
-   snd_printdd(KERN_ERR "alloc dmachan fail\n");
+   codec_dbg(codec, "alloc dmachan fail\n");
    dma_chan = INVALID_DMA_CHANNEL;
    goto exit;
   }
@@ -2490,7 +2488,7 @@ static int dspxfr_image(struct hda_codec *codec,
  status = dsp_allocate_ports_format(codec, hda_format,
      &port_map_mask);
  if (status < 0) {
-  snd_printdd(KERN_ERR "alloc ports fail\n");
+  codec_dbg(codec, "alloc ports fail\n");
   goto exit;
  }
 
@@ -2498,13 +2496,13 @@ static int dspxfr_image(struct hda_codec *codec,
  status = codec_set_converter_stream_channel(codec,
    WIDGET_CHIP_CTRL, stream_id, 0, &response);
  if (status < 0) {
-  snd_printdd(KERN_ERR "set stream chan fail\n");
+  codec_dbg(codec, "set stream chan fail\n");
   goto exit;
  }
 
  while ((fls_data != NULL) && !is_last(fls_data)) {
   if (!is_valid(fls_data)) {
-   snd_printdd(KERN_ERR "FLS check fail\n");
+   codec_dbg(codec, "FLS check fail\n");
    status = -EINVAL;
    goto exit;
   }
@@ -2547,7 +2545,7 @@ exit:
  */
 static void dspload_post_setup(struct hda_codec *codec)
 {
- snd_printdd(KERN_INFO "---- dspload_post_setup ------\n");
+ codec_dbg(codec, "---- dspload_post_setup ------\n");
 
  /*set DSP speaker to 2.0 configuration*/
  chipio_write(codec, XRAM_XRAM_INST_OFFSET(0x18), 0x08080080);
@@ -2585,7 +2583,7 @@ static int dspload_image(struct hda_codec *codec,
  unsigned int sample_rate;
  unsigned short channels;
 
- snd_printdd(KERN_INFO "---- dspload_image begin ------\n");
+ codec_dbg(codec, "---- dspload_image begin ------\n");
  if (router_chans == 0) {
   if (!ovly)
    router_chans = DMA_TRANSFER_FRAME_SIZE_NWORDS;
@@ -2602,27 +2600,27 @@ static int dspload_image(struct hda_codec *codec,
  }
 
  do {
-  snd_printdd(KERN_INFO "Ready to program DMA\n");
+  codec_dbg(codec, "Ready to program DMA\n");
   if (!ovly)
    status = dsp_reset(codec);
 
   if (status < 0)
    break;
 
-  snd_printdd(KERN_INFO "dsp_reset() complete\n");
+  codec_dbg(codec, "dsp_reset() complete\n");
   status = dspxfr_image(codec, fls, reloc, sample_rate, channels,
           ovly);
 
   if (status < 0)
    break;
 
-  snd_printdd(KERN_INFO "dspxfr_image() complete\n");
+  codec_dbg(codec, "dspxfr_image() complete\n");
   if (autostart && !ovly) {
    dspload_post_setup(codec);
    status = dsp_set_run_state(codec);
   }
 
-  snd_printdd(KERN_INFO "LOAD FINISHED\n");
+  codec_dbg(codec, "LOAD FINISHED\n");
  } while (0);
 
  return status;
@@ -3131,7 +3129,7 @@ static int ca0132_select_out(struct hda_codec *codec)
  unsigned int tmp;
  int err;
 
- snd_printdd(KERN_INFO "ca0132_select_out\n");
+ codec_dbg(codec, "ca0132_select_out\n");
 
  snd_hda_power_up(codec);
 
@@ -3149,7 +3147,7 @@ static int ca0132_select_out(struct hda_codec *codec)
   spec->cur_out_type = SPEAKER_OUT;
 
  if (spec->cur_out_type == SPEAKER_OUT) {
-  snd_printdd(KERN_INFO "ca0132_select_out speaker\n");
+  codec_dbg(codec, "ca0132_select_out speaker\n");
   /*speaker out config*/
   tmp = FLOAT_ONE;
   err = dspio_set_uint_param(codec, 0x80, 0x04, tmp);
@@ -3182,7 +3180,7 @@ static int ca0132_select_out(struct hda_codec *codec)
   snd_hda_set_pin_ctl(codec, spec->out_pins[0],
         pin_ctl | PIN_OUT);
  } else {
-  snd_printdd(KERN_INFO "ca0132_select_out hp\n");
+  codec_dbg(codec, "ca0132_select_out hp\n");
   /*headphone out config*/
   tmp = FLOAT_ZERO;
   err = dspio_set_uint_param(codec, 0x80, 0x04, tmp);
@@ -3287,7 +3285,7 @@ static int ca0132_select_mic(struct hda_codec *codec)
  int jack_present;
  int auto_jack;
 
- snd_printdd(KERN_INFO "ca0132_select_mic\n");
+ codec_dbg(codec, "ca0132_select_mic\n");
 
  snd_hda_power_up(codec);
 
@@ -3409,7 +3407,7 @@ static int ca0132_effects_set(struct hda_codec *codec, hda_nid_t nid, long val)
    val = 0;
  }
 
- snd_printdd(KERN_INFO "ca0132_effect_set: nid=0x%x, val=%ld\n",
+ codec_dbg(codec, "ca0132_effect_set: nid=0x%x, val=%ld\n",
       nid, val);
 
  on = (val == 0) ? FLOAT_ZERO : FLOAT_ONE;
@@ -3431,7 +3429,7 @@ static int ca0132_pe_switch_set(struct hda_codec *codec)
  hda_nid_t nid;
  int i, ret = 0;
 
- snd_printdd(KERN_INFO "ca0132_pe_switch_set: val=%ld\n",
+ codec_dbg(codec, "ca0132_pe_switch_set: val=%ld\n",
       spec->effects_switch[PLAY_ENHANCEMENT - EFFECT_START_NID]);
 
  i = OUT_EFFECT_START_NID - EFFECT_START_NID;
@@ -3477,7 +3475,7 @@ static int ca0132_cvoice_switch_set(struct hda_codec *codec)
  int i, ret = 0;
  unsigned int oldval;
 
- snd_printdd(KERN_INFO "ca0132_cvoice_switch_set: val=%ld\n",
+ codec_dbg(codec, "ca0132_cvoice_switch_set: val=%ld\n",
       spec->effects_switch[CRYSTAL_VOICE - EFFECT_START_NID]);
 
  i = IN_EFFECT_START_NID - EFFECT_START_NID;
@@ -3607,7 +3605,7 @@ static int ca0132_voicefx_put(struct snd_kcontrol *kcontrol,
  if (sel >= items)
   return 0;
 
- snd_printdd(KERN_INFO "ca0132_voicefx_put: sel=%d, preset=%s\n",
+ codec_dbg(codec, "ca0132_voicefx_put: sel=%d, preset=%s\n",
       sel, ca0132_voicefx_presets[sel].name);
 
  /*
@@ -3678,7 +3676,7 @@ static int ca0132_switch_put(struct snd_kcontrol *kcontrol,
  long *valp = ucontrol->value.integer.value;
  int changed = 1;
 
- snd_printdd(KERN_INFO "ca0132_switch_put: nid=0x%x, val=%ld\n",
+ codec_dbg(codec, "ca0132_switch_put: nid=0x%x, val=%ld\n",
       nid, *valp);
 
  snd_hda_power_up(codec);
@@ -4141,7 +4139,7 @@ static void ca0132_set_dmic(struct hda_codec *codec, int enable)
  u8 val;
  unsigned int oldval;
 
- snd_printdd(KERN_INFO "ca0132_set_dmic: enable=%d\n", enable);
+ codec_dbg(codec, "ca0132_set_dmic: enable=%d\n", enable);
 
  oldval = stop_mic1(codec);
  ca0132_set_vipsource(codec, 0);
@@ -4249,7 +4247,7 @@ static void ca0132_refresh_widget_caps(struct hda_codec *codec)
  int i;
  hda_nid_t nid;
 
- snd_printdd(KERN_INFO "ca0132_refresh_widget_caps.\n");
+ codec_dbg(codec, "ca0132_refresh_widget_caps.\n");
  nid = codec->start_nid;
  for (i = 0; i < codec->num_nodes; i++, nid++)
   codec->wcaps[i] = snd_hda_param_read(codec, nid,
@@ -4393,7 +4391,7 @@ static void ca0132_process_dsp_response(struct hda_codec *codec)
 {
  struct ca0132_spec *spec = codec->spec;
 
- snd_printdd(KERN_INFO "ca0132_process_dsp_response\n");
+ codec_dbg(codec, "ca0132_process_dsp_response\n");
  if (spec->wait_scp) {
   if (dspio_get_response_data(codec) >= 0)
    spec->wait_scp = 0;
@@ -4412,7 +4410,7 @@ static void ca0132_unsol_event(struct hda_codec *codec, unsigned int res)
   res = snd_hda_jack_get_action(codec,
     (res >> AC_UNSOL_RES_TAG_SHIFT) & 0x3f);
 
-  snd_printdd(KERN_INFO "snd_hda_jack_get_action: 0x%x\n", res);
+  codec_dbg(codec, "snd_hda_jack_get_action: 0x%x\n", res);
 
   switch (res) {
   case UNSOL_TAG_HP:
@@ -4657,7 +4655,7 @@ static int patch_ca0132(struct hda_codec *codec)
  struct ca0132_spec *spec;
  int err;
 
- snd_printdd("patch_ca0132\n");
+ codec_dbg(codec, "patch_ca0132\n");
 
  spec = kzalloc(sizeof(*spec), GFP_KERNEL);
  if (!spec)
diff --git a/sound/pci/hda/patch_cmedia.c b/sound/pci/hda/patch_cmedia.c
index d782292..061ea59 100644
--- a/sound/pci/hda/patch_cmedia.c
+++ b/sound/pci/hda/patch_cmedia.c
@@ -623,7 +623,7 @@ static int patch_cmi9880(struct hda_codec *codec)
        cmi9880_models,
        cmi9880_cfg_tbl);
  if (spec->board_config < 0) {
-  snd_printdd(KERN_INFO "hda_codec: %s: BIOS auto-probing.\n",
+  codec_dbg(codec, "%s: BIOS auto-probing.\n",
        codec->chip_name);
   spec->board_config = CMI_AUTO; /* try everything */
  }
diff --git a/sound/pci/hda/patch_conexant.c b/sound/pci/hda/patch_conexant.c
index 13a4160..09d6d0d 100644
--- a/sound/pci/hda/patch_conexant.c
+++ b/sound/pci/hda/patch_conexant.c
@@ -1900,7 +1900,8 @@ static void cxt5066_update_speaker(struct hda_codec *codec)
  struct conexant_spec *spec = codec->spec;
  unsigned int pinctl;
 
- snd_printdd("CXT5066: update speaker, hp_present=%d, cur_eapd=%d\n",
+ codec_dbg(codec,
+    "CXT5066: update speaker, hp_present=%d, cur_eapd=%d\n",
       spec->hp_present, spec->cur_eapd);
 
  /* Port A (HP) */
@@ -1969,10 +1970,10 @@ static void cxt5066_vostro_automic(struct hda_codec *codec)
 
  present = snd_hda_jack_detect(codec, 0x1a);
  if (present) {
-  snd_printdd("CXT5066: external microphone detected\n");
+  codec_dbg(codec, "CXT5066: external microphone detected\n");
   snd_hda_sequence_write(codec, ext_mic_present);
  } else {
-  snd_printdd("CXT5066: external microphone absent\n");
+  codec_dbg(codec, "CXT5066: external microphone absent\n");
   snd_hda_sequence_write(codec, ext_mic_absent);
  }
 }
@@ -1997,10 +1998,10 @@ static void cxt5066_ideapad_automic(struct hda_codec *codec)
 
  present = snd_hda_jack_detect(codec, 0x1b);
  if (present) {
-  snd_printdd("CXT5066: external microphone detected\n");
+  codec_dbg(codec, "CXT5066: external microphone detected\n");
   snd_hda_sequence_write(codec, ext_mic_present);
  } else {
-  snd_printdd("CXT5066: external microphone absent\n");
+  codec_dbg(codec, "CXT5066: external microphone absent\n");
   snd_hda_sequence_write(codec, ext_mic_absent);
  }
 }
@@ -2012,7 +2013,7 @@ static void cxt5066_asus_automic(struct hda_codec *codec)
  unsigned int present;
 
  present = snd_hda_jack_detect(codec, 0x1b);
- snd_printdd("CXT5066: external microphone present=%d\n", present);
+ codec_dbg(codec, "CXT5066: external microphone present=%d\n", present);
  snd_hda_codec_write(codec, 0x17, 0, AC_VERB_SET_CONNECT_SEL,
        present ? 1 : 0);
 }
@@ -2024,7 +2025,7 @@ static void cxt5066_hp_laptop_automic(struct hda_codec *codec)
  unsigned int present;
 
  present = snd_hda_jack_detect(codec, 0x1b);
- snd_printdd("CXT5066: external microphone present=%d\n", present);
+ codec_dbg(codec, "CXT5066: external microphone present=%d\n", present);
  snd_hda_codec_write(codec, 0x17, 0, AC_VERB_SET_CONNECT_SEL,
        present ? 1 : 3);
 }
@@ -2063,13 +2064,13 @@ static void cxt5066_thinkpad_automic(struct hda_codec *codec)
  ext_present = snd_hda_jack_detect(codec, 0x1b);
  dock_present = snd_hda_jack_detect(codec, 0x1a);
  if (ext_present) {
-  snd_printdd("CXT5066: external microphone detected\n");
+  codec_dbg(codec, "CXT5066: external microphone detected\n");
   snd_hda_sequence_write(codec, ext_mic_present);
  } else if (dock_present) {
-  snd_printdd("CXT5066: dock microphone detected\n");
+  codec_dbg(codec, "CXT5066: dock microphone detected\n");
   snd_hda_sequence_write(codec, dock_mic_present);
  } else {
-  snd_printdd("CXT5066: external microphone absent\n");
+  codec_dbg(codec, "CXT5066: external microphone absent\n");
   snd_hda_sequence_write(codec, ext_mic_absent);
  }
 }
@@ -2088,7 +2089,7 @@ static void cxt5066_hp_automute(struct hda_codec *codec)
 
  spec->hp_present = portA ? HP_PRESENT_PORT_A : 0;
  spec->hp_present |= portD ? HP_PRESENT_PORT_D : 0;
- snd_printdd("CXT5066: hp automute portA=%x portD=%x present=%d\n",
+ codec_dbg(codec, "CXT5066: hp automute portA=%x portD=%x present=%d\n",
   portA, portD, spec->hp_present);
  cxt5066_update_speaker(codec);
 }
@@ -2113,7 +2114,7 @@ static void cxt5066_automic(struct hda_codec *codec)
 /* unsolicited event for jack sensing */
 static void cxt5066_unsol_event(struct hda_codec *codec, unsigned int res)
 {
- snd_printdd("CXT5066: unsol event %x (%x)\n", res, res >> 26);
+ codec_dbg(codec, "CXT5066: unsol event %x (%x)\n", res, res >> 26);
  switch (res >> 26) {
  case CONEXANT_HP_EVENT:
   cxt5066_hp_automute(codec);
@@ -2509,7 +2510,7 @@ static const struct hda_verb cxt5066_init_verbs_hp_laptop[] = {
 /* initialize jack-sensing, too */
 static int cxt5066_init(struct hda_codec *codec)
 {
- snd_printdd("CXT5066: init\n");
+ codec_dbg(codec, "CXT5066: init\n");
  conexant_init(codec);
  if (codec->patch_ops.unsol_event) {
   cxt5066_hp_automute(codec);
@@ -3401,8 +3402,7 @@ static int patch_conexant_auto(struct hda_codec *codec)
  struct conexant_spec *spec;
  int err;
 
- printk(KERN_INFO "hda_codec: %s: BIOS auto-probing.\n",
-        codec->chip_name);
+ codec_info(codec, "%s: BIOS auto-probing.\n", codec->chip_name);
 
  spec = kzalloc(sizeof(*spec), GFP_KERNEL);
  if (!spec)
@@ -3474,7 +3474,7 @@ static int patch_conexant_auto(struct hda_codec *codec)
   * Better to make reset, then.
   */
  if (!codec->bus->sync_write) {
-  snd_printd("hda_codec: "
+  codec_info(codec,
       "Enable sync_write for stable communication\n");
   codec->bus->sync_write = 1;
   codec->bus->allow_bus_reset = 1;
diff --git a/sound/pci/hda/patch_hdmi.c b/sound/pci/hda/patch_hdmi.c
index 5ef9503..994713c 100644
--- a/sound/pci/hda/patch_hdmi.c
+++ b/sound/pci/hda/patch_hdmi.c
@@ -353,40 +353,43 @@ static struct cea_channel_speaker_allocation channel_allocations[] = {
 #define get_pcm_rec(spec, idx) \
  ((struct hda_pcm *)snd_array_elem(&spec->pcm_rec, idx))
 
-static int pin_nid_to_pin_index(struct hdmi_spec *spec, hda_nid_t pin_nid)
+static int pin_nid_to_pin_index(struct hda_codec *codec, hda_nid_t pin_nid)
 {
+ struct hdmi_spec *spec = codec->spec;
  int pin_idx;
 
  for (pin_idx = 0; pin_idx < spec->num_pins; pin_idx++)
   if (get_pin(spec, pin_idx)->pin_nid == pin_nid)
    return pin_idx;
 
- snd_printk(KERN_WARNING "HDMI: pin nid %d not registered\n", pin_nid);
+ codec_warn(codec, "HDMI: pin nid %d not registered\n", pin_nid);
  return -EINVAL;
 }
 
-static int hinfo_to_pin_index(struct hdmi_spec *spec,
+static int hinfo_to_pin_index(struct hda_codec *codec,
          struct hda_pcm_stream *hinfo)
 {
+ struct hdmi_spec *spec = codec->spec;
  int pin_idx;
 
  for (pin_idx = 0; pin_idx < spec->num_pins; pin_idx++)
   if (get_pcm_rec(spec, pin_idx)->stream == hinfo)
    return pin_idx;
 
- snd_printk(KERN_WARNING "HDMI: hinfo %p not registered\n", hinfo);
+ codec_warn(codec, "HDMI: hinfo %p not registered\n", hinfo);
  return -EINVAL;
 }
 
-static int cvt_nid_to_cvt_index(struct hdmi_spec *spec, hda_nid_t cvt_nid)
+static int cvt_nid_to_cvt_index(struct hda_codec *codec, hda_nid_t cvt_nid)
 {
+ struct hdmi_spec *spec = codec->spec;
  int cvt_idx;
 
  for (cvt_idx = 0; cvt_idx < spec->num_cvts; cvt_idx++)
   if (get_cvt(spec, cvt_idx)->cvt_nid == cvt_nid)
    return cvt_idx;
 
- snd_printk(KERN_WARNING "HDMI: cvt nid %d not registered\n", cvt_nid);
+ codec_warn(codec, "HDMI: cvt nid %d not registered\n", cvt_nid);
  return -EINVAL;
 }
 
@@ -706,7 +709,7 @@ static void hdmi_debug_channel_mapping(struct hda_codec *codec,
 
  for (i = 0; i < 8; i++) {
   channel = spec->ops.pin_get_slot_channel(codec, pin_nid, i);
-  printk(KERN_DEBUG "HDMI: ASP channel %d => slot %d\n",
+  codec_dbg(codec, "HDMI: ASP channel %d => slot %d\n",
       channel, i);
  }
 #endif
@@ -755,8 +758,7 @@ static void hdmi_std_setup_channel_mapping(struct hda_codec *codec,
   int channel = (slotsetup & 0xf0) >> 4;
   err = spec->ops.pin_set_slot_channel(codec, pin_nid, hdmi_slot, channel);
   if (err) {
-   snd_printdd(KERN_NOTICE
-        "HDMI: channel mapping failed\n");
+   codec_dbg(codec, "HDMI: channel mapping failed\n");
    break;
   }
  }
@@ -967,12 +969,12 @@ static void hdmi_debug_dip_size(struct hda_codec *codec, hda_nid_t pin_nid)
  int size;
 
  size = snd_hdmi_get_eld_size(codec, pin_nid);
- printk(KERN_DEBUG "HDMI: ELD buf size is %d\n", size);
+ codec_dbg(codec, "HDMI: ELD buf size is %d\n", size);
 
  for (i = 0; i < 8; i++) {
   size = snd_hda_codec_read(codec, pin_nid, 0,
       AC_VERB_GET_HDMI_DIP_SIZE, i);
-  printk(KERN_DEBUG "HDMI: DIP GP[%d] buf size is %d\n", i, size);
+  codec_dbg(codec, "HDMI: DIP GP[%d] buf size is %d\n", i, size);
  }
 #endif
 }
@@ -994,12 +996,12 @@ static void hdmi_clear_dip_buffers(struct hda_codec *codec, hda_nid_t pin_nid)
    hdmi_write_dip_byte(codec, pin_nid, 0x0);
    hdmi_get_dip_index(codec, pin_nid, &pi, &bi);
    if (pi != i)
-    snd_printd(KERN_INFO "dip index %d: %d != %d\n",
+    codec_dbg(codec, "dip index %d: %d != %d\n",
       bi, pi, i);
    if (bi == 0) /* byte index wrapped around */
     break;
   }
-  snd_printd(KERN_INFO
+  codec_dbg(codec,
    "HDMI: DIP GP[%d] buf reported size=%d, written=%d\n",
    i, size, j);
  }
@@ -1080,7 +1082,7 @@ static void hdmi_pin_setup_infoframe(struct hda_codec *codec,
   dp_ai->CC02_CT47 = active_channels - 1;
   dp_ai->CA  = ca;
  } else {
-  snd_printd("HDMI: unknown connection type at pin %d\n",
+  codec_dbg(codec, "HDMI: unknown connection type at pin %d\n",
        pin_nid);
   return;
  }
@@ -1092,8 +1094,8 @@ static void hdmi_pin_setup_infoframe(struct hda_codec *codec,
   */
  if (!hdmi_infoframe_uptodate(codec, pin_nid, ai.bytes,
      sizeof(ai))) {
-  snd_printdd("hdmi_pin_setup_infoframe: "
-       "pin=%d channels=%d ca=0x%02x\n",
+  codec_dbg(codec,
+     "hdmi_pin_setup_infoframe: pin=%d channels=%d ca=0x%02x\n",
        pin_nid,
        active_channels, ca);
   hdmi_stop_infoframe_trans(codec, pin_nid);
@@ -1161,7 +1163,7 @@ static bool hdmi_present_sense(struct hdmi_spec_per_pin *per_pin, int repoll);
 static void jack_callback(struct hda_codec *codec, struct hda_jack_tbl *jack)
 {
  struct hdmi_spec *spec = codec->spec;
- int pin_idx = pin_nid_to_pin_index(spec, jack->nid);
+ int pin_idx = pin_nid_to_pin_index(codec, jack->nid);
  if (pin_idx < 0)
   return;
 
@@ -1180,7 +1182,7 @@ static void hdmi_intrinsic_event(struct hda_codec *codec, unsigned int res)
   return;
  jack->jack_dirty = 1;
 
- _snd_printd(SND_PR_VERBOSE,
+ codec_dbg(codec,
   "HDMI hot plug event: Codec=%d Pin=%d Device=%d Inactive=%d Presence_Detect=%d ELD_Valid=%d\n",
   codec->addr, jack->nid, dev_entry, !!(res & AC_UNSOL_RES_IA),
   !!(res & AC_UNSOL_RES_PD), !!(res & AC_UNSOL_RES_ELDV));
@@ -1195,7 +1197,7 @@ static void hdmi_non_intrinsic_event(struct hda_codec *codec, unsigned int res)
  int cp_state = !!(res & AC_UNSOL_RES_CP_STATE);
  int cp_ready = !!(res & AC_UNSOL_RES_CP_READY);
 
- printk(KERN_INFO
+ codec_info(codec,
   "HDMI CP event: CODEC=%d TAG=%d SUBTAG=0x%x CP_STATE=%d CP_READY=%d\n",
   codec->addr,
   tag,
@@ -1217,7 +1219,7 @@ static void hdmi_unsol_event(struct hda_codec *codec, unsigned int res)
  int subtag = (res & AC_UNSOL_RES_SUBTAG) >> AC_UNSOL_RES_SUBTAG_SHIFT;
 
  if (!snd_hda_jack_tbl_get_from_tag(codec, tag)) {
-  snd_printd(KERN_INFO "Unexpected HDMI event tag 0x%x\n", tag);
+  codec_dbg(codec, "Unexpected HDMI event tag 0x%x\n", tag);
   return;
  }
 
@@ -1244,7 +1246,7 @@ static void haswell_verify_D0(struct hda_codec *codec,
   msleep(40);
   pwr = snd_hda_codec_read(codec, nid, 0, AC_VERB_GET_POWER_STATE, 0);
   pwr = (pwr & AC_PWRST_ACTUAL) >> AC_PWRST_ACTUAL_SHIFT;
-  snd_printd("Haswell HDMI audio: Power for pin 0x%x is now D%d\n", nid, pwr);
+  codec_dbg(codec, "Haswell HDMI audio: Power for pin 0x%x is now D%d\n", nid, pwr);
  }
 }
 
@@ -1274,8 +1276,8 @@ static int hdmi_pin_hbr_setup(struct hda_codec *codec, hda_nid_t pin_nid,
   else
    new_pinctl |= AC_PINCTL_EPT_NATIVE;
 
-  snd_printdd("hdmi_pin_hbr_setup: "
-       "NID=0x%x, %spinctl=0x%x\n",
+  codec_dbg(codec,
+     "hdmi_pin_hbr_setup: NID=0x%x, %spinctl=0x%x\n",
        pin_nid,
        pinctl == new_pinctl ? "" : "new-",
        new_pinctl);
@@ -1302,7 +1304,7 @@ static int hdmi_setup_stream(struct hda_codec *codec, hda_nid_t cvt_nid,
  err = spec->ops.pin_hbr_setup(codec, pin_nid, is_hbr_format(format));
 
  if (err) {
-  snd_printdd("hdmi_setup_stream: HBR is not supported\n");
+  codec_dbg(codec, "hdmi_setup_stream: HBR is not supported\n");
   return err;
  }
 
@@ -1389,7 +1391,8 @@ static void intel_not_share_assigned_cvt(struct hda_codec *codec,
   for (cvt_idx = 0; cvt_idx < spec->num_cvts; cvt_idx++) {
    per_cvt = get_cvt(spec, cvt_idx);
    if (!per_cvt->assigned) {
-    snd_printdd("choose cvt %d for pin nid %d\n",
+    codec_dbg(codec,
+       "choose cvt %d for pin nid %d\n",
      cvt_idx, nid);
     snd_hda_codec_write_cache(codec, nid, 0,
          AC_VERB_SET_CONNECT_SEL,
@@ -1416,7 +1419,7 @@ static int hdmi_pcm_open(struct hda_pcm_stream *hinfo,
  int err;
 
  /* Validate hinfo */
- pin_idx = hinfo_to_pin_index(spec, hinfo);
+ pin_idx = hinfo_to_pin_index(codec, hinfo);
  if (snd_BUG_ON(pin_idx < 0))
   return -EINVAL;
  per_pin = get_pin(spec, pin_idx);
@@ -1482,9 +1485,8 @@ static int hdmi_read_pin_conn(struct hda_codec *codec, int pin_idx)
  hda_nid_t pin_nid = per_pin->pin_nid;
 
  if (!(get_wcaps(codec, pin_nid) & AC_WCAP_CONN_LIST)) {
-  snd_printk(KERN_WARNING
-      "HDMI: pin %d wcaps %#x "
-      "does not support connection list\n",
+  codec_warn(codec,
+      "HDMI: pin %d wcaps %#x does not support connection list\n",
       pin_nid, get_wcaps(codec, pin_nid));
   return -EINVAL;
  }
@@ -1527,7 +1529,7 @@ static bool hdmi_present_sense(struct hdmi_spec_per_pin *per_pin, int repoll)
  else
   eld->eld_valid = false;
 
- _snd_printd(SND_PR_VERBOSE,
+ codec_dbg(codec,
   "HDMI status: Codec=%d Pin=%d Presence_Detect=%d ELD_Valid=%d\n",
   codec->addr, pin_nid, pin_eld->monitor_present, eld->eld_valid);
 
@@ -1690,7 +1692,7 @@ static int hdmi_parse_codec(struct hda_codec *codec)
 
  nodes = snd_hda_get_sub_nodes(codec, codec->afg, &nid);
  if (!nid || nodes < 0) {
-  snd_printk(KERN_WARNING "HDMI: failed to get afg sub nodes\n");
+  codec_warn(codec, "HDMI: failed to get afg sub nodes\n");
   return -EINVAL;
  }
 
@@ -1744,7 +1746,7 @@ static int generic_hdmi_playback_pcm_prepare(struct hda_pcm_stream *hinfo,
 {
  hda_nid_t cvt_nid = hinfo->nid;
  struct hdmi_spec *spec = codec->spec;
- int pin_idx = hinfo_to_pin_index(spec, hinfo);
+ int pin_idx = hinfo_to_pin_index(codec, hinfo);
  struct hdmi_spec_per_pin *per_pin = get_pin(spec, pin_idx);
  hda_nid_t pin_nid = per_pin->pin_nid;
  bool non_pcm;
@@ -1788,7 +1790,7 @@ static int hdmi_pcm_close(struct hda_pcm_stream *hinfo,
  int pinctl;
 
  if (hinfo->nid) {
-  cvt_idx = cvt_nid_to_cvt_index(spec, hinfo->nid);
+  cvt_idx = cvt_nid_to_cvt_index(codec, hinfo->nid);
   if (snd_BUG_ON(cvt_idx < 0))
    return -EINVAL;
   per_cvt = get_cvt(spec, cvt_idx);
@@ -1797,7 +1799,7 @@ static int hdmi_pcm_close(struct hda_pcm_stream *hinfo,
   per_cvt->assigned = 0;
   hinfo->nid = 0;
 
-  pin_idx = hinfo_to_pin_index(spec, hinfo);
+  pin_idx = hinfo_to_pin_index(codec, hinfo);
   if (snd_BUG_ON(pin_idx < 0))
    return -EINVAL;
   per_pin = get_pin(spec, pin_idx);
@@ -2211,7 +2213,7 @@ static void intel_haswell_fixup_connect_list(struct hda_codec *codec,
   return;
 
  /* override pins connection list */
- snd_printdd("hdmi: haswell: override pin connection 0x%x\n", nid);
+ codec_dbg(codec, "hdmi: haswell: override pin connection 0x%x\n", nid);
  snd_hda_override_conn_list(codec, nid, spec->num_cvts, spec->cvt_nids);
 }
 
@@ -3132,8 +3134,8 @@ static int atihdmi_pin_hbr_setup(struct hda_codec *codec, hda_nid_t pin_nid,
   else
    hbr_ctl_new = hbr_ctl & ~ATI_HBR_ENABLE;
 
-  snd_printdd("atihdmi_pin_hbr_setup: "
-    "NID=0x%x, %shbr-ctl=0x%x\n",
+  codec_dbg(codec,
+     "atihdmi_pin_hbr_setup: NID=0x%x, %shbr-ctl=0x%x\n",
     pin_nid,
     hbr_ctl == hbr_ctl_new ? "" : "new-",
     hbr_ctl_new);
diff --git a/sound/pci/hda/patch_realtek.c b/sound/pci/hda/patch_realtek.c
index ee1ba22..c232220 100644
--- a/sound/pci/hda/patch_realtek.c
+++ b/sound/pci/hda/patch_realtek.c
@@ -407,8 +407,8 @@ static int alc_auto_parse_customize_define(struct hda_codec *codec)
  ass = snd_hda_codec_get_pincfg(codec, nid);
 
  if (!(ass & 1)) {
-  printk(KERN_INFO "hda_codec: %s: SKU not ready 0x%08x\n",
-         codec->chip_name, ass);
+  codec_info(codec, "%s: SKU not ready 0x%08x\n",
+      codec->chip_name, ass);
   return -1;
  }
 
@@ -432,17 +432,17 @@ do_sku:
  spec->cdefine.swap = (ass & 0x2) >> 1;
  spec->cdefine.override = ass & 0x1;
 
- snd_printd("SKU: Nid=0x%x sku_cfg=0x%08x\n",
+ codec_dbg(codec, "SKU: Nid=0x%x sku_cfg=0x%08x\n",
      nid, spec->cdefine.sku_cfg);
- snd_printd("SKU: port_connectivity=0x%x\n",
+ codec_dbg(codec, "SKU: port_connectivity=0x%x\n",
      spec->cdefine.port_connectivity);
- snd_printd("SKU: enable_pcbeep=0x%x\n", spec->cdefine.enable_pcbeep);
- snd_printd("SKU: check_sum=0x%08x\n", spec->cdefine.check_sum);
- snd_printd("SKU: customization=0x%08x\n", spec->cdefine.customization);
- snd_printd("SKU: external_amp=0x%x\n", spec->cdefine.external_amp);
- snd_printd("SKU: platform_type=0x%x\n", spec->cdefine.platform_type);
- snd_printd("SKU: swap=0x%x\n", spec->cdefine.swap);
- snd_printd("SKU: override=0x%x\n", spec->cdefine.override);
+ codec_dbg(codec, "SKU: enable_pcbeep=0x%x\n", spec->cdefine.enable_pcbeep);
+ codec_dbg(codec, "SKU: check_sum=0x%08x\n", spec->cdefine.check_sum);
+ codec_dbg(codec, "SKU: customization=0x%08x\n", spec->cdefine.customization);
+ codec_dbg(codec, "SKU: external_amp=0x%x\n", spec->cdefine.external_amp);
+ codec_dbg(codec, "SKU: platform_type=0x%x\n", spec->cdefine.platform_type);
+ codec_dbg(codec, "SKU: swap=0x%x\n", spec->cdefine.swap);
+ codec_dbg(codec, "SKU: override=0x%x\n", spec->cdefine.override);
 
  return 0;
 }
@@ -502,8 +502,8 @@ static int alc_subsystem_id(struct hda_codec *codec, const hda_nid_t *ports)
  if (codec->vendor_id == 0x10ec0260)
   nid = 0x17;
  ass = snd_hda_codec_get_pincfg(codec, nid);
- snd_printd("realtek: No valid SSID, "
-     "checking pincfg 0x%08x for NID 0x%x\n",
+ codec_dbg(codec,
+    "realtek: No valid SSID, checking pincfg 0x%08x for NID 0x%x\n",
      ass, nid);
  if (!(ass & 1))
   return 0;
@@ -519,7 +519,7 @@ static int alc_subsystem_id(struct hda_codec *codec, const hda_nid_t *ports)
  if (((ass >> 16) & 0xf) != tmp)
   return 0;
 do_sku:
- snd_printd("realtek: Enabling init ASM_ID=0x%04x CODEC_ID=%08x\n",
+ codec_dbg(codec, "realtek: Enabling init ASM_ID=0x%04x CODEC_ID=%08x\n",
      ass & 0xffff, codec->vendor_id);
  /*
   * 0 : override
@@ -577,8 +577,8 @@ static void alc_ssid_check(struct hda_codec *codec, const hda_nid_t *ports)
 {
  if (!alc_subsystem_id(codec, ports)) {
   struct alc_spec *spec = codec->spec;
-  snd_printd("realtek: "
-      "Enable default setup for auto mode as fallback\n");
+  codec_dbg(codec,
+     "realtek: Enable default setup for auto mode as fallback\n");
   spec->init_amp = ALC_INIT_DEFAULT;
  }
 }
@@ -3170,7 +3170,8 @@ static void alc269_fixup_hp_mute_led(struct hda_codec *codec,
   spec->gen.vmaster_mute.hook = alc269_fixup_mic_mute_hook;
   spec->gen.vmaster_mute_enum = 1;
   codec->power_filter = led_power_filter;
-  snd_printd("Detected mute LED for %x:%d\n", spec->mute_led_nid,
+  codec_dbg(codec,
+     "Detected mute LED for %x:%d\n", spec->mute_led_nid,
       spec->mute_led_polarity);
   break;
  }
@@ -3296,7 +3297,7 @@ static void alc_headset_mode_unplugged(struct hda_codec *codec)
   alc_write_coef_idx(codec, 0xb7, 0x802b);
   break;
  }
- snd_printdd("Headset jack set to unplugged mode.\n");
+ codec_dbg(codec, "Headset jack set to unplugged mode.\n");
 }
 
 
@@ -3339,7 +3340,7 @@ static void alc_headset_mode_mic_in(struct hda_codec *codec, hda_nid_t hp_pin,
   snd_hda_set_pin_ctl_cache(codec, mic_pin, PIN_VREF50);
   break;
  }
- snd_printdd("Headset jack set to mic-in mode.\n");
+ codec_dbg(codec, "Headset jack set to mic-in mode.\n");
 }
 
 static void alc_headset_mode_default(struct hda_codec *codec)
@@ -3367,7 +3368,7 @@ static void alc_headset_mode_default(struct hda_codec *codec)
   alc_write_coef_idx(codec, 0xb7, 0x802b);
   break;
  }
- snd_printdd("Headset jack set to headphone (default) mode.\n");
+ codec_dbg(codec, "Headset jack set to headphone (default) mode.\n");
 }
 
 /* Iphone type */
@@ -3396,7 +3397,7 @@ static void alc_headset_mode_ctia(struct hda_codec *codec)
   alc_write_coef_idx(codec, 0xc3, 0x0000);
   break;
  }
- snd_printdd("Headset jack set to iPhone-style headset mode.\n");
+ codec_dbg(codec, "Headset jack set to iPhone-style headset mode.\n");
 }
 
 /* Nokia type */
@@ -3425,7 +3426,7 @@ static void alc_headset_mode_omtp(struct hda_codec *codec)
   alc_write_coef_idx(codec, 0xc3, 0x0000);
   break;
  }
- snd_printdd("Headset jack set to Nokia-style headset mode.\n");
+ codec_dbg(codec, "Headset jack set to Nokia-style headset mode.\n");
 }
 
 static void alc_determine_headset_type(struct hda_codec *codec)
@@ -3467,7 +3468,7 @@ static void alc_determine_headset_type(struct hda_codec *codec)
   break;
  }
 
- snd_printdd("Headset jack detected iPhone-style headset: %s\n",
+ codec_dbg(codec, "Headset jack detected iPhone-style headset: %s\n",
       is_ctia ? "yes" : "no");
  spec->current_headset_type = is_ctia ? ALC_HEADSET_TYPE_CTIA : ALC_HEADSET_TYPE_OMTP;
 }
@@ -4901,8 +4902,7 @@ static void alc272_fixup_mario(struct hda_codec *codec,
           (0x3b << AC_AMPCAP_NUM_STEPS_SHIFT) |
           (0x03 << AC_AMPCAP_STEP_SIZE_SHIFT) |
           (0 << AC_AMPCAP_MUTE_SHIFT)))
-  printk(KERN_WARNING
-         "hda_codec: failed to override amp caps for NID 0x2\n");
+  codec_warn(codec, "failed to override amp caps for NID 0x2\n");
 }
 
 static const struct snd_pcm_chmap_elem asus_pcm_2_1_chmaps[] = {
diff --git a/sound/pci/hda/patch_si3054.c b/sound/pci/hda/patch_si3054.c
index 6679a50..3208ad6 100644
--- a/sound/pci/hda/patch_si3054.c
+++ b/sound/pci/hda/patch_si3054.c
@@ -236,7 +236,7 @@ static int si3054_init(struct hda_codec *codec)
  } while ((val & SI3054_MEI_READY) != SI3054_MEI_READY && wait_count--);
 
  if((val&SI3054_MEI_READY) != SI3054_MEI_READY) {
-  snd_printk(KERN_ERR "si3054: cannot initialize. EXT MID = %04x\n", val);
+  codec_err(codec, "si3054: cannot initialize. EXT MID = %04x\n", val);
   /* let's pray that this is no fatal error */
   /* return -EACCES; */
  }
@@ -247,7 +247,8 @@ static int si3054_init(struct hda_codec *codec)
  SET_REG(codec, SI3054_LINE_CFG1,0x200);
 
  if((GET_REG(codec,SI3054_LINE_STATUS) & (1<<6)) == 0) {
-  snd_printd("Link Frame Detect(FDT) is not ready (line status: %04x)\n",
+  codec_dbg(codec,
+     "Link Frame Detect(FDT) is not ready (line status: %04x)\n",
     GET_REG(codec,SI3054_LINE_STATUS));
  }
 
diff --git a/sound/pci/hda/patch_sigmatel.c b/sound/pci/hda/patch_sigmatel.c
index 3bc29c9..f378480 100644
--- a/sound/pci/hda/patch_sigmatel.c
+++ b/sound/pci/hda/patch_sigmatel.c
@@ -296,7 +296,7 @@ static void stac_gpio_set(struct hda_codec *codec, unsigned int mask,
 {
  unsigned int gpiostate, gpiomask, gpiodir;
 
- snd_printdd("%s msk %x dir %x gpio %x\n", __func__, mask, dir_mask, data);
+ codec_dbg(codec, "%s msk %x dir %x gpio %x\n", __func__, mask, dir_mask, data);
 
  gpiostate = snd_hda_codec_read(codec, codec->afg, 0,
            AC_VERB_GET_GPIO_DATA, 0);
@@ -359,7 +359,7 @@ static int stac_vrefout_set(struct hda_codec *codec,
 {
  int error, pinctl;
 
- snd_printdd("%s, nid %x ctl %x\n", __func__, nid, new_vref);
+ codec_dbg(codec, "%s, nid %x ctl %x\n", __func__, nid, new_vref);
  pinctl = snd_hda_codec_read(codec, nid, 0,
     AC_VERB_GET_PIN_WIDGET_CONTROL, 0);
 
@@ -2086,7 +2086,7 @@ static void stac92hd83xxx_fixup_hp(struct hda_codec *codec,
  }
 
  if (find_mute_led_cfg(codec, spec->default_polarity))
-  snd_printd("mute LED gpio %d polarity %d\n",
+  codec_dbg(codec, "mute LED gpio %d polarity %d\n",
     spec->gpio_led,
     spec->gpio_led_polarity);
 }
@@ -3077,7 +3077,7 @@ static void stac92hd71bxx_fixup_hp(struct hda_codec *codec,
  }
 
  if (find_mute_led_cfg(codec, 1))
-  snd_printd("mute LED gpio %d polarity %d\n",
+  codec_dbg(codec, "mute LED gpio %d polarity %d\n",
     spec->gpio_led,
     spec->gpio_led_polarity);
 
@@ -4422,8 +4422,8 @@ static int patch_stac92hd73xx(struct hda_codec *codec)
 
  num_dacs = snd_hda_get_num_conns(codec, 0x0a) - 1;
  if (num_dacs < 3 || num_dacs > 5) {
-  printk(KERN_WARNING "hda_codec: Could not determine "
-         "number of channels defaulting to DAC count\n");
+  codec_warn(codec,
+      "Could not determine number of channels defaulting to DAC count\n");
   num_dacs = 5;
  }
 
diff --git a/sound/pci/hda/thinkpad_helper.c b/sound/pci/hda/thinkpad_helper.c
index 8fe3b8c..6ba0b55 100644
--- a/sound/pci/hda/thinkpad_helper.c
+++ b/sound/pci/hda/thinkpad_helper.c
@@ -63,7 +63,8 @@ static void hda_fixup_thinkpad_acpi(struct hda_codec *codec,
   if (!led_set_func)
    led_set_func = symbol_request(tpacpi_led_set);
   if (!led_set_func) {
-   snd_printk(KERN_WARNING "Failed to find thinkpad-acpi symbol tpacpi_led_set\n");
+   codec_warn(codec,
+       "Failed to find thinkpad-acpi symbol tpacpi_led_set\n");
    return;
   }
 
@@ -75,7 +76,8 @@ static void hda_fixup_thinkpad_acpi(struct hda_codec *codec,
   }
   if (led_set_func(TPACPI_LED_MICMUTE, false) >= 0) {
    if (spec->num_adc_nids > 1)
-    snd_printdd("Skipping micmute LED control due to several ADCs");
+    codec_dbg(codec,
+       "Skipping micmute LED control due to several ADCs");
    else {
     spec->cap_sync_hook = update_tpacpi_micmute_led;
     removefunc = false;
-- 
1.7.1