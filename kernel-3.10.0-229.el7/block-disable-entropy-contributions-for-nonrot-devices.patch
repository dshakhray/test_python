From 9a2bc387aed4b8b81fe84a0131e22fa3f6348309 Mon Sep 17 00:00:00 2001
From: Mike Snitzer <snitzer@redhat.com>
Date: Mon, 6 Oct 2014 20:56:15 -0400
Subject: [block] disable entropy contributions for nonrot devices

Message-id: <1412628975-32753-1-git-send-email-snitzer@redhat.com>
Patchwork-id: 96938
O-Subject: [RHEL7.1] block: disable entropy contributions for nonrot devices
Bugzilla: 852425
RH-Acked-by: Jes Sorensen <Jes.Sorensen@redhat.com>
RH-Acked-by: Mikulas Patocka <mpatocka@redhat.com>

BZ: 852425

Dropped upstream changes to drivers/block/skd_main.c and
drivers/block/zram/zram_drv.c since RHEL7 doesn't have these drivers.
Also dropped the change to bcache since I know RHEL7 doesn't enable
it.

But I may still be patching "DEAD CODE".  Hopefully the maintainer(s)
filter out any offending hunks.

This commit is staged in Jens' linux-block.git 'for-3.18/drivers'
branch.

Upstream linux-block.git commit b277da0a8a594308e17881f4926879bd5fca2a2d
Author: Mike Snitzer <snitzer@redhat.com>
Date:   Sat Oct 4 10:55:32 2014 -0600

    block: disable entropy contributions for nonrot devices

    Clear QUEUE_FLAG_ADD_RANDOM in all block drivers that set
    QUEUE_FLAG_NONROT.

    Historically, all block devices have automatically made entropy
    contributions.  But as previously stated in commit e2e1a148 ("block: add
    sysfs knob for turning off disk entropy contributions"):
        - On SSD disks, the completion times aren't as random as they
          are for rotational drives. So it's questionable whether they
          should contribute to the random pool in the first place.
        - Calling add_disk_randomness() has a lot of overhead.

    There are more reliable sources for randomness than non-rotational block
    devices.  From a security perspective it is better to err on the side of
    caution than to allow entropy contributions from unreliable "random"
    sources.

    Signed-off-by: Mike Snitzer <snitzer@redhat.com>
    Signed-off-by: Jens Axboe <axboe@fb.com>

Signed-off-by: Jarod Wilson <jarod@redhat.com>

diff --git a/drivers/block/mtip32xx/mtip32xx.c b/drivers/block/mtip32xx/mtip32xx.c
index 9f86fb6..07f8a1d 100644
--- a/drivers/block/mtip32xx/mtip32xx.c
+++ b/drivers/block/mtip32xx/mtip32xx.c
@@ -3952,6 +3952,7 @@ skip_create_disk:
 
  /* Set device limits. */
  set_bit(QUEUE_FLAG_NONROT, &dd->queue->queue_flags);
+ clear_bit(QUEUE_FLAG_ADD_RANDOM, &dd->queue->queue_flags);
  blk_queue_max_segments(dd->queue, MTIP_MAX_SG);
  blk_queue_physical_block_size(dd->queue, 4096);
  blk_queue_max_hw_sectors(dd->queue, 0xffff);
diff --git a/drivers/block/nbd.c b/drivers/block/nbd.c
index cf1576d..7f9fc0d 100644
--- a/drivers/block/nbd.c
+++ b/drivers/block/nbd.c
@@ -859,6 +859,7 @@ static int __init nbd_init(void)
    * Tell the block layer that we are not a rotational device
    */
   queue_flag_set_unlocked(QUEUE_FLAG_NONROT, disk->queue);
+  queue_flag_clear_unlocked(QUEUE_FLAG_ADD_RANDOM, disk->queue);
   disk->queue->limits.discard_granularity = 512;
   disk->queue->limits.max_discard_sectors = UINT_MAX;
   disk->queue->limits.discard_zeroes_data = 0;
diff --git a/drivers/block/null_blk.c b/drivers/block/null_blk.c
index d58bf88..3f16cd7 100644
--- a/drivers/block/null_blk.c
+++ b/drivers/block/null_blk.c
@@ -504,6 +504,7 @@ static int null_add_dev(void)
 
  nullb->q->queuedata = nullb;
  queue_flag_set_unlocked(QUEUE_FLAG_NONROT, nullb->q);
+ queue_flag_clear_unlocked(QUEUE_FLAG_ADD_RANDOM, nullb->q);
 
  disk = nullb->disk = alloc_disk_node(1, home_node);
  if (!disk)
diff --git a/drivers/block/nvme-core.c b/drivers/block/nvme-core.c
index eda23cb..fd58bc7 100644
--- a/drivers/block/nvme-core.c
+++ b/drivers/block/nvme-core.c
@@ -1998,6 +1998,7 @@ static struct nvme_ns *nvme_alloc_ns(struct nvme_dev *dev, unsigned nsid,
  ns->queue->queue_flags = QUEUE_FLAG_DEFAULT;
  queue_flag_set_unlocked(QUEUE_FLAG_NOMERGES, ns->queue);
  queue_flag_set_unlocked(QUEUE_FLAG_NONROT, ns->queue);
+ queue_flag_clear_unlocked(QUEUE_FLAG_ADD_RANDOM, ns->queue);
  blk_queue_make_request(ns->queue, nvme_make_request);
  ns->dev = dev;
  ns->queue->queuedata = ns;
diff --git a/drivers/block/rsxx/dev.c b/drivers/block/rsxx/dev.c
index 2284f5d..67dfe37 100644
--- a/drivers/block/rsxx/dev.c
+++ b/drivers/block/rsxx/dev.c
@@ -307,6 +307,7 @@ int rsxx_setup_dev(struct rsxx_cardinfo *card)
  blk_queue_physical_block_size(card->queue, RSXX_HW_BLK_SIZE);
 
  queue_flag_set_unlocked(QUEUE_FLAG_NONROT, card->queue);
+ queue_flag_clear_unlocked(QUEUE_FLAG_ADD_RANDOM, card->queue);
  if (rsxx_discard_supported(card)) {
   queue_flag_set_unlocked(QUEUE_FLAG_DISCARD, card->queue);
   blk_queue_max_discard_sectors(card->queue,
diff --git a/drivers/ide/ide-disk.c b/drivers/ide/ide-disk.c
index 16f69be..121071f 100644
--- a/drivers/ide/ide-disk.c
+++ b/drivers/ide/ide-disk.c
@@ -686,8 +686,10 @@ static void ide_disk_setup(ide_drive_t *drive)
  printk(KERN_INFO "%s: max request size: %dKiB\n", drive->name,
         queue_max_sectors(q) / 2);
 
- if (ata_id_is_ssd(id))
+ if (ata_id_is_ssd(id)) {
   queue_flag_set_unlocked(QUEUE_FLAG_NONROT, q);
+  queue_flag_clear_unlocked(QUEUE_FLAG_ADD_RANDOM, q);
+ }
 
  /* calculate drive capacity, and select LBA if possible */
  ide_disk_get_capacity(drive);
diff --git a/drivers/mmc/card/queue.c b/drivers/mmc/card/queue.c
index 9447a0e..b4cfaba 100644
--- a/drivers/mmc/card/queue.c
+++ b/drivers/mmc/card/queue.c
@@ -209,6 +209,7 @@ int mmc_init_queue(struct mmc_queue *mq, struct mmc_card *card,
 
  blk_queue_prep_rq(mq->queue, mmc_prep_request);
  queue_flag_set_unlocked(QUEUE_FLAG_NONROT, mq->queue);
+ queue_flag_clear_unlocked(QUEUE_FLAG_ADD_RANDOM, mq->queue);
  if (mmc_can_erase(card))
   mmc_queue_setup_discard(mq->queue, card);
 
diff --git a/drivers/mtd/mtd_blkdevs.c b/drivers/mtd/mtd_blkdevs.c
index 5073cbc..a7ca480 100644
--- a/drivers/mtd/mtd_blkdevs.c
+++ b/drivers/mtd/mtd_blkdevs.c
@@ -413,6 +413,7 @@ int add_mtd_blktrans_dev(struct mtd_blktrans_dev *new)
  blk_queue_logical_block_size(new->rq, tr->blksize);
 
  queue_flag_set_unlocked(QUEUE_FLAG_NONROT, new->rq);
+ queue_flag_clear_unlocked(QUEUE_FLAG_ADD_RANDOM, new->rq);
 
  if (tr->discard) {
   queue_flag_set_unlocked(QUEUE_FLAG_DISCARD, new->rq);
diff --git a/drivers/s390/block/scm_blk.c b/drivers/s390/block/scm_blk.c
index 3c511d6..b2ecdc8 100644
--- a/drivers/s390/block/scm_blk.c
+++ b/drivers/s390/block/scm_blk.c
@@ -382,6 +382,7 @@ int scm_blk_dev_setup(struct scm_blk_dev *bdev, struct scm_device *scmdev)
  blk_queue_max_hw_sectors(rq, nr_max_blk << 3); /* 8 * 512 = blk_size */
  blk_queue_max_segments(rq, nr_max_blk);
  queue_flag_set_unlocked(QUEUE_FLAG_NONROT, rq);
+ queue_flag_clear_unlocked(QUEUE_FLAG_ADD_RANDOM, rq);
  scm_blk_dev_cluster_setup(bdev);
 
  bdev->gendisk = alloc_disk(SCM_NR_PARTS);
diff --git a/drivers/s390/block/xpram.c b/drivers/s390/block/xpram.c
index 464dd29..324a8cd 100644
--- a/drivers/s390/block/xpram.c
+++ b/drivers/s390/block/xpram.c
@@ -344,6 +344,7 @@ static int __init xpram_setup_blkdev(void)
    goto out;
   }
   queue_flag_set_unlocked(QUEUE_FLAG_NONROT, xpram_queues[i]);
+  queue_flag_clear_unlocked(QUEUE_FLAG_ADD_RANDOM, xpram_queues[i]);
   blk_queue_make_request(xpram_queues[i], xpram_make_request);
   blk_queue_logical_block_size(xpram_queues[i], 4096);
  }
diff --git a/drivers/scsi/sd.c b/drivers/scsi/sd.c
index 3bc6b66..495e8a7 100644
--- a/drivers/scsi/sd.c
+++ b/drivers/scsi/sd.c
@@ -2612,8 +2612,10 @@ static void sd_read_block_characteristics(struct scsi_disk *sdkp)
 
  rot = get_unaligned_be16(&buffer[4]);
 
- if (rot == 1)
+ if (rot == 1) {
   queue_flag_set_unlocked(QUEUE_FLAG_NONROT, sdkp->disk->queue);
+  queue_flag_clear_unlocked(QUEUE_FLAG_ADD_RANDOM, sdkp->disk->queue);
+ }
 
  out:
  kfree(buffer);
-- 
1.7.1