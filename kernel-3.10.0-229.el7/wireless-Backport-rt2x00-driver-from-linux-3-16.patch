From ab20f79d3ed4158907248a6f34ae1d07380cb645 Mon Sep 17 00:00:00 2001
From: Stanislaw Gruszka <sgruszka@redhat.com>
Date: Fri, 5 Sep 2014 11:23:48 -0400
Subject: [wireless] Backport rt2x00 driver from linux 3.16

Message-id: <1409916232-5882-12-git-send-email-sgruszka@redhat.com>
Patchwork-id: 91440
O-Subject: [RHEL7 PATCH 11/15] Backport rt2x00 driver from linux 3.16
Bugzilla: 1136324
RH-Acked-by: John Linville <linville@redhat.com>
RH-Acked-by: Prarit Bhargava <prarit@redhat.com>
RH-Acked-by: John Greene <jogreene@redhat.com>

BZ#1136324

Decription:
Sync rt2x00 driver to code from linux 3.16 (up to commit
19583ca584d6f574384e17fe7613dfaeadcdc4a6).

Brew:
https://brewweb.devel.redhat.com/taskinfo?taskID=7918052

Testing:
Tested on RT3572 and RT3071 devices.

Signed-off-by: Jarod Wilson <jarod@redhat.com>

diff --git a/drivers/net/wireless/rt2x00/Kconfig b/drivers/net/wireless/rt2x00/Kconfig
index 9b915d3..006b8bc 100644
--- a/drivers/net/wireless/rt2x00/Kconfig
+++ b/drivers/net/wireless/rt2x00/Kconfig
@@ -1,6 +1,6 @@
 menuconfig RT2X00
  tristate "Ralink driver support"
- depends on MAC80211
+ depends on MAC80211 && HAS_DMA
  ---help---
    This will enable the support for the Ralink drivers,
    developed in the rt2x00 project <http://rt2x00.serialmonkey.com>.
@@ -58,11 +58,11 @@ config RT61PCI
 
 config RT2800PCI
  tristate "Ralink rt27xx/rt28xx/rt30xx (PCI/PCIe/PCMCIA) support"
- depends on PCI || SOC_RT288X || SOC_RT305X
+ depends on PCI
  select RT2800_LIB
+ select RT2800_LIB_MMIO
  select RT2X00_LIB_MMIO
- select RT2X00_LIB_PCI if PCI
- select RT2X00_LIB_SOC if SOC_RT288X || SOC_RT305X
+ select RT2X00_LIB_PCI
  select RT2X00_LIB_FIRMWARE
  select RT2X00_LIB_CRYPTO
  select CRC_CCITT
@@ -166,6 +166,12 @@ config RT2800USB_RT35XX
    rt2800usb driver.
    Supported chips: RT3572
 
+config RT2800USB_RT3573
+ bool "rt2800usb - Include support for rt3573 devices (EXPERIMENTAL)"
+ ---help---
+   This enables support for RT3573 chipset based wireless USB devices
+   in the rt2800usb driver.
+
 config RT2800USB_RT53XX
        bool "rt2800usb - Include support for rt53xx devices (EXPERIMENTAL)"
        ---help---
@@ -193,9 +199,30 @@ config RT2800USB_UNKNOWN
 
 endif
 
+config RT2800SOC
+ tristate "Ralink WiSoC support"
+ depends on SOC_RT288X || SOC_RT305X
+ select RT2X00_LIB_SOC
+ select RT2X00_LIB_MMIO
+ select RT2X00_LIB_CRYPTO
+ select RT2X00_LIB_FIRMWARE
+ select RT2800_LIB
+ select RT2800_LIB_MMIO
+ ---help---
+   This adds support for Ralink WiSoC devices.
+   Supported chips: RT2880, RT3050, RT3052, RT3350, RT3352.
+
+   When compiled as a module, this driver will be called rt2800soc.
+
+
 config RT2800_LIB
  tristate
 
+config RT2800_LIB_MMIO
+ tristate
+ select RT2X00_LIB_MMIO
+ select RT2800_LIB
+
 config RT2X00_LIB_MMIO
  tristate
 
@@ -213,6 +240,7 @@ config RT2X00_LIB_USB
 
 config RT2X00_LIB
  tristate
+ select AVERAGE
 
 config RT2X00_LIB_FIRMWARE
  boolean
diff --git a/drivers/net/wireless/rt2x00/Makefile b/drivers/net/wireless/rt2x00/Makefile
index f069d8b..24a6601 100644
--- a/drivers/net/wireless/rt2x00/Makefile
+++ b/drivers/net/wireless/rt2x00/Makefile
@@ -14,6 +14,7 @@ obj-$(CONFIG_RT2X00_LIB_PCI)  += rt2x00pci.o
 obj-$(CONFIG_RT2X00_LIB_SOC)  += rt2x00soc.o
 obj-$(CONFIG_RT2X00_LIB_USB)  += rt2x00usb.o
 obj-$(CONFIG_RT2800_LIB)  += rt2800lib.o
+obj-$(CONFIG_RT2800_LIB_MMIO)  += rt2800mmio.o
 obj-$(CONFIG_RT2400PCI)   += rt2400pci.o
 obj-$(CONFIG_RT2500PCI)   += rt2500pci.o
 obj-$(CONFIG_RT61PCI)   += rt61pci.o
@@ -21,3 +22,4 @@ obj-$(CONFIG_RT2800PCI)   += rt2800pci.o
 obj-$(CONFIG_RT2500USB)   += rt2500usb.o
 obj-$(CONFIG_RT73USB)   += rt73usb.o
 obj-$(CONFIG_RT2800USB)   += rt2800usb.o
+obj-$(CONFIG_RT2800SOC)   += rt2800soc.o
diff --git a/drivers/net/wireless/rt2x00/rt2400pci.c b/drivers/net/wireless/rt2x00/rt2400pci.c
index a3a2dcd..4ccfef5 100644
--- a/drivers/net/wireless/rt2x00/rt2400pci.c
+++ b/drivers/net/wireless/rt2x00/rt2400pci.c
@@ -13,9 +13,7 @@
  GNU General Public License for more details.
 
  You should have received a copy of the GNU General Public License
- along with this program; if not, write to the
- Free Software Foundation, Inc.,
- 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ along with this program; if not, see <http://www.gnu.org/licenses/>.
  */
 
 /*
@@ -26,7 +24,6 @@
 
 #include <linux/delay.h>
 #include <linux/etherdevice.h>
-#include <linux/init.h>
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/pci.h>
@@ -1767,33 +1764,45 @@ static const struct rt2x00lib_ops rt2400pci_rt2x00_ops = {
  .config   = rt2400pci_config,
 };
 
-static const struct data_queue_desc rt2400pci_queue_rx = {
- .entry_num  = 24,
- .data_size  = DATA_FRAME_SIZE,
- .desc_size  = RXD_DESC_SIZE,
- .priv_size  = sizeof(struct queue_entry_priv_mmio),
-};
+static void rt2400pci_queue_init(struct data_queue *queue)
+{
+ switch (queue->qid) {
+ case QID_RX:
+  queue->limit = 24;
+  queue->data_size = DATA_FRAME_SIZE;
+  queue->desc_size = RXD_DESC_SIZE;
+  queue->priv_size = sizeof(struct queue_entry_priv_mmio);
+  break;
 
-static const struct data_queue_desc rt2400pci_queue_tx = {
- .entry_num  = 24,
- .data_size  = DATA_FRAME_SIZE,
- .desc_size  = TXD_DESC_SIZE,
- .priv_size  = sizeof(struct queue_entry_priv_mmio),
-};
+ case QID_AC_VO:
+ case QID_AC_VI:
+ case QID_AC_BE:
+ case QID_AC_BK:
+  queue->limit = 24;
+  queue->data_size = DATA_FRAME_SIZE;
+  queue->desc_size = TXD_DESC_SIZE;
+  queue->priv_size = sizeof(struct queue_entry_priv_mmio);
+  break;
 
-static const struct data_queue_desc rt2400pci_queue_bcn = {
- .entry_num  = 1,
- .data_size  = MGMT_FRAME_SIZE,
- .desc_size  = TXD_DESC_SIZE,
- .priv_size  = sizeof(struct queue_entry_priv_mmio),
-};
+ case QID_BEACON:
+  queue->limit = 1;
+  queue->data_size = MGMT_FRAME_SIZE;
+  queue->desc_size = TXD_DESC_SIZE;
+  queue->priv_size = sizeof(struct queue_entry_priv_mmio);
+  break;
 
-static const struct data_queue_desc rt2400pci_queue_atim = {
- .entry_num  = 8,
- .data_size  = DATA_FRAME_SIZE,
- .desc_size  = TXD_DESC_SIZE,
- .priv_size  = sizeof(struct queue_entry_priv_mmio),
-};
+ case QID_ATIM:
+  queue->limit = 8;
+  queue->data_size = DATA_FRAME_SIZE;
+  queue->desc_size = TXD_DESC_SIZE;
+  queue->priv_size = sizeof(struct queue_entry_priv_mmio);
+  break;
+
+ default:
+  BUG();
+  break;
+ }
+}
 
 static const struct rt2x00_ops rt2400pci_ops = {
  .name   = KBUILD_MODNAME,
@@ -1801,11 +1810,7 @@ static const struct rt2x00_ops rt2400pci_ops = {
  .eeprom_size  = EEPROM_SIZE,
  .rf_size  = RF_SIZE,
  .tx_queues  = NUM_TX_QUEUES,
- .extra_tx_headroom = 0,
- .rx   = &rt2400pci_queue_rx,
- .tx   = &rt2400pci_queue_tx,
- .bcn   = &rt2400pci_queue_bcn,
- .atim   = &rt2400pci_queue_atim,
+ .queue_init  = rt2400pci_queue_init,
  .lib   = &rt2400pci_rt2x00_ops,
  .hw   = &rt2400pci_mac80211_ops,
 #ifdef CONFIG_RT2X00_LIB_DEBUGFS
diff --git a/drivers/net/wireless/rt2x00/rt2400pci.h b/drivers/net/wireless/rt2x00/rt2400pci.h
index e4b07f0..0fd3a9d 100644
--- a/drivers/net/wireless/rt2x00/rt2400pci.h
+++ b/drivers/net/wireless/rt2x00/rt2400pci.h
@@ -13,9 +13,7 @@
  GNU General Public License for more details.
 
  You should have received a copy of the GNU General Public License
- along with this program; if not, write to the
- Free Software Foundation, Inc.,
- 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ along with this program; if not, see <http://www.gnu.org/licenses/>.
  */
 
 /*
diff --git a/drivers/net/wireless/rt2x00/rt2500pci.c b/drivers/net/wireless/rt2x00/rt2500pci.c
index 77e45b2..a511ccc 100644
--- a/drivers/net/wireless/rt2x00/rt2500pci.c
+++ b/drivers/net/wireless/rt2x00/rt2500pci.c
@@ -13,9 +13,7 @@
  GNU General Public License for more details.
 
  You should have received a copy of the GNU General Public License
- along with this program; if not, write to the
- Free Software Foundation, Inc.,
- 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ along with this program; if not, see <http://www.gnu.org/licenses/>.
  */
 
 /*
@@ -26,7 +24,6 @@
 
 #include <linux/delay.h>
 #include <linux/etherdevice.h>
-#include <linux/init.h>
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/pci.h>
@@ -1684,8 +1681,13 @@ static int rt2500pci_init_eeprom(struct rt2x00_dev *rt2x00dev)
  /*
   * Detect if this device has an hardware controlled radio.
   */
- if (rt2x00_get_field16(eeprom, EEPROM_ANTENNA_HARDWARE_RADIO))
+ if (rt2x00_get_field16(eeprom, EEPROM_ANTENNA_HARDWARE_RADIO)) {
   __set_bit(CAPABILITY_HW_BUTTON, &rt2x00dev->cap_flags);
+  /*
+   * On this device RFKILL initialized during probe does not work.
+   */
+  __set_bit(REQUIRE_DELAYED_RFKILL, &rt2x00dev->cap_flags);
+ }
 
  /*
   * Check if the BBP tuning should be enabled.
@@ -1880,6 +1882,11 @@ static int rt2500pci_probe_hw_mode(struct rt2x00_dev *rt2x00dev)
          EEPROM_MAC_ADDR_0));
 
  /*
+  * Disable powersaving as default.
+  */
+ rt2x00dev->hw->wiphy->flags &= ~WIPHY_FLAG_PS_ON_BY_DEFAULT;
+
+ /*
   * Initialize hw_mode information.
   */
  spec->supported_bands = SUPPORT_BAND_2GHZ;
@@ -2056,33 +2063,45 @@ static const struct rt2x00lib_ops rt2500pci_rt2x00_ops = {
  .config   = rt2500pci_config,
 };
 
-static const struct data_queue_desc rt2500pci_queue_rx = {
- .entry_num  = 32,
- .data_size  = DATA_FRAME_SIZE,
- .desc_size  = RXD_DESC_SIZE,
- .priv_size  = sizeof(struct queue_entry_priv_mmio),
-};
+static void rt2500pci_queue_init(struct data_queue *queue)
+{
+ switch (queue->qid) {
+ case QID_RX:
+  queue->limit = 32;
+  queue->data_size = DATA_FRAME_SIZE;
+  queue->desc_size = RXD_DESC_SIZE;
+  queue->priv_size = sizeof(struct queue_entry_priv_mmio);
+  break;
 
-static const struct data_queue_desc rt2500pci_queue_tx = {
- .entry_num  = 32,
- .data_size  = DATA_FRAME_SIZE,
- .desc_size  = TXD_DESC_SIZE,
- .priv_size  = sizeof(struct queue_entry_priv_mmio),
-};
+ case QID_AC_VO:
+ case QID_AC_VI:
+ case QID_AC_BE:
+ case QID_AC_BK:
+  queue->limit = 32;
+  queue->data_size = DATA_FRAME_SIZE;
+  queue->desc_size = TXD_DESC_SIZE;
+  queue->priv_size = sizeof(struct queue_entry_priv_mmio);
+  break;
 
-static const struct data_queue_desc rt2500pci_queue_bcn = {
- .entry_num  = 1,
- .data_size  = MGMT_FRAME_SIZE,
- .desc_size  = TXD_DESC_SIZE,
- .priv_size  = sizeof(struct queue_entry_priv_mmio),
-};
+ case QID_BEACON:
+  queue->limit = 1;
+  queue->data_size = MGMT_FRAME_SIZE;
+  queue->desc_size = TXD_DESC_SIZE;
+  queue->priv_size = sizeof(struct queue_entry_priv_mmio);
+  break;
 
-static const struct data_queue_desc rt2500pci_queue_atim = {
- .entry_num  = 8,
- .data_size  = DATA_FRAME_SIZE,
- .desc_size  = TXD_DESC_SIZE,
- .priv_size  = sizeof(struct queue_entry_priv_mmio),
-};
+ case QID_ATIM:
+  queue->limit = 8;
+  queue->data_size = DATA_FRAME_SIZE;
+  queue->desc_size = TXD_DESC_SIZE;
+  queue->priv_size = sizeof(struct queue_entry_priv_mmio);
+  break;
+
+ default:
+  BUG();
+  break;
+ }
+}
 
 static const struct rt2x00_ops rt2500pci_ops = {
  .name   = KBUILD_MODNAME,
@@ -2090,11 +2109,7 @@ static const struct rt2x00_ops rt2500pci_ops = {
  .eeprom_size  = EEPROM_SIZE,
  .rf_size  = RF_SIZE,
  .tx_queues  = NUM_TX_QUEUES,
- .extra_tx_headroom = 0,
- .rx   = &rt2500pci_queue_rx,
- .tx   = &rt2500pci_queue_tx,
- .bcn   = &rt2500pci_queue_bcn,
- .atim   = &rt2500pci_queue_atim,
+ .queue_init  = rt2500pci_queue_init,
  .lib   = &rt2500pci_rt2x00_ops,
  .hw   = &rt2500pci_mac80211_ops,
 #ifdef CONFIG_RT2X00_LIB_DEBUGFS
diff --git a/drivers/net/wireless/rt2x00/rt2500pci.h b/drivers/net/wireless/rt2x00/rt2500pci.h
index 9c10068..573e87b 100644
--- a/drivers/net/wireless/rt2x00/rt2500pci.h
+++ b/drivers/net/wireless/rt2x00/rt2500pci.h
@@ -13,9 +13,7 @@
  GNU General Public License for more details.
 
  You should have received a copy of the GNU General Public License
- along with this program; if not, write to the
- Free Software Foundation, Inc.,
- 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ along with this program; if not, see <http://www.gnu.org/licenses/>.
  */
 
 /*
diff --git a/drivers/net/wireless/rt2x00/rt2500usb.c b/drivers/net/wireless/rt2x00/rt2500usb.c
index a7f7b36..d849d59 100644
--- a/drivers/net/wireless/rt2x00/rt2500usb.c
+++ b/drivers/net/wireless/rt2x00/rt2500usb.c
@@ -13,9 +13,7 @@
  GNU General Public License for more details.
 
  You should have received a copy of the GNU General Public License
- along with this program; if not, write to the
- Free Software Foundation, Inc.,
- 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ along with this program; if not, see <http://www.gnu.org/licenses/>.
  */
 
 /*
@@ -26,7 +24,6 @@
 
 #include <linux/delay.h>
 #include <linux/etherdevice.h>
-#include <linux/init.h>
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/slab.h>
@@ -1709,6 +1706,11 @@ static int rt2500usb_probe_hw_mode(struct rt2x00_dev *rt2x00dev)
      IEEE80211_HW_SUPPORTS_PS |
      IEEE80211_HW_PS_NULLFUNC_STACK;
 
+ /*
+  * Disable powersaving as default.
+  */
+ rt2x00dev->hw->wiphy->flags &= ~WIPHY_FLAG_PS_ON_BY_DEFAULT;
+
  SET_IEEE80211_DEV(rt2x00dev->hw, rt2x00dev->dev);
  SET_IEEE80211_PERM_ADDR(rt2x00dev->hw,
     rt2x00_eeprom_addr(rt2x00dev,
@@ -1867,33 +1869,45 @@ static const struct rt2x00lib_ops rt2500usb_rt2x00_ops = {
  .config   = rt2500usb_config,
 };
 
-static const struct data_queue_desc rt2500usb_queue_rx = {
- .entry_num  = 32,
- .data_size  = DATA_FRAME_SIZE,
- .desc_size  = RXD_DESC_SIZE,
- .priv_size  = sizeof(struct queue_entry_priv_usb),
-};
+static void rt2500usb_queue_init(struct data_queue *queue)
+{
+ switch (queue->qid) {
+ case QID_RX:
+  queue->limit = 32;
+  queue->data_size = DATA_FRAME_SIZE;
+  queue->desc_size = RXD_DESC_SIZE;
+  queue->priv_size = sizeof(struct queue_entry_priv_usb);
+  break;
 
-static const struct data_queue_desc rt2500usb_queue_tx = {
- .entry_num  = 32,
- .data_size  = DATA_FRAME_SIZE,
- .desc_size  = TXD_DESC_SIZE,
- .priv_size  = sizeof(struct queue_entry_priv_usb),
-};
+ case QID_AC_VO:
+ case QID_AC_VI:
+ case QID_AC_BE:
+ case QID_AC_BK:
+  queue->limit = 32;
+  queue->data_size = DATA_FRAME_SIZE;
+  queue->desc_size = TXD_DESC_SIZE;
+  queue->priv_size = sizeof(struct queue_entry_priv_usb);
+  break;
 
-static const struct data_queue_desc rt2500usb_queue_bcn = {
- .entry_num  = 1,
- .data_size  = MGMT_FRAME_SIZE,
- .desc_size  = TXD_DESC_SIZE,
- .priv_size  = sizeof(struct queue_entry_priv_usb_bcn),
-};
+ case QID_BEACON:
+  queue->limit = 1;
+  queue->data_size = MGMT_FRAME_SIZE;
+  queue->desc_size = TXD_DESC_SIZE;
+  queue->priv_size = sizeof(struct queue_entry_priv_usb_bcn);
+  break;
 
-static const struct data_queue_desc rt2500usb_queue_atim = {
- .entry_num  = 8,
- .data_size  = DATA_FRAME_SIZE,
- .desc_size  = TXD_DESC_SIZE,
- .priv_size  = sizeof(struct queue_entry_priv_usb),
-};
+ case QID_ATIM:
+  queue->limit = 8;
+  queue->data_size = DATA_FRAME_SIZE;
+  queue->desc_size = TXD_DESC_SIZE;
+  queue->priv_size = sizeof(struct queue_entry_priv_usb);
+  break;
+
+ default:
+  BUG();
+  break;
+ }
+}
 
 static const struct rt2x00_ops rt2500usb_ops = {
  .name   = KBUILD_MODNAME,
@@ -1901,11 +1915,7 @@ static const struct rt2x00_ops rt2500usb_ops = {
  .eeprom_size  = EEPROM_SIZE,
  .rf_size  = RF_SIZE,
  .tx_queues  = NUM_TX_QUEUES,
- .extra_tx_headroom = TXD_DESC_SIZE,
- .rx   = &rt2500usb_queue_rx,
- .tx   = &rt2500usb_queue_tx,
- .bcn   = &rt2500usb_queue_bcn,
- .atim   = &rt2500usb_queue_atim,
+ .queue_init  = rt2500usb_queue_init,
  .lib   = &rt2500usb_rt2x00_ops,
  .hw   = &rt2500usb_mac80211_ops,
 #ifdef CONFIG_RT2X00_LIB_DEBUGFS
diff --git a/drivers/net/wireless/rt2x00/rt2500usb.h b/drivers/net/wireless/rt2x00/rt2500usb.h
index 1b91a4c..afba073 100644
--- a/drivers/net/wireless/rt2x00/rt2500usb.h
+++ b/drivers/net/wireless/rt2x00/rt2500usb.h
@@ -13,9 +13,7 @@
  GNU General Public License for more details.
 
  You should have received a copy of the GNU General Public License
- along with this program; if not, write to the
- Free Software Foundation, Inc.,
- 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ along with this program; if not, see <http://www.gnu.org/licenses/>.
  */
 
 /*
diff --git a/drivers/net/wireless/rt2x00/rt2800.h b/drivers/net/wireless/rt2x00/rt2800.h
index a7630d5..a394a9a 100644
--- a/drivers/net/wireless/rt2x00/rt2800.h
+++ b/drivers/net/wireless/rt2x00/rt2800.h
@@ -21,9 +21,7 @@
  GNU General Public License for more details.
 
  You should have received a copy of the GNU General Public License
- along with this program; if not, write to the
- Free Software Foundation, Inc.,
- 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ along with this program; if not, see <http://www.gnu.org/licenses/>.
  */
 
 /*
@@ -52,6 +50,7 @@
  * RF3322 2.4G 2T2R(RT3352/RT3371/RT3372/RT3391/RT3392)
  * RF3053 2.4G/5G 3T3R(RT3883/RT3563/RT3573/RT3593/RT3662)
  * RF5592 2.4G/5G 2T2R
+ * RF3070 2.4G 1T1R
  * RF5360 2.4G 1T1R
  * RF5370 2.4G 1T1R
  * RF5390 2.4G 1T1R
@@ -70,6 +69,7 @@
 #define RF3322    0x000c
 #define RF3053    0x000d
 #define RF5592    0x000f
+#define RF3070    0x3070
 #define RF3290    0x3290
 #define RF5360    0x5360
 #define RF5370    0x5370
@@ -88,6 +88,7 @@
 #define REV_RT3071E   0x0211
 #define REV_RT3090E   0x0211
 #define REV_RT3390E   0x0211
+#define REV_RT3593E   0x0211
 #define REV_RT5390F   0x0502
 #define REV_RT5390R   0x1502
 #define REV_RT5592C   0x0221
@@ -100,7 +101,7 @@
 #define CSR_REG_BASE   0x1000
 #define CSR_REG_SIZE   0x0800
 #define EEPROM_BASE   0x0000
-#define EEPROM_SIZE   0x0110
+#define EEPROM_SIZE   0x0200
 #define BBP_BASE   0x0000
 #define BBP_SIZE   0x00ff
 #define RF_BASE    0x0004
@@ -121,7 +122,7 @@
 /*
  * MAC_CSR0_3290: MAC_CSR0 for RT3290 to identity MAC version number.
  */
-#define MAC_CSR0_3290    0x0000
+#define MAC_CSR0_3290   0x0000
 
 /*
  * E2PROM_CSR: PCI EEPROM control register.
@@ -210,17 +211,17 @@
 /*
  * COEX_CFG_0
  */
-#define COEX_CFG0   0x0040
+#define COEX_CFG0  0x0040
 #define COEX_CFG_ANT  FIELD32(0xff000000)
 /*
  * COEX_CFG_1
  */
-#define COEX_CFG1   0x0044
+#define COEX_CFG1  0x0044
 
 /*
  * COEX_CFG_2
  */
-#define COEX_CFG2   0x0048
+#define COEX_CFG2  0x0048
 #define BT_COEX_CFG1  FIELD32(0xff000000)
 #define BT_COEX_CFG0  FIELD32(0x00ff0000)
 #define WL_COEX_CFG1  FIELD32(0x0000ff00)
@@ -234,8 +235,8 @@
 #define PLL_RESERVED_INPUT2 FIELD32(0x0000ff00)
 #define PLL_CONTROL  FIELD32(0x00070000)
 #define PLL_LPF_R1  FIELD32(0x00080000)
-#define PLL_LPF_C1_CTRL FIELD32(0x00300000)
-#define PLL_LPF_C2_CTRL FIELD32(0x00c00000)
+#define PLL_LPF_C1_CTRL  FIELD32(0x00300000)
+#define PLL_LPF_C2_CTRL  FIELD32(0x00c00000)
 #define PLL_CP_CURRENT_CTRL FIELD32(0x03000000)
 #define PLL_PFD_DELAY_CTRL FIELD32(0x0c000000)
 #define PLL_LOCK_CTRL  FIELD32(0x70000000)
@@ -1082,6 +1083,15 @@
 #define TX_PWR_CFG_0_9MBS  FIELD32(0x00f00000)
 #define TX_PWR_CFG_0_12MBS  FIELD32(0x0f000000)
 #define TX_PWR_CFG_0_18MBS  FIELD32(0xf0000000)
+/* bits for 3T devices */
+#define TX_PWR_CFG_0_CCK1_CH0  FIELD32(0x0000000f)
+#define TX_PWR_CFG_0_CCK1_CH1  FIELD32(0x000000f0)
+#define TX_PWR_CFG_0_CCK5_CH0  FIELD32(0x00000f00)
+#define TX_PWR_CFG_0_CCK5_CH1  FIELD32(0x0000f000)
+#define TX_PWR_CFG_0_OFDM6_CH0  FIELD32(0x000f0000)
+#define TX_PWR_CFG_0_OFDM6_CH1  FIELD32(0x00f00000)
+#define TX_PWR_CFG_0_OFDM12_CH0  FIELD32(0x0f000000)
+#define TX_PWR_CFG_0_OFDM12_CH1  FIELD32(0xf0000000)
 
 /*
  * TX_PWR_CFG_1:
@@ -1095,6 +1105,15 @@
 #define TX_PWR_CFG_1_MCS1  FIELD32(0x00f00000)
 #define TX_PWR_CFG_1_MCS2  FIELD32(0x0f000000)
 #define TX_PWR_CFG_1_MCS3  FIELD32(0xf0000000)
+/* bits for 3T devices */
+#define TX_PWR_CFG_1_OFDM24_CH0  FIELD32(0x0000000f)
+#define TX_PWR_CFG_1_OFDM24_CH1  FIELD32(0x000000f0)
+#define TX_PWR_CFG_1_OFDM48_CH0  FIELD32(0x00000f00)
+#define TX_PWR_CFG_1_OFDM48_CH1  FIELD32(0x0000f000)
+#define TX_PWR_CFG_1_MCS0_CH0  FIELD32(0x000f0000)
+#define TX_PWR_CFG_1_MCS0_CH1  FIELD32(0x00f00000)
+#define TX_PWR_CFG_1_MCS2_CH0  FIELD32(0x0f000000)
+#define TX_PWR_CFG_1_MCS2_CH1  FIELD32(0xf0000000)
 
 /*
  * TX_PWR_CFG_2:
@@ -1108,6 +1127,15 @@
 #define TX_PWR_CFG_2_MCS9  FIELD32(0x00f00000)
 #define TX_PWR_CFG_2_MCS10  FIELD32(0x0f000000)
 #define TX_PWR_CFG_2_MCS11  FIELD32(0xf0000000)
+/* bits for 3T devices */
+#define TX_PWR_CFG_2_MCS4_CH0  FIELD32(0x0000000f)
+#define TX_PWR_CFG_2_MCS4_CH1  FIELD32(0x000000f0)
+#define TX_PWR_CFG_2_MCS6_CH0  FIELD32(0x00000f00)
+#define TX_PWR_CFG_2_MCS6_CH1  FIELD32(0x0000f000)
+#define TX_PWR_CFG_2_MCS8_CH0  FIELD32(0x000f0000)
+#define TX_PWR_CFG_2_MCS8_CH1  FIELD32(0x00f00000)
+#define TX_PWR_CFG_2_MCS10_CH0  FIELD32(0x0f000000)
+#define TX_PWR_CFG_2_MCS10_CH1  FIELD32(0xf0000000)
 
 /*
  * TX_PWR_CFG_3:
@@ -1121,6 +1149,15 @@
 #define TX_PWR_CFG_3_UKNOWN2  FIELD32(0x00f00000)
 #define TX_PWR_CFG_3_UKNOWN3  FIELD32(0x0f000000)
 #define TX_PWR_CFG_3_UKNOWN4  FIELD32(0xf0000000)
+/* bits for 3T devices */
+#define TX_PWR_CFG_3_MCS12_CH0  FIELD32(0x0000000f)
+#define TX_PWR_CFG_3_MCS12_CH1  FIELD32(0x000000f0)
+#define TX_PWR_CFG_3_MCS14_CH0  FIELD32(0x00000f00)
+#define TX_PWR_CFG_3_MCS14_CH1  FIELD32(0x0000f000)
+#define TX_PWR_CFG_3_STBC0_CH0  FIELD32(0x000f0000)
+#define TX_PWR_CFG_3_STBC0_CH1  FIELD32(0x00f00000)
+#define TX_PWR_CFG_3_STBC2_CH0  FIELD32(0x0f000000)
+#define TX_PWR_CFG_3_STBC2_CH1  FIELD32(0xf0000000)
 
 /*
  * TX_PWR_CFG_4:
@@ -1130,6 +1167,11 @@
 #define TX_PWR_CFG_4_UKNOWN6  FIELD32(0x000000f0)
 #define TX_PWR_CFG_4_UKNOWN7  FIELD32(0x00000f00)
 #define TX_PWR_CFG_4_UKNOWN8  FIELD32(0x0000f000)
+/* bits for 3T devices */
+#define TX_PWR_CFG_3_STBC4_CH0  FIELD32(0x0000000f)
+#define TX_PWR_CFG_3_STBC4_CH1  FIELD32(0x000000f0)
+#define TX_PWR_CFG_3_STBC6_CH0  FIELD32(0x00000f00)
+#define TX_PWR_CFG_3_STBC6_CH1  FIELD32(0x0000f000)
 
 /*
  * TX_PIN_CFG:
@@ -1451,6 +1493,81 @@
  */
 #define EXP_ACK_TIME   0x1380
 
+/* TX_PWR_CFG_5 */
+#define TX_PWR_CFG_5   0x1384
+#define TX_PWR_CFG_5_MCS16_CH0  FIELD32(0x0000000f)
+#define TX_PWR_CFG_5_MCS16_CH1  FIELD32(0x000000f0)
+#define TX_PWR_CFG_5_MCS16_CH2  FIELD32(0x00000f00)
+#define TX_PWR_CFG_5_MCS18_CH0  FIELD32(0x000f0000)
+#define TX_PWR_CFG_5_MCS18_CH1  FIELD32(0x00f00000)
+#define TX_PWR_CFG_5_MCS18_CH2  FIELD32(0x0f000000)
+
+/* TX_PWR_CFG_6 */
+#define TX_PWR_CFG_6   0x1388
+#define TX_PWR_CFG_6_MCS20_CH0  FIELD32(0x0000000f)
+#define TX_PWR_CFG_6_MCS20_CH1  FIELD32(0x000000f0)
+#define TX_PWR_CFG_6_MCS20_CH2  FIELD32(0x00000f00)
+#define TX_PWR_CFG_6_MCS22_CH0  FIELD32(0x000f0000)
+#define TX_PWR_CFG_6_MCS22_CH1  FIELD32(0x00f00000)
+#define TX_PWR_CFG_6_MCS22_CH2  FIELD32(0x0f000000)
+
+/* TX_PWR_CFG_0_EXT */
+#define TX_PWR_CFG_0_EXT  0x1390
+#define TX_PWR_CFG_0_EXT_CCK1_CH2 FIELD32(0x0000000f)
+#define TX_PWR_CFG_0_EXT_CCK5_CH2 FIELD32(0x00000f00)
+#define TX_PWR_CFG_0_EXT_OFDM6_CH2 FIELD32(0x000f0000)
+#define TX_PWR_CFG_0_EXT_OFDM12_CH2 FIELD32(0x0f000000)
+
+/* TX_PWR_CFG_1_EXT */
+#define TX_PWR_CFG_1_EXT  0x1394
+#define TX_PWR_CFG_1_EXT_OFDM24_CH2 FIELD32(0x0000000f)
+#define TX_PWR_CFG_1_EXT_OFDM48_CH2 FIELD32(0x00000f00)
+#define TX_PWR_CFG_1_EXT_MCS0_CH2 FIELD32(0x000f0000)
+#define TX_PWR_CFG_1_EXT_MCS2_CH2 FIELD32(0x0f000000)
+
+/* TX_PWR_CFG_2_EXT */
+#define TX_PWR_CFG_2_EXT  0x1398
+#define TX_PWR_CFG_2_EXT_MCS4_CH2 FIELD32(0x0000000f)
+#define TX_PWR_CFG_2_EXT_MCS6_CH2 FIELD32(0x00000f00)
+#define TX_PWR_CFG_2_EXT_MCS8_CH2 FIELD32(0x000f0000)
+#define TX_PWR_CFG_2_EXT_MCS10_CH2 FIELD32(0x0f000000)
+
+/* TX_PWR_CFG_3_EXT */
+#define TX_PWR_CFG_3_EXT  0x139c
+#define TX_PWR_CFG_3_EXT_MCS12_CH2 FIELD32(0x0000000f)
+#define TX_PWR_CFG_3_EXT_MCS14_CH2 FIELD32(0x00000f00)
+#define TX_PWR_CFG_3_EXT_STBC0_CH2 FIELD32(0x000f0000)
+#define TX_PWR_CFG_3_EXT_STBC2_CH2 FIELD32(0x0f000000)
+
+/* TX_PWR_CFG_4_EXT */
+#define TX_PWR_CFG_4_EXT  0x13a0
+#define TX_PWR_CFG_4_EXT_STBC4_CH2 FIELD32(0x0000000f)
+#define TX_PWR_CFG_4_EXT_STBC6_CH2 FIELD32(0x00000f00)
+
+/* TX_PWR_CFG_7 */
+#define TX_PWR_CFG_7   0x13d4
+#define TX_PWR_CFG_7_OFDM54_CH0  FIELD32(0x0000000f)
+#define TX_PWR_CFG_7_OFDM54_CH1  FIELD32(0x000000f0)
+#define TX_PWR_CFG_7_OFDM54_CH2  FIELD32(0x00000f00)
+#define TX_PWR_CFG_7_MCS7_CH0  FIELD32(0x000f0000)
+#define TX_PWR_CFG_7_MCS7_CH1  FIELD32(0x00f00000)
+#define TX_PWR_CFG_7_MCS7_CH2  FIELD32(0x0f000000)
+
+/* TX_PWR_CFG_8 */
+#define TX_PWR_CFG_8   0x13d8
+#define TX_PWR_CFG_8_MCS15_CH0  FIELD32(0x0000000f)
+#define TX_PWR_CFG_8_MCS15_CH1  FIELD32(0x000000f0)
+#define TX_PWR_CFG_8_MCS15_CH2  FIELD32(0x00000f00)
+#define TX_PWR_CFG_8_MCS23_CH0  FIELD32(0x000f0000)
+#define TX_PWR_CFG_8_MCS23_CH1  FIELD32(0x00f00000)
+#define TX_PWR_CFG_8_MCS23_CH2  FIELD32(0x0f000000)
+
+/* TX_PWR_CFG_9 */
+#define TX_PWR_CFG_9   0x13dc
+#define TX_PWR_CFG_9_STBC7_CH0  FIELD32(0x0000000f)
+#define TX_PWR_CFG_9_STBC7_CH1  FIELD32(0x000000f0)
+#define TX_PWR_CFG_9_STBC7_CH2  FIELD32(0x00000f00)
+
 /*
  * RX_FILTER_CFG: RX configuration register.
  */
@@ -1902,11 +2019,13 @@ struct mac_iveiv_entry {
 #define HW_BEACON_BASE6   0x5dc0
 #define HW_BEACON_BASE7   0x5bc0
 
-#define HW_BEACON_OFFSET(__index) \
+#define HW_BEACON_BASE(__index) \
  (((__index) < 4) ? (HW_BEACON_BASE0 + (__index * 0x0200)) : \
    (((__index) < 6) ? (HW_BEACON_BASE4 + ((__index - 4) * 0x0200)) : \
    (HW_BEACON_BASE6 - ((__index - 6) * 0x0200))))
 
+#define BEACON_BASE_TO_OFFSET(_base) (((_base) - 0x4000) / 64)
+
 /*
  * BBP registers.
  * The wordsize of the BBP is 8 bits.
@@ -1975,6 +2094,10 @@ struct mac_iveiv_entry {
 #define BBP109_TX0_POWER  FIELD8(0x0f)
 #define BBP109_TX1_POWER  FIELD8(0xf0)
 
+/* BBP 110 */
+#define BBP110_TX2_POWER  FIELD8(0x0f)
+
+
 /*
  * BBP 138: Unknown
  */
@@ -2024,6 +2147,12 @@ struct mac_iveiv_entry {
 #define RFCSR3_PA2_CASCODE_BIAS_CCKK FIELD8(0x80)
 /* Bits for RF3290/RF5360/RF5370/RF5372/RF5390/RF5392 */
 #define RFCSR3_VCOCAL_EN  FIELD8(0x80)
+/* Bits for RF3050 */
+#define RFCSR3_BIT1   FIELD8(0x02)
+#define RFCSR3_BIT2   FIELD8(0x04)
+#define RFCSR3_BIT3   FIELD8(0x08)
+#define RFCSR3_BIT4   FIELD8(0x10)
+#define RFCSR3_BIT5   FIELD8(0x20)
 
 /*
  * FRCSR 5:
@@ -2035,7 +2164,9 @@ struct mac_iveiv_entry {
  */
 #define RFCSR6_R1   FIELD8(0x03)
 #define RFCSR6_R2   FIELD8(0x40)
-#define RFCSR6_TXDIV  FIELD8(0x0c)
+#define RFCSR6_TXDIV   FIELD8(0x0c)
+/* bits for RF3053 */
+#define RFCSR6_VCO_IC   FIELD8(0xc0)
 
 /*
  * RFCSR 7:
@@ -2060,19 +2191,24 @@ struct mac_iveiv_entry {
  * RFCSR 11:
  */
 #define RFCSR11_R   FIELD8(0x03)
+#define RFCSR11_PLL_MOD   FIELD8(0x0c)
 #define RFCSR11_MOD   FIELD8(0xc0)
+/* bits for RF3053 */
+/* TODO: verify RFCSR11_MOD usage on other chips */
+#define RFCSR11_PLL_IDOH  FIELD8(0x40)
+
 
 /*
  * RFCSR 12:
  */
 #define RFCSR12_TX_POWER  FIELD8(0x1f)
-#define RFCSR12_DR0    FIELD8(0xe0)
+#define RFCSR12_DR0   FIELD8(0xe0)
 
 /*
  * RFCSR 13:
  */
 #define RFCSR13_TX_POWER  FIELD8(0x1f)
-#define RFCSR13_DR0    FIELD8(0xe0)
+#define RFCSR13_DR0   FIELD8(0xe0)
 
 /*
  * RFCSR 15:
@@ -2090,7 +2226,11 @@ struct mac_iveiv_entry {
 #define RFCSR17_TXMIXER_GAIN  FIELD8(0x07)
 #define RFCSR17_TX_LO1_EN  FIELD8(0x08)
 #define RFCSR17_R   FIELD8(0x20)
-#define RFCSR17_CODE                   FIELD8(0x7f)
+#define RFCSR17_CODE   FIELD8(0x7f)
+
+/* RFCSR 18 */
+#define RFCSR18_XO_TUNE_BYPASS  FIELD8(0x40)
+
 
 /*
  * RFCSR 20:
@@ -2152,6 +2292,12 @@ struct mac_iveiv_entry {
 #define RFCSR31_RX_H20M   FIELD8(0x20)
 #define RFCSR31_RX_CALIB  FIELD8(0x7f)
 
+/* RFCSR 32 bits for RF3053 */
+#define RFCSR32_TX_AGC_FC  FIELD8(0xf8)
+
+/* RFCSR 36 bits for RF3053 */
+#define RFCSR36_RF_BS   FIELD8(0x80)
+
 /*
  * RFCSR 38:
  */
@@ -2160,6 +2306,7 @@ struct mac_iveiv_entry {
 /*
  * RFCSR 39:
  */
+#define RFCSR39_RX_DIV   FIELD8(0x40)
 #define RFCSR39_RX_LO2_EN  FIELD8(0x80)
 
 /*
@@ -2167,12 +2314,36 @@ struct mac_iveiv_entry {
  */
 #define RFCSR49_TX   FIELD8(0x3f)
 #define RFCSR49_EP   FIELD8(0xc0)
+/* bits for RT3593 */
+#define RFCSR49_TX_LO1_IC  FIELD8(0x1c)
+#define RFCSR49_TX_DIV   FIELD8(0x20)
 
 /*
  * RFCSR 50:
  */
 #define RFCSR50_TX   FIELD8(0x3f)
 #define RFCSR50_EP   FIELD8(0xc0)
+/* bits for RT3593 */
+#define RFCSR50_TX_LO1_EN  FIELD8(0x20)
+#define RFCSR50_TX_LO2_EN  FIELD8(0x10)
+
+/* RFCSR 51 */
+/* bits for RT3593 */
+#define RFCSR51_BITS01   FIELD8(0x03)
+#define RFCSR51_BITS24   FIELD8(0x1c)
+#define RFCSR51_BITS57   FIELD8(0xe0)
+
+#define RFCSR53_TX_POWER  FIELD8(0x3f)
+#define RFCSR53_UNKNOWN   FIELD8(0xc0)
+
+#define RFCSR54_TX_POWER  FIELD8(0x3f)
+#define RFCSR54_UNKNOWN   FIELD8(0xc0)
+
+#define RFCSR55_TX_POWER  FIELD8(0x3f)
+#define RFCSR55_UNKNOWN   FIELD8(0xc0)
+
+#define RFCSR57_DRV_CC   FIELD8(0xfc)
+
 
 /*
  * RF registers
@@ -2206,28 +2377,67 @@ struct mac_iveiv_entry {
  * The wordsize of the EEPROM is 16 bits.
  */
 
-/*
- * Chip ID
- */
-#define EEPROM_CHIP_ID   0x0000
+enum rt2800_eeprom_word {
+ EEPROM_CHIP_ID = 0,
+ EEPROM_VERSION,
+ EEPROM_MAC_ADDR_0,
+ EEPROM_MAC_ADDR_1,
+ EEPROM_MAC_ADDR_2,
+ EEPROM_NIC_CONF0,
+ EEPROM_NIC_CONF1,
+ EEPROM_FREQ,
+ EEPROM_LED_AG_CONF,
+ EEPROM_LED_ACT_CONF,
+ EEPROM_LED_POLARITY,
+ EEPROM_NIC_CONF2,
+ EEPROM_LNA,
+ EEPROM_RSSI_BG,
+ EEPROM_RSSI_BG2,
+ EEPROM_TXMIXER_GAIN_BG,
+ EEPROM_RSSI_A,
+ EEPROM_RSSI_A2,
+ EEPROM_TXMIXER_GAIN_A,
+ EEPROM_EIRP_MAX_TX_POWER,
+ EEPROM_TXPOWER_DELTA,
+ EEPROM_TXPOWER_BG1,
+ EEPROM_TXPOWER_BG2,
+ EEPROM_TSSI_BOUND_BG1,
+ EEPROM_TSSI_BOUND_BG2,
+ EEPROM_TSSI_BOUND_BG3,
+ EEPROM_TSSI_BOUND_BG4,
+ EEPROM_TSSI_BOUND_BG5,
+ EEPROM_TXPOWER_A1,
+ EEPROM_TXPOWER_A2,
+ EEPROM_TSSI_BOUND_A1,
+ EEPROM_TSSI_BOUND_A2,
+ EEPROM_TSSI_BOUND_A3,
+ EEPROM_TSSI_BOUND_A4,
+ EEPROM_TSSI_BOUND_A5,
+ EEPROM_TXPOWER_BYRATE,
+ EEPROM_BBP_START,
+
+ /* IDs for extended EEPROM format used by three-chain devices */
+ EEPROM_EXT_LNA2,
+ EEPROM_EXT_TXPOWER_BG3,
+ EEPROM_EXT_TXPOWER_A3,
+
+ /* New values must be added before this */
+ EEPROM_WORD_COUNT
+};
 
 /*
  * EEPROM Version
  */
-#define EEPROM_VERSION   0x0001
 #define EEPROM_VERSION_FAE  FIELD16(0x00ff)
 #define EEPROM_VERSION_VERSION  FIELD16(0xff00)
 
 /*
  * HW MAC address.
  */
-#define EEPROM_MAC_ADDR_0  0x0002
 #define EEPROM_MAC_ADDR_BYTE0  FIELD16(0x00ff)
 #define EEPROM_MAC_ADDR_BYTE1  FIELD16(0xff00)
-#define EEPROM_MAC_ADDR_1  0x0003
 #define EEPROM_MAC_ADDR_BYTE2  FIELD16(0x00ff)
 #define EEPROM_MAC_ADDR_BYTE3  FIELD16(0xff00)
-#define EEPROM_MAC_ADDR_2  0x0004
 #define EEPROM_MAC_ADDR_BYTE4  FIELD16(0x00ff)
 #define EEPROM_MAC_ADDR_BYTE5  FIELD16(0xff00)
 
@@ -2237,10 +2447,9 @@ struct mac_iveiv_entry {
  * TXPATH: 1: 1T, 2: 2T, 3: 3T
  * RF_TYPE: RFIC type
  */
-#define EEPROM_NIC_CONF0  0x001a
 #define EEPROM_NIC_CONF0_RXPATH  FIELD16(0x000f)
 #define EEPROM_NIC_CONF0_TXPATH  FIELD16(0x00f0)
-#define EEPROM_NIC_CONF0_RF_TYPE  FIELD16(0x0f00)
+#define EEPROM_NIC_CONF0_RF_TYPE FIELD16(0x0f00)
 
 /*
  * EEPROM NIC Configuration 1
@@ -2261,27 +2470,25 @@ struct mac_iveiv_entry {
  * BT_COEXIST: 0: disable, 1: enable
  * DAC_TEST: 0: disable, 1: enable
  */
-#define EEPROM_NIC_CONF1  0x001b
 #define EEPROM_NIC_CONF1_HW_RADIO  FIELD16(0x0001)
-#define EEPROM_NIC_CONF1_EXTERNAL_TX_ALC  FIELD16(0x0002)
-#define EEPROM_NIC_CONF1_EXTERNAL_LNA_2G  FIELD16(0x0004)
-#define EEPROM_NIC_CONF1_EXTERNAL_LNA_5G  FIELD16(0x0008)
+#define EEPROM_NIC_CONF1_EXTERNAL_TX_ALC FIELD16(0x0002)
+#define EEPROM_NIC_CONF1_EXTERNAL_LNA_2G FIELD16(0x0004)
+#define EEPROM_NIC_CONF1_EXTERNAL_LNA_5G FIELD16(0x0008)
 #define EEPROM_NIC_CONF1_CARDBUS_ACCEL  FIELD16(0x0010)
 #define EEPROM_NIC_CONF1_BW40M_SB_2G  FIELD16(0x0020)
 #define EEPROM_NIC_CONF1_BW40M_SB_5G  FIELD16(0x0040)
 #define EEPROM_NIC_CONF1_WPS_PBC  FIELD16(0x0080)
 #define EEPROM_NIC_CONF1_BW40M_2G  FIELD16(0x0100)
 #define EEPROM_NIC_CONF1_BW40M_5G  FIELD16(0x0200)
-#define EEPROM_NIC_CONF1_BROADBAND_EXT_LNA  FIELD16(0x400)
+#define EEPROM_NIC_CONF1_BROADBAND_EXT_LNA FIELD16(0x400)
 #define EEPROM_NIC_CONF1_ANT_DIVERSITY  FIELD16(0x1800)
-#define EEPROM_NIC_CONF1_INTERNAL_TX_ALC  FIELD16(0x2000)
+#define EEPROM_NIC_CONF1_INTERNAL_TX_ALC FIELD16(0x2000)
 #define EEPROM_NIC_CONF1_BT_COEXIST  FIELD16(0x4000)
 #define EEPROM_NIC_CONF1_DAC_TEST  FIELD16(0x8000)
 
 /*
  * EEPROM frequency
  */
-#define EEPROM_FREQ   0x001d
 #define EEPROM_FREQ_OFFSET  FIELD16(0x00ff)
 #define EEPROM_FREQ_LED_MODE  FIELD16(0x7f00)
 #define EEPROM_FREQ_LED_POLARITY FIELD16(0x1000)
@@ -2298,9 +2505,6 @@ struct mac_iveiv_entry {
  * POLARITY_GPIO_4: Polarity GPIO4 setting.
  * LED_MODE: Led mode.
  */
-#define EEPROM_LED_AG_CONF  0x001e
-#define EEPROM_LED_ACT_CONF  0x001f
-#define EEPROM_LED_POLARITY  0x0020
 #define EEPROM_LED_POLARITY_RDY_BG FIELD16(0x0001)
 #define EEPROM_LED_POLARITY_RDY_A FIELD16(0x0002)
 #define EEPROM_LED_POLARITY_ACT  FIELD16(0x0004)
@@ -2317,62 +2521,53 @@ struct mac_iveiv_entry {
  * TX_STREAM: 0: Reserved, 1: 1 Stream, 2: 2 Stream
  * CRYSTAL: 00: Reserved, 01: One crystal, 10: Two crystal, 11: Reserved
  */
-#define EEPROM_NIC_CONF2  0x0021
-#define EEPROM_NIC_CONF2_RX_STREAM  FIELD16(0x000f)
-#define EEPROM_NIC_CONF2_TX_STREAM  FIELD16(0x00f0)
-#define EEPROM_NIC_CONF2_CRYSTAL  FIELD16(0x0600)
+#define EEPROM_NIC_CONF2_RX_STREAM FIELD16(0x000f)
+#define EEPROM_NIC_CONF2_TX_STREAM FIELD16(0x00f0)
+#define EEPROM_NIC_CONF2_CRYSTAL FIELD16(0x0600)
 
 /*
  * EEPROM LNA
  */
-#define EEPROM_LNA   0x0022
 #define EEPROM_LNA_BG   FIELD16(0x00ff)
 #define EEPROM_LNA_A0   FIELD16(0xff00)
 
 /*
  * EEPROM RSSI BG offset
  */
-#define EEPROM_RSSI_BG   0x0023
 #define EEPROM_RSSI_BG_OFFSET0  FIELD16(0x00ff)
 #define EEPROM_RSSI_BG_OFFSET1  FIELD16(0xff00)
 
 /*
  * EEPROM RSSI BG2 offset
  */
-#define EEPROM_RSSI_BG2   0x0024
 #define EEPROM_RSSI_BG2_OFFSET2  FIELD16(0x00ff)
 #define EEPROM_RSSI_BG2_LNA_A1  FIELD16(0xff00)
 
 /*
  * EEPROM TXMIXER GAIN BG offset (note overlaps with EEPROM RSSI BG2).
  */
-#define EEPROM_TXMIXER_GAIN_BG  0x0024
 #define EEPROM_TXMIXER_GAIN_BG_VAL FIELD16(0x0007)
 
 /*
  * EEPROM RSSI A offset
  */
-#define EEPROM_RSSI_A   0x0025
 #define EEPROM_RSSI_A_OFFSET0  FIELD16(0x00ff)
 #define EEPROM_RSSI_A_OFFSET1  FIELD16(0xff00)
 
 /*
  * EEPROM RSSI A2 offset
  */
-#define EEPROM_RSSI_A2   0x0026
 #define EEPROM_RSSI_A2_OFFSET2  FIELD16(0x00ff)
 #define EEPROM_RSSI_A2_LNA_A2  FIELD16(0xff00)
 
 /*
  * EEPROM TXMIXER GAIN A offset (note overlaps with EEPROM RSSI A2).
  */
-#define EEPROM_TXMIXER_GAIN_A  0x0026
 #define EEPROM_TXMIXER_GAIN_A_VAL FIELD16(0x0007)
 
 /*
  * EEPROM EIRP Maximum TX power values(unit: dbm)
  */
-#define EEPROM_EIRP_MAX_TX_POWER 0x0027
 #define EEPROM_EIRP_MAX_TX_POWER_2GHZ FIELD16(0x00ff)
 #define EEPROM_EIRP_MAX_TX_POWER_5GHZ FIELD16(0xff00)
 
@@ -2383,7 +2578,6 @@ struct mac_iveiv_entry {
  * TYPE: 1: Plus the delta value, 0: minus the delta value
  * ENABLE: enable tx power compensation for 40BW
  */
-#define EEPROM_TXPOWER_DELTA  0x0028
 #define EEPROM_TXPOWER_DELTA_VALUE_2G FIELD16(0x003f)
 #define EEPROM_TXPOWER_DELTA_TYPE_2G FIELD16(0x0040)
 #define EEPROM_TXPOWER_DELTA_ENABLE_2G FIELD16(0x0080)
@@ -2394,8 +2588,6 @@ struct mac_iveiv_entry {
 /*
  * EEPROM TXPOWER 802.11BG
  */
-#define EEPROM_TXPOWER_BG1  0x0029
-#define EEPROM_TXPOWER_BG2  0x0030
 #define EEPROM_TXPOWER_BG_SIZE  7
 #define EEPROM_TXPOWER_BG_1  FIELD16(0x00ff)
 #define EEPROM_TXPOWER_BG_2  FIELD16(0xff00)
@@ -2407,7 +2599,6 @@ struct mac_iveiv_entry {
  * MINUS3: If the actual TSSI is below this boundary, tx power needs to be
  *         reduced by (agc_step * -3)
  */
-#define EEPROM_TSSI_BOUND_BG1  0x0037
 #define EEPROM_TSSI_BOUND_BG1_MINUS4 FIELD16(0x00ff)
 #define EEPROM_TSSI_BOUND_BG1_MINUS3 FIELD16(0xff00)
 
@@ -2418,7 +2609,6 @@ struct mac_iveiv_entry {
  * MINUS1: If the actual TSSI is below this boundary, tx power needs to be
  *         reduced by (agc_step * -1)
  */
-#define EEPROM_TSSI_BOUND_BG2  0x0038
 #define EEPROM_TSSI_BOUND_BG2_MINUS2 FIELD16(0x00ff)
 #define EEPROM_TSSI_BOUND_BG2_MINUS1 FIELD16(0xff00)
 
@@ -2428,7 +2618,6 @@ struct mac_iveiv_entry {
  * PLUS1: If the actual TSSI is above this boundary, tx power needs to be
  *        increased by (agc_step * 1)
  */
-#define EEPROM_TSSI_BOUND_BG3  0x0039
 #define EEPROM_TSSI_BOUND_BG3_REF FIELD16(0x00ff)
 #define EEPROM_TSSI_BOUND_BG3_PLUS1 FIELD16(0xff00)
 
@@ -2439,7 +2628,6 @@ struct mac_iveiv_entry {
  * PLUS3: If the actual TSSI is above this boundary, tx power needs to be
  *        increased by (agc_step * 3)
  */
-#define EEPROM_TSSI_BOUND_BG4  0x003a
 #define EEPROM_TSSI_BOUND_BG4_PLUS2 FIELD16(0x00ff)
 #define EEPROM_TSSI_BOUND_BG4_PLUS3 FIELD16(0xff00)
 
@@ -2449,19 +2637,20 @@ struct mac_iveiv_entry {
  *        increased by (agc_step * 4)
  * AGC_STEP: Temperature compensation step.
  */
-#define EEPROM_TSSI_BOUND_BG5  0x003b
 #define EEPROM_TSSI_BOUND_BG5_PLUS4 FIELD16(0x00ff)
 #define EEPROM_TSSI_BOUND_BG5_AGC_STEP FIELD16(0xff00)
 
 /*
  * EEPROM TXPOWER 802.11A
  */
-#define EEPROM_TXPOWER_A1  0x003c
-#define EEPROM_TXPOWER_A2  0x0053
 #define EEPROM_TXPOWER_A_SIZE  6
 #define EEPROM_TXPOWER_A_1  FIELD16(0x00ff)
 #define EEPROM_TXPOWER_A_2  FIELD16(0xff00)
 
+/* EEPROM_TXPOWER_{A,G} fields for RT3593 */
+#define EEPROM_TXPOWER_ALC  FIELD8(0x1f)
+#define EEPROM_TXPOWER_FINE_CTRL FIELD8(0xe0)
+
 /*
  * EEPROM temperature compensation boundaries 802.11A
  * MINUS4: If the actual TSSI is below this boundary, tx power needs to be
@@ -2469,7 +2658,6 @@ struct mac_iveiv_entry {
  * MINUS3: If the actual TSSI is below this boundary, tx power needs to be
  *         reduced by (agc_step * -3)
  */
-#define EEPROM_TSSI_BOUND_A1  0x006a
 #define EEPROM_TSSI_BOUND_A1_MINUS4 FIELD16(0x00ff)
 #define EEPROM_TSSI_BOUND_A1_MINUS3 FIELD16(0xff00)
 
@@ -2480,7 +2668,6 @@ struct mac_iveiv_entry {
  * MINUS1: If the actual TSSI is below this boundary, tx power needs to be
  *         reduced by (agc_step * -1)
  */
-#define EEPROM_TSSI_BOUND_A2  0x006b
 #define EEPROM_TSSI_BOUND_A2_MINUS2 FIELD16(0x00ff)
 #define EEPROM_TSSI_BOUND_A2_MINUS1 FIELD16(0xff00)
 
@@ -2490,7 +2677,6 @@ struct mac_iveiv_entry {
  * PLUS1: If the actual TSSI is above this boundary, tx power needs to be
  *        increased by (agc_step * 1)
  */
-#define EEPROM_TSSI_BOUND_A3  0x006c
 #define EEPROM_TSSI_BOUND_A3_REF FIELD16(0x00ff)
 #define EEPROM_TSSI_BOUND_A3_PLUS1 FIELD16(0xff00)
 
@@ -2501,7 +2687,6 @@ struct mac_iveiv_entry {
  * PLUS3: If the actual TSSI is above this boundary, tx power needs to be
  *        increased by (agc_step * 3)
  */
-#define EEPROM_TSSI_BOUND_A4  0x006d
 #define EEPROM_TSSI_BOUND_A4_PLUS2 FIELD16(0x00ff)
 #define EEPROM_TSSI_BOUND_A4_PLUS3 FIELD16(0xff00)
 
@@ -2511,14 +2696,12 @@ struct mac_iveiv_entry {
  *        increased by (agc_step * 4)
  * AGC_STEP: Temperature compensation step.
  */
-#define EEPROM_TSSI_BOUND_A5  0x006e
 #define EEPROM_TSSI_BOUND_A5_PLUS4 FIELD16(0x00ff)
 #define EEPROM_TSSI_BOUND_A5_AGC_STEP FIELD16(0xff00)
 
 /*
  * EEPROM TXPOWER by rate: tx power per tx rate for HT20 mode
  */
-#define EEPROM_TXPOWER_BYRATE  0x006f
 #define EEPROM_TXPOWER_BYRATE_SIZE 9
 
 #define EEPROM_TXPOWER_BYRATE_RATE0 FIELD16(0x000f)
@@ -2529,11 +2712,14 @@ struct mac_iveiv_entry {
 /*
  * EEPROM BBP.
  */
-#define EEPROM_BBP_START  0x0078
 #define EEPROM_BBP_SIZE   16
 #define EEPROM_BBP_VALUE  FIELD16(0x00ff)
 #define EEPROM_BBP_REG_ID  FIELD16(0xff00)
 
+/* EEPROM_EXT_LNA2 */
+#define EEPROM_EXT_LNA2_A1  FIELD16(0x00ff)
+#define EEPROM_EXT_LNA2_A2  FIELD16(0xff00)
+
 /*
  * EEPROM IQ Calibration, unlike other entries those are byte addresses.
  */
@@ -2604,15 +2790,16 @@ struct mac_iveiv_entry {
 #define MCU_CURRENT   0x36
 #define MCU_LED    0x50
 #define MCU_LED_STRENGTH  0x51
-#define MCU_LED_AG_CONF  0x52
+#define MCU_LED_AG_CONF   0x52
 #define MCU_LED_ACT_CONF  0x53
 #define MCU_LED_LED_POLARITY  0x54
 #define MCU_RADAR   0x60
 #define MCU_BOOT_SIGNAL   0x72
 #define MCU_ANT_SELECT   0X73
+#define MCU_FREQ_OFFSET   0x74
 #define MCU_BBP_SIGNAL   0x80
 #define MCU_POWER_SAVE   0x83
-#define MCU_BAND_SELECT  0x91
+#define MCU_BAND_SELECT   0x91
 
 /*
  * MCU mailbox tokens
@@ -2625,11 +2812,14 @@ struct mac_iveiv_entry {
 /*
  * DMA descriptor defines.
  */
-#define TXWI_DESC_SIZE   (4 * sizeof(__le32))
-#define RXWI_DESC_SIZE   (4 * sizeof(__le32))
 
-#define TXWI_DESC_SIZE_5592  (5 * sizeof(__le32))
-#define RXWI_DESC_SIZE_5592  (6 * sizeof(__le32))
+#define TXWI_DESC_SIZE_4WORDS  (4 * sizeof(__le32))
+#define TXWI_DESC_SIZE_5WORDS  (5 * sizeof(__le32))
+
+#define RXWI_DESC_SIZE_4WORDS  (4 * sizeof(__le32))
+#define RXWI_DESC_SIZE_5WORDS  (5 * sizeof(__le32))
+#define RXWI_DESC_SIZE_6WORDS  (6 * sizeof(__le32))
+
 /*
  * TX WI structure
  */
@@ -2748,18 +2938,15 @@ struct mac_iveiv_entry {
 #define MAX_A_TXPOWER 15
 #define DEFAULT_TXPOWER 5
 
+#define MIN_A_TXPOWER_3593 0
+#define MAX_A_TXPOWER_3593 31
+
 #define TXPOWER_G_FROM_DEV(__txpower) \
  ((__txpower) > MAX_G_TXPOWER) ? DEFAULT_TXPOWER : (__txpower)
 
-#define TXPOWER_G_TO_DEV(__txpower) \
- clamp_t(char, __txpower, MIN_G_TXPOWER, MAX_G_TXPOWER)
-
 #define TXPOWER_A_FROM_DEV(__txpower) \
  ((__txpower) > MAX_A_TXPOWER) ? DEFAULT_TXPOWER : (__txpower)
 
-#define TXPOWER_A_TO_DEV(__txpower) \
- clamp_t(char, __txpower, MIN_A_TXPOWER, MAX_A_TXPOWER)
-
 /*
  *  Board's maximun TX power limitation
  */
diff --git a/drivers/net/wireless/rt2x00/rt2800lib.c b/drivers/net/wireless/rt2x00/rt2800lib.c
index f281971..c17fcf2 100644
--- a/drivers/net/wireless/rt2x00/rt2800lib.c
+++ b/drivers/net/wireless/rt2x00/rt2800lib.c
@@ -24,9 +24,7 @@
  GNU General Public License for more details.
 
  You should have received a copy of the GNU General Public License
- along with this program; if not, write to the
- Free Software Foundation, Inc.,
- 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ along with this program; if not, see <http://www.gnu.org/licenses/>.
  */
 
 /*
@@ -221,6 +219,154 @@ static void rt2800_rf_write(struct rt2x00_dev *rt2x00dev,
  mutex_unlock(&rt2x00dev->csr_mutex);
 }
 
+static const unsigned int rt2800_eeprom_map[EEPROM_WORD_COUNT] = {
+ [EEPROM_CHIP_ID]  = 0x0000,
+ [EEPROM_VERSION]  = 0x0001,
+ [EEPROM_MAC_ADDR_0]  = 0x0002,
+ [EEPROM_MAC_ADDR_1]  = 0x0003,
+ [EEPROM_MAC_ADDR_2]  = 0x0004,
+ [EEPROM_NIC_CONF0]  = 0x001a,
+ [EEPROM_NIC_CONF1]  = 0x001b,
+ [EEPROM_FREQ]   = 0x001d,
+ [EEPROM_LED_AG_CONF]  = 0x001e,
+ [EEPROM_LED_ACT_CONF]  = 0x001f,
+ [EEPROM_LED_POLARITY]  = 0x0020,
+ [EEPROM_NIC_CONF2]  = 0x0021,
+ [EEPROM_LNA]   = 0x0022,
+ [EEPROM_RSSI_BG]  = 0x0023,
+ [EEPROM_RSSI_BG2]  = 0x0024,
+ [EEPROM_TXMIXER_GAIN_BG] = 0x0024, /* overlaps with RSSI_BG2 */
+ [EEPROM_RSSI_A]   = 0x0025,
+ [EEPROM_RSSI_A2]  = 0x0026,
+ [EEPROM_TXMIXER_GAIN_A]  = 0x0026, /* overlaps with RSSI_A2 */
+ [EEPROM_EIRP_MAX_TX_POWER] = 0x0027,
+ [EEPROM_TXPOWER_DELTA]  = 0x0028,
+ [EEPROM_TXPOWER_BG1]  = 0x0029,
+ [EEPROM_TXPOWER_BG2]  = 0x0030,
+ [EEPROM_TSSI_BOUND_BG1]  = 0x0037,
+ [EEPROM_TSSI_BOUND_BG2]  = 0x0038,
+ [EEPROM_TSSI_BOUND_BG3]  = 0x0039,
+ [EEPROM_TSSI_BOUND_BG4]  = 0x003a,
+ [EEPROM_TSSI_BOUND_BG5]  = 0x003b,
+ [EEPROM_TXPOWER_A1]  = 0x003c,
+ [EEPROM_TXPOWER_A2]  = 0x0053,
+ [EEPROM_TSSI_BOUND_A1]  = 0x006a,
+ [EEPROM_TSSI_BOUND_A2]  = 0x006b,
+ [EEPROM_TSSI_BOUND_A3]  = 0x006c,
+ [EEPROM_TSSI_BOUND_A4]  = 0x006d,
+ [EEPROM_TSSI_BOUND_A5]  = 0x006e,
+ [EEPROM_TXPOWER_BYRATE]  = 0x006f,
+ [EEPROM_BBP_START]  = 0x0078,
+};
+
+static const unsigned int rt2800_eeprom_map_ext[EEPROM_WORD_COUNT] = {
+ [EEPROM_CHIP_ID]  = 0x0000,
+ [EEPROM_VERSION]  = 0x0001,
+ [EEPROM_MAC_ADDR_0]  = 0x0002,
+ [EEPROM_MAC_ADDR_1]  = 0x0003,
+ [EEPROM_MAC_ADDR_2]  = 0x0004,
+ [EEPROM_NIC_CONF0]  = 0x001a,
+ [EEPROM_NIC_CONF1]  = 0x001b,
+ [EEPROM_NIC_CONF2]  = 0x001c,
+ [EEPROM_EIRP_MAX_TX_POWER] = 0x0020,
+ [EEPROM_FREQ]   = 0x0022,
+ [EEPROM_LED_AG_CONF]  = 0x0023,
+ [EEPROM_LED_ACT_CONF]  = 0x0024,
+ [EEPROM_LED_POLARITY]  = 0x0025,
+ [EEPROM_LNA]   = 0x0026,
+ [EEPROM_EXT_LNA2]  = 0x0027,
+ [EEPROM_RSSI_BG]  = 0x0028,
+ [EEPROM_RSSI_BG2]  = 0x0029,
+ [EEPROM_RSSI_A]   = 0x002a,
+ [EEPROM_RSSI_A2]  = 0x002b,
+ [EEPROM_TXPOWER_BG1]  = 0x0030,
+ [EEPROM_TXPOWER_BG2]  = 0x0037,
+ [EEPROM_EXT_TXPOWER_BG3] = 0x003e,
+ [EEPROM_TSSI_BOUND_BG1]  = 0x0045,
+ [EEPROM_TSSI_BOUND_BG2]  = 0x0046,
+ [EEPROM_TSSI_BOUND_BG3]  = 0x0047,
+ [EEPROM_TSSI_BOUND_BG4]  = 0x0048,
+ [EEPROM_TSSI_BOUND_BG5]  = 0x0049,
+ [EEPROM_TXPOWER_A1]  = 0x004b,
+ [EEPROM_TXPOWER_A2]  = 0x0065,
+ [EEPROM_EXT_TXPOWER_A3]  = 0x007f,
+ [EEPROM_TSSI_BOUND_A1]  = 0x009a,
+ [EEPROM_TSSI_BOUND_A2]  = 0x009b,
+ [EEPROM_TSSI_BOUND_A3]  = 0x009c,
+ [EEPROM_TSSI_BOUND_A4]  = 0x009d,
+ [EEPROM_TSSI_BOUND_A5]  = 0x009e,
+ [EEPROM_TXPOWER_BYRATE]  = 0x00a0,
+};
+
+static unsigned int rt2800_eeprom_word_index(struct rt2x00_dev *rt2x00dev,
+          const enum rt2800_eeprom_word word)
+{
+ const unsigned int *map;
+ unsigned int index;
+
+ if (WARN_ONCE(word >= EEPROM_WORD_COUNT,
+        "%s: invalid EEPROM word %d\n",
+        wiphy_name(rt2x00dev->hw->wiphy), word))
+  return 0;
+
+ if (rt2x00_rt(rt2x00dev, RT3593))
+  map = rt2800_eeprom_map_ext;
+ else
+  map = rt2800_eeprom_map;
+
+ index = map[word];
+
+ /* Index 0 is valid only for EEPROM_CHIP_ID.
+  * Otherwise it means that the offset of the
+  * given word is not initialized in the map,
+  * or that the field is not usable on the
+  * actual chipset.
+  */
+ WARN_ONCE(word != EEPROM_CHIP_ID && index == 0,
+    "%s: invalid access of EEPROM word %d\n",
+    wiphy_name(rt2x00dev->hw->wiphy), word);
+
+ return index;
+}
+
+static void *rt2800_eeprom_addr(struct rt2x00_dev *rt2x00dev,
+    const enum rt2800_eeprom_word word)
+{
+ unsigned int index;
+
+ index = rt2800_eeprom_word_index(rt2x00dev, word);
+ return rt2x00_eeprom_addr(rt2x00dev, index);
+}
+
+static void rt2800_eeprom_read(struct rt2x00_dev *rt2x00dev,
+          const enum rt2800_eeprom_word word, u16 *data)
+{
+ unsigned int index;
+
+ index = rt2800_eeprom_word_index(rt2x00dev, word);
+ rt2x00_eeprom_read(rt2x00dev, index, data);
+}
+
+static void rt2800_eeprom_write(struct rt2x00_dev *rt2x00dev,
+    const enum rt2800_eeprom_word word, u16 data)
+{
+ unsigned int index;
+
+ index = rt2800_eeprom_word_index(rt2x00dev, word);
+ rt2x00_eeprom_write(rt2x00dev, index, data);
+}
+
+static void rt2800_eeprom_read_from_array(struct rt2x00_dev *rt2x00dev,
+       const enum rt2800_eeprom_word array,
+       unsigned int offset,
+       u16 *data)
+{
+ unsigned int index;
+
+ index = rt2800_eeprom_word_index(rt2x00dev, array);
+ rt2x00_eeprom_read(rt2x00dev, index + offset, data);
+}
+
 static int rt2800_enable_wlan_rt3290(struct rt2x00_dev *rt2x00dev)
 {
  u32 reg;
@@ -370,6 +516,29 @@ void rt2800_disable_wpdma(struct rt2x00_dev *rt2x00dev)
 }
 EXPORT_SYMBOL_GPL(rt2800_disable_wpdma);
 
+void rt2800_get_txwi_rxwi_size(struct rt2x00_dev *rt2x00dev,
+          unsigned short *txwi_size,
+          unsigned short *rxwi_size)
+{
+ switch (rt2x00dev->chip.rt) {
+ case RT3593:
+  *txwi_size = TXWI_DESC_SIZE_4WORDS;
+  *rxwi_size = RXWI_DESC_SIZE_5WORDS;
+  break;
+
+ case RT5592:
+  *txwi_size = TXWI_DESC_SIZE_5WORDS;
+  *rxwi_size = RXWI_DESC_SIZE_6WORDS;
+  break;
+
+ default:
+  *txwi_size = TXWI_DESC_SIZE_4WORDS;
+  *rxwi_size = RXWI_DESC_SIZE_4WORDS;
+  break;
+ }
+}
+EXPORT_SYMBOL_GPL(rt2800_get_txwi_rxwi_size);
+
 static bool rt2800_check_firmware_crc(const u8 *data, const size_t len)
 {
  u16 fw_crc;
@@ -609,16 +778,16 @@ static int rt2800_agc_to_rssi(struct rt2x00_dev *rt2x00dev, u32 rxwi_w2)
  u8 offset2;
 
  if (rt2x00dev->curr_band == IEEE80211_BAND_2GHZ) {
-  rt2x00_eeprom_read(rt2x00dev, EEPROM_RSSI_BG, &eeprom);
+  rt2800_eeprom_read(rt2x00dev, EEPROM_RSSI_BG, &eeprom);
   offset0 = rt2x00_get_field16(eeprom, EEPROM_RSSI_BG_OFFSET0);
   offset1 = rt2x00_get_field16(eeprom, EEPROM_RSSI_BG_OFFSET1);
-  rt2x00_eeprom_read(rt2x00dev, EEPROM_RSSI_BG2, &eeprom);
+  rt2800_eeprom_read(rt2x00dev, EEPROM_RSSI_BG2, &eeprom);
   offset2 = rt2x00_get_field16(eeprom, EEPROM_RSSI_BG2_OFFSET2);
  } else {
-  rt2x00_eeprom_read(rt2x00dev, EEPROM_RSSI_A, &eeprom);
+  rt2800_eeprom_read(rt2x00dev, EEPROM_RSSI_A, &eeprom);
   offset0 = rt2x00_get_field16(eeprom, EEPROM_RSSI_A_OFFSET0);
   offset1 = rt2x00_get_field16(eeprom, EEPROM_RSSI_A_OFFSET1);
-  rt2x00_eeprom_read(rt2x00dev, EEPROM_RSSI_A2, &eeprom);
+  rt2800_eeprom_read(rt2x00dev, EEPROM_RSSI_A2, &eeprom);
   offset2 = rt2x00_get_field16(eeprom, EEPROM_RSSI_A2_OFFSET2);
  }
 
@@ -766,6 +935,18 @@ void rt2800_txdone_entry(struct queue_entry *entry, u32 status, __le32 *txwi)
 }
 EXPORT_SYMBOL_GPL(rt2800_txdone_entry);
 
+static unsigned int rt2800_hw_beacon_base(struct rt2x00_dev *rt2x00dev,
+       unsigned int index)
+{
+ return HW_BEACON_BASE(index);
+}
+
+static inline u8 rt2800_get_beacon_offset(struct rt2x00_dev *rt2x00dev,
+       unsigned int index)
+{
+ return BEACON_BASE_TO_OFFSET(rt2800_hw_beacon_base(rt2x00dev, index));
+}
+
 void rt2800_write_beacon(struct queue_entry *entry, struct txentry_desc *txdesc)
 {
  struct rt2x00_dev *rt2x00dev = entry->queue->rt2x00dev;
@@ -818,15 +999,15 @@ void rt2800_write_beacon(struct queue_entry *entry, struct txentry_desc *txdesc)
   return;
  }
 
- beacon_base = HW_BEACON_OFFSET(entry->entry_idx);
+ beacon_base = rt2800_hw_beacon_base(rt2x00dev, entry->entry_idx);
+
  rt2800_register_multiwrite(rt2x00dev, beacon_base, entry->skb->data,
        entry->skb->len + padding_len);
 
  /*
-  * Enable beaconing again.
+  * Restore beaconing state.
   */
- rt2x00_set_field32(&reg, BCN_TIME_CFG_BEACON_GEN, 1);
- rt2800_register_write(rt2x00dev, BCN_TIME_CFG, reg);
+ rt2800_register_write(rt2x00dev, BCN_TIME_CFG, orig_reg);
 
  /*
   * Clean up beacon skb.
@@ -837,10 +1018,13 @@ void rt2800_write_beacon(struct queue_entry *entry, struct txentry_desc *txdesc)
 EXPORT_SYMBOL_GPL(rt2800_write_beacon);
 
 static inline void rt2800_clear_beacon_register(struct rt2x00_dev *rt2x00dev,
-      unsigned int beacon_base)
+      unsigned int index)
 {
  int i;
- const int txwi_desc_size = rt2x00dev->ops->bcn->winfo_size;
+ const int txwi_desc_size = rt2x00dev->bcn->winfo_size;
+ unsigned int beacon_base;
+
+ beacon_base = rt2800_hw_beacon_base(rt2x00dev, index);
 
  /*
   * For the Beacon base registers we only need to clear
@@ -854,27 +1038,26 @@ static inline void rt2800_clear_beacon_register(struct rt2x00_dev *rt2x00dev,
 void rt2800_clear_beacon(struct queue_entry *entry)
 {
  struct rt2x00_dev *rt2x00dev = entry->queue->rt2x00dev;
- u32 reg;
+ u32 orig_reg, reg;
 
  /*
   * Disable beaconing while we are reloading the beacon data,
   * otherwise we might be sending out invalid data.
   */
- rt2800_register_read(rt2x00dev, BCN_TIME_CFG, &reg);
+ rt2800_register_read(rt2x00dev, BCN_TIME_CFG, &orig_reg);
+ reg = orig_reg;
  rt2x00_set_field32(&reg, BCN_TIME_CFG_BEACON_GEN, 0);
  rt2800_register_write(rt2x00dev, BCN_TIME_CFG, reg);
 
  /*
   * Clear beacon.
   */
- rt2800_clear_beacon_register(rt2x00dev,
-         HW_BEACON_OFFSET(entry->entry_idx));
+ rt2800_clear_beacon_register(rt2x00dev, entry->entry_idx);
 
  /*
-  * Enabled beaconing again.
+  * Restore beaconing state.
   */
- rt2x00_set_field32(&reg, BCN_TIME_CFG_BEACON_GEN, 1);
- rt2800_register_write(rt2x00dev, BCN_TIME_CFG, reg);
+ rt2800_register_write(rt2x00dev, BCN_TIME_CFG, orig_reg);
 }
 EXPORT_SYMBOL_GPL(rt2800_clear_beacon);
 
@@ -890,6 +1073,9 @@ const struct rt2x00debug rt2800_rt2x00debug = {
   .word_count = CSR_REG_SIZE / sizeof(u32),
  },
  .eeprom = {
+  /* NOTE: The local EEPROM access functions can't
+   * be used here, use the generic versions instead.
+   */
   .read  = rt2x00_eeprom_read,
   .write  = rt2x00_eeprom_write,
   .word_base = EEPROM_BASE,
@@ -1547,7 +1733,7 @@ static void rt2800_config_3572bt_ant(struct rt2x00_dev *rt2x00dev)
  led_r_mode = rt2x00_get_field32(reg, LED_CFG_LED_POLAR) ? 0 : 3;
  if (led_g_mode != rt2x00_get_field32(reg, LED_CFG_G_LED_MODE) ||
      led_r_mode != rt2x00_get_field32(reg, LED_CFG_R_LED_MODE)) {
-  rt2x00_eeprom_read(rt2x00dev, EEPROM_FREQ, &eeprom);
+  rt2800_eeprom_read(rt2x00dev, EEPROM_FREQ, &eeprom);
   led_ctrl = rt2x00_get_field16(eeprom, EEPROM_FREQ_LED_MODE);
   if (led_ctrl == 0 || led_ctrl > 0x40) {
    rt2x00_set_field32(&reg, LED_CFG_G_LED_MODE, led_g_mode);
@@ -1591,7 +1777,7 @@ void rt2800_config_ant(struct rt2x00_dev *rt2x00dev, struct antenna_setup *ant)
  rt2800_bbp_read(rt2x00dev, 3, &r3);
 
  if (rt2x00_rt(rt2x00dev, RT3572) &&
-     test_bit(CAPABILITY_BT_COEXIST, &rt2x00dev->cap_flags))
+     rt2x00_has_cap_bt_coexist(rt2x00dev))
   rt2800_config_3572bt_ant(rt2x00dev);
 
  /*
@@ -1603,13 +1789,13 @@ void rt2800_config_ant(struct rt2x00_dev *rt2x00dev, struct antenna_setup *ant)
   break;
  case 2:
   if (rt2x00_rt(rt2x00dev, RT3572) &&
-      test_bit(CAPABILITY_BT_COEXIST, &rt2x00dev->cap_flags))
+      rt2x00_has_cap_bt_coexist(rt2x00dev))
    rt2x00_set_field8(&r1, BBP1_TX_ANTENNA, 1);
   else
    rt2x00_set_field8(&r1, BBP1_TX_ANTENNA, 2);
   break;
  case 3:
-  rt2x00_set_field8(&r1, BBP1_TX_ANTENNA, 0);
+  rt2x00_set_field8(&r1, BBP1_TX_ANTENNA, 2);
   break;
  }
 
@@ -1622,7 +1808,7 @@ void rt2800_config_ant(struct rt2x00_dev *rt2x00dev, struct antenna_setup *ant)
       rt2x00_rt(rt2x00dev, RT3090) ||
       rt2x00_rt(rt2x00dev, RT3352) ||
       rt2x00_rt(rt2x00dev, RT3390)) {
-   rt2x00_eeprom_read(rt2x00dev,
+   rt2800_eeprom_read(rt2x00dev,
         EEPROM_NIC_CONF1, &eeprom);
    if (rt2x00_get_field16(eeprom,
       EEPROM_NIC_CONF1_ANT_DIVERSITY))
@@ -1633,7 +1819,7 @@ void rt2800_config_ant(struct rt2x00_dev *rt2x00dev, struct antenna_setup *ant)
   break;
  case 2:
   if (rt2x00_rt(rt2x00dev, RT3572) &&
-      test_bit(CAPABILITY_BT_COEXIST, &rt2x00dev->cap_flags)) {
+      rt2x00_has_cap_bt_coexist(rt2x00dev)) {
    rt2x00_set_field8(&r3, BBP3_RX_ADC, 1);
    rt2x00_set_field8(&r3, BBP3_RX_ANTENNA,
     rt2x00dev->curr_band == IEEE80211_BAND_5GHZ);
@@ -1649,6 +1835,13 @@ void rt2800_config_ant(struct rt2x00_dev *rt2x00dev, struct antenna_setup *ant)
 
  rt2800_bbp_write(rt2x00dev, 3, r3);
  rt2800_bbp_write(rt2x00dev, 1, r1);
+
+ if (rt2x00_rt(rt2x00dev, RT3593)) {
+  if (ant->rx_chain_num == 1)
+   rt2800_bbp_write(rt2x00dev, 86, 0x00);
+  else
+   rt2800_bbp_write(rt2x00dev, 86, 0x46);
+ }
 }
 EXPORT_SYMBOL_GPL(rt2800_config_ant);
 
@@ -1659,22 +1852,73 @@ static void rt2800_config_lna_gain(struct rt2x00_dev *rt2x00dev,
  short lna_gain;
 
  if (libconf->rf.channel <= 14) {
-  rt2x00_eeprom_read(rt2x00dev, EEPROM_LNA, &eeprom);
+  rt2800_eeprom_read(rt2x00dev, EEPROM_LNA, &eeprom);
   lna_gain = rt2x00_get_field16(eeprom, EEPROM_LNA_BG);
  } else if (libconf->rf.channel <= 64) {
-  rt2x00_eeprom_read(rt2x00dev, EEPROM_LNA, &eeprom);
+  rt2800_eeprom_read(rt2x00dev, EEPROM_LNA, &eeprom);
   lna_gain = rt2x00_get_field16(eeprom, EEPROM_LNA_A0);
  } else if (libconf->rf.channel <= 128) {
-  rt2x00_eeprom_read(rt2x00dev, EEPROM_RSSI_BG2, &eeprom);
-  lna_gain = rt2x00_get_field16(eeprom, EEPROM_RSSI_BG2_LNA_A1);
+  if (rt2x00_rt(rt2x00dev, RT3593)) {
+   rt2800_eeprom_read(rt2x00dev, EEPROM_EXT_LNA2, &eeprom);
+   lna_gain = rt2x00_get_field16(eeprom,
+            EEPROM_EXT_LNA2_A1);
+  } else {
+   rt2800_eeprom_read(rt2x00dev, EEPROM_RSSI_BG2, &eeprom);
+   lna_gain = rt2x00_get_field16(eeprom,
+            EEPROM_RSSI_BG2_LNA_A1);
+  }
  } else {
-  rt2x00_eeprom_read(rt2x00dev, EEPROM_RSSI_A2, &eeprom);
-  lna_gain = rt2x00_get_field16(eeprom, EEPROM_RSSI_A2_LNA_A2);
+  if (rt2x00_rt(rt2x00dev, RT3593)) {
+   rt2800_eeprom_read(rt2x00dev, EEPROM_EXT_LNA2, &eeprom);
+   lna_gain = rt2x00_get_field16(eeprom,
+            EEPROM_EXT_LNA2_A2);
+  } else {
+   rt2800_eeprom_read(rt2x00dev, EEPROM_RSSI_A2, &eeprom);
+   lna_gain = rt2x00_get_field16(eeprom,
+            EEPROM_RSSI_A2_LNA_A2);
+  }
  }
 
  rt2x00dev->lna_gain = lna_gain;
 }
 
+#define FREQ_OFFSET_BOUND 0x5f
+
+static void rt2800_adjust_freq_offset(struct rt2x00_dev *rt2x00dev)
+{
+ u8 freq_offset, prev_freq_offset;
+ u8 rfcsr, prev_rfcsr;
+
+ freq_offset = rt2x00_get_field8(rt2x00dev->freq_offset, RFCSR17_CODE);
+ freq_offset = min_t(u8, freq_offset, FREQ_OFFSET_BOUND);
+
+ rt2800_rfcsr_read(rt2x00dev, 17, &rfcsr);
+ prev_rfcsr = rfcsr;
+
+ rt2x00_set_field8(&rfcsr, RFCSR17_CODE, freq_offset);
+ if (rfcsr == prev_rfcsr)
+  return;
+
+ if (rt2x00_is_usb(rt2x00dev)) {
+  rt2800_mcu_request(rt2x00dev, MCU_FREQ_OFFSET, 0xff,
+       freq_offset, prev_rfcsr);
+  return;
+ }
+
+ prev_freq_offset = rt2x00_get_field8(prev_rfcsr, RFCSR17_CODE);
+ while (prev_freq_offset != freq_offset) {
+  if (prev_freq_offset < freq_offset)
+   prev_freq_offset++;
+  else
+   prev_freq_offset--;
+
+  rt2x00_set_field8(&rfcsr, RFCSR17_CODE, prev_freq_offset);
+  rt2800_rfcsr_write(rt2x00dev, 17, rfcsr);
+
+  usleep_range(1000, 1500);
+ }
+}
+
 static void rt2800_config_channel_rf2xxx(struct rt2x00_dev *rt2x00dev,
       struct ieee80211_conf *conf,
       struct rf_channel *rf,
@@ -1779,13 +2023,6 @@ static void rt2800_config_channel_rf3xxx(struct rt2x00_dev *rt2x00dev,
      rt2x00dev->default_ant.tx_chain_num <= 2);
  rt2800_rfcsr_write(rt2x00dev, 1, rfcsr);
 
- rt2800_rfcsr_read(rt2x00dev, 30, &rfcsr);
- rt2x00_set_field8(&rfcsr, RFCSR30_RF_CALIBRATION, 1);
- rt2800_rfcsr_write(rt2x00dev, 30, rfcsr);
- msleep(1);
- rt2x00_set_field8(&rfcsr, RFCSR30_RF_CALIBRATION, 0);
- rt2800_rfcsr_write(rt2x00dev, 30, rfcsr);
-
  rt2800_rfcsr_read(rt2x00dev, 23, &rfcsr);
  rt2x00_set_field8(&rfcsr, RFCSR23_FREQ_OFFSET, rt2x00dev->freq_offset);
  rt2800_rfcsr_write(rt2x00dev, 23, rfcsr);
@@ -1891,7 +2128,7 @@ static void rt2800_config_channel_rf3052(struct rt2x00_dev *rt2x00dev,
  rt2x00_set_field8(&rfcsr, RFCSR1_TX1_PD, 0);
  rt2x00_set_field8(&rfcsr, RFCSR1_RX2_PD, 0);
  rt2x00_set_field8(&rfcsr, RFCSR1_TX2_PD, 0);
- if (test_bit(CAPABILITY_BT_COEXIST, &rt2x00dev->cap_flags)) {
+ if (rt2x00_has_cap_bt_coexist(rt2x00dev)) {
   if (rf->channel <= 14) {
    rt2x00_set_field8(&rfcsr, RFCSR1_RX0_PD, 1);
    rt2x00_set_field8(&rfcsr, RFCSR1_TX0_PD, 1);
@@ -1993,22 +2230,306 @@ static void rt2800_config_channel_rf3052(struct rt2x00_dev *rt2x00dev,
  rt2800_rfcsr_write(rt2x00dev, 7, rfcsr);
 }
 
-#define POWER_BOUND  0x27
-#define POWER_BOUND_5G  0x2b
-#define FREQ_OFFSET_BOUND 0x5f
-
-static void rt2800_adjust_freq_offset(struct rt2x00_dev *rt2x00dev)
+static void rt2800_config_channel_rf3053(struct rt2x00_dev *rt2x00dev,
+      struct ieee80211_conf *conf,
+      struct rf_channel *rf,
+      struct channel_info *info)
 {
+ struct rt2800_drv_data *drv_data = rt2x00dev->drv_data;
+ u8 txrx_agc_fc;
+ u8 txrx_h20m;
  u8 rfcsr;
+ u8 bbp;
+ const bool txbf_enabled = false; /* TODO */
 
- rt2800_rfcsr_read(rt2x00dev, 17, &rfcsr);
- if (rt2x00dev->freq_offset > FREQ_OFFSET_BOUND)
-  rt2x00_set_field8(&rfcsr, RFCSR17_CODE, FREQ_OFFSET_BOUND);
+ /* TODO: use TX{0,1,2}FinePowerControl values from EEPROM */
+ rt2800_bbp_read(rt2x00dev, 109, &bbp);
+ rt2x00_set_field8(&bbp, BBP109_TX0_POWER, 0);
+ rt2x00_set_field8(&bbp, BBP109_TX1_POWER, 0);
+ rt2800_bbp_write(rt2x00dev, 109, bbp);
+
+ rt2800_bbp_read(rt2x00dev, 110, &bbp);
+ rt2x00_set_field8(&bbp, BBP110_TX2_POWER, 0);
+ rt2800_bbp_write(rt2x00dev, 110, bbp);
+
+ if (rf->channel <= 14) {
+  /* Restore BBP 25 & 26 for 2.4 GHz */
+  rt2800_bbp_write(rt2x00dev, 25, drv_data->bbp25);
+  rt2800_bbp_write(rt2x00dev, 26, drv_data->bbp26);
+ } else {
+  /* Hard code BBP 25 & 26 for 5GHz */
+
+  /* Enable IQ Phase correction */
+  rt2800_bbp_write(rt2x00dev, 25, 0x09);
+  /* Setup IQ Phase correction value */
+  rt2800_bbp_write(rt2x00dev, 26, 0xff);
+ }
+
+ rt2800_rfcsr_write(rt2x00dev, 8, rf->rf1);
+ rt2800_rfcsr_write(rt2x00dev, 9, rf->rf3 & 0xf);
+
+ rt2800_rfcsr_read(rt2x00dev, 11, &rfcsr);
+ rt2x00_set_field8(&rfcsr, RFCSR11_R, (rf->rf2 & 0x3));
+ rt2800_rfcsr_write(rt2x00dev, 11, rfcsr);
+
+ rt2800_rfcsr_read(rt2x00dev, 11, &rfcsr);
+ rt2x00_set_field8(&rfcsr, RFCSR11_PLL_IDOH, 1);
+ if (rf->channel <= 14)
+  rt2x00_set_field8(&rfcsr, RFCSR11_PLL_MOD, 1);
  else
-  rt2x00_set_field8(&rfcsr, RFCSR17_CODE, rt2x00dev->freq_offset);
- rt2800_rfcsr_write(rt2x00dev, 17, rfcsr);
+  rt2x00_set_field8(&rfcsr, RFCSR11_PLL_MOD, 2);
+ rt2800_rfcsr_write(rt2x00dev, 11, rfcsr);
+
+ rt2800_rfcsr_read(rt2x00dev, 53, &rfcsr);
+ if (rf->channel <= 14) {
+  rfcsr = 0;
+  rt2x00_set_field8(&rfcsr, RFCSR53_TX_POWER,
+      info->default_power1 & 0x1f);
+ } else {
+  if (rt2x00_is_usb(rt2x00dev))
+   rfcsr = 0x40;
+
+  rt2x00_set_field8(&rfcsr, RFCSR53_TX_POWER,
+      ((info->default_power1 & 0x18) << 1) |
+      (info->default_power1 & 7));
+ }
+ rt2800_rfcsr_write(rt2x00dev, 53, rfcsr);
+
+ rt2800_rfcsr_read(rt2x00dev, 55, &rfcsr);
+ if (rf->channel <= 14) {
+  rfcsr = 0;
+  rt2x00_set_field8(&rfcsr, RFCSR55_TX_POWER,
+      info->default_power2 & 0x1f);
+ } else {
+  if (rt2x00_is_usb(rt2x00dev))
+   rfcsr = 0x40;
+
+  rt2x00_set_field8(&rfcsr, RFCSR55_TX_POWER,
+      ((info->default_power2 & 0x18) << 1) |
+      (info->default_power2 & 7));
+ }
+ rt2800_rfcsr_write(rt2x00dev, 55, rfcsr);
+
+ rt2800_rfcsr_read(rt2x00dev, 54, &rfcsr);
+ if (rf->channel <= 14) {
+  rfcsr = 0;
+  rt2x00_set_field8(&rfcsr, RFCSR54_TX_POWER,
+      info->default_power3 & 0x1f);
+ } else {
+  if (rt2x00_is_usb(rt2x00dev))
+   rfcsr = 0x40;
+
+  rt2x00_set_field8(&rfcsr, RFCSR54_TX_POWER,
+      ((info->default_power3 & 0x18) << 1) |
+      (info->default_power3 & 7));
+ }
+ rt2800_rfcsr_write(rt2x00dev, 54, rfcsr);
+
+ rt2800_rfcsr_read(rt2x00dev, 1, &rfcsr);
+ rt2x00_set_field8(&rfcsr, RFCSR1_RX0_PD, 0);
+ rt2x00_set_field8(&rfcsr, RFCSR1_TX0_PD, 0);
+ rt2x00_set_field8(&rfcsr, RFCSR1_RX1_PD, 0);
+ rt2x00_set_field8(&rfcsr, RFCSR1_TX1_PD, 0);
+ rt2x00_set_field8(&rfcsr, RFCSR1_RX2_PD, 0);
+ rt2x00_set_field8(&rfcsr, RFCSR1_TX2_PD, 0);
+ rt2x00_set_field8(&rfcsr, RFCSR1_RF_BLOCK_EN, 1);
+ rt2x00_set_field8(&rfcsr, RFCSR1_PLL_PD, 1);
+
+ switch (rt2x00dev->default_ant.tx_chain_num) {
+ case 3:
+  rt2x00_set_field8(&rfcsr, RFCSR1_TX2_PD, 1);
+  /* fallthrough */
+ case 2:
+  rt2x00_set_field8(&rfcsr, RFCSR1_TX1_PD, 1);
+  /* fallthrough */
+ case 1:
+  rt2x00_set_field8(&rfcsr, RFCSR1_TX0_PD, 1);
+  break;
+ }
+
+ switch (rt2x00dev->default_ant.rx_chain_num) {
+ case 3:
+  rt2x00_set_field8(&rfcsr, RFCSR1_RX2_PD, 1);
+  /* fallthrough */
+ case 2:
+  rt2x00_set_field8(&rfcsr, RFCSR1_RX1_PD, 1);
+  /* fallthrough */
+ case 1:
+  rt2x00_set_field8(&rfcsr, RFCSR1_RX0_PD, 1);
+  break;
+ }
+ rt2800_rfcsr_write(rt2x00dev, 1, rfcsr);
+
+ rt2800_adjust_freq_offset(rt2x00dev);
+
+ if (conf_is_ht40(conf)) {
+  txrx_agc_fc = rt2x00_get_field8(drv_data->calibration_bw40,
+      RFCSR24_TX_AGC_FC);
+  txrx_h20m = rt2x00_get_field8(drv_data->calibration_bw40,
+           RFCSR24_TX_H20M);
+ } else {
+  txrx_agc_fc = rt2x00_get_field8(drv_data->calibration_bw20,
+      RFCSR24_TX_AGC_FC);
+  txrx_h20m = rt2x00_get_field8(drv_data->calibration_bw20,
+           RFCSR24_TX_H20M);
+ }
+
+ /* NOTE: the reference driver does not writes the new value
+  * back to RFCSR 32
+  */
+ rt2800_rfcsr_read(rt2x00dev, 32, &rfcsr);
+ rt2x00_set_field8(&rfcsr, RFCSR32_TX_AGC_FC, txrx_agc_fc);
+
+ if (rf->channel <= 14)
+  rfcsr = 0xa0;
+ else
+  rfcsr = 0x80;
+ rt2800_rfcsr_write(rt2x00dev, 31, rfcsr);
+
+ rt2800_rfcsr_read(rt2x00dev, 30, &rfcsr);
+ rt2x00_set_field8(&rfcsr, RFCSR30_TX_H20M, txrx_h20m);
+ rt2x00_set_field8(&rfcsr, RFCSR30_RX_H20M, txrx_h20m);
+ rt2800_rfcsr_write(rt2x00dev, 30, rfcsr);
+
+ /* Band selection */
+ rt2800_rfcsr_read(rt2x00dev, 36, &rfcsr);
+ if (rf->channel <= 14)
+  rt2x00_set_field8(&rfcsr, RFCSR36_RF_BS, 1);
+ else
+  rt2x00_set_field8(&rfcsr, RFCSR36_RF_BS, 0);
+ rt2800_rfcsr_write(rt2x00dev, 36, rfcsr);
+
+ rt2800_rfcsr_read(rt2x00dev, 34, &rfcsr);
+ if (rf->channel <= 14)
+  rfcsr = 0x3c;
+ else
+  rfcsr = 0x20;
+ rt2800_rfcsr_write(rt2x00dev, 34, rfcsr);
+
+ rt2800_rfcsr_read(rt2x00dev, 12, &rfcsr);
+ if (rf->channel <= 14)
+  rfcsr = 0x1a;
+ else
+  rfcsr = 0x12;
+ rt2800_rfcsr_write(rt2x00dev, 12, rfcsr);
+
+ rt2800_rfcsr_read(rt2x00dev, 6, &rfcsr);
+ if (rf->channel >= 1 && rf->channel <= 14)
+  rt2x00_set_field8(&rfcsr, RFCSR6_VCO_IC, 1);
+ else if (rf->channel >= 36 && rf->channel <= 64)
+  rt2x00_set_field8(&rfcsr, RFCSR6_VCO_IC, 2);
+ else if (rf->channel >= 100 && rf->channel <= 128)
+  rt2x00_set_field8(&rfcsr, RFCSR6_VCO_IC, 2);
+ else
+  rt2x00_set_field8(&rfcsr, RFCSR6_VCO_IC, 1);
+ rt2800_rfcsr_write(rt2x00dev, 6, rfcsr);
+
+ rt2800_rfcsr_read(rt2x00dev, 30, &rfcsr);
+ rt2x00_set_field8(&rfcsr, RFCSR30_RX_VCM, 2);
+ rt2800_rfcsr_write(rt2x00dev, 30, rfcsr);
+
+ rt2800_rfcsr_write(rt2x00dev, 46, 0x60);
+
+ if (rf->channel <= 14) {
+  rt2800_rfcsr_write(rt2x00dev, 10, 0xd3);
+  rt2800_rfcsr_write(rt2x00dev, 13, 0x12);
+ } else {
+  rt2800_rfcsr_write(rt2x00dev, 10, 0xd8);
+  rt2800_rfcsr_write(rt2x00dev, 13, 0x23);
+ }
+
+ rt2800_rfcsr_read(rt2x00dev, 51, &rfcsr);
+ rt2x00_set_field8(&rfcsr, RFCSR51_BITS01, 1);
+ rt2800_rfcsr_write(rt2x00dev, 51, rfcsr);
+
+ rt2800_rfcsr_read(rt2x00dev, 51, &rfcsr);
+ if (rf->channel <= 14) {
+  rt2x00_set_field8(&rfcsr, RFCSR51_BITS24, 5);
+  rt2x00_set_field8(&rfcsr, RFCSR51_BITS57, 3);
+ } else {
+  rt2x00_set_field8(&rfcsr, RFCSR51_BITS24, 4);
+  rt2x00_set_field8(&rfcsr, RFCSR51_BITS57, 2);
+ }
+ rt2800_rfcsr_write(rt2x00dev, 51, rfcsr);
+
+ rt2800_rfcsr_read(rt2x00dev, 49, &rfcsr);
+ if (rf->channel <= 14)
+  rt2x00_set_field8(&rfcsr, RFCSR49_TX_LO1_IC, 3);
+ else
+  rt2x00_set_field8(&rfcsr, RFCSR49_TX_LO1_IC, 2);
+
+ if (txbf_enabled)
+  rt2x00_set_field8(&rfcsr, RFCSR49_TX_DIV, 1);
+
+ rt2800_rfcsr_write(rt2x00dev, 49, rfcsr);
+
+ rt2800_rfcsr_read(rt2x00dev, 50, &rfcsr);
+ rt2x00_set_field8(&rfcsr, RFCSR50_TX_LO1_EN, 0);
+ rt2800_rfcsr_write(rt2x00dev, 50, rfcsr);
+
+ rt2800_rfcsr_read(rt2x00dev, 57, &rfcsr);
+ if (rf->channel <= 14)
+  rt2x00_set_field8(&rfcsr, RFCSR57_DRV_CC, 0x1b);
+ else
+  rt2x00_set_field8(&rfcsr, RFCSR57_DRV_CC, 0x0f);
+ rt2800_rfcsr_write(rt2x00dev, 57, rfcsr);
+
+ if (rf->channel <= 14) {
+  rt2800_rfcsr_write(rt2x00dev, 44, 0x93);
+  rt2800_rfcsr_write(rt2x00dev, 52, 0x45);
+ } else {
+  rt2800_rfcsr_write(rt2x00dev, 44, 0x9b);
+  rt2800_rfcsr_write(rt2x00dev, 52, 0x05);
+ }
+
+ /* Initiate VCO calibration */
+ rt2800_rfcsr_read(rt2x00dev, 3, &rfcsr);
+ if (rf->channel <= 14) {
+  rt2x00_set_field8(&rfcsr, RFCSR3_VCOCAL_EN, 1);
+ } else {
+  rt2x00_set_field8(&rfcsr, RFCSR3_BIT1, 1);
+  rt2x00_set_field8(&rfcsr, RFCSR3_BIT2, 1);
+  rt2x00_set_field8(&rfcsr, RFCSR3_BIT3, 1);
+  rt2x00_set_field8(&rfcsr, RFCSR3_BIT4, 1);
+  rt2x00_set_field8(&rfcsr, RFCSR3_BIT5, 1);
+  rt2x00_set_field8(&rfcsr, RFCSR3_VCOCAL_EN, 1);
+ }
+ rt2800_rfcsr_write(rt2x00dev, 3, rfcsr);
+
+ if (rf->channel >= 1 && rf->channel <= 14) {
+  rfcsr = 0x23;
+  if (txbf_enabled)
+   rt2x00_set_field8(&rfcsr, RFCSR39_RX_DIV, 1);
+  rt2800_rfcsr_write(rt2x00dev, 39, rfcsr);
+
+  rt2800_rfcsr_write(rt2x00dev, 45, 0xbb);
+ } else if (rf->channel >= 36 && rf->channel <= 64) {
+  rfcsr = 0x36;
+  if (txbf_enabled)
+   rt2x00_set_field8(&rfcsr, RFCSR39_RX_DIV, 1);
+  rt2800_rfcsr_write(rt2x00dev, 39, 0x36);
+
+  rt2800_rfcsr_write(rt2x00dev, 45, 0xeb);
+ } else if (rf->channel >= 100 && rf->channel <= 128) {
+  rfcsr = 0x32;
+  if (txbf_enabled)
+   rt2x00_set_field8(&rfcsr, RFCSR39_RX_DIV, 1);
+  rt2800_rfcsr_write(rt2x00dev, 39, rfcsr);
+
+  rt2800_rfcsr_write(rt2x00dev, 45, 0xb3);
+ } else {
+  rfcsr = 0x30;
+  if (txbf_enabled)
+   rt2x00_set_field8(&rfcsr, RFCSR39_RX_DIV, 1);
+  rt2800_rfcsr_write(rt2x00dev, 39, rfcsr);
+
+  rt2800_rfcsr_write(rt2x00dev, 45, 0x9b);
+ }
 }
 
+#define POWER_BOUND  0x27
+#define POWER_BOUND_5G  0x2b
+
 static void rt2800_config_channel_rf3290(struct rt2x00_dev *rt2x00dev,
       struct ieee80211_conf *conf,
       struct rf_channel *rf,
@@ -2116,7 +2637,7 @@ static void rt2800_config_channel_rf53xx(struct rt2x00_dev *rt2x00dev,
 
  if (rt2x00_rt(rt2x00dev, RT5392)) {
   rt2800_rfcsr_read(rt2x00dev, 50, &rfcsr);
-  if (info->default_power1 > POWER_BOUND)
+  if (info->default_power2 > POWER_BOUND)
    rt2x00_set_field8(&rfcsr, RFCSR50_TX, POWER_BOUND);
   else
    rt2x00_set_field8(&rfcsr, RFCSR50_TX,
@@ -2140,7 +2661,7 @@ static void rt2800_config_channel_rf53xx(struct rt2x00_dev *rt2x00dev,
  if (rf->channel <= 14) {
   int idx = rf->channel-1;
 
-  if (test_bit(CAPABILITY_BT_COEXIST, &rt2x00dev->cap_flags)) {
+  if (rt2x00_has_cap_bt_coexist(rt2x00dev)) {
    if (rt2x00_rt_rev_gte(rt2x00dev, RT5390, REV_RT5390F)) {
     /* r55/r59 value array of channel 1~14 */
     static const char r55_bt_rev[] = {0x83, 0x83,
@@ -2563,6 +3084,23 @@ static void rt2800_iq_calibrate(struct rt2x00_dev *rt2x00dev, int channel)
  rt2800_bbp_write(rt2x00dev, 159, cal != 0xff ? cal : 0);
 }
 
+static char rt2800_txpower_to_dev(struct rt2x00_dev *rt2x00dev,
+      unsigned int channel,
+      char txpower)
+{
+ if (rt2x00_rt(rt2x00dev, RT3593))
+  txpower = rt2x00_get_field8(txpower, EEPROM_TXPOWER_ALC);
+
+ if (channel <= 14)
+  return clamp_t(char, txpower, MIN_G_TXPOWER, MAX_G_TXPOWER);
+
+ if (rt2x00_rt(rt2x00dev, RT3593))
+  return clamp_t(char, txpower, MIN_A_TXPOWER_3593,
+          MAX_A_TXPOWER_3593);
+ else
+  return clamp_t(char, txpower, MIN_A_TXPOWER, MAX_A_TXPOWER);
+}
+
 static void rt2800_config_channel(struct rt2x00_dev *rt2x00dev,
       struct ieee80211_conf *conf,
       struct rf_channel *rf,
@@ -2572,13 +3110,14 @@ static void rt2800_config_channel(struct rt2x00_dev *rt2x00dev,
  unsigned int tx_pin;
  u8 bbp, rfcsr;
 
- if (rf->channel <= 14) {
-  info->default_power1 = TXPOWER_G_TO_DEV(info->default_power1);
-  info->default_power2 = TXPOWER_G_TO_DEV(info->default_power2);
- } else {
-  info->default_power1 = TXPOWER_A_TO_DEV(info->default_power1);
-  info->default_power2 = TXPOWER_A_TO_DEV(info->default_power2);
- }
+ info->default_power1 = rt2800_txpower_to_dev(rt2x00dev, rf->channel,
+           info->default_power1);
+ info->default_power2 = rt2800_txpower_to_dev(rt2x00dev, rf->channel,
+           info->default_power2);
+ if (rt2x00dev->default_ant.tx_chain_num > 2)
+  info->default_power3 =
+   rt2800_txpower_to_dev(rt2x00dev, rf->channel,
+           info->default_power3);
 
  switch (rt2x00dev->chip.rf) {
  case RF2020:
@@ -2591,12 +3130,16 @@ static void rt2800_config_channel(struct rt2x00_dev *rt2x00dev,
  case RF3052:
   rt2800_config_channel_rf3052(rt2x00dev, conf, rf, info);
   break;
+ case RF3053:
+  rt2800_config_channel_rf3053(rt2x00dev, conf, rf, info);
+  break;
  case RF3290:
   rt2800_config_channel_rf3290(rt2x00dev, conf, rf, info);
   break;
  case RF3322:
   rt2800_config_channel_rf3322(rt2x00dev, conf, rf, info);
   break;
+ case RF3070:
  case RF5360:
  case RF5370:
  case RF5372:
@@ -2611,7 +3154,8 @@ static void rt2800_config_channel(struct rt2x00_dev *rt2x00dev,
   rt2800_config_channel_rf2xxx(rt2x00dev, conf, rf, info);
  }
 
- if (rt2x00_rf(rt2x00dev, RF3290) ||
+ if (rt2x00_rf(rt2x00dev, RF3070) ||
+     rt2x00_rf(rt2x00dev, RF3290) ||
      rt2x00_rf(rt2x00dev, RF3322) ||
      rt2x00_rf(rt2x00dev, RF5360) ||
      rt2x00_rf(rt2x00dev, RF5370) ||
@@ -2636,6 +3180,23 @@ static void rt2800_config_channel(struct rt2x00_dev *rt2x00dev,
   rt2800_bbp_write(rt2x00dev, 66, 0x26 + rt2x00dev->lna_gain);
   rt2800_bbp_write(rt2x00dev, 27, 0x20);
   rt2800_bbp_write(rt2x00dev, 66, 0x26 + rt2x00dev->lna_gain);
+ } else if (rt2x00_rt(rt2x00dev, RT3593)) {
+  if (rf->channel > 14) {
+   /* Disable CCK Packet detection on 5GHz */
+   rt2800_bbp_write(rt2x00dev, 70, 0x00);
+  } else {
+   rt2800_bbp_write(rt2x00dev, 70, 0x0a);
+  }
+
+  if (conf_is_ht40(conf))
+   rt2800_bbp_write(rt2x00dev, 105, 0x04);
+  else
+   rt2800_bbp_write(rt2x00dev, 105, 0x34);
+
+  rt2800_bbp_write(rt2x00dev, 62, 0x37 - rt2x00dev->lna_gain);
+  rt2800_bbp_write(rt2x00dev, 63, 0x37 - rt2x00dev->lna_gain);
+  rt2800_bbp_write(rt2x00dev, 64, 0x37 - rt2x00dev->lna_gain);
+  rt2800_bbp_write(rt2x00dev, 77, 0x98);
  } else {
   rt2800_bbp_write(rt2x00dev, 62, 0x37 - rt2x00dev->lna_gain);
   rt2800_bbp_write(rt2x00dev, 63, 0x37 - rt2x00dev->lna_gain);
@@ -2646,22 +3207,32 @@ static void rt2800_config_channel(struct rt2x00_dev *rt2x00dev,
  if (rf->channel <= 14) {
   if (!rt2x00_rt(rt2x00dev, RT5390) &&
       !rt2x00_rt(rt2x00dev, RT5392)) {
-   if (test_bit(CAPABILITY_EXTERNAL_LNA_BG,
-         &rt2x00dev->cap_flags)) {
+   if (rt2x00_has_cap_external_lna_bg(rt2x00dev)) {
     rt2800_bbp_write(rt2x00dev, 82, 0x62);
     rt2800_bbp_write(rt2x00dev, 75, 0x46);
    } else {
-    rt2800_bbp_write(rt2x00dev, 82, 0x84);
+    if (rt2x00_rt(rt2x00dev, RT3593))
+     rt2800_bbp_write(rt2x00dev, 82, 0x62);
+    else
+     rt2800_bbp_write(rt2x00dev, 82, 0x84);
     rt2800_bbp_write(rt2x00dev, 75, 0x50);
    }
+   if (rt2x00_rt(rt2x00dev, RT3593))
+    rt2800_bbp_write(rt2x00dev, 83, 0x8a);
   }
+
  } else {
   if (rt2x00_rt(rt2x00dev, RT3572))
    rt2800_bbp_write(rt2x00dev, 82, 0x94);
+  else if (rt2x00_rt(rt2x00dev, RT3593))
+   rt2800_bbp_write(rt2x00dev, 82, 0x82);
   else
    rt2800_bbp_write(rt2x00dev, 82, 0xf2);
 
-  if (test_bit(CAPABILITY_EXTERNAL_LNA_A, &rt2x00dev->cap_flags))
+  if (rt2x00_rt(rt2x00dev, RT3593))
+   rt2800_bbp_write(rt2x00dev, 83, 0x9a);
+
+  if (rt2x00_has_cap_external_lna_a(rt2x00dev))
    rt2800_bbp_write(rt2x00dev, 75, 0x46);
   else
    rt2800_bbp_write(rt2x00dev, 75, 0x50);
@@ -2678,36 +3249,111 @@ static void rt2800_config_channel(struct rt2x00_dev *rt2x00dev,
 
  tx_pin = 0;
 
- /* Turn on unused PA or LNA when not using 1T or 1R */
- if (rt2x00dev->default_ant.tx_chain_num == 2) {
+ switch (rt2x00dev->default_ant.tx_chain_num) {
+ case 3:
+  /* Turn on tertiary PAs */
+  rt2x00_set_field32(&tx_pin, TX_PIN_CFG_PA_PE_A2_EN,
+       rf->channel > 14);
+  rt2x00_set_field32(&tx_pin, TX_PIN_CFG_PA_PE_G2_EN,
+       rf->channel <= 14);
+  /* fall-through */
+ case 2:
+  /* Turn on secondary PAs */
   rt2x00_set_field32(&tx_pin, TX_PIN_CFG_PA_PE_A1_EN,
        rf->channel > 14);
   rt2x00_set_field32(&tx_pin, TX_PIN_CFG_PA_PE_G1_EN,
        rf->channel <= 14);
+  /* fall-through */
+ case 1:
+  /* Turn on primary PAs */
+  rt2x00_set_field32(&tx_pin, TX_PIN_CFG_PA_PE_A0_EN,
+       rf->channel > 14);
+  if (rt2x00_has_cap_bt_coexist(rt2x00dev))
+   rt2x00_set_field32(&tx_pin, TX_PIN_CFG_PA_PE_G0_EN, 1);
+  else
+   rt2x00_set_field32(&tx_pin, TX_PIN_CFG_PA_PE_G0_EN,
+        rf->channel <= 14);
+  break;
  }
 
- /* Turn on unused PA or LNA when not using 1T or 1R */
- if (rt2x00dev->default_ant.rx_chain_num == 2) {
+ switch (rt2x00dev->default_ant.rx_chain_num) {
+ case 3:
+  /* Turn on tertiary LNAs */
+  rt2x00_set_field32(&tx_pin, TX_PIN_CFG_LNA_PE_A2_EN, 1);
+  rt2x00_set_field32(&tx_pin, TX_PIN_CFG_LNA_PE_G2_EN, 1);
+  /* fall-through */
+ case 2:
+  /* Turn on secondary LNAs */
   rt2x00_set_field32(&tx_pin, TX_PIN_CFG_LNA_PE_A1_EN, 1);
   rt2x00_set_field32(&tx_pin, TX_PIN_CFG_LNA_PE_G1_EN, 1);
+  /* fall-through */
+ case 1:
+  /* Turn on primary LNAs */
+  rt2x00_set_field32(&tx_pin, TX_PIN_CFG_LNA_PE_A0_EN, 1);
+  rt2x00_set_field32(&tx_pin, TX_PIN_CFG_LNA_PE_G0_EN, 1);
+  break;
  }
 
- rt2x00_set_field32(&tx_pin, TX_PIN_CFG_LNA_PE_A0_EN, 1);
- rt2x00_set_field32(&tx_pin, TX_PIN_CFG_LNA_PE_G0_EN, 1);
  rt2x00_set_field32(&tx_pin, TX_PIN_CFG_RFTR_EN, 1);
  rt2x00_set_field32(&tx_pin, TX_PIN_CFG_TRSW_EN, 1);
- if (test_bit(CAPABILITY_BT_COEXIST, &rt2x00dev->cap_flags))
-  rt2x00_set_field32(&tx_pin, TX_PIN_CFG_PA_PE_G0_EN, 1);
- else
-  rt2x00_set_field32(&tx_pin, TX_PIN_CFG_PA_PE_G0_EN,
-       rf->channel <= 14);
- rt2x00_set_field32(&tx_pin, TX_PIN_CFG_PA_PE_A0_EN, rf->channel > 14);
 
  rt2800_register_write(rt2x00dev, TX_PIN_CFG, tx_pin);
 
- if (rt2x00_rt(rt2x00dev, RT3572))
+ if (rt2x00_rt(rt2x00dev, RT3572)) {
   rt2800_rfcsr_write(rt2x00dev, 8, 0x80);
 
+  /* AGC init */
+  if (rf->channel <= 14)
+   reg = 0x1c + (2 * rt2x00dev->lna_gain);
+  else
+   reg = 0x22 + ((rt2x00dev->lna_gain * 5) / 3);
+
+  rt2800_bbp_write_with_rx_chain(rt2x00dev, 66, reg);
+ }
+
+ if (rt2x00_rt(rt2x00dev, RT3593)) {
+  rt2800_register_read(rt2x00dev, GPIO_CTRL, &reg);
+
+  /* Band selection */
+  if (rt2x00_is_usb(rt2x00dev) ||
+      rt2x00_is_pcie(rt2x00dev)) {
+   /* GPIO #8 controls all paths */
+   rt2x00_set_field32(&reg, GPIO_CTRL_DIR8, 0);
+   if (rf->channel <= 14)
+    rt2x00_set_field32(&reg, GPIO_CTRL_VAL8, 1);
+   else
+    rt2x00_set_field32(&reg, GPIO_CTRL_VAL8, 0);
+  }
+
+  /* LNA PE control. */
+  if (rt2x00_is_usb(rt2x00dev)) {
+   /* GPIO #4 controls PE0 and PE1,
+    * GPIO #7 controls PE2
+    */
+   rt2x00_set_field32(&reg, GPIO_CTRL_DIR4, 0);
+   rt2x00_set_field32(&reg, GPIO_CTRL_DIR7, 0);
+
+   rt2x00_set_field32(&reg, GPIO_CTRL_VAL4, 1);
+   rt2x00_set_field32(&reg, GPIO_CTRL_VAL7, 1);
+  } else if (rt2x00_is_pcie(rt2x00dev)) {
+   /* GPIO #4 controls PE0, PE1 and PE2 */
+   rt2x00_set_field32(&reg, GPIO_CTRL_DIR4, 0);
+   rt2x00_set_field32(&reg, GPIO_CTRL_VAL4, 1);
+  }
+
+  rt2800_register_write(rt2x00dev, GPIO_CTRL, reg);
+
+  /* AGC init */
+  if (rf->channel <= 14)
+   reg = 0x1c + 2 * rt2x00dev->lna_gain;
+  else
+   reg = 0x22 + ((rt2x00dev->lna_gain * 5) / 3);
+
+  rt2800_bbp_write_with_rx_chain(rt2x00dev, 66, reg);
+
+  usleep_range(1000, 1500);
+ }
+
  if (rt2x00_rt(rt2x00dev, RT5592)) {
   rt2800_bbp_write(rt2x00dev, 195, 141);
   rt2800_bbp_write(rt2x00dev, 196, conf_is_ht40(conf) ? 0x10 : 0x1a);
@@ -2769,7 +3415,7 @@ static int rt2800_get_gain_calibration_delta(struct rt2x00_dev *rt2x00dev)
  /*
   * First check if temperature compensation is supported.
   */
- rt2x00_eeprom_read(rt2x00dev, EEPROM_NIC_CONF1, &eeprom);
+ rt2800_eeprom_read(rt2x00dev, EEPROM_NIC_CONF1, &eeprom);
  if (!rt2x00_get_field16(eeprom, EEPROM_NIC_CONF1_EXTERNAL_TX_ALC))
   return 0;
 
@@ -2782,62 +3428,62 @@ static int rt2800_get_gain_calibration_delta(struct rt2x00_dev *rt2x00dev)
   * Example TSSI bounds  0xF0 0xD0 0xB5 0xA0 0x88 0x45 0x25 0x15 0x00
   */
  if (rt2x00dev->curr_band == IEEE80211_BAND_2GHZ) {
-  rt2x00_eeprom_read(rt2x00dev, EEPROM_TSSI_BOUND_BG1, &eeprom);
+  rt2800_eeprom_read(rt2x00dev, EEPROM_TSSI_BOUND_BG1, &eeprom);
   tssi_bounds[0] = rt2x00_get_field16(eeprom,
      EEPROM_TSSI_BOUND_BG1_MINUS4);
   tssi_bounds[1] = rt2x00_get_field16(eeprom,
      EEPROM_TSSI_BOUND_BG1_MINUS3);
 
-  rt2x00_eeprom_read(rt2x00dev, EEPROM_TSSI_BOUND_BG2, &eeprom);
+  rt2800_eeprom_read(rt2x00dev, EEPROM_TSSI_BOUND_BG2, &eeprom);
   tssi_bounds[2] = rt2x00_get_field16(eeprom,
      EEPROM_TSSI_BOUND_BG2_MINUS2);
   tssi_bounds[3] = rt2x00_get_field16(eeprom,
      EEPROM_TSSI_BOUND_BG2_MINUS1);
 
-  rt2x00_eeprom_read(rt2x00dev, EEPROM_TSSI_BOUND_BG3, &eeprom);
+  rt2800_eeprom_read(rt2x00dev, EEPROM_TSSI_BOUND_BG3, &eeprom);
   tssi_bounds[4] = rt2x00_get_field16(eeprom,
      EEPROM_TSSI_BOUND_BG3_REF);
   tssi_bounds[5] = rt2x00_get_field16(eeprom,
      EEPROM_TSSI_BOUND_BG3_PLUS1);
 
-  rt2x00_eeprom_read(rt2x00dev, EEPROM_TSSI_BOUND_BG4, &eeprom);
+  rt2800_eeprom_read(rt2x00dev, EEPROM_TSSI_BOUND_BG4, &eeprom);
   tssi_bounds[6] = rt2x00_get_field16(eeprom,
      EEPROM_TSSI_BOUND_BG4_PLUS2);
   tssi_bounds[7] = rt2x00_get_field16(eeprom,
      EEPROM_TSSI_BOUND_BG4_PLUS3);
 
-  rt2x00_eeprom_read(rt2x00dev, EEPROM_TSSI_BOUND_BG5, &eeprom);
+  rt2800_eeprom_read(rt2x00dev, EEPROM_TSSI_BOUND_BG5, &eeprom);
   tssi_bounds[8] = rt2x00_get_field16(eeprom,
      EEPROM_TSSI_BOUND_BG5_PLUS4);
 
   step = rt2x00_get_field16(eeprom,
        EEPROM_TSSI_BOUND_BG5_AGC_STEP);
  } else {
-  rt2x00_eeprom_read(rt2x00dev, EEPROM_TSSI_BOUND_A1, &eeprom);
+  rt2800_eeprom_read(rt2x00dev, EEPROM_TSSI_BOUND_A1, &eeprom);
   tssi_bounds[0] = rt2x00_get_field16(eeprom,
      EEPROM_TSSI_BOUND_A1_MINUS4);
   tssi_bounds[1] = rt2x00_get_field16(eeprom,
      EEPROM_TSSI_BOUND_A1_MINUS3);
 
-  rt2x00_eeprom_read(rt2x00dev, EEPROM_TSSI_BOUND_A2, &eeprom);
+  rt2800_eeprom_read(rt2x00dev, EEPROM_TSSI_BOUND_A2, &eeprom);
   tssi_bounds[2] = rt2x00_get_field16(eeprom,
      EEPROM_TSSI_BOUND_A2_MINUS2);
   tssi_bounds[3] = rt2x00_get_field16(eeprom,
      EEPROM_TSSI_BOUND_A2_MINUS1);
 
-  rt2x00_eeprom_read(rt2x00dev, EEPROM_TSSI_BOUND_A3, &eeprom);
+  rt2800_eeprom_read(rt2x00dev, EEPROM_TSSI_BOUND_A3, &eeprom);
   tssi_bounds[4] = rt2x00_get_field16(eeprom,
      EEPROM_TSSI_BOUND_A3_REF);
   tssi_bounds[5] = rt2x00_get_field16(eeprom,
      EEPROM_TSSI_BOUND_A3_PLUS1);
 
-  rt2x00_eeprom_read(rt2x00dev, EEPROM_TSSI_BOUND_A4, &eeprom);
+  rt2800_eeprom_read(rt2x00dev, EEPROM_TSSI_BOUND_A4, &eeprom);
   tssi_bounds[6] = rt2x00_get_field16(eeprom,
      EEPROM_TSSI_BOUND_A4_PLUS2);
   tssi_bounds[7] = rt2x00_get_field16(eeprom,
      EEPROM_TSSI_BOUND_A4_PLUS3);
 
-  rt2x00_eeprom_read(rt2x00dev, EEPROM_TSSI_BOUND_A5, &eeprom);
+  rt2800_eeprom_read(rt2x00dev, EEPROM_TSSI_BOUND_A5, &eeprom);
   tssi_bounds[8] = rt2x00_get_field16(eeprom,
      EEPROM_TSSI_BOUND_A5_PLUS4);
 
@@ -2883,7 +3529,7 @@ static int rt2800_get_txpower_bw_comp(struct rt2x00_dev *rt2x00dev,
  u8 comp_type;
  int comp_value = 0;
 
- rt2x00_eeprom_read(rt2x00dev, EEPROM_TXPOWER_DELTA, &eeprom);
+ rt2800_eeprom_read(rt2x00dev, EEPROM_TXPOWER_DELTA, &eeprom);
 
  /*
   * HT40 compensation not required.
@@ -2924,7 +3570,7 @@ static int rt2800_get_txpower_reg_delta(struct rt2x00_dev *rt2x00dev,
 {
  int delta;
 
- if (test_bit(CAPABILITY_POWER_LIMIT, &rt2x00dev->cap_flags))
+ if (rt2x00_has_cap_power_limit(rt2x00dev))
   return 0;
 
  /*
@@ -2950,7 +3596,10 @@ static u8 rt2800_compensate_txpower(struct rt2x00_dev *rt2x00dev, int is_rate_b,
  u8 eirp_txpower_criterion;
  u8 reg_limit;
 
- if (test_bit(CAPABILITY_POWER_LIMIT, &rt2x00dev->cap_flags)) {
+ if (rt2x00_rt(rt2x00dev, RT3593))
+  return min_t(u8, txpower, 0xc);
+
+ if (rt2x00_has_cap_power_limit(rt2x00dev)) {
   /*
    * Check if eirp txpower exceed txpower_limit.
    * We use OFDM 6M as criterion and its eirp txpower
@@ -2958,12 +3607,12 @@ static u8 rt2800_compensate_txpower(struct rt2x00_dev *rt2x00dev, int is_rate_b,
    * .11b data rate need add additional 4dbm
    * when calculating eirp txpower.
    */
-  rt2x00_eeprom_read(rt2x00dev, EEPROM_TXPOWER_BYRATE + 1,
-       &eeprom);
+  rt2800_eeprom_read_from_array(rt2x00dev, EEPROM_TXPOWER_BYRATE,
+           1, &eeprom);
   criterion = rt2x00_get_field16(eeprom,
             EEPROM_TXPOWER_BYRATE_RATE0);
 
-  rt2x00_eeprom_read(rt2x00dev, EEPROM_EIRP_MAX_TX_POWER,
+  rt2800_eeprom_read(rt2x00dev, EEPROM_EIRP_MAX_TX_POWER,
        &eeprom);
 
   if (band == IEEE80211_BAND_2GHZ)
@@ -2985,6 +3634,412 @@ static u8 rt2800_compensate_txpower(struct rt2x00_dev *rt2x00dev, int is_rate_b,
  return min_t(u8, txpower, 0xc);
 }
 
+
+enum {
+ TX_PWR_CFG_0_IDX,
+ TX_PWR_CFG_1_IDX,
+ TX_PWR_CFG_2_IDX,
+ TX_PWR_CFG_3_IDX,
+ TX_PWR_CFG_4_IDX,
+ TX_PWR_CFG_5_IDX,
+ TX_PWR_CFG_6_IDX,
+ TX_PWR_CFG_7_IDX,
+ TX_PWR_CFG_8_IDX,
+ TX_PWR_CFG_9_IDX,
+ TX_PWR_CFG_0_EXT_IDX,
+ TX_PWR_CFG_1_EXT_IDX,
+ TX_PWR_CFG_2_EXT_IDX,
+ TX_PWR_CFG_3_EXT_IDX,
+ TX_PWR_CFG_4_EXT_IDX,
+ TX_PWR_CFG_IDX_COUNT,
+};
+
+static void rt2800_config_txpower_rt3593(struct rt2x00_dev *rt2x00dev,
+      struct ieee80211_channel *chan,
+      int power_level)
+{
+ u8 txpower;
+ u16 eeprom;
+ u32 regs[TX_PWR_CFG_IDX_COUNT];
+ unsigned int offset;
+ enum ieee80211_band band = chan->band;
+ int delta;
+ int i;
+
+ memset(regs, '\0', sizeof(regs));
+
+ /* TODO: adapt TX power reduction from the rt28xx code */
+
+ /* calculate temperature compensation delta */
+ delta = rt2800_get_gain_calibration_delta(rt2x00dev);
+
+ if (band == IEEE80211_BAND_5GHZ)
+  offset = 16;
+ else
+  offset = 0;
+
+ if (test_bit(CONFIG_CHANNEL_HT40, &rt2x00dev->flags))
+  offset += 8;
+
+ /* read the next four txpower values */
+ rt2800_eeprom_read_from_array(rt2x00dev, EEPROM_TXPOWER_BYRATE,
+          offset, &eeprom);
+
+ /* CCK 1MBS,2MBS */
+ txpower = rt2x00_get_field16(eeprom, EEPROM_TXPOWER_BYRATE_RATE0);
+ txpower = rt2800_compensate_txpower(rt2x00dev, 1, band, power_level,
+         txpower, delta);
+ rt2x00_set_field32(&regs[TX_PWR_CFG_0_IDX],
+      TX_PWR_CFG_0_CCK1_CH0, txpower);
+ rt2x00_set_field32(&regs[TX_PWR_CFG_0_IDX],
+      TX_PWR_CFG_0_CCK1_CH1, txpower);
+ rt2x00_set_field32(&regs[TX_PWR_CFG_0_EXT_IDX],
+      TX_PWR_CFG_0_EXT_CCK1_CH2, txpower);
+
+ /* CCK 5.5MBS,11MBS */
+ txpower = rt2x00_get_field16(eeprom, EEPROM_TXPOWER_BYRATE_RATE1);
+ txpower = rt2800_compensate_txpower(rt2x00dev, 1, band, power_level,
+         txpower, delta);
+ rt2x00_set_field32(&regs[TX_PWR_CFG_0_IDX],
+      TX_PWR_CFG_0_CCK5_CH0, txpower);
+ rt2x00_set_field32(&regs[TX_PWR_CFG_0_IDX],
+      TX_PWR_CFG_0_CCK5_CH1, txpower);
+ rt2x00_set_field32(&regs[TX_PWR_CFG_0_EXT_IDX],
+      TX_PWR_CFG_0_EXT_CCK5_CH2, txpower);
+
+ /* OFDM 6MBS,9MBS */
+ txpower = rt2x00_get_field16(eeprom, EEPROM_TXPOWER_BYRATE_RATE2);
+ txpower = rt2800_compensate_txpower(rt2x00dev, 0, band, power_level,
+         txpower, delta);
+ rt2x00_set_field32(&regs[TX_PWR_CFG_0_IDX],
+      TX_PWR_CFG_0_OFDM6_CH0, txpower);
+ rt2x00_set_field32(&regs[TX_PWR_CFG_0_IDX],
+      TX_PWR_CFG_0_OFDM6_CH1, txpower);
+ rt2x00_set_field32(&regs[TX_PWR_CFG_0_EXT_IDX],
+      TX_PWR_CFG_0_EXT_OFDM6_CH2, txpower);
+
+ /* OFDM 12MBS,18MBS */
+ txpower = rt2x00_get_field16(eeprom, EEPROM_TXPOWER_BYRATE_RATE3);
+ txpower = rt2800_compensate_txpower(rt2x00dev, 0, band, power_level,
+         txpower, delta);
+ rt2x00_set_field32(&regs[TX_PWR_CFG_0_IDX],
+      TX_PWR_CFG_0_OFDM12_CH0, txpower);
+ rt2x00_set_field32(&regs[TX_PWR_CFG_0_IDX],
+      TX_PWR_CFG_0_OFDM12_CH1, txpower);
+ rt2x00_set_field32(&regs[TX_PWR_CFG_0_EXT_IDX],
+      TX_PWR_CFG_0_EXT_OFDM12_CH2, txpower);
+
+ /* read the next four txpower values */
+ rt2800_eeprom_read_from_array(rt2x00dev, EEPROM_TXPOWER_BYRATE,
+          offset + 1, &eeprom);
+
+ /* OFDM 24MBS,36MBS */
+ txpower = rt2x00_get_field16(eeprom, EEPROM_TXPOWER_BYRATE_RATE0);
+ txpower = rt2800_compensate_txpower(rt2x00dev, 0, band, power_level,
+         txpower, delta);
+ rt2x00_set_field32(&regs[TX_PWR_CFG_1_IDX],
+      TX_PWR_CFG_1_OFDM24_CH0, txpower);
+ rt2x00_set_field32(&regs[TX_PWR_CFG_1_IDX],
+      TX_PWR_CFG_1_OFDM24_CH1, txpower);
+ rt2x00_set_field32(&regs[TX_PWR_CFG_1_EXT_IDX],
+      TX_PWR_CFG_1_EXT_OFDM24_CH2, txpower);
+
+ /* OFDM 48MBS */
+ txpower = rt2x00_get_field16(eeprom, EEPROM_TXPOWER_BYRATE_RATE1);
+ txpower = rt2800_compensate_txpower(rt2x00dev, 0, band, power_level,
+         txpower, delta);
+ rt2x00_set_field32(&regs[TX_PWR_CFG_1_IDX],
+      TX_PWR_CFG_1_OFDM48_CH0, txpower);
+ rt2x00_set_field32(&regs[TX_PWR_CFG_1_IDX],
+      TX_PWR_CFG_1_OFDM48_CH1, txpower);
+ rt2x00_set_field32(&regs[TX_PWR_CFG_1_EXT_IDX],
+      TX_PWR_CFG_1_EXT_OFDM48_CH2, txpower);
+
+ /* OFDM 54MBS */
+ txpower = rt2x00_get_field16(eeprom, EEPROM_TXPOWER_BYRATE_RATE2);
+ txpower = rt2800_compensate_txpower(rt2x00dev, 0, band, power_level,
+         txpower, delta);
+ rt2x00_set_field32(&regs[TX_PWR_CFG_7_IDX],
+      TX_PWR_CFG_7_OFDM54_CH0, txpower);
+ rt2x00_set_field32(&regs[TX_PWR_CFG_7_IDX],
+      TX_PWR_CFG_7_OFDM54_CH1, txpower);
+ rt2x00_set_field32(&regs[TX_PWR_CFG_7_IDX],
+      TX_PWR_CFG_7_OFDM54_CH2, txpower);
+
+ /* read the next four txpower values */
+ rt2800_eeprom_read_from_array(rt2x00dev, EEPROM_TXPOWER_BYRATE,
+          offset + 2, &eeprom);
+
+ /* MCS 0,1 */
+ txpower = rt2x00_get_field16(eeprom, EEPROM_TXPOWER_BYRATE_RATE0);
+ txpower = rt2800_compensate_txpower(rt2x00dev, 0, band, power_level,
+         txpower, delta);
+ rt2x00_set_field32(&regs[TX_PWR_CFG_1_IDX],
+      TX_PWR_CFG_1_MCS0_CH0, txpower);
+ rt2x00_set_field32(&regs[TX_PWR_CFG_1_IDX],
+      TX_PWR_CFG_1_MCS0_CH1, txpower);
+ rt2x00_set_field32(&regs[TX_PWR_CFG_1_EXT_IDX],
+      TX_PWR_CFG_1_EXT_MCS0_CH2, txpower);
+
+ /* MCS 2,3 */
+ txpower = rt2x00_get_field16(eeprom, EEPROM_TXPOWER_BYRATE_RATE1);
+ txpower = rt2800_compensate_txpower(rt2x00dev, 0, band, power_level,
+         txpower, delta);
+ rt2x00_set_field32(&regs[TX_PWR_CFG_1_IDX],
+      TX_PWR_CFG_1_MCS2_CH0, txpower);
+ rt2x00_set_field32(&regs[TX_PWR_CFG_1_IDX],
+      TX_PWR_CFG_1_MCS2_CH1, txpower);
+ rt2x00_set_field32(&regs[TX_PWR_CFG_1_EXT_IDX],
+      TX_PWR_CFG_1_EXT_MCS2_CH2, txpower);
+
+ /* MCS 4,5 */
+ txpower = rt2x00_get_field16(eeprom, EEPROM_TXPOWER_BYRATE_RATE2);
+ txpower = rt2800_compensate_txpower(rt2x00dev, 0, band, power_level,
+         txpower, delta);
+ rt2x00_set_field32(&regs[TX_PWR_CFG_2_IDX],
+      TX_PWR_CFG_2_MCS4_CH0, txpower);
+ rt2x00_set_field32(&regs[TX_PWR_CFG_2_IDX],
+      TX_PWR_CFG_2_MCS4_CH1, txpower);
+ rt2x00_set_field32(&regs[TX_PWR_CFG_2_EXT_IDX],
+      TX_PWR_CFG_2_EXT_MCS4_CH2, txpower);
+
+ /* MCS 6 */
+ txpower = rt2x00_get_field16(eeprom, EEPROM_TXPOWER_BYRATE_RATE3);
+ txpower = rt2800_compensate_txpower(rt2x00dev, 0, band, power_level,
+         txpower, delta);
+ rt2x00_set_field32(&regs[TX_PWR_CFG_2_IDX],
+      TX_PWR_CFG_2_MCS6_CH0, txpower);
+ rt2x00_set_field32(&regs[TX_PWR_CFG_2_IDX],
+      TX_PWR_CFG_2_MCS6_CH1, txpower);
+ rt2x00_set_field32(&regs[TX_PWR_CFG_2_EXT_IDX],
+      TX_PWR_CFG_2_EXT_MCS6_CH2, txpower);
+
+ /* read the next four txpower values */
+ rt2800_eeprom_read_from_array(rt2x00dev, EEPROM_TXPOWER_BYRATE,
+          offset + 3, &eeprom);
+
+ /* MCS 7 */
+ txpower = rt2x00_get_field16(eeprom, EEPROM_TXPOWER_BYRATE_RATE0);
+ txpower = rt2800_compensate_txpower(rt2x00dev, 0, band, power_level,
+         txpower, delta);
+ rt2x00_set_field32(&regs[TX_PWR_CFG_7_IDX],
+      TX_PWR_CFG_7_MCS7_CH0, txpower);
+ rt2x00_set_field32(&regs[TX_PWR_CFG_7_IDX],
+      TX_PWR_CFG_7_MCS7_CH1, txpower);
+ rt2x00_set_field32(&regs[TX_PWR_CFG_7_IDX],
+      TX_PWR_CFG_7_MCS7_CH2, txpower);
+
+ /* MCS 8,9 */
+ txpower = rt2x00_get_field16(eeprom, EEPROM_TXPOWER_BYRATE_RATE1);
+ txpower = rt2800_compensate_txpower(rt2x00dev, 0, band, power_level,
+         txpower, delta);
+ rt2x00_set_field32(&regs[TX_PWR_CFG_2_IDX],
+      TX_PWR_CFG_2_MCS8_CH0, txpower);
+ rt2x00_set_field32(&regs[TX_PWR_CFG_2_IDX],
+      TX_PWR_CFG_2_MCS8_CH1, txpower);
+ rt2x00_set_field32(&regs[TX_PWR_CFG_2_EXT_IDX],
+      TX_PWR_CFG_2_EXT_MCS8_CH2, txpower);
+
+ /* MCS 10,11 */
+ txpower = rt2x00_get_field16(eeprom, EEPROM_TXPOWER_BYRATE_RATE2);
+ txpower = rt2800_compensate_txpower(rt2x00dev, 0, band, power_level,
+         txpower, delta);
+ rt2x00_set_field32(&regs[TX_PWR_CFG_2_IDX],
+      TX_PWR_CFG_2_MCS10_CH0, txpower);
+ rt2x00_set_field32(&regs[TX_PWR_CFG_2_IDX],
+      TX_PWR_CFG_2_MCS10_CH1, txpower);
+ rt2x00_set_field32(&regs[TX_PWR_CFG_2_EXT_IDX],
+      TX_PWR_CFG_2_EXT_MCS10_CH2, txpower);
+
+ /* MCS 12,13 */
+ txpower = rt2x00_get_field16(eeprom, EEPROM_TXPOWER_BYRATE_RATE3);
+ txpower = rt2800_compensate_txpower(rt2x00dev, 0, band, power_level,
+         txpower, delta);
+ rt2x00_set_field32(&regs[TX_PWR_CFG_3_IDX],
+      TX_PWR_CFG_3_MCS12_CH0, txpower);
+ rt2x00_set_field32(&regs[TX_PWR_CFG_3_IDX],
+      TX_PWR_CFG_3_MCS12_CH1, txpower);
+ rt2x00_set_field32(&regs[TX_PWR_CFG_3_EXT_IDX],
+      TX_PWR_CFG_3_EXT_MCS12_CH2, txpower);
+
+ /* read the next four txpower values */
+ rt2800_eeprom_read_from_array(rt2x00dev, EEPROM_TXPOWER_BYRATE,
+          offset + 4, &eeprom);
+
+ /* MCS 14 */
+ txpower = rt2x00_get_field16(eeprom, EEPROM_TXPOWER_BYRATE_RATE0);
+ txpower = rt2800_compensate_txpower(rt2x00dev, 0, band, power_level,
+         txpower, delta);
+ rt2x00_set_field32(&regs[TX_PWR_CFG_3_IDX],
+      TX_PWR_CFG_3_MCS14_CH0, txpower);
+ rt2x00_set_field32(&regs[TX_PWR_CFG_3_IDX],
+      TX_PWR_CFG_3_MCS14_CH1, txpower);
+ rt2x00_set_field32(&regs[TX_PWR_CFG_3_EXT_IDX],
+      TX_PWR_CFG_3_EXT_MCS14_CH2, txpower);
+
+ /* MCS 15 */
+ txpower = rt2x00_get_field16(eeprom, EEPROM_TXPOWER_BYRATE_RATE1);
+ txpower = rt2800_compensate_txpower(rt2x00dev, 0, band, power_level,
+         txpower, delta);
+ rt2x00_set_field32(&regs[TX_PWR_CFG_8_IDX],
+      TX_PWR_CFG_8_MCS15_CH0, txpower);
+ rt2x00_set_field32(&regs[TX_PWR_CFG_8_IDX],
+      TX_PWR_CFG_8_MCS15_CH1, txpower);
+ rt2x00_set_field32(&regs[TX_PWR_CFG_8_IDX],
+      TX_PWR_CFG_8_MCS15_CH2, txpower);
+
+ /* MCS 16,17 */
+ txpower = rt2x00_get_field16(eeprom, EEPROM_TXPOWER_BYRATE_RATE2);
+ txpower = rt2800_compensate_txpower(rt2x00dev, 0, band, power_level,
+         txpower, delta);
+ rt2x00_set_field32(&regs[TX_PWR_CFG_5_IDX],
+      TX_PWR_CFG_5_MCS16_CH0, txpower);
+ rt2x00_set_field32(&regs[TX_PWR_CFG_5_IDX],
+      TX_PWR_CFG_5_MCS16_CH1, txpower);
+ rt2x00_set_field32(&regs[TX_PWR_CFG_5_IDX],
+      TX_PWR_CFG_5_MCS16_CH2, txpower);
+
+ /* MCS 18,19 */
+ txpower = rt2x00_get_field16(eeprom, EEPROM_TXPOWER_BYRATE_RATE3);
+ txpower = rt2800_compensate_txpower(rt2x00dev, 0, band, power_level,
+         txpower, delta);
+ rt2x00_set_field32(&regs[TX_PWR_CFG_5_IDX],
+      TX_PWR_CFG_5_MCS18_CH0, txpower);
+ rt2x00_set_field32(&regs[TX_PWR_CFG_5_IDX],
+      TX_PWR_CFG_5_MCS18_CH1, txpower);
+ rt2x00_set_field32(&regs[TX_PWR_CFG_5_IDX],
+      TX_PWR_CFG_5_MCS18_CH2, txpower);
+
+ /* read the next four txpower values */
+ rt2800_eeprom_read_from_array(rt2x00dev, EEPROM_TXPOWER_BYRATE,
+          offset + 5, &eeprom);
+
+ /* MCS 20,21 */
+ txpower = rt2x00_get_field16(eeprom, EEPROM_TXPOWER_BYRATE_RATE0);
+ txpower = rt2800_compensate_txpower(rt2x00dev, 0, band, power_level,
+         txpower, delta);
+ rt2x00_set_field32(&regs[TX_PWR_CFG_6_IDX],
+      TX_PWR_CFG_6_MCS20_CH0, txpower);
+ rt2x00_set_field32(&regs[TX_PWR_CFG_6_IDX],
+      TX_PWR_CFG_6_MCS20_CH1, txpower);
+ rt2x00_set_field32(&regs[TX_PWR_CFG_6_IDX],
+      TX_PWR_CFG_6_MCS20_CH2, txpower);
+
+ /* MCS 22 */
+ txpower = rt2x00_get_field16(eeprom, EEPROM_TXPOWER_BYRATE_RATE1);
+ txpower = rt2800_compensate_txpower(rt2x00dev, 0, band, power_level,
+         txpower, delta);
+ rt2x00_set_field32(&regs[TX_PWR_CFG_6_IDX],
+      TX_PWR_CFG_6_MCS22_CH0, txpower);
+ rt2x00_set_field32(&regs[TX_PWR_CFG_6_IDX],
+      TX_PWR_CFG_6_MCS22_CH1, txpower);
+ rt2x00_set_field32(&regs[TX_PWR_CFG_6_IDX],
+      TX_PWR_CFG_6_MCS22_CH2, txpower);
+
+ /* MCS 23 */
+ txpower = rt2x00_get_field16(eeprom, EEPROM_TXPOWER_BYRATE_RATE2);
+ txpower = rt2800_compensate_txpower(rt2x00dev, 0, band, power_level,
+         txpower, delta);
+ rt2x00_set_field32(&regs[TX_PWR_CFG_8_IDX],
+      TX_PWR_CFG_8_MCS23_CH0, txpower);
+ rt2x00_set_field32(&regs[TX_PWR_CFG_8_IDX],
+      TX_PWR_CFG_8_MCS23_CH1, txpower);
+ rt2x00_set_field32(&regs[TX_PWR_CFG_8_IDX],
+      TX_PWR_CFG_8_MCS23_CH2, txpower);
+
+ /* read the next four txpower values */
+ rt2800_eeprom_read_from_array(rt2x00dev, EEPROM_TXPOWER_BYRATE,
+          offset + 6, &eeprom);
+
+ /* STBC, MCS 0,1 */
+ txpower = rt2x00_get_field16(eeprom, EEPROM_TXPOWER_BYRATE_RATE0);
+ txpower = rt2800_compensate_txpower(rt2x00dev, 0, band, power_level,
+         txpower, delta);
+ rt2x00_set_field32(&regs[TX_PWR_CFG_3_IDX],
+      TX_PWR_CFG_3_STBC0_CH0, txpower);
+ rt2x00_set_field32(&regs[TX_PWR_CFG_3_IDX],
+      TX_PWR_CFG_3_STBC0_CH1, txpower);
+ rt2x00_set_field32(&regs[TX_PWR_CFG_3_EXT_IDX],
+      TX_PWR_CFG_3_EXT_STBC0_CH2, txpower);
+
+ /* STBC, MCS 2,3 */
+ txpower = rt2x00_get_field16(eeprom, EEPROM_TXPOWER_BYRATE_RATE1);
+ txpower = rt2800_compensate_txpower(rt2x00dev, 0, band, power_level,
+         txpower, delta);
+ rt2x00_set_field32(&regs[TX_PWR_CFG_3_IDX],
+      TX_PWR_CFG_3_STBC2_CH0, txpower);
+ rt2x00_set_field32(&regs[TX_PWR_CFG_3_IDX],
+      TX_PWR_CFG_3_STBC2_CH1, txpower);
+ rt2x00_set_field32(&regs[TX_PWR_CFG_3_EXT_IDX],
+      TX_PWR_CFG_3_EXT_STBC2_CH2, txpower);
+
+ /* STBC, MCS 4,5 */
+ txpower = rt2x00_get_field16(eeprom, EEPROM_TXPOWER_BYRATE_RATE2);
+ txpower = rt2800_compensate_txpower(rt2x00dev, 0, band, power_level,
+         txpower, delta);
+ rt2x00_set_field32(&regs[TX_PWR_CFG_4_IDX], TX_PWR_CFG_RATE0, txpower);
+ rt2x00_set_field32(&regs[TX_PWR_CFG_4_IDX], TX_PWR_CFG_RATE1, txpower);
+ rt2x00_set_field32(&regs[TX_PWR_CFG_4_EXT_IDX], TX_PWR_CFG_RATE0,
+      txpower);
+
+ /* STBC, MCS 6 */
+ txpower = rt2x00_get_field16(eeprom, EEPROM_TXPOWER_BYRATE_RATE3);
+ txpower = rt2800_compensate_txpower(rt2x00dev, 0, band, power_level,
+         txpower, delta);
+ rt2x00_set_field32(&regs[TX_PWR_CFG_4_IDX], TX_PWR_CFG_RATE2, txpower);
+ rt2x00_set_field32(&regs[TX_PWR_CFG_4_IDX], TX_PWR_CFG_RATE3, txpower);
+ rt2x00_set_field32(&regs[TX_PWR_CFG_4_EXT_IDX], TX_PWR_CFG_RATE2,
+      txpower);
+
+ /* read the next four txpower values */
+ rt2800_eeprom_read_from_array(rt2x00dev, EEPROM_TXPOWER_BYRATE,
+          offset + 7, &eeprom);
+
+ /* STBC, MCS 7 */
+ txpower = rt2x00_get_field16(eeprom, EEPROM_TXPOWER_BYRATE_RATE0);
+ txpower = rt2800_compensate_txpower(rt2x00dev, 0, band, power_level,
+         txpower, delta);
+ rt2x00_set_field32(&regs[TX_PWR_CFG_9_IDX],
+      TX_PWR_CFG_9_STBC7_CH0, txpower);
+ rt2x00_set_field32(&regs[TX_PWR_CFG_9_IDX],
+      TX_PWR_CFG_9_STBC7_CH1, txpower);
+ rt2x00_set_field32(&regs[TX_PWR_CFG_9_IDX],
+      TX_PWR_CFG_9_STBC7_CH2, txpower);
+
+ rt2800_register_write(rt2x00dev, TX_PWR_CFG_0, regs[TX_PWR_CFG_0_IDX]);
+ rt2800_register_write(rt2x00dev, TX_PWR_CFG_1, regs[TX_PWR_CFG_1_IDX]);
+ rt2800_register_write(rt2x00dev, TX_PWR_CFG_2, regs[TX_PWR_CFG_2_IDX]);
+ rt2800_register_write(rt2x00dev, TX_PWR_CFG_3, regs[TX_PWR_CFG_3_IDX]);
+ rt2800_register_write(rt2x00dev, TX_PWR_CFG_4, regs[TX_PWR_CFG_4_IDX]);
+ rt2800_register_write(rt2x00dev, TX_PWR_CFG_5, regs[TX_PWR_CFG_5_IDX]);
+ rt2800_register_write(rt2x00dev, TX_PWR_CFG_6, regs[TX_PWR_CFG_6_IDX]);
+ rt2800_register_write(rt2x00dev, TX_PWR_CFG_7, regs[TX_PWR_CFG_7_IDX]);
+ rt2800_register_write(rt2x00dev, TX_PWR_CFG_8, regs[TX_PWR_CFG_8_IDX]);
+ rt2800_register_write(rt2x00dev, TX_PWR_CFG_9, regs[TX_PWR_CFG_9_IDX]);
+
+ rt2800_register_write(rt2x00dev, TX_PWR_CFG_0_EXT,
+         regs[TX_PWR_CFG_0_EXT_IDX]);
+ rt2800_register_write(rt2x00dev, TX_PWR_CFG_1_EXT,
+         regs[TX_PWR_CFG_1_EXT_IDX]);
+ rt2800_register_write(rt2x00dev, TX_PWR_CFG_2_EXT,
+         regs[TX_PWR_CFG_2_EXT_IDX]);
+ rt2800_register_write(rt2x00dev, TX_PWR_CFG_3_EXT,
+         regs[TX_PWR_CFG_3_EXT_IDX]);
+ rt2800_register_write(rt2x00dev, TX_PWR_CFG_4_EXT,
+         regs[TX_PWR_CFG_4_EXT_IDX]);
+
+ for (i = 0; i < TX_PWR_CFG_IDX_COUNT; i++)
+  rt2x00_dbg(rt2x00dev,
+      "band:%cGHz, BW:%c0MHz, TX_PWR_CFG_%d%s = %08lx\n",
+      (band == IEEE80211_BAND_5GHZ) ? '5' : '2',
+      (test_bit(CONFIG_CHANNEL_HT40, &rt2x00dev->flags)) ?
+        '4' : '2',
+      (i > TX_PWR_CFG_9_IDX) ?
+     (i - TX_PWR_CFG_9_IDX - 1) : i,
+      (i > TX_PWR_CFG_9_IDX) ? "_EXT" : "",
+      (unsigned long) regs[i]);
+}
+
 /*
  * We configure transmit power using MAC TX_PWR_CFG_{0,...,N} registers and
  * BBP R1 register. TX_PWR_CFG_X allow to configure per rate TX power values,
@@ -2994,9 +4049,9 @@ static u8 rt2800_compensate_txpower(struct rt2x00_dev *rt2x00dev, int is_rate_b,
  * EEPROM_TXPOWER_BYRATE offset. We adjust them and BBP R1 settings according to
  * current conditions (i.e. band, bandwidth, temperature, user settings).
  */
-static void rt2800_config_txpower(struct rt2x00_dev *rt2x00dev,
-      struct ieee80211_channel *chan,
-      int power_level)
+static void rt2800_config_txpower_rt28xx(struct rt2x00_dev *rt2x00dev,
+      struct ieee80211_channel *chan,
+      int power_level)
 {
  u8 txpower, r1;
  u16 eeprom;
@@ -3064,8 +4119,8 @@ static void rt2800_config_txpower(struct rt2x00_dev *rt2x00dev,
   rt2800_register_read(rt2x00dev, offset, &reg);
 
   /* read the next four txpower values */
-  rt2x00_eeprom_read(rt2x00dev, EEPROM_TXPOWER_BYRATE + i,
-       &eeprom);
+  rt2800_eeprom_read_from_array(rt2x00dev, EEPROM_TXPOWER_BYRATE,
+           i, &eeprom);
 
   is_rate_b = i ? 0 : 1;
   /*
@@ -3113,8 +4168,8 @@ static void rt2800_config_txpower(struct rt2x00_dev *rt2x00dev,
   rt2x00_set_field32(&reg, TX_PWR_CFG_RATE3, txpower);
 
   /* read the next four txpower values */
-  rt2x00_eeprom_read(rt2x00dev, EEPROM_TXPOWER_BYRATE + i + 1,
-       &eeprom);
+  rt2800_eeprom_read_from_array(rt2x00dev, EEPROM_TXPOWER_BYRATE,
+           i + 1, &eeprom);
 
   is_rate_b = 0;
   /*
@@ -3168,6 +4223,16 @@ static void rt2800_config_txpower(struct rt2x00_dev *rt2x00dev,
  }
 }
 
+static void rt2800_config_txpower(struct rt2x00_dev *rt2x00dev,
+      struct ieee80211_channel *chan,
+      int power_level)
+{
+ if (rt2x00_rt(rt2x00dev, RT3593))
+  rt2800_config_txpower_rt3593(rt2x00dev, chan, power_level);
+ else
+  rt2800_config_txpower_rt28xx(rt2x00dev, chan, power_level);
+}
+
 void rt2800_gain_calibration(struct rt2x00_dev *rt2x00dev)
 {
  rt2800_config_txpower(rt2x00dev, rt2x00dev->hw->conf.chandef.chan,
@@ -3203,6 +4268,8 @@ void rt2800_vco_calibration(struct rt2x00_dev *rt2x00dev)
   rt2x00_set_field8(&rfcsr, RFCSR7_RF_TUNING, 1);
   rt2800_rfcsr_write(rt2x00dev, 7, rfcsr);
   break;
+ case RF3053:
+ case RF3070:
  case RF3290:
  case RF5360:
  case RF5370:
@@ -3344,6 +4411,7 @@ static u8 rt2800_get_default_vgc(struct rt2x00_dev *rt2x00dev)
       rt2x00_rt(rt2x00dev, RT3290) ||
       rt2x00_rt(rt2x00dev, RT3390) ||
       rt2x00_rt(rt2x00dev, RT3572) ||
+      rt2x00_rt(rt2x00dev, RT3593) ||
       rt2x00_rt(rt2x00dev, RT5390) ||
       rt2x00_rt(rt2x00dev, RT5392) ||
       rt2x00_rt(rt2x00dev, RT5592))
@@ -3351,8 +4419,8 @@ static u8 rt2800_get_default_vgc(struct rt2x00_dev *rt2x00dev)
   else
    vgc = 0x2e + rt2x00dev->lna_gain;
  } else { /* 5GHZ band */
-  if (rt2x00_rt(rt2x00dev, RT3572))
-   vgc = 0x22 + (rt2x00dev->lna_gain * 5) / 3;
+  if (rt2x00_rt(rt2x00dev, RT3593))
+   vgc = 0x20 + (rt2x00dev->lna_gain * 5) / 3;
   else if (rt2x00_rt(rt2x00dev, RT5592))
    vgc = 0x24 + (2 * rt2x00dev->lna_gain);
   else {
@@ -3370,11 +4438,17 @@ static inline void rt2800_set_vgc(struct rt2x00_dev *rt2x00dev,
       struct link_qual *qual, u8 vgc_level)
 {
  if (qual->vgc_level != vgc_level) {
-  if (rt2x00_rt(rt2x00dev, RT5592)) {
+  if (rt2x00_rt(rt2x00dev, RT3572) ||
+      rt2x00_rt(rt2x00dev, RT3593)) {
+   rt2800_bbp_write_with_rx_chain(rt2x00dev, 66,
+             vgc_level);
+  } else if (rt2x00_rt(rt2x00dev, RT5592)) {
    rt2800_bbp_write(rt2x00dev, 83, qual->rssi > -65 ? 0x4a : 0x7a);
    rt2800_bbp_write_with_rx_chain(rt2x00dev, 66, vgc_level);
-  } else
+  } else {
    rt2800_bbp_write(rt2x00dev, 66, vgc_level);
+  }
+
   qual->vgc_level = vgc_level;
   qual->vgc_level_reg = vgc_level;
  }
@@ -3393,17 +4467,35 @@ void rt2800_link_tuner(struct rt2x00_dev *rt2x00dev, struct link_qual *qual,
 
  if (rt2x00_rt_rev(rt2x00dev, RT2860, REV_RT2860C))
   return;
- /*
-  * When RSSI is better then -80 increase VGC level with 0x10, except
-  * for rt5592 chip.
+
+ /* When RSSI is better than a certain threshold, increase VGC
+  * with a chip specific value in order to improve the balance
+  * between sensibility and noise isolation.
   */
 
  vgc = rt2800_get_default_vgc(rt2x00dev);
 
- if (rt2x00_rt(rt2x00dev, RT5592) && qual->rssi > -65)
-  vgc += 0x20;
- else if (qual->rssi > -80)
-  vgc += 0x10;
+ switch (rt2x00dev->chip.rt) {
+ case RT3572:
+ case RT3593:
+  if (qual->rssi > -65) {
+   if (rt2x00dev->curr_band == IEEE80211_BAND_2GHZ)
+    vgc += 0x20;
+   else
+    vgc += 0x10;
+  }
+  break;
+
+ case RT5592:
+  if (qual->rssi > -65)
+   vgc += 0x20;
+  break;
+
+ default:
+  if (qual->rssi > -80)
+   vgc += 0x10;
+  break;
+ }
 
  rt2800_set_vgc(rt2x00dev, qual, vgc);
 }
@@ -3426,17 +4518,25 @@ static int rt2800_init_registers(struct rt2x00_dev *rt2x00dev)
   return ret;
 
  rt2800_register_read(rt2x00dev, BCN_OFFSET0, &reg);
- rt2x00_set_field32(&reg, BCN_OFFSET0_BCN0, 0xe0); /* 0x3800 */
- rt2x00_set_field32(&reg, BCN_OFFSET0_BCN1, 0xe8); /* 0x3a00 */
- rt2x00_set_field32(&reg, BCN_OFFSET0_BCN2, 0xf0); /* 0x3c00 */
- rt2x00_set_field32(&reg, BCN_OFFSET0_BCN3, 0xf8); /* 0x3e00 */
+ rt2x00_set_field32(&reg, BCN_OFFSET0_BCN0,
+      rt2800_get_beacon_offset(rt2x00dev, 0));
+ rt2x00_set_field32(&reg, BCN_OFFSET0_BCN1,
+      rt2800_get_beacon_offset(rt2x00dev, 1));
+ rt2x00_set_field32(&reg, BCN_OFFSET0_BCN2,
+      rt2800_get_beacon_offset(rt2x00dev, 2));
+ rt2x00_set_field32(&reg, BCN_OFFSET0_BCN3,
+      rt2800_get_beacon_offset(rt2x00dev, 3));
  rt2800_register_write(rt2x00dev, BCN_OFFSET0, reg);
 
  rt2800_register_read(rt2x00dev, BCN_OFFSET1, &reg);
- rt2x00_set_field32(&reg, BCN_OFFSET1_BCN4, 0xc8); /* 0x3200 */
- rt2x00_set_field32(&reg, BCN_OFFSET1_BCN5, 0xd0); /* 0x3400 */
- rt2x00_set_field32(&reg, BCN_OFFSET1_BCN6, 0x77); /* 0x1dc0 */
- rt2x00_set_field32(&reg, BCN_OFFSET1_BCN7, 0x6f); /* 0x1bc0 */
+ rt2x00_set_field32(&reg, BCN_OFFSET1_BCN4,
+      rt2800_get_beacon_offset(rt2x00dev, 4));
+ rt2x00_set_field32(&reg, BCN_OFFSET1_BCN5,
+      rt2800_get_beacon_offset(rt2x00dev, 5));
+ rt2x00_set_field32(&reg, BCN_OFFSET1_BCN6,
+      rt2800_get_beacon_offset(rt2x00dev, 6));
+ rt2x00_set_field32(&reg, BCN_OFFSET1_BCN7,
+      rt2800_get_beacon_offset(rt2x00dev, 7));
  rt2800_register_write(rt2x00dev, BCN_OFFSET1, reg);
 
  rt2800_register_write(rt2x00dev, LEGACY_BASIC_RATE, 0x0000013f);
@@ -3512,7 +4612,8 @@ static int rt2800_init_registers(struct rt2x00_dev *rt2x00dev)
   if (rt2x00_rt_rev_lt(rt2x00dev, RT3071, REV_RT3071E) ||
       rt2x00_rt_rev_lt(rt2x00dev, RT3090, REV_RT3090E) ||
       rt2x00_rt_rev_lt(rt2x00dev, RT3390, REV_RT3390E)) {
-   rt2x00_eeprom_read(rt2x00dev, EEPROM_NIC_CONF1, &eeprom);
+   rt2800_eeprom_read(rt2x00dev, EEPROM_NIC_CONF1,
+        &eeprom);
    if (rt2x00_get_field16(eeprom, EEPROM_NIC_CONF1_DAC_TEST))
     rt2800_register_write(rt2x00dev, TX_SW_CFG2,
             0x0000002c);
@@ -3543,6 +4644,23 @@ static int rt2800_init_registers(struct rt2x00_dev *rt2x00dev)
  } else if (rt2x00_rt(rt2x00dev, RT3572)) {
   rt2800_register_write(rt2x00dev, TX_SW_CFG0, 0x00000400);
   rt2800_register_write(rt2x00dev, TX_SW_CFG1, 0x00080606);
+ } else if (rt2x00_rt(rt2x00dev, RT3593)) {
+  rt2800_register_write(rt2x00dev, TX_SW_CFG0, 0x00000402);
+  rt2800_register_write(rt2x00dev, TX_SW_CFG1, 0x00000000);
+  if (rt2x00_rt_rev_lt(rt2x00dev, RT3593, REV_RT3593E)) {
+   rt2800_eeprom_read(rt2x00dev, EEPROM_NIC_CONF1,
+        &eeprom);
+   if (rt2x00_get_field16(eeprom,
+            EEPROM_NIC_CONF1_DAC_TEST))
+    rt2800_register_write(rt2x00dev, TX_SW_CFG2,
+            0x0000001f);
+   else
+    rt2800_register_write(rt2x00dev, TX_SW_CFG2,
+            0x0000000f);
+  } else {
+   rt2800_register_write(rt2x00dev, TX_SW_CFG2,
+           0x00000000);
+  }
  } else if (rt2x00_rt(rt2x00dev, RT5390) ||
      rt2x00_rt(rt2x00dev, RT5392) ||
      rt2x00_rt(rt2x00dev, RT5592)) {
@@ -3770,14 +4888,8 @@ static int rt2800_init_registers(struct rt2x00_dev *rt2x00dev)
  /*
   * Clear all beacons
   */
- rt2800_clear_beacon_register(rt2x00dev, HW_BEACON_BASE0);
- rt2800_clear_beacon_register(rt2x00dev, HW_BEACON_BASE1);
- rt2800_clear_beacon_register(rt2x00dev, HW_BEACON_BASE2);
- rt2800_clear_beacon_register(rt2x00dev, HW_BEACON_BASE3);
- rt2800_clear_beacon_register(rt2x00dev, HW_BEACON_BASE4);
- rt2800_clear_beacon_register(rt2x00dev, HW_BEACON_BASE5);
- rt2800_clear_beacon_register(rt2x00dev, HW_BEACON_BASE6);
- rt2800_clear_beacon_register(rt2x00dev, HW_BEACON_BASE7);
+ for (i = 0; i < 8; i++)
+  rt2800_clear_beacon_register(rt2x00dev, i);
 
  if (rt2x00_is_usb(rt2x00dev)) {
   rt2800_register_read(rt2x00dev, US_CYC_CNT, &reg);
@@ -3967,379 +5079,601 @@ static void rt2800_init_bbp_early(struct rt2x00_dev *rt2x00dev)
  rt2800_bbp_write(rt2x00dev, 106, 0x35);
 }
 
-static void rt2800_init_bbp_5592(struct rt2x00_dev *rt2x00dev)
+static void rt2800_disable_unused_dac_adc(struct rt2x00_dev *rt2x00dev)
 {
- int ant, div_mode;
  u16 eeprom;
  u8 value;
 
- rt2800_init_bbp_early(rt2x00dev);
+ rt2800_bbp_read(rt2x00dev, 138, &value);
+ rt2800_eeprom_read(rt2x00dev, EEPROM_NIC_CONF0, &eeprom);
+ if (rt2x00_get_field16(eeprom, EEPROM_NIC_CONF0_TXPATH) == 1)
+  value |= 0x20;
+ if (rt2x00_get_field16(eeprom, EEPROM_NIC_CONF0_RXPATH) == 1)
+  value &= ~0x02;
+ rt2800_bbp_write(rt2x00dev, 138, value);
+}
 
- rt2800_bbp_read(rt2x00dev, 105, &value);
- rt2x00_set_field8(&value, BBP105_MLD,
-     rt2x00dev->default_ant.rx_chain_num == 2);
- rt2800_bbp_write(rt2x00dev, 105, value);
+static void rt2800_init_bbp_305x_soc(struct rt2x00_dev *rt2x00dev)
+{
+ rt2800_bbp_write(rt2x00dev, 31, 0x08);
+
+ rt2800_bbp_write(rt2x00dev, 65, 0x2c);
+ rt2800_bbp_write(rt2x00dev, 66, 0x38);
+
+ rt2800_bbp_write(rt2x00dev, 69, 0x12);
+ rt2800_bbp_write(rt2x00dev, 73, 0x10);
+
+ rt2800_bbp_write(rt2x00dev, 70, 0x0a);
+
+ rt2800_bbp_write(rt2x00dev, 78, 0x0e);
+ rt2800_bbp_write(rt2x00dev, 80, 0x08);
+
+ rt2800_bbp_write(rt2x00dev, 82, 0x62);
+
+ rt2800_bbp_write(rt2x00dev, 83, 0x6a);
+
+ rt2800_bbp_write(rt2x00dev, 84, 0x99);
+
+ rt2800_bbp_write(rt2x00dev, 86, 0x00);
+
+ rt2800_bbp_write(rt2x00dev, 91, 0x04);
+
+ rt2800_bbp_write(rt2x00dev, 92, 0x00);
+
+ rt2800_bbp_write(rt2x00dev, 103, 0xc0);
+
+ rt2800_bbp_write(rt2x00dev, 105, 0x01);
+
+ rt2800_bbp_write(rt2x00dev, 106, 0x35);
+}
+
+static void rt2800_init_bbp_28xx(struct rt2x00_dev *rt2x00dev)
+{
+ rt2800_bbp_write(rt2x00dev, 65, 0x2c);
+ rt2800_bbp_write(rt2x00dev, 66, 0x38);
+
+ if (rt2x00_rt_rev(rt2x00dev, RT2860, REV_RT2860C)) {
+  rt2800_bbp_write(rt2x00dev, 69, 0x16);
+  rt2800_bbp_write(rt2x00dev, 73, 0x12);
+ } else {
+  rt2800_bbp_write(rt2x00dev, 69, 0x12);
+  rt2800_bbp_write(rt2x00dev, 73, 0x10);
+ }
+
+ rt2800_bbp_write(rt2x00dev, 70, 0x0a);
+
+ rt2800_bbp_write(rt2x00dev, 81, 0x37);
+
+ rt2800_bbp_write(rt2x00dev, 82, 0x62);
+
+ rt2800_bbp_write(rt2x00dev, 83, 0x6a);
+
+ if (rt2x00_rt_rev(rt2x00dev, RT2860, REV_RT2860D))
+  rt2800_bbp_write(rt2x00dev, 84, 0x19);
+ else
+  rt2800_bbp_write(rt2x00dev, 84, 0x99);
+
+ rt2800_bbp_write(rt2x00dev, 86, 0x00);
+
+ rt2800_bbp_write(rt2x00dev, 91, 0x04);
+
+ rt2800_bbp_write(rt2x00dev, 92, 0x00);
+
+ rt2800_bbp_write(rt2x00dev, 103, 0x00);
+
+ rt2800_bbp_write(rt2x00dev, 105, 0x05);
+
+ rt2800_bbp_write(rt2x00dev, 106, 0x35);
+}
+
+static void rt2800_init_bbp_30xx(struct rt2x00_dev *rt2x00dev)
+{
+ rt2800_bbp_write(rt2x00dev, 65, 0x2c);
+ rt2800_bbp_write(rt2x00dev, 66, 0x38);
+
+ rt2800_bbp_write(rt2x00dev, 69, 0x12);
+ rt2800_bbp_write(rt2x00dev, 73, 0x10);
+
+ rt2800_bbp_write(rt2x00dev, 70, 0x0a);
+
+ rt2800_bbp_write(rt2x00dev, 79, 0x13);
+ rt2800_bbp_write(rt2x00dev, 80, 0x05);
+ rt2800_bbp_write(rt2x00dev, 81, 0x33);
+
+ rt2800_bbp_write(rt2x00dev, 82, 0x62);
+
+ rt2800_bbp_write(rt2x00dev, 83, 0x6a);
+
+ rt2800_bbp_write(rt2x00dev, 84, 0x99);
+
+ rt2800_bbp_write(rt2x00dev, 86, 0x00);
+
+ rt2800_bbp_write(rt2x00dev, 91, 0x04);
+
+ rt2800_bbp_write(rt2x00dev, 92, 0x00);
+
+ if (rt2x00_rt_rev_gte(rt2x00dev, RT3070, REV_RT3070F) ||
+     rt2x00_rt_rev_gte(rt2x00dev, RT3071, REV_RT3071E) ||
+     rt2x00_rt_rev_gte(rt2x00dev, RT3090, REV_RT3090E))
+  rt2800_bbp_write(rt2x00dev, 103, 0xc0);
+ else
+  rt2800_bbp_write(rt2x00dev, 103, 0x00);
+
+ rt2800_bbp_write(rt2x00dev, 105, 0x05);
+
+ rt2800_bbp_write(rt2x00dev, 106, 0x35);
+
+ if (rt2x00_rt(rt2x00dev, RT3071) ||
+     rt2x00_rt(rt2x00dev, RT3090))
+  rt2800_disable_unused_dac_adc(rt2x00dev);
+}
+
+static void rt2800_init_bbp_3290(struct rt2x00_dev *rt2x00dev)
+{
+ u8 value;
 
  rt2800_bbp4_mac_if_ctrl(rt2x00dev);
 
- rt2800_bbp_write(rt2x00dev, 20, 0x06);
  rt2800_bbp_write(rt2x00dev, 31, 0x08);
- rt2800_bbp_write(rt2x00dev, 65, 0x2C);
- rt2800_bbp_write(rt2x00dev, 68, 0xDD);
- rt2800_bbp_write(rt2x00dev, 69, 0x1A);
- rt2800_bbp_write(rt2x00dev, 70, 0x05);
+
+ rt2800_bbp_write(rt2x00dev, 65, 0x2c);
+ rt2800_bbp_write(rt2x00dev, 66, 0x38);
+
+ rt2800_bbp_write(rt2x00dev, 68, 0x0b);
+
+ rt2800_bbp_write(rt2x00dev, 69, 0x12);
  rt2800_bbp_write(rt2x00dev, 73, 0x13);
- rt2800_bbp_write(rt2x00dev, 74, 0x0F);
- rt2800_bbp_write(rt2x00dev, 75, 0x4F);
+ rt2800_bbp_write(rt2x00dev, 75, 0x46);
  rt2800_bbp_write(rt2x00dev, 76, 0x28);
+
+ rt2800_bbp_write(rt2x00dev, 77, 0x58);
+
+ rt2800_bbp_write(rt2x00dev, 70, 0x0a);
+
+ rt2800_bbp_write(rt2x00dev, 74, 0x0b);
+ rt2800_bbp_write(rt2x00dev, 79, 0x18);
+ rt2800_bbp_write(rt2x00dev, 80, 0x09);
+ rt2800_bbp_write(rt2x00dev, 81, 0x33);
+
+ rt2800_bbp_write(rt2x00dev, 82, 0x62);
+
+ rt2800_bbp_write(rt2x00dev, 83, 0x7a);
+
+ rt2800_bbp_write(rt2x00dev, 84, 0x9a);
+
+ rt2800_bbp_write(rt2x00dev, 86, 0x38);
+
+ rt2800_bbp_write(rt2x00dev, 91, 0x04);
+
+ rt2800_bbp_write(rt2x00dev, 92, 0x02);
+
+ rt2800_bbp_write(rt2x00dev, 103, 0xc0);
+
+ rt2800_bbp_write(rt2x00dev, 104, 0x92);
+
+ rt2800_bbp_write(rt2x00dev, 105, 0x1c);
+
+ rt2800_bbp_write(rt2x00dev, 106, 0x03);
+
+ rt2800_bbp_write(rt2x00dev, 128, 0x12);
+
+ rt2800_bbp_write(rt2x00dev, 67, 0x24);
+ rt2800_bbp_write(rt2x00dev, 143, 0x04);
+ rt2800_bbp_write(rt2x00dev, 142, 0x99);
+ rt2800_bbp_write(rt2x00dev, 150, 0x30);
+ rt2800_bbp_write(rt2x00dev, 151, 0x2e);
+ rt2800_bbp_write(rt2x00dev, 152, 0x20);
+ rt2800_bbp_write(rt2x00dev, 153, 0x34);
+ rt2800_bbp_write(rt2x00dev, 154, 0x40);
+ rt2800_bbp_write(rt2x00dev, 155, 0x3b);
+ rt2800_bbp_write(rt2x00dev, 253, 0x04);
+
+ rt2800_bbp_read(rt2x00dev, 47, &value);
+ rt2x00_set_field8(&value, BBP47_TSSI_ADC6, 1);
+ rt2800_bbp_write(rt2x00dev, 47, value);
+
+ /* Use 5-bit ADC for Acquisition and 8-bit ADC for data */
+ rt2800_bbp_read(rt2x00dev, 3, &value);
+ rt2x00_set_field8(&value, BBP3_ADC_MODE_SWITCH, 1);
+ rt2x00_set_field8(&value, BBP3_ADC_INIT_MODE, 1);
+ rt2800_bbp_write(rt2x00dev, 3, value);
+}
+
+static void rt2800_init_bbp_3352(struct rt2x00_dev *rt2x00dev)
+{
+ rt2800_bbp_write(rt2x00dev, 3, 0x00);
+ rt2800_bbp_write(rt2x00dev, 4, 0x50);
+
+ rt2800_bbp_write(rt2x00dev, 31, 0x08);
+
+ rt2800_bbp_write(rt2x00dev, 47, 0x48);
+
+ rt2800_bbp_write(rt2x00dev, 65, 0x2c);
+ rt2800_bbp_write(rt2x00dev, 66, 0x38);
+
+ rt2800_bbp_write(rt2x00dev, 68, 0x0b);
+
+ rt2800_bbp_write(rt2x00dev, 69, 0x12);
+ rt2800_bbp_write(rt2x00dev, 73, 0x13);
+ rt2800_bbp_write(rt2x00dev, 75, 0x46);
+ rt2800_bbp_write(rt2x00dev, 76, 0x28);
+
  rt2800_bbp_write(rt2x00dev, 77, 0x59);
- rt2800_bbp_write(rt2x00dev, 84, 0x9A);
+
+ rt2800_bbp_write(rt2x00dev, 70, 0x0a);
+
+ rt2800_bbp_write(rt2x00dev, 78, 0x0e);
+ rt2800_bbp_write(rt2x00dev, 80, 0x08);
+ rt2800_bbp_write(rt2x00dev, 81, 0x37);
+
+ rt2800_bbp_write(rt2x00dev, 82, 0x62);
+
+ rt2800_bbp_write(rt2x00dev, 83, 0x6a);
+
+ rt2800_bbp_write(rt2x00dev, 84, 0x99);
+
  rt2800_bbp_write(rt2x00dev, 86, 0x38);
+
  rt2800_bbp_write(rt2x00dev, 88, 0x90);
+
  rt2800_bbp_write(rt2x00dev, 91, 0x04);
+
  rt2800_bbp_write(rt2x00dev, 92, 0x02);
- rt2800_bbp_write(rt2x00dev, 95, 0x9a);
- rt2800_bbp_write(rt2x00dev, 98, 0x12);
- rt2800_bbp_write(rt2x00dev, 103, 0xC0);
+
+ rt2800_bbp_write(rt2x00dev, 103, 0xc0);
+
  rt2800_bbp_write(rt2x00dev, 104, 0x92);
- /* FIXME BBP105 owerwrite */
- rt2800_bbp_write(rt2x00dev, 105, 0x3C);
+
+ rt2800_bbp_write(rt2x00dev, 105, 0x34);
+
+ rt2800_bbp_write(rt2x00dev, 106, 0x05);
+
+ rt2800_bbp_write(rt2x00dev, 120, 0x50);
+
+ rt2800_bbp_write(rt2x00dev, 137, 0x0f);
+
+ rt2800_bbp_write(rt2x00dev, 163, 0xbd);
+ /* Set ITxBF timeout to 0x9c40=1000msec */
+ rt2800_bbp_write(rt2x00dev, 179, 0x02);
+ rt2800_bbp_write(rt2x00dev, 180, 0x00);
+ rt2800_bbp_write(rt2x00dev, 182, 0x40);
+ rt2800_bbp_write(rt2x00dev, 180, 0x01);
+ rt2800_bbp_write(rt2x00dev, 182, 0x9c);
+ rt2800_bbp_write(rt2x00dev, 179, 0x00);
+ /* Reprogram the inband interface to put right values in RXWI */
+ rt2800_bbp_write(rt2x00dev, 142, 0x04);
+ rt2800_bbp_write(rt2x00dev, 143, 0x3b);
+ rt2800_bbp_write(rt2x00dev, 142, 0x06);
+ rt2800_bbp_write(rt2x00dev, 143, 0xa0);
+ rt2800_bbp_write(rt2x00dev, 142, 0x07);
+ rt2800_bbp_write(rt2x00dev, 143, 0xa1);
+ rt2800_bbp_write(rt2x00dev, 142, 0x08);
+ rt2800_bbp_write(rt2x00dev, 143, 0xa2);
+
+ rt2800_bbp_write(rt2x00dev, 148, 0xc8);
+}
+
+static void rt2800_init_bbp_3390(struct rt2x00_dev *rt2x00dev)
+{
+ rt2800_bbp_write(rt2x00dev, 65, 0x2c);
+ rt2800_bbp_write(rt2x00dev, 66, 0x38);
+
+ rt2800_bbp_write(rt2x00dev, 69, 0x12);
+ rt2800_bbp_write(rt2x00dev, 73, 0x10);
+
+ rt2800_bbp_write(rt2x00dev, 70, 0x0a);
+
+ rt2800_bbp_write(rt2x00dev, 79, 0x13);
+ rt2800_bbp_write(rt2x00dev, 80, 0x05);
+ rt2800_bbp_write(rt2x00dev, 81, 0x33);
+
+ rt2800_bbp_write(rt2x00dev, 82, 0x62);
+
+ rt2800_bbp_write(rt2x00dev, 83, 0x6a);
+
+ rt2800_bbp_write(rt2x00dev, 84, 0x99);
+
+ rt2800_bbp_write(rt2x00dev, 86, 0x00);
+
+ rt2800_bbp_write(rt2x00dev, 91, 0x04);
+
+ rt2800_bbp_write(rt2x00dev, 92, 0x00);
+
+ if (rt2x00_rt_rev_gte(rt2x00dev, RT3390, REV_RT3390E))
+  rt2800_bbp_write(rt2x00dev, 103, 0xc0);
+ else
+  rt2800_bbp_write(rt2x00dev, 103, 0x00);
+
+ rt2800_bbp_write(rt2x00dev, 105, 0x05);
+
  rt2800_bbp_write(rt2x00dev, 106, 0x35);
- rt2800_bbp_write(rt2x00dev, 128, 0x12);
- rt2800_bbp_write(rt2x00dev, 134, 0xD0);
- rt2800_bbp_write(rt2x00dev, 135, 0xF6);
- rt2800_bbp_write(rt2x00dev, 137, 0x0F);
 
- /* Initialize GLRT (Generalized Likehood Radio Test) */
- rt2800_init_bbp_5592_glrt(rt2x00dev);
+ rt2800_disable_unused_dac_adc(rt2x00dev);
+}
 
- rt2800_bbp4_mac_if_ctrl(rt2x00dev);
+static void rt2800_init_bbp_3572(struct rt2x00_dev *rt2x00dev)
+{
+ rt2800_bbp_write(rt2x00dev, 31, 0x08);
 
- rt2x00_eeprom_read(rt2x00dev, EEPROM_NIC_CONF1, &eeprom);
- div_mode = rt2x00_get_field16(eeprom, EEPROM_NIC_CONF1_ANT_DIVERSITY);
- ant = (div_mode == 3) ? 1 : 0;
- rt2800_bbp_read(rt2x00dev, 152, &value);
- if (ant == 0) {
-  /* Main antenna */
-  rt2x00_set_field8(&value, BBP152_RX_DEFAULT_ANT, 1);
- } else {
-  /* Auxiliary antenna */
-  rt2x00_set_field8(&value, BBP152_RX_DEFAULT_ANT, 0);
- }
- rt2800_bbp_write(rt2x00dev, 152, value);
+ rt2800_bbp_write(rt2x00dev, 65, 0x2c);
+ rt2800_bbp_write(rt2x00dev, 66, 0x38);
 
- if (rt2x00_rt_rev_gte(rt2x00dev, RT5592, REV_RT5592C)) {
-  rt2800_bbp_read(rt2x00dev, 254, &value);
-  rt2x00_set_field8(&value, BBP254_BIT7, 1);
-  rt2800_bbp_write(rt2x00dev, 254, value);
- }
+ rt2800_bbp_write(rt2x00dev, 69, 0x12);
+ rt2800_bbp_write(rt2x00dev, 73, 0x10);
 
- rt2800_init_freq_calibration(rt2x00dev);
+ rt2800_bbp_write(rt2x00dev, 70, 0x0a);
+
+ rt2800_bbp_write(rt2x00dev, 79, 0x13);
+ rt2800_bbp_write(rt2x00dev, 80, 0x05);
+ rt2800_bbp_write(rt2x00dev, 81, 0x33);
+
+ rt2800_bbp_write(rt2x00dev, 82, 0x62);
+
+ rt2800_bbp_write(rt2x00dev, 83, 0x6a);
+
+ rt2800_bbp_write(rt2x00dev, 84, 0x99);
+
+ rt2800_bbp_write(rt2x00dev, 86, 0x00);
+
+ rt2800_bbp_write(rt2x00dev, 91, 0x04);
+
+ rt2800_bbp_write(rt2x00dev, 92, 0x00);
+
+ rt2800_bbp_write(rt2x00dev, 103, 0xc0);
+
+ rt2800_bbp_write(rt2x00dev, 105, 0x05);
+
+ rt2800_bbp_write(rt2x00dev, 106, 0x35);
+
+ rt2800_disable_unused_dac_adc(rt2x00dev);
+}
+
+static void rt2800_init_bbp_3593(struct rt2x00_dev *rt2x00dev)
+{
+ rt2800_init_bbp_early(rt2x00dev);
+
+ rt2800_bbp_write(rt2x00dev, 79, 0x13);
+ rt2800_bbp_write(rt2x00dev, 80, 0x05);
+ rt2800_bbp_write(rt2x00dev, 81, 0x33);
+ rt2800_bbp_write(rt2x00dev, 137, 0x0f);
 
  rt2800_bbp_write(rt2x00dev, 84, 0x19);
- if (rt2x00_rt_rev_gte(rt2x00dev, RT5592, REV_RT5592C))
+
+ /* Enable DC filter */
+ if (rt2x00_rt_rev_gte(rt2x00dev, RT3593, REV_RT3593E))
   rt2800_bbp_write(rt2x00dev, 103, 0xc0);
 }
 
-static int rt2800_init_bbp(struct rt2x00_dev *rt2x00dev)
+static void rt2800_init_bbp_53xx(struct rt2x00_dev *rt2x00dev)
 {
- unsigned int i;
+ int ant, div_mode;
  u16 eeprom;
- u8 reg_id;
  u8 value;
 
- if (rt2x00_rt(rt2x00dev, RT5592)) {
-  rt2800_init_bbp_5592(rt2x00dev);
-  return 0;
- }
-
- if (rt2x00_rt(rt2x00dev, RT3352)) {
-  rt2800_bbp_write(rt2x00dev, 3, 0x00);
-  rt2800_bbp_write(rt2x00dev, 4, 0x50);
- }
-
- if (rt2x00_rt(rt2x00dev, RT3290) ||
-     rt2x00_rt(rt2x00dev, RT5390) ||
-     rt2x00_rt(rt2x00dev, RT5392))
-  rt2800_bbp4_mac_if_ctrl(rt2x00dev);
-
- if (rt2800_is_305x_soc(rt2x00dev) ||
-     rt2x00_rt(rt2x00dev, RT3290) ||
-     rt2x00_rt(rt2x00dev, RT3352) ||
-     rt2x00_rt(rt2x00dev, RT3572) ||
-     rt2x00_rt(rt2x00dev, RT5390) ||
-     rt2x00_rt(rt2x00dev, RT5392))
-  rt2800_bbp_write(rt2x00dev, 31, 0x08);
+ rt2800_bbp4_mac_if_ctrl(rt2x00dev);
 
- if (rt2x00_rt(rt2x00dev, RT3352))
-  rt2800_bbp_write(rt2x00dev, 47, 0x48);
+ rt2800_bbp_write(rt2x00dev, 31, 0x08);
 
  rt2800_bbp_write(rt2x00dev, 65, 0x2c);
  rt2800_bbp_write(rt2x00dev, 66, 0x38);
 
- if (rt2x00_rt(rt2x00dev, RT3290) ||
-     rt2x00_rt(rt2x00dev, RT3352) ||
-     rt2x00_rt(rt2x00dev, RT5390) ||
-     rt2x00_rt(rt2x00dev, RT5392))
-  rt2800_bbp_write(rt2x00dev, 68, 0x0b);
+ rt2800_bbp_write(rt2x00dev, 68, 0x0b);
 
- if (rt2x00_rt_rev(rt2x00dev, RT2860, REV_RT2860C)) {
-  rt2800_bbp_write(rt2x00dev, 69, 0x16);
-  rt2800_bbp_write(rt2x00dev, 73, 0x12);
- } else if (rt2x00_rt(rt2x00dev, RT3290) ||
-     rt2x00_rt(rt2x00dev, RT3352) ||
-     rt2x00_rt(rt2x00dev, RT5390) ||
-     rt2x00_rt(rt2x00dev, RT5392)) {
-  rt2800_bbp_write(rt2x00dev, 69, 0x12);
-  rt2800_bbp_write(rt2x00dev, 73, 0x13);
-  rt2800_bbp_write(rt2x00dev, 75, 0x46);
-  rt2800_bbp_write(rt2x00dev, 76, 0x28);
+ rt2800_bbp_write(rt2x00dev, 69, 0x12);
+ rt2800_bbp_write(rt2x00dev, 73, 0x13);
+ rt2800_bbp_write(rt2x00dev, 75, 0x46);
+ rt2800_bbp_write(rt2x00dev, 76, 0x28);
 
-  if (rt2x00_rt(rt2x00dev, RT3290))
-   rt2800_bbp_write(rt2x00dev, 77, 0x58);
-  else
-   rt2800_bbp_write(rt2x00dev, 77, 0x59);
- } else {
-  rt2800_bbp_write(rt2x00dev, 69, 0x12);
-  rt2800_bbp_write(rt2x00dev, 73, 0x10);
- }
+ rt2800_bbp_write(rt2x00dev, 77, 0x59);
 
  rt2800_bbp_write(rt2x00dev, 70, 0x0a);
 
- if (rt2x00_rt(rt2x00dev, RT3070) ||
-     rt2x00_rt(rt2x00dev, RT3071) ||
-     rt2x00_rt(rt2x00dev, RT3090) ||
-     rt2x00_rt(rt2x00dev, RT3390) ||
-     rt2x00_rt(rt2x00dev, RT3572) ||
-     rt2x00_rt(rt2x00dev, RT5390) ||
-     rt2x00_rt(rt2x00dev, RT5392)) {
-  rt2800_bbp_write(rt2x00dev, 79, 0x13);
-  rt2800_bbp_write(rt2x00dev, 80, 0x05);
-  rt2800_bbp_write(rt2x00dev, 81, 0x33);
- } else if (rt2800_is_305x_soc(rt2x00dev)) {
-  rt2800_bbp_write(rt2x00dev, 78, 0x0e);
-  rt2800_bbp_write(rt2x00dev, 80, 0x08);
- } else if (rt2x00_rt(rt2x00dev, RT3290)) {
-  rt2800_bbp_write(rt2x00dev, 74, 0x0b);
-  rt2800_bbp_write(rt2x00dev, 79, 0x18);
-  rt2800_bbp_write(rt2x00dev, 80, 0x09);
-  rt2800_bbp_write(rt2x00dev, 81, 0x33);
- } else if (rt2x00_rt(rt2x00dev, RT3352)) {
-  rt2800_bbp_write(rt2x00dev, 78, 0x0e);
-  rt2800_bbp_write(rt2x00dev, 80, 0x08);
-  rt2800_bbp_write(rt2x00dev, 81, 0x37);
- } else {
-  rt2800_bbp_write(rt2x00dev, 81, 0x37);
- }
+ rt2800_bbp_write(rt2x00dev, 79, 0x13);
+ rt2800_bbp_write(rt2x00dev, 80, 0x05);
+ rt2800_bbp_write(rt2x00dev, 81, 0x33);
 
  rt2800_bbp_write(rt2x00dev, 82, 0x62);
- if (rt2x00_rt(rt2x00dev, RT3290) ||
-     rt2x00_rt(rt2x00dev, RT5390) ||
-     rt2x00_rt(rt2x00dev, RT5392))
-  rt2800_bbp_write(rt2x00dev, 83, 0x7a);
- else
-  rt2800_bbp_write(rt2x00dev, 83, 0x6a);
 
- if (rt2x00_rt_rev(rt2x00dev, RT2860, REV_RT2860D))
-  rt2800_bbp_write(rt2x00dev, 84, 0x19);
- else if (rt2x00_rt(rt2x00dev, RT3290) ||
-   rt2x00_rt(rt2x00dev, RT5390) ||
-   rt2x00_rt(rt2x00dev, RT5392))
-  rt2800_bbp_write(rt2x00dev, 84, 0x9a);
- else
-  rt2800_bbp_write(rt2x00dev, 84, 0x99);
+ rt2800_bbp_write(rt2x00dev, 83, 0x7a);
 
- if (rt2x00_rt(rt2x00dev, RT3290) ||
-     rt2x00_rt(rt2x00dev, RT3352) ||
-     rt2x00_rt(rt2x00dev, RT5390) ||
-     rt2x00_rt(rt2x00dev, RT5392))
-  rt2800_bbp_write(rt2x00dev, 86, 0x38);
- else
-  rt2800_bbp_write(rt2x00dev, 86, 0x00);
+ rt2800_bbp_write(rt2x00dev, 84, 0x9a);
 
- if (rt2x00_rt(rt2x00dev, RT3352) ||
-     rt2x00_rt(rt2x00dev, RT5392))
+ rt2800_bbp_write(rt2x00dev, 86, 0x38);
+
+ if (rt2x00_rt(rt2x00dev, RT5392))
   rt2800_bbp_write(rt2x00dev, 88, 0x90);
 
  rt2800_bbp_write(rt2x00dev, 91, 0x04);
 
- if (rt2x00_rt(rt2x00dev, RT3290) ||
-     rt2x00_rt(rt2x00dev, RT3352) ||
-     rt2x00_rt(rt2x00dev, RT5390) ||
-     rt2x00_rt(rt2x00dev, RT5392))
-  rt2800_bbp_write(rt2x00dev, 92, 0x02);
- else
-  rt2800_bbp_write(rt2x00dev, 92, 0x00);
+ rt2800_bbp_write(rt2x00dev, 92, 0x02);
 
  if (rt2x00_rt(rt2x00dev, RT5392)) {
   rt2800_bbp_write(rt2x00dev, 95, 0x9a);
   rt2800_bbp_write(rt2x00dev, 98, 0x12);
  }
 
- if (rt2x00_rt_rev_gte(rt2x00dev, RT3070, REV_RT3070F) ||
-     rt2x00_rt_rev_gte(rt2x00dev, RT3071, REV_RT3071E) ||
-     rt2x00_rt_rev_gte(rt2x00dev, RT3090, REV_RT3090E) ||
-     rt2x00_rt_rev_gte(rt2x00dev, RT3390, REV_RT3390E) ||
-     rt2x00_rt(rt2x00dev, RT3290) ||
-     rt2x00_rt(rt2x00dev, RT3352) ||
-     rt2x00_rt(rt2x00dev, RT3572) ||
-     rt2x00_rt(rt2x00dev, RT5390) ||
-     rt2x00_rt(rt2x00dev, RT5392) ||
-     rt2800_is_305x_soc(rt2x00dev))
-  rt2800_bbp_write(rt2x00dev, 103, 0xc0);
- else
-  rt2800_bbp_write(rt2x00dev, 103, 0x00);
+ rt2800_bbp_write(rt2x00dev, 103, 0xc0);
 
- if (rt2x00_rt(rt2x00dev, RT3290) ||
-     rt2x00_rt(rt2x00dev, RT3352) ||
-     rt2x00_rt(rt2x00dev, RT5390) ||
-     rt2x00_rt(rt2x00dev, RT5392))
-  rt2800_bbp_write(rt2x00dev, 104, 0x92);
+ rt2800_bbp_write(rt2x00dev, 104, 0x92);
 
- if (rt2800_is_305x_soc(rt2x00dev))
-  rt2800_bbp_write(rt2x00dev, 105, 0x01);
- else if (rt2x00_rt(rt2x00dev, RT3290))
-  rt2800_bbp_write(rt2x00dev, 105, 0x1c);
- else if (rt2x00_rt(rt2x00dev, RT3352))
-  rt2800_bbp_write(rt2x00dev, 105, 0x34);
- else if (rt2x00_rt(rt2x00dev, RT5390) ||
-   rt2x00_rt(rt2x00dev, RT5392))
-  rt2800_bbp_write(rt2x00dev, 105, 0x3c);
- else
-  rt2800_bbp_write(rt2x00dev, 105, 0x05);
+ rt2800_bbp_write(rt2x00dev, 105, 0x3c);
 
- if (rt2x00_rt(rt2x00dev, RT3290) ||
-     rt2x00_rt(rt2x00dev, RT5390))
+ if (rt2x00_rt(rt2x00dev, RT5390))
   rt2800_bbp_write(rt2x00dev, 106, 0x03);
- else if (rt2x00_rt(rt2x00dev, RT3352))
-  rt2800_bbp_write(rt2x00dev, 106, 0x05);
  else if (rt2x00_rt(rt2x00dev, RT5392))
   rt2800_bbp_write(rt2x00dev, 106, 0x12);
  else
-  rt2800_bbp_write(rt2x00dev, 106, 0x35);
+  WARN_ON(1);
 
- if (rt2x00_rt(rt2x00dev, RT3352))
-  rt2800_bbp_write(rt2x00dev, 120, 0x50);
-
- if (rt2x00_rt(rt2x00dev, RT3290) ||
-     rt2x00_rt(rt2x00dev, RT5390) ||
-     rt2x00_rt(rt2x00dev, RT5392))
-  rt2800_bbp_write(rt2x00dev, 128, 0x12);
+ rt2800_bbp_write(rt2x00dev, 128, 0x12);
 
  if (rt2x00_rt(rt2x00dev, RT5392)) {
   rt2800_bbp_write(rt2x00dev, 134, 0xd0);
   rt2800_bbp_write(rt2x00dev, 135, 0xf6);
  }
 
- if (rt2x00_rt(rt2x00dev, RT3352))
-  rt2800_bbp_write(rt2x00dev, 137, 0x0f);
+ rt2800_disable_unused_dac_adc(rt2x00dev);
 
- if (rt2x00_rt(rt2x00dev, RT3071) ||
-     rt2x00_rt(rt2x00dev, RT3090) ||
-     rt2x00_rt(rt2x00dev, RT3390) ||
-     rt2x00_rt(rt2x00dev, RT3572) ||
-     rt2x00_rt(rt2x00dev, RT5390) ||
-     rt2x00_rt(rt2x00dev, RT5392)) {
-  rt2800_bbp_read(rt2x00dev, 138, &value);
+ rt2800_eeprom_read(rt2x00dev, EEPROM_NIC_CONF1, &eeprom);
+ div_mode = rt2x00_get_field16(eeprom,
+          EEPROM_NIC_CONF1_ANT_DIVERSITY);
+ ant = (div_mode == 3) ? 1 : 0;
 
-  rt2x00_eeprom_read(rt2x00dev, EEPROM_NIC_CONF0, &eeprom);
-  if (rt2x00_get_field16(eeprom, EEPROM_NIC_CONF0_TXPATH) == 1)
-   value |= 0x20;
-  if (rt2x00_get_field16(eeprom, EEPROM_NIC_CONF0_RXPATH) == 1)
-   value &= ~0x02;
+ /* check if this is a Bluetooth combo card */
+ if (rt2x00_has_cap_bt_coexist(rt2x00dev)) {
+  u32 reg;
 
-  rt2800_bbp_write(rt2x00dev, 138, value);
+  rt2800_register_read(rt2x00dev, GPIO_CTRL, &reg);
+  rt2x00_set_field32(&reg, GPIO_CTRL_DIR3, 0);
+  rt2x00_set_field32(&reg, GPIO_CTRL_DIR6, 0);
+  rt2x00_set_field32(&reg, GPIO_CTRL_VAL3, 0);
+  rt2x00_set_field32(&reg, GPIO_CTRL_VAL6, 0);
+  if (ant == 0)
+   rt2x00_set_field32(&reg, GPIO_CTRL_VAL3, 1);
+  else if (ant == 1)
+   rt2x00_set_field32(&reg, GPIO_CTRL_VAL6, 1);
+  rt2800_register_write(rt2x00dev, GPIO_CTRL, reg);
  }
 
- if (rt2x00_rt(rt2x00dev, RT3290)) {
-  rt2800_bbp_write(rt2x00dev, 67, 0x24);
-  rt2800_bbp_write(rt2x00dev, 143, 0x04);
-  rt2800_bbp_write(rt2x00dev, 142, 0x99);
-  rt2800_bbp_write(rt2x00dev, 150, 0x30);
-  rt2800_bbp_write(rt2x00dev, 151, 0x2e);
-  rt2800_bbp_write(rt2x00dev, 152, 0x20);
-  rt2800_bbp_write(rt2x00dev, 153, 0x34);
-  rt2800_bbp_write(rt2x00dev, 154, 0x40);
-  rt2800_bbp_write(rt2x00dev, 155, 0x3b);
-  rt2800_bbp_write(rt2x00dev, 253, 0x04);
-
-  rt2800_bbp_read(rt2x00dev, 47, &value);
-  rt2x00_set_field8(&value, BBP47_TSSI_ADC6, 1);
-  rt2800_bbp_write(rt2x00dev, 47, value);
-
-  /* Use 5-bit ADC for Acquisition and 8-bit ADC for data */
-  rt2800_bbp_read(rt2x00dev, 3, &value);
-  rt2x00_set_field8(&value, BBP3_ADC_MODE_SWITCH, 1);
-  rt2x00_set_field8(&value, BBP3_ADC_INIT_MODE, 1);
-  rt2800_bbp_write(rt2x00dev, 3, value);
+ /* This chip has hardware antenna diversity*/
+ if (rt2x00_rt_rev_gte(rt2x00dev, RT5390, REV_RT5390R)) {
+  rt2800_bbp_write(rt2x00dev, 150, 0); /* Disable Antenna Software OFDM */
+  rt2800_bbp_write(rt2x00dev, 151, 0); /* Disable Antenna Software CCK */
+  rt2800_bbp_write(rt2x00dev, 154, 0); /* Clear previously selected antenna */
  }
 
- if (rt2x00_rt(rt2x00dev, RT3352)) {
-  rt2800_bbp_write(rt2x00dev, 163, 0xbd);
-  /* Set ITxBF timeout to 0x9c40=1000msec */
-  rt2800_bbp_write(rt2x00dev, 179, 0x02);
-  rt2800_bbp_write(rt2x00dev, 180, 0x00);
-  rt2800_bbp_write(rt2x00dev, 182, 0x40);
-  rt2800_bbp_write(rt2x00dev, 180, 0x01);
-  rt2800_bbp_write(rt2x00dev, 182, 0x9c);
-  rt2800_bbp_write(rt2x00dev, 179, 0x00);
-  /* Reprogram the inband interface to put right values in RXWI */
-  rt2800_bbp_write(rt2x00dev, 142, 0x04);
-  rt2800_bbp_write(rt2x00dev, 143, 0x3b);
-  rt2800_bbp_write(rt2x00dev, 142, 0x06);
-  rt2800_bbp_write(rt2x00dev, 143, 0xa0);
-  rt2800_bbp_write(rt2x00dev, 142, 0x07);
-  rt2800_bbp_write(rt2x00dev, 143, 0xa1);
-  rt2800_bbp_write(rt2x00dev, 142, 0x08);
-  rt2800_bbp_write(rt2x00dev, 143, 0xa2);
-
-  rt2800_bbp_write(rt2x00dev, 148, 0xc8);
- }
-
- if (rt2x00_rt(rt2x00dev, RT5390) ||
-     rt2x00_rt(rt2x00dev, RT5392)) {
-  int ant, div_mode;
-
-  rt2x00_eeprom_read(rt2x00dev, EEPROM_NIC_CONF1, &eeprom);
-  div_mode = rt2x00_get_field16(eeprom,
-           EEPROM_NIC_CONF1_ANT_DIVERSITY);
-  ant = (div_mode == 3) ? 1 : 0;
-
-  /* check if this is a Bluetooth combo card */
-  if (test_bit(CAPABILITY_BT_COEXIST, &rt2x00dev->cap_flags)) {
-   u32 reg;
-
-   rt2800_register_read(rt2x00dev, GPIO_CTRL, &reg);
-   rt2x00_set_field32(&reg, GPIO_CTRL_DIR3, 0);
-   rt2x00_set_field32(&reg, GPIO_CTRL_DIR6, 0);
-   rt2x00_set_field32(&reg, GPIO_CTRL_VAL3, 0);
-   rt2x00_set_field32(&reg, GPIO_CTRL_VAL6, 0);
-   if (ant == 0)
-    rt2x00_set_field32(&reg, GPIO_CTRL_VAL3, 1);
-   else if (ant == 1)
-    rt2x00_set_field32(&reg, GPIO_CTRL_VAL6, 1);
-   rt2800_register_write(rt2x00dev, GPIO_CTRL, reg);
-  }
+ rt2800_bbp_read(rt2x00dev, 152, &value);
+ if (ant == 0)
+  rt2x00_set_field8(&value, BBP152_RX_DEFAULT_ANT, 1);
+ else
+  rt2x00_set_field8(&value, BBP152_RX_DEFAULT_ANT, 0);
+ rt2800_bbp_write(rt2x00dev, 152, value);
 
-  /* This chip has hardware antenna diversity*/
-  if (rt2x00_rt_rev_gte(rt2x00dev, RT5390, REV_RT5390R)) {
-   rt2800_bbp_write(rt2x00dev, 150, 0); /* Disable Antenna Software OFDM */
-   rt2800_bbp_write(rt2x00dev, 151, 0); /* Disable Antenna Software CCK */
-   rt2800_bbp_write(rt2x00dev, 154, 0); /* Clear previously selected antenna */
-  }
+ rt2800_init_freq_calibration(rt2x00dev);
+}
 
-  rt2800_bbp_read(rt2x00dev, 152, &value);
-  if (ant == 0)
-   rt2x00_set_field8(&value, BBP152_RX_DEFAULT_ANT, 1);
-  else
-   rt2x00_set_field8(&value, BBP152_RX_DEFAULT_ANT, 0);
-  rt2800_bbp_write(rt2x00dev, 152, value);
+static void rt2800_init_bbp_5592(struct rt2x00_dev *rt2x00dev)
+{
+ int ant, div_mode;
+ u16 eeprom;
+ u8 value;
+
+ rt2800_init_bbp_early(rt2x00dev);
+
+ rt2800_bbp_read(rt2x00dev, 105, &value);
+ rt2x00_set_field8(&value, BBP105_MLD,
+     rt2x00dev->default_ant.rx_chain_num == 2);
+ rt2800_bbp_write(rt2x00dev, 105, value);
 
-  rt2800_init_freq_calibration(rt2x00dev);
+ rt2800_bbp4_mac_if_ctrl(rt2x00dev);
+
+ rt2800_bbp_write(rt2x00dev, 20, 0x06);
+ rt2800_bbp_write(rt2x00dev, 31, 0x08);
+ rt2800_bbp_write(rt2x00dev, 65, 0x2C);
+ rt2800_bbp_write(rt2x00dev, 68, 0xDD);
+ rt2800_bbp_write(rt2x00dev, 69, 0x1A);
+ rt2800_bbp_write(rt2x00dev, 70, 0x05);
+ rt2800_bbp_write(rt2x00dev, 73, 0x13);
+ rt2800_bbp_write(rt2x00dev, 74, 0x0F);
+ rt2800_bbp_write(rt2x00dev, 75, 0x4F);
+ rt2800_bbp_write(rt2x00dev, 76, 0x28);
+ rt2800_bbp_write(rt2x00dev, 77, 0x59);
+ rt2800_bbp_write(rt2x00dev, 84, 0x9A);
+ rt2800_bbp_write(rt2x00dev, 86, 0x38);
+ rt2800_bbp_write(rt2x00dev, 88, 0x90);
+ rt2800_bbp_write(rt2x00dev, 91, 0x04);
+ rt2800_bbp_write(rt2x00dev, 92, 0x02);
+ rt2800_bbp_write(rt2x00dev, 95, 0x9a);
+ rt2800_bbp_write(rt2x00dev, 98, 0x12);
+ rt2800_bbp_write(rt2x00dev, 103, 0xC0);
+ rt2800_bbp_write(rt2x00dev, 104, 0x92);
+ /* FIXME BBP105 owerwrite */
+ rt2800_bbp_write(rt2x00dev, 105, 0x3C);
+ rt2800_bbp_write(rt2x00dev, 106, 0x35);
+ rt2800_bbp_write(rt2x00dev, 128, 0x12);
+ rt2800_bbp_write(rt2x00dev, 134, 0xD0);
+ rt2800_bbp_write(rt2x00dev, 135, 0xF6);
+ rt2800_bbp_write(rt2x00dev, 137, 0x0F);
+
+ /* Initialize GLRT (Generalized Likehood Radio Test) */
+ rt2800_init_bbp_5592_glrt(rt2x00dev);
+
+ rt2800_bbp4_mac_if_ctrl(rt2x00dev);
+
+ rt2800_eeprom_read(rt2x00dev, EEPROM_NIC_CONF1, &eeprom);
+ div_mode = rt2x00_get_field16(eeprom, EEPROM_NIC_CONF1_ANT_DIVERSITY);
+ ant = (div_mode == 3) ? 1 : 0;
+ rt2800_bbp_read(rt2x00dev, 152, &value);
+ if (ant == 0) {
+  /* Main antenna */
+  rt2x00_set_field8(&value, BBP152_RX_DEFAULT_ANT, 1);
+ } else {
+  /* Auxiliary antenna */
+  rt2x00_set_field8(&value, BBP152_RX_DEFAULT_ANT, 0);
+ }
+ rt2800_bbp_write(rt2x00dev, 152, value);
+
+ if (rt2x00_rt_rev_gte(rt2x00dev, RT5592, REV_RT5592C)) {
+  rt2800_bbp_read(rt2x00dev, 254, &value);
+  rt2x00_set_field8(&value, BBP254_BIT7, 1);
+  rt2800_bbp_write(rt2x00dev, 254, value);
+ }
+
+ rt2800_init_freq_calibration(rt2x00dev);
+
+ rt2800_bbp_write(rt2x00dev, 84, 0x19);
+ if (rt2x00_rt_rev_gte(rt2x00dev, RT5592, REV_RT5592C))
+  rt2800_bbp_write(rt2x00dev, 103, 0xc0);
+}
+
+static void rt2800_init_bbp(struct rt2x00_dev *rt2x00dev)
+{
+ unsigned int i;
+ u16 eeprom;
+ u8 reg_id;
+ u8 value;
+
+ if (rt2800_is_305x_soc(rt2x00dev))
+  rt2800_init_bbp_305x_soc(rt2x00dev);
+
+ switch (rt2x00dev->chip.rt) {
+ case RT2860:
+ case RT2872:
+ case RT2883:
+  rt2800_init_bbp_28xx(rt2x00dev);
+  break;
+ case RT3070:
+ case RT3071:
+ case RT3090:
+  rt2800_init_bbp_30xx(rt2x00dev);
+  break;
+ case RT3290:
+  rt2800_init_bbp_3290(rt2x00dev);
+  break;
+ case RT3352:
+  rt2800_init_bbp_3352(rt2x00dev);
+  break;
+ case RT3390:
+  rt2800_init_bbp_3390(rt2x00dev);
+  break;
+ case RT3572:
+  rt2800_init_bbp_3572(rt2x00dev);
+  break;
+ case RT3593:
+  rt2800_init_bbp_3593(rt2x00dev);
+  return;
+ case RT5390:
+ case RT5392:
+  rt2800_init_bbp_53xx(rt2x00dev);
+  break;
+ case RT5592:
+  rt2800_init_bbp_5592(rt2x00dev);
+  return;
  }
 
  for (i = 0; i < EEPROM_BBP_SIZE; i++) {
-  rt2x00_eeprom_read(rt2x00dev, EEPROM_BBP_START + i, &eeprom);
+  rt2800_eeprom_read_from_array(rt2x00dev, EEPROM_BBP_START, i,
+           &eeprom);
 
   if (eeprom != 0xffff && eeprom != 0x0000) {
    reg_id = rt2x00_get_field16(eeprom, EEPROM_BBP_REG_ID);
@@ -4347,8 +5681,6 @@ static int rt2800_init_bbp(struct rt2x00_dev *rt2x00dev)
    rt2800_bbp_write(rt2x00dev, reg_id, value);
   }
  }
-
- return 0;
 }
 
 static void rt2800_led_open_drain_enable(struct rt2x00_dev *rt2x00dev)
@@ -4497,7 +5829,7 @@ static void rt2800_normal_mode_setup_3xxx(struct rt2x00_dev *rt2x00dev)
      rt2x00_rt_rev_lt(rt2x00dev, RT3071, REV_RT3071E) ||
      rt2x00_rt_rev_lt(rt2x00dev, RT3090, REV_RT3090E) ||
      rt2x00_rt_rev_lt(rt2x00dev, RT3390, REV_RT3390E)) {
-  if (!test_bit(CAPABILITY_EXTERNAL_LNA_BG, &rt2x00dev->cap_flags))
+  if (!rt2x00_has_cap_external_lna_bg(rt2x00dev))
    rt2x00_set_field8(&rfcsr, RFCSR17_R, 1);
  }
 
@@ -4512,7 +5844,7 @@ static void rt2800_normal_mode_setup_3xxx(struct rt2x00_dev *rt2x00dev)
  if (rt2x00_rt(rt2x00dev, RT3090)) {
   /*  Turn off unused DAC1 and ADC1 to reduce power consumption */
   rt2800_bbp_read(rt2x00dev, 138, &bbp);
-  rt2x00_eeprom_read(rt2x00dev, EEPROM_NIC_CONF0, &eeprom);
+  rt2800_eeprom_read(rt2x00dev, EEPROM_NIC_CONF0, &eeprom);
   if (rt2x00_get_field16(eeprom, EEPROM_NIC_CONF0_RXPATH) == 1)
    rt2x00_set_field8(&bbp, BBP138_RX_ADC1, 0);
   if (rt2x00_get_field16(eeprom, EEPROM_NIC_CONF0_TXPATH) == 1)
@@ -4555,6 +5887,42 @@ static void rt2800_normal_mode_setup_3xxx(struct rt2x00_dev *rt2x00dev)
  }
 }
 
+static void rt2800_normal_mode_setup_3593(struct rt2x00_dev *rt2x00dev)
+{
+ struct rt2800_drv_data *drv_data = rt2x00dev->drv_data;
+ u8 rfcsr;
+ u8 tx_gain;
+
+ rt2800_rfcsr_read(rt2x00dev, 50, &rfcsr);
+ rt2x00_set_field8(&rfcsr, RFCSR50_TX_LO2_EN, 0);
+ rt2800_rfcsr_write(rt2x00dev, 50, rfcsr);
+
+ rt2800_rfcsr_read(rt2x00dev, 51, &rfcsr);
+ tx_gain = rt2x00_get_field8(drv_data->txmixer_gain_24g,
+        RFCSR17_TXMIXER_GAIN);
+ rt2x00_set_field8(&rfcsr, RFCSR51_BITS24, tx_gain);
+ rt2800_rfcsr_write(rt2x00dev, 51, rfcsr);
+
+ rt2800_rfcsr_read(rt2x00dev, 38, &rfcsr);
+ rt2x00_set_field8(&rfcsr, RFCSR38_RX_LO1_EN, 0);
+ rt2800_rfcsr_write(rt2x00dev, 38, rfcsr);
+
+ rt2800_rfcsr_read(rt2x00dev, 39, &rfcsr);
+ rt2x00_set_field8(&rfcsr, RFCSR39_RX_LO2_EN, 0);
+ rt2800_rfcsr_write(rt2x00dev, 39, rfcsr);
+
+ rt2800_rfcsr_read(rt2x00dev, 1, &rfcsr);
+ rt2x00_set_field8(&rfcsr, RFCSR1_RF_BLOCK_EN, 1);
+ rt2x00_set_field8(&rfcsr, RFCSR1_PLL_PD, 1);
+ rt2800_rfcsr_write(rt2x00dev, 1, rfcsr);
+
+ rt2800_rfcsr_read(rt2x00dev, 30, &rfcsr);
+ rt2x00_set_field8(&rfcsr, RFCSR30_RX_VCM, 2);
+ rt2800_rfcsr_write(rt2x00dev, 30, rfcsr);
+
+ /* TODO: enable stream mode */
+}
+
 static void rt2800_normal_mode_setup_5xxx(struct rt2x00_dev *rt2x00dev)
 {
  u8 reg;
@@ -4562,7 +5930,7 @@ static void rt2800_normal_mode_setup_5xxx(struct rt2x00_dev *rt2x00dev)
 
  /*  Turn off unused DAC1 and ADC1 to reduce power consumption */
  rt2800_bbp_read(rt2x00dev, 138, &reg);
- rt2x00_eeprom_read(rt2x00dev, EEPROM_NIC_CONF0, &eeprom);
+ rt2800_eeprom_read(rt2x00dev, EEPROM_NIC_CONF0, &eeprom);
  if (rt2x00_get_field16(eeprom, EEPROM_NIC_CONF0_RXPATH) == 1)
   rt2x00_set_field8(&reg, BBP138_RX_ADC1, 0);
  if (rt2x00_get_field16(eeprom, EEPROM_NIC_CONF0_TXPATH) == 1)
@@ -4648,7 +6016,7 @@ static void rt2800_init_rfcsr_30xx(struct rt2x00_dev *rt2x00dev)
  rt2800_rfcsr_write(rt2x00dev, 20, 0xba);
  rt2800_rfcsr_write(rt2x00dev, 21, 0xdb);
  rt2800_rfcsr_write(rt2x00dev, 24, 0x16);
- rt2800_rfcsr_write(rt2x00dev, 25, 0x01);
+ rt2800_rfcsr_write(rt2x00dev, 25, 0x03);
  rt2800_rfcsr_write(rt2x00dev, 29, 0x1f);
 
  if (rt2x00_rt_rev_lt(rt2x00dev, RT3070, REV_RT3070F)) {
@@ -4668,7 +6036,8 @@ static void rt2800_init_rfcsr_30xx(struct rt2x00_dev *rt2x00dev)
   rt2x00_set_field32(&reg, LDO_CFG0_BGSEL, 1);
   if (rt2x00_rt_rev_lt(rt2x00dev, RT3071, REV_RT3071E) ||
       rt2x00_rt_rev_lt(rt2x00dev, RT3090, REV_RT3090E)) {
-   rt2x00_eeprom_read(rt2x00dev, EEPROM_NIC_CONF1, &eeprom);
+   rt2800_eeprom_read(rt2x00dev, EEPROM_NIC_CONF1,
+        &eeprom);
    if (rt2x00_get_field16(eeprom, EEPROM_NIC_CONF1_DAC_TEST))
     rt2x00_set_field32(&reg, LDO_CFG0_LDO_CORE_VLEVEL, 3);
    else
@@ -4936,6 +6305,136 @@ static void rt2800_init_rfcsr_3572(struct rt2x00_dev *rt2x00dev)
  rt2800_normal_mode_setup_3xxx(rt2x00dev);
 }
 
+static void rt3593_post_bbp_init(struct rt2x00_dev *rt2x00dev)
+{
+ u8 bbp;
+ bool txbf_enabled = false; /* FIXME */
+
+ rt2800_bbp_read(rt2x00dev, 105, &bbp);
+ if (rt2x00dev->default_ant.rx_chain_num == 1)
+  rt2x00_set_field8(&bbp, BBP105_MLD, 0);
+ else
+  rt2x00_set_field8(&bbp, BBP105_MLD, 1);
+ rt2800_bbp_write(rt2x00dev, 105, bbp);
+
+ rt2800_bbp4_mac_if_ctrl(rt2x00dev);
+
+ rt2800_bbp_write(rt2x00dev, 92, 0x02);
+ rt2800_bbp_write(rt2x00dev, 82, 0x82);
+ rt2800_bbp_write(rt2x00dev, 106, 0x05);
+ rt2800_bbp_write(rt2x00dev, 104, 0x92);
+ rt2800_bbp_write(rt2x00dev, 88, 0x90);
+ rt2800_bbp_write(rt2x00dev, 148, 0xc8);
+ rt2800_bbp_write(rt2x00dev, 47, 0x48);
+ rt2800_bbp_write(rt2x00dev, 120, 0x50);
+
+ if (txbf_enabled)
+  rt2800_bbp_write(rt2x00dev, 163, 0xbd);
+ else
+  rt2800_bbp_write(rt2x00dev, 163, 0x9d);
+
+ /* SNR mapping */
+ rt2800_bbp_write(rt2x00dev, 142, 6);
+ rt2800_bbp_write(rt2x00dev, 143, 160);
+ rt2800_bbp_write(rt2x00dev, 142, 7);
+ rt2800_bbp_write(rt2x00dev, 143, 161);
+ rt2800_bbp_write(rt2x00dev, 142, 8);
+ rt2800_bbp_write(rt2x00dev, 143, 162);
+
+ /* ADC/DAC control */
+ rt2800_bbp_write(rt2x00dev, 31, 0x08);
+
+ /* RX AGC energy lower bound in log2 */
+ rt2800_bbp_write(rt2x00dev, 68, 0x0b);
+
+ /* FIXME: BBP 105 owerwrite? */
+ rt2800_bbp_write(rt2x00dev, 105, 0x04);
+
+}
+
+static void rt2800_init_rfcsr_3593(struct rt2x00_dev *rt2x00dev)
+{
+ struct rt2800_drv_data *drv_data = rt2x00dev->drv_data;
+ u32 reg;
+ u8 rfcsr;
+
+ /* Disable GPIO #4 and #7 function for LAN PE control */
+ rt2800_register_read(rt2x00dev, GPIO_SWITCH, &reg);
+ rt2x00_set_field32(&reg, GPIO_SWITCH_4, 0);
+ rt2x00_set_field32(&reg, GPIO_SWITCH_7, 0);
+ rt2800_register_write(rt2x00dev, GPIO_SWITCH, reg);
+
+ /* Initialize default register values */
+ rt2800_rfcsr_write(rt2x00dev, 1, 0x03);
+ rt2800_rfcsr_write(rt2x00dev, 3, 0x80);
+ rt2800_rfcsr_write(rt2x00dev, 5, 0x00);
+ rt2800_rfcsr_write(rt2x00dev, 6, 0x40);
+ rt2800_rfcsr_write(rt2x00dev, 8, 0xf1);
+ rt2800_rfcsr_write(rt2x00dev, 9, 0x02);
+ rt2800_rfcsr_write(rt2x00dev, 10, 0xd3);
+ rt2800_rfcsr_write(rt2x00dev, 11, 0x40);
+ rt2800_rfcsr_write(rt2x00dev, 12, 0x4e);
+ rt2800_rfcsr_write(rt2x00dev, 13, 0x12);
+ rt2800_rfcsr_write(rt2x00dev, 18, 0x40);
+ rt2800_rfcsr_write(rt2x00dev, 22, 0x20);
+ rt2800_rfcsr_write(rt2x00dev, 30, 0x10);
+ rt2800_rfcsr_write(rt2x00dev, 31, 0x80);
+ rt2800_rfcsr_write(rt2x00dev, 32, 0x78);
+ rt2800_rfcsr_write(rt2x00dev, 33, 0x3b);
+ rt2800_rfcsr_write(rt2x00dev, 34, 0x3c);
+ rt2800_rfcsr_write(rt2x00dev, 35, 0xe0);
+ rt2800_rfcsr_write(rt2x00dev, 38, 0x86);
+ rt2800_rfcsr_write(rt2x00dev, 39, 0x23);
+ rt2800_rfcsr_write(rt2x00dev, 44, 0xd3);
+ rt2800_rfcsr_write(rt2x00dev, 45, 0xbb);
+ rt2800_rfcsr_write(rt2x00dev, 46, 0x60);
+ rt2800_rfcsr_write(rt2x00dev, 49, 0x8e);
+ rt2800_rfcsr_write(rt2x00dev, 50, 0x86);
+ rt2800_rfcsr_write(rt2x00dev, 51, 0x75);
+ rt2800_rfcsr_write(rt2x00dev, 52, 0x45);
+ rt2800_rfcsr_write(rt2x00dev, 53, 0x18);
+ rt2800_rfcsr_write(rt2x00dev, 54, 0x18);
+ rt2800_rfcsr_write(rt2x00dev, 55, 0x18);
+ rt2800_rfcsr_write(rt2x00dev, 56, 0xdb);
+ rt2800_rfcsr_write(rt2x00dev, 57, 0x6e);
+
+ /* Initiate calibration */
+ /* TODO: use rt2800_rf_init_calibration ? */
+ rt2800_rfcsr_read(rt2x00dev, 2, &rfcsr);
+ rt2x00_set_field8(&rfcsr, RFCSR2_RESCAL_EN, 1);
+ rt2800_rfcsr_write(rt2x00dev, 2, rfcsr);
+
+ rt2800_adjust_freq_offset(rt2x00dev);
+
+ rt2800_rfcsr_read(rt2x00dev, 18, &rfcsr);
+ rt2x00_set_field8(&rfcsr, RFCSR18_XO_TUNE_BYPASS, 1);
+ rt2800_rfcsr_write(rt2x00dev, 18, rfcsr);
+
+ rt2800_register_read(rt2x00dev, LDO_CFG0, &reg);
+ rt2x00_set_field32(&reg, LDO_CFG0_LDO_CORE_VLEVEL, 3);
+ rt2x00_set_field32(&reg, LDO_CFG0_BGSEL, 1);
+ rt2800_register_write(rt2x00dev, LDO_CFG0, reg);
+ usleep_range(1000, 1500);
+ rt2800_register_read(rt2x00dev, LDO_CFG0, &reg);
+ rt2x00_set_field32(&reg, LDO_CFG0_LDO_CORE_VLEVEL, 0);
+ rt2800_register_write(rt2x00dev, LDO_CFG0, reg);
+
+ /* Set initial values for RX filter calibration */
+ drv_data->calibration_bw20 = 0x1f;
+ drv_data->calibration_bw40 = 0x2f;
+
+ /* Save BBP 25 & 26 values for later use in channel switching */
+ rt2800_bbp_read(rt2x00dev, 25, &drv_data->bbp25);
+ rt2800_bbp_read(rt2x00dev, 26, &drv_data->bbp26);
+
+ rt2800_led_open_drain_enable(rt2x00dev);
+ rt2800_normal_mode_setup_3593(rt2x00dev);
+
+ rt3593_post_bbp_init(rt2x00dev);
+
+ /* TODO: enable stream mode support */
+}
+
 static void rt2800_init_rfcsr_5390(struct rt2x00_dev *rt2x00dev)
 {
  rt2800_rf_init_calibration(rt2x00dev, 2);
@@ -4951,7 +6450,7 @@ static void rt2800_init_rfcsr_5390(struct rt2x00_dev *rt2x00dev)
  rt2800_rfcsr_write(rt2x00dev, 7, 0x00);
  rt2800_rfcsr_write(rt2x00dev, 10, 0x53);
  rt2800_rfcsr_write(rt2x00dev, 11, 0x4a);
- rt2800_rfcsr_write(rt2x00dev, 12, 0xc6);
+ rt2800_rfcsr_write(rt2x00dev, 12, 0x46);
  rt2800_rfcsr_write(rt2x00dev, 13, 0x9f);
  rt2800_rfcsr_write(rt2x00dev, 14, 0x00);
  rt2800_rfcsr_write(rt2x00dev, 15, 0x00);
@@ -4964,7 +6463,8 @@ static void rt2800_init_rfcsr_5390(struct rt2x00_dev *rt2x00dev)
  rt2800_rfcsr_write(rt2x00dev, 22, 0x20);
  rt2800_rfcsr_write(rt2x00dev, 23, 0x00);
  rt2800_rfcsr_write(rt2x00dev, 24, 0x00);
- if (rt2x00_rt_rev_gte(rt2x00dev, RT5390, REV_RT5390F))
+ if (rt2x00_is_usb(rt2x00dev) &&
+     rt2x00_rt_rev_gte(rt2x00dev, RT5390, REV_RT5390F))
   rt2800_rfcsr_write(rt2x00dev, 25, 0x80);
  else
   rt2800_rfcsr_write(rt2x00dev, 25, 0xc0);
@@ -4973,7 +6473,7 @@ static void rt2800_init_rfcsr_5390(struct rt2x00_dev *rt2x00dev)
  rt2800_rfcsr_write(rt2x00dev, 28, 0x00);
  rt2800_rfcsr_write(rt2x00dev, 29, 0x10);
 
- rt2800_rfcsr_write(rt2x00dev, 30, 0x00);
+ rt2800_rfcsr_write(rt2x00dev, 30, 0x10);
  rt2800_rfcsr_write(rt2x00dev, 31, 0x80);
  rt2800_rfcsr_write(rt2x00dev, 32, 0x80);
  rt2800_rfcsr_write(rt2x00dev, 33, 0x00);
@@ -4984,10 +6484,7 @@ static void rt2800_init_rfcsr_5390(struct rt2x00_dev *rt2x00dev)
  rt2800_rfcsr_write(rt2x00dev, 38, 0x85);
  rt2800_rfcsr_write(rt2x00dev, 39, 0x1b);
 
- if (rt2x00_rt_rev_gte(rt2x00dev, RT5390, REV_RT5390F))
-  rt2800_rfcsr_write(rt2x00dev, 40, 0x0b);
- else
-  rt2800_rfcsr_write(rt2x00dev, 40, 0x4b);
+ rt2800_rfcsr_write(rt2x00dev, 40, 0x0b);
  rt2800_rfcsr_write(rt2x00dev, 41, 0xbb);
  rt2800_rfcsr_write(rt2x00dev, 42, 0xd2);
  rt2800_rfcsr_write(rt2x00dev, 43, 0x9a);
@@ -5008,16 +6505,26 @@ static void rt2800_init_rfcsr_5390(struct rt2x00_dev *rt2x00dev)
   rt2800_rfcsr_write(rt2x00dev, 53, 0x84);
  rt2800_rfcsr_write(rt2x00dev, 54, 0x78);
  rt2800_rfcsr_write(rt2x00dev, 55, 0x44);
- rt2800_rfcsr_write(rt2x00dev, 56, 0x22);
+ if (rt2x00_rt_rev_gte(rt2x00dev, RT5390, REV_RT5390F))
+  rt2800_rfcsr_write(rt2x00dev, 56, 0x42);
+ else
+  rt2800_rfcsr_write(rt2x00dev, 56, 0x22);
  rt2800_rfcsr_write(rt2x00dev, 57, 0x80);
  rt2800_rfcsr_write(rt2x00dev, 58, 0x7f);
- rt2800_rfcsr_write(rt2x00dev, 59, 0x63);
+ rt2800_rfcsr_write(rt2x00dev, 59, 0x8f);
 
  rt2800_rfcsr_write(rt2x00dev, 60, 0x45);
- if (rt2x00_rt_rev_gte(rt2x00dev, RT5390, REV_RT5390F))
-  rt2800_rfcsr_write(rt2x00dev, 61, 0xd1);
- else
-  rt2800_rfcsr_write(rt2x00dev, 61, 0xdd);
+ if (rt2x00_rt_rev_gte(rt2x00dev, RT5390, REV_RT5390F)) {
+  if (rt2x00_is_usb(rt2x00dev))
+   rt2800_rfcsr_write(rt2x00dev, 61, 0xd1);
+  else
+   rt2800_rfcsr_write(rt2x00dev, 61, 0xd5);
+ } else {
+  if (rt2x00_is_usb(rt2x00dev))
+   rt2800_rfcsr_write(rt2x00dev, 61, 0xdd);
+  else
+   rt2800_rfcsr_write(rt2x00dev, 61, 0xb5);
+ }
  rt2800_rfcsr_write(rt2x00dev, 62, 0x00);
  rt2800_rfcsr_write(rt2x00dev, 63, 0x00);
 
@@ -5031,7 +6538,6 @@ static void rt2800_init_rfcsr_5392(struct rt2x00_dev *rt2x00dev)
  rt2800_rf_init_calibration(rt2x00dev, 2);
 
  rt2800_rfcsr_write(rt2x00dev, 1, 0x17);
- rt2800_rfcsr_write(rt2x00dev, 2, 0x80);
  rt2800_rfcsr_write(rt2x00dev, 3, 0x88);
  rt2800_rfcsr_write(rt2x00dev, 5, 0x10);
  rt2800_rfcsr_write(rt2x00dev, 6, 0xe0);
@@ -5101,7 +6607,6 @@ static void rt2800_init_rfcsr_5592(struct rt2x00_dev *rt2x00dev)
 
  rt2800_rfcsr_write(rt2x00dev, 1, 0x3F);
  rt2800_rfcsr_write(rt2x00dev, 3, 0x08);
- rt2800_rfcsr_write(rt2x00dev, 3, 0x08);
  rt2800_rfcsr_write(rt2x00dev, 5, 0x10);
  rt2800_rfcsr_write(rt2x00dev, 6, 0xE4);
  rt2800_rfcsr_write(rt2x00dev, 7, 0x00);
@@ -5164,6 +6669,9 @@ static void rt2800_init_rfcsr(struct rt2x00_dev *rt2x00dev)
  case RT3572:
   rt2800_init_rfcsr_3572(rt2x00dev);
   break;
+ case RT3593:
+  rt2800_init_rfcsr_3593(rt2x00dev);
+  break;
  case RT5390:
   rt2800_init_rfcsr_5390(rt2x00dev);
   break;
@@ -5182,17 +6690,20 @@ int rt2800_enable_radio(struct rt2x00_dev *rt2x00dev)
  u16 word;
 
  /*
-  * Initialize all registers.
+  * Initialize MAC registers.
   */
  if (unlikely(rt2800_wait_wpdma_ready(rt2x00dev) ||
        rt2800_init_registers(rt2x00dev)))
   return -EIO;
 
+ /*
+  * Wait BBP/RF to wake up.
+  */
  if (unlikely(rt2800_wait_bbp_rf_ready(rt2x00dev)))
   return -EIO;
 
  /*
-  * Send signal to firmware during boot time.
+  * Send signal during boot time to initialize firmware.
   */
  rt2800_register_write(rt2x00dev, H2M_BBP_AGENT, 0);
  rt2800_register_write(rt2x00dev, H2M_MAILBOX_CSR, 0);
@@ -5201,9 +6712,15 @@ int rt2800_enable_radio(struct rt2x00_dev *rt2x00dev)
  rt2800_mcu_request(rt2x00dev, MCU_BOOT_SIGNAL, 0, 0, 0);
  msleep(1);
 
+ /*
+  * Make sure BBP is up and running.
+  */
  if (unlikely(rt2800_wait_bbp_ready(rt2x00dev)))
   return -EIO;
 
+ /*
+  * Initialize BBP/RF registers.
+  */
  rt2800_init_bbp(rt2x00dev);
  rt2800_init_rfcsr(rt2x00dev);
 
@@ -5241,15 +6758,15 @@ int rt2800_enable_radio(struct rt2x00_dev *rt2x00dev)
  /*
   * Initialize LED control
   */
- rt2x00_eeprom_read(rt2x00dev, EEPROM_LED_AG_CONF, &word);
+ rt2800_eeprom_read(rt2x00dev, EEPROM_LED_AG_CONF, &word);
  rt2800_mcu_request(rt2x00dev, MCU_LED_AG_CONF, 0xff,
       word & 0xff, (word >> 8) & 0xff);
 
- rt2x00_eeprom_read(rt2x00dev, EEPROM_LED_ACT_CONF, &word);
+ rt2800_eeprom_read(rt2x00dev, EEPROM_LED_ACT_CONF, &word);
  rt2800_mcu_request(rt2x00dev, MCU_LED_ACT_CONF, 0xff,
       word & 0xff, (word >> 8) & 0xff);
 
- rt2x00_eeprom_read(rt2x00dev, EEPROM_LED_POLARITY, &word);
+ rt2800_eeprom_read(rt2x00dev, EEPROM_LED_POLARITY, &word);
  rt2800_mcu_request(rt2x00dev, MCU_LED_LED_POLARITY, 0xff,
       word & 0xff, (word >> 8) & 0xff);
 
@@ -5345,6 +6862,34 @@ int rt2800_read_eeprom_efuse(struct rt2x00_dev *rt2x00dev)
 }
 EXPORT_SYMBOL_GPL(rt2800_read_eeprom_efuse);
 
+static u8 rt2800_get_txmixer_gain_24g(struct rt2x00_dev *rt2x00dev)
+{
+ u16 word;
+
+ if (rt2x00_rt(rt2x00dev, RT3593))
+  return 0;
+
+ rt2800_eeprom_read(rt2x00dev, EEPROM_TXMIXER_GAIN_BG, &word);
+ if ((word & 0x00ff) != 0x00ff)
+  return rt2x00_get_field16(word, EEPROM_TXMIXER_GAIN_BG_VAL);
+
+ return 0;
+}
+
+static u8 rt2800_get_txmixer_gain_5g(struct rt2x00_dev *rt2x00dev)
+{
+ u16 word;
+
+ if (rt2x00_rt(rt2x00dev, RT3593))
+  return 0;
+
+ rt2800_eeprom_read(rt2x00dev, EEPROM_TXMIXER_GAIN_A, &word);
+ if ((word & 0x00ff) != 0x00ff)
+  return rt2x00_get_field16(word, EEPROM_TXMIXER_GAIN_A_VAL);
+
+ return 0;
+}
+
 static int rt2800_validate_eeprom(struct rt2x00_dev *rt2x00dev)
 {
  struct rt2800_drv_data *drv_data = rt2x00dev->drv_data;
@@ -5363,18 +6908,18 @@ static int rt2800_validate_eeprom(struct rt2x00_dev *rt2x00dev)
  /*
   * Start validation of the data that has been read.
   */
- mac = rt2x00_eeprom_addr(rt2x00dev, EEPROM_MAC_ADDR_0);
+ mac = rt2800_eeprom_addr(rt2x00dev, EEPROM_MAC_ADDR_0);
  if (!is_valid_ether_addr(mac)) {
   eth_random_addr(mac);
   rt2x00_eeprom_dbg(rt2x00dev, "MAC: %pM\n", mac);
  }
 
- rt2x00_eeprom_read(rt2x00dev, EEPROM_NIC_CONF0, &word);
+ rt2800_eeprom_read(rt2x00dev, EEPROM_NIC_CONF0, &word);
  if (word == 0xffff) {
   rt2x00_set_field16(&word, EEPROM_NIC_CONF0_RXPATH, 2);
   rt2x00_set_field16(&word, EEPROM_NIC_CONF0_TXPATH, 1);
   rt2x00_set_field16(&word, EEPROM_NIC_CONF0_RF_TYPE, RF2820);
-  rt2x00_eeprom_write(rt2x00dev, EEPROM_NIC_CONF0, word);
+  rt2800_eeprom_write(rt2x00dev, EEPROM_NIC_CONF0, word);
   rt2x00_eeprom_dbg(rt2x00dev, "Antenna: 0x%04x\n", word);
  } else if (rt2x00_rt(rt2x00dev, RT2860) ||
      rt2x00_rt(rt2x00dev, RT2872)) {
@@ -5383,10 +6928,10 @@ static int rt2800_validate_eeprom(struct rt2x00_dev *rt2x00dev)
    */
   if (rt2x00_get_field16(word, EEPROM_NIC_CONF0_RXPATH) > 2)
    rt2x00_set_field16(&word, EEPROM_NIC_CONF0_RXPATH, 2);
-  rt2x00_eeprom_write(rt2x00dev, EEPROM_NIC_CONF0, word);
+  rt2800_eeprom_write(rt2x00dev, EEPROM_NIC_CONF0, word);
  }
 
- rt2x00_eeprom_read(rt2x00dev, EEPROM_NIC_CONF1, &word);
+ rt2800_eeprom_read(rt2x00dev, EEPROM_NIC_CONF1, &word);
  if (word == 0xffff) {
   rt2x00_set_field16(&word, EEPROM_NIC_CONF1_HW_RADIO, 0);
   rt2x00_set_field16(&word, EEPROM_NIC_CONF1_EXTERNAL_TX_ALC, 0);
@@ -5403,24 +6948,24 @@ static int rt2800_validate_eeprom(struct rt2x00_dev *rt2x00dev)
   rt2x00_set_field16(&word, EEPROM_NIC_CONF1_INTERNAL_TX_ALC, 0);
   rt2x00_set_field16(&word, EEPROM_NIC_CONF1_BT_COEXIST, 0);
   rt2x00_set_field16(&word, EEPROM_NIC_CONF1_DAC_TEST, 0);
-  rt2x00_eeprom_write(rt2x00dev, EEPROM_NIC_CONF1, word);
+  rt2800_eeprom_write(rt2x00dev, EEPROM_NIC_CONF1, word);
   rt2x00_eeprom_dbg(rt2x00dev, "NIC: 0x%04x\n", word);
  }
 
- rt2x00_eeprom_read(rt2x00dev, EEPROM_FREQ, &word);
+ rt2800_eeprom_read(rt2x00dev, EEPROM_FREQ, &word);
  if ((word & 0x00ff) == 0x00ff) {
   rt2x00_set_field16(&word, EEPROM_FREQ_OFFSET, 0);
-  rt2x00_eeprom_write(rt2x00dev, EEPROM_FREQ, word);
+  rt2800_eeprom_write(rt2x00dev, EEPROM_FREQ, word);
   rt2x00_eeprom_dbg(rt2x00dev, "Freq: 0x%04x\n", word);
  }
  if ((word & 0xff00) == 0xff00) {
   rt2x00_set_field16(&word, EEPROM_FREQ_LED_MODE,
        LED_MODE_TXRX_ACTIVITY);
   rt2x00_set_field16(&word, EEPROM_FREQ_LED_POLARITY, 0);
-  rt2x00_eeprom_write(rt2x00dev, EEPROM_FREQ, word);
-  rt2x00_eeprom_write(rt2x00dev, EEPROM_LED_AG_CONF, 0x5555);
-  rt2x00_eeprom_write(rt2x00dev, EEPROM_LED_ACT_CONF, 0x2221);
-  rt2x00_eeprom_write(rt2x00dev, EEPROM_LED_POLARITY, 0xa9f8);
+  rt2800_eeprom_write(rt2x00dev, EEPROM_FREQ, word);
+  rt2800_eeprom_write(rt2x00dev, EEPROM_LED_AG_CONF, 0x5555);
+  rt2800_eeprom_write(rt2x00dev, EEPROM_LED_ACT_CONF, 0x2221);
+  rt2800_eeprom_write(rt2x00dev, EEPROM_LED_POLARITY, 0xa9f8);
   rt2x00_eeprom_dbg(rt2x00dev, "Led Mode: 0x%04x\n", word);
  }
 
@@ -5429,56 +6974,61 @@ static int rt2800_validate_eeprom(struct rt2x00_dev *rt2x00dev)
   * lna0 as correct value. Note that EEPROM_LNA
   * is never validated.
   */
- rt2x00_eeprom_read(rt2x00dev, EEPROM_LNA, &word);
+ rt2800_eeprom_read(rt2x00dev, EEPROM_LNA, &word);
  default_lna_gain = rt2x00_get_field16(word, EEPROM_LNA_A0);
 
- rt2x00_eeprom_read(rt2x00dev, EEPROM_RSSI_BG, &word);
+ rt2800_eeprom_read(rt2x00dev, EEPROM_RSSI_BG, &word);
  if (abs(rt2x00_get_field16(word, EEPROM_RSSI_BG_OFFSET0)) > 10)
   rt2x00_set_field16(&word, EEPROM_RSSI_BG_OFFSET0, 0);
  if (abs(rt2x00_get_field16(word, EEPROM_RSSI_BG_OFFSET1)) > 10)
   rt2x00_set_field16(&word, EEPROM_RSSI_BG_OFFSET1, 0);
- rt2x00_eeprom_write(rt2x00dev, EEPROM_RSSI_BG, word);
+ rt2800_eeprom_write(rt2x00dev, EEPROM_RSSI_BG, word);
 
- rt2x00_eeprom_read(rt2x00dev, EEPROM_TXMIXER_GAIN_BG, &word);
- if ((word & 0x00ff) != 0x00ff) {
-  drv_data->txmixer_gain_24g =
-   rt2x00_get_field16(word, EEPROM_TXMIXER_GAIN_BG_VAL);
- } else {
-  drv_data->txmixer_gain_24g = 0;
- }
+ drv_data->txmixer_gain_24g = rt2800_get_txmixer_gain_24g(rt2x00dev);
 
- rt2x00_eeprom_read(rt2x00dev, EEPROM_RSSI_BG2, &word);
+ rt2800_eeprom_read(rt2x00dev, EEPROM_RSSI_BG2, &word);
  if (abs(rt2x00_get_field16(word, EEPROM_RSSI_BG2_OFFSET2)) > 10)
   rt2x00_set_field16(&word, EEPROM_RSSI_BG2_OFFSET2, 0);
- if (rt2x00_get_field16(word, EEPROM_RSSI_BG2_LNA_A1) == 0x00 ||
-     rt2x00_get_field16(word, EEPROM_RSSI_BG2_LNA_A1) == 0xff)
-  rt2x00_set_field16(&word, EEPROM_RSSI_BG2_LNA_A1,
-       default_lna_gain);
- rt2x00_eeprom_write(rt2x00dev, EEPROM_RSSI_BG2, word);
-
- rt2x00_eeprom_read(rt2x00dev, EEPROM_TXMIXER_GAIN_A, &word);
- if ((word & 0x00ff) != 0x00ff) {
-  drv_data->txmixer_gain_5g =
-   rt2x00_get_field16(word, EEPROM_TXMIXER_GAIN_A_VAL);
- } else {
-  drv_data->txmixer_gain_5g = 0;
+ if (!rt2x00_rt(rt2x00dev, RT3593)) {
+  if (rt2x00_get_field16(word, EEPROM_RSSI_BG2_LNA_A1) == 0x00 ||
+      rt2x00_get_field16(word, EEPROM_RSSI_BG2_LNA_A1) == 0xff)
+   rt2x00_set_field16(&word, EEPROM_RSSI_BG2_LNA_A1,
+        default_lna_gain);
  }
+ rt2800_eeprom_write(rt2x00dev, EEPROM_RSSI_BG2, word);
+
+ drv_data->txmixer_gain_5g = rt2800_get_txmixer_gain_5g(rt2x00dev);
 
- rt2x00_eeprom_read(rt2x00dev, EEPROM_RSSI_A, &word);
+ rt2800_eeprom_read(rt2x00dev, EEPROM_RSSI_A, &word);
  if (abs(rt2x00_get_field16(word, EEPROM_RSSI_A_OFFSET0)) > 10)
   rt2x00_set_field16(&word, EEPROM_RSSI_A_OFFSET0, 0);
  if (abs(rt2x00_get_field16(word, EEPROM_RSSI_A_OFFSET1)) > 10)
   rt2x00_set_field16(&word, EEPROM_RSSI_A_OFFSET1, 0);
- rt2x00_eeprom_write(rt2x00dev, EEPROM_RSSI_A, word);
+ rt2800_eeprom_write(rt2x00dev, EEPROM_RSSI_A, word);
 
- rt2x00_eeprom_read(rt2x00dev, EEPROM_RSSI_A2, &word);
+ rt2800_eeprom_read(rt2x00dev, EEPROM_RSSI_A2, &word);
  if (abs(rt2x00_get_field16(word, EEPROM_RSSI_A2_OFFSET2)) > 10)
   rt2x00_set_field16(&word, EEPROM_RSSI_A2_OFFSET2, 0);
- if (rt2x00_get_field16(word, EEPROM_RSSI_A2_LNA_A2) == 0x00 ||
-     rt2x00_get_field16(word, EEPROM_RSSI_A2_LNA_A2) == 0xff)
-  rt2x00_set_field16(&word, EEPROM_RSSI_A2_LNA_A2,
-       default_lna_gain);
- rt2x00_eeprom_write(rt2x00dev, EEPROM_RSSI_A2, word);
+ if (!rt2x00_rt(rt2x00dev, RT3593)) {
+  if (rt2x00_get_field16(word, EEPROM_RSSI_A2_LNA_A2) == 0x00 ||
+      rt2x00_get_field16(word, EEPROM_RSSI_A2_LNA_A2) == 0xff)
+   rt2x00_set_field16(&word, EEPROM_RSSI_A2_LNA_A2,
+        default_lna_gain);
+ }
+ rt2800_eeprom_write(rt2x00dev, EEPROM_RSSI_A2, word);
+
+ if (rt2x00_rt(rt2x00dev, RT3593)) {
+  rt2800_eeprom_read(rt2x00dev, EEPROM_EXT_LNA2, &word);
+  if (rt2x00_get_field16(word, EEPROM_EXT_LNA2_A1) == 0x00 ||
+      rt2x00_get_field16(word, EEPROM_EXT_LNA2_A1) == 0xff)
+   rt2x00_set_field16(&word, EEPROM_EXT_LNA2_A1,
+        default_lna_gain);
+  if (rt2x00_get_field16(word, EEPROM_EXT_LNA2_A2) == 0x00 ||
+      rt2x00_get_field16(word, EEPROM_EXT_LNA2_A2) == 0xff)
+   rt2x00_set_field16(&word, EEPROM_EXT_LNA2_A1,
+        default_lna_gain);
+  rt2800_eeprom_write(rt2x00dev, EEPROM_EXT_LNA2, word);
+ }
 
  return 0;
 }
@@ -5492,7 +7042,7 @@ static int rt2800_init_eeprom(struct rt2x00_dev *rt2x00dev)
  /*
   * Read EEPROM word for configuration.
   */
- rt2x00_eeprom_read(rt2x00dev, EEPROM_NIC_CONF0, &eeprom);
+ rt2800_eeprom_read(rt2x00dev, EEPROM_NIC_CONF0, &eeprom);
 
  /*
   * Identify RF chipset by EEPROM value
@@ -5502,7 +7052,7 @@ static int rt2800_init_eeprom(struct rt2x00_dev *rt2x00dev)
  if (rt2x00_rt(rt2x00dev, RT3290) ||
      rt2x00_rt(rt2x00dev, RT5390) ||
      rt2x00_rt(rt2x00dev, RT5392))
-  rt2x00_eeprom_read(rt2x00dev, EEPROM_CHIP_ID, &rf);
+  rt2800_eeprom_read(rt2x00dev, EEPROM_CHIP_ID, &rf);
  else
   rf = rt2x00_get_field16(eeprom, EEPROM_NIC_CONF0_RF_TYPE);
 
@@ -5516,6 +7066,8 @@ static int rt2800_init_eeprom(struct rt2x00_dev *rt2x00dev)
  case RF3021:
  case RF3022:
  case RF3052:
+ case RF3053:
+ case RF3070:
  case RF3290:
  case RF3320:
  case RF3322:
@@ -5542,7 +7094,7 @@ static int rt2800_init_eeprom(struct rt2x00_dev *rt2x00dev)
  rt2x00dev->default_ant.rx_chain_num =
      rt2x00_get_field16(eeprom, EEPROM_NIC_CONF0_RXPATH);
 
- rt2x00_eeprom_read(rt2x00dev, EEPROM_NIC_CONF1, &eeprom);
+ rt2800_eeprom_read(rt2x00dev, EEPROM_NIC_CONF1, &eeprom);
 
  if (rt2x00_rt(rt2x00dev, RT3070) ||
      rt2x00_rt(rt2x00dev, RT3090) ||
@@ -5595,7 +7147,7 @@ static int rt2800_init_eeprom(struct rt2x00_dev *rt2x00dev)
  /*
   * Read frequency offset and RF programming sequence.
   */
- rt2x00_eeprom_read(rt2x00dev, EEPROM_FREQ, &eeprom);
+ rt2800_eeprom_read(rt2x00dev, EEPROM_FREQ, &eeprom);
  rt2x00dev->freq_offset = rt2x00_get_field16(eeprom, EEPROM_FREQ_OFFSET);
 
  /*
@@ -5612,7 +7164,7 @@ static int rt2800_init_eeprom(struct rt2x00_dev *rt2x00dev)
  /*
   * Check if support EIRP tx power limit feature.
   */
- rt2x00_eeprom_read(rt2x00dev, EEPROM_EIRP_MAX_TX_POWER, &eeprom);
+ rt2800_eeprom_read(rt2x00dev, EEPROM_EIRP_MAX_TX_POWER, &eeprom);
 
  if (rt2x00_get_field16(eeprom, EEPROM_EIRP_MAX_TX_POWER_2GHZ) <
      EIRP_MAX_TX_POWER_LIMIT)
@@ -5698,7 +7250,7 @@ static const struct rf_channel rf_vals[] = {
 
 /*
  * RF value list for rt3xxx
- * Supports: 2.4 GHz (all) & 5.2 GHz (RF3052)
+ * Supports: 2.4 GHz (all) & 5.2 GHz (RF3052 & RF3053)
  */
 static const struct rf_channel rf_vals_3x[] = {
  {1,  241, 2, 2 },
@@ -5900,15 +7452,14 @@ static int rt2800_probe_hw_mode(struct rt2x00_dev *rt2x00dev)
  struct channel_info *info;
  char *default_power1;
  char *default_power2;
+ char *default_power3;
  unsigned int i;
- u16 eeprom;
  u32 reg;
 
  /*
-  * Disable powersaving as default on PCI devices.
+  * Disable powersaving as default.
   */
- if (rt2x00_is_pci(rt2x00dev) || rt2x00_is_soc(rt2x00dev))
-  rt2x00dev->hw->wiphy->flags &= ~WIPHY_FLAG_PS_ON_BY_DEFAULT;
+ rt2x00dev->hw->wiphy->flags &= ~WIPHY_FLAG_PS_ON_BY_DEFAULT;
 
  /*
   * Initialize all hw fields.
@@ -5934,7 +7485,7 @@ static int rt2800_probe_hw_mode(struct rt2x00_dev *rt2x00dev)
 
  SET_IEEE80211_DEV(rt2x00dev->hw, rt2x00dev->dev);
  SET_IEEE80211_PERM_ADDR(rt2x00dev->hw,
-    rt2x00_eeprom_addr(rt2x00dev,
+    rt2800_eeprom_addr(rt2x00dev,
          EEPROM_MAC_ADDR_0));
 
  /*
@@ -5950,44 +7501,48 @@ static int rt2800_probe_hw_mode(struct rt2x00_dev *rt2x00dev)
  rt2x00dev->hw->max_report_rates = 7;
  rt2x00dev->hw->max_rate_tries = 1;
 
- rt2x00_eeprom_read(rt2x00dev, EEPROM_NIC_CONF0, &eeprom);
-
  /*
   * Initialize hw_mode information.
   */
- spec->supported_bands = SUPPORT_BAND_2GHZ;
  spec->supported_rates = SUPPORT_RATE_CCK | SUPPORT_RATE_OFDM;
 
- if (rt2x00_rf(rt2x00dev, RF2820) ||
-     rt2x00_rf(rt2x00dev, RF2720)) {
+ switch (rt2x00dev->chip.rf) {
+ case RF2720:
+ case RF2820:
   spec->num_channels = 14;
   spec->channels = rf_vals;
- } else if (rt2x00_rf(rt2x00dev, RF2850) ||
-     rt2x00_rf(rt2x00dev, RF2750)) {
-  spec->supported_bands |= SUPPORT_BAND_5GHZ;
+  break;
+
+ case RF2750:
+ case RF2850:
   spec->num_channels = ARRAY_SIZE(rf_vals);
   spec->channels = rf_vals;
- } else if (rt2x00_rf(rt2x00dev, RF3020) ||
-     rt2x00_rf(rt2x00dev, RF2020) ||
-     rt2x00_rf(rt2x00dev, RF3021) ||
-     rt2x00_rf(rt2x00dev, RF3022) ||
-     rt2x00_rf(rt2x00dev, RF3290) ||
-     rt2x00_rf(rt2x00dev, RF3320) ||
-     rt2x00_rf(rt2x00dev, RF3322) ||
-     rt2x00_rf(rt2x00dev, RF5360) ||
-     rt2x00_rf(rt2x00dev, RF5370) ||
-     rt2x00_rf(rt2x00dev, RF5372) ||
-     rt2x00_rf(rt2x00dev, RF5390) ||
-     rt2x00_rf(rt2x00dev, RF5392)) {
+  break;
+
+ case RF2020:
+ case RF3020:
+ case RF3021:
+ case RF3022:
+ case RF3070:
+ case RF3290:
+ case RF3320:
+ case RF3322:
+ case RF5360:
+ case RF5370:
+ case RF5372:
+ case RF5390:
+ case RF5392:
   spec->num_channels = 14;
   spec->channels = rf_vals_3x;
- } else if (rt2x00_rf(rt2x00dev, RF3052)) {
-  spec->supported_bands |= SUPPORT_BAND_5GHZ;
+  break;
+
+ case RF3052:
+ case RF3053:
   spec->num_channels = ARRAY_SIZE(rf_vals_3x);
   spec->channels = rf_vals_3x;
- } else if (rt2x00_rf(rt2x00dev, RF5592)) {
-  spec->supported_bands |= SUPPORT_BAND_5GHZ;
+  break;
 
+ case RF5592:
   rt2800_register_read(rt2x00dev, MAC_DEBUG_INDEX, &reg);
   if (rt2x00_get_field32(reg, MAC_DEBUG_INDEX_XTAL)) {
    spec->num_channels = ARRAY_SIZE(rf_vals_5592_xtal40);
@@ -5996,11 +7551,16 @@ static int rt2800_probe_hw_mode(struct rt2x00_dev *rt2x00dev)
    spec->num_channels = ARRAY_SIZE(rf_vals_5592_xtal20);
    spec->channels = rf_vals_5592_xtal20;
   }
+  break;
  }
 
  if (WARN_ON_ONCE(!spec->channels))
   return -ENODEV;
 
+ spec->supported_bands = SUPPORT_BAND_2GHZ;
+ if (spec->num_channels > 14)
+  spec->supported_bands |= SUPPORT_BAND_5GHZ;
+
  /*
   * Initialize HT information.
   */
@@ -6015,22 +7575,21 @@ static int rt2800_probe_hw_mode(struct rt2x00_dev *rt2x00dev)
      IEEE80211_HT_CAP_SGI_20 |
      IEEE80211_HT_CAP_SGI_40;
 
- if (rt2x00_get_field16(eeprom, EEPROM_NIC_CONF0_TXPATH) >= 2)
+ if (rt2x00dev->default_ant.tx_chain_num >= 2)
   spec->ht.cap |= IEEE80211_HT_CAP_TX_STBC;
 
- spec->ht.cap |=
-     rt2x00_get_field16(eeprom, EEPROM_NIC_CONF0_RXPATH) <<
-  IEEE80211_HT_CAP_RX_STBC_SHIFT;
+ spec->ht.cap |= rt2x00dev->default_ant.rx_chain_num <<
+   IEEE80211_HT_CAP_RX_STBC_SHIFT;
 
  spec->ht.ampdu_factor = 3;
  spec->ht.ampdu_density = 4;
  spec->ht.mcs.tx_params =
      IEEE80211_HT_MCS_TX_DEFINED |
      IEEE80211_HT_MCS_TX_RX_DIFF |
-     ((rt2x00_get_field16(eeprom, EEPROM_NIC_CONF0_TXPATH) - 1) <<
-  IEEE80211_HT_MCS_TX_MAX_STREAMS_SHIFT);
+     ((rt2x00dev->default_ant.tx_chain_num - 1) <<
+      IEEE80211_HT_MCS_TX_MAX_STREAMS_SHIFT);
 
- switch (rt2x00_get_field16(eeprom, EEPROM_NIC_CONF0_RXPATH)) {
+ switch (rt2x00dev->default_ant.rx_chain_num) {
  case 3:
   spec->ht.mcs.rx_mask[2] = 0xff;
  case 2:
@@ -6050,21 +7609,40 @@ static int rt2800_probe_hw_mode(struct rt2x00_dev *rt2x00dev)
 
  spec->channels_info = info;
 
- default_power1 = rt2x00_eeprom_addr(rt2x00dev, EEPROM_TXPOWER_BG1);
- default_power2 = rt2x00_eeprom_addr(rt2x00dev, EEPROM_TXPOWER_BG2);
+ default_power1 = rt2800_eeprom_addr(rt2x00dev, EEPROM_TXPOWER_BG1);
+ default_power2 = rt2800_eeprom_addr(rt2x00dev, EEPROM_TXPOWER_BG2);
+
+ if (rt2x00dev->default_ant.tx_chain_num > 2)
+  default_power3 = rt2800_eeprom_addr(rt2x00dev,
+          EEPROM_EXT_TXPOWER_BG3);
+ else
+  default_power3 = NULL;
 
  for (i = 0; i < 14; i++) {
   info[i].default_power1 = default_power1[i];
   info[i].default_power2 = default_power2[i];
+  if (default_power3)
+   info[i].default_power3 = default_power3[i];
  }
 
  if (spec->num_channels > 14) {
-  default_power1 = rt2x00_eeprom_addr(rt2x00dev, EEPROM_TXPOWER_A1);
-  default_power2 = rt2x00_eeprom_addr(rt2x00dev, EEPROM_TXPOWER_A2);
+  default_power1 = rt2800_eeprom_addr(rt2x00dev,
+          EEPROM_TXPOWER_A1);
+  default_power2 = rt2800_eeprom_addr(rt2x00dev,
+          EEPROM_TXPOWER_A2);
+
+  if (rt2x00dev->default_ant.tx_chain_num > 2)
+   default_power3 =
+    rt2800_eeprom_addr(rt2x00dev,
+         EEPROM_EXT_TXPOWER_A3);
+  else
+   default_power3 = NULL;
 
   for (i = 14; i < spec->num_channels; i++) {
    info[i].default_power1 = default_power1[i - 14];
    info[i].default_power2 = default_power2[i - 14];
+   if (default_power3)
+    info[i].default_power3 = default_power3[i - 14];
   }
  }
 
@@ -6075,6 +7653,8 @@ static int rt2800_probe_hw_mode(struct rt2x00_dev *rt2x00dev)
  case RF3022:
  case RF3320:
  case RF3052:
+ case RF3053:
+ case RF3070:
  case RF3290:
  case RF5360:
  case RF5370:
@@ -6113,6 +7693,7 @@ static int rt2800_probe_rt(struct rt2x00_dev *rt2x00dev)
  case RT3352:
  case RT3390:
  case RT3572:
+ case RT3593:
  case RT5390:
  case RT5392:
  case RT5592:
diff --git a/drivers/net/wireless/rt2x00/rt2800lib.h b/drivers/net/wireless/rt2x00/rt2800lib.h
index 6ec7394..3019db6 100644
--- a/drivers/net/wireless/rt2x00/rt2800lib.h
+++ b/drivers/net/wireless/rt2x00/rt2800lib.h
@@ -14,9 +14,7 @@
  GNU General Public License for more details.
 
  You should have received a copy of the GNU General Public License
- along with this program; if not, write to the
- Free Software Foundation, Inc.,
- 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ along with this program; if not, see <http://www.gnu.org/licenses/>.
  */
 
 #ifndef RT2800LIB_H
@@ -226,4 +224,8 @@ int rt2800_get_survey(struct ieee80211_hw *hw, int idx,
         struct survey_info *survey);
 void rt2800_disable_wpdma(struct rt2x00_dev *rt2x00dev);
 
+void rt2800_get_txwi_rxwi_size(struct rt2x00_dev *rt2x00dev,
+          unsigned short *txwi_size,
+          unsigned short *rxwi_size);
+
 #endif /* RT2800LIB_H */
diff --git a/drivers/net/wireless/rt2x00/rt2800mmio.c b/drivers/net/wireless/rt2x00/rt2800mmio.c
new file mode 100644
index 0000000..f96e572
--- /dev/null
+++ b/drivers/net/wireless/rt2x00/rt2800mmio.c
@@ -0,0 +1,871 @@
+/* Copyright (C) 2009 - 2010 Ivo van Doorn <IvDoorn@gmail.com>
+ * Copyright (C) 2009 Alban Browaeys <prahal@yahoo.com>
+ * Copyright (C) 2009 Felix Fietkau <nbd@openwrt.org>
+ * Copyright (C) 2009 Luis Correia <luis.f.correia@gmail.com>
+ * Copyright (C) 2009 Mattias Nissler <mattias.nissler@gmx.de>
+ * Copyright (C) 2009 Mark Asselstine <asselsm@gmail.com>
+ * Copyright (C) 2009 Xose Vazquez Perez <xose.vazquez@gmail.com>
+ * Copyright (C) 2009 Bart Zolnierkiewicz <bzolnier@gmail.com>
+ * <http://rt2x00.serialmonkey.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+/* Module: rt2800mmio
+ * Abstract: rt2800 MMIO device routines.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/export.h>
+
+#include "rt2x00.h"
+#include "rt2x00mmio.h"
+#include "rt2800.h"
+#include "rt2800lib.h"
+#include "rt2800mmio.h"
+
+/*
+ * TX descriptor initialization
+ */
+__le32 *rt2800mmio_get_txwi(struct queue_entry *entry)
+{
+ return (__le32 *) entry->skb->data;
+}
+EXPORT_SYMBOL_GPL(rt2800mmio_get_txwi);
+
+void rt2800mmio_write_tx_desc(struct queue_entry *entry,
+         struct txentry_desc *txdesc)
+{
+ struct skb_frame_desc *skbdesc = get_skb_frame_desc(entry->skb);
+ struct queue_entry_priv_mmio *entry_priv = entry->priv_data;
+ __le32 *txd = entry_priv->desc;
+ u32 word;
+ const unsigned int txwi_size = entry->queue->winfo_size;
+
+ /*
+  * The buffers pointed by SD_PTR0/SD_LEN0 and SD_PTR1/SD_LEN1
+  * must contains a TXWI structure + 802.11 header + padding + 802.11
+  * data. We choose to have SD_PTR0/SD_LEN0 only contains TXWI and
+  * SD_PTR1/SD_LEN1 contains 802.11 header + padding + 802.11
+  * data. It means that LAST_SEC0 is always 0.
+  */
+
+ /*
+  * Initialize TX descriptor
+  */
+ word = 0;
+ rt2x00_set_field32(&word, TXD_W0_SD_PTR0, skbdesc->skb_dma);
+ rt2x00_desc_write(txd, 0, word);
+
+ word = 0;
+ rt2x00_set_field32(&word, TXD_W1_SD_LEN1, entry->skb->len);
+ rt2x00_set_field32(&word, TXD_W1_LAST_SEC1,
+      !test_bit(ENTRY_TXD_MORE_FRAG, &txdesc->flags));
+ rt2x00_set_field32(&word, TXD_W1_BURST,
+      test_bit(ENTRY_TXD_BURST, &txdesc->flags));
+ rt2x00_set_field32(&word, TXD_W1_SD_LEN0, txwi_size);
+ rt2x00_set_field32(&word, TXD_W1_LAST_SEC0, 0);
+ rt2x00_set_field32(&word, TXD_W1_DMA_DONE, 0);
+ rt2x00_desc_write(txd, 1, word);
+
+ word = 0;
+ rt2x00_set_field32(&word, TXD_W2_SD_PTR1,
+      skbdesc->skb_dma + txwi_size);
+ rt2x00_desc_write(txd, 2, word);
+
+ word = 0;
+ rt2x00_set_field32(&word, TXD_W3_WIV,
+      !test_bit(ENTRY_TXD_ENCRYPT_IV, &txdesc->flags));
+ rt2x00_set_field32(&word, TXD_W3_QSEL, 2);
+ rt2x00_desc_write(txd, 3, word);
+
+ /*
+  * Register descriptor details in skb frame descriptor.
+  */
+ skbdesc->desc = txd;
+ skbdesc->desc_len = TXD_DESC_SIZE;
+}
+EXPORT_SYMBOL_GPL(rt2800mmio_write_tx_desc);
+
+/*
+ * RX control handlers
+ */
+void rt2800mmio_fill_rxdone(struct queue_entry *entry,
+       struct rxdone_entry_desc *rxdesc)
+{
+ struct queue_entry_priv_mmio *entry_priv = entry->priv_data;
+ __le32 *rxd = entry_priv->desc;
+ u32 word;
+
+ rt2x00_desc_read(rxd, 3, &word);
+
+ if (rt2x00_get_field32(word, RXD_W3_CRC_ERROR))
+  rxdesc->flags |= RX_FLAG_FAILED_FCS_CRC;
+
+ /*
+  * Unfortunately we don't know the cipher type used during
+  * decryption. This prevents us from correct providing
+  * correct statistics through debugfs.
+  */
+ rxdesc->cipher_status = rt2x00_get_field32(word, RXD_W3_CIPHER_ERROR);
+
+ if (rt2x00_get_field32(word, RXD_W3_DECRYPTED)) {
+  /*
+   * Hardware has stripped IV/EIV data from 802.11 frame during
+   * decryption. Unfortunately the descriptor doesn't contain
+   * any fields with the EIV/IV data either, so they can't
+   * be restored by rt2x00lib.
+   */
+  rxdesc->flags |= RX_FLAG_IV_STRIPPED;
+
+  /*
+   * The hardware has already checked the Michael Mic and has
+   * stripped it from the frame. Signal this to mac80211.
+   */
+  rxdesc->flags |= RX_FLAG_MMIC_STRIPPED;
+
+  if (rxdesc->cipher_status == RX_CRYPTO_SUCCESS)
+   rxdesc->flags |= RX_FLAG_DECRYPTED;
+  else if (rxdesc->cipher_status == RX_CRYPTO_FAIL_MIC)
+   rxdesc->flags |= RX_FLAG_MMIC_ERROR;
+ }
+
+ if (rt2x00_get_field32(word, RXD_W3_MY_BSS))
+  rxdesc->dev_flags |= RXDONE_MY_BSS;
+
+ if (rt2x00_get_field32(word, RXD_W3_L2PAD))
+  rxdesc->dev_flags |= RXDONE_L2PAD;
+
+ /*
+  * Process the RXWI structure that is at the start of the buffer.
+  */
+ rt2800_process_rxwi(entry, rxdesc);
+}
+EXPORT_SYMBOL_GPL(rt2800mmio_fill_rxdone);
+
+/*
+ * Interrupt functions.
+ */
+static void rt2800mmio_wakeup(struct rt2x00_dev *rt2x00dev)
+{
+ struct ieee80211_conf conf = { .flags = 0 };
+ struct rt2x00lib_conf libconf = { .conf = &conf };
+
+ rt2800_config(rt2x00dev, &libconf, IEEE80211_CONF_CHANGE_PS);
+}
+
+static bool rt2800mmio_txdone_entry_check(struct queue_entry *entry, u32 status)
+{
+ __le32 *txwi;
+ u32 word;
+ int wcid, tx_wcid;
+
+ wcid = rt2x00_get_field32(status, TX_STA_FIFO_WCID);
+
+ txwi = rt2800_drv_get_txwi(entry);
+ rt2x00_desc_read(txwi, 1, &word);
+ tx_wcid = rt2x00_get_field32(word, TXWI_W1_WIRELESS_CLI_ID);
+
+ return (tx_wcid == wcid);
+}
+
+static bool rt2800mmio_txdone_find_entry(struct queue_entry *entry, void *data)
+{
+ u32 status = *(u32 *)data;
+
+ /*
+  * rt2800pci hardware might reorder frames when exchanging traffic
+  * with multiple BA enabled STAs.
+  *
+  * For example, a tx queue
+  *    [ STA1 | STA2 | STA1 | STA2 ]
+  * can result in tx status reports
+  *    [ STA1 | STA1 | STA2 | STA2 ]
+  * when the hw decides to aggregate the frames for STA1 into one AMPDU.
+  *
+  * To mitigate this effect, associate the tx status to the first frame
+  * in the tx queue with a matching wcid.
+  */
+ if (rt2800mmio_txdone_entry_check(entry, status) &&
+     !test_bit(ENTRY_DATA_STATUS_SET, &entry->flags)) {
+  /*
+   * Got a matching frame, associate the tx status with
+   * the frame
+   */
+  entry->status = status;
+  set_bit(ENTRY_DATA_STATUS_SET, &entry->flags);
+  return true;
+ }
+
+ /* Check the next frame */
+ return false;
+}
+
+static bool rt2800mmio_txdone_match_first(struct queue_entry *entry, void *data)
+{
+ u32 status = *(u32 *)data;
+
+ /*
+  * Find the first frame without tx status and assign this status to it
+  * regardless if it matches or not.
+  */
+ if (!test_bit(ENTRY_DATA_STATUS_SET, &entry->flags)) {
+  /*
+   * Got a matching frame, associate the tx status with
+   * the frame
+   */
+  entry->status = status;
+  set_bit(ENTRY_DATA_STATUS_SET, &entry->flags);
+  return true;
+ }
+
+ /* Check the next frame */
+ return false;
+}
+static bool rt2800mmio_txdone_release_entries(struct queue_entry *entry,
+           void *data)
+{
+ if (test_bit(ENTRY_DATA_STATUS_SET, &entry->flags)) {
+  rt2800_txdone_entry(entry, entry->status,
+        rt2800mmio_get_txwi(entry));
+  return false;
+ }
+
+ /* No more frames to release */
+ return true;
+}
+
+static bool rt2800mmio_txdone(struct rt2x00_dev *rt2x00dev)
+{
+ struct data_queue *queue;
+ u32 status;
+ u8 qid;
+ int max_tx_done = 16;
+
+ while (kfifo_get(&rt2x00dev->txstatus_fifo, &status)) {
+  qid = rt2x00_get_field32(status, TX_STA_FIFO_PID_QUEUE);
+  if (unlikely(qid >= QID_RX)) {
+   /*
+    * Unknown queue, this shouldn't happen. Just drop
+    * this tx status.
+    */
+   rt2x00_warn(rt2x00dev, "Got TX status report with unexpected pid %u, dropping\n",
+        qid);
+   break;
+  }
+
+  queue = rt2x00queue_get_tx_queue(rt2x00dev, qid);
+  if (unlikely(queue == NULL)) {
+   /*
+    * The queue is NULL, this shouldn't happen. Stop
+    * processing here and drop the tx status
+    */
+   rt2x00_warn(rt2x00dev, "Got TX status for an unavailable queue %u, dropping\n",
+        qid);
+   break;
+  }
+
+  if (unlikely(rt2x00queue_empty(queue))) {
+   /*
+    * The queue is empty. Stop processing here
+    * and drop the tx status.
+    */
+   rt2x00_warn(rt2x00dev, "Got TX status for an empty queue %u, dropping\n",
+        qid);
+   break;
+  }
+
+  /*
+   * Let's associate this tx status with the first
+   * matching frame.
+   */
+  if (!rt2x00queue_for_each_entry(queue, Q_INDEX_DONE,
+      Q_INDEX, &status,
+      rt2800mmio_txdone_find_entry)) {
+   /*
+    * We cannot match the tx status to any frame, so just
+    * use the first one.
+    */
+   if (!rt2x00queue_for_each_entry(queue, Q_INDEX_DONE,
+       Q_INDEX, &status,
+       rt2800mmio_txdone_match_first)) {
+    rt2x00_warn(rt2x00dev, "No frame found for TX status on queue %u, dropping\n",
+         qid);
+    break;
+   }
+  }
+
+  /*
+   * Release all frames with a valid tx status.
+   */
+  rt2x00queue_for_each_entry(queue, Q_INDEX_DONE,
+        Q_INDEX, NULL,
+        rt2800mmio_txdone_release_entries);
+
+  if (--max_tx_done == 0)
+   break;
+ }
+
+ return !max_tx_done;
+}
+
+static inline void rt2800mmio_enable_interrupt(struct rt2x00_dev *rt2x00dev,
+            struct rt2x00_field32 irq_field)
+{
+ u32 reg;
+
+ /*
+  * Enable a single interrupt. The interrupt mask register
+  * access needs locking.
+  */
+ spin_lock_irq(&rt2x00dev->irqmask_lock);
+ rt2x00mmio_register_read(rt2x00dev, INT_MASK_CSR, &reg);
+ rt2x00_set_field32(&reg, irq_field, 1);
+ rt2x00mmio_register_write(rt2x00dev, INT_MASK_CSR, reg);
+ spin_unlock_irq(&rt2x00dev->irqmask_lock);
+}
+
+void rt2800mmio_txstatus_tasklet(unsigned long data)
+{
+ struct rt2x00_dev *rt2x00dev = (struct rt2x00_dev *)data;
+ if (rt2800mmio_txdone(rt2x00dev))
+  tasklet_schedule(&rt2x00dev->txstatus_tasklet);
+
+ /*
+  * No need to enable the tx status interrupt here as we always
+  * leave it enabled to minimize the possibility of a tx status
+  * register overflow. See comment in interrupt handler.
+  */
+}
+EXPORT_SYMBOL_GPL(rt2800mmio_txstatus_tasklet);
+
+void rt2800mmio_pretbtt_tasklet(unsigned long data)
+{
+ struct rt2x00_dev *rt2x00dev = (struct rt2x00_dev *)data;
+ rt2x00lib_pretbtt(rt2x00dev);
+ if (test_bit(DEVICE_STATE_ENABLED_RADIO, &rt2x00dev->flags))
+  rt2800mmio_enable_interrupt(rt2x00dev, INT_MASK_CSR_PRE_TBTT);
+}
+EXPORT_SYMBOL_GPL(rt2800mmio_pretbtt_tasklet);
+
+void rt2800mmio_tbtt_tasklet(unsigned long data)
+{
+ struct rt2x00_dev *rt2x00dev = (struct rt2x00_dev *)data;
+ struct rt2800_drv_data *drv_data = rt2x00dev->drv_data;
+ u32 reg;
+
+ rt2x00lib_beacondone(rt2x00dev);
+
+ if (rt2x00dev->intf_ap_count) {
+  /*
+   * The rt2800pci hardware tbtt timer is off by 1us per tbtt
+   * causing beacon skew and as a result causing problems with
+   * some powersaving clients over time. Shorten the beacon
+   * interval every 64 beacons by 64us to mitigate this effect.
+   */
+  if (drv_data->tbtt_tick == (BCN_TBTT_OFFSET - 2)) {
+   rt2x00mmio_register_read(rt2x00dev, BCN_TIME_CFG, &reg);
+   rt2x00_set_field32(&reg, BCN_TIME_CFG_BEACON_INTERVAL,
+        (rt2x00dev->beacon_int * 16) - 1);
+   rt2x00mmio_register_write(rt2x00dev, BCN_TIME_CFG, reg);
+  } else if (drv_data->tbtt_tick == (BCN_TBTT_OFFSET - 1)) {
+   rt2x00mmio_register_read(rt2x00dev, BCN_TIME_CFG, &reg);
+   rt2x00_set_field32(&reg, BCN_TIME_CFG_BEACON_INTERVAL,
+        (rt2x00dev->beacon_int * 16));
+   rt2x00mmio_register_write(rt2x00dev, BCN_TIME_CFG, reg);
+  }
+  drv_data->tbtt_tick++;
+  drv_data->tbtt_tick %= BCN_TBTT_OFFSET;
+ }
+
+ if (test_bit(DEVICE_STATE_ENABLED_RADIO, &rt2x00dev->flags))
+  rt2800mmio_enable_interrupt(rt2x00dev, INT_MASK_CSR_TBTT);
+}
+EXPORT_SYMBOL_GPL(rt2800mmio_tbtt_tasklet);
+
+void rt2800mmio_rxdone_tasklet(unsigned long data)
+{
+ struct rt2x00_dev *rt2x00dev = (struct rt2x00_dev *)data;
+ if (rt2x00mmio_rxdone(rt2x00dev))
+  tasklet_schedule(&rt2x00dev->rxdone_tasklet);
+ else if (test_bit(DEVICE_STATE_ENABLED_RADIO, &rt2x00dev->flags))
+  rt2800mmio_enable_interrupt(rt2x00dev, INT_MASK_CSR_RX_DONE);
+}
+EXPORT_SYMBOL_GPL(rt2800mmio_rxdone_tasklet);
+
+void rt2800mmio_autowake_tasklet(unsigned long data)
+{
+ struct rt2x00_dev *rt2x00dev = (struct rt2x00_dev *)data;
+ rt2800mmio_wakeup(rt2x00dev);
+ if (test_bit(DEVICE_STATE_ENABLED_RADIO, &rt2x00dev->flags))
+  rt2800mmio_enable_interrupt(rt2x00dev,
+         INT_MASK_CSR_AUTO_WAKEUP);
+}
+EXPORT_SYMBOL_GPL(rt2800mmio_autowake_tasklet);
+
+static void rt2800mmio_txstatus_interrupt(struct rt2x00_dev *rt2x00dev)
+{
+ u32 status;
+ int i;
+
+ /*
+  * The TX_FIFO_STATUS interrupt needs special care. We should
+  * read TX_STA_FIFO but we should do it immediately as otherwise
+  * the register can overflow and we would lose status reports.
+  *
+  * Hence, read the TX_STA_FIFO register and copy all tx status
+  * reports into a kernel FIFO which is handled in the txstatus
+  * tasklet. We use a tasklet to process the tx status reports
+  * because we can schedule the tasklet multiple times (when the
+  * interrupt fires again during tx status processing).
+  *
+  * Furthermore we don't disable the TX_FIFO_STATUS
+  * interrupt here but leave it enabled so that the TX_STA_FIFO
+  * can also be read while the tx status tasklet gets executed.
+  *
+  * Since we have only one producer and one consumer we don't
+  * need to lock the kfifo.
+  */
+ for (i = 0; i < rt2x00dev->tx->limit; i++) {
+  rt2x00mmio_register_read(rt2x00dev, TX_STA_FIFO, &status);
+
+  if (!rt2x00_get_field32(status, TX_STA_FIFO_VALID))
+   break;
+
+  if (!kfifo_put(&rt2x00dev->txstatus_fifo, &status)) {
+   rt2x00_warn(rt2x00dev, "TX status FIFO overrun, drop tx status report\n");
+   break;
+  }
+ }
+
+ /* Schedule the tasklet for processing the tx status. */
+ tasklet_schedule(&rt2x00dev->txstatus_tasklet);
+}
+
+irqreturn_t rt2800mmio_interrupt(int irq, void *dev_instance)
+{
+ struct rt2x00_dev *rt2x00dev = dev_instance;
+ u32 reg, mask;
+
+ /* Read status and ACK all interrupts */
+ rt2x00mmio_register_read(rt2x00dev, INT_SOURCE_CSR, &reg);
+ rt2x00mmio_register_write(rt2x00dev, INT_SOURCE_CSR, reg);
+
+ if (!reg)
+  return IRQ_NONE;
+
+ if (!test_bit(DEVICE_STATE_ENABLED_RADIO, &rt2x00dev->flags))
+  return IRQ_HANDLED;
+
+ /*
+  * Since INT_MASK_CSR and INT_SOURCE_CSR use the same bits
+  * for interrupts and interrupt masks we can just use the value of
+  * INT_SOURCE_CSR to create the interrupt mask.
+  */
+ mask = ~reg;
+
+ if (rt2x00_get_field32(reg, INT_SOURCE_CSR_TX_FIFO_STATUS)) {
+  rt2800mmio_txstatus_interrupt(rt2x00dev);
+  /*
+   * Never disable the TX_FIFO_STATUS interrupt.
+   */
+  rt2x00_set_field32(&mask, INT_MASK_CSR_TX_FIFO_STATUS, 1);
+ }
+
+ if (rt2x00_get_field32(reg, INT_SOURCE_CSR_PRE_TBTT))
+  tasklet_hi_schedule(&rt2x00dev->pretbtt_tasklet);
+
+ if (rt2x00_get_field32(reg, INT_SOURCE_CSR_TBTT))
+  tasklet_hi_schedule(&rt2x00dev->tbtt_tasklet);
+
+ if (rt2x00_get_field32(reg, INT_SOURCE_CSR_RX_DONE))
+  tasklet_schedule(&rt2x00dev->rxdone_tasklet);
+
+ if (rt2x00_get_field32(reg, INT_SOURCE_CSR_AUTO_WAKEUP))
+  tasklet_schedule(&rt2x00dev->autowake_tasklet);
+
+ /*
+  * Disable all interrupts for which a tasklet was scheduled right now,
+  * the tasklet will reenable the appropriate interrupts.
+  */
+ spin_lock(&rt2x00dev->irqmask_lock);
+ rt2x00mmio_register_read(rt2x00dev, INT_MASK_CSR, &reg);
+ reg &= mask;
+ rt2x00mmio_register_write(rt2x00dev, INT_MASK_CSR, reg);
+ spin_unlock(&rt2x00dev->irqmask_lock);
+
+ return IRQ_HANDLED;
+}
+EXPORT_SYMBOL_GPL(rt2800mmio_interrupt);
+
+void rt2800mmio_toggle_irq(struct rt2x00_dev *rt2x00dev,
+      enum dev_state state)
+{
+ u32 reg;
+ unsigned long flags;
+
+ /*
+  * When interrupts are being enabled, the interrupt registers
+  * should clear the register to assure a clean state.
+  */
+ if (state == STATE_RADIO_IRQ_ON) {
+  rt2x00mmio_register_read(rt2x00dev, INT_SOURCE_CSR, &reg);
+  rt2x00mmio_register_write(rt2x00dev, INT_SOURCE_CSR, reg);
+ }
+
+ spin_lock_irqsave(&rt2x00dev->irqmask_lock, flags);
+ reg = 0;
+ if (state == STATE_RADIO_IRQ_ON) {
+  rt2x00_set_field32(&reg, INT_MASK_CSR_RX_DONE, 1);
+  rt2x00_set_field32(&reg, INT_MASK_CSR_TBTT, 1);
+  rt2x00_set_field32(&reg, INT_MASK_CSR_PRE_TBTT, 1);
+  rt2x00_set_field32(&reg, INT_MASK_CSR_TX_FIFO_STATUS, 1);
+  rt2x00_set_field32(&reg, INT_MASK_CSR_AUTO_WAKEUP, 1);
+ }
+ rt2x00mmio_register_write(rt2x00dev, INT_MASK_CSR, reg);
+ spin_unlock_irqrestore(&rt2x00dev->irqmask_lock, flags);
+
+ if (state == STATE_RADIO_IRQ_OFF) {
+  /*
+   * Wait for possibly running tasklets to finish.
+   */
+  tasklet_kill(&rt2x00dev->txstatus_tasklet);
+  tasklet_kill(&rt2x00dev->rxdone_tasklet);
+  tasklet_kill(&rt2x00dev->autowake_tasklet);
+  tasklet_kill(&rt2x00dev->tbtt_tasklet);
+  tasklet_kill(&rt2x00dev->pretbtt_tasklet);
+ }
+}
+EXPORT_SYMBOL_GPL(rt2800mmio_toggle_irq);
+
+/*
+ * Queue handlers.
+ */
+void rt2800mmio_start_queue(struct data_queue *queue)
+{
+ struct rt2x00_dev *rt2x00dev = queue->rt2x00dev;
+ u32 reg;
+
+ switch (queue->qid) {
+ case QID_RX:
+  rt2x00mmio_register_read(rt2x00dev, MAC_SYS_CTRL, &reg);
+  rt2x00_set_field32(&reg, MAC_SYS_CTRL_ENABLE_RX, 1);
+  rt2x00mmio_register_write(rt2x00dev, MAC_SYS_CTRL, reg);
+  break;
+ case QID_BEACON:
+  rt2x00mmio_register_read(rt2x00dev, BCN_TIME_CFG, &reg);
+  rt2x00_set_field32(&reg, BCN_TIME_CFG_TSF_TICKING, 1);
+  rt2x00_set_field32(&reg, BCN_TIME_CFG_TBTT_ENABLE, 1);
+  rt2x00_set_field32(&reg, BCN_TIME_CFG_BEACON_GEN, 1);
+  rt2x00mmio_register_write(rt2x00dev, BCN_TIME_CFG, reg);
+
+  rt2x00mmio_register_read(rt2x00dev, INT_TIMER_EN, &reg);
+  rt2x00_set_field32(&reg, INT_TIMER_EN_PRE_TBTT_TIMER, 1);
+  rt2x00mmio_register_write(rt2x00dev, INT_TIMER_EN, reg);
+  break;
+ default:
+  break;
+ }
+}
+EXPORT_SYMBOL_GPL(rt2800mmio_start_queue);
+
+void rt2800mmio_kick_queue(struct data_queue *queue)
+{
+ struct rt2x00_dev *rt2x00dev = queue->rt2x00dev;
+ struct queue_entry *entry;
+
+ switch (queue->qid) {
+ case QID_AC_VO:
+ case QID_AC_VI:
+ case QID_AC_BE:
+ case QID_AC_BK:
+  entry = rt2x00queue_get_entry(queue, Q_INDEX);
+  rt2x00mmio_register_write(rt2x00dev, TX_CTX_IDX(queue->qid),
+       entry->entry_idx);
+  break;
+ case QID_MGMT:
+  entry = rt2x00queue_get_entry(queue, Q_INDEX);
+  rt2x00mmio_register_write(rt2x00dev, TX_CTX_IDX(5),
+       entry->entry_idx);
+  break;
+ default:
+  break;
+ }
+}
+EXPORT_SYMBOL_GPL(rt2800mmio_kick_queue);
+
+void rt2800mmio_stop_queue(struct data_queue *queue)
+{
+ struct rt2x00_dev *rt2x00dev = queue->rt2x00dev;
+ u32 reg;
+
+ switch (queue->qid) {
+ case QID_RX:
+  rt2x00mmio_register_read(rt2x00dev, MAC_SYS_CTRL, &reg);
+  rt2x00_set_field32(&reg, MAC_SYS_CTRL_ENABLE_RX, 0);
+  rt2x00mmio_register_write(rt2x00dev, MAC_SYS_CTRL, reg);
+  break;
+ case QID_BEACON:
+  rt2x00mmio_register_read(rt2x00dev, BCN_TIME_CFG, &reg);
+  rt2x00_set_field32(&reg, BCN_TIME_CFG_TSF_TICKING, 0);
+  rt2x00_set_field32(&reg, BCN_TIME_CFG_TBTT_ENABLE, 0);
+  rt2x00_set_field32(&reg, BCN_TIME_CFG_BEACON_GEN, 0);
+  rt2x00mmio_register_write(rt2x00dev, BCN_TIME_CFG, reg);
+
+  rt2x00mmio_register_read(rt2x00dev, INT_TIMER_EN, &reg);
+  rt2x00_set_field32(&reg, INT_TIMER_EN_PRE_TBTT_TIMER, 0);
+  rt2x00mmio_register_write(rt2x00dev, INT_TIMER_EN, reg);
+
+  /*
+   * Wait for current invocation to finish. The tasklet
+   * won't be scheduled anymore afterwards since we disabled
+   * the TBTT and PRE TBTT timer.
+   */
+  tasklet_kill(&rt2x00dev->tbtt_tasklet);
+  tasklet_kill(&rt2x00dev->pretbtt_tasklet);
+
+  break;
+ default:
+  break;
+ }
+}
+EXPORT_SYMBOL_GPL(rt2800mmio_stop_queue);
+
+void rt2800mmio_queue_init(struct data_queue *queue)
+{
+ struct rt2x00_dev *rt2x00dev = queue->rt2x00dev;
+ unsigned short txwi_size, rxwi_size;
+
+ rt2800_get_txwi_rxwi_size(rt2x00dev, &txwi_size, &rxwi_size);
+
+ switch (queue->qid) {
+ case QID_RX:
+  queue->limit = 128;
+  queue->data_size = AGGREGATION_SIZE;
+  queue->desc_size = RXD_DESC_SIZE;
+  queue->winfo_size = rxwi_size;
+  queue->priv_size = sizeof(struct queue_entry_priv_mmio);
+  break;
+
+ case QID_AC_VO:
+ case QID_AC_VI:
+ case QID_AC_BE:
+ case QID_AC_BK:
+  queue->limit = 64;
+  queue->data_size = AGGREGATION_SIZE;
+  queue->desc_size = TXD_DESC_SIZE;
+  queue->winfo_size = txwi_size;
+  queue->priv_size = sizeof(struct queue_entry_priv_mmio);
+  break;
+
+ case QID_BEACON:
+  queue->limit = 8;
+  queue->data_size = 0; /* No DMA required for beacons */
+  queue->desc_size = TXD_DESC_SIZE;
+  queue->winfo_size = txwi_size;
+  queue->priv_size = sizeof(struct queue_entry_priv_mmio);
+  break;
+
+ case QID_ATIM:
+  /* fallthrough */
+ default:
+  BUG();
+  break;
+ }
+}
+EXPORT_SYMBOL_GPL(rt2800mmio_queue_init);
+
+/*
+ * Initialization functions.
+ */
+bool rt2800mmio_get_entry_state(struct queue_entry *entry)
+{
+ struct queue_entry_priv_mmio *entry_priv = entry->priv_data;
+ u32 word;
+
+ if (entry->queue->qid == QID_RX) {
+  rt2x00_desc_read(entry_priv->desc, 1, &word);
+
+  return (!rt2x00_get_field32(word, RXD_W1_DMA_DONE));
+ } else {
+  rt2x00_desc_read(entry_priv->desc, 1, &word);
+
+  return (!rt2x00_get_field32(word, TXD_W1_DMA_DONE));
+ }
+}
+EXPORT_SYMBOL_GPL(rt2800mmio_get_entry_state);
+
+void rt2800mmio_clear_entry(struct queue_entry *entry)
+{
+ struct queue_entry_priv_mmio *entry_priv = entry->priv_data;
+ struct skb_frame_desc *skbdesc = get_skb_frame_desc(entry->skb);
+ struct rt2x00_dev *rt2x00dev = entry->queue->rt2x00dev;
+ u32 word;
+
+ if (entry->queue->qid == QID_RX) {
+  rt2x00_desc_read(entry_priv->desc, 0, &word);
+  rt2x00_set_field32(&word, RXD_W0_SDP0, skbdesc->skb_dma);
+  rt2x00_desc_write(entry_priv->desc, 0, word);
+
+  rt2x00_desc_read(entry_priv->desc, 1, &word);
+  rt2x00_set_field32(&word, RXD_W1_DMA_DONE, 0);
+  rt2x00_desc_write(entry_priv->desc, 1, word);
+
+  /*
+   * Set RX IDX in register to inform hardware that we have
+   * handled this entry and it is available for reuse again.
+   */
+  rt2x00mmio_register_write(rt2x00dev, RX_CRX_IDX,
+       entry->entry_idx);
+ } else {
+  rt2x00_desc_read(entry_priv->desc, 1, &word);
+  rt2x00_set_field32(&word, TXD_W1_DMA_DONE, 1);
+  rt2x00_desc_write(entry_priv->desc, 1, word);
+ }
+}
+EXPORT_SYMBOL_GPL(rt2800mmio_clear_entry);
+
+int rt2800mmio_init_queues(struct rt2x00_dev *rt2x00dev)
+{
+ struct queue_entry_priv_mmio *entry_priv;
+
+ /*
+  * Initialize registers.
+  */
+ entry_priv = rt2x00dev->tx[0].entries[0].priv_data;
+ rt2x00mmio_register_write(rt2x00dev, TX_BASE_PTR0,
+      entry_priv->desc_dma);
+ rt2x00mmio_register_write(rt2x00dev, TX_MAX_CNT0,
+      rt2x00dev->tx[0].limit);
+ rt2x00mmio_register_write(rt2x00dev, TX_CTX_IDX0, 0);
+ rt2x00mmio_register_write(rt2x00dev, TX_DTX_IDX0, 0);
+
+ entry_priv = rt2x00dev->tx[1].entries[0].priv_data;
+ rt2x00mmio_register_write(rt2x00dev, TX_BASE_PTR1,
+      entry_priv->desc_dma);
+ rt2x00mmio_register_write(rt2x00dev, TX_MAX_CNT1,
+      rt2x00dev->tx[1].limit);
+ rt2x00mmio_register_write(rt2x00dev, TX_CTX_IDX1, 0);
+ rt2x00mmio_register_write(rt2x00dev, TX_DTX_IDX1, 0);
+
+ entry_priv = rt2x00dev->tx[2].entries[0].priv_data;
+ rt2x00mmio_register_write(rt2x00dev, TX_BASE_PTR2,
+      entry_priv->desc_dma);
+ rt2x00mmio_register_write(rt2x00dev, TX_MAX_CNT2,
+      rt2x00dev->tx[2].limit);
+ rt2x00mmio_register_write(rt2x00dev, TX_CTX_IDX2, 0);
+ rt2x00mmio_register_write(rt2x00dev, TX_DTX_IDX2, 0);
+
+ entry_priv = rt2x00dev->tx[3].entries[0].priv_data;
+ rt2x00mmio_register_write(rt2x00dev, TX_BASE_PTR3,
+      entry_priv->desc_dma);
+ rt2x00mmio_register_write(rt2x00dev, TX_MAX_CNT3,
+      rt2x00dev->tx[3].limit);
+ rt2x00mmio_register_write(rt2x00dev, TX_CTX_IDX3, 0);
+ rt2x00mmio_register_write(rt2x00dev, TX_DTX_IDX3, 0);
+
+ rt2x00mmio_register_write(rt2x00dev, TX_BASE_PTR4, 0);
+ rt2x00mmio_register_write(rt2x00dev, TX_MAX_CNT4, 0);
+ rt2x00mmio_register_write(rt2x00dev, TX_CTX_IDX4, 0);
+ rt2x00mmio_register_write(rt2x00dev, TX_DTX_IDX4, 0);
+
+ rt2x00mmio_register_write(rt2x00dev, TX_BASE_PTR5, 0);
+ rt2x00mmio_register_write(rt2x00dev, TX_MAX_CNT5, 0);
+ rt2x00mmio_register_write(rt2x00dev, TX_CTX_IDX5, 0);
+ rt2x00mmio_register_write(rt2x00dev, TX_DTX_IDX5, 0);
+
+ entry_priv = rt2x00dev->rx->entries[0].priv_data;
+ rt2x00mmio_register_write(rt2x00dev, RX_BASE_PTR,
+      entry_priv->desc_dma);
+ rt2x00mmio_register_write(rt2x00dev, RX_MAX_CNT,
+      rt2x00dev->rx[0].limit);
+ rt2x00mmio_register_write(rt2x00dev, RX_CRX_IDX,
+      rt2x00dev->rx[0].limit - 1);
+ rt2x00mmio_register_write(rt2x00dev, RX_DRX_IDX, 0);
+
+ rt2800_disable_wpdma(rt2x00dev);
+
+ rt2x00mmio_register_write(rt2x00dev, DELAY_INT_CFG, 0);
+
+ return 0;
+}
+EXPORT_SYMBOL_GPL(rt2800mmio_init_queues);
+
+int rt2800mmio_init_registers(struct rt2x00_dev *rt2x00dev)
+{
+ u32 reg;
+
+ /*
+  * Reset DMA indexes
+  */
+ rt2x00mmio_register_read(rt2x00dev, WPDMA_RST_IDX, &reg);
+ rt2x00_set_field32(&reg, WPDMA_RST_IDX_DTX_IDX0, 1);
+ rt2x00_set_field32(&reg, WPDMA_RST_IDX_DTX_IDX1, 1);
+ rt2x00_set_field32(&reg, WPDMA_RST_IDX_DTX_IDX2, 1);
+ rt2x00_set_field32(&reg, WPDMA_RST_IDX_DTX_IDX3, 1);
+ rt2x00_set_field32(&reg, WPDMA_RST_IDX_DTX_IDX4, 1);
+ rt2x00_set_field32(&reg, WPDMA_RST_IDX_DTX_IDX5, 1);
+ rt2x00_set_field32(&reg, WPDMA_RST_IDX_DRX_IDX0, 1);
+ rt2x00mmio_register_write(rt2x00dev, WPDMA_RST_IDX, reg);
+
+ rt2x00mmio_register_write(rt2x00dev, PBF_SYS_CTRL, 0x00000e1f);
+ rt2x00mmio_register_write(rt2x00dev, PBF_SYS_CTRL, 0x00000e00);
+
+ if (rt2x00_is_pcie(rt2x00dev) &&
+     (rt2x00_rt(rt2x00dev, RT3090) ||
+      rt2x00_rt(rt2x00dev, RT3390) ||
+      rt2x00_rt(rt2x00dev, RT3572) ||
+      rt2x00_rt(rt2x00dev, RT3593) ||
+      rt2x00_rt(rt2x00dev, RT5390) ||
+      rt2x00_rt(rt2x00dev, RT5392) ||
+      rt2x00_rt(rt2x00dev, RT5592))) {
+  rt2x00mmio_register_read(rt2x00dev, AUX_CTRL, &reg);
+  rt2x00_set_field32(&reg, AUX_CTRL_FORCE_PCIE_CLK, 1);
+  rt2x00_set_field32(&reg, AUX_CTRL_WAKE_PCIE_EN, 1);
+  rt2x00mmio_register_write(rt2x00dev, AUX_CTRL, reg);
+ }
+
+ rt2x00mmio_register_write(rt2x00dev, PWR_PIN_CFG, 0x00000003);
+
+ reg = 0;
+ rt2x00_set_field32(&reg, MAC_SYS_CTRL_RESET_CSR, 1);
+ rt2x00_set_field32(&reg, MAC_SYS_CTRL_RESET_BBP, 1);
+ rt2x00mmio_register_write(rt2x00dev, MAC_SYS_CTRL, reg);
+
+ rt2x00mmio_register_write(rt2x00dev, MAC_SYS_CTRL, 0x00000000);
+
+ return 0;
+}
+EXPORT_SYMBOL_GPL(rt2800mmio_init_registers);
+
+/*
+ * Device state switch handlers.
+ */
+int rt2800mmio_enable_radio(struct rt2x00_dev *rt2x00dev)
+{
+ /* Wait for DMA, ignore error until we initialize queues. */
+ rt2800_wait_wpdma_ready(rt2x00dev);
+
+ if (unlikely(rt2800mmio_init_queues(rt2x00dev)))
+  return -EIO;
+
+ return rt2800_enable_radio(rt2x00dev);
+}
+EXPORT_SYMBOL_GPL(rt2800mmio_enable_radio);
+
+MODULE_AUTHOR(DRV_PROJECT);
+MODULE_VERSION(DRV_VERSION);
+MODULE_DESCRIPTION("rt2800 MMIO library");
+MODULE_LICENSE("GPL");
diff --git a/drivers/net/wireless/rt2x00/rt2800mmio.h b/drivers/net/wireless/rt2x00/rt2800mmio.h
new file mode 100644
index 0000000..b63312c
--- /dev/null
+++ b/drivers/net/wireless/rt2x00/rt2800mmio.h
@@ -0,0 +1,163 @@
+/* Copyright (C) 2009 - 2010 Ivo van Doorn <IvDoorn@gmail.com>
+ * Copyright (C) 2009 Alban Browaeys <prahal@yahoo.com>
+ * Copyright (C) 2009 Felix Fietkau <nbd@openwrt.org>
+ * Copyright (C) 2009 Luis Correia <luis.f.correia@gmail.com>
+ * Copyright (C) 2009 Mattias Nissler <mattias.nissler@gmx.de>
+ * Copyright (C) 2009 Mark Asselstine <asselsm@gmail.com>
+ * Copyright (C) 2009 Xose Vazquez Perez <xose.vazquez@gmail.com>
+ * Copyright (C) 2009 Bart Zolnierkiewicz <bzolnier@gmail.com>
+ * <http://rt2x00.serialmonkey.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+/* Module: rt2800mmio
+ * Abstract: forward declarations for the rt2800mmio module.
+ */
+
+#ifndef RT2800MMIO_H
+#define RT2800MMIO_H
+
+/*
+ * Queue register offset macros
+ */
+#define TX_QUEUE_REG_OFFSET 0x10
+#define TX_BASE_PTR(__x) (TX_BASE_PTR0 + ((__x) * TX_QUEUE_REG_OFFSET))
+#define TX_MAX_CNT(__x)  (TX_MAX_CNT0 + ((__x) * TX_QUEUE_REG_OFFSET))
+#define TX_CTX_IDX(__x)  (TX_CTX_IDX0 + ((__x) * TX_QUEUE_REG_OFFSET))
+#define TX_DTX_IDX(__x)  (TX_DTX_IDX0 + ((__x) * TX_QUEUE_REG_OFFSET))
+
+/*
+ * DMA descriptor defines.
+ */
+#define TXD_DESC_SIZE   (4 * sizeof(__le32))
+#define RXD_DESC_SIZE   (4 * sizeof(__le32))
+
+/*
+ * TX descriptor format for TX, PRIO and Beacon Ring.
+ */
+
+/*
+ * Word0
+ */
+#define TXD_W0_SD_PTR0   FIELD32(0xffffffff)
+
+/*
+ * Word1
+ */
+#define TXD_W1_SD_LEN1   FIELD32(0x00003fff)
+#define TXD_W1_LAST_SEC1  FIELD32(0x00004000)
+#define TXD_W1_BURST   FIELD32(0x00008000)
+#define TXD_W1_SD_LEN0   FIELD32(0x3fff0000)
+#define TXD_W1_LAST_SEC0  FIELD32(0x40000000)
+#define TXD_W1_DMA_DONE   FIELD32(0x80000000)
+
+/*
+ * Word2
+ */
+#define TXD_W2_SD_PTR1   FIELD32(0xffffffff)
+
+/*
+ * Word3
+ * WIV: Wireless Info Valid. 1: Driver filled WI, 0: DMA needs to copy WI
+ * QSEL: Select on-chip FIFO ID for 2nd-stage output scheduler.
+ *       0:MGMT, 1:HCCA 2:EDCA
+ */
+#define TXD_W3_WIV   FIELD32(0x01000000)
+#define TXD_W3_QSEL   FIELD32(0x06000000)
+#define TXD_W3_TCO   FIELD32(0x20000000)
+#define TXD_W3_UCO   FIELD32(0x40000000)
+#define TXD_W3_ICO   FIELD32(0x80000000)
+
+/*
+ * RX descriptor format for RX Ring.
+ */
+
+/*
+ * Word0
+ */
+#define RXD_W0_SDP0   FIELD32(0xffffffff)
+
+/*
+ * Word1
+ */
+#define RXD_W1_SDL1   FIELD32(0x00003fff)
+#define RXD_W1_SDL0   FIELD32(0x3fff0000)
+#define RXD_W1_LS0   FIELD32(0x40000000)
+#define RXD_W1_DMA_DONE   FIELD32(0x80000000)
+
+/*
+ * Word2
+ */
+#define RXD_W2_SDP1   FIELD32(0xffffffff)
+
+/*
+ * Word3
+ * AMSDU: RX with 802.3 header, not 802.11 header.
+ * DECRYPTED: This frame is being decrypted.
+ */
+#define RXD_W3_BA   FIELD32(0x00000001)
+#define RXD_W3_DATA   FIELD32(0x00000002)
+#define RXD_W3_NULLDATA   FIELD32(0x00000004)
+#define RXD_W3_FRAG   FIELD32(0x00000008)
+#define RXD_W3_UNICAST_TO_ME  FIELD32(0x00000010)
+#define RXD_W3_MULTICAST  FIELD32(0x00000020)
+#define RXD_W3_BROADCAST  FIELD32(0x00000040)
+#define RXD_W3_MY_BSS   FIELD32(0x00000080)
+#define RXD_W3_CRC_ERROR  FIELD32(0x00000100)
+#define RXD_W3_CIPHER_ERROR  FIELD32(0x00000600)
+#define RXD_W3_AMSDU   FIELD32(0x00000800)
+#define RXD_W3_HTC   FIELD32(0x00001000)
+#define RXD_W3_RSSI   FIELD32(0x00002000)
+#define RXD_W3_L2PAD   FIELD32(0x00004000)
+#define RXD_W3_AMPDU   FIELD32(0x00008000)
+#define RXD_W3_DECRYPTED  FIELD32(0x00010000)
+#define RXD_W3_PLCP_SIGNAL  FIELD32(0x00020000)
+#define RXD_W3_PLCP_RSSI  FIELD32(0x00040000)
+
+/* TX descriptor initialization */
+__le32 *rt2800mmio_get_txwi(struct queue_entry *entry);
+void rt2800mmio_write_tx_desc(struct queue_entry *entry,
+         struct txentry_desc *txdesc);
+
+/* RX control handlers */
+void rt2800mmio_fill_rxdone(struct queue_entry *entry,
+       struct rxdone_entry_desc *rxdesc);
+
+/* Interrupt functions */
+void rt2800mmio_txstatus_tasklet(unsigned long data);
+void rt2800mmio_pretbtt_tasklet(unsigned long data);
+void rt2800mmio_tbtt_tasklet(unsigned long data);
+void rt2800mmio_rxdone_tasklet(unsigned long data);
+void rt2800mmio_autowake_tasklet(unsigned long data);
+irqreturn_t rt2800mmio_interrupt(int irq, void *dev_instance);
+void rt2800mmio_toggle_irq(struct rt2x00_dev *rt2x00dev,
+      enum dev_state state);
+
+/* Queue handlers */
+void rt2800mmio_start_queue(struct data_queue *queue);
+void rt2800mmio_kick_queue(struct data_queue *queue);
+void rt2800mmio_stop_queue(struct data_queue *queue);
+void rt2800mmio_queue_init(struct data_queue *queue);
+
+/* Initialization functions */
+bool rt2800mmio_get_entry_state(struct queue_entry *entry);
+void rt2800mmio_clear_entry(struct queue_entry *entry);
+int rt2800mmio_init_queues(struct rt2x00_dev *rt2x00dev);
+int rt2800mmio_init_registers(struct rt2x00_dev *rt2x00dev);
+
+/* Device state switch handlers. */
+int rt2800mmio_enable_radio(struct rt2x00_dev *rt2x00dev);
+
+#endif /* RT2800MMIO_H */
diff --git a/drivers/net/wireless/rt2x00/rt2800pci.c b/drivers/net/wireless/rt2x00/rt2800pci.c
index 6f4a861..a5b32ca 100644
--- a/drivers/net/wireless/rt2x00/rt2800pci.c
+++ b/drivers/net/wireless/rt2x00/rt2800pci.c
@@ -20,9 +20,7 @@
  GNU General Public License for more details.
 
  You should have received a copy of the GNU General Public License
- along with this program; if not, write to the
- Free Software Foundation, Inc.,
- 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ along with this program; if not, see <http://www.gnu.org/licenses/>.
  */
 
 /*
@@ -37,14 +35,13 @@
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/pci.h>
-#include <linux/platform_device.h>
 #include <linux/eeprom_93cx6.h>
 
 #include "rt2x00.h"
 #include "rt2x00mmio.h"
 #include "rt2x00pci.h"
-#include "rt2x00soc.h"
 #include "rt2800lib.h"
+#include "rt2800mmio.h"
 #include "rt2800.h"
 #include "rt2800pci.h"
 
@@ -90,27 +87,6 @@ static void rt2800pci_mcu_status(struct rt2x00_dev *rt2x00dev, const u8 token)
  rt2x00mmio_register_write(rt2x00dev, H2M_MAILBOX_CID, ~0);
 }
 
-#if defined(CONFIG_SOC_RT288X) || defined(CONFIG_SOC_RT305X)
-static int rt2800pci_read_eeprom_soc(struct rt2x00_dev *rt2x00dev)
-{
- void __iomem *base_addr = ioremap(0x1F040000, EEPROM_SIZE);
-
- if (!base_addr)
-  return -ENOMEM;
-
- memcpy_fromio(rt2x00dev->eeprom, base_addr, EEPROM_SIZE);
-
- iounmap(base_addr);
- return 0;
-}
-#else
-static inline int rt2800pci_read_eeprom_soc(struct rt2x00_dev *rt2x00dev)
-{
- return -ENOMEM;
-}
-#endif /* CONFIG_SOC_RT288X || CONFIG_SOC_RT305X */
-
-#ifdef CONFIG_PCI
 static void rt2800pci_eepromregister_read(struct eeprom_93cx6 *eeprom)
 {
  struct rt2x00_dev *rt2x00dev = eeprom->data;
@@ -183,112 +159,6 @@ static inline int rt2800pci_read_eeprom_efuse(struct rt2x00_dev *rt2x00dev)
 {
  return rt2800_read_eeprom_efuse(rt2x00dev);
 }
-#else
-static inline int rt2800pci_read_eeprom_pci(struct rt2x00_dev *rt2x00dev)
-{
- return -EOPNOTSUPP;
-}
-
-static inline int rt2800pci_efuse_detect(struct rt2x00_dev *rt2x00dev)
-{
- return 0;
-}
-
-static inline int rt2800pci_read_eeprom_efuse(struct rt2x00_dev *rt2x00dev)
-{
- return -EOPNOTSUPP;
-}
-#endif /* CONFIG_PCI */
-
-/*
- * Queue handlers.
- */
-static void rt2800pci_start_queue(struct data_queue *queue)
-{
- struct rt2x00_dev *rt2x00dev = queue->rt2x00dev;
- u32 reg;
-
- switch (queue->qid) {
- case QID_RX:
-  rt2x00mmio_register_read(rt2x00dev, MAC_SYS_CTRL, &reg);
-  rt2x00_set_field32(&reg, MAC_SYS_CTRL_ENABLE_RX, 1);
-  rt2x00mmio_register_write(rt2x00dev, MAC_SYS_CTRL, reg);
-  break;
- case QID_BEACON:
-  rt2x00mmio_register_read(rt2x00dev, BCN_TIME_CFG, &reg);
-  rt2x00_set_field32(&reg, BCN_TIME_CFG_TSF_TICKING, 1);
-  rt2x00_set_field32(&reg, BCN_TIME_CFG_TBTT_ENABLE, 1);
-  rt2x00_set_field32(&reg, BCN_TIME_CFG_BEACON_GEN, 1);
-  rt2x00mmio_register_write(rt2x00dev, BCN_TIME_CFG, reg);
-
-  rt2x00mmio_register_read(rt2x00dev, INT_TIMER_EN, &reg);
-  rt2x00_set_field32(&reg, INT_TIMER_EN_PRE_TBTT_TIMER, 1);
-  rt2x00mmio_register_write(rt2x00dev, INT_TIMER_EN, reg);
-  break;
- default:
-  break;
- }
-}
-
-static void rt2800pci_kick_queue(struct data_queue *queue)
-{
- struct rt2x00_dev *rt2x00dev = queue->rt2x00dev;
- struct queue_entry *entry;
-
- switch (queue->qid) {
- case QID_AC_VO:
- case QID_AC_VI:
- case QID_AC_BE:
- case QID_AC_BK:
-  entry = rt2x00queue_get_entry(queue, Q_INDEX);
-  rt2x00mmio_register_write(rt2x00dev, TX_CTX_IDX(queue->qid),
-       entry->entry_idx);
-  break;
- case QID_MGMT:
-  entry = rt2x00queue_get_entry(queue, Q_INDEX);
-  rt2x00mmio_register_write(rt2x00dev, TX_CTX_IDX(5),
-       entry->entry_idx);
-  break;
- default:
-  break;
- }
-}
-
-static void rt2800pci_stop_queue(struct data_queue *queue)
-{
- struct rt2x00_dev *rt2x00dev = queue->rt2x00dev;
- u32 reg;
-
- switch (queue->qid) {
- case QID_RX:
-  rt2x00mmio_register_read(rt2x00dev, MAC_SYS_CTRL, &reg);
-  rt2x00_set_field32(&reg, MAC_SYS_CTRL_ENABLE_RX, 0);
-  rt2x00mmio_register_write(rt2x00dev, MAC_SYS_CTRL, reg);
-  break;
- case QID_BEACON:
-  rt2x00mmio_register_read(rt2x00dev, BCN_TIME_CFG, &reg);
-  rt2x00_set_field32(&reg, BCN_TIME_CFG_TSF_TICKING, 0);
-  rt2x00_set_field32(&reg, BCN_TIME_CFG_TBTT_ENABLE, 0);
-  rt2x00_set_field32(&reg, BCN_TIME_CFG_BEACON_GEN, 0);
-  rt2x00mmio_register_write(rt2x00dev, BCN_TIME_CFG, reg);
-
-  rt2x00mmio_register_read(rt2x00dev, INT_TIMER_EN, &reg);
-  rt2x00_set_field32(&reg, INT_TIMER_EN_PRE_TBTT_TIMER, 0);
-  rt2x00mmio_register_write(rt2x00dev, INT_TIMER_EN, reg);
-
-  /*
-   * Wait for current invocation to finish. The tasklet
-   * won't be scheduled anymore afterwards since we disabled
-   * the TBTT and PRE TBTT timer.
-   */
-  tasklet_kill(&rt2x00dev->tbtt_tasklet);
-  tasklet_kill(&rt2x00dev->pretbtt_tasklet);
-
-  break;
- default:
-  break;
- }
-}
 
 /*
  * Firmware functions
@@ -332,213 +202,13 @@ static int rt2800pci_write_firmware(struct rt2x00_dev *rt2x00dev,
 }
 
 /*
- * Initialization functions.
- */
-static bool rt2800pci_get_entry_state(struct queue_entry *entry)
-{
- struct queue_entry_priv_mmio *entry_priv = entry->priv_data;
- u32 word;
-
- if (entry->queue->qid == QID_RX) {
-  rt2x00_desc_read(entry_priv->desc, 1, &word);
-
-  return (!rt2x00_get_field32(word, RXD_W1_DMA_DONE));
- } else {
-  rt2x00_desc_read(entry_priv->desc, 1, &word);
-
-  return (!rt2x00_get_field32(word, TXD_W1_DMA_DONE));
- }
-}
-
-static void rt2800pci_clear_entry(struct queue_entry *entry)
-{
- struct queue_entry_priv_mmio *entry_priv = entry->priv_data;
- struct skb_frame_desc *skbdesc = get_skb_frame_desc(entry->skb);
- struct rt2x00_dev *rt2x00dev = entry->queue->rt2x00dev;
- u32 word;
-
- if (entry->queue->qid == QID_RX) {
-  rt2x00_desc_read(entry_priv->desc, 0, &word);
-  rt2x00_set_field32(&word, RXD_W0_SDP0, skbdesc->skb_dma);
-  rt2x00_desc_write(entry_priv->desc, 0, word);
-
-  rt2x00_desc_read(entry_priv->desc, 1, &word);
-  rt2x00_set_field32(&word, RXD_W1_DMA_DONE, 0);
-  rt2x00_desc_write(entry_priv->desc, 1, word);
-
-  /*
-   * Set RX IDX in register to inform hardware that we have
-   * handled this entry and it is available for reuse again.
-   */
-  rt2x00mmio_register_write(rt2x00dev, RX_CRX_IDX,
-       entry->entry_idx);
- } else {
-  rt2x00_desc_read(entry_priv->desc, 1, &word);
-  rt2x00_set_field32(&word, TXD_W1_DMA_DONE, 1);
-  rt2x00_desc_write(entry_priv->desc, 1, word);
- }
-}
-
-static int rt2800pci_init_queues(struct rt2x00_dev *rt2x00dev)
-{
- struct queue_entry_priv_mmio *entry_priv;
-
- /*
-  * Initialize registers.
-  */
- entry_priv = rt2x00dev->tx[0].entries[0].priv_data;
- rt2x00mmio_register_write(rt2x00dev, TX_BASE_PTR0,
-      entry_priv->desc_dma);
- rt2x00mmio_register_write(rt2x00dev, TX_MAX_CNT0,
-      rt2x00dev->tx[0].limit);
- rt2x00mmio_register_write(rt2x00dev, TX_CTX_IDX0, 0);
- rt2x00mmio_register_write(rt2x00dev, TX_DTX_IDX0, 0);
-
- entry_priv = rt2x00dev->tx[1].entries[0].priv_data;
- rt2x00mmio_register_write(rt2x00dev, TX_BASE_PTR1,
-      entry_priv->desc_dma);
- rt2x00mmio_register_write(rt2x00dev, TX_MAX_CNT1,
-      rt2x00dev->tx[1].limit);
- rt2x00mmio_register_write(rt2x00dev, TX_CTX_IDX1, 0);
- rt2x00mmio_register_write(rt2x00dev, TX_DTX_IDX1, 0);
-
- entry_priv = rt2x00dev->tx[2].entries[0].priv_data;
- rt2x00mmio_register_write(rt2x00dev, TX_BASE_PTR2,
-      entry_priv->desc_dma);
- rt2x00mmio_register_write(rt2x00dev, TX_MAX_CNT2,
-      rt2x00dev->tx[2].limit);
- rt2x00mmio_register_write(rt2x00dev, TX_CTX_IDX2, 0);
- rt2x00mmio_register_write(rt2x00dev, TX_DTX_IDX2, 0);
-
- entry_priv = rt2x00dev->tx[3].entries[0].priv_data;
- rt2x00mmio_register_write(rt2x00dev, TX_BASE_PTR3,
-      entry_priv->desc_dma);
- rt2x00mmio_register_write(rt2x00dev, TX_MAX_CNT3,
-      rt2x00dev->tx[3].limit);
- rt2x00mmio_register_write(rt2x00dev, TX_CTX_IDX3, 0);
- rt2x00mmio_register_write(rt2x00dev, TX_DTX_IDX3, 0);
-
- rt2x00mmio_register_write(rt2x00dev, TX_BASE_PTR4, 0);
- rt2x00mmio_register_write(rt2x00dev, TX_MAX_CNT4, 0);
- rt2x00mmio_register_write(rt2x00dev, TX_CTX_IDX4, 0);
- rt2x00mmio_register_write(rt2x00dev, TX_DTX_IDX4, 0);
-
- rt2x00mmio_register_write(rt2x00dev, TX_BASE_PTR5, 0);
- rt2x00mmio_register_write(rt2x00dev, TX_MAX_CNT5, 0);
- rt2x00mmio_register_write(rt2x00dev, TX_CTX_IDX5, 0);
- rt2x00mmio_register_write(rt2x00dev, TX_DTX_IDX5, 0);
-
- entry_priv = rt2x00dev->rx->entries[0].priv_data;
- rt2x00mmio_register_write(rt2x00dev, RX_BASE_PTR,
-      entry_priv->desc_dma);
- rt2x00mmio_register_write(rt2x00dev, RX_MAX_CNT,
-      rt2x00dev->rx[0].limit);
- rt2x00mmio_register_write(rt2x00dev, RX_CRX_IDX,
-      rt2x00dev->rx[0].limit - 1);
- rt2x00mmio_register_write(rt2x00dev, RX_DRX_IDX, 0);
-
- rt2800_disable_wpdma(rt2x00dev);
-
- rt2x00mmio_register_write(rt2x00dev, DELAY_INT_CFG, 0);
-
- return 0;
-}
-
-/*
  * Device state switch handlers.
  */
-static void rt2800pci_toggle_irq(struct rt2x00_dev *rt2x00dev,
-     enum dev_state state)
-{
- u32 reg;
- unsigned long flags;
-
- /*
-  * When interrupts are being enabled, the interrupt registers
-  * should clear the register to assure a clean state.
-  */
- if (state == STATE_RADIO_IRQ_ON) {
-  rt2x00mmio_register_read(rt2x00dev, INT_SOURCE_CSR, &reg);
-  rt2x00mmio_register_write(rt2x00dev, INT_SOURCE_CSR, reg);
- }
-
- spin_lock_irqsave(&rt2x00dev->irqmask_lock, flags);
- reg = 0;
- if (state == STATE_RADIO_IRQ_ON) {
-  rt2x00_set_field32(&reg, INT_MASK_CSR_RX_DONE, 1);
-  rt2x00_set_field32(&reg, INT_MASK_CSR_TBTT, 1);
-  rt2x00_set_field32(&reg, INT_MASK_CSR_PRE_TBTT, 1);
-  rt2x00_set_field32(&reg, INT_MASK_CSR_TX_FIFO_STATUS, 1);
-  rt2x00_set_field32(&reg, INT_MASK_CSR_AUTO_WAKEUP, 1);
- }
- rt2x00mmio_register_write(rt2x00dev, INT_MASK_CSR, reg);
- spin_unlock_irqrestore(&rt2x00dev->irqmask_lock, flags);
-
- if (state == STATE_RADIO_IRQ_OFF) {
-  /*
-   * Wait for possibly running tasklets to finish.
-   */
-  tasklet_kill(&rt2x00dev->txstatus_tasklet);
-  tasklet_kill(&rt2x00dev->rxdone_tasklet);
-  tasklet_kill(&rt2x00dev->autowake_tasklet);
-  tasklet_kill(&rt2x00dev->tbtt_tasklet);
-  tasklet_kill(&rt2x00dev->pretbtt_tasklet);
- }
-}
-
-static int rt2800pci_init_registers(struct rt2x00_dev *rt2x00dev)
-{
- u32 reg;
-
- /*
-  * Reset DMA indexes
-  */
- rt2x00mmio_register_read(rt2x00dev, WPDMA_RST_IDX, &reg);
- rt2x00_set_field32(&reg, WPDMA_RST_IDX_DTX_IDX0, 1);
- rt2x00_set_field32(&reg, WPDMA_RST_IDX_DTX_IDX1, 1);
- rt2x00_set_field32(&reg, WPDMA_RST_IDX_DTX_IDX2, 1);
- rt2x00_set_field32(&reg, WPDMA_RST_IDX_DTX_IDX3, 1);
- rt2x00_set_field32(&reg, WPDMA_RST_IDX_DTX_IDX4, 1);
- rt2x00_set_field32(&reg, WPDMA_RST_IDX_DTX_IDX5, 1);
- rt2x00_set_field32(&reg, WPDMA_RST_IDX_DRX_IDX0, 1);
- rt2x00mmio_register_write(rt2x00dev, WPDMA_RST_IDX, reg);
-
- rt2x00mmio_register_write(rt2x00dev, PBF_SYS_CTRL, 0x00000e1f);
- rt2x00mmio_register_write(rt2x00dev, PBF_SYS_CTRL, 0x00000e00);
-
- if (rt2x00_is_pcie(rt2x00dev) &&
-     (rt2x00_rt(rt2x00dev, RT3572) ||
-      rt2x00_rt(rt2x00dev, RT5390) ||
-      rt2x00_rt(rt2x00dev, RT5392))) {
-  rt2x00mmio_register_read(rt2x00dev, AUX_CTRL, &reg);
-  rt2x00_set_field32(&reg, AUX_CTRL_FORCE_PCIE_CLK, 1);
-  rt2x00_set_field32(&reg, AUX_CTRL_WAKE_PCIE_EN, 1);
-  rt2x00mmio_register_write(rt2x00dev, AUX_CTRL, reg);
- }
-
- rt2x00mmio_register_write(rt2x00dev, PWR_PIN_CFG, 0x00000003);
-
- reg = 0;
- rt2x00_set_field32(&reg, MAC_SYS_CTRL_RESET_CSR, 1);
- rt2x00_set_field32(&reg, MAC_SYS_CTRL_RESET_BBP, 1);
- rt2x00mmio_register_write(rt2x00dev, MAC_SYS_CTRL, reg);
-
- rt2x00mmio_register_write(rt2x00dev, MAC_SYS_CTRL, 0x00000000);
-
- return 0;
-}
-
 static int rt2800pci_enable_radio(struct rt2x00_dev *rt2x00dev)
 {
  int retval;
 
- /* Wait for DMA, ignore error until we initialize queues. */
- rt2800_wait_wpdma_ready(rt2x00dev);
-
- if (unlikely(rt2800pci_init_queues(rt2x00dev)))
-  return -EIO;
-
- retval = rt2800_enable_radio(rt2x00dev);
+ retval = rt2800mmio_enable_radio(rt2x00dev);
  if (retval)
   return retval;
 
@@ -555,15 +225,6 @@ static int rt2800pci_enable_radio(struct rt2x00_dev *rt2x00dev)
  return retval;
 }
 
-static void rt2800pci_disable_radio(struct rt2x00_dev *rt2x00dev)
-{
- if (rt2x00_is_soc(rt2x00dev)) {
-  rt2800_disable_radio(rt2x00dev);
-  rt2x00mmio_register_write(rt2x00dev, PWR_PIN_CFG, 0);
-  rt2x00mmio_register_write(rt2x00dev, TX_PIN_CFG, 0);
- }
-}
-
 static int rt2800pci_set_state(struct rt2x00_dev *rt2x00dev,
           enum dev_state state)
 {
@@ -597,12 +258,11 @@ static int rt2800pci_set_device_state(struct rt2x00_dev *rt2x00dev,
    * After the radio has been disabled, the device should
    * be put to sleep for powersaving.
    */
-  rt2800pci_disable_radio(rt2x00dev);
   rt2800pci_set_state(rt2x00dev, STATE_SLEEP);
   break;
  case STATE_RADIO_IRQ_ON:
  case STATE_RADIO_IRQ_OFF:
-  rt2800pci_toggle_irq(rt2x00dev, state);
+  rt2800mmio_toggle_irq(rt2x00dev, state);
   break;
  case STATE_DEEP_SLEEP:
  case STATE_SLEEP:
@@ -623,478 +283,13 @@ static int rt2800pci_set_device_state(struct rt2x00_dev *rt2x00dev,
 }
 
 /*
- * TX descriptor initialization
- */
-static __le32 *rt2800pci_get_txwi(struct queue_entry *entry)
-{
- return (__le32 *) entry->skb->data;
-}
-
-static void rt2800pci_write_tx_desc(struct queue_entry *entry,
-        struct txentry_desc *txdesc)
-{
- struct skb_frame_desc *skbdesc = get_skb_frame_desc(entry->skb);
- struct queue_entry_priv_mmio *entry_priv = entry->priv_data;
- __le32 *txd = entry_priv->desc;
- u32 word;
-
- /*
-  * The buffers pointed by SD_PTR0/SD_LEN0 and SD_PTR1/SD_LEN1
-  * must contains a TXWI structure + 802.11 header + padding + 802.11
-  * data. We choose to have SD_PTR0/SD_LEN0 only contains TXWI and
-  * SD_PTR1/SD_LEN1 contains 802.11 header + padding + 802.11
-  * data. It means that LAST_SEC0 is always 0.
-  */
-
- /*
-  * Initialize TX descriptor
-  */
- word = 0;
- rt2x00_set_field32(&word, TXD_W0_SD_PTR0, skbdesc->skb_dma);
- rt2x00_desc_write(txd, 0, word);
-
- word = 0;
- rt2x00_set_field32(&word, TXD_W1_SD_LEN1, entry->skb->len);
- rt2x00_set_field32(&word, TXD_W1_LAST_SEC1,
-      !test_bit(ENTRY_TXD_MORE_FRAG, &txdesc->flags));
- rt2x00_set_field32(&word, TXD_W1_BURST,
-      test_bit(ENTRY_TXD_BURST, &txdesc->flags));
- rt2x00_set_field32(&word, TXD_W1_SD_LEN0, TXWI_DESC_SIZE);
- rt2x00_set_field32(&word, TXD_W1_LAST_SEC0, 0);
- rt2x00_set_field32(&word, TXD_W1_DMA_DONE, 0);
- rt2x00_desc_write(txd, 1, word);
-
- word = 0;
- rt2x00_set_field32(&word, TXD_W2_SD_PTR1,
-      skbdesc->skb_dma + TXWI_DESC_SIZE);
- rt2x00_desc_write(txd, 2, word);
-
- word = 0;
- rt2x00_set_field32(&word, TXD_W3_WIV,
-      !test_bit(ENTRY_TXD_ENCRYPT_IV, &txdesc->flags));
- rt2x00_set_field32(&word, TXD_W3_QSEL, 2);
- rt2x00_desc_write(txd, 3, word);
-
- /*
-  * Register descriptor details in skb frame descriptor.
-  */
- skbdesc->desc = txd;
- skbdesc->desc_len = TXD_DESC_SIZE;
-}
-
-/*
- * RX control handlers
- */
-static void rt2800pci_fill_rxdone(struct queue_entry *entry,
-      struct rxdone_entry_desc *rxdesc)
-{
- struct queue_entry_priv_mmio *entry_priv = entry->priv_data;
- __le32 *rxd = entry_priv->desc;
- u32 word;
-
- rt2x00_desc_read(rxd, 3, &word);
-
- if (rt2x00_get_field32(word, RXD_W3_CRC_ERROR))
-  rxdesc->flags |= RX_FLAG_FAILED_FCS_CRC;
-
- /*
-  * Unfortunately we don't know the cipher type used during
-  * decryption. This prevents us from correct providing
-  * correct statistics through debugfs.
-  */
- rxdesc->cipher_status = rt2x00_get_field32(word, RXD_W3_CIPHER_ERROR);
-
- if (rt2x00_get_field32(word, RXD_W3_DECRYPTED)) {
-  /*
-   * Hardware has stripped IV/EIV data from 802.11 frame during
-   * decryption. Unfortunately the descriptor doesn't contain
-   * any fields with the EIV/IV data either, so they can't
-   * be restored by rt2x00lib.
-   */
-  rxdesc->flags |= RX_FLAG_IV_STRIPPED;
-
-  /*
-   * The hardware has already checked the Michael Mic and has
-   * stripped it from the frame. Signal this to mac80211.
-   */
-  rxdesc->flags |= RX_FLAG_MMIC_STRIPPED;
-
-  if (rxdesc->cipher_status == RX_CRYPTO_SUCCESS)
-   rxdesc->flags |= RX_FLAG_DECRYPTED;
-  else if (rxdesc->cipher_status == RX_CRYPTO_FAIL_MIC)
-   rxdesc->flags |= RX_FLAG_MMIC_ERROR;
- }
-
- if (rt2x00_get_field32(word, RXD_W3_MY_BSS))
-  rxdesc->dev_flags |= RXDONE_MY_BSS;
-
- if (rt2x00_get_field32(word, RXD_W3_L2PAD))
-  rxdesc->dev_flags |= RXDONE_L2PAD;
-
- /*
-  * Process the RXWI structure that is at the start of the buffer.
-  */
- rt2800_process_rxwi(entry, rxdesc);
-}
-
-/*
- * Interrupt functions.
- */
-static void rt2800pci_wakeup(struct rt2x00_dev *rt2x00dev)
-{
- struct ieee80211_conf conf = { .flags = 0 };
- struct rt2x00lib_conf libconf = { .conf = &conf };
-
- rt2800_config(rt2x00dev, &libconf, IEEE80211_CONF_CHANGE_PS);
-}
-
-static bool rt2800pci_txdone_entry_check(struct queue_entry *entry, u32 status)
-{
- __le32 *txwi;
- u32 word;
- int wcid, tx_wcid;
-
- wcid = rt2x00_get_field32(status, TX_STA_FIFO_WCID);
-
- txwi = rt2800_drv_get_txwi(entry);
- rt2x00_desc_read(txwi, 1, &word);
- tx_wcid = rt2x00_get_field32(word, TXWI_W1_WIRELESS_CLI_ID);
-
- return (tx_wcid == wcid);
-}
-
-static bool rt2800pci_txdone_find_entry(struct queue_entry *entry, void *data)
-{
- u32 status = *(u32 *)data;
-
- /*
-  * rt2800pci hardware might reorder frames when exchanging traffic
-  * with multiple BA enabled STAs.
-  *
-  * For example, a tx queue
-  *    [ STA1 | STA2 | STA1 | STA2 ]
-  * can result in tx status reports
-  *    [ STA1 | STA1 | STA2 | STA2 ]
-  * when the hw decides to aggregate the frames for STA1 into one AMPDU.
-  *
-  * To mitigate this effect, associate the tx status to the first frame
-  * in the tx queue with a matching wcid.
-  */
- if (rt2800pci_txdone_entry_check(entry, status) &&
-     !test_bit(ENTRY_DATA_STATUS_SET, &entry->flags)) {
-  /*
-   * Got a matching frame, associate the tx status with
-   * the frame
-   */
-  entry->status = status;
-  set_bit(ENTRY_DATA_STATUS_SET, &entry->flags);
-  return true;
- }
-
- /* Check the next frame */
- return false;
-}
-
-static bool rt2800pci_txdone_match_first(struct queue_entry *entry, void *data)
-{
- u32 status = *(u32 *)data;
-
- /*
-  * Find the first frame without tx status and assign this status to it
-  * regardless if it matches or not.
-  */
- if (!test_bit(ENTRY_DATA_STATUS_SET, &entry->flags)) {
-  /*
-   * Got a matching frame, associate the tx status with
-   * the frame
-   */
-  entry->status = status;
-  set_bit(ENTRY_DATA_STATUS_SET, &entry->flags);
-  return true;
- }
-
- /* Check the next frame */
- return false;
-}
-static bool rt2800pci_txdone_release_entries(struct queue_entry *entry,
-          void *data)
-{
- if (test_bit(ENTRY_DATA_STATUS_SET, &entry->flags)) {
-  rt2800_txdone_entry(entry, entry->status,
-        rt2800pci_get_txwi(entry));
-  return false;
- }
-
- /* No more frames to release */
- return true;
-}
-
-static bool rt2800pci_txdone(struct rt2x00_dev *rt2x00dev)
-{
- struct data_queue *queue;
- u32 status;
- u8 qid;
- int max_tx_done = 16;
-
- while (kfifo_get(&rt2x00dev->txstatus_fifo, &status)) {
-  qid = rt2x00_get_field32(status, TX_STA_FIFO_PID_QUEUE);
-  if (unlikely(qid >= QID_RX)) {
-   /*
-    * Unknown queue, this shouldn't happen. Just drop
-    * this tx status.
-    */
-   rt2x00_warn(rt2x00dev, "Got TX status report with unexpected pid %u, dropping\n",
-        qid);
-   break;
-  }
-
-  queue = rt2x00queue_get_tx_queue(rt2x00dev, qid);
-  if (unlikely(queue == NULL)) {
-   /*
-    * The queue is NULL, this shouldn't happen. Stop
-    * processing here and drop the tx status
-    */
-   rt2x00_warn(rt2x00dev, "Got TX status for an unavailable queue %u, dropping\n",
-        qid);
-   break;
-  }
-
-  if (unlikely(rt2x00queue_empty(queue))) {
-   /*
-    * The queue is empty. Stop processing here
-    * and drop the tx status.
-    */
-   rt2x00_warn(rt2x00dev, "Got TX status for an empty queue %u, dropping\n",
-        qid);
-   break;
-  }
-
-  /*
-   * Let's associate this tx status with the first
-   * matching frame.
-   */
-  if (!rt2x00queue_for_each_entry(queue, Q_INDEX_DONE,
-      Q_INDEX, &status,
-      rt2800pci_txdone_find_entry)) {
-   /*
-    * We cannot match the tx status to any frame, so just
-    * use the first one.
-    */
-   if (!rt2x00queue_for_each_entry(queue, Q_INDEX_DONE,
-       Q_INDEX, &status,
-       rt2800pci_txdone_match_first)) {
-    rt2x00_warn(rt2x00dev, "No frame found for TX status on queue %u, dropping\n",
-         qid);
-    break;
-   }
-  }
-
-  /*
-   * Release all frames with a valid tx status.
-   */
-  rt2x00queue_for_each_entry(queue, Q_INDEX_DONE,
-        Q_INDEX, NULL,
-        rt2800pci_txdone_release_entries);
-
-  if (--max_tx_done == 0)
-   break;
- }
-
- return !max_tx_done;
-}
-
-static inline void rt2800pci_enable_interrupt(struct rt2x00_dev *rt2x00dev,
-           struct rt2x00_field32 irq_field)
-{
- u32 reg;
-
- /*
-  * Enable a single interrupt. The interrupt mask register
-  * access needs locking.
-  */
- spin_lock_irq(&rt2x00dev->irqmask_lock);
- rt2x00mmio_register_read(rt2x00dev, INT_MASK_CSR, &reg);
- rt2x00_set_field32(&reg, irq_field, 1);
- rt2x00mmio_register_write(rt2x00dev, INT_MASK_CSR, reg);
- spin_unlock_irq(&rt2x00dev->irqmask_lock);
-}
-
-static void rt2800pci_txstatus_tasklet(unsigned long data)
-{
- struct rt2x00_dev *rt2x00dev = (struct rt2x00_dev *)data;
- if (rt2800pci_txdone(rt2x00dev))
-  tasklet_schedule(&rt2x00dev->txstatus_tasklet);
-
- /*
-  * No need to enable the tx status interrupt here as we always
-  * leave it enabled to minimize the possibility of a tx status
-  * register overflow. See comment in interrupt handler.
-  */
-}
-
-static void rt2800pci_pretbtt_tasklet(unsigned long data)
-{
- struct rt2x00_dev *rt2x00dev = (struct rt2x00_dev *)data;
- rt2x00lib_pretbtt(rt2x00dev);
- if (test_bit(DEVICE_STATE_ENABLED_RADIO, &rt2x00dev->flags))
-  rt2800pci_enable_interrupt(rt2x00dev, INT_MASK_CSR_PRE_TBTT);
-}
-
-static void rt2800pci_tbtt_tasklet(unsigned long data)
-{
- struct rt2x00_dev *rt2x00dev = (struct rt2x00_dev *)data;
- struct rt2800_drv_data *drv_data = rt2x00dev->drv_data;
- u32 reg;
-
- rt2x00lib_beacondone(rt2x00dev);
-
- if (rt2x00dev->intf_ap_count) {
-  /*
-   * The rt2800pci hardware tbtt timer is off by 1us per tbtt
-   * causing beacon skew and as a result causing problems with
-   * some powersaving clients over time. Shorten the beacon
-   * interval every 64 beacons by 64us to mitigate this effect.
-   */
-  if (drv_data->tbtt_tick == (BCN_TBTT_OFFSET - 2)) {
-   rt2x00mmio_register_read(rt2x00dev, BCN_TIME_CFG, &reg);
-   rt2x00_set_field32(&reg, BCN_TIME_CFG_BEACON_INTERVAL,
-        (rt2x00dev->beacon_int * 16) - 1);
-   rt2x00mmio_register_write(rt2x00dev, BCN_TIME_CFG, reg);
-  } else if (drv_data->tbtt_tick == (BCN_TBTT_OFFSET - 1)) {
-   rt2x00mmio_register_read(rt2x00dev, BCN_TIME_CFG, &reg);
-   rt2x00_set_field32(&reg, BCN_TIME_CFG_BEACON_INTERVAL,
-        (rt2x00dev->beacon_int * 16));
-   rt2x00mmio_register_write(rt2x00dev, BCN_TIME_CFG, reg);
-  }
-  drv_data->tbtt_tick++;
-  drv_data->tbtt_tick %= BCN_TBTT_OFFSET;
- }
-
- if (test_bit(DEVICE_STATE_ENABLED_RADIO, &rt2x00dev->flags))
-  rt2800pci_enable_interrupt(rt2x00dev, INT_MASK_CSR_TBTT);
-}
-
-static void rt2800pci_rxdone_tasklet(unsigned long data)
-{
- struct rt2x00_dev *rt2x00dev = (struct rt2x00_dev *)data;
- if (rt2x00mmio_rxdone(rt2x00dev))
-  tasklet_schedule(&rt2x00dev->rxdone_tasklet);
- else if (test_bit(DEVICE_STATE_ENABLED_RADIO, &rt2x00dev->flags))
-  rt2800pci_enable_interrupt(rt2x00dev, INT_MASK_CSR_RX_DONE);
-}
-
-static void rt2800pci_autowake_tasklet(unsigned long data)
-{
- struct rt2x00_dev *rt2x00dev = (struct rt2x00_dev *)data;
- rt2800pci_wakeup(rt2x00dev);
- if (test_bit(DEVICE_STATE_ENABLED_RADIO, &rt2x00dev->flags))
-  rt2800pci_enable_interrupt(rt2x00dev, INT_MASK_CSR_AUTO_WAKEUP);
-}
-
-static void rt2800pci_txstatus_interrupt(struct rt2x00_dev *rt2x00dev)
-{
- u32 status;
- int i;
-
- /*
-  * The TX_FIFO_STATUS interrupt needs special care. We should
-  * read TX_STA_FIFO but we should do it immediately as otherwise
-  * the register can overflow and we would lose status reports.
-  *
-  * Hence, read the TX_STA_FIFO register and copy all tx status
-  * reports into a kernel FIFO which is handled in the txstatus
-  * tasklet. We use a tasklet to process the tx status reports
-  * because we can schedule the tasklet multiple times (when the
-  * interrupt fires again during tx status processing).
-  *
-  * Furthermore we don't disable the TX_FIFO_STATUS
-  * interrupt here but leave it enabled so that the TX_STA_FIFO
-  * can also be read while the tx status tasklet gets executed.
-  *
-  * Since we have only one producer and one consumer we don't
-  * need to lock the kfifo.
-  */
- for (i = 0; i < rt2x00dev->ops->tx->entry_num; i++) {
-  rt2x00mmio_register_read(rt2x00dev, TX_STA_FIFO, &status);
-
-  if (!rt2x00_get_field32(status, TX_STA_FIFO_VALID))
-   break;
-
-  if (!kfifo_put(&rt2x00dev->txstatus_fifo, &status)) {
-   rt2x00_warn(rt2x00dev, "TX status FIFO overrun, drop tx status report\n");
-   break;
-  }
- }
-
- /* Schedule the tasklet for processing the tx status. */
- tasklet_schedule(&rt2x00dev->txstatus_tasklet);
-}
-
-static irqreturn_t rt2800pci_interrupt(int irq, void *dev_instance)
-{
- struct rt2x00_dev *rt2x00dev = dev_instance;
- u32 reg, mask;
-
- /* Read status and ACK all interrupts */
- rt2x00mmio_register_read(rt2x00dev, INT_SOURCE_CSR, &reg);
- rt2x00mmio_register_write(rt2x00dev, INT_SOURCE_CSR, reg);
-
- if (!reg)
-  return IRQ_NONE;
-
- if (!test_bit(DEVICE_STATE_ENABLED_RADIO, &rt2x00dev->flags))
-  return IRQ_HANDLED;
-
- /*
-  * Since INT_MASK_CSR and INT_SOURCE_CSR use the same bits
-  * for interrupts and interrupt masks we can just use the value of
-  * INT_SOURCE_CSR to create the interrupt mask.
-  */
- mask = ~reg;
-
- if (rt2x00_get_field32(reg, INT_SOURCE_CSR_TX_FIFO_STATUS)) {
-  rt2800pci_txstatus_interrupt(rt2x00dev);
-  /*
-   * Never disable the TX_FIFO_STATUS interrupt.
-   */
-  rt2x00_set_field32(&mask, INT_MASK_CSR_TX_FIFO_STATUS, 1);
- }
-
- if (rt2x00_get_field32(reg, INT_SOURCE_CSR_PRE_TBTT))
-  tasklet_hi_schedule(&rt2x00dev->pretbtt_tasklet);
-
- if (rt2x00_get_field32(reg, INT_SOURCE_CSR_TBTT))
-  tasklet_hi_schedule(&rt2x00dev->tbtt_tasklet);
-
- if (rt2x00_get_field32(reg, INT_SOURCE_CSR_RX_DONE))
-  tasklet_schedule(&rt2x00dev->rxdone_tasklet);
-
- if (rt2x00_get_field32(reg, INT_SOURCE_CSR_AUTO_WAKEUP))
-  tasklet_schedule(&rt2x00dev->autowake_tasklet);
-
- /*
-  * Disable all interrupts for which a tasklet was scheduled right now,
-  * the tasklet will reenable the appropriate interrupts.
-  */
- spin_lock(&rt2x00dev->irqmask_lock);
- rt2x00mmio_register_read(rt2x00dev, INT_MASK_CSR, &reg);
- reg &= mask;
- rt2x00mmio_register_write(rt2x00dev, INT_MASK_CSR, reg);
- spin_unlock(&rt2x00dev->irqmask_lock);
-
- return IRQ_HANDLED;
-}
-
-/*
  * Device probe functions.
  */
 static int rt2800pci_read_eeprom(struct rt2x00_dev *rt2x00dev)
 {
  int retval;
 
- if (rt2x00_is_soc(rt2x00dev))
-  retval = rt2800pci_read_eeprom_soc(rt2x00dev);
- else if (rt2800pci_efuse_detect(rt2x00dev))
+ if (rt2800pci_efuse_detect(rt2x00dev))
   retval = rt2800pci_read_eeprom_efuse(rt2x00dev);
  else
   retval = rt2800pci_read_eeprom_pci(rt2x00dev);
@@ -1140,25 +335,25 @@ static const struct rt2800_ops rt2800pci_rt2800_ops = {
  .read_eeprom  = rt2800pci_read_eeprom,
  .hwcrypt_disabled = rt2800pci_hwcrypt_disabled,
  .drv_write_firmware = rt2800pci_write_firmware,
- .drv_init_registers = rt2800pci_init_registers,
- .drv_get_txwi  = rt2800pci_get_txwi,
+ .drv_init_registers = rt2800mmio_init_registers,
+ .drv_get_txwi  = rt2800mmio_get_txwi,
 };
 
 static const struct rt2x00lib_ops rt2800pci_rt2x00_ops = {
- .irq_handler  = rt2800pci_interrupt,
- .txstatus_tasklet = rt2800pci_txstatus_tasklet,
- .pretbtt_tasklet = rt2800pci_pretbtt_tasklet,
- .tbtt_tasklet  = rt2800pci_tbtt_tasklet,
- .rxdone_tasklet  = rt2800pci_rxdone_tasklet,
- .autowake_tasklet = rt2800pci_autowake_tasklet,
+ .irq_handler  = rt2800mmio_interrupt,
+ .txstatus_tasklet = rt2800mmio_txstatus_tasklet,
+ .pretbtt_tasklet = rt2800mmio_pretbtt_tasklet,
+ .tbtt_tasklet  = rt2800mmio_tbtt_tasklet,
+ .rxdone_tasklet  = rt2800mmio_rxdone_tasklet,
+ .autowake_tasklet = rt2800mmio_autowake_tasklet,
  .probe_hw  = rt2800_probe_hw,
  .get_firmware_name = rt2800pci_get_firmware_name,
  .check_firmware  = rt2800_check_firmware,
  .load_firmware  = rt2800_load_firmware,
  .initialize  = rt2x00mmio_initialize,
  .uninitialize  = rt2x00mmio_uninitialize,
- .get_entry_state = rt2800pci_get_entry_state,
- .clear_entry  = rt2800pci_clear_entry,
+ .get_entry_state = rt2800mmio_get_entry_state,
+ .clear_entry  = rt2800mmio_clear_entry,
  .set_device_state = rt2800pci_set_device_state,
  .rfkill_poll  = rt2800_rfkill_poll,
  .link_stats  = rt2800_link_stats,
@@ -1166,15 +361,15 @@ static const struct rt2x00lib_ops rt2800pci_rt2x00_ops = {
  .link_tuner  = rt2800_link_tuner,
  .gain_calibration = rt2800_gain_calibration,
  .vco_calibration = rt2800_vco_calibration,
- .start_queue  = rt2800pci_start_queue,
- .kick_queue  = rt2800pci_kick_queue,
- .stop_queue  = rt2800pci_stop_queue,
+ .start_queue  = rt2800mmio_start_queue,
+ .kick_queue  = rt2800mmio_kick_queue,
+ .stop_queue  = rt2800mmio_stop_queue,
  .flush_queue  = rt2x00mmio_flush_queue,
- .write_tx_desc  = rt2800pci_write_tx_desc,
+ .write_tx_desc  = rt2800mmio_write_tx_desc,
  .write_tx_data  = rt2800_write_tx_data,
  .write_beacon  = rt2800_write_beacon,
  .clear_beacon  = rt2800_clear_beacon,
- .fill_rxdone  = rt2800pci_fill_rxdone,
+ .fill_rxdone  = rt2800mmio_fill_rxdone,
  .config_shared_key = rt2800_config_shared_key,
  .config_pairwise_key = rt2800_config_pairwise_key,
  .config_filter  = rt2800_config_filter,
@@ -1186,30 +381,6 @@ static const struct rt2x00lib_ops rt2800pci_rt2x00_ops = {
  .sta_remove  = rt2800_sta_remove,
 };
 
-static const struct data_queue_desc rt2800pci_queue_rx = {
- .entry_num  = 128,
- .data_size  = AGGREGATION_SIZE,
- .desc_size  = RXD_DESC_SIZE,
- .winfo_size  = RXWI_DESC_SIZE,
- .priv_size  = sizeof(struct queue_entry_priv_mmio),
-};
-
-static const struct data_queue_desc rt2800pci_queue_tx = {
- .entry_num  = 64,
- .data_size  = AGGREGATION_SIZE,
- .desc_size  = TXD_DESC_SIZE,
- .winfo_size  = TXWI_DESC_SIZE,
- .priv_size  = sizeof(struct queue_entry_priv_mmio),
-};
-
-static const struct data_queue_desc rt2800pci_queue_bcn = {
- .entry_num  = 8,
- .data_size  = 0, /* No DMA required for beacons */
- .desc_size  = TXD_DESC_SIZE,
- .winfo_size  = TXWI_DESC_SIZE,
- .priv_size  = sizeof(struct queue_entry_priv_mmio),
-};
-
 static const struct rt2x00_ops rt2800pci_ops = {
  .name   = KBUILD_MODNAME,
  .drv_data_size  = sizeof(struct rt2800_drv_data),
@@ -1217,10 +388,7 @@ static const struct rt2x00_ops rt2800pci_ops = {
  .eeprom_size  = EEPROM_SIZE,
  .rf_size  = RF_SIZE,
  .tx_queues  = NUM_TX_QUEUES,
- .extra_tx_headroom = TXWI_DESC_SIZE,
- .rx   = &rt2800pci_queue_rx,
- .tx   = &rt2800pci_queue_tx,
- .bcn   = &rt2800pci_queue_bcn,
+ .queue_init  = rt2800mmio_queue_init,
  .lib   = &rt2800pci_rt2x00_ops,
  .drv   = &rt2800pci_rt2800_ops,
  .hw   = &rt2800pci_mac80211_ops,
@@ -1232,7 +400,6 @@ static const struct rt2x00_ops rt2800pci_ops = {
 /*
  * RT2800pci module information.
  */
-#ifdef CONFIG_PCI
 static DEFINE_PCI_DEVICE_TABLE(rt2800pci_device_table) = {
  { PCI_DEVICE(0x1814, 0x0601) },
  { PCI_DEVICE(0x1814, 0x0681) },
@@ -1277,38 +444,15 @@ static DEFINE_PCI_DEVICE_TABLE(rt2800pci_device_table) = {
 #endif
  { 0, }
 };
-#endif /* CONFIG_PCI */
 
 MODULE_AUTHOR(DRV_PROJECT);
 MODULE_VERSION(DRV_VERSION);
 MODULE_DESCRIPTION("Ralink RT2800 PCI & PCMCIA Wireless LAN driver.");
 MODULE_SUPPORTED_DEVICE("Ralink RT2860 PCI & PCMCIA chipset based cards");
-#ifdef CONFIG_PCI
 MODULE_FIRMWARE(FIRMWARE_RT2860);
 MODULE_DEVICE_TABLE(pci, rt2800pci_device_table);
-#endif /* CONFIG_PCI */
 MODULE_LICENSE("GPL");
 
-#if defined(CONFIG_SOC_RT288X) || defined(CONFIG_SOC_RT305X)
-static int rt2800soc_probe(struct platform_device *pdev)
-{
- return rt2x00soc_probe(pdev, &rt2800pci_ops);
-}
-
-static struct platform_driver rt2800soc_driver = {
- .driver  = {
-  .name  = "rt2800_wmac",
-  .owner  = THIS_MODULE,
-  .mod_name = KBUILD_MODNAME,
- },
- .probe  = rt2800soc_probe,
- .remove  = rt2x00soc_remove,
- .suspend = rt2x00soc_suspend,
- .resume  = rt2x00soc_resume,
-};
-#endif /* CONFIG_SOC_RT288X || CONFIG_SOC_RT305X */
-
-#ifdef CONFIG_PCI
 static int rt2800pci_probe(struct pci_dev *pci_dev,
       const struct pci_device_id *id)
 {
@@ -1323,39 +467,5 @@ static struct pci_driver rt2800pci_driver = {
  .suspend = rt2x00pci_suspend,
  .resume  = rt2x00pci_resume,
 };
-#endif /* CONFIG_PCI */
-
-static int __init rt2800pci_init(void)
-{
- int ret = 0;
-
-#if defined(CONFIG_SOC_RT288X) || defined(CONFIG_SOC_RT305X)
- ret = platform_driver_register(&rt2800soc_driver);
- if (ret)
-  return ret;
-#endif
-#ifdef CONFIG_PCI
- ret = pci_register_driver(&rt2800pci_driver);
- if (ret) {
-#if defined(CONFIG_SOC_RT288X) || defined(CONFIG_SOC_RT305X)
-  platform_driver_unregister(&rt2800soc_driver);
-#endif
-  return ret;
- }
-#endif
-
- return ret;
-}
-
-static void __exit rt2800pci_exit(void)
-{
-#ifdef CONFIG_PCI
- pci_unregister_driver(&rt2800pci_driver);
-#endif
-#if defined(CONFIG_SOC_RT288X) || defined(CONFIG_SOC_RT305X)
- platform_driver_unregister(&rt2800soc_driver);
-#endif
-}
 
-module_init(rt2800pci_init);
-module_exit(rt2800pci_exit);
+module_pci_driver(rt2800pci_driver);
diff --git a/drivers/net/wireless/rt2x00/rt2800pci.c.rej b/drivers/net/wireless/rt2x00/rt2800pci.c.rej
new file mode 100644
index 0000000..dd347bc
--- /dev/null
+++ b/drivers/net/wireless/rt2x00/rt2800pci.c.rej
@@ -0,0 +1,482 @@
+--- drivers/net/wireless/rt2x00/rt2800pci.c
++++ drivers/net/wireless/rt2x00/rt2800pci.c
+@@ -283,478 +-57,13 @@
+ }
+ 
+ /*
+- * TX descriptor initialization
+- */
+-static __le32 *rt2800pci_get_txwi(struct queue_entry *entry)
+-{
+- return (__le32 *) entry->skb->data;
+-}
+-
+-static void rt2800pci_write_tx_desc(struct queue_entry *entry,
+-        struct txentry_desc *txdesc)
+-{
+- struct skb_frame_desc *skbdesc = get_skb_frame_desc(entry->skb);
+- struct queue_entry_priv_mmio *entry_priv = entry->priv_data;
+- __le32 *txd = entry_priv->desc;
+- u32 word;
+-
+- /*
+-  * The buffers pointed by SD_PTR0/SD_LEN0 and SD_PTR1/SD_LEN1
+-  * must contains a TXWI structure + 802.11 header + padding + 802.11
+-  * data. We choose to have SD_PTR0/SD_LEN0 only contains TXWI and
+-  * SD_PTR1/SD_LEN1 contains 802.11 header + padding + 802.11
+-  * data. It means that LAST_SEC0 is always 0.
+-  */
+-
+- /*
+-  * Initialize TX descriptor
+-  */
+- word = 0;
+- rt2x00_set_field32(&word, TXD_W0_SD_PTR0, skbdesc->skb_dma);
+- rt2x00_desc_write(txd, 0, word);
+-
+- word = 0;
+- rt2x00_set_field32(&word, TXD_W1_SD_LEN1, entry->skb->len);
+- rt2x00_set_field32(&word, TXD_W1_LAST_SEC1,
+-      !test_bit(ENTRY_TXD_MORE_FRAG, &txdesc->flags));
+- rt2x00_set_field32(&word, TXD_W1_BURST,
+-      test_bit(ENTRY_TXD_BURST, &txdesc->flags));
+- rt2x00_set_field32(&word, TXD_W1_SD_LEN0, TXWI_DESC_SIZE);
+- rt2x00_set_field32(&word, TXD_W1_LAST_SEC0, 0);
+- rt2x00_set_field32(&word, TXD_W1_DMA_DONE, 0);
+- rt2x00_desc_write(txd, 1, word);
+-
+- word = 0;
+- rt2x00_set_field32(&word, TXD_W2_SD_PTR1,
+-      skbdesc->skb_dma + TXWI_DESC_SIZE);
+- rt2x00_desc_write(txd, 2, word);
+-
+- word = 0;
+- rt2x00_set_field32(&word, TXD_W3_WIV,
+-      !test_bit(ENTRY_TXD_ENCRYPT_IV, &txdesc->flags));
+- rt2x00_set_field32(&word, TXD_W3_QSEL, 2);
+- rt2x00_desc_write(txd, 3, word);
+-
+- /*
+-  * Register descriptor details in skb frame descriptor.
+-  */
+- skbdesc->desc = txd;
+- skbdesc->desc_len = TXD_DESC_SIZE;
+-}
+-
+-/*
+- * RX control handlers
+- */
+-static void rt2800pci_fill_rxdone(struct queue_entry *entry,
+-      struct rxdone_entry_desc *rxdesc)
+-{
+- struct queue_entry_priv_mmio *entry_priv = entry->priv_data;
+- __le32 *rxd = entry_priv->desc;
+- u32 word;
+-
+- rt2x00_desc_read(rxd, 3, &word);
+-
+- if (rt2x00_get_field32(word, RXD_W3_CRC_ERROR))
+-  rxdesc->flags |= RX_FLAG_FAILED_FCS_CRC;
+-
+- /*
+-  * Unfortunately we don't know the cipher type used during
+-  * decryption. This prevents us from correct providing
+-  * correct statistics through debugfs.
+-  */
+- rxdesc->cipher_status = rt2x00_get_field32(word, RXD_W3_CIPHER_ERROR);
+-
+- if (rt2x00_get_field32(word, RXD_W3_DECRYPTED)) {
+-  /*
+-   * Hardware has stripped IV/EIV data from 802.11 frame during
+-   * decryption. Unfortunately the descriptor doesn't contain
+-   * any fields with the EIV/IV data either, so they can't
+-   * be restored by rt2x00lib.
+-   */
+-  rxdesc->flags |= RX_FLAG_IV_STRIPPED;
+-
+-  /*
+-   * The hardware has already checked the Michael Mic and has
+-   * stripped it from the frame. Signal this to mac80211.
+-   */
+-  rxdesc->flags |= RX_FLAG_MMIC_STRIPPED;
+-
+-  if (rxdesc->cipher_status == RX_CRYPTO_SUCCESS)
+-   rxdesc->flags |= RX_FLAG_DECRYPTED;
+-  else if (rxdesc->cipher_status == RX_CRYPTO_FAIL_MIC)
+-   rxdesc->flags |= RX_FLAG_MMIC_ERROR;
+- }
+-
+- if (rt2x00_get_field32(word, RXD_W3_MY_BSS))
+-  rxdesc->dev_flags |= RXDONE_MY_BSS;
+-
+- if (rt2x00_get_field32(word, RXD_W3_L2PAD))
+-  rxdesc->dev_flags |= RXDONE_L2PAD;
+-
+- /*
+-  * Process the RXWI structure that is at the start of the buffer.
+-  */
+- rt2800_process_rxwi(entry, rxdesc);
+-}
+-
+-/*
+- * Interrupt functions.
+- */
+-static void rt2800pci_wakeup(struct rt2x00_dev *rt2x00dev)
+-{
+- struct ieee80211_conf conf = { .flags = 0 };
+- struct rt2x00lib_conf libconf = { .conf = &conf };
+-
+- rt2800_config(rt2x00dev, &libconf, IEEE80211_CONF_CHANGE_PS);
+-}
+-
+-static bool rt2800pci_txdone_entry_check(struct queue_entry *entry, u32 status)
+-{
+- __le32 *txwi;
+- u32 word;
+- int wcid, tx_wcid;
+-
+- wcid = rt2x00_get_field32(status, TX_STA_FIFO_WCID);
+-
+- txwi = rt2800_drv_get_txwi(entry);
+- rt2x00_desc_read(txwi, 1, &word);
+- tx_wcid = rt2x00_get_field32(word, TXWI_W1_WIRELESS_CLI_ID);
+-
+- return (tx_wcid == wcid);
+-}
+-
+-static bool rt2800pci_txdone_find_entry(struct queue_entry *entry, void *data)
+-{
+- u32 status = *(u32 *)data;
+-
+- /*
+-  * rt2800pci hardware might reorder frames when exchanging traffic
+-  * with multiple BA enabled STAs.
+-  *
+-  * For example, a tx queue
+-  *    [ STA1 | STA2 | STA1 | STA2 ]
+-  * can result in tx status reports
+-  *    [ STA1 | STA1 | STA2 | STA2 ]
+-  * when the hw decides to aggregate the frames for STA1 into one AMPDU.
+-  *
+-  * To mitigate this effect, associate the tx status to the first frame
+-  * in the tx queue with a matching wcid.
+-  */
+- if (rt2800pci_txdone_entry_check(entry, status) &&
+-     !test_bit(ENTRY_DATA_STATUS_SET, &entry->flags)) {
+-  /*
+-   * Got a matching frame, associate the tx status with
+-   * the frame
+-   */
+-  entry->status = status;
+-  set_bit(ENTRY_DATA_STATUS_SET, &entry->flags);
+-  return true;
+- }
+-
+- /* Check the next frame */
+- return false;
+-}
+-
+-static bool rt2800pci_txdone_match_first(struct queue_entry *entry, void *data)
+-{
+- u32 status = *(u32 *)data;
+-
+- /*
+-  * Find the first frame without tx status and assign this status to it
+-  * regardless if it matches or not.
+-  */
+- if (!test_bit(ENTRY_DATA_STATUS_SET, &entry->flags)) {
+-  /*
+-   * Got a matching frame, associate the tx status with
+-   * the frame
+-   */
+-  entry->status = status;
+-  set_bit(ENTRY_DATA_STATUS_SET, &entry->flags);
+-  return true;
+- }
+-
+- /* Check the next frame */
+- return false;
+-}
+-static bool rt2800pci_txdone_release_entries(struct queue_entry *entry,
+-          void *data)
+-{
+- if (test_bit(ENTRY_DATA_STATUS_SET, &entry->flags)) {
+-  rt2800_txdone_entry(entry, entry->status,
+-        rt2800pci_get_txwi(entry));
+-  return false;
+- }
+-
+- /* No more frames to release */
+- return true;
+-}
+-
+-static bool rt2800pci_txdone(struct rt2x00_dev *rt2x00dev)
+-{
+- struct data_queue *queue;
+- u32 status;
+- u8 qid;
+- int max_tx_done = 16;
+-
+- while (kfifo_get(&rt2x00dev->txstatus_fifo, &status)) {
+-  qid = rt2x00_get_field32(status, TX_STA_FIFO_PID_QUEUE);
+-  if (unlikely(qid >= QID_RX)) {
+-   /*
+-    * Unknown queue, this shouldn't happen. Just drop
+-    * this tx status.
+-    */
+-   rt2x00_warn(rt2x00dev, "Got TX status report with unexpected pid %u, dropping\n",
+-        qid);
+-   break;
+-  }
+-
+-  queue = rt2x00queue_get_tx_queue(rt2x00dev, qid);
+-  if (unlikely(queue == NULL)) {
+-   /*
+-    * The queue is NULL, this shouldn't happen. Stop
+-    * processing here and drop the tx status
+-    */
+-   rt2x00_warn(rt2x00dev, "Got TX status for an unavailable queue %u, dropping\n",
+-        qid);
+-   break;
+-  }
+-
+-  if (unlikely(rt2x00queue_empty(queue))) {
+-   /*
+-    * The queue is empty. Stop processing here
+-    * and drop the tx status.
+-    */
+-   rt2x00_warn(rt2x00dev, "Got TX status for an empty queue %u, dropping\n",
+-        qid);
+-   break;
+-  }
+-
+-  /*
+-   * Let's associate this tx status with the first
+-   * matching frame.
+-   */
+-  if (!rt2x00queue_for_each_entry(queue, Q_INDEX_DONE,
+-      Q_INDEX, &status,
+-      rt2800pci_txdone_find_entry)) {
+-   /*
+-    * We cannot match the tx status to any frame, so just
+-    * use the first one.
+-    */
+-   if (!rt2x00queue_for_each_entry(queue, Q_INDEX_DONE,
+-       Q_INDEX, &status,
+-       rt2800pci_txdone_match_first)) {
+-    rt2x00_warn(rt2x00dev, "No frame found for TX status on queue %u, dropping\n",
+-         qid);
+-    break;
+-   }
+-  }
+-
+-  /*
+-   * Release all frames with a valid tx status.
+-   */
+-  rt2x00queue_for_each_entry(queue, Q_INDEX_DONE,
+-        Q_INDEX, NULL,
+-        rt2800pci_txdone_release_entries);
+-
+-  if (--max_tx_done == 0)
+-   break;
+- }
+-
+- return !max_tx_done;
+-}
+-
+-static inline void rt2800pci_enable_interrupt(struct rt2x00_dev *rt2x00dev,
+-           struct rt2x00_field32 irq_field)
+-{
+- u32 reg;
+-
+- /*
+-  * Enable a single interrupt. The interrupt mask register
+-  * access needs locking.
+-  */
+- spin_lock_irq(&rt2x00dev->irqmask_lock);
+- rt2x00mmio_register_read(rt2x00dev, INT_MASK_CSR, &reg);
+- rt2x00_set_field32(&reg, irq_field, 1);
+- rt2x00mmio_register_write(rt2x00dev, INT_MASK_CSR, reg);
+- spin_unlock_irq(&rt2x00dev->irqmask_lock);
+-}
+-
+-static void rt2800pci_txstatus_tasklet(unsigned long data)
+-{
+- struct rt2x00_dev *rt2x00dev = (struct rt2x00_dev *)data;
+- if (rt2800pci_txdone(rt2x00dev))
+-  tasklet_schedule(&rt2x00dev->txstatus_tasklet);
+-
+- /*
+-  * No need to enable the tx status interrupt here as we always
+-  * leave it enabled to minimize the possibility of a tx status
+-  * register overflow. See comment in interrupt handler.
+-  */
+-}
+-
+-static void rt2800pci_pretbtt_tasklet(unsigned long data)
+-{
+- struct rt2x00_dev *rt2x00dev = (struct rt2x00_dev *)data;
+- rt2x00lib_pretbtt(rt2x00dev);
+- if (test_bit(DEVICE_STATE_ENABLED_RADIO, &rt2x00dev->flags))
+-  rt2800pci_enable_interrupt(rt2x00dev, INT_MASK_CSR_PRE_TBTT);
+-}
+-
+-static void rt2800pci_tbtt_tasklet(unsigned long data)
+-{
+- struct rt2x00_dev *rt2x00dev = (struct rt2x00_dev *)data;
+- struct rt2800_drv_data *drv_data = rt2x00dev->drv_data;
+- u32 reg;
+-
+- rt2x00lib_beacondone(rt2x00dev);
+-
+- if (rt2x00dev->intf_ap_count) {
+-  /*
+-   * The rt2800pci hardware tbtt timer is off by 1us per tbtt
+-   * causing beacon skew and as a result causing problems with
+-   * some powersaving clients over time. Shorten the beacon
+-   * interval every 64 beacons by 64us to mitigate this effect.
+-   */
+-  if (drv_data->tbtt_tick == (BCN_TBTT_OFFSET - 2)) {
+-   rt2x00mmio_register_read(rt2x00dev, BCN_TIME_CFG, &reg);
+-   rt2x00_set_field32(&reg, BCN_TIME_CFG_BEACON_INTERVAL,
+-        (rt2x00dev->beacon_int * 16) - 1);
+-   rt2x00mmio_register_write(rt2x00dev, BCN_TIME_CFG, reg);
+-  } else if (drv_data->tbtt_tick == (BCN_TBTT_OFFSET - 1)) {
+-   rt2x00mmio_register_read(rt2x00dev, BCN_TIME_CFG, &reg);
+-   rt2x00_set_field32(&reg, BCN_TIME_CFG_BEACON_INTERVAL,
+-        (rt2x00dev->beacon_int * 16));
+-   rt2x00mmio_register_write(rt2x00dev, BCN_TIME_CFG, reg);
+-  }
+-  drv_data->tbtt_tick++;
+-  drv_data->tbtt_tick %= BCN_TBTT_OFFSET;
+- }
+-
+- if (test_bit(DEVICE_STATE_ENABLED_RADIO, &rt2x00dev->flags))
+-  rt2800pci_enable_interrupt(rt2x00dev, INT_MASK_CSR_TBTT);
+-}
+-
+-static void rt2800pci_rxdone_tasklet(unsigned long data)
+-{
+- struct rt2x00_dev *rt2x00dev = (struct rt2x00_dev *)data;
+- if (rt2x00mmio_rxdone(rt2x00dev))
+-  tasklet_schedule(&rt2x00dev->rxdone_tasklet);
+- else if (test_bit(DEVICE_STATE_ENABLED_RADIO, &rt2x00dev->flags))
+-  rt2800pci_enable_interrupt(rt2x00dev, INT_MASK_CSR_RX_DONE);
+-}
+-
+-static void rt2800pci_autowake_tasklet(unsigned long data)
+-{
+- struct rt2x00_dev *rt2x00dev = (struct rt2x00_dev *)data;
+- rt2800pci_wakeup(rt2x00dev);
+- if (test_bit(DEVICE_STATE_ENABLED_RADIO, &rt2x00dev->flags))
+-  rt2800pci_enable_interrupt(rt2x00dev, INT_MASK_CSR_AUTO_WAKEUP);
+-}
+-
+-static void rt2800pci_txstatus_interrupt(struct rt2x00_dev *rt2x00dev)
+-{
+- u32 status;
+- int i;
+-
+- /*
+-  * The TX_FIFO_STATUS interrupt needs special care. We should
+-  * read TX_STA_FIFO but we should do it immediately as otherwise
+-  * the register can overflow and we would lose status reports.
+-  *
+-  * Hence, read the TX_STA_FIFO register and copy all tx status
+-  * reports into a kernel FIFO which is handled in the txstatus
+-  * tasklet. We use a tasklet to process the tx status reports
+-  * because we can schedule the tasklet multiple times (when the
+-  * interrupt fires again during tx status processing).
+-  *
+-  * Furthermore we don't disable the TX_FIFO_STATUS
+-  * interrupt here but leave it enabled so that the TX_STA_FIFO
+-  * can also be read while the tx status tasklet gets executed.
+-  *
+-  * Since we have only one producer and one consumer we don't
+-  * need to lock the kfifo.
+-  */
+- for (i = 0; i < rt2x00dev->ops->tx->entry_num; i++) {
+-  rt2x00mmio_register_read(rt2x00dev, TX_STA_FIFO, &status);
+-
+-  if (!rt2x00_get_field32(status, TX_STA_FIFO_VALID))
+-   break;
+-
+-  if (!kfifo_put(&rt2x00dev->txstatus_fifo, status)) {
+-   rt2x00_warn(rt2x00dev, "TX status FIFO overrun, drop tx status report\n");
+-   break;
+-  }
+- }
+-
+- /* Schedule the tasklet for processing the tx status. */
+- tasklet_schedule(&rt2x00dev->txstatus_tasklet);
+-}
+-
+-static irqreturn_t rt2800pci_interrupt(int irq, void *dev_instance)
+-{
+- struct rt2x00_dev *rt2x00dev = dev_instance;
+- u32 reg, mask;
+-
+- /* Read status and ACK all interrupts */
+- rt2x00mmio_register_read(rt2x00dev, INT_SOURCE_CSR, &reg);
+- rt2x00mmio_register_write(rt2x00dev, INT_SOURCE_CSR, reg);
+-
+- if (!reg)
+-  return IRQ_NONE;
+-
+- if (!test_bit(DEVICE_STATE_ENABLED_RADIO, &rt2x00dev->flags))
+-  return IRQ_HANDLED;
+-
+- /*
+-  * Since INT_MASK_CSR and INT_SOURCE_CSR use the same bits
+-  * for interrupts and interrupt masks we can just use the value of
+-  * INT_SOURCE_CSR to create the interrupt mask.
+-  */
+- mask = ~reg;
+-
+- if (rt2x00_get_field32(reg, INT_SOURCE_CSR_TX_FIFO_STATUS)) {
+-  rt2800pci_txstatus_interrupt(rt2x00dev);
+-  /*
+-   * Never disable the TX_FIFO_STATUS interrupt.
+-   */
+-  rt2x00_set_field32(&mask, INT_MASK_CSR_TX_FIFO_STATUS, 1);
+- }
+-
+- if (rt2x00_get_field32(reg, INT_SOURCE_CSR_PRE_TBTT))
+-  tasklet_hi_schedule(&rt2x00dev->pretbtt_tasklet);
+-
+- if (rt2x00_get_field32(reg, INT_SOURCE_CSR_TBTT))
+-  tasklet_hi_schedule(&rt2x00dev->tbtt_tasklet);
+-
+- if (rt2x00_get_field32(reg, INT_SOURCE_CSR_RX_DONE))
+-  tasklet_schedule(&rt2x00dev->rxdone_tasklet);
+-
+- if (rt2x00_get_field32(reg, INT_SOURCE_CSR_AUTO_WAKEUP))
+-  tasklet_schedule(&rt2x00dev->autowake_tasklet);
+-
+- /*
+-  * Disable all interrupts for which a tasklet was scheduled right now,
+-  * the tasklet will reenable the appropriate interrupts.
+-  */
+- spin_lock(&rt2x00dev->irqmask_lock);
+- rt2x00mmio_register_read(rt2x00dev, INT_MASK_CSR, &reg);
+- reg &= mask;
+- rt2x00mmio_register_write(rt2x00dev, INT_MASK_CSR, reg);
+- spin_unlock(&rt2x00dev->irqmask_lock);
+-
+- return IRQ_HANDLED;
+-}
+-
+-/*
+  * Device probe functions.
+  */
+ static int rt2800pci_read_eeprom(struct rt2x00_dev *rt2x00dev)
+ {
+  int retval;
+ 
+- if (rt2x00_is_soc(rt2x00dev))
+-  retval = rt2800pci_read_eeprom_soc(rt2x00dev);
+- else if (rt2800pci_efuse_detect(rt2x00dev))
++ if (rt2800pci_efuse_detect(rt2x00dev))
+   retval = rt2800pci_read_eeprom_efuse(rt2x00dev);
+  else
+   retval = rt2800pci_read_eeprom_pci(rt2x00dev);
diff --git a/drivers/net/wireless/rt2x00/rt2800pci.h b/drivers/net/wireless/rt2x00/rt2800pci.h
index ab22a08..9dfef46 100644
--- a/drivers/net/wireless/rt2x00/rt2800pci.h
+++ b/drivers/net/wireless/rt2x00/rt2800pci.h
@@ -20,9 +20,7 @@
  GNU General Public License for more details.
 
  You should have received a copy of the GNU General Public License
- along with this program; if not, write to the
- Free Software Foundation, Inc.,
- 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ along with this program; if not, see <http://www.gnu.org/licenses/>.
  */
 
 /*
@@ -35,107 +33,10 @@
 #define RT2800PCI_H
 
 /*
- * Queue register offset macros
- */
-#define TX_QUEUE_REG_OFFSET  0x10
-#define TX_BASE_PTR(__x)  (TX_BASE_PTR0 + ((__x) * TX_QUEUE_REG_OFFSET))
-#define TX_MAX_CNT(__x)   (TX_MAX_CNT0 + ((__x) * TX_QUEUE_REG_OFFSET))
-#define TX_CTX_IDX(__x)   (TX_CTX_IDX0 + ((__x) * TX_QUEUE_REG_OFFSET))
-#define TX_DTX_IDX(__x)   (TX_DTX_IDX0 + ((__x) * TX_QUEUE_REG_OFFSET))
-
-/*
  * 8051 firmware image.
  */
 #define FIRMWARE_RT2860   "rt2860.bin"
 #define FIRMWARE_RT3290   "rt3290.bin"
 #define FIRMWARE_IMAGE_BASE  0x2000
 
-/*
- * DMA descriptor defines.
- */
-#define TXD_DESC_SIZE   (4 * sizeof(__le32))
-#define RXD_DESC_SIZE   (4 * sizeof(__le32))
-
-/*
- * TX descriptor format for TX, PRIO and Beacon Ring.
- */
-
-/*
- * Word0
- */
-#define TXD_W0_SD_PTR0   FIELD32(0xffffffff)
-
-/*
- * Word1
- */
-#define TXD_W1_SD_LEN1   FIELD32(0x00003fff)
-#define TXD_W1_LAST_SEC1  FIELD32(0x00004000)
-#define TXD_W1_BURST   FIELD32(0x00008000)
-#define TXD_W1_SD_LEN0   FIELD32(0x3fff0000)
-#define TXD_W1_LAST_SEC0  FIELD32(0x40000000)
-#define TXD_W1_DMA_DONE   FIELD32(0x80000000)
-
-/*
- * Word2
- */
-#define TXD_W2_SD_PTR1   FIELD32(0xffffffff)
-
-/*
- * Word3
- * WIV: Wireless Info Valid. 1: Driver filled WI, 0: DMA needs to copy WI
- * QSEL: Select on-chip FIFO ID for 2nd-stage output scheduler.
- *       0:MGMT, 1:HCCA 2:EDCA
- */
-#define TXD_W3_WIV   FIELD32(0x01000000)
-#define TXD_W3_QSEL   FIELD32(0x06000000)
-#define TXD_W3_TCO   FIELD32(0x20000000)
-#define TXD_W3_UCO   FIELD32(0x40000000)
-#define TXD_W3_ICO   FIELD32(0x80000000)
-
-/*
- * RX descriptor format for RX Ring.
- */
-
-/*
- * Word0
- */
-#define RXD_W0_SDP0   FIELD32(0xffffffff)
-
-/*
- * Word1
- */
-#define RXD_W1_SDL1   FIELD32(0x00003fff)
-#define RXD_W1_SDL0   FIELD32(0x3fff0000)
-#define RXD_W1_LS0   FIELD32(0x40000000)
-#define RXD_W1_DMA_DONE   FIELD32(0x80000000)
-
-/*
- * Word2
- */
-#define RXD_W2_SDP1   FIELD32(0xffffffff)
-
-/*
- * Word3
- * AMSDU: RX with 802.3 header, not 802.11 header.
- * DECRYPTED: This frame is being decrypted.
- */
-#define RXD_W3_BA   FIELD32(0x00000001)
-#define RXD_W3_DATA   FIELD32(0x00000002)
-#define RXD_W3_NULLDATA   FIELD32(0x00000004)
-#define RXD_W3_FRAG   FIELD32(0x00000008)
-#define RXD_W3_UNICAST_TO_ME  FIELD32(0x00000010)
-#define RXD_W3_MULTICAST  FIELD32(0x00000020)
-#define RXD_W3_BROADCAST  FIELD32(0x00000040)
-#define RXD_W3_MY_BSS   FIELD32(0x00000080)
-#define RXD_W3_CRC_ERROR  FIELD32(0x00000100)
-#define RXD_W3_CIPHER_ERROR  FIELD32(0x00000600)
-#define RXD_W3_AMSDU   FIELD32(0x00000800)
-#define RXD_W3_HTC   FIELD32(0x00001000)
-#define RXD_W3_RSSI   FIELD32(0x00002000)
-#define RXD_W3_L2PAD   FIELD32(0x00004000)
-#define RXD_W3_AMPDU   FIELD32(0x00008000)
-#define RXD_W3_DECRYPTED  FIELD32(0x00010000)
-#define RXD_W3_PLCP_SIGNAL  FIELD32(0x00020000)
-#define RXD_W3_PLCP_RSSI  FIELD32(0x00040000)
-
 #endif /* RT2800PCI_H */
diff --git a/drivers/net/wireless/rt2x00/rt2800soc.c b/drivers/net/wireless/rt2x00/rt2800soc.c
new file mode 100644
index 0000000..f6d1bf5
--- /dev/null
+++ b/drivers/net/wireless/rt2x00/rt2800soc.c
@@ -0,0 +1,261 @@
+/* Copyright (C) 2009 - 2010 Ivo van Doorn <IvDoorn@gmail.com>
+ * Copyright (C) 2009 Alban Browaeys <prahal@yahoo.com>
+ * Copyright (C) 2009 Felix Fietkau <nbd@openwrt.org>
+ * Copyright (C) 2009 Luis Correia <luis.f.correia@gmail.com>
+ * Copyright (C) 2009 Mattias Nissler <mattias.nissler@gmx.de>
+ * Copyright (C) 2009 Mark Asselstine <asselsm@gmail.com>
+ * Copyright (C) 2009 Xose Vazquez Perez <xose.vazquez@gmail.com>
+ * Copyright (C) 2009 Bart Zolnierkiewicz <bzolnier@gmail.com>
+ * <http://rt2x00.serialmonkey.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+/* Module: rt2800soc
+ * Abstract: rt2800 WiSoC specific routines.
+ */
+
+#include <linux/etherdevice.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+
+#include "rt2x00.h"
+#include "rt2x00mmio.h"
+#include "rt2x00soc.h"
+#include "rt2800.h"
+#include "rt2800lib.h"
+#include "rt2800mmio.h"
+
+/* Allow hardware encryption to be disabled. */
+static bool modparam_nohwcrypt;
+module_param_named(nohwcrypt, modparam_nohwcrypt, bool, S_IRUGO);
+MODULE_PARM_DESC(nohwcrypt, "Disable hardware encryption.");
+
+static bool rt2800soc_hwcrypt_disabled(struct rt2x00_dev *rt2x00dev)
+{
+ return modparam_nohwcrypt;
+}
+
+static void rt2800soc_disable_radio(struct rt2x00_dev *rt2x00dev)
+{
+ rt2800_disable_radio(rt2x00dev);
+ rt2x00mmio_register_write(rt2x00dev, PWR_PIN_CFG, 0);
+ rt2x00mmio_register_write(rt2x00dev, TX_PIN_CFG, 0);
+}
+
+static int rt2800soc_set_device_state(struct rt2x00_dev *rt2x00dev,
+          enum dev_state state)
+{
+ int retval = 0;
+
+ switch (state) {
+ case STATE_RADIO_ON:
+  retval = rt2800mmio_enable_radio(rt2x00dev);
+  break;
+
+ case STATE_RADIO_OFF:
+  rt2800soc_disable_radio(rt2x00dev);
+  break;
+
+ case STATE_RADIO_IRQ_ON:
+ case STATE_RADIO_IRQ_OFF:
+  rt2800mmio_toggle_irq(rt2x00dev, state);
+  break;
+
+ case STATE_DEEP_SLEEP:
+ case STATE_SLEEP:
+ case STATE_STANDBY:
+ case STATE_AWAKE:
+  /* These states are not supported, but don't report an error */
+  retval = 0;
+  break;
+
+ default:
+  retval = -ENOTSUPP;
+  break;
+ }
+
+ if (unlikely(retval))
+  rt2x00_err(rt2x00dev, "Device failed to enter state %d (%d)\n",
+      state, retval);
+
+ return retval;
+}
+
+static int rt2800soc_read_eeprom(struct rt2x00_dev *rt2x00dev)
+{
+ void __iomem *base_addr = ioremap(0x1F040000, EEPROM_SIZE);
+
+ if (!base_addr)
+  return -ENOMEM;
+
+ memcpy_fromio(rt2x00dev->eeprom, base_addr, EEPROM_SIZE);
+
+ iounmap(base_addr);
+ return 0;
+}
+
+/* Firmware functions */
+static char *rt2800soc_get_firmware_name(struct rt2x00_dev *rt2x00dev)
+{
+ WARN_ON_ONCE(1);
+ return NULL;
+}
+
+static int rt2800soc_load_firmware(struct rt2x00_dev *rt2x00dev,
+       const u8 *data, const size_t len)
+{
+ WARN_ON_ONCE(1);
+ return 0;
+}
+
+static int rt2800soc_check_firmware(struct rt2x00_dev *rt2x00dev,
+        const u8 *data, const size_t len)
+{
+ WARN_ON_ONCE(1);
+ return 0;
+}
+
+static int rt2800soc_write_firmware(struct rt2x00_dev *rt2x00dev,
+        const u8 *data, const size_t len)
+{
+ WARN_ON_ONCE(1);
+ return 0;
+}
+
+static const struct ieee80211_ops rt2800soc_mac80211_ops = {
+ .tx   = rt2x00mac_tx,
+ .start   = rt2x00mac_start,
+ .stop   = rt2x00mac_stop,
+ .add_interface  = rt2x00mac_add_interface,
+ .remove_interface = rt2x00mac_remove_interface,
+ .config   = rt2x00mac_config,
+ .configure_filter = rt2x00mac_configure_filter,
+ .set_key  = rt2x00mac_set_key,
+ .sw_scan_start  = rt2x00mac_sw_scan_start,
+ .sw_scan_complete = rt2x00mac_sw_scan_complete,
+ .get_stats  = rt2x00mac_get_stats,
+ .get_tkip_seq  = rt2800_get_tkip_seq,
+ .set_rts_threshold = rt2800_set_rts_threshold,
+ .sta_add  = rt2x00mac_sta_add,
+ .sta_remove  = rt2x00mac_sta_remove,
+ .bss_info_changed = rt2x00mac_bss_info_changed,
+ .conf_tx  = rt2800_conf_tx,
+ .get_tsf  = rt2800_get_tsf,
+ .rfkill_poll  = rt2x00mac_rfkill_poll,
+ .ampdu_action  = rt2800_ampdu_action,
+ .flush   = rt2x00mac_flush,
+ .get_survey  = rt2800_get_survey,
+ .get_ringparam  = rt2x00mac_get_ringparam,
+ .tx_frames_pending = rt2x00mac_tx_frames_pending,
+};
+
+static const struct rt2800_ops rt2800soc_rt2800_ops = {
+ .register_read  = rt2x00mmio_register_read,
+ .register_read_lock = rt2x00mmio_register_read, /* same for SoCs */
+ .register_write  = rt2x00mmio_register_write,
+ .register_write_lock = rt2x00mmio_register_write, /* same for SoCs */
+ .register_multiread = rt2x00mmio_register_multiread,
+ .register_multiwrite = rt2x00mmio_register_multiwrite,
+ .regbusy_read  = rt2x00mmio_regbusy_read,
+ .read_eeprom  = rt2800soc_read_eeprom,
+ .hwcrypt_disabled = rt2800soc_hwcrypt_disabled,
+ .drv_write_firmware = rt2800soc_write_firmware,
+ .drv_init_registers = rt2800mmio_init_registers,
+ .drv_get_txwi  = rt2800mmio_get_txwi,
+};
+
+static const struct rt2x00lib_ops rt2800soc_rt2x00_ops = {
+ .irq_handler  = rt2800mmio_interrupt,
+ .txstatus_tasklet = rt2800mmio_txstatus_tasklet,
+ .pretbtt_tasklet = rt2800mmio_pretbtt_tasklet,
+ .tbtt_tasklet  = rt2800mmio_tbtt_tasklet,
+ .rxdone_tasklet  = rt2800mmio_rxdone_tasklet,
+ .autowake_tasklet = rt2800mmio_autowake_tasklet,
+ .probe_hw  = rt2800_probe_hw,
+ .get_firmware_name = rt2800soc_get_firmware_name,
+ .check_firmware  = rt2800soc_check_firmware,
+ .load_firmware  = rt2800soc_load_firmware,
+ .initialize  = rt2x00mmio_initialize,
+ .uninitialize  = rt2x00mmio_uninitialize,
+ .get_entry_state = rt2800mmio_get_entry_state,
+ .clear_entry  = rt2800mmio_clear_entry,
+ .set_device_state = rt2800soc_set_device_state,
+ .rfkill_poll  = rt2800_rfkill_poll,
+ .link_stats  = rt2800_link_stats,
+ .reset_tuner  = rt2800_reset_tuner,
+ .link_tuner  = rt2800_link_tuner,
+ .gain_calibration = rt2800_gain_calibration,
+ .vco_calibration = rt2800_vco_calibration,
+ .start_queue  = rt2800mmio_start_queue,
+ .kick_queue  = rt2800mmio_kick_queue,
+ .stop_queue  = rt2800mmio_stop_queue,
+ .flush_queue  = rt2x00mmio_flush_queue,
+ .write_tx_desc  = rt2800mmio_write_tx_desc,
+ .write_tx_data  = rt2800_write_tx_data,
+ .write_beacon  = rt2800_write_beacon,
+ .clear_beacon  = rt2800_clear_beacon,
+ .fill_rxdone  = rt2800mmio_fill_rxdone,
+ .config_shared_key = rt2800_config_shared_key,
+ .config_pairwise_key = rt2800_config_pairwise_key,
+ .config_filter  = rt2800_config_filter,
+ .config_intf  = rt2800_config_intf,
+ .config_erp  = rt2800_config_erp,
+ .config_ant  = rt2800_config_ant,
+ .config   = rt2800_config,
+ .sta_add  = rt2800_sta_add,
+ .sta_remove  = rt2800_sta_remove,
+};
+
+static const struct rt2x00_ops rt2800soc_ops = {
+ .name   = KBUILD_MODNAME,
+ .drv_data_size  = sizeof(struct rt2800_drv_data),
+ .max_ap_intf  = 8,
+ .eeprom_size  = EEPROM_SIZE,
+ .rf_size  = RF_SIZE,
+ .tx_queues  = NUM_TX_QUEUES,
+ .queue_init  = rt2800mmio_queue_init,
+ .lib   = &rt2800soc_rt2x00_ops,
+ .drv   = &rt2800soc_rt2800_ops,
+ .hw   = &rt2800soc_mac80211_ops,
+#ifdef CONFIG_RT2X00_LIB_DEBUGFS
+ .debugfs  = &rt2800_rt2x00debug,
+#endif /* CONFIG_RT2X00_LIB_DEBUGFS */
+};
+
+static int rt2800soc_probe(struct platform_device *pdev)
+{
+ return rt2x00soc_probe(pdev, &rt2800soc_ops);
+}
+
+static struct platform_driver rt2800soc_driver = {
+ .driver  = {
+  .name  = "rt2800_wmac",
+  .owner  = THIS_MODULE,
+  .mod_name = KBUILD_MODNAME,
+ },
+ .probe  = rt2800soc_probe,
+ .remove  = rt2x00soc_remove,
+ .suspend = rt2x00soc_suspend,
+ .resume  = rt2x00soc_resume,
+};
+
+module_platform_driver(rt2800soc_driver);
+
+MODULE_AUTHOR(DRV_PROJECT);
+MODULE_VERSION(DRV_VERSION);
+MODULE_DESCRIPTION("Ralink WiSoC Wireless LAN driver.");
+MODULE_LICENSE("GPL");
diff --git a/drivers/net/wireless/rt2x00/rt2800usb.c b/drivers/net/wireless/rt2x00/rt2800usb.c
index ac854d7..48bdb87 100644
--- a/drivers/net/wireless/rt2x00/rt2800usb.c
+++ b/drivers/net/wireless/rt2x00/rt2800usb.c
@@ -18,9 +18,7 @@
  GNU General Public License for more details.
 
  You should have received a copy of the GNU General Public License
- along with this program; if not, write to the
- Free Software Foundation, Inc.,
- 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ along with this program; if not, see <http://www.gnu.org/licenses/>.
  */
 
 /*
@@ -31,7 +29,6 @@
 
 #include <linux/delay.h>
 #include <linux/etherdevice.h>
-#include <linux/init.h>
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/usb.h>
@@ -128,9 +125,9 @@ static inline bool rt2800usb_entry_txstatus_timeout(struct queue_entry *entry)
 
  tout = time_after(jiffies, entry->last_action + msecs_to_jiffies(100));
  if (unlikely(tout))
-  rt2x00_warn(entry->queue->rt2x00dev,
-       "TX status timeout for entry %d in queue %d\n",
-       entry->entry_idx, entry->queue->qid);
+  rt2x00_dbg(entry->queue->rt2x00dev,
+      "TX status timeout for entry %d in queue %d\n",
+      entry->entry_idx, entry->queue->qid);
  return tout;
 
 }
@@ -148,6 +145,8 @@ static bool rt2800usb_txstatus_timeout(struct rt2x00_dev *rt2x00dev)
  return false;
 }
 
+#define TXSTATUS_READ_INTERVAL 1000000
+
 static bool rt2800usb_tx_sta_fifo_read_completed(struct rt2x00_dev *rt2x00dev,
        int urb_status, u32 tx_status)
 {
@@ -176,8 +175,9 @@ static bool rt2800usb_tx_sta_fifo_read_completed(struct rt2x00_dev *rt2x00dev,
   queue_work(rt2x00dev->workqueue, &rt2x00dev->txdone_work);
 
  if (rt2800usb_txstatus_pending(rt2x00dev)) {
-  /* Read register after 250 us */
-  hrtimer_start(&rt2x00dev->txstatus_timer, ktime_set(0, 250000),
+  /* Read register after 1 ms */
+  hrtimer_start(&rt2x00dev->txstatus_timer,
+         ktime_set(0, TXSTATUS_READ_INTERVAL),
          HRTIMER_MODE_REL);
   return false;
  }
@@ -202,8 +202,9 @@ static void rt2800usb_async_read_tx_status(struct rt2x00_dev *rt2x00dev)
  if (test_and_set_bit(TX_STATUS_READING, &rt2x00dev->flags))
   return;
 
- /* Read TX_STA_FIFO register after 500 us */
- hrtimer_start(&rt2x00dev->txstatus_timer, ktime_set(0, 500000),
+ /* Read TX_STA_FIFO register after 2 ms */
+ hrtimer_start(&rt2x00dev->txstatus_timer,
+        ktime_set(0, 2*TXSTATUS_READ_INTERVAL),
         HRTIMER_MODE_REL);
 }
 
@@ -228,6 +229,31 @@ static enum hrtimer_restart rt2800usb_tx_sta_fifo_timeout(struct hrtimer *timer)
 /*
  * Firmware functions
  */
+static int rt2800usb_autorun_detect(struct rt2x00_dev *rt2x00dev)
+{
+ __le32 *reg;
+ u32 fw_mode;
+
+ reg = kmalloc(sizeof(*reg), GFP_KERNEL);
+ if (reg == NULL)
+  return -ENOMEM;
+ /* cannot use rt2x00usb_register_read here as it uses different
+  * mode (MULTI_READ vs. DEVICE_MODE) and does not pass the
+  * magic value USB_MODE_AUTORUN (0x11) to the device, thus the
+  * returned value would be invalid.
+  */
+ rt2x00usb_vendor_request(rt2x00dev, USB_DEVICE_MODE,
+     USB_VENDOR_REQUEST_IN, 0, USB_MODE_AUTORUN,
+     reg, sizeof(*reg), REGISTER_TIMEOUT_FIRMWARE);
+ fw_mode = le32_to_cpu(*reg);
+ kfree(reg);
+
+ if ((fw_mode & 0x00000003) == 2)
+  return 1;
+
+ return 0;
+}
+
 static char *rt2800usb_get_firmware_name(struct rt2x00_dev *rt2x00dev)
 {
  return FIRMWARE_RT2870;
@@ -239,6 +265,7 @@ static int rt2800usb_write_firmware(struct rt2x00_dev *rt2x00dev,
  int status;
  u32 offset;
  u32 length;
+ int retval;
 
  /*
   * Check which section of the firmware we need.
@@ -256,8 +283,16 @@ static int rt2800usb_write_firmware(struct rt2x00_dev *rt2x00dev,
  /*
   * Write firmware to device.
   */
- rt2x00usb_register_multiwrite(rt2x00dev, FIRMWARE_IMAGE_BASE,
-          data + offset, length);
+ retval = rt2800usb_autorun_detect(rt2x00dev);
+ if (retval < 0)
+  return retval;
+ if (retval) {
+  rt2x00_info(rt2x00dev,
+       "Firmware loading not required - NIC in AutoRun mode\n");
+ } else {
+  rt2x00usb_register_multiwrite(rt2x00dev, FIRMWARE_IMAGE_BASE,
+           data + offset, length);
+ }
 
  rt2x00usb_register_write(rt2x00dev, H2M_MAILBOX_CID, ~0);
  rt2x00usb_register_write(rt2x00dev, H2M_MAILBOX_STATUS, ~0);
@@ -327,7 +362,7 @@ static int rt2800usb_enable_radio(struct rt2x00_dev *rt2x00dev)
   * this limit so reduce the number to prevent errors.
   */
  rt2x00_set_field32(&reg, USB_DMA_CFG_RX_BULK_AGG_LIMIT,
-      ((rt2x00dev->ops->rx->entry_num * DATA_FRAME_SIZE)
+      ((rt2x00dev->rx->limit * DATA_FRAME_SIZE)
        / 1024) - 3);
  rt2x00_set_field32(&reg, USB_DMA_CFG_RX_BULK_EN, 1);
  rt2x00_set_field32(&reg, USB_DMA_CFG_TX_BULK_EN, 1);
@@ -565,8 +600,8 @@ static void rt2800usb_txdone(struct rt2x00_dev *rt2x00dev)
   queue = rt2x00queue_get_tx_queue(rt2x00dev, qid);
 
   if (unlikely(rt2x00queue_empty(queue))) {
-   rt2x00_warn(rt2x00dev, "Got TX status for an empty queue %u, dropping\n",
-        qid);
+   rt2x00_dbg(rt2x00dev, "Got TX status for an empty queue %u, dropping\n",
+       qid);
    break;
   }
 
@@ -734,11 +769,26 @@ static void rt2800usb_fill_rxdone(struct queue_entry *entry,
 /*
  * Device probe functions.
  */
+static int rt2800usb_efuse_detect(struct rt2x00_dev *rt2x00dev)
+{
+ int retval;
+
+ retval = rt2800usb_autorun_detect(rt2x00dev);
+ if (retval < 0)
+  return retval;
+ if (retval)
+  return 1;
+ return rt2800_efuse_detect(rt2x00dev);
+}
+
 static int rt2800usb_read_eeprom(struct rt2x00_dev *rt2x00dev)
 {
  int retval;
 
- if (rt2800_efuse_detect(rt2x00dev))
+ retval = rt2800usb_efuse_detect(rt2x00dev);
+ if (retval < 0)
+  return retval;
+ if (retval)
   retval = rt2800_read_eeprom_efuse(rt2x00dev);
  else
   retval = rt2x00usb_eeprom_read(rt2x00dev, rt2x00dev->eeprom,
@@ -763,7 +813,7 @@ static int rt2800usb_probe_hw(struct rt2x00_dev *rt2x00dev)
  /*
   * Overwrite TX done handler
   */
- PREPARE_WORK(&rt2x00dev->txdone_work, rt2800usb_work_txdone);
+ INIT_WORK(&rt2x00dev->txdone_work, rt2800usb_work_txdone);
 
  return 0;
 }
@@ -849,85 +899,57 @@ static const struct rt2x00lib_ops rt2800usb_rt2x00_ops = {
  .sta_remove  = rt2800_sta_remove,
 };
 
-static const struct data_queue_desc rt2800usb_queue_rx = {
- .entry_num  = 128,
- .data_size  = AGGREGATION_SIZE,
- .desc_size  = RXINFO_DESC_SIZE,
- .winfo_size  = RXWI_DESC_SIZE,
- .priv_size  = sizeof(struct queue_entry_priv_usb),
-};
-
-static const struct data_queue_desc rt2800usb_queue_tx = {
- .entry_num  = 16,
- .data_size  = AGGREGATION_SIZE,
- .desc_size  = TXINFO_DESC_SIZE,
- .winfo_size  = TXWI_DESC_SIZE,
- .priv_size  = sizeof(struct queue_entry_priv_usb),
-};
-
-static const struct data_queue_desc rt2800usb_queue_bcn = {
- .entry_num  = 8,
- .data_size  = MGMT_FRAME_SIZE,
- .desc_size  = TXINFO_DESC_SIZE,
- .winfo_size  = TXWI_DESC_SIZE,
- .priv_size  = sizeof(struct queue_entry_priv_usb),
-};
+static void rt2800usb_queue_init(struct data_queue *queue)
+{
+ struct rt2x00_dev *rt2x00dev = queue->rt2x00dev;
+ unsigned short txwi_size, rxwi_size;
 
-static const struct rt2x00_ops rt2800usb_ops = {
- .name   = KBUILD_MODNAME,
- .drv_data_size  = sizeof(struct rt2800_drv_data),
- .max_ap_intf  = 8,
- .eeprom_size  = EEPROM_SIZE,
- .rf_size  = RF_SIZE,
- .tx_queues  = NUM_TX_QUEUES,
- .extra_tx_headroom = TXINFO_DESC_SIZE + TXWI_DESC_SIZE,
- .rx   = &rt2800usb_queue_rx,
- .tx   = &rt2800usb_queue_tx,
- .bcn   = &rt2800usb_queue_bcn,
- .lib   = &rt2800usb_rt2x00_ops,
- .drv   = &rt2800usb_rt2800_ops,
- .hw   = &rt2800usb_mac80211_ops,
-#ifdef CONFIG_RT2X00_LIB_DEBUGFS
- .debugfs  = &rt2800_rt2x00debug,
-#endif /* CONFIG_RT2X00_LIB_DEBUGFS */
-};
+ rt2800_get_txwi_rxwi_size(rt2x00dev, &txwi_size, &rxwi_size);
 
-static const struct data_queue_desc rt2800usb_queue_rx_5592 = {
- .entry_num  = 128,
- .data_size  = AGGREGATION_SIZE,
- .desc_size  = RXINFO_DESC_SIZE,
- .winfo_size  = RXWI_DESC_SIZE_5592,
- .priv_size  = sizeof(struct queue_entry_priv_usb),
-};
+ switch (queue->qid) {
+ case QID_RX:
+  queue->limit = 128;
+  queue->data_size = AGGREGATION_SIZE;
+  queue->desc_size = RXINFO_DESC_SIZE;
+  queue->winfo_size = rxwi_size;
+  queue->priv_size = sizeof(struct queue_entry_priv_usb);
+  break;
 
-static const struct data_queue_desc rt2800usb_queue_tx_5592 = {
- .entry_num  = 16,
- .data_size  = AGGREGATION_SIZE,
- .desc_size  = TXINFO_DESC_SIZE,
- .winfo_size  = TXWI_DESC_SIZE_5592,
- .priv_size  = sizeof(struct queue_entry_priv_usb),
-};
+ case QID_AC_VO:
+ case QID_AC_VI:
+ case QID_AC_BE:
+ case QID_AC_BK:
+  queue->limit = 16;
+  queue->data_size = AGGREGATION_SIZE;
+  queue->desc_size = TXINFO_DESC_SIZE;
+  queue->winfo_size = txwi_size;
+  queue->priv_size = sizeof(struct queue_entry_priv_usb);
+  break;
 
-static const struct data_queue_desc rt2800usb_queue_bcn_5592 = {
- .entry_num  = 8,
- .data_size  = MGMT_FRAME_SIZE,
- .desc_size  = TXINFO_DESC_SIZE,
- .winfo_size  = TXWI_DESC_SIZE_5592,
- .priv_size  = sizeof(struct queue_entry_priv_usb),
-};
+ case QID_BEACON:
+  queue->limit = 8;
+  queue->data_size = MGMT_FRAME_SIZE;
+  queue->desc_size = TXINFO_DESC_SIZE;
+  queue->winfo_size = txwi_size;
+  queue->priv_size = sizeof(struct queue_entry_priv_usb);
+  break;
 
+ case QID_ATIM:
+  /* fallthrough */
+ default:
+  BUG();
+  break;
+ }
+}
 
-static const struct rt2x00_ops rt2800usb_ops_5592 = {
+static const struct rt2x00_ops rt2800usb_ops = {
  .name   = KBUILD_MODNAME,
  .drv_data_size  = sizeof(struct rt2800_drv_data),
  .max_ap_intf  = 8,
  .eeprom_size  = EEPROM_SIZE,
  .rf_size  = RF_SIZE,
  .tx_queues  = NUM_TX_QUEUES,
- .extra_tx_headroom = TXINFO_DESC_SIZE + TXWI_DESC_SIZE_5592,
- .rx   = &rt2800usb_queue_rx_5592,
- .tx   = &rt2800usb_queue_tx_5592,
- .bcn   = &rt2800usb_queue_bcn_5592,
+ .queue_init  = rt2800usb_queue_init,
  .lib   = &rt2800usb_rt2x00_ops,
  .drv   = &rt2800usb_rt2800_ops,
  .hw   = &rt2800usb_mac80211_ops,
@@ -999,6 +1021,7 @@ static struct usb_device_id rt2800usb_device_table[] = {
  { USB_DEVICE(0x0411, 0x016f) },
  { USB_DEVICE(0x0411, 0x01a2) },
  { USB_DEVICE(0x0411, 0x01ee) },
+ { USB_DEVICE(0x0411, 0x01a8) },
  /* Corega */
  { USB_DEVICE(0x07aa, 0x002f) },
  { USB_DEVICE(0x07aa, 0x003c) },
@@ -1015,6 +1038,7 @@ static struct usb_device_id rt2800usb_device_table[] = {
  { USB_DEVICE(0x07d1, 0x3c15) },
  { USB_DEVICE(0x07d1, 0x3c16) },
  { USB_DEVICE(0x07d1, 0x3c17) },
+ { USB_DEVICE(0x2001, 0x3317) },
  { USB_DEVICE(0x2001, 0x3c1b) },
  /* Draytek */
  { USB_DEVICE(0x07fa, 0x7712) },
@@ -1203,6 +1227,8 @@ static struct usb_device_id rt2800usb_device_table[] = {
  /* Linksys */
  { USB_DEVICE(0x13b1, 0x002f) },
  { USB_DEVICE(0x1737, 0x0079) },
+ /* Logitec */
+ { USB_DEVICE(0x0789, 0x0170) },
  /* Ralink */
  { USB_DEVICE(0x148f, 0x3572) },
  /* Sitecom */
@@ -1216,6 +1242,44 @@ static struct usb_device_id rt2800usb_device_table[] = {
  /* Zinwell */
  { USB_DEVICE(0x5a57, 0x0284) },
 #endif
+#ifdef CONFIG_RT2800USB_RT3573
+ /* AirLive */
+ { USB_DEVICE(0x1b75, 0x7733) },
+ /* ASUS */
+ { USB_DEVICE(0x0b05, 0x17bc) },
+ { USB_DEVICE(0x0b05, 0x17ad) },
+ /* Belkin */
+ { USB_DEVICE(0x050d, 0x1103) },
+ /* Cameo */
+ { USB_DEVICE(0x148f, 0xf301) },
+ /* D-Link */
+ { USB_DEVICE(0x2001, 0x3c1f) },
+ /* Edimax */
+ { USB_DEVICE(0x7392, 0x7733) },
+ /* Hawking */
+ { USB_DEVICE(0x0e66, 0x0020) },
+ { USB_DEVICE(0x0e66, 0x0021) },
+ /* I-O DATA */
+ { USB_DEVICE(0x04bb, 0x094e) },
+ /* Linksys */
+ { USB_DEVICE(0x13b1, 0x003b) },
+ /* Logitec */
+ { USB_DEVICE(0x0789, 0x016b) },
+ /* NETGEAR */
+ { USB_DEVICE(0x0846, 0x9012) },
+ { USB_DEVICE(0x0846, 0x9013) },
+ { USB_DEVICE(0x0846, 0x9019) },
+ /* Planex */
+ { USB_DEVICE(0x2019, 0xed19) },
+ /* Ralink */
+ { USB_DEVICE(0x148f, 0x3573) },
+ /* Sitecom */
+ { USB_DEVICE(0x0df6, 0x0067) },
+ { USB_DEVICE(0x0df6, 0x006a) },
+ { USB_DEVICE(0x0df6, 0x006e) },
+ /* ZyXEL */
+ { USB_DEVICE(0x0586, 0x3421) },
+#endif
 #ifdef CONFIG_RT2800USB_RT53XX
  /* Arcadyan */
  { USB_DEVICE(0x043e, 0x7a12) },
@@ -1229,6 +1293,9 @@ static struct usb_device_id rt2800usb_device_table[] = {
  { USB_DEVICE(0x2001, 0x3c1c) },
  { USB_DEVICE(0x2001, 0x3c1d) },
  { USB_DEVICE(0x2001, 0x3c1e) },
+ { USB_DEVICE(0x2001, 0x3c20) },
+ { USB_DEVICE(0x2001, 0x3c22) },
+ { USB_DEVICE(0x2001, 0x3c23) },
  /* LG innotek */
  { USB_DEVICE(0x043e, 0x7a22) },
  { USB_DEVICE(0x043e, 0x7a42) },
@@ -1248,15 +1315,20 @@ static struct usb_device_id rt2800usb_device_table[] = {
 #endif
 #ifdef CONFIG_RT2800USB_RT55XX
  /* Arcadyan */
- { USB_DEVICE(0x043e, 0x7a32), .driver_info = 5592 },
+ { USB_DEVICE(0x043e, 0x7a32) },
  /* AVM GmbH */
- { USB_DEVICE(0x057c, 0x8501), .driver_info = 5592 },
- /* D-Link DWA-160-B2 */
- { USB_DEVICE(0x2001, 0x3c1a), .driver_info = 5592 },
+ { USB_DEVICE(0x057c, 0x8501) },
+ /* Buffalo */
+ { USB_DEVICE(0x0411, 0x0241) },
+ /* D-Link */
+ { USB_DEVICE(0x2001, 0x3c1a) },
+ { USB_DEVICE(0x2001, 0x3c21) },
  /* Proware */
- { USB_DEVICE(0x043e, 0x7a13), .driver_info = 5592 },
+ { USB_DEVICE(0x043e, 0x7a13) },
  /* Ralink */
- { USB_DEVICE(0x148f, 0x5572), .driver_info = 5592 },
+ { USB_DEVICE(0x148f, 0x5572) },
+ /* TRENDnet */
+ { USB_DEVICE(0x20f4, 0x724a) },
 #endif
 #ifdef CONFIG_RT2800USB_UNKNOWN
  /*
@@ -1326,6 +1398,7 @@ static struct usb_device_id rt2800usb_device_table[] = {
  { USB_DEVICE(0x1d4d, 0x0010) },
  /* Planex */
  { USB_DEVICE(0x2019, 0xab24) },
+ { USB_DEVICE(0x2019, 0xab29) },
  /* Qcom */
  { USB_DEVICE(0x18e8, 0x6259) },
  /* RadioShack */
@@ -1361,9 +1434,6 @@ MODULE_LICENSE("GPL");
 static int rt2800usb_probe(struct usb_interface *usb_intf,
       const struct usb_device_id *id)
 {
- if (id->driver_info == 5592)
-  return rt2x00usb_probe(usb_intf, &rt2800usb_ops_5592);
-
  return rt2x00usb_probe(usb_intf, &rt2800usb_ops);
 }
 
diff --git a/drivers/net/wireless/rt2x00/rt2800usb.h b/drivers/net/wireless/rt2x00/rt2800usb.h
index 671ea35..ea7cac0 100644
--- a/drivers/net/wireless/rt2x00/rt2800usb.h
+++ b/drivers/net/wireless/rt2x00/rt2800usb.h
@@ -17,9 +17,7 @@
  GNU General Public License for more details.
 
  You should have received a copy of the GNU General Public License
- along with this program; if not, write to the
- Free Software Foundation, Inc.,
- 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ along with this program; if not, see <http://www.gnu.org/licenses/>.
  */
 
 /*
diff --git a/drivers/net/wireless/rt2x00/rt2x00.h b/drivers/net/wireless/rt2x00/rt2x00.h
index 7510723..d13f25c 100644
--- a/drivers/net/wireless/rt2x00/rt2x00.h
+++ b/drivers/net/wireless/rt2x00/rt2x00.h
@@ -15,9 +15,7 @@
  GNU General Public License for more details.
 
  You should have received a copy of the GNU General Public License
- along with this program; if not, write to the
- Free Software Foundation, Inc.,
- 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ along with this program; if not, see <http://www.gnu.org/licenses/>.
  */
 
 /*
@@ -39,6 +37,7 @@
 #include <linux/input-polldev.h>
 #include <linux/kfifo.h>
 #include <linux/hrtimer.h>
+#include <linux/average.h>
 
 #include <net/mac80211.h>
 
@@ -138,17 +137,6 @@
 #define SHORT_EIFS  ( SIFS + SHORT_DIFS + \
       GET_DURATION(IEEE80211_HEADER + ACK_SIZE, 10) )
 
-/*
- * Structure for average calculation
- * The avg field contains the actual average value,
- * but avg_weight is internally used during calculations
- * to prevent rounding errors.
- */
-struct avg_val {
- int avg;
- int avg_weight;
-};
-
 enum rt2x00_chip_intf {
  RT2X00_CHIP_INTF_PCI,
  RT2X00_CHIP_INTF_PCIE,
@@ -211,6 +199,7 @@ struct channel_info {
  short max_power;
  short default_power1;
  short default_power2;
+ short default_power3;
 };
 
 /*
@@ -296,7 +285,7 @@ struct link_ant {
   * Similar to the avg_rssi in the link_qual structure
   * this value is updated by using the walking average.
   */
- struct avg_val rssi_ant;
+ struct ewma rssi_ant;
 };
 
 /*
@@ -325,7 +314,7 @@ struct link {
  /*
   * Currently active average RSSI value
   */
- struct avg_val avg_rssi;
+ struct ewma avg_rssi;
 
  /*
   * Work structure for scheduling periodic link tuning.
@@ -648,11 +637,7 @@ struct rt2x00_ops {
  const unsigned int eeprom_size;
  const unsigned int rf_size;
  const unsigned int tx_queues;
- const unsigned int extra_tx_headroom;
- const struct data_queue_desc *rx;
- const struct data_queue_desc *tx;
- const struct data_queue_desc *bcn;
- const struct data_queue_desc *atim;
+ void (*queue_init)(struct data_queue *queue);
  const struct rt2x00lib_ops *lib;
  const void *drv;
  const struct ieee80211_ops *hw;
@@ -708,6 +693,7 @@ enum rt2x00_capability_flags {
  REQUIRE_SW_SEQNO,
  REQUIRE_HT_TX_DESC,
  REQUIRE_PS_AUTOWAKE,
+ REQUIRE_DELAYED_RFKILL,
 
  /*
   * Capabilities
@@ -1010,6 +996,9 @@ struct rt2x00_dev {
   */
  struct list_head bar_list;
  spinlock_t bar_list_lock;
+
+ /* Extra TX headroom required for alignment purposes. */
+ unsigned int extra_tx_headroom;
 };
 
 struct rt2x00_bar_list_entry {
@@ -1179,6 +1168,93 @@ static inline bool rt2x00_is_soc(struct rt2x00_dev *rt2x00dev)
  return rt2x00_intf(rt2x00dev, RT2X00_CHIP_INTF_SOC);
 }
 
+/* Helpers for capability flags */
+
+static inline bool
+rt2x00_has_cap_flag(struct rt2x00_dev *rt2x00dev,
+      enum rt2x00_capability_flags cap_flag)
+{
+ return test_bit(cap_flag, &rt2x00dev->cap_flags);
+}
+
+static inline bool
+rt2x00_has_cap_hw_crypto(struct rt2x00_dev *rt2x00dev)
+{
+ return rt2x00_has_cap_flag(rt2x00dev, CAPABILITY_HW_CRYPTO);
+}
+
+static inline bool
+rt2x00_has_cap_power_limit(struct rt2x00_dev *rt2x00dev)
+{
+ return rt2x00_has_cap_flag(rt2x00dev, CAPABILITY_POWER_LIMIT);
+}
+
+static inline bool
+rt2x00_has_cap_control_filters(struct rt2x00_dev *rt2x00dev)
+{
+ return rt2x00_has_cap_flag(rt2x00dev, CAPABILITY_CONTROL_FILTERS);
+}
+
+static inline bool
+rt2x00_has_cap_control_filter_pspoll(struct rt2x00_dev *rt2x00dev)
+{
+ return rt2x00_has_cap_flag(rt2x00dev, CAPABILITY_CONTROL_FILTER_PSPOLL);
+}
+
+static inline bool
+rt2x00_has_cap_pre_tbtt_interrupt(struct rt2x00_dev *rt2x00dev)
+{
+ return rt2x00_has_cap_flag(rt2x00dev, CAPABILITY_PRE_TBTT_INTERRUPT);
+}
+
+static inline bool
+rt2x00_has_cap_link_tuning(struct rt2x00_dev *rt2x00dev)
+{
+ return rt2x00_has_cap_flag(rt2x00dev, CAPABILITY_LINK_TUNING);
+}
+
+static inline bool
+rt2x00_has_cap_frame_type(struct rt2x00_dev *rt2x00dev)
+{
+ return rt2x00_has_cap_flag(rt2x00dev, CAPABILITY_FRAME_TYPE);
+}
+
+static inline bool
+rt2x00_has_cap_rf_sequence(struct rt2x00_dev *rt2x00dev)
+{
+ return rt2x00_has_cap_flag(rt2x00dev, CAPABILITY_RF_SEQUENCE);
+}
+
+static inline bool
+rt2x00_has_cap_external_lna_a(struct rt2x00_dev *rt2x00dev)
+{
+ return rt2x00_has_cap_flag(rt2x00dev, CAPABILITY_EXTERNAL_LNA_A);
+}
+
+static inline bool
+rt2x00_has_cap_external_lna_bg(struct rt2x00_dev *rt2x00dev)
+{
+ return rt2x00_has_cap_flag(rt2x00dev, CAPABILITY_EXTERNAL_LNA_BG);
+}
+
+static inline bool
+rt2x00_has_cap_double_antenna(struct rt2x00_dev *rt2x00dev)
+{
+ return rt2x00_has_cap_flag(rt2x00dev, CAPABILITY_DOUBLE_ANTENNA);
+}
+
+static inline bool
+rt2x00_has_cap_bt_coexist(struct rt2x00_dev *rt2x00dev)
+{
+ return rt2x00_has_cap_flag(rt2x00dev, CAPABILITY_BT_COEXIST);
+}
+
+static inline bool
+rt2x00_has_cap_vco_recalibration(struct rt2x00_dev *rt2x00dev)
+{
+ return rt2x00_has_cap_flag(rt2x00dev, CAPABILITY_VCO_RECALIBRATION);
+}
+
 /**
  * rt2x00queue_map_txskb - Map a skb into DMA for TX purposes.
  * @entry: Pointer to &struct queue_entry
@@ -1373,7 +1449,8 @@ int rt2x00mac_conf_tx(struct ieee80211_hw *hw,
         struct ieee80211_vif *vif, u16 queue,
         const struct ieee80211_tx_queue_params *params);
 void rt2x00mac_rfkill_poll(struct ieee80211_hw *hw);
-void rt2x00mac_flush(struct ieee80211_hw *hw, u32 queues, bool drop);
+void rt2x00mac_flush(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
+       u32 queues, bool drop);
 int rt2x00mac_set_antenna(struct ieee80211_hw *hw, u32 tx_ant, u32 rx_ant);
 int rt2x00mac_get_antenna(struct ieee80211_hw *hw, u32 *tx_ant, u32 *rx_ant);
 void rt2x00mac_get_ringparam(struct ieee80211_hw *hw,
diff --git a/drivers/net/wireless/rt2x00/rt2x00config.c b/drivers/net/wireless/rt2x00/rt2x00config.c
index 8cb43f8..1122dc4 100644
--- a/drivers/net/wireless/rt2x00/rt2x00config.c
+++ b/drivers/net/wireless/rt2x00/rt2x00config.c
@@ -13,9 +13,7 @@
  GNU General Public License for more details.
 
  You should have received a copy of the GNU General Public License
- along with this program; if not, write to the
- Free Software Foundation, Inc.,
- 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ along with this program; if not, see <http://www.gnu.org/licenses/>.
  */
 
 /*
diff --git a/drivers/net/wireless/rt2x00/rt2x00crypto.c b/drivers/net/wireless/rt2x00/rt2x00crypto.c
index 1ca4c7f..a2fd05b 100644
--- a/drivers/net/wireless/rt2x00/rt2x00crypto.c
+++ b/drivers/net/wireless/rt2x00/rt2x00crypto.c
@@ -13,9 +13,7 @@
  GNU General Public License for more details.
 
  You should have received a copy of the GNU General Public License
- along with this program; if not, write to the
- Free Software Foundation, Inc.,
- 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ along with this program; if not, see <http://www.gnu.org/licenses/>.
  */
 
 /*
@@ -52,7 +50,7 @@ void rt2x00crypto_create_tx_descriptor(struct rt2x00_dev *rt2x00dev,
  struct ieee80211_tx_info *tx_info = IEEE80211_SKB_CB(skb);
  struct ieee80211_key_conf *hw_key = tx_info->control.hw_key;
 
- if (!test_bit(CAPABILITY_HW_CRYPTO, &rt2x00dev->cap_flags) || !hw_key)
+ if (!rt2x00_has_cap_hw_crypto(rt2x00dev) || !hw_key)
   return;
 
  __set_bit(ENTRY_TXD_ENCRYPT, &txdesc->flags);
@@ -80,7 +78,7 @@ unsigned int rt2x00crypto_tx_overhead(struct rt2x00_dev *rt2x00dev,
  struct ieee80211_key_conf *key = tx_info->control.hw_key;
  unsigned int overhead = 0;
 
- if (!test_bit(CAPABILITY_HW_CRYPTO, &rt2x00dev->cap_flags) || !key)
+ if (!rt2x00_has_cap_hw_crypto(rt2x00dev) || !key)
   return overhead;
 
  /*
diff --git a/drivers/net/wireless/rt2x00/rt2x00debug.c b/drivers/net/wireless/rt2x00/rt2x00debug.c
index fe7a7f6..90fdb02 100644
--- a/drivers/net/wireless/rt2x00/rt2x00debug.c
+++ b/drivers/net/wireless/rt2x00/rt2x00debug.c
@@ -13,9 +13,7 @@
  GNU General Public License for more details.
 
  You should have received a copy of the GNU General Public License
- along with this program; if not, write to the
- Free Software Foundation, Inc.,
- 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ along with this program; if not, see <http://www.gnu.org/licenses/>.
  */
 
 /*
@@ -288,7 +286,7 @@ static ssize_t rt2x00debug_read_queue_dump(struct file *file,
  if (retval)
   return retval;
 
- status = min((size_t)skb->len, length);
+ status = min_t(size_t, skb->len, length);
  if (copy_to_user(buf, skb->data, status)) {
   status = -EFAULT;
   goto exit;
@@ -750,7 +748,7 @@ void rt2x00debug_register(struct rt2x00_dev *rt2x00dev)
     intf, &rt2x00debug_fop_queue_stats);
 
 #ifdef CONFIG_RT2X00_LIB_CRYPTO
- if (test_bit(CAPABILITY_HW_CRYPTO, &rt2x00dev->cap_flags))
+ if (rt2x00_has_cap_hw_crypto(rt2x00dev))
   intf->crypto_stats_entry =
       debugfs_create_file("crypto", S_IRUGO, intf->queue_folder,
      intf, &rt2x00debug_fop_crypto_stats);
diff --git a/drivers/net/wireless/rt2x00/rt2x00debug.h b/drivers/net/wireless/rt2x00/rt2x00debug.h
index e11d39b..e65712c 100644
--- a/drivers/net/wireless/rt2x00/rt2x00debug.h
+++ b/drivers/net/wireless/rt2x00/rt2x00debug.h
@@ -13,9 +13,7 @@
  GNU General Public License for more details.
 
  You should have received a copy of the GNU General Public License
- along with this program; if not, write to the
- Free Software Foundation, Inc.,
- 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ along with this program; if not, see <http://www.gnu.org/licenses/>.
  */
 
 /*
diff --git a/drivers/net/wireless/rt2x00/rt2x00dev.c b/drivers/net/wireless/rt2x00/rt2x00dev.c
index 90dc143..4fa43a2 100644
--- a/drivers/net/wireless/rt2x00/rt2x00dev.c
+++ b/drivers/net/wireless/rt2x00/rt2x00dev.c
@@ -14,9 +14,7 @@
  GNU General Public License for more details.
 
  You should have received a copy of the GNU General Public License
- along with this program; if not, write to the
- Free Software Foundation, Inc.,
- 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ along with this program; if not, see <http://www.gnu.org/licenses/>.
  */
 
 /*
@@ -88,7 +86,7 @@ int rt2x00lib_enable_radio(struct rt2x00_dev *rt2x00dev)
  rt2x00queue_start_queues(rt2x00dev);
  rt2x00link_start_tuner(rt2x00dev);
  rt2x00link_start_agc(rt2x00dev);
- if (test_bit(CAPABILITY_VCO_RECALIBRATION, &rt2x00dev->cap_flags))
+ if (rt2x00_has_cap_vco_recalibration(rt2x00dev))
   rt2x00link_start_vcocal(rt2x00dev);
 
  /*
@@ -113,7 +111,7 @@ void rt2x00lib_disable_radio(struct rt2x00_dev *rt2x00dev)
   * Stop all queues
   */
  rt2x00link_stop_agc(rt2x00dev);
- if (test_bit(CAPABILITY_VCO_RECALIBRATION, &rt2x00dev->cap_flags))
+ if (rt2x00_has_cap_vco_recalibration(rt2x00dev))
   rt2x00link_stop_vcocal(rt2x00dev);
  rt2x00link_stop_tuner(rt2x00dev);
  rt2x00queue_stop_queues(rt2x00dev);
@@ -181,6 +179,7 @@ static void rt2x00lib_autowakeup(struct work_struct *work)
 static void rt2x00lib_bc_buffer_iter(void *data, u8 *mac,
          struct ieee80211_vif *vif)
 {
+ struct ieee80211_tx_control control = {};
  struct rt2x00_dev *rt2x00dev = data;
  struct sk_buff *skb;
 
@@ -195,7 +194,7 @@ static void rt2x00lib_bc_buffer_iter(void *data, u8 *mac,
   */
  skb = ieee80211_get_buffered_bc(rt2x00dev->hw, vif);
  while (skb) {
-  rt2x00mac_tx(rt2x00dev->hw, NULL, skb);
+  rt2x00mac_tx(rt2x00dev->hw, &control, skb);
   skb = ieee80211_get_buffered_bc(rt2x00dev->hw, vif);
  }
 }
@@ -234,7 +233,7 @@ void rt2x00lib_beacondone(struct rt2x00_dev *rt2x00dev)
   * here as they will fetch the next beacon directly prior to
   * transmission.
   */
- if (test_bit(CAPABILITY_PRE_TBTT_INTERRUPT, &rt2x00dev->cap_flags))
+ if (rt2x00_has_cap_pre_tbtt_interrupt(rt2x00dev))
   return;
 
  /* fetch next beacon */
@@ -334,7 +333,7 @@ void rt2x00lib_txdone(struct queue_entry *entry,
  /*
   * Remove the extra tx headroom from the skb.
   */
- skb_pull(entry->skb, rt2x00dev->ops->extra_tx_headroom);
+ skb_pull(entry->skb, rt2x00dev->extra_tx_headroom);
 
  /*
   * Signal that the TX descriptor is no longer in the skb.
@@ -358,7 +357,7 @@ void rt2x00lib_txdone(struct queue_entry *entry,
   * mac80211 will expect the same data to be present it the
   * frame as it was passed to us.
   */
- if (test_bit(CAPABILITY_HW_CRYPTO, &rt2x00dev->cap_flags))
+ if (rt2x00_has_cap_hw_crypto(rt2x00dev))
   rt2x00crypto_tx_insert_iv(entry->skb, header_length);
 
  /*
@@ -566,10 +565,10 @@ static void rt2x00lib_rxdone_check_ba(struct rt2x00_dev *rt2x00dev,
 
 #undef TID_CHECK
 
-  if (compare_ether_addr(ba->ra, entry->ta))
+  if (!ether_addr_equal_64bits(ba->ra, entry->ta))
    continue;
 
-  if (compare_ether_addr(ba->ta, entry->ra))
+  if (!ether_addr_equal_64bits(ba->ta, entry->ra))
    continue;
 
   /* Mark BAR since we received the according BA */
@@ -1049,7 +1048,7 @@ static int rt2x00lib_probe_hw(struct rt2x00_dev *rt2x00dev)
   */
  rt2x00dev->hw->extra_tx_headroom =
   max_t(unsigned int, IEEE80211_TX_STATUS_HEADROOM,
-        rt2x00dev->ops->extra_tx_headroom);
+        rt2x00dev->extra_tx_headroom);
 
  /*
   * Take TX headroom required for alignment into account.
@@ -1077,7 +1076,7 @@ static int rt2x00lib_probe_hw(struct rt2x00_dev *rt2x00dev)
    */
   int kfifo_size =
    roundup_pow_of_two(rt2x00dev->ops->tx_queues *
-        rt2x00dev->ops->tx->entry_num *
+        rt2x00dev->tx->limit *
         sizeof(u32));
 
   status = kfifo_alloc(&rt2x00dev->txstatus_fifo, kfifo_size,
@@ -1127,9 +1126,10 @@ static void rt2x00lib_uninitialize(struct rt2x00_dev *rt2x00dev)
   return;
 
  /*
-  * Unregister extra components.
+  * Stop rfkill polling.
   */
- rt2x00rfkill_unregister(rt2x00dev);
+ if (test_bit(REQUIRE_DELAYED_RFKILL, &rt2x00dev->cap_flags))
+  rt2x00rfkill_unregister(rt2x00dev);
 
  /*
   * Allow the HW to uninitialize.
@@ -1167,6 +1167,12 @@ static int rt2x00lib_initialize(struct rt2x00_dev *rt2x00dev)
 
  set_bit(DEVICE_STATE_INITIALIZED, &rt2x00dev->flags);
 
+ /*
+  * Start rfkill polling.
+  */
+ if (test_bit(REQUIRE_DELAYED_RFKILL, &rt2x00dev->cap_flags))
+  rt2x00rfkill_register(rt2x00dev);
+
  return 0;
 }
 
@@ -1256,6 +1262,17 @@ static inline void rt2x00lib_set_if_combinations(struct rt2x00_dev *rt2x00dev)
  rt2x00dev->hw->wiphy->n_iface_combinations = 1;
 }
 
+static unsigned int rt2x00dev_extra_tx_headroom(struct rt2x00_dev *rt2x00dev)
+{
+ if (WARN_ON(!rt2x00dev->tx))
+  return 0;
+
+ if (rt2x00_is_usb(rt2x00dev))
+  return rt2x00dev->tx[0].winfo_size + rt2x00dev->tx[0].desc_size;
+
+ return rt2x00dev->tx[0].winfo_size;
+}
+
 /*
  * driver allocation handlers.
  */
@@ -1301,27 +1318,10 @@ int rt2x00lib_probe_dev(struct rt2x00_dev *rt2x00dev)
   (rt2x00dev->ops->max_ap_intf - 1);
 
  /*
-  * Determine which operating modes are supported, all modes
-  * which require beaconing, depend on the availability of
-  * beacon entries.
-  */
- rt2x00dev->hw->wiphy->interface_modes = BIT(NL80211_IFTYPE_STATION);
- if (rt2x00dev->ops->bcn->entry_num > 0)
-  rt2x00dev->hw->wiphy->interface_modes |=
-      BIT(NL80211_IFTYPE_ADHOC) |
-      BIT(NL80211_IFTYPE_AP) |
-#ifdef CONFIG_MAC80211_MESH
-      BIT(NL80211_IFTYPE_MESH_POINT) |
-#endif
-      BIT(NL80211_IFTYPE_WDS);
-
- rt2x00dev->hw->wiphy->flags |= WIPHY_FLAG_IBSS_RSN;
-
- /*
   * Initialize work.
   */
  rt2x00dev->workqueue =
-     alloc_ordered_workqueue(wiphy_name(rt2x00dev->hw->wiphy), 0);
+     alloc_ordered_workqueue("%s", 0, wiphy_name(rt2x00dev->hw->wiphy));
  if (!rt2x00dev->workqueue) {
   retval = -ENOMEM;
   goto exit;
@@ -1347,6 +1347,26 @@ int rt2x00lib_probe_dev(struct rt2x00_dev *rt2x00dev)
  if (retval)
   goto exit;
 
+ /* Cache TX headroom value */
+ rt2x00dev->extra_tx_headroom = rt2x00dev_extra_tx_headroom(rt2x00dev);
+
+ /*
+  * Determine which operating modes are supported, all modes
+  * which require beaconing, depend on the availability of
+  * beacon entries.
+  */
+ rt2x00dev->hw->wiphy->interface_modes = BIT(NL80211_IFTYPE_STATION);
+ if (rt2x00dev->bcn->limit > 0)
+  rt2x00dev->hw->wiphy->interface_modes |=
+      BIT(NL80211_IFTYPE_ADHOC) |
+      BIT(NL80211_IFTYPE_AP) |
+#ifdef CONFIG_MAC80211_MESH
+      BIT(NL80211_IFTYPE_MESH_POINT) |
+#endif
+      BIT(NL80211_IFTYPE_WDS);
+
+ rt2x00dev->hw->wiphy->flags |= WIPHY_FLAG_IBSS_RSN;
+
  /*
   * Initialize ieee80211 structure.
   */
@@ -1362,7 +1382,12 @@ int rt2x00lib_probe_dev(struct rt2x00_dev *rt2x00dev)
  rt2x00link_register(rt2x00dev);
  rt2x00leds_register(rt2x00dev);
  rt2x00debug_register(rt2x00dev);
- rt2x00rfkill_register(rt2x00dev);
+
+ /*
+  * Start rfkill polling.
+  */
+ if (!test_bit(REQUIRE_DELAYED_RFKILL, &rt2x00dev->cap_flags))
+  rt2x00rfkill_register(rt2x00dev);
 
  return 0;
 
@@ -1378,6 +1403,12 @@ void rt2x00lib_remove_dev(struct rt2x00_dev *rt2x00dev)
  clear_bit(DEVICE_STATE_PRESENT, &rt2x00dev->flags);
 
  /*
+  * Stop rfkill polling.
+  */
+ if (!test_bit(REQUIRE_DELAYED_RFKILL, &rt2x00dev->cap_flags))
+  rt2x00rfkill_unregister(rt2x00dev);
+
+ /*
   * Disable radio.
   */
  rt2x00lib_disable_radio(rt2x00dev);
diff --git a/drivers/net/wireless/rt2x00/rt2x00dump.h b/drivers/net/wireless/rt2x00/rt2x00dump.h
index 063ebcc..4c0e01b 100644
--- a/drivers/net/wireless/rt2x00/rt2x00dump.h
+++ b/drivers/net/wireless/rt2x00/rt2x00dump.h
@@ -13,9 +13,7 @@
  GNU General Public License for more details.
 
  You should have received a copy of the GNU General Public License
- along with this program; if not, write to the
- Free Software Foundation, Inc.,
- 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ along with this program; if not, see <http://www.gnu.org/licenses/>.
  */
 
 /*
diff --git a/drivers/net/wireless/rt2x00/rt2x00firmware.c b/drivers/net/wireless/rt2x00/rt2x00firmware.c
index 1b4254b..fbae279 100644
--- a/drivers/net/wireless/rt2x00/rt2x00firmware.c
+++ b/drivers/net/wireless/rt2x00/rt2x00firmware.c
@@ -14,9 +14,7 @@
  GNU General Public License for more details.
 
  You should have received a copy of the GNU General Public License
- along with this program; if not, write to the
- Free Software Foundation, Inc.,
- 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ along with this program; if not, see <http://www.gnu.org/licenses/>.
  */
 
 /*
diff --git a/drivers/net/wireless/rt2x00/rt2x00leds.c b/drivers/net/wireless/rt2x00/rt2x00leds.c
index 997a6c8..c681d04 100644
--- a/drivers/net/wireless/rt2x00/rt2x00leds.c
+++ b/drivers/net/wireless/rt2x00/rt2x00leds.c
@@ -13,9 +13,7 @@
  GNU General Public License for more details.
 
  You should have received a copy of the GNU General Public License
- along with this program; if not, write to the
- Free Software Foundation, Inc.,
- 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ along with this program; if not, see <http://www.gnu.org/licenses/>.
  */
 
 /*
diff --git a/drivers/net/wireless/rt2x00/rt2x00leds.h b/drivers/net/wireless/rt2x00/rt2x00leds.h
index 3b46f0c..b2c5269 100644
--- a/drivers/net/wireless/rt2x00/rt2x00leds.h
+++ b/drivers/net/wireless/rt2x00/rt2x00leds.h
@@ -13,9 +13,7 @@
  GNU General Public License for more details.
 
  You should have received a copy of the GNU General Public License
- along with this program; if not, write to the
- Free Software Foundation, Inc.,
- 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ along with this program; if not, see <http://www.gnu.org/licenses/>.
  */
 
 /*
diff --git a/drivers/net/wireless/rt2x00/rt2x00lib.h b/drivers/net/wireless/rt2x00/rt2x00lib.h
index a093598..fb7c349 100644
--- a/drivers/net/wireless/rt2x00/rt2x00lib.h
+++ b/drivers/net/wireless/rt2x00/rt2x00lib.h
@@ -14,9 +14,7 @@
  GNU General Public License for more details.
 
  You should have received a copy of the GNU General Public License
- along with this program; if not, write to the
- Free Software Foundation, Inc.,
- 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ along with this program; if not, see <http://www.gnu.org/licenses/>.
  */
 
 /*
@@ -146,7 +144,7 @@ void rt2x00queue_remove_l2pad(struct sk_buff *skb, unsigned int header_length);
  * @local: frame is not from mac80211
  */
 int rt2x00queue_write_tx_frame(struct data_queue *queue, struct sk_buff *skb,
-          bool local);
+          struct ieee80211_sta *sta, bool local);
 
 /**
  * rt2x00queue_update_beacon - Send new beacon from mac80211
diff --git a/drivers/net/wireless/rt2x00/rt2x00link.c b/drivers/net/wireless/rt2x00/rt2x00link.c
index 8368aab..9b941c0 100644
--- a/drivers/net/wireless/rt2x00/rt2x00link.c
+++ b/drivers/net/wireless/rt2x00/rt2x00link.c
@@ -13,9 +13,7 @@
  GNU General Public License for more details.
 
  You should have received a copy of the GNU General Public License
- along with this program; if not, write to the
- Free Software Foundation, Inc.,
- 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ along with this program; if not, see <http://www.gnu.org/licenses/>.
  */
 
 /*
@@ -35,50 +33,28 @@
  */
 #define DEFAULT_RSSI  -128
 
-/*
- * Helper struct and macro to work with moving/walking averages.
- * When adding a value to the average value the following calculation
- * is needed:
- *
- *        avg_rssi = ((avg_rssi * 7) + rssi) / 8;
- *
- * The advantage of this approach is that we only need 1 variable
- * to store the average in (No need for a count and a total).
- * But more importantly, normal average values will over time
- * move less and less towards newly added values this results
- * that with link tuning, the device can have a very good RSSI
- * for a few minutes but when the device is moved away from the AP
- * the average will not decrease fast enough to compensate.
- * The walking average compensates this and will move towards
- * the new values correctly allowing a effective link tuning,
- * the speed of the average moving towards other values depends
- * on the value for the number of samples. The higher the number
- * of samples, the slower the average will move.
- * We use two variables to keep track of the average value to
- * compensate for the rounding errors. This can be a significant
- * error (>5dBm) if the factor is too low.
- */
-#define AVG_SAMPLES 8
-#define AVG_FACTOR 1000
-#define MOVING_AVERAGE(__avg, __val) \
-({ \
- struct avg_val __new; \
- __new.avg_weight = \
-     (__avg).avg_weight  ? \
-  ((((__avg).avg_weight * ((AVG_SAMPLES) - 1)) + \
-    ((__val) * (AVG_FACTOR))) / \
-   (AVG_SAMPLES)) : \
-  ((__val) * (AVG_FACTOR)); \
- __new.avg = __new.avg_weight / (AVG_FACTOR); \
- __new; \
-})
+/* Constants for EWMA calculations. */
+#define RT2X00_EWMA_FACTOR 1024
+#define RT2X00_EWMA_WEIGHT 8
+
+static inline int rt2x00link_get_avg_rssi(struct ewma *ewma)
+{
+ unsigned long avg;
+
+ avg = ewma_read(ewma);
+ if (avg)
+  return -avg;
+
+ return DEFAULT_RSSI;
+}
 
 static int rt2x00link_antenna_get_link_rssi(struct rt2x00_dev *rt2x00dev)
 {
  struct link_ant *ant = &rt2x00dev->link.ant;
 
- if (ant->rssi_ant.avg && rt2x00dev->link.qual.rx_success)
-  return ant->rssi_ant.avg;
+ if (rt2x00dev->link.qual.rx_success)
+  return rt2x00link_get_avg_rssi(&ant->rssi_ant);
+
  return DEFAULT_RSSI;
 }
 
@@ -100,8 +76,8 @@ static void rt2x00link_antenna_update_rssi_history(struct rt2x00_dev *rt2x00dev,
 
 static void rt2x00link_antenna_reset(struct rt2x00_dev *rt2x00dev)
 {
- rt2x00dev->link.ant.rssi_ant.avg = 0;
- rt2x00dev->link.ant.rssi_ant.avg_weight = 0;
+ ewma_init(&rt2x00dev->link.ant.rssi_ant, RT2X00_EWMA_FACTOR,
+    RT2X00_EWMA_WEIGHT);
 }
 
 static void rt2x00lib_antenna_diversity_sample(struct rt2x00_dev *rt2x00dev)
@@ -249,12 +225,12 @@ void rt2x00link_update_stats(struct rt2x00_dev *rt2x00dev,
  /*
   * Update global RSSI
   */
- link->avg_rssi = MOVING_AVERAGE(link->avg_rssi, rxdesc->rssi);
+ ewma_add(&link->avg_rssi, -rxdesc->rssi);
 
  /*
   * Update antenna RSSI
   */
- ant->rssi_ant = MOVING_AVERAGE(ant->rssi_ant, rxdesc->rssi);
+ ewma_add(&ant->rssi_ant, -rxdesc->rssi);
 }
 
 void rt2x00link_start_tuner(struct rt2x00_dev *rt2x00dev)
@@ -309,6 +285,8 @@ void rt2x00link_reset_tuner(struct rt2x00_dev *rt2x00dev, bool antenna)
   */
  rt2x00dev->link.count = 0;
  memset(qual, 0, sizeof(*qual));
+ ewma_init(&rt2x00dev->link.avg_rssi, RT2X00_EWMA_FACTOR,
+    RT2X00_EWMA_WEIGHT);
 
  /*
   * Restore the VGC level as stored in the registers,
@@ -363,17 +341,17 @@ static void rt2x00link_tuner(struct work_struct *work)
   * collect the RSSI data we could use this. Otherwise we
   * must fallback to the default RSSI value.
   */
- if (!link->avg_rssi.avg || !qual->rx_success)
+ if (!qual->rx_success)
   qual->rssi = DEFAULT_RSSI;
  else
-  qual->rssi = link->avg_rssi.avg;
+  qual->rssi = rt2x00link_get_avg_rssi(&link->avg_rssi);
 
  /*
   * Check if link tuning is supported by the hardware, some hardware
   * do not support link tuning at all, while other devices can disable
   * the feature from the EEPROM.
   */
- if (test_bit(CAPABILITY_LINK_TUNING, &rt2x00dev->cap_flags))
+ if (rt2x00_has_cap_link_tuning(rt2x00dev))
   rt2x00dev->ops->lib->link_tuner(rt2x00dev, qual, link->count);
 
  /*
@@ -513,7 +491,7 @@ static void rt2x00link_vcocal(struct work_struct *work)
 void rt2x00link_register(struct rt2x00_dev *rt2x00dev)
 {
  INIT_DELAYED_WORK(&rt2x00dev->link.agc_work, rt2x00link_agc);
- if (test_bit(CAPABILITY_VCO_RECALIBRATION, &rt2x00dev->cap_flags))
+ if (rt2x00_has_cap_vco_recalibration(rt2x00dev))
   INIT_DELAYED_WORK(&rt2x00dev->link.vco_work, rt2x00link_vcocal);
  INIT_DELAYED_WORK(&rt2x00dev->link.watchdog_work, rt2x00link_watchdog);
  INIT_DELAYED_WORK(&rt2x00dev->link.work, rt2x00link_tuner);
diff --git a/drivers/net/wireless/rt2x00/rt2x00mac.c b/drivers/net/wireless/rt2x00/rt2x00mac.c
index f883802..004dff9 100644
--- a/drivers/net/wireless/rt2x00/rt2x00mac.c
+++ b/drivers/net/wireless/rt2x00/rt2x00mac.c
@@ -13,9 +13,7 @@
  GNU General Public License for more details.
 
  You should have received a copy of the GNU General Public License
- along with this program; if not, write to the
- Free Software Foundation, Inc.,
- 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ along with this program; if not, see <http://www.gnu.org/licenses/>.
  */
 
 /*
@@ -90,7 +88,7 @@ static int rt2x00mac_tx_rts_cts(struct rt2x00_dev *rt2x00dev,
       frag_skb->data, data_length, tx_info,
       (struct ieee80211_rts *)(skb->data));
 
- retval = rt2x00queue_write_tx_frame(queue, skb, true);
+ retval = rt2x00queue_write_tx_frame(queue, skb, NULL, true);
  if (retval) {
   dev_kfree_skb_any(skb);
   rt2x00_warn(rt2x00dev, "Failed to send RTS/CTS frame\n");
@@ -151,7 +149,7 @@ void rt2x00mac_tx(struct ieee80211_hw *hw,
    goto exit_fail;
  }
 
- if (unlikely(rt2x00queue_write_tx_frame(queue, skb, false)))
+ if (unlikely(rt2x00queue_write_tx_frame(queue, skb, control->sta, false)))
   goto exit_fail;
 
  /*
@@ -382,11 +380,11 @@ void rt2x00mac_configure_filter(struct ieee80211_hw *hw,
   * of different types, but has no a separate filter for PS Poll frames,
   * FIF_CONTROL flag implies FIF_PSPOLL.
   */
- if (!test_bit(CAPABILITY_CONTROL_FILTERS, &rt2x00dev->cap_flags)) {
+ if (!rt2x00_has_cap_control_filters(rt2x00dev)) {
   if (*total_flags & FIF_CONTROL || *total_flags & FIF_PSPOLL)
    *total_flags |= FIF_CONTROL | FIF_PSPOLL;
  }
- if (!test_bit(CAPABILITY_CONTROL_FILTER_PSPOLL, &rt2x00dev->cap_flags)) {
+ if (!rt2x00_has_cap_control_filter_pspoll(rt2x00dev)) {
   if (*total_flags & FIF_CONTROL)
    *total_flags |= FIF_PSPOLL;
  }
@@ -469,7 +467,7 @@ int rt2x00mac_set_key(struct ieee80211_hw *hw, enum set_key_cmd cmd,
  if (!test_bit(DEVICE_STATE_PRESENT, &rt2x00dev->flags))
   return 0;
 
- if (!test_bit(CAPABILITY_HW_CRYPTO, &rt2x00dev->cap_flags))
+ if (!rt2x00_has_cap_hw_crypto(rt2x00dev))
   return -EOPNOTSUPP;
 
  /*
@@ -489,6 +487,8 @@ int rt2x00mac_set_key(struct ieee80211_hw *hw, enum set_key_cmd cmd,
  crypto.cipher = rt2x00crypto_key_to_cipher(key);
  if (crypto.cipher == CIPHER_NONE)
   return -EOPNOTSUPP;
+ if (crypto.cipher == CIPHER_TKIP && rt2x00_is_usb(rt2x00dev))
+  return -EOPNOTSUPP;
 
  crypto.cmd = cmd;
 
@@ -623,20 +623,18 @@ void rt2x00mac_bss_info_changed(struct ieee80211_hw *hw,
           bss_conf->bssid);
 
  /*
-  * Update the beacon. This is only required on USB devices. PCI
-  * devices fetch beacons periodically.
-  */
- if (changes & BSS_CHANGED_BEACON && rt2x00_is_usb(rt2x00dev))
-  rt2x00queue_update_beacon(rt2x00dev, vif);
-
- /*
   * Start/stop beaconing.
   */
  if (changes & BSS_CHANGED_BEACON_ENABLED) {
   if (!bss_conf->enable_beacon && intf->enable_beacon) {
-   rt2x00queue_clear_beacon(rt2x00dev, vif);
    rt2x00dev->intf_beaconing--;
    intf->enable_beacon = false;
+   /*
+    * Clear beacon in the H/W for this vif. This is needed
+    * to disable beaconing on this particular interface
+    * and keep it running on other interfaces.
+    */
+   rt2x00queue_clear_beacon(rt2x00dev, vif);
 
    if (rt2x00dev->intf_beaconing == 0) {
     /*
@@ -647,11 +645,15 @@ void rt2x00mac_bss_info_changed(struct ieee80211_hw *hw,
     rt2x00queue_stop_queue(rt2x00dev->bcn);
     mutex_unlock(&intf->beacon_skb_mutex);
    }
-
-
   } else if (bss_conf->enable_beacon && !intf->enable_beacon) {
    rt2x00dev->intf_beaconing++;
    intf->enable_beacon = true;
+   /*
+    * Upload beacon to the H/W. This is only required on
+    * USB devices. PCI devices fetch beacons periodically.
+    */
+   if (rt2x00_is_usb(rt2x00dev))
+    rt2x00queue_update_beacon(rt2x00dev, vif);
 
    if (rt2x00dev->intf_beaconing == 1) {
     /*
@@ -749,11 +751,15 @@ void rt2x00mac_rfkill_poll(struct ieee80211_hw *hw)
 }
 EXPORT_SYMBOL_GPL(rt2x00mac_rfkill_poll);
 
-void rt2x00mac_flush(struct ieee80211_hw *hw, u32 queues, bool drop)
+void rt2x00mac_flush(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
+       u32 queues, bool drop)
 {
  struct rt2x00_dev *rt2x00dev = hw->priv;
  struct data_queue *queue;
 
+ if (!test_bit(DEVICE_STATE_PRESENT, &rt2x00dev->flags))
+  return;
+
  tx_queue_for_each(rt2x00dev, queue)
   rt2x00queue_flush_queue(queue, drop);
 }
diff --git a/drivers/net/wireless/rt2x00/rt2x00mmio.c b/drivers/net/wireless/rt2x00/rt2x00mmio.c
index 64b06c6..6f236ea 100644
--- a/drivers/net/wireless/rt2x00/rt2x00mmio.c
+++ b/drivers/net/wireless/rt2x00/rt2x00mmio.c
@@ -13,9 +13,7 @@
  GNU General Public License for more details.
 
  You should have received a copy of the GNU General Public License
- along with this program; if not, write to the
- Free Software Foundation, Inc.,
- 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ along with this program; if not, see <http://www.gnu.org/licenses/>.
  */
 
 /*
diff --git a/drivers/net/wireless/rt2x00/rt2x00mmio.h b/drivers/net/wireless/rt2x00/rt2x00mmio.h
index cda3dbc..701c312 100644
--- a/drivers/net/wireless/rt2x00/rt2x00mmio.h
+++ b/drivers/net/wireless/rt2x00/rt2x00mmio.h
@@ -13,9 +13,7 @@
  GNU General Public License for more details.
 
  You should have received a copy of the GNU General Public License
- along with this program; if not, write to the
- Free Software Foundation, Inc.,
- 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ along with this program; if not, see <http://www.gnu.org/licenses/>.
  */
 
 /*
diff --git a/drivers/net/wireless/rt2x00/rt2x00pci.c b/drivers/net/wireless/rt2x00/rt2x00pci.c
index dc49e52..d93db4b 100644
--- a/drivers/net/wireless/rt2x00/rt2x00pci.c
+++ b/drivers/net/wireless/rt2x00/rt2x00pci.c
@@ -13,9 +13,7 @@
  GNU General Public License for more details.
 
  You should have received a copy of the GNU General Public License
- along with this program; if not, write to the
- Free Software Foundation, Inc.,
- 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ along with this program; if not, see <http://www.gnu.org/licenses/>.
  */
 
 /*
@@ -119,7 +117,7 @@ int rt2x00pci_probe(struct pci_dev *pci_dev, const struct rt2x00_ops *ops)
  rt2x00dev->ops = ops;
  rt2x00dev->hw = hw;
  rt2x00dev->irq = pci_dev->irq;
- rt2x00dev->name = pci_name(pci_dev);
+ rt2x00dev->name = ops->name;
 
  if (pci_is_pcie(pci_dev))
   rt2x00_set_chip_intf(rt2x00dev, RT2X00_CHIP_INTF_PCIE);
@@ -156,8 +154,6 @@ exit_release_regions:
 exit_disable_device:
  pci_disable_device(pci_dev);
 
- pci_set_drvdata(pci_dev, NULL);
-
  return retval;
 }
 EXPORT_SYMBOL_GPL(rt2x00pci_probe);
@@ -177,7 +173,6 @@ void rt2x00pci_remove(struct pci_dev *pci_dev)
  /*
   * Free the PCI device data.
   */
- pci_set_drvdata(pci_dev, NULL);
  pci_disable_device(pci_dev);
  pci_release_regions(pci_dev);
 }
diff --git a/drivers/net/wireless/rt2x00/rt2x00pci.h b/drivers/net/wireless/rt2x00/rt2x00pci.h
index 60d90b2..bc0ca5f 100644
--- a/drivers/net/wireless/rt2x00/rt2x00pci.h
+++ b/drivers/net/wireless/rt2x00/rt2x00pci.h
@@ -13,9 +13,7 @@
  GNU General Public License for more details.
 
  You should have received a copy of the GNU General Public License
- along with this program; if not, write to the
- Free Software Foundation, Inc.,
- 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ along with this program; if not, see <http://www.gnu.org/licenses/>.
  */
 
 /*
diff --git a/drivers/net/wireless/rt2x00/rt2x00queue.c b/drivers/net/wireless/rt2x00/rt2x00queue.c
index d955741..5642ccc 100644
--- a/drivers/net/wireless/rt2x00/rt2x00queue.c
+++ b/drivers/net/wireless/rt2x00/rt2x00queue.c
@@ -15,9 +15,7 @@
  GNU General Public License for more details.
 
  You should have received a copy of the GNU General Public License
- along with this program; if not, write to the
- Free Software Foundation, Inc.,
- 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ along with this program; if not, see <http://www.gnu.org/licenses/>.
  */
 
 /*
@@ -61,7 +59,7 @@ struct sk_buff *rt2x00queue_alloc_rxskb(struct queue_entry *entry, gfp_t gfp)
   * at least 8 bytes bytes available in headroom for IV/EIV
   * and 8 bytes for ICV data as tailroon.
   */
- if (test_bit(CAPABILITY_HW_CRYPTO, &rt2x00dev->cap_flags)) {
+ if (rt2x00_has_cap_hw_crypto(rt2x00dev)) {
   head_size += 8;
   tail_size += 8;
  }
@@ -542,8 +540,8 @@ static int rt2x00queue_write_tx_data(struct queue_entry *entry,
  /*
   * Add the requested extra tx headroom in front of the skb.
   */
- skb_push(entry->skb, rt2x00dev->ops->extra_tx_headroom);
- memset(entry->skb->data, 0, rt2x00dev->ops->extra_tx_headroom);
+ skb_push(entry->skb, rt2x00dev->extra_tx_headroom);
+ memset(entry->skb->data, 0, rt2x00dev->extra_tx_headroom);
 
  /*
   * Call the driver's write_tx_data function, if it exists.
@@ -596,7 +594,7 @@ static void rt2x00queue_bar_check(struct queue_entry *entry)
 {
  struct rt2x00_dev *rt2x00dev = entry->queue->rt2x00dev;
  struct ieee80211_bar *bar = (void *) (entry->skb->data +
-        rt2x00dev->ops->extra_tx_headroom);
+        rt2x00dev->extra_tx_headroom);
  struct rt2x00_bar_list_entry *bar_entry;
 
  if (likely(!ieee80211_is_back_req(bar->frame_control)))
@@ -635,7 +633,7 @@ static void rt2x00queue_bar_check(struct queue_entry *entry)
 }
 
 int rt2x00queue_write_tx_frame(struct data_queue *queue, struct sk_buff *skb,
-          bool local)
+          struct ieee80211_sta *sta, bool local)
 {
  struct ieee80211_tx_info *tx_info;
  struct queue_entry *entry;
@@ -649,7 +647,7 @@ int rt2x00queue_write_tx_frame(struct data_queue *queue, struct sk_buff *skb,
   * after that we are free to use the skb->cb array
   * for our information.
   */
- rt2x00queue_create_tx_descriptor(queue->rt2x00dev, skb, &txdesc, NULL);
+ rt2x00queue_create_tx_descriptor(queue->rt2x00dev, skb, &txdesc, sta);
 
  /*
   * All information is retrieved from the skb->cb array,
@@ -936,7 +934,7 @@ void rt2x00queue_index_inc(struct queue_entry *entry, enum queue_index index)
  spin_unlock_irqrestore(&queue->index_lock, irqflags);
 }
 
-void rt2x00queue_pause_queue_nocheck(struct data_queue *queue)
+static void rt2x00queue_pause_queue_nocheck(struct data_queue *queue)
 {
  switch (queue->qid) {
  case QID_AC_VO:
@@ -1033,38 +1031,21 @@ EXPORT_SYMBOL_GPL(rt2x00queue_stop_queue);
 
 void rt2x00queue_flush_queue(struct data_queue *queue, bool drop)
 {
- bool started;
  bool tx_queue =
   (queue->qid == QID_AC_VO) ||
   (queue->qid == QID_AC_VI) ||
   (queue->qid == QID_AC_BE) ||
   (queue->qid == QID_AC_BK);
 
- mutex_lock(&queue->status_lock);
 
  /*
-  * If the queue has been started, we must stop it temporarily
-  * to prevent any new frames to be queued on the device. If
-  * we are not dropping the pending frames, the queue must
-  * only be stopped in the software and not the hardware,
-  * otherwise the queue will never become empty on its own.
+  * If we are not supposed to drop any pending
+  * frames, this means we must force a start (=kick)
+  * to the queue to make sure the hardware will
+  * start transmitting.
   */
- started = test_bit(QUEUE_STARTED, &queue->flags);
- if (started) {
-  /*
-   * Pause the queue
-   */
-  rt2x00queue_pause_queue(queue);
-
-  /*
-   * If we are not supposed to drop any pending
-   * frames, this means we must force a start (=kick)
-   * to the queue to make sure the hardware will
-   * start transmitting.
-   */
-  if (!drop && tx_queue)
-   queue->rt2x00dev->ops->lib->kick_queue(queue);
- }
+ if (!drop && tx_queue)
+  queue->rt2x00dev->ops->lib->kick_queue(queue);
 
  /*
   * Check if driver supports flushing, if that is the case we can
@@ -1080,14 +1061,6 @@ void rt2x00queue_flush_queue(struct data_queue *queue, bool drop)
  if (unlikely(!rt2x00queue_empty(queue)))
   rt2x00_warn(queue->rt2x00dev, "Queue %d failed to flush\n",
        queue->qid);
-
- /*
-  * Restore the queue to the previous status
-  */
- if (started)
-  rt2x00queue_unpause_queue(queue);
-
- mutex_unlock(&queue->status_lock);
 }
 EXPORT_SYMBOL_GPL(rt2x00queue_flush_queue);
 
@@ -1165,8 +1138,7 @@ void rt2x00queue_init_queues(struct rt2x00_dev *rt2x00dev)
  }
 }
 
-static int rt2x00queue_alloc_entries(struct data_queue *queue,
-         const struct data_queue_desc *qdesc)
+static int rt2x00queue_alloc_entries(struct data_queue *queue)
 {
  struct queue_entry *entries;
  unsigned int entry_size;
@@ -1174,16 +1146,10 @@ static int rt2x00queue_alloc_entries(struct data_queue *queue,
 
  rt2x00queue_reset(queue);
 
- queue->limit = qdesc->entry_num;
- queue->threshold = DIV_ROUND_UP(qdesc->entry_num, 10);
- queue->data_size = qdesc->data_size;
- queue->desc_size = qdesc->desc_size;
- queue->winfo_size = qdesc->winfo_size;
-
  /*
   * Allocate all queue entries.
   */
- entry_size = sizeof(*entries) + qdesc->priv_size;
+ entry_size = sizeof(*entries) + queue->priv_size;
  entries = kcalloc(queue->limit, entry_size, GFP_KERNEL);
  if (!entries)
   return -ENOMEM;
@@ -1199,7 +1165,7 @@ static int rt2x00queue_alloc_entries(struct data_queue *queue,
   entries[i].entry_idx = i;
   entries[i].priv_data =
       QUEUE_ENTRY_PRIV_OFFSET(entries, i, queue->limit,
-         sizeof(*entries), qdesc->priv_size);
+         sizeof(*entries), queue->priv_size);
  }
 
 #undef QUEUE_ENTRY_PRIV_OFFSET
@@ -1241,23 +1207,22 @@ int rt2x00queue_initialize(struct rt2x00_dev *rt2x00dev)
  struct data_queue *queue;
  int status;
 
- status = rt2x00queue_alloc_entries(rt2x00dev->rx, rt2x00dev->ops->rx);
+ status = rt2x00queue_alloc_entries(rt2x00dev->rx);
  if (status)
   goto exit;
 
  tx_queue_for_each(rt2x00dev, queue) {
-  status = rt2x00queue_alloc_entries(queue, rt2x00dev->ops->tx);
+  status = rt2x00queue_alloc_entries(queue);
   if (status)
    goto exit;
  }
 
- status = rt2x00queue_alloc_entries(rt2x00dev->bcn, rt2x00dev->ops->bcn);
+ status = rt2x00queue_alloc_entries(rt2x00dev->bcn);
  if (status)
   goto exit;
 
  if (test_bit(REQUIRE_ATIM_QUEUE, &rt2x00dev->cap_flags)) {
-  status = rt2x00queue_alloc_entries(rt2x00dev->atim,
-         rt2x00dev->ops->atim);
+  status = rt2x00queue_alloc_entries(rt2x00dev->atim);
   if (status)
    goto exit;
  }
@@ -1301,6 +1266,10 @@ static void rt2x00queue_init(struct rt2x00_dev *rt2x00dev,
  queue->aifs = 2;
  queue->cw_min = 5;
  queue->cw_max = 10;
+
+ rt2x00dev->ops->queue_init(queue);
+
+ queue->threshold = DIV_ROUND_UP(queue->limit, 10);
 }
 
 int rt2x00queue_allocate(struct rt2x00_dev *rt2x00dev)
diff --git a/drivers/net/wireless/rt2x00/rt2x00queue.h b/drivers/net/wireless/rt2x00/rt2x00queue.h
index 4a7b34e..c48125b 100644
--- a/drivers/net/wireless/rt2x00/rt2x00queue.h
+++ b/drivers/net/wireless/rt2x00/rt2x00queue.h
@@ -13,9 +13,7 @@
  GNU General Public License for more details.
 
  You should have received a copy of the GNU General Public License
- along with this program; if not, write to the
- Free Software Foundation, Inc.,
- 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ along with this program; if not, see <http://www.gnu.org/licenses/>.
  */
 
 /*
@@ -453,6 +451,7 @@ enum data_queue_flags {
  * @cw_max: The cw max value for outgoing frames (field ignored in RX queue).
  * @data_size: Maximum data size for the frames in this queue.
  * @desc_size: Hardware descriptor size for the data in this queue.
+ * @priv_size: Size of per-queue_entry private data.
  * @usb_endpoint: Device endpoint used for communication (USB only)
  * @usb_maxpacket: Max packet size for given endpoint (USB only)
  */
@@ -481,31 +480,13 @@ struct data_queue {
  unsigned short data_size;
  unsigned char  desc_size;
  unsigned char  winfo_size;
+ unsigned short priv_size;
 
  unsigned short usb_endpoint;
  unsigned short usb_maxpacket;
 };
 
 /**
- * struct data_queue_desc: Data queue description
- *
- * The information in this structure is used by drivers
- * to inform rt2x00lib about the creation of the data queue.
- *
- * @entry_num: Maximum number of entries for a queue.
- * @data_size: Maximum data size for the frames in this queue.
- * @desc_size: Hardware descriptor size for the data in this queue.
- * @priv_size: Size of per-queue_entry private data.
- */
-struct data_queue_desc {
- unsigned short entry_num;
- unsigned short data_size;
- unsigned char  desc_size;
- unsigned char  winfo_size;
- unsigned short priv_size;
-};
-
-/**
  * queue_end - Return pointer to the last queue (HELPER MACRO).
  * @__dev: Pointer to &struct rt2x00_dev
  *
diff --git a/drivers/net/wireless/rt2x00/rt2x00reg.h b/drivers/net/wireless/rt2x00/rt2x00reg.h
index 6f867ee..3cc541d 100644
--- a/drivers/net/wireless/rt2x00/rt2x00reg.h
+++ b/drivers/net/wireless/rt2x00/rt2x00reg.h
@@ -13,9 +13,7 @@
  GNU General Public License for more details.
 
  You should have received a copy of the GNU General Public License
- along with this program; if not, write to the
- Free Software Foundation, Inc.,
- 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ along with this program; if not, see <http://www.gnu.org/licenses/>.
  */
 
 /*
diff --git a/drivers/net/wireless/rt2x00/rt2x00soc.c b/drivers/net/wireless/rt2x00/rt2x00soc.c
index 9271a5f..69a0cda 100644
--- a/drivers/net/wireless/rt2x00/rt2x00soc.c
+++ b/drivers/net/wireless/rt2x00/rt2x00soc.c
@@ -14,9 +14,7 @@
  GNU General Public License for more details.
 
  You should have received a copy of the GNU General Public License
- along with this program; if not, write to the
- Free Software Foundation, Inc.,
- 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ along with this program; if not, see <http://www.gnu.org/licenses/>.
  */
 
 /*
diff --git a/drivers/net/wireless/rt2x00/rt2x00soc.h b/drivers/net/wireless/rt2x00/rt2x00soc.h
index 474cbfc..9948d35 100644
--- a/drivers/net/wireless/rt2x00/rt2x00soc.h
+++ b/drivers/net/wireless/rt2x00/rt2x00soc.h
@@ -13,9 +13,7 @@
  GNU General Public License for more details.
 
  You should have received a copy of the GNU General Public License
- along with this program; if not, write to the
- Free Software Foundation, Inc.,
- 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ along with this program; if not, see <http://www.gnu.org/licenses/>.
  */
 
 /*
diff --git a/drivers/net/wireless/rt2x00/rt2x00usb.c b/drivers/net/wireless/rt2x00/rt2x00usb.c
index 8828987..86c43d1 100644
--- a/drivers/net/wireless/rt2x00/rt2x00usb.c
+++ b/drivers/net/wireless/rt2x00/rt2x00usb.c
@@ -14,9 +14,7 @@
  GNU General Public License for more details.
 
  You should have received a copy of the GNU General Public License
- along with this program; if not, write to the
- Free Software Foundation, Inc.,
- 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ along with this program; if not, see <http://www.gnu.org/licenses/>.
  */
 
 /*
@@ -70,6 +68,12 @@ int rt2x00usb_vendor_request(struct rt2x00_dev *rt2x00dev,
   }
  }
 
+ /* If the port is powered down, we get a -EPROTO error, and this
+  * leads to a endless loop. So just say that the device is gone.
+  */
+ if (status == -EPROTO)
+  clear_bit(DEVICE_STATE_PRESENT, &rt2x00dev->flags);
+
  rt2x00_err(rt2x00dev,
      "Vendor Request 0x%02x failed for offset 0x%04x with error %d\n",
      request, offset, status);
@@ -523,7 +527,9 @@ static void rt2x00usb_watchdog_tx_dma(struct data_queue *queue)
  rt2x00_warn(queue->rt2x00dev, "TX queue %d DMA timed out, invoke forced forced reset\n",
       queue->qid);
 
+ rt2x00queue_stop_queue(queue);
  rt2x00queue_flush_queue(queue, true);
+ rt2x00queue_start_queue(queue);
 }
 
 static int rt2x00usb_dma_timeout(struct data_queue *queue)
diff --git a/drivers/net/wireless/rt2x00/rt2x00usb.h b/drivers/net/wireless/rt2x00/rt2x00usb.h
index 323ca7b..831b65f 100644
--- a/drivers/net/wireless/rt2x00/rt2x00usb.h
+++ b/drivers/net/wireless/rt2x00/rt2x00usb.h
@@ -13,9 +13,7 @@
  GNU General Public License for more details.
 
  You should have received a copy of the GNU General Public License
- along with this program; if not, write to the
- Free Software Foundation, Inc.,
- 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ along with this program; if not, see <http://www.gnu.org/licenses/>.
  */
 
 /*
@@ -95,6 +93,7 @@ enum rt2x00usb_mode_offset {
  USB_MODE_SLEEP = 7, /* RT73USB */
  USB_MODE_FIRMWARE = 8, /* RT73USB */
  USB_MODE_WAKEUP = 9, /* RT73USB */
+ USB_MODE_AUTORUN = 17, /* RT2800USB */
 };
 
 /**
diff --git a/drivers/net/wireless/rt2x00/rt61pci.c b/drivers/net/wireless/rt2x00/rt61pci.c
index 883a54c..9048a9c 100644
--- a/drivers/net/wireless/rt2x00/rt61pci.c
+++ b/drivers/net/wireless/rt2x00/rt61pci.c
@@ -13,9 +13,7 @@
  GNU General Public License for more details.
 
  You should have received a copy of the GNU General Public License
- along with this program; if not, write to the
- Free Software Foundation, Inc.,
- 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ along with this program; if not, see <http://www.gnu.org/licenses/>.
  */
 
 /*
@@ -27,7 +25,6 @@
 #include <linux/crc-itu-t.h>
 #include <linux/delay.h>
 #include <linux/etherdevice.h>
-#include <linux/init.h>
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/slab.h>
@@ -685,7 +682,7 @@ static void rt61pci_config_antenna_2x(struct rt2x00_dev *rt2x00dev,
 
  rt2x00_set_field8(&r3, BBP_R3_SMART_MODE, rt2x00_rf(rt2x00dev, RF2529));
  rt2x00_set_field8(&r4, BBP_R4_RX_FRAME_END,
-     !test_bit(CAPABILITY_FRAME_TYPE, &rt2x00dev->cap_flags));
+     !rt2x00_has_cap_frame_type(rt2x00dev));
 
  /*
   * Configure the RX antenna.
@@ -813,10 +810,10 @@ static void rt61pci_config_ant(struct rt2x00_dev *rt2x00dev,
 
  if (rt2x00dev->curr_band == IEEE80211_BAND_5GHZ) {
   sel = antenna_sel_a;
-  lna = test_bit(CAPABILITY_EXTERNAL_LNA_A, &rt2x00dev->cap_flags);
+  lna = rt2x00_has_cap_external_lna_a(rt2x00dev);
  } else {
   sel = antenna_sel_bg;
-  lna = test_bit(CAPABILITY_EXTERNAL_LNA_BG, &rt2x00dev->cap_flags);
+  lna = rt2x00_has_cap_external_lna_bg(rt2x00dev);
  }
 
  for (i = 0; i < ARRAY_SIZE(antenna_sel_a); i++)
@@ -836,7 +833,7 @@ static void rt61pci_config_ant(struct rt2x00_dev *rt2x00dev,
  else if (rt2x00_rf(rt2x00dev, RF2527))
   rt61pci_config_antenna_2x(rt2x00dev, ant);
  else if (rt2x00_rf(rt2x00dev, RF2529)) {
-  if (test_bit(CAPABILITY_DOUBLE_ANTENNA, &rt2x00dev->cap_flags))
+  if (rt2x00_has_cap_double_antenna(rt2x00dev))
    rt61pci_config_antenna_2x(rt2x00dev, ant);
   else
    rt61pci_config_antenna_2529(rt2x00dev, ant);
@@ -850,13 +847,13 @@ static void rt61pci_config_lna_gain(struct rt2x00_dev *rt2x00dev,
  short lna_gain = 0;
 
  if (libconf->conf->chandef.chan->band == IEEE80211_BAND_2GHZ) {
-  if (test_bit(CAPABILITY_EXTERNAL_LNA_BG, &rt2x00dev->cap_flags))
+  if (rt2x00_has_cap_external_lna_bg(rt2x00dev))
    lna_gain += 14;
 
   rt2x00_eeprom_read(rt2x00dev, EEPROM_RSSI_OFFSET_BG, &eeprom);
   lna_gain -= rt2x00_get_field16(eeprom, EEPROM_RSSI_OFFSET_BG_1);
  } else {
-  if (test_bit(CAPABILITY_EXTERNAL_LNA_A, &rt2x00dev->cap_flags))
+  if (rt2x00_has_cap_external_lna_a(rt2x00dev))
    lna_gain += 14;
 
   rt2x00_eeprom_read(rt2x00dev, EEPROM_RSSI_OFFSET_A, &eeprom);
@@ -1054,14 +1051,14 @@ static void rt61pci_link_tuner(struct rt2x00_dev *rt2x00dev,
  if (rt2x00dev->curr_band == IEEE80211_BAND_5GHZ) {
   low_bound = 0x28;
   up_bound = 0x48;
-  if (test_bit(CAPABILITY_EXTERNAL_LNA_A, &rt2x00dev->cap_flags)) {
+  if (rt2x00_has_cap_external_lna_a(rt2x00dev)) {
    low_bound += 0x10;
    up_bound += 0x10;
   }
  } else {
   low_bound = 0x20;
   up_bound = 0x40;
-  if (test_bit(CAPABILITY_EXTERNAL_LNA_BG, &rt2x00dev->cap_flags)) {
+  if (rt2x00_has_cap_external_lna_bg(rt2x00dev)) {
    low_bound += 0x10;
    up_bound += 0x10;
   }
@@ -2034,13 +2031,14 @@ static void rt61pci_write_beacon(struct queue_entry *entry,
 static void rt61pci_clear_beacon(struct queue_entry *entry)
 {
  struct rt2x00_dev *rt2x00dev = entry->queue->rt2x00dev;
- u32 reg;
+ u32 orig_reg, reg;
 
  /*
   * Disable beaconing while we are reloading the beacon data,
   * otherwise we might be sending out invalid data.
   */
- rt2x00mmio_register_read(rt2x00dev, TXRX_CSR9, &reg);
+ rt2x00mmio_register_read(rt2x00dev, TXRX_CSR9, &orig_reg);
+ reg = orig_reg;
  rt2x00_set_field32(&reg, TXRX_CSR9_BEACON_GEN, 0);
  rt2x00mmio_register_write(rt2x00dev, TXRX_CSR9, reg);
 
@@ -2051,10 +2049,9 @@ static void rt61pci_clear_beacon(struct queue_entry *entry)
       HW_BEACON_OFFSET(entry->entry_idx), 0);
 
  /*
-  * Enable beaconing again.
+  * Restore global beaconing state.
   */
- rt2x00_set_field32(&reg, TXRX_CSR9_BEACON_GEN, 1);
- rt2x00mmio_register_write(rt2x00dev, TXRX_CSR9, reg);
+ rt2x00mmio_register_write(rt2x00dev, TXRX_CSR9, orig_reg);
 }
 
 /*
@@ -2175,7 +2172,7 @@ static void rt61pci_txdone(struct rt2x00_dev *rt2x00dev)
   * that the TX_STA_FIFO stack has a size of 16. We stick to our
   * tx ring size for now.
   */
- for (i = 0; i < rt2x00dev->ops->tx->entry_num; i++) {
+ for (i = 0; i < rt2x00dev->tx->limit; i++) {
   rt2x00mmio_register_read(rt2x00dev, STA_CSR4, &reg);
   if (!rt2x00_get_field32(reg, STA_CSR4_VALID))
    break;
@@ -2578,7 +2575,7 @@ static int rt61pci_init_eeprom(struct rt2x00_dev *rt2x00dev)
   * eeprom word.
   */
  if (rt2x00_rf(rt2x00dev, RF2529) &&
-     !test_bit(CAPABILITY_DOUBLE_ANTENNA, &rt2x00dev->cap_flags)) {
+     !rt2x00_has_cap_double_antenna(rt2x00dev)) {
   rt2x00dev->default_ant.rx =
       ANTENNA_A + rt2x00_get_field16(eeprom, EEPROM_NIC_RX_FIXED);
   rt2x00dev->default_ant.tx =
@@ -2793,7 +2790,7 @@ static int rt61pci_probe_hw_mode(struct rt2x00_dev *rt2x00dev)
  spec->supported_bands = SUPPORT_BAND_2GHZ;
  spec->supported_rates = SUPPORT_RATE_CCK | SUPPORT_RATE_OFDM;
 
- if (!test_bit(CAPABILITY_RF_SEQUENCE, &rt2x00dev->cap_flags)) {
+ if (!rt2x00_has_cap_rf_sequence(rt2x00dev)) {
   spec->num_channels = 14;
   spec->channels = rf_vals_noseq;
  } else {
@@ -3026,26 +3023,40 @@ static const struct rt2x00lib_ops rt61pci_rt2x00_ops = {
  .config   = rt61pci_config,
 };
 
-static const struct data_queue_desc rt61pci_queue_rx = {
- .entry_num  = 32,
- .data_size  = DATA_FRAME_SIZE,
- .desc_size  = RXD_DESC_SIZE,
- .priv_size  = sizeof(struct queue_entry_priv_mmio),
-};
+static void rt61pci_queue_init(struct data_queue *queue)
+{
+ switch (queue->qid) {
+ case QID_RX:
+  queue->limit = 32;
+  queue->data_size = DATA_FRAME_SIZE;
+  queue->desc_size = RXD_DESC_SIZE;
+  queue->priv_size = sizeof(struct queue_entry_priv_mmio);
+  break;
 
-static const struct data_queue_desc rt61pci_queue_tx = {
- .entry_num  = 32,
- .data_size  = DATA_FRAME_SIZE,
- .desc_size  = TXD_DESC_SIZE,
- .priv_size  = sizeof(struct queue_entry_priv_mmio),
-};
+ case QID_AC_VO:
+ case QID_AC_VI:
+ case QID_AC_BE:
+ case QID_AC_BK:
+  queue->limit = 32;
+  queue->data_size = DATA_FRAME_SIZE;
+  queue->desc_size = TXD_DESC_SIZE;
+  queue->priv_size = sizeof(struct queue_entry_priv_mmio);
+  break;
 
-static const struct data_queue_desc rt61pci_queue_bcn = {
- .entry_num  = 4,
- .data_size  = 0, /* No DMA required for beacons */
- .desc_size  = TXINFO_SIZE,
- .priv_size  = sizeof(struct queue_entry_priv_mmio),
-};
+ case QID_BEACON:
+  queue->limit = 4;
+  queue->data_size = 0; /* No DMA required for beacons */
+  queue->desc_size = TXINFO_SIZE;
+  queue->priv_size = sizeof(struct queue_entry_priv_mmio);
+  break;
+
+ case QID_ATIM:
+  /* fallthrough */
+ default:
+  BUG();
+  break;
+ }
+}
 
 static const struct rt2x00_ops rt61pci_ops = {
  .name   = KBUILD_MODNAME,
@@ -3053,10 +3064,7 @@ static const struct rt2x00_ops rt61pci_ops = {
  .eeprom_size  = EEPROM_SIZE,
  .rf_size  = RF_SIZE,
  .tx_queues  = NUM_TX_QUEUES,
- .extra_tx_headroom = 0,
- .rx   = &rt61pci_queue_rx,
- .tx   = &rt61pci_queue_tx,
- .bcn   = &rt61pci_queue_bcn,
+ .queue_init  = rt61pci_queue_init,
  .lib   = &rt61pci_rt2x00_ops,
  .hw   = &rt61pci_mac80211_ops,
 #ifdef CONFIG_RT2X00_LIB_DEBUGFS
diff --git a/drivers/net/wireless/rt2x00/rt61pci.h b/drivers/net/wireless/rt2x00/rt61pci.h
index 9bc6b60..1442075 100644
--- a/drivers/net/wireless/rt2x00/rt61pci.h
+++ b/drivers/net/wireless/rt2x00/rt61pci.h
@@ -13,9 +13,7 @@
  GNU General Public License for more details.
 
  You should have received a copy of the GNU General Public License
- along with this program; if not, write to the
- Free Software Foundation, Inc.,
- 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ along with this program; if not, see <http://www.gnu.org/licenses/>.
  */
 
 /*
diff --git a/drivers/net/wireless/rt2x00/rt73usb.c b/drivers/net/wireless/rt2x00/rt73usb.c
index 2bbca18..95724ff 100644
--- a/drivers/net/wireless/rt2x00/rt73usb.c
+++ b/drivers/net/wireless/rt2x00/rt73usb.c
@@ -13,9 +13,7 @@
  GNU General Public License for more details.
 
  You should have received a copy of the GNU General Public License
- along with this program; if not, write to the
- Free Software Foundation, Inc.,
- 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ along with this program; if not, see <http://www.gnu.org/licenses/>.
  */
 
 /*
@@ -27,7 +25,6 @@
 #include <linux/crc-itu-t.h>
 #include <linux/delay.h>
 #include <linux/etherdevice.h>
-#include <linux/init.h>
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/slab.h>
@@ -595,8 +592,8 @@ static void rt73usb_config_antenna_5x(struct rt2x00_dev *rt2x00dev,
  switch (ant->rx) {
  case ANTENNA_HW_DIVERSITY:
   rt2x00_set_field8(&r4, BBP_R4_RX_ANTENNA_CONTROL, 2);
-  temp = !test_bit(CAPABILITY_FRAME_TYPE, &rt2x00dev->cap_flags)
-         && (rt2x00dev->curr_band != IEEE80211_BAND_5GHZ);
+  temp = !rt2x00_has_cap_frame_type(rt2x00dev) &&
+         (rt2x00dev->curr_band != IEEE80211_BAND_5GHZ);
   rt2x00_set_field8(&r4, BBP_R4_RX_FRAME_END, temp);
   break;
  case ANTENNA_A:
@@ -636,7 +633,7 @@ static void rt73usb_config_antenna_2x(struct rt2x00_dev *rt2x00dev,
 
  rt2x00_set_field8(&r3, BBP_R3_SMART_MODE, 0);
  rt2x00_set_field8(&r4, BBP_R4_RX_FRAME_END,
-     !test_bit(CAPABILITY_FRAME_TYPE, &rt2x00dev->cap_flags));
+     !rt2x00_has_cap_frame_type(rt2x00dev));
 
  /*
   * Configure the RX antenna.
@@ -709,10 +706,10 @@ static void rt73usb_config_ant(struct rt2x00_dev *rt2x00dev,
 
  if (rt2x00dev->curr_band == IEEE80211_BAND_5GHZ) {
   sel = antenna_sel_a;
-  lna = test_bit(CAPABILITY_EXTERNAL_LNA_A, &rt2x00dev->cap_flags);
+  lna = rt2x00_has_cap_external_lna_a(rt2x00dev);
  } else {
   sel = antenna_sel_bg;
-  lna = test_bit(CAPABILITY_EXTERNAL_LNA_BG, &rt2x00dev->cap_flags);
+  lna = rt2x00_has_cap_external_lna_bg(rt2x00dev);
  }
 
  for (i = 0; i < ARRAY_SIZE(antenna_sel_a); i++)
@@ -740,7 +737,7 @@ static void rt73usb_config_lna_gain(struct rt2x00_dev *rt2x00dev,
  short lna_gain = 0;
 
  if (libconf->conf->chandef.chan->band == IEEE80211_BAND_2GHZ) {
-  if (test_bit(CAPABILITY_EXTERNAL_LNA_BG, &rt2x00dev->cap_flags))
+  if (rt2x00_has_cap_external_lna_bg(rt2x00dev))
    lna_gain += 14;
 
   rt2x00_eeprom_read(rt2x00dev, EEPROM_RSSI_OFFSET_BG, &eeprom);
@@ -930,7 +927,7 @@ static void rt73usb_link_tuner(struct rt2x00_dev *rt2x00dev,
   low_bound = 0x28;
   up_bound = 0x48;
 
-  if (test_bit(CAPABILITY_EXTERNAL_LNA_A, &rt2x00dev->cap_flags)) {
+  if (rt2x00_has_cap_external_lna_a(rt2x00dev)) {
    low_bound += 0x10;
    up_bound += 0x10;
   }
@@ -946,7 +943,7 @@ static void rt73usb_link_tuner(struct rt2x00_dev *rt2x00dev,
    up_bound = 0x1c;
   }
 
-  if (test_bit(CAPABILITY_EXTERNAL_LNA_BG, &rt2x00dev->cap_flags)) {
+  if (rt2x00_has_cap_external_lna_bg(rt2x00dev)) {
    low_bound += 0x14;
    up_bound += 0x10;
   }
@@ -1600,13 +1597,14 @@ static void rt73usb_clear_beacon(struct queue_entry *entry)
 {
  struct rt2x00_dev *rt2x00dev = entry->queue->rt2x00dev;
  unsigned int beacon_base;
- u32 reg;
+ u32 orig_reg, reg;
 
  /*
   * Disable beaconing while we are reloading the beacon data,
   * otherwise we might be sending out invalid data.
   */
- rt2x00usb_register_read(rt2x00dev, TXRX_CSR9, &reg);
+ rt2x00usb_register_read(rt2x00dev, TXRX_CSR9, &orig_reg);
+ reg = orig_reg;
  rt2x00_set_field32(&reg, TXRX_CSR9_BEACON_GEN, 0);
  rt2x00usb_register_write(rt2x00dev, TXRX_CSR9, reg);
 
@@ -1617,10 +1615,9 @@ static void rt73usb_clear_beacon(struct queue_entry *entry)
  rt2x00usb_register_write(rt2x00dev, beacon_base, 0);
 
  /*
-  * Enable beaconing again.
+  * Restore beaconing state.
   */
- rt2x00_set_field32(&reg, TXRX_CSR9_BEACON_GEN, 1);
- rt2x00usb_register_write(rt2x00dev, TXRX_CSR9, reg);
+ rt2x00usb_register_write(rt2x00dev, TXRX_CSR9, orig_reg);
 }
 
 static int rt73usb_get_tx_data_len(struct queue_entry *entry)
@@ -1661,7 +1658,7 @@ static int rt73usb_agc_to_rssi(struct rt2x00_dev *rt2x00dev, int rxd_w1)
  }
 
  if (rt2x00dev->curr_band == IEEE80211_BAND_5GHZ) {
-  if (test_bit(CAPABILITY_EXTERNAL_LNA_A, &rt2x00dev->cap_flags)) {
+  if (rt2x00_has_cap_external_lna_a(rt2x00dev)) {
    if (lna == 3 || lna == 2)
     offset += 10;
   } else {
@@ -2360,26 +2357,40 @@ static const struct rt2x00lib_ops rt73usb_rt2x00_ops = {
  .config   = rt73usb_config,
 };
 
-static const struct data_queue_desc rt73usb_queue_rx = {
- .entry_num  = 32,
- .data_size  = DATA_FRAME_SIZE,
- .desc_size  = RXD_DESC_SIZE,
- .priv_size  = sizeof(struct queue_entry_priv_usb),
-};
+static void rt73usb_queue_init(struct data_queue *queue)
+{
+ switch (queue->qid) {
+ case QID_RX:
+  queue->limit = 32;
+  queue->data_size = DATA_FRAME_SIZE;
+  queue->desc_size = RXD_DESC_SIZE;
+  queue->priv_size = sizeof(struct queue_entry_priv_usb);
+  break;
 
-static const struct data_queue_desc rt73usb_queue_tx = {
- .entry_num  = 32,
- .data_size  = DATA_FRAME_SIZE,
- .desc_size  = TXD_DESC_SIZE,
- .priv_size  = sizeof(struct queue_entry_priv_usb),
-};
+ case QID_AC_VO:
+ case QID_AC_VI:
+ case QID_AC_BE:
+ case QID_AC_BK:
+  queue->limit = 32;
+  queue->data_size = DATA_FRAME_SIZE;
+  queue->desc_size = TXD_DESC_SIZE;
+  queue->priv_size = sizeof(struct queue_entry_priv_usb);
+  break;
 
-static const struct data_queue_desc rt73usb_queue_bcn = {
- .entry_num  = 4,
- .data_size  = MGMT_FRAME_SIZE,
- .desc_size  = TXINFO_SIZE,
- .priv_size  = sizeof(struct queue_entry_priv_usb),
-};
+ case QID_BEACON:
+  queue->limit = 4;
+  queue->data_size = MGMT_FRAME_SIZE;
+  queue->desc_size = TXINFO_SIZE;
+  queue->priv_size = sizeof(struct queue_entry_priv_usb);
+  break;
+
+ case QID_ATIM:
+  /* fallthrough */
+ default:
+  BUG();
+  break;
+ }
+}
 
 static const struct rt2x00_ops rt73usb_ops = {
  .name   = KBUILD_MODNAME,
@@ -2387,10 +2398,7 @@ static const struct rt2x00_ops rt73usb_ops = {
  .eeprom_size  = EEPROM_SIZE,
  .rf_size  = RF_SIZE,
  .tx_queues  = NUM_TX_QUEUES,
- .extra_tx_headroom = TXD_DESC_SIZE,
- .rx   = &rt73usb_queue_rx,
- .tx   = &rt73usb_queue_tx,
- .bcn   = &rt73usb_queue_bcn,
+ .queue_init  = rt73usb_queue_init,
  .lib   = &rt73usb_rt2x00_ops,
  .hw   = &rt73usb_mac80211_ops,
 #ifdef CONFIG_RT2X00_LIB_DEBUGFS
diff --git a/drivers/net/wireless/rt2x00/rt73usb.h b/drivers/net/wireless/rt2x00/rt73usb.h
index 7577e0b..4a4f235 100644
--- a/drivers/net/wireless/rt2x00/rt73usb.h
+++ b/drivers/net/wireless/rt2x00/rt73usb.h
@@ -13,9 +13,7 @@
  GNU General Public License for more details.
 
  You should have received a copy of the GNU General Public License
- along with this program; if not, write to the
- Free Software Foundation, Inc.,
- 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ along with this program; if not, see <http://www.gnu.org/licenses/>.
  */
 
 /*
-- 
1.7.1