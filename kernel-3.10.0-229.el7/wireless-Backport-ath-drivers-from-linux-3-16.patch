From 0358ca4c29d02b6fe4939018e485294a1d2acc77 Mon Sep 17 00:00:00 2001
From: Stanislaw Gruszka <sgruszka@redhat.com>
Date: Fri, 5 Sep 2014 11:23:46 -0400
Subject: [wireless] Backport ath drivers from linux 3.16

Message-id: <1409916232-5882-10-git-send-email-sgruszka@redhat.com>
Patchwork-id: 91441
O-Subject: [RHEL7 PATCH 09/15] Backport ath drivers from linux 3.16
Bugzilla: 1136324
RH-Acked-by: John Linville <linville@redhat.com>
RH-Acked-by: Prarit Bhargava <prarit@redhat.com>
RH-Acked-by: John Greene <jogreene@redhat.com>

BZ#1136324

Decription:
Sync ath drivers to code from linux 3.16 (up to commit
19583ca584d6f574384e17fe7613dfaeadcdc4a6).

Brew:
https://brewweb.devel.redhat.com/taskinfo?taskID=7918052

Testing:
Tested on AR5418 adapter.

Signed-off-by: Jarod Wilson <jarod@redhat.com>

diff --git a/drivers/net/wireless/ath/Kconfig b/drivers/net/wireless/ath/Kconfig
index 2c02b4e..519647d 100644
--- a/drivers/net/wireless/ath/Kconfig
+++ b/drivers/net/wireless/ath/Kconfig
@@ -25,6 +25,23 @@ config ATH_DEBUG
    Say Y, if you want to debug atheros wireless drivers.
    Right now only ath9k makes use of this.
 
+config ATH_REG_DYNAMIC_USER_REG_HINTS
+ bool "Atheros dynamic user regulatory hints"
+ depends on CFG80211_CERTIFICATION_ONUS
+ default n
+ ---help---
+   Say N. This should only be enabled in countries where
+   this feature is explicitly allowed and only on cards that
+   specifically have been tested for this.
+
+config ATH_REG_DYNAMIC_USER_CERT_TESTING
+ bool "Atheros dynamic user regulatory testing"
+ depends on ATH_REG_DYNAMIC_USER_REG_HINTS && CFG80211_CERTIFICATION_ONUS
+ default n
+ ---help---
+   Say N. This should only be enabled on systems
+   undergoing certification testing.
+
 source "drivers/net/wireless/ath/ath5k/Kconfig"
 source "drivers/net/wireless/ath/ath9k/Kconfig"
 source "drivers/net/wireless/ath/carl9170/Kconfig"
diff --git a/drivers/net/wireless/ath/Makefile b/drivers/net/wireless/ath/Makefile
index 97b964d..606d899 100644
--- a/drivers/net/wireless/ath/Makefile
+++ b/drivers/net/wireless/ath/Makefile
@@ -10,7 +10,9 @@ obj-$(CONFIG_ATH_COMMON) += ath.o
 ath-objs := main.o \
   regd.o \
   hw.o \
-  key.o
+  key.o \
+  dfs_pattern_detector.o \
+  dfs_pri_detector.o
 
 ath-$(CONFIG_ATH_DEBUG) += debug.o
 ccflags-y += -D__CHECK_ENDIAN__
diff --git a/drivers/net/wireless/ath/ar5523/ar5523.c b/drivers/net/wireless/ath/ar5523/ar5523.c
index 17d7fec..f920506 100644
--- a/drivers/net/wireless/ath/ar5523/ar5523.c
+++ b/drivers/net/wireless/ath/ar5523/ar5523.c
@@ -25,7 +25,6 @@
  * that and only has minimal functionality.
  */
 #include <linux/compiler.h>
-#include <linux/init.h>
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/list.h>
@@ -1091,7 +1090,8 @@ static int ar5523_set_rts_threshold(struct ieee80211_hw *hw, u32 value)
  return ret;
 }
 
-static void ar5523_flush(struct ieee80211_hw *hw, u32 queues, bool drop)
+static void ar5523_flush(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
+    u32 queues, bool drop)
 {
  struct ar5523 *ar = hw->priv;
 
@@ -1762,9 +1762,10 @@ static struct usb_device_id ar5523_id_table[] = {
  AR5523_DEVICE_UX(0x2001, 0x3a00), /* Dlink / DWLAG132 */
  AR5523_DEVICE_UG(0x2001, 0x3a02), /* Dlink / DWLG132 */
  AR5523_DEVICE_UX(0x2001, 0x3a04), /* Dlink / DWLAG122 */
+ AR5523_DEVICE_UG(0x07d1, 0x3a07), /* D-Link / WUA-2340 rev A1 */
  AR5523_DEVICE_UG(0x1690, 0x0712), /* Gigaset / AR5523 */
  AR5523_DEVICE_UG(0x1690, 0x0710), /* Gigaset / SMCWUSBTG */
- AR5523_DEVICE_UG(0x129b, 0x160c), /* Gigaset / USB stick 108
+ AR5523_DEVICE_UG(0x129b, 0x160b), /* Gigaset / USB stick 108
          (CyberTAN Technology) */
  AR5523_DEVICE_UG(0x16ab, 0x7801), /* Globalsun / AR5523_1 */
  AR5523_DEVICE_UX(0x16ab, 0x7811), /* Globalsun / AR5523_2 */
diff --git a/drivers/net/wireless/ath/ath.h b/drivers/net/wireless/ath/ath.h
index 4521342..a889fd6 100644
--- a/drivers/net/wireless/ath/ath.h
+++ b/drivers/net/wireless/ath/ath.h
@@ -17,6 +17,7 @@
 #ifndef ATH_H
 #define ATH_H
 
+#include <linux/etherdevice.h>
 #include <linux/skbuff.h>
 #include <linux/if_ether.h>
 #include <linux/spinlock.h>
@@ -55,6 +56,15 @@ enum ath_device_state {
  ATH_HW_INITIALIZED,
 };
 
+enum ath_op_flags {
+ ATH_OP_INVALID,
+ ATH_OP_BEACONS,
+ ATH_OP_ANI_RUN,
+ ATH_OP_PRIM_STA_VIF,
+ ATH_OP_HW_RESET,
+ ATH_OP_SCANNING,
+};
+
 enum ath_bus_type {
  ATH_PCI,
  ATH_AHB,
@@ -62,7 +72,7 @@ enum ath_bus_type {
 };
 
 struct reg_dmn_pair_mapping {
- u16 regDmnEnum;
+ u16 reg_domain;
  u16 reg_5ghz_ctl;
  u16 reg_2ghz_ctl;
 };
@@ -129,6 +139,7 @@ struct ath_common {
  struct ieee80211_hw *hw;
  int debug_mask;
  enum ath_device_state state;
+ unsigned long op_flags;
 
  struct ath_ani ani;
 
@@ -159,12 +170,16 @@ struct ath_common {
 
  bool btcoex_enabled;
  bool disable_ani;
- bool antenna_diversity;
+ bool bt_ant_diversity;
+
+ int last_rssi;
+ struct ieee80211_supported_band sbands[IEEE80211_NUM_BANDS];
 };
 
 struct sk_buff *ath_rxbuf_alloc(struct ath_common *common,
     u32 len,
     gfp_t gfp_mask);
+bool ath_is_mybeacon(struct ath_common *common, struct ieee80211_hdr *hdr);
 
 void ath_hw_setbssidmask(struct ath_common *common);
 void ath_key_delete(struct ath_common *common, struct ieee80211_key_conf *key);
@@ -239,13 +254,12 @@ enum ATH_DEBUG {
  ATH_DBG_CONFIG  = 0x00000200,
  ATH_DBG_FATAL  = 0x00000400,
  ATH_DBG_PS  = 0x00000800,
- ATH_DBG_HWTIMER  = 0x00001000,
- ATH_DBG_BTCOEX  = 0x00002000,
- ATH_DBG_WMI  = 0x00004000,
- ATH_DBG_BSTUCK  = 0x00008000,
- ATH_DBG_MCI  = 0x00010000,
- ATH_DBG_DFS  = 0x00020000,
- ATH_DBG_WOW  = 0x00040000,
+ ATH_DBG_BTCOEX  = 0x00001000,
+ ATH_DBG_WMI  = 0x00002000,
+ ATH_DBG_BSTUCK  = 0x00004000,
+ ATH_DBG_MCI  = 0x00008000,
+ ATH_DBG_DFS  = 0x00010000,
+ ATH_DBG_WOW  = 0x00020000,
  ATH_DBG_ANY  = 0xffffffff
 };
 
diff --git a/drivers/net/wireless/ath/ath5k/ahb.c b/drivers/net/wireless/ath/ath5k/ahb.c
index 8e8bcc7..79bffe1 100644
--- a/drivers/net/wireless/ath/ath5k/ahb.c
+++ b/drivers/net/wireless/ath/ath5k/ahb.c
@@ -37,12 +37,9 @@ ath5k_ahb_eeprom_read(struct ath_common *common, u32 off, u16 *data)
 {
  struct ath5k_hw *ah = common->priv;
  struct platform_device *pdev = to_platform_device(ah->dev);
- struct ar231x_board_config *bcfg = pdev->dev.platform_data;
+ struct ar231x_board_config *bcfg = dev_get_platdata(&pdev->dev);
  u16 *eeprom, *eeprom_end;
 
-
-
- bcfg = pdev->dev.platform_data;
  eeprom = (u16 *) bcfg->radio;
  eeprom_end = ((void *) bcfg->config) + BOARD_CONFIG_BUFSZ;
 
@@ -57,7 +54,7 @@ ath5k_ahb_eeprom_read(struct ath_common *common, u32 off, u16 *data)
 int ath5k_hw_read_srev(struct ath5k_hw *ah)
 {
  struct platform_device *pdev = to_platform_device(ah->dev);
- struct ar231x_board_config *bcfg = pdev->dev.platform_data;
+ struct ar231x_board_config *bcfg = dev_get_platdata(&pdev->dev);
  ah->ah_mac_srev = bcfg->devid;
  return 0;
 }
@@ -65,7 +62,7 @@ int ath5k_hw_read_srev(struct ath5k_hw *ah)
 static int ath5k_ahb_eeprom_read_mac(struct ath5k_hw *ah, u8 *mac)
 {
  struct platform_device *pdev = to_platform_device(ah->dev);
- struct ar231x_board_config *bcfg = pdev->dev.platform_data;
+ struct ar231x_board_config *bcfg = dev_get_platdata(&pdev->dev);
  u8 *cfg_mac;
 
  if (to_platform_device(ah->dev)->id == 0)
@@ -87,7 +84,7 @@ static const struct ath_bus_ops ath_ahb_bus_ops = {
 /*Initialization*/
 static int ath_ahb_probe(struct platform_device *pdev)
 {
- struct ar231x_board_config *bcfg = pdev->dev.platform_data;
+ struct ar231x_board_config *bcfg = dev_get_platdata(&pdev->dev);
  struct ath5k_hw *ah;
  struct ieee80211_hw *hw;
  struct resource *res;
@@ -96,7 +93,7 @@ static int ath_ahb_probe(struct platform_device *pdev)
  int ret = 0;
  u32 reg;
 
- if (!pdev->dev.platform_data) {
+ if (!dev_get_platdata(&pdev->dev)) {
   dev_err(&pdev->dev, "no platform data specified\n");
   ret = -EINVAL;
   goto err_out;
@@ -185,7 +182,6 @@ static int ath_ahb_probe(struct platform_device *pdev)
 
  err_free_hw:
  ieee80211_free_hw(hw);
- platform_set_drvdata(pdev, NULL);
  err_iounmap:
         iounmap(mem);
  err_out:
@@ -194,7 +190,7 @@ static int ath_ahb_probe(struct platform_device *pdev)
 
 static int ath_ahb_remove(struct platform_device *pdev)
 {
- struct ar231x_board_config *bcfg = pdev->dev.platform_data;
+ struct ar231x_board_config *bcfg = dev_get_platdata(&pdev->dev);
  struct ieee80211_hw *hw = platform_get_drvdata(pdev);
  struct ath5k_hw *ah;
  u32 reg;
@@ -221,7 +217,6 @@ static int ath_ahb_remove(struct platform_device *pdev)
 
  ath5k_deinit_ah(ah);
  iounmap(ah->iobase);
- platform_set_drvdata(pdev, NULL);
  ieee80211_free_hw(hw);
 
  return 0;
diff --git a/drivers/net/wireless/ath/ath5k/ath5k.h b/drivers/net/wireless/ath/ath5k/ath5k.h
index 2d691b8..74bd54d 100644
--- a/drivers/net/wireless/ath/ath5k/ath5k.h
+++ b/drivers/net/wireless/ath/ath5k/ath5k.h
@@ -29,6 +29,7 @@
 #include <linux/average.h>
 #include <linux/leds.h>
 #include <net/mac80211.h>
+#include <net/cfg80211.h>
 
 /* RX/TX descriptor hw structs
  * TODO: Driver part should only see sw structs */
diff --git a/drivers/net/wireless/ath/ath5k/base.c b/drivers/net/wireless/ath/ath5k/base.c
index 7f702fe..4b18434 100644
--- a/drivers/net/wireless/ath/ath5k/base.c
+++ b/drivers/net/wireless/ath/ath5k/base.c
@@ -56,10 +56,12 @@
 #include <linux/etherdevice.h>
 #include <linux/nl80211.h>
 
+#include <net/cfg80211.h>
 #include <net/ieee80211_radiotap.h>
 
 #include <asm/unaligned.h>
 
+#include <net/mac80211.h>
 #include "base.h"
 #include "reg.h"
 #include "debug.h"
@@ -164,28 +166,36 @@ static const struct ieee80211_rate ath5k_rates[] = {
    .flags = IEEE80211_RATE_SHORT_PREAMBLE },
  { .bitrate = 60,
    .hw_value = ATH5K_RATE_CODE_6M,
-   .flags = 0 },
+   .flags = IEEE80211_RATE_SUPPORTS_5MHZ |
+     IEEE80211_RATE_SUPPORTS_10MHZ },
  { .bitrate = 90,
    .hw_value = ATH5K_RATE_CODE_9M,
-   .flags = 0 },
+   .flags = IEEE80211_RATE_SUPPORTS_5MHZ |
+     IEEE80211_RATE_SUPPORTS_10MHZ },
  { .bitrate = 120,
    .hw_value = ATH5K_RATE_CODE_12M,
-   .flags = 0 },
+   .flags = IEEE80211_RATE_SUPPORTS_5MHZ |
+     IEEE80211_RATE_SUPPORTS_10MHZ },
  { .bitrate = 180,
    .hw_value = ATH5K_RATE_CODE_18M,
-   .flags = 0 },
+   .flags = IEEE80211_RATE_SUPPORTS_5MHZ |
+     IEEE80211_RATE_SUPPORTS_10MHZ },
  { .bitrate = 240,
    .hw_value = ATH5K_RATE_CODE_24M,
-   .flags = 0 },
+   .flags = IEEE80211_RATE_SUPPORTS_5MHZ |
+     IEEE80211_RATE_SUPPORTS_10MHZ },
  { .bitrate = 360,
    .hw_value = ATH5K_RATE_CODE_36M,
-   .flags = 0 },
+   .flags = IEEE80211_RATE_SUPPORTS_5MHZ |
+     IEEE80211_RATE_SUPPORTS_10MHZ },
  { .bitrate = 480,
    .hw_value = ATH5K_RATE_CODE_48M,
-   .flags = 0 },
+   .flags = IEEE80211_RATE_SUPPORTS_5MHZ |
+     IEEE80211_RATE_SUPPORTS_10MHZ },
  { .bitrate = 540,
    .hw_value = ATH5K_RATE_CODE_54M,
-   .flags = 0 },
+   .flags = IEEE80211_RATE_SUPPORTS_5MHZ |
+     IEEE80211_RATE_SUPPORTS_10MHZ },
 };
 
 static inline u64 ath5k_extend_tsf(struct ath5k_hw *ah, u32 rstamp)
@@ -434,11 +444,27 @@ ath5k_setup_bands(struct ieee80211_hw *hw)
  * Called with ah->lock.
  */
 int
-ath5k_chan_set(struct ath5k_hw *ah, struct ieee80211_channel *chan)
+ath5k_chan_set(struct ath5k_hw *ah, struct cfg80211_chan_def *chandef)
 {
  ATH5K_DBG(ah, ATH5K_DEBUG_RESET,
     "channel set, resetting (%u -> %u MHz)\n",
-    ah->curchan->center_freq, chan->center_freq);
+    ah->curchan->center_freq, chandef->chan->center_freq);
+
+ switch (chandef->width) {
+ case NL80211_CHAN_WIDTH_20:
+ case NL80211_CHAN_WIDTH_20_NOHT:
+  ah->ah_bwmode = AR5K_BWMODE_DEFAULT;
+  break;
+ case NL80211_CHAN_WIDTH_5:
+  ah->ah_bwmode = AR5K_BWMODE_5MHZ;
+  break;
+ case NL80211_CHAN_WIDTH_10:
+  ah->ah_bwmode = AR5K_BWMODE_10MHZ;
+  break;
+ default:
+  WARN_ON(1);
+  return -EINVAL;
+ }
 
  /*
   * To switch channels clear any pending DMA operations;
@@ -446,7 +472,7 @@ ath5k_chan_set(struct ath5k_hw *ah, struct ieee80211_channel *chan)
   * hardware at the new frequency, and then re-enable
   * the relevant bits of the h/w.
   */
- return ath5k_reset(ah, chan, true);
+ return ath5k_reset(ah, chandef->chan, true);
 }
 
 void ath5k_vif_iter(void *data, u8 *mac, struct ieee80211_vif *vif)
@@ -666,9 +692,46 @@ static enum ath5k_pkt_type get_hw_packet_type(struct sk_buff *skb)
  return htype;
 }
 
+static struct ieee80211_rate *
+ath5k_get_rate(const struct ieee80211_hw *hw,
+        const struct ieee80211_tx_info *info,
+        struct ath5k_buf *bf, int idx)
+{
+ /*
+ * convert a ieee80211_tx_rate RC-table entry to
+ * the respective ieee80211_rate struct
+ */
+ if (bf->rates[idx].idx < 0) {
+  return NULL;
+ }
+
+ return &hw->wiphy->bands[info->band]->bitrates[ bf->rates[idx].idx ];
+}
+
+static u16
+ath5k_get_rate_hw_value(const struct ieee80211_hw *hw,
+   const struct ieee80211_tx_info *info,
+   struct ath5k_buf *bf, int idx)
+{
+ struct ieee80211_rate *rate;
+ u16 hw_rate;
+ u8 rc_flags;
+
+ rate = ath5k_get_rate(hw, info, bf, idx);
+ if (!rate)
+  return 0;
+
+ rc_flags = bf->rates[idx].flags;
+ hw_rate = (rc_flags & IEEE80211_TX_RC_USE_SHORT_PREAMBLE) ?
+     rate->hw_value_short : rate->hw_value;
+
+ return hw_rate;
+}
+
 static int
 ath5k_txbuf_setup(struct ath5k_hw *ah, struct ath5k_buf *bf,
-    struct ath5k_txq *txq, int padsize)
+    struct ath5k_txq *txq, int padsize,
+    struct ieee80211_tx_control *control)
 {
  struct ath5k_desc *ds = bf->desc;
  struct sk_buff *skb = bf->skb;
@@ -688,7 +751,14 @@ ath5k_txbuf_setup(struct ath5k_hw *ah, struct ath5k_buf *bf,
  bf->skbaddr = dma_map_single(ah->dev, skb->data, skb->len,
    DMA_TO_DEVICE);
 
- rate = ieee80211_get_tx_rate(ah->hw, info);
+ if (dma_mapping_error(ah->dev, bf->skbaddr))
+  return -ENOSPC;
+
+ ieee80211_get_tx_rates(info->control.vif, (control) ? control->sta : NULL, skb, bf->rates,
+          ARRAY_SIZE(bf->rates));
+
+ rate = ath5k_get_rate(ah->hw, info, bf, 0);
+
  if (!rate) {
   ret = -EINVAL;
   goto err_unmap;
@@ -698,8 +768,8 @@ ath5k_txbuf_setup(struct ath5k_hw *ah, struct ath5k_buf *bf,
   flags |= AR5K_TXDESC_NOACK;
 
  rc_flags = info->control.rates[0].flags;
- hw_rate = (rc_flags & IEEE80211_TX_RC_USE_SHORT_PREAMBLE) ?
-  rate->hw_value_short : rate->hw_value;
+
+ hw_rate = ath5k_get_rate_hw_value(ah->hw, info, bf, 0);
 
  pktlen = skb->len;
 
@@ -722,12 +792,13 @@ ath5k_txbuf_setup(struct ath5k_hw *ah, struct ath5k_buf *bf,
   duration = le16_to_cpu(ieee80211_ctstoself_duration(ah->hw,
    info->control.vif, pktlen, info));
  }
+
  ret = ah->ah_setup_tx_desc(ah, ds, pktlen,
   ieee80211_get_hdrlen_from_skb(skb), padsize,
   get_hw_packet_type(skb),
   (ah->ah_txpower.txp_requested * 2),
   hw_rate,
-  info->control.rates[0].count, keyidx, ah->ah_tx_ant, flags,
+  bf->rates[0].count, keyidx, ah->ah_tx_ant, flags,
   cts_rate, duration);
  if (ret)
   goto err_unmap;
@@ -736,13 +807,15 @@ ath5k_txbuf_setup(struct ath5k_hw *ah, struct ath5k_buf *bf,
  if (ah->ah_capabilities.cap_has_mrr_support) {
   memset(mrr_rate, 0, sizeof(mrr_rate));
   memset(mrr_tries, 0, sizeof(mrr_tries));
+
   for (i = 0; i < 3; i++) {
-   rate = ieee80211_get_alt_retry_rate(ah->hw, info, i);
+
+   rate = ath5k_get_rate(ah->hw, info, bf, i);
    if (!rate)
     break;
 
-   mrr_rate[i] = rate->hw_value;
-   mrr_tries[i] = info->control.rates[i + 1].count;
+   mrr_rate[i] = ath5k_get_rate_hw_value(ah->hw, info, bf, i);
+   mrr_tries[i] = bf->rates[i].count;
   }
 
   ath5k_hw_setup_mrr_tx_desc(ah, ds,
@@ -1168,14 +1241,11 @@ static void
 ath5k_check_ibss_tsf(struct ath5k_hw *ah, struct sk_buff *skb,
        struct ieee80211_rx_status *rxs)
 {
- struct ath_common *common = ath5k_hw_common(ah);
  u64 tsf, bc_tstamp;
  u32 hw_tu;
  struct ieee80211_mgmt *mgmt = (struct ieee80211_mgmt *)skb->data;
 
- if (ieee80211_is_beacon(mgmt->frame_control) &&
-     le16_to_cpu(mgmt->u.beacon.capab_info) & WLAN_CAPABILITY_IBSS &&
-     ether_addr_equal(mgmt->bssid, common->curbssid)) {
+ if (le16_to_cpu(mgmt->u.beacon.capab_info) & WLAN_CAPABILITY_IBSS) {
   /*
    * Received an IBSS beacon with the same BSSID. Hardware *must*
    * have updated the local TSF. We have to work around various
@@ -1231,23 +1301,6 @@ ath5k_check_ibss_tsf(struct ath5k_hw *ah, struct sk_buff *skb,
  }
 }
 
-static void
-ath5k_update_beacon_rssi(struct ath5k_hw *ah, struct sk_buff *skb, int rssi)
-{
- struct ieee80211_mgmt *mgmt = (struct ieee80211_mgmt *)skb->data;
- struct ath_common *common = ath5k_hw_common(ah);
-
- /* only beacons from our BSSID */
- if (!ieee80211_is_beacon(mgmt->frame_control) ||
-     !ether_addr_equal(mgmt->bssid, common->curbssid))
-  return;
-
- ewma_add(&ah->ah_beacon_rssi_avg, rssi);
-
- /* in IBSS mode we should keep RSSI statistics per neighbour */
- /* le16_to_cpu(mgmt->u.beacon.capab_info) & WLAN_CAPABILITY_IBSS */
-}
-
 /*
  * Compute padding position. skb must contain an IEEE 802.11 frame
  */
@@ -1320,6 +1373,7 @@ ath5k_receive_frame(struct ath5k_hw *ah, struct sk_buff *skb,
       struct ath5k_rx_status *rs)
 {
  struct ieee80211_rx_status *rxs;
+ struct ath_common *common = ath5k_hw_common(ah);
 
  ath5k_remove_padding(skb);
 
@@ -1355,6 +1409,16 @@ ath5k_receive_frame(struct ath5k_hw *ah, struct sk_buff *skb,
 
  rxs->rate_idx = ath5k_hw_to_driver_rix(ah, rs->rs_rate);
  rxs->flag |= ath5k_rx_decrypted(ah, skb, rs);
+ switch (ah->ah_bwmode) {
+ case AR5K_BWMODE_5MHZ:
+  rxs->flag |= RX_FLAG_5MHZ;
+  break;
+ case AR5K_BWMODE_10MHZ:
+  rxs->flag |= RX_FLAG_10MHZ;
+  break;
+ default:
+  break;
+ }
 
  if (rxs->rate_idx >= 0 && rs->rs_rate ==
      ah->sbands[ah->curchan->band].bitrates[rxs->rate_idx].hw_value_short)
@@ -1362,11 +1426,13 @@ ath5k_receive_frame(struct ath5k_hw *ah, struct sk_buff *skb,
 
  trace_ath5k_rx(ah, skb);
 
- ath5k_update_beacon_rssi(ah, skb, rs->rs_rssi);
+ if (ath_is_mybeacon(common, (struct ieee80211_hdr *)skb->data)) {
+  ewma_add(&ah->ah_beacon_rssi_avg, rs->rs_rssi);
 
- /* check beacons in IBSS mode */
- if (ah->opmode == NL80211_IFTYPE_ADHOC)
-  ath5k_check_ibss_tsf(ah, skb, rxs);
+  /* check beacons in IBSS mode */
+  if (ah->opmode == NL80211_IFTYPE_ADHOC)
+   ath5k_check_ibss_tsf(ah, skb, rxs);
+ }
 
  ieee80211_rx(ah->hw, skb);
 }
@@ -1515,7 +1581,7 @@ unlock:
 
 void
 ath5k_tx_queue(struct ieee80211_hw *hw, struct sk_buff *skb,
-        struct ath5k_txq *txq)
+        struct ath5k_txq *txq, struct ieee80211_tx_control *control)
 {
  struct ath5k_hw *ah = hw->priv;
  struct ath5k_buf *bf;
@@ -1555,7 +1621,7 @@ ath5k_tx_queue(struct ieee80211_hw *hw, struct sk_buff *skb,
 
  bf->skb = skb;
 
- if (ath5k_txbuf_setup(ah, bf, txq, padsize)) {
+ if (ath5k_txbuf_setup(ah, bf, txq, padsize, control)) {
   bf->skb = NULL;
   spin_lock_irqsave(&ah->txbuflock, flags);
   list_add_tail(&bf->list, &ah->txbuf);
@@ -1571,16 +1637,21 @@ drop_packet:
 
 static void
 ath5k_tx_frame_completed(struct ath5k_hw *ah, struct sk_buff *skb,
-    struct ath5k_txq *txq, struct ath5k_tx_status *ts)
+    struct ath5k_txq *txq, struct ath5k_tx_status *ts,
+    struct ath5k_buf *bf)
 {
  struct ieee80211_tx_info *info;
  u8 tries[3];
  int i;
+ int size = 0;
 
  ah->stats.tx_all_count++;
  ah->stats.tx_bytes_count += skb->len;
  info = IEEE80211_SKB_CB(skb);
 
+ size = min_t(int, sizeof(info->status.rates), sizeof(bf->rates));
+ memcpy(info->status.rates, bf->rates, size);
+
  tries[0] = info->status.rates[0].count;
  tries[1] = info->status.rates[1].count;
  tries[2] = info->status.rates[2].count;
@@ -1663,7 +1734,7 @@ ath5k_tx_processq(struct ath5k_hw *ah, struct ath5k_txq *txq)
 
    dma_unmap_single(ah->dev, bf->skbaddr, skb->len,
      DMA_TO_DEVICE);
-   ath5k_tx_frame_completed(ah, skb, txq, &ts);
+   ath5k_tx_frame_completed(ah, skb, txq, &ts, bf);
   }
 
   /*
@@ -1917,7 +1988,7 @@ ath5k_beacon_send(struct ath5k_hw *ah)
 
  skb = ieee80211_get_buffered_bc(ah->hw, vif);
  while (skb) {
-  ath5k_tx_queue(ah->hw, skb, ah->cabq);
+  ath5k_tx_queue(ah->hw, skb, ah->cabq, NULL);
 
   if (ah->cabq->txq_len >= ah->cabq->txq_max)
    break;
@@ -2442,7 +2513,8 @@ ath5k_init_ah(struct ath5k_hw *ah, const struct ath_bus_ops *bus_ops)
    IEEE80211_HW_HOST_BROADCAST_PS_BUFFERING |
    IEEE80211_HW_SIGNAL_DBM |
    IEEE80211_HW_MFP_CAPABLE |
-   IEEE80211_HW_REPORTS_TX_ACK_STATUS;
+   IEEE80211_HW_REPORTS_TX_ACK_STATUS |
+   IEEE80211_HW_SUPPORTS_RC_TABLE;
 
  hw->wiphy->interface_modes =
   BIT(NL80211_IFTYPE_AP) |
@@ -2456,12 +2528,13 @@ ath5k_init_ah(struct ath5k_hw *ah, const struct ath_bus_ops *bus_ops)
  /* SW support for IBSS_RSN is provided by mac80211 */
  hw->wiphy->flags |= WIPHY_FLAG_IBSS_RSN;
 
+ hw->wiphy->flags |= WIPHY_FLAG_SUPPORTS_5_10_MHZ;
+
  /* both antennas can be configured as RX or TX */
  hw->wiphy->available_antennas_tx = 0x3;
  hw->wiphy->available_antennas_rx = 0x3;
 
  hw->extra_tx_headroom = 2;
- hw->channel_change_time = 5000;
 
  /*
   * Mark the device as detached to avoid processing
diff --git a/drivers/net/wireless/ath/ath5k/base.h b/drivers/net/wireless/ath/ath5k/base.h
index 6c94c7f..97469d0 100644
--- a/drivers/net/wireless/ath/ath5k/base.h
+++ b/drivers/net/wireless/ath/ath5k/base.h
@@ -47,6 +47,7 @@ struct ath5k_hw;
 struct ath5k_txq;
 struct ieee80211_channel;
 struct ath_bus_ops;
+struct ieee80211_tx_control;
 enum nl80211_iftype;
 
 enum ath5k_srev_type {
@@ -61,11 +62,12 @@ struct ath5k_srev_name {
 };
 
 struct ath5k_buf {
- struct list_head list;
- struct ath5k_desc *desc; /* virtual addr of desc */
- dma_addr_t  daddr; /* physical addr of desc */
- struct sk_buff  *skb; /* skbuff for buf */
- dma_addr_t  skbaddr;/* physical addr of skb data */
+ struct list_head  list;
+ struct ath5k_desc  *desc;  /* virtual addr of desc */
+ dma_addr_t   daddr;  /* physical addr of desc */
+ struct sk_buff   *skb;  /* skbuff for buf */
+ dma_addr_t   skbaddr; /* physical addr of skb data */
+ struct ieee80211_tx_rate rates[4]; /* number of multi-rate stages */
 };
 
 struct ath5k_vif {
@@ -99,11 +101,11 @@ void ath5k_set_beacon_filter(struct ieee80211_hw *hw, bool enable);
 
 void ath5k_update_bssid_mask_and_opmode(struct ath5k_hw *ah,
      struct ieee80211_vif *vif);
-int ath5k_chan_set(struct ath5k_hw *ah, struct ieee80211_channel *chan);
+int ath5k_chan_set(struct ath5k_hw *ah, struct cfg80211_chan_def *chandef);
 void ath5k_txbuf_free_skb(struct ath5k_hw *ah, struct ath5k_buf *bf);
 void ath5k_rxbuf_free_skb(struct ath5k_hw *ah, struct ath5k_buf *bf);
 void ath5k_tx_queue(struct ieee80211_hw *hw, struct sk_buff *skb,
-      struct ath5k_txq *txq);
+      struct ath5k_txq *txq, struct ieee80211_tx_control *control);
 
 const char *ath5k_chip_name(enum ath5k_srev_type type, u_int16_t val);
 
diff --git a/drivers/net/wireless/ath/ath5k/debug.c b/drivers/net/wireless/ath/ath5k/debug.c
index 9d00dab..b8d031a 100644
--- a/drivers/net/wireless/ath/ath5k/debug.c
+++ b/drivers/net/wireless/ath/ath5k/debug.c
@@ -245,9 +245,11 @@ static ssize_t write_file_beacon(struct file *file,
  struct ath5k_hw *ah = file->private_data;
  char buf[20];
 
- if (copy_from_user(buf, userbuf, min(count, sizeof(buf))))
+ count = min_t(size_t, count, sizeof(buf) - 1);
+ if (copy_from_user(buf, userbuf, count))
   return -EFAULT;
 
+ buf[count] = '\0';
  if (strncmp(buf, "disable", 7) == 0) {
   AR5K_REG_DISABLE_BITS(ah, AR5K_BEACON, AR5K_BEACON_ENABLE);
   pr_info("debugfs disable beacons\n");
@@ -345,9 +347,11 @@ static ssize_t write_file_debug(struct file *file,
  unsigned int i;
  char buf[20];
 
- if (copy_from_user(buf, userbuf, min(count, sizeof(buf))))
+ count = min_t(size_t, count, sizeof(buf) - 1);
+ if (copy_from_user(buf, userbuf, count))
   return -EFAULT;
 
+ buf[count] = '\0';
  for (i = 0; i < ARRAY_SIZE(dbg_info); i++) {
   if (strncmp(buf, dbg_info[i].name,
      strlen(dbg_info[i].name)) == 0) {
@@ -448,9 +452,11 @@ static ssize_t write_file_antenna(struct file *file,
  unsigned int i;
  char buf[20];
 
- if (copy_from_user(buf, userbuf, min(count, sizeof(buf))))
+ count = min_t(size_t, count, sizeof(buf) - 1);
+ if (copy_from_user(buf, userbuf, count))
   return -EFAULT;
 
+ buf[count] = '\0';
  if (strncmp(buf, "diversity", 9) == 0) {
   ath5k_hw_set_antenna_mode(ah, AR5K_ANTMODE_DEFAULT);
   pr_info("debug: enable diversity\n");
@@ -619,9 +625,11 @@ static ssize_t write_file_frameerrors(struct file *file,
  struct ath5k_statistics *st = &ah->stats;
  char buf[20];
 
- if (copy_from_user(buf, userbuf, min(count, sizeof(buf))))
+ count = min_t(size_t, count, sizeof(buf) - 1);
+ if (copy_from_user(buf, userbuf, count))
   return -EFAULT;
 
+ buf[count] = '\0';
  if (strncmp(buf, "clear", 5) == 0) {
   st->rxerr_crc = 0;
   st->rxerr_phy = 0;
@@ -766,9 +774,11 @@ static ssize_t write_file_ani(struct file *file,
  struct ath5k_hw *ah = file->private_data;
  char buf[20];
 
- if (copy_from_user(buf, userbuf, min(count, sizeof(buf))))
+ count = min_t(size_t, count, sizeof(buf) - 1);
+ if (copy_from_user(buf, userbuf, count))
   return -EFAULT;
 
+ buf[count] = '\0';
  if (strncmp(buf, "sens-low", 8) == 0) {
   ath5k_ani_init(ah, ATH5K_ANI_MODE_MANUAL_HIGH);
  } else if (strncmp(buf, "sens-high", 9) == 0) {
@@ -862,9 +872,11 @@ static ssize_t write_file_queue(struct file *file,
  struct ath5k_hw *ah = file->private_data;
  char buf[20];
 
- if (copy_from_user(buf, userbuf, min(count, sizeof(buf))))
+ count = min_t(size_t, count, sizeof(buf) - 1);
+ if (copy_from_user(buf, userbuf, count))
   return -EFAULT;
 
+ buf[count] = '\0';
  if (strncmp(buf, "start", 5) == 0)
   ieee80211_wake_queues(ah->hw);
  else if (strncmp(buf, "stop", 4) == 0)
diff --git a/drivers/net/wireless/ath/ath5k/dma.c b/drivers/net/wireless/ath/ath5k/dma.c
index ce86f15..e6c52f7 100644
--- a/drivers/net/wireless/ath/ath5k/dma.c
+++ b/drivers/net/wireless/ath/ath5k/dma.c
@@ -616,7 +616,16 @@ ath5k_hw_get_isr(struct ath5k_hw *ah, enum ath5k_int *interrupt_mask)
    * SISRs will also clear PISR so no need to worry here.
    */
 
-  pisr_clear = pisr & ~AR5K_ISR_BITS_FROM_SISRS;
+  /* XXX: There seems to be  an issue on some cards
+   * with tx interrupt flags not being updated
+   * on PISR despite that all Tx interrupt bits
+   *  are cleared on SISRs. Since we handle all
+   * Tx queues all together it shouldn't be an
+   * issue if we clear Tx interrupt flags also
+   *  on PISR to avoid that.
+   */
+  pisr_clear = (pisr & ~AR5K_ISR_BITS_FROM_SISRS) |
+     (pisr & AR5K_INT_TX_ALL);
 
   /*
    * Write to clear them...
@@ -661,7 +670,7 @@ ath5k_hw_get_isr(struct ath5k_hw *ah, enum ath5k_int *interrupt_mask)
    ah->ah_txq_isr_txok_all |= AR5K_REG_MS(sisr1,
       AR5K_SISR1_QCU_TXEOL);
 
-  /* Currently this is not much usefull since we treat
+  /* Currently this is not much useful since we treat
    * all queues the same way if we get a TXURN (update
    * tx trigger level) but we might need it later on*/
   if (pisr & AR5K_ISR_TXURN)
diff --git a/drivers/net/wireless/ath/ath5k/mac80211-ops.c b/drivers/net/wireless/ath/ath5k/mac80211-ops.c
index 06f86f4..afb23b3 100644
--- a/drivers/net/wireless/ath/ath5k/mac80211-ops.c
+++ b/drivers/net/wireless/ath/ath5k/mac80211-ops.c
@@ -66,7 +66,7 @@ ath5k_tx(struct ieee80211_hw *hw, struct ieee80211_tx_control *control,
   return;
  }
 
- ath5k_tx_queue(hw, skb, &ah->txqs[qnum]);
+ ath5k_tx_queue(hw, skb, &ah->txqs[qnum], control);
 }
 
 
@@ -202,7 +202,7 @@ ath5k_config(struct ieee80211_hw *hw, u32 changed)
  mutex_lock(&ah->lock);
 
  if (changed & IEEE80211_CONF_CHANGE_CHANNEL) {
-  ret = ath5k_chan_set(ah, conf->chandef.chan);
+  ret = ath5k_chan_set(ah, &conf->chandef);
   if (ret < 0)
    goto unlock;
  }
@@ -325,7 +325,7 @@ ath5k_prepare_multicast(struct ieee80211_hw *hw,
  struct netdev_hw_addr *ha;
 
  mfilt[0] = 0;
- mfilt[1] = 1;
+ mfilt[1] = 0;
 
  netdev_hw_addr_list_for_each(ha, mc_list) {
   /* calculate XOR of eight 6-bit values */
@@ -681,6 +681,7 @@ ath5k_get_survey(struct ieee80211_hw *hw, int idx, struct survey_info *survey)
  survey->channel = conf->chandef.chan;
  survey->noise = ah->ah_noise_floor;
  survey->filled = SURVEY_INFO_NOISE_DBM |
+   SURVEY_INFO_IN_USE |
    SURVEY_INFO_CHANNEL_TIME |
    SURVEY_INFO_CHANNEL_TIME_BUSY |
    SURVEY_INFO_CHANNEL_TIME_RX |
diff --git a/drivers/net/wireless/ath/ath5k/pcu.c b/drivers/net/wireless/ath/ath5k/pcu.c
index 1f16b42..c60d36a 100644
--- a/drivers/net/wireless/ath/ath5k/pcu.c
+++ b/drivers/net/wireless/ath/ath5k/pcu.c
@@ -144,11 +144,13 @@ ath5k_hw_get_frame_duration(struct ath5k_hw *ah, enum ieee80211_band band,
   sifs = AR5K_INIT_SIFS_HALF_RATE;
   preamble *= 2;
   sym_time *= 2;
+  bitrate = DIV_ROUND_UP(bitrate, 2);
   break;
  case AR5K_BWMODE_5MHZ:
   sifs = AR5K_INIT_SIFS_QUARTER_RATE;
   preamble *= 4;
   sym_time *= 4;
+  bitrate = DIV_ROUND_UP(bitrate, 4);
   break;
  default:
   sifs = AR5K_INIT_SIFS_DEFAULT_BG;
diff --git a/drivers/net/wireless/ath/ath5k/phy.c b/drivers/net/wireless/ath/ath5k/phy.c
index d6bc7cb..0fce1c7 100644
--- a/drivers/net/wireless/ath/ath5k/phy.c
+++ b/drivers/net/wireless/ath/ath5k/phy.c
@@ -110,7 +110,7 @@ ath5k_hw_radio_revision(struct ath5k_hw *ah, enum ieee80211_band band)
   ath5k_hw_reg_write(ah, 0x00010000, AR5K_PHY(0x20));
 
  if (ah->ah_version == AR5K_AR5210) {
-  srev = ath5k_hw_reg_read(ah, AR5K_PHY(256) >> 28) & 0xf;
+  srev = (ath5k_hw_reg_read(ah, AR5K_PHY(256)) >> 28) & 0xf;
   ret = (u16)ath5k_hw_bitswap(srev, 4) + 1;
  } else {
   srev = (ath5k_hw_reg_read(ah, AR5K_PHY(0x100)) >> 24) & 0xff;
@@ -3709,8 +3709,8 @@ ath5k_hw_txpower(struct ath5k_hw *ah, struct ieee80211_channel *channel,
    AR5K_REG_MS(AR5K_TUNE_MAX_TXPOWER, AR5K_TPC_CHIRP),
    AR5K_TPC);
  } else {
-  ath5k_hw_reg_write(ah, AR5K_PHY_TXPOWER_RATE_MAX |
-   AR5K_TUNE_MAX_TXPOWER, AR5K_PHY_TXPOWER_RATE_MAX);
+  ath5k_hw_reg_write(ah, AR5K_TUNE_MAX_TXPOWER,
+   AR5K_PHY_TXPOWER_RATE_MAX);
  }
 
  return 0;
diff --git a/drivers/net/wireless/ath/ath5k/qcu.c b/drivers/net/wireless/ath/ath5k/qcu.c
index 65fe929..0583c69 100644
--- a/drivers/net/wireless/ath/ath5k/qcu.c
+++ b/drivers/net/wireless/ath/ath5k/qcu.c
@@ -566,9 +566,11 @@ int ath5k_hw_set_ifs_intervals(struct ath5k_hw *ah, unsigned int slot_time)
 {
  struct ieee80211_channel *channel = ah->ah_current_channel;
  enum ieee80211_band band;
+ struct ieee80211_supported_band *sband;
  struct ieee80211_rate *rate;
  u32 ack_tx_time, eifs, eifs_clock, sifs, sifs_clock;
  u32 slot_time_clock = ath5k_hw_htoclock(ah, slot_time);
+ u32 rate_flags, i;
 
  if (slot_time < 6 || slot_time_clock > AR5K_SLOT_TIME_MAX)
   return -EINVAL;
@@ -605,7 +607,28 @@ int ath5k_hw_set_ifs_intervals(struct ath5k_hw *ah, unsigned int slot_time)
  else
   band = IEEE80211_BAND_2GHZ;
 
- rate = &ah->sbands[band].bitrates[0];
+ switch (ah->ah_bwmode) {
+ case AR5K_BWMODE_5MHZ:
+  rate_flags = IEEE80211_RATE_SUPPORTS_5MHZ;
+  break;
+ case AR5K_BWMODE_10MHZ:
+  rate_flags = IEEE80211_RATE_SUPPORTS_10MHZ;
+  break;
+ default:
+  rate_flags = 0;
+  break;
+ }
+ sband = &ah->sbands[band];
+ rate = NULL;
+ for (i = 0; i < sband->n_bitrates; i++) {
+  if ((rate_flags & sband->bitrates[i].flags) != rate_flags)
+   continue;
+  rate = &sband->bitrates[i];
+  break;
+ }
+ if (WARN_ON(!rate))
+  return -EINVAL;
+
  ack_tx_time = ath5k_hw_get_frame_duration(ah, band, 10, rate, false);
 
  /* ack_tx_time includes an SIFS already */
diff --git a/drivers/net/wireless/ath/ath6kl/Kconfig b/drivers/net/wireless/ath/ath6kl/Kconfig
index e39e586..9c125ff 100644
--- a/drivers/net/wireless/ath/ath6kl/Kconfig
+++ b/drivers/net/wireless/ath/ath6kl/Kconfig
@@ -1,11 +1,19 @@
 config ATH6KL
  tristate "Atheros mobile chipsets support"
+ depends on CFG80211
+        ---help---
+   This module adds core support for wireless adapters based on
+   Atheros AR6003 and AR6004 chipsets. You still need separate
+   bus drivers for USB and SDIO to be able to use real devices.
+
+   If you choose to build it as a module, it will be called
+   ath6kl_core. Please note that AR6002 and AR6001 are not
+   supported by this driver.
 
 config ATH6KL_SDIO
  tristate "Atheros ath6kl SDIO support"
  depends on ATH6KL
  depends on MMC
- depends on CFG80211
  ---help---
    This module adds support for wireless adapters based on
    Atheros AR6003 and AR6004 chipsets running over SDIO. If you
@@ -17,25 +25,31 @@ config ATH6KL_USB
  tristate "Atheros ath6kl USB support"
  depends on ATH6KL
  depends on USB
- depends on CFG80211
  ---help---
    This module adds support for wireless adapters based on
-   Atheros AR6004 chipset running over USB. This is still under
-   implementation and it isn't functional. If you choose to
-   build it as a module, it will be called ath6kl_usb.
+   Atheros AR6004 chipset and chipsets based on it running over
+   USB. If you choose to build it as a module, it will be
+   called ath6kl_usb.
 
 config ATH6KL_DEBUG
  bool "Atheros ath6kl debugging"
  depends on ATH6KL
  ---help---
-   Enables debug support
+   Enables ath6kl debug support, including debug messages
+   enabled with debug_mask module parameter and debugfs
+   interface.
+
+   If unsure, say Y to make it easier to debug problems.
 
 config ATH6KL_TRACING
  bool "Atheros ath6kl tracing support"
  depends on ATH6KL
  depends on EVENT_TRACING
  ---help---
-   Select this to ath6kl use tracing infrastructure.
+   Select this to ath6kl use tracing infrastructure which, for
+   example, can be enabled with help of trace-cmd. All debug
+   messages and commands are delivered to using individually
+   enablable trace points.
 
    If unsure, say Y to make it easier to debug problems.
 
@@ -47,3 +61,5 @@ config ATH6KL_REGDOMAIN
    Enabling this makes it possible to change the regdomain in
    the firmware. This can be only enabled if regulatory requirements
    are taken into account.
+
+   If unsure, say N.
diff --git a/drivers/net/wireless/ath/ath6kl/cfg80211.c b/drivers/net/wireless/ath/ath6kl/cfg80211.c
index 5c9736a..0e26f4a 100644
--- a/drivers/net/wireless/ath/ath6kl/cfg80211.c
+++ b/drivers/net/wireless/ath/ath6kl/cfg80211.c
@@ -724,8 +724,9 @@ ath6kl_add_bss_if_needed(struct ath6kl_vif *vif,
    ath6kl_dbg(ATH6KL_DBG_WLAN_CFG,
        "added bss %pM to cfg80211\n", bssid);
   kfree(ie);
- } else
+ } else {
   ath6kl_dbg(ATH6KL_DBG_WLAN_CFG, "cfg80211 already has a bss\n");
+ }
 
  return bss;
 }
@@ -790,7 +791,7 @@ void ath6kl_cfg80211_connect_event(struct ath6kl_vif *vif, u16 channel,
  if (nw_type & ADHOC_NETWORK) {
   ath6kl_dbg(ATH6KL_DBG_WLAN_CFG, "ad-hoc %s selected\n",
       nw_type & ADHOC_CREATOR ? "creator" : "joiner");
-  cfg80211_ibss_joined(vif->ndev, bssid, GFP_KERNEL);
+  cfg80211_ibss_joined(vif->ndev, bssid, chan, GFP_KERNEL);
   cfg80211_put_bss(ar->wiphy, bss);
   return;
  }
@@ -861,13 +862,9 @@ void ath6kl_cfg80211_disconnect_event(struct ath6kl_vif *vif, u8 reason,
  }
 
  if (vif->nw_type & ADHOC_NETWORK) {
-  if (vif->wdev.iftype != NL80211_IFTYPE_ADHOC) {
+  if (vif->wdev.iftype != NL80211_IFTYPE_ADHOC)
    ath6kl_dbg(ATH6KL_DBG_WLAN_CFG,
        "%s: ath6k not in ibss mode\n", __func__);
-   return;
-  }
-  memset(bssid, 0, ETH_ALEN);
-  cfg80211_ibss_joined(vif->ndev, bssid, GFP_KERNEL);
   return;
  }
 
@@ -974,7 +971,6 @@ static int ath6kl_set_probed_ssids(struct ath6kl *ar,
        ssid_list[i].flag,
        ssid_list[i].ssid.ssid_len,
        ssid_list[i].ssid.ssid);
-
  }
 
  /* Make sure no old entries are left behind */
@@ -1109,7 +1105,9 @@ void ath6kl_cfg80211_ch_switch_notify(struct ath6kl_vif *vif, int freq,
     (mode == WMI_11G_HT20) ?
      NL80211_CHAN_HT20 : NL80211_CHAN_NO_HT);
 
+ mutex_lock(&vif->wdev.mtx);
  cfg80211_ch_switch_notify(vif->ndev, &chandef);
+ mutex_unlock(&vif->wdev.mtx);
 }
 
 static int ath6kl_cfg80211_add_key(struct wiphy *wiphy, struct net_device *ndev,
@@ -1761,7 +1759,7 @@ static bool is_rate_ht40(s32 rate, u8 *mcs, bool *sgi)
 }
 
 static int ath6kl_get_station(struct wiphy *wiphy, struct net_device *dev,
-         u8 *mac, struct station_info *sinfo)
+         const u8 *mac, struct station_info *sinfo)
 {
  struct ath6kl *ar = ath6kl_priv(dev);
  struct ath6kl_vif *vif = netdev_priv(dev);
@@ -1899,7 +1897,6 @@ static int ath6kl_wow_usr(struct ath6kl *ar, struct ath6kl_vif *vif,
 
  /* Configure the patterns that we received from the user. */
  for (i = 0; i < wow->n_patterns; i++) {
-
   /*
    * Convert given nl80211 specific mask value to equivalent
    * driver specific mask value and send it to the chip along
@@ -2852,8 +2849,9 @@ static int ath6kl_start_ap(struct wiphy *wiphy, struct net_device *dev,
  if (p.prwise_crypto_type == 0) {
   p.prwise_crypto_type = NONE_CRYPT;
   ath6kl_set_cipher(vif, 0, true);
- } else if (info->crypto.n_ciphers_pairwise == 1)
+ } else if (info->crypto.n_ciphers_pairwise == 1) {
   ath6kl_set_cipher(vif, info->crypto.ciphers_pairwise[0], true);
+ }
 
  switch (info->crypto.cipher_group) {
  case WLAN_CIPHER_SUITE_WEP40:
@@ -2899,7 +2897,6 @@ static int ath6kl_start_ap(struct wiphy *wiphy, struct net_device *dev,
  }
 
  if (info->inactivity_timeout) {
-
   inactivity_timeout = info->inactivity_timeout;
 
   if (ar->hw.flags & ATH6KL_HW_AP_INACTIVITY_MINS)
@@ -2977,7 +2974,7 @@ static int ath6kl_stop_ap(struct wiphy *wiphy, struct net_device *dev)
 static const u8 bcast_addr[ETH_ALEN] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };
 
 static int ath6kl_del_station(struct wiphy *wiphy, struct net_device *dev,
-         u8 *mac)
+         const u8 *mac)
 {
  struct ath6kl *ar = ath6kl_priv(dev);
  struct ath6kl_vif *vif = netdev_priv(dev);
@@ -2988,7 +2985,8 @@ static int ath6kl_del_station(struct wiphy *wiphy, struct net_device *dev,
 }
 
 static int ath6kl_change_station(struct wiphy *wiphy, struct net_device *dev,
-     u8 *mac, struct station_parameters *params)
+     const u8 *mac,
+     struct station_parameters *params)
 {
  struct ath6kl *ar = ath6kl_priv(dev);
  struct ath6kl_vif *vif = netdev_priv(dev);
@@ -3169,16 +3167,30 @@ static bool ath6kl_is_p2p_go_ssid(const u8 *buf, size_t len)
 }
 
 static int ath6kl_mgmt_tx(struct wiphy *wiphy, struct wireless_dev *wdev,
-     struct ieee80211_channel *chan, bool offchan,
-     unsigned int wait, const u8 *buf, size_t len,
-     bool no_cck, bool dont_wait_for_ack, u64 *cookie)
+     struct cfg80211_mgmt_tx_params *params, u64 *cookie)
 {
  struct ath6kl_vif *vif = ath6kl_vif_from_wdev(wdev);
  struct ath6kl *ar = ath6kl_priv(vif->ndev);
- u32 id;
+ struct ieee80211_channel *chan = params->chan;
+ const u8 *buf = params->buf;
+ size_t len = params->len;
+ unsigned int wait = params->wait;
+ bool no_cck = params->no_cck;
+ u32 id, freq;
  const struct ieee80211_mgmt *mgmt;
  bool more_data, queued;
 
+ /* default to the current channel, but use the one specified as argument
+  * if any
+  */
+ freq = vif->ch_hint;
+ if (chan)
+  freq = chan->center_freq;
+
+ /* never send freq zero to the firmware */
+ if (WARN_ON(freq == 0))
+  return -EINVAL;
+
  mgmt = (const struct ieee80211_mgmt *) buf;
  if (vif->nw_type == AP_NETWORK && test_bit(CONNECTED, &vif->flags) &&
      ieee80211_is_probe_resp(mgmt->frame_control) &&
@@ -3188,8 +3200,7 @@ static int ath6kl_mgmt_tx(struct wiphy *wiphy, struct wireless_dev *wdev,
    * command to allow the target to fill in the generic IEs.
    */
   *cookie = 0; /* TX status not supported */
-  return ath6kl_send_go_probe_resp(vif, buf, len,
-       chan->center_freq);
+  return ath6kl_send_go_probe_resp(vif, buf, len, freq);
  }
 
  id = vif->send_action_id++;
@@ -3205,17 +3216,14 @@ static int ath6kl_mgmt_tx(struct wiphy *wiphy, struct wireless_dev *wdev,
 
  /* AP mode Power saving processing */
  if (vif->nw_type == AP_NETWORK) {
-  queued = ath6kl_mgmt_powersave_ap(vif,
-     id, chan->center_freq,
-     wait, buf,
-     len, &more_data, no_cck);
+  queued = ath6kl_mgmt_powersave_ap(vif, id, freq, wait, buf, len,
+        &more_data, no_cck);
   if (queued)
    return 0;
  }
 
- return ath6kl_wmi_send_mgmt_cmd(ar->wmi, vif->fw_vif_idx, id,
-     chan->center_freq, wait,
-     buf, len, no_cck);
+ return ath6kl_wmi_send_mgmt_cmd(ar->wmi, vif->fw_vif_idx, id, freq,
+     wait, buf, len, no_cck);
 }
 
 static void ath6kl_mgmt_frame_register(struct wiphy *wiphy,
@@ -3244,6 +3252,15 @@ static int ath6kl_cfg80211_sscan_start(struct wiphy *wiphy,
  struct ath6kl_vif *vif = netdev_priv(dev);
  u16 interval;
  int ret, rssi_thold;
+ int n_match_sets = request->n_match_sets;
+
+ /*
+  * If there's a matchset w/o an SSID, then assume it's just for
+  * the RSSI (nothing else is currently supported) and ignore it.
+  * The device only supports a global RSSI filter that we set below.
+  */
+ if (n_match_sets == 1 && !request->match_sets[0].ssid.ssid_len)
+  n_match_sets = 0;
 
  if (ar->state != ATH6KL_STATE_ON)
   return -EIO;
@@ -3256,11 +3273,11 @@ static int ath6kl_cfg80211_sscan_start(struct wiphy *wiphy,
  ret = ath6kl_set_probed_ssids(ar, vif, request->ssids,
           request->n_ssids,
           request->match_sets,
-          request->n_match_sets);
+          n_match_sets);
  if (ret < 0)
   return ret;
 
- if (!request->n_match_sets) {
+ if (!n_match_sets) {
   ret = ath6kl_wmi_bssfilter_cmd(ar->wmi, vif->fw_vif_idx,
             ALL_BSS_FILTER, 0);
   if (ret < 0)
@@ -3274,12 +3291,12 @@ static int ath6kl_cfg80211_sscan_start(struct wiphy *wiphy,
 
  if (test_bit(ATH6KL_FW_CAPABILITY_RSSI_SCAN_THOLD,
        ar->fw_capabilities)) {
-  if (request->rssi_thold <= NL80211_SCAN_RSSI_THOLD_OFF)
+  if (request->min_rssi_thold <= NL80211_SCAN_RSSI_THOLD_OFF)
    rssi_thold = 0;
-  else if (request->rssi_thold < -127)
+  else if (request->min_rssi_thold < -127)
    rssi_thold = -127;
   else
-   rssi_thold = request->rssi_thold;
+   rssi_thold = request->min_rssi_thold;
 
   ret = ath6kl_wmi_set_rssi_filter_cmd(ar->wmi, vif->fw_vif_idx,
            rssi_thold);
@@ -3679,6 +3696,20 @@ err:
  return NULL;
 }
 
+#ifdef CONFIG_PM
+static const struct wiphy_wowlan_support ath6kl_wowlan_support = {
+ .flags = WIPHY_WOWLAN_MAGIC_PKT |
+   WIPHY_WOWLAN_DISCONNECT |
+   WIPHY_WOWLAN_GTK_REKEY_FAILURE  |
+   WIPHY_WOWLAN_SUPPORTS_GTK_REKEY |
+   WIPHY_WOWLAN_EAP_IDENTITY_REQ   |
+   WIPHY_WOWLAN_4WAY_HANDSHAKE,
+ .n_patterns = WOW_MAX_FILTERS_PER_LIST,
+ .pattern_min_len = 1,
+ .pattern_max_len = WOW_PATTERN_SIZE,
+};
+#endif
+
 int ath6kl_cfg80211_init(struct ath6kl *ar)
 {
  struct wiphy *wiphy = ar->wiphy;
@@ -3772,15 +3803,7 @@ int ath6kl_cfg80211_init(struct ath6kl *ar)
  wiphy->n_cipher_suites = ARRAY_SIZE(cipher_suites);
 
 #ifdef CONFIG_PM
- wiphy->wowlan.flags = WIPHY_WOWLAN_MAGIC_PKT |
-         WIPHY_WOWLAN_DISCONNECT |
-         WIPHY_WOWLAN_GTK_REKEY_FAILURE  |
-         WIPHY_WOWLAN_SUPPORTS_GTK_REKEY |
-         WIPHY_WOWLAN_EAP_IDENTITY_REQ   |
-         WIPHY_WOWLAN_4WAY_HANDSHAKE;
- wiphy->wowlan.n_patterns = WOW_MAX_FILTERS_PER_LIST;
- wiphy->wowlan.pattern_min_len = 1;
- wiphy->wowlan.pattern_max_len = WOW_PATTERN_SIZE;
+ wiphy->wowlan = &ath6kl_wowlan_support;
 #endif
 
  wiphy->max_sched_scan_ssids = MAX_PROBED_SSIDS;
diff --git a/drivers/net/wireless/ath/ath6kl/common.h b/drivers/net/wireless/ath/ath6kl/common.h
index 98a8861..05debf7 100644
--- a/drivers/net/wireless/ath/ath6kl/common.h
+++ b/drivers/net/wireless/ath/ath6kl/common.h
@@ -22,8 +22,7 @@
 
 #define ATH6KL_MAX_IE   256
 
-extern __printf(2, 3)
-int ath6kl_printk(const char *level, const char *fmt, ...);
+__printf(2, 3) int ath6kl_printk(const char *level, const char *fmt, ...);
 
 /*
  * Reflects the version of binary interface exposed by ATH6KL target
diff --git a/drivers/net/wireless/ath/ath6kl/core.c b/drivers/net/wireless/ath/ath6kl/core.c
index 4b46adb..b0b6520 100644
--- a/drivers/net/wireless/ath/ath6kl/core.c
+++ b/drivers/net/wireless/ath/ath6kl/core.c
@@ -45,9 +45,9 @@ module_param(testmode, uint, 0644);
 module_param(recovery_enable, uint, 0644);
 module_param(heart_beat_poll, uint, 0644);
 MODULE_PARM_DESC(recovery_enable, "Enable recovery from firmware error");
-MODULE_PARM_DESC(heart_beat_poll, "Enable fw error detection periodic"   \
-   "polling. This also specifies the polling interval in"  \
-   "msecs. Set reocvery_enable for this to be effective");
+MODULE_PARM_DESC(heart_beat_poll,
+   "Enable fw error detection periodic polling in msecs - Also set recovery_enable for this to be effective");
+
 
 void ath6kl_core_tx_complete(struct ath6kl *ar, struct sk_buff *skb)
 {
diff --git a/drivers/net/wireless/ath/ath6kl/debug.c b/drivers/net/wireless/ath/ath6kl/debug.c
index fe38b83..55c4064 100644
--- a/drivers/net/wireless/ath/ath6kl/debug.c
+++ b/drivers/net/wireless/ath/ath6kl/debug.c
@@ -172,7 +172,6 @@ void ath6kl_dump_registers(struct ath6kl_device *dev,
       struct ath6kl_irq_proc_registers *irq_proc_reg,
       struct ath6kl_irq_enable_reg *irq_enable_reg)
 {
-
  ath6kl_dbg(ATH6KL_DBG_IRQ, ("<------- Register Table -------->\n"));
 
  if (irq_proc_reg != NULL) {
@@ -219,7 +218,6 @@ void ath6kl_dump_registers(struct ath6kl_device *dev,
        "GMBOX lookahead alias 1:   0x%x\n",
        irq_proc_reg->rx_gmbox_lkahd_alias[1]);
   }
-
  }
 
  if (irq_enable_reg != NULL) {
@@ -1240,20 +1238,14 @@ static ssize_t ath6kl_force_roam_write(struct file *file,
  char buf[20];
  size_t len;
  u8 bssid[ETH_ALEN];
- int i;
- int addr[ETH_ALEN];
 
  len = min(count, sizeof(buf) - 1);
  if (copy_from_user(buf, user_buf, len))
   return -EFAULT;
  buf[len] = '\0';
 
- if (sscanf(buf, "%02x:%02x:%02x:%02x:%02x:%02x",
-     &addr[0], &addr[1], &addr[2], &addr[3], &addr[4], &addr[5])
-     != ETH_ALEN)
+ if (!mac_pton(buf, bssid))
   return -EINVAL;
- for (i = 0; i < ETH_ALEN; i++)
-  bssid[i] = addr[i];
 
  ret = ath6kl_wmi_force_roam_cmd(ar->wmi, bssid);
  if (ret)
@@ -1402,7 +1394,6 @@ static ssize_t ath6kl_create_qos_write(struct file *file,
       const char __user *user_buf,
       size_t count, loff_t *ppos)
 {
-
  struct ath6kl *ar = file->private_data;
  struct ath6kl_vif *vif;
  char buf[200];
@@ -1581,7 +1572,6 @@ static ssize_t ath6kl_delete_qos_write(struct file *file,
     const char __user *user_buf,
     size_t count, loff_t *ppos)
 {
-
  struct ath6kl *ar = file->private_data;
  struct ath6kl_vif *vif;
  char buf[100];
diff --git a/drivers/net/wireless/ath/ath6kl/debug.h b/drivers/net/wireless/ath/ath6kl/debug.h
index 74369de..e194c10 100644
--- a/drivers/net/wireless/ath/ath6kl/debug.h
+++ b/drivers/net/wireless/ath/ath6kl/debug.h
@@ -50,11 +50,10 @@ enum ATH6K_DEBUG_MASK {
 };
 
 extern unsigned int debug_mask;
-extern __printf(2, 3)
-int ath6kl_printk(const char *level, const char *fmt, ...);
-extern __printf(1, 2) int ath6kl_info(const char *fmt, ...);
-extern __printf(1, 2) int ath6kl_err(const char *fmt, ...);
-extern __printf(1, 2) int ath6kl_warn(const char *fmt, ...);
+__printf(2, 3) int ath6kl_printk(const char *level, const char *fmt, ...);
+__printf(1, 2) int ath6kl_info(const char *fmt, ...);
+__printf(1, 2) int ath6kl_err(const char *fmt, ...);
+__printf(1, 2) int ath6kl_warn(const char *fmt, ...);
 
 enum ath6kl_war {
  ATH6KL_WAR_INVALID_RATE,
@@ -98,8 +97,8 @@ static inline void ath6kl_dump_registers(struct ath6kl_device *dev,
   struct ath6kl_irq_proc_registers *irq_proc_reg,
   struct ath6kl_irq_enable_reg *irq_en_reg)
 {
-
 }
+
 static inline void dump_cred_dist_stats(struct htc_target *target)
 {
 }
diff --git a/drivers/net/wireless/ath/ath6kl/hif.c b/drivers/net/wireless/ath/ath6kl/hif.c
index fea7709..18c0708 100644
--- a/drivers/net/wireless/ath/ath6kl/hif.c
+++ b/drivers/net/wireless/ath/ath6kl/hif.c
@@ -37,7 +37,6 @@ static int ath6kl_hif_cp_scat_dma_buf(struct hif_scatter_req *req,
  buf = req->virt_dma_buf;
 
  for (i = 0; i < req->scat_entries; i++) {
-
   if (from_dma)
    memcpy(req->scat_list[i].buf, buf,
           req->scat_list[i].len);
@@ -116,7 +115,6 @@ static void ath6kl_hif_dump_fw_crash(struct ath6kl *ar)
        le32_to_cpu(regdump_val[i + 2]),
        le32_to_cpu(regdump_val[i + 3]));
  }
-
 }
 
 static int ath6kl_hif_proc_dbg_intr(struct ath6kl_device *dev)
@@ -701,5 +699,4 @@ int ath6kl_hif_setup(struct ath6kl_device *dev)
 
 fail_setup:
  return status;
-
 }
diff --git a/drivers/net/wireless/ath/ath6kl/hif.h b/drivers/net/wireless/ath/ath6kl/hif.h
index 61f6b21..dc6bd8c 100644
--- a/drivers/net/wireless/ath/ath6kl/hif.h
+++ b/drivers/net/wireless/ath/ath6kl/hif.h
@@ -197,9 +197,9 @@ struct hif_scatter_req {
  /* bounce buffer for upper layers to copy to/from */
  u8 *virt_dma_buf;
 
- struct hif_scatter_item scat_list[1];
-
  u32 scat_q_depth;
+
+ struct hif_scatter_item scat_list[0];
 };
 
 struct ath6kl_irq_proc_registers {
diff --git a/drivers/net/wireless/ath/ath6kl/htc.h b/drivers/net/wireless/ath/ath6kl/htc.h
index a2c8ff8..14cab14 100644
--- a/drivers/net/wireless/ath/ath6kl/htc.h
+++ b/drivers/net/wireless/ath/ath6kl/htc.h
@@ -60,7 +60,7 @@
 /* disable credit flow control on a specific service */
 #define HTC_CONN_FLGS_DISABLE_CRED_FLOW_CTRL          (1 << 3)
 #define HTC_CONN_FLGS_SET_RECV_ALLOC_SHIFT    8
-#define HTC_CONN_FLGS_SET_RECV_ALLOC_MASK     0xFF00
+#define HTC_CONN_FLGS_SET_RECV_ALLOC_MASK     0xFF00U
 
 /* connect response status codes */
 #define HTC_SERVICE_SUCCESS      0
diff --git a/drivers/net/wireless/ath/ath6kl/htc_mbox.c b/drivers/net/wireless/ath/ath6kl/htc_mbox.c
index 65e5b71..e481f14 100644
--- a/drivers/net/wireless/ath/ath6kl/htc_mbox.c
+++ b/drivers/net/wireless/ath/ath6kl/htc_mbox.c
@@ -112,9 +112,9 @@ static void ath6kl_credit_init(struct ath6kl_htc_credit_info *cred_info,
   if (cur_ep_dist->endpoint == ENDPOINT_0)
    continue;
 
-  if (cur_ep_dist->svc_id == WMI_CONTROL_SVC)
+  if (cur_ep_dist->svc_id == WMI_CONTROL_SVC) {
    cur_ep_dist->cred_norm = cur_ep_dist->cred_per_msg;
-  else {
+  } else {
    /*
     * For the remaining data endpoints, we assume that
     * each cred_per_msg are the same. We use a simple
@@ -129,7 +129,6 @@ static void ath6kl_credit_init(struct ath6kl_htc_credit_info *cred_info,
    count = (count * 3) >> 2;
    count = max(count, cur_ep_dist->cred_per_msg);
    cur_ep_dist->cred_norm = count;
-
   }
 
   ath6kl_dbg(ATH6KL_DBG_CREDIT,
@@ -549,7 +548,6 @@ static int htc_check_credits(struct htc_target *target,
         enum htc_endpoint_id eid, unsigned int len,
         int *req_cred)
 {
-
  *req_cred = (len > target->tgt_cred_sz) ?
        DIV_ROUND_UP(len, target->tgt_cred_sz) : 1;
 
@@ -608,7 +606,6 @@ static void ath6kl_htc_tx_pkts_get(struct htc_target *target,
  unsigned int len;
 
  while (true) {
-
   flags = 0;
 
   if (list_empty(&endpoint->txq))
@@ -889,7 +886,6 @@ static void ath6kl_htc_tx_from_queue(struct htc_target *target,
   ac = target->dev->ar->ep2ac_map[endpoint->eid];
 
  while (true) {
-
   if (list_empty(&endpoint->txq))
    break;
 
@@ -1190,7 +1186,6 @@ static void ath6kl_htc_mbox_flush_txep(struct htc_target *target,
   list_add_tail(&packet->list, &container);
   htc_tx_complete(endpoint, &container);
  }
-
 }
 
 static void ath6kl_htc_flush_txep_all(struct htc_target *target)
@@ -1394,7 +1389,6 @@ static int ath6kl_htc_rx_setup(struct htc_target *target,
 
  ep_cb = ep->ep_cb;
  for (j = 0; j < n_msg; j++) {
-
   /*
    * Reset flag, any packets allocated using the
    * rx_alloc() API cannot be recycled on
@@ -1424,9 +1418,9 @@ static int ath6kl_htc_rx_setup(struct htc_target *target,
     }
    }
 
-   if (list_empty(&ep->rx_bufq))
+   if (list_empty(&ep->rx_bufq)) {
     packet = NULL;
-   else {
+   } else {
     packet = list_first_entry(&ep->rx_bufq,
       struct htc_packet, list);
     list_del(&packet->list);
@@ -1487,7 +1481,6 @@ static int ath6kl_htc_rx_alloc(struct htc_target *target,
  spin_lock_bh(&target->rx_lock);
 
  for (i = 0; i < msg; i++) {
-
   htc_hdr = (struct htc_frame_hdr *)&lk_ahds[i];
 
   if (htc_hdr->eid >= ENDPOINT_MAX) {
@@ -1708,7 +1701,6 @@ static int htc_parse_trailer(struct htc_target *target,
   lk_ahd = (struct htc_lookahead_report *) record_buf;
   if ((lk_ahd->pre_valid == ((~lk_ahd->post_valid) & 0xFF)) &&
       next_lk_ahds) {
-
    ath6kl_dbg(ATH6KL_DBG_HTC,
        "htc rx lk_ahd found pre_valid 0x%x post_valid 0x%x\n",
        lk_ahd->pre_valid, lk_ahd->post_valid);
@@ -1755,7 +1747,6 @@ static int htc_parse_trailer(struct htc_target *target,
  }
 
  return 0;
-
 }
 
 static int htc_proc_trailer(struct htc_target *target,
@@ -1776,7 +1767,6 @@ static int htc_proc_trailer(struct htc_target *target,
  status = 0;
 
  while (len > 0) {
-
   if (len < sizeof(struct htc_record_hdr)) {
    status = -ENOMEM;
    break;
@@ -2098,7 +2088,6 @@ static int ath6kl_htc_rx_fetch(struct htc_target *target,
   }
 
   if (!fetched_pkts) {
-
    packet = list_first_entry(rx_pktq, struct htc_packet,
          list);
 
@@ -2173,7 +2162,6 @@ int ath6kl_htc_rxmsg_pending_handler(struct htc_target *target,
  look_aheads[0] = msg_look_ahead;
 
  while (true) {
-
   /*
    * First lookahead sets the expected endpoint IDs for all
    * packets in a bundle.
@@ -2825,8 +2813,9 @@ static int ath6kl_htc_reset(struct htc_target *target)
    packet->buf = packet->buf_start;
    packet->endpoint = ENDPOINT_0;
    list_add_tail(&packet->list, &target->free_ctrl_rxbuf);
-  } else
+  } else {
    list_add_tail(&packet->list, &target->free_ctrl_txbuf);
+  }
  }
 
  return 0;
diff --git a/drivers/net/wireless/ath/ath6kl/htc_pipe.c b/drivers/net/wireless/ath/ath6kl/htc_pipe.c
index 67aa924..756fe52 100644
--- a/drivers/net/wireless/ath/ath6kl/htc_pipe.c
+++ b/drivers/net/wireless/ath/ath6kl/htc_pipe.c
@@ -137,7 +137,6 @@ static void get_htc_packet_credit_based(struct htc_target *target,
    credits_required = 0;
 
   } else {
-
    if (ep->cred_dist.credits < credits_required)
     break;
 
@@ -169,7 +168,6 @@ static void get_htc_packet_credit_based(struct htc_target *target,
   /* queue this packet into the caller's queue */
   list_add_tail(&packet->list, queue);
  }
-
 }
 
 static void get_htc_packet(struct htc_target *target,
@@ -279,7 +277,6 @@ static int htc_issue_packets(struct htc_target *target,
    list_add(&packet->list, pkt_queue);
    break;
   }
-
  }
 
  if (status != 0) {
@@ -385,7 +382,6 @@ static enum htc_send_queue_result htc_try_send(struct htc_target *target,
     */
    list_for_each_entry_safe(packet, tmp_pkt,
        txq, list) {
-
     ath6kl_dbg(ATH6KL_DBG_HTC,
         "%s: Indicat overflowed TX pkts: %p\n",
         __func__, packet);
@@ -403,7 +399,6 @@ static enum htc_send_queue_result htc_try_send(struct htc_target *target,
      list_move_tail(&packet->list,
              &send_queue);
     }
-
    }
 
    if (list_empty(&send_queue)) {
@@ -454,7 +449,6 @@ static enum htc_send_queue_result htc_try_send(struct htc_target *target,
   * enough transmit resources.
   */
  while (true) {
-
   if (get_queue_depth(&ep->txq) == 0)
    break;
 
@@ -495,8 +489,8 @@ static enum htc_send_queue_result htc_try_send(struct htc_target *target,
   }
 
   spin_lock_bh(&target->tx_lock);
-
  }
+
  /* done with this endpoint, we can clear the count */
  ep->tx_proc_cnt = 0;
  spin_unlock_bh(&target->tx_lock);
@@ -1106,7 +1100,6 @@ free_skb:
  dev_kfree_skb(skb);
 
  return status;
-
 }
 
 static void htc_flush_rx_queue(struct htc_target *target,
@@ -1258,7 +1251,6 @@ static int ath6kl_htc_pipe_conn_service(struct htc_target *target,
   tx_alloc = 0;
 
  } else {
-
   tx_alloc = htc_get_credit_alloc(target, conn_req->svc_id);
   if (tx_alloc == 0) {
    status = -ENOMEM;
diff --git a/drivers/net/wireless/ath/ath6kl/init.c b/drivers/net/wireless/ath/ath6kl/init.c
index 40ffee6..d5ef211 100644
--- a/drivers/net/wireless/ath/ath6kl/init.c
+++ b/drivers/net/wireless/ath/ath6kl/init.c
@@ -1192,7 +1192,6 @@ static int ath6kl_upload_board_file(struct ath6kl *ar)
 
  if (board_ext_address &&
      ar->fw_board_len == (board_data_size + board_ext_data_size)) {
-
   /* write extended board data */
   ath6kl_dbg(ATH6KL_DBG_BOOT,
       "writing extended board data to 0x%x (%d B)\n",
@@ -1696,10 +1695,16 @@ static int __ath6kl_init_hw_start(struct ath6kl *ar)
           test_bit(WMI_READY,
             &ar->flag),
           WMI_TIMEOUT);
+ if (timeleft <= 0) {
+  clear_bit(WMI_READY, &ar->flag);
+  ath6kl_err("wmi is not ready or wait was interrupted: %ld\n",
+      timeleft);
+  ret = -EIO;
+  goto err_htc_stop;
+ }
 
  ath6kl_dbg(ATH6KL_DBG_BOOT, "firmware booted\n");
 
-
  if (test_and_clear_bit(FIRST_BOOT, &ar->flag)) {
   ath6kl_info("%s %s fw %s api %d%s\n",
        ar->hw.name,
@@ -1718,12 +1723,6 @@ static int __ath6kl_init_hw_start(struct ath6kl *ar)
   goto err_htc_stop;
  }
 
- if (!timeleft || signal_pending(current)) {
-  ath6kl_err("wmi is not ready or wait was interrupted\n");
-  ret = -EIO;
-  goto err_htc_stop;
- }
-
  ath6kl_dbg(ATH6KL_DBG_TRC, "%s: wmi is ready\n", __func__);
 
  /* communicate the wmi protocol verision to the target */
@@ -1836,6 +1835,9 @@ void ath6kl_stop_txrx(struct ath6kl *ar)
 
  clear_bit(WMI_READY, &ar->flag);
 
+ if (ar->fw_recovery.enable)
+  del_timer_sync(&ar->fw_recovery.hb_timer);
+
  /*
   * After wmi_shudown all WMI events will be dropped. We
   * need to cleanup the buffers allocated in AP mode and
diff --git a/drivers/net/wireless/ath/ath6kl/main.c b/drivers/net/wireless/ath/ath6kl/main.c
index d4fcfca..d565546 100644
--- a/drivers/net/wireless/ath/ath6kl/main.c
+++ b/drivers/net/wireless/ath/ath6kl/main.c
@@ -29,6 +29,9 @@ struct ath6kl_sta *ath6kl_find_sta(struct ath6kl_vif *vif, u8 *node_addr)
  struct ath6kl_sta *conn = NULL;
  u8 i, max_conn;
 
+ if (is_zero_ether_addr(node_addr))
+  return NULL;
+
  max_conn = (vif->nw_type == AP_NETWORK) ? AP_MAX_NUM_STA : 0;
 
  for (i = 0; i < max_conn; i++) {
@@ -568,7 +571,6 @@ void ath6kl_scan_complete_evt(struct ath6kl_vif *vif, int status)
 
 static int ath6kl_commit_ch_switch(struct ath6kl_vif *vif, u16 channel)
 {
-
  struct ath6kl *ar = vif->ar;
 
  vif->profile.ch = cpu_to_le16(channel);
@@ -597,7 +599,6 @@ static int ath6kl_commit_ch_switch(struct ath6kl_vif *vif, u16 channel)
 
 static void ath6kl_check_ch_switch(struct ath6kl *ar, u16 channel)
 {
-
  struct ath6kl_vif *vif;
  int res = 0;
 
@@ -689,9 +690,9 @@ void ath6kl_tkip_micerr_event(struct ath6kl_vif *vif, u8 keyid, bool ismcast)
   cfg80211_michael_mic_failure(vif->ndev, sta->mac,
           NL80211_KEYTYPE_PAIRWISE, keyid,
           tsc, GFP_KERNEL);
- } else
+ } else {
   ath6kl_cfg80211_tkip_micerr_event(vif, keyid, ismcast);
-
+ }
 }
 
 static void ath6kl_update_target_stats(struct ath6kl_vif *vif, u8 *ptr, u32 len)
@@ -1090,8 +1091,9 @@ static int ath6kl_open(struct net_device *dev)
  if (test_bit(CONNECTED, &vif->flags)) {
   netif_carrier_on(dev);
   netif_wake_queue(dev);
- } else
+ } else {
   netif_carrier_off(dev);
+ }
 
  return 0;
 }
@@ -1143,7 +1145,6 @@ static int ath6kl_set_features(struct net_device *dev,
    dev->features = features | NETIF_F_RXCSUM;
    return err;
   }
-
  }
 
  return err;
diff --git a/drivers/net/wireless/ath/ath6kl/sdio.c b/drivers/net/wireless/ath/ath6kl/sdio.c
index fb14145..339d89f 100644
--- a/drivers/net/wireless/ath/ath6kl/sdio.c
+++ b/drivers/net/wireless/ath/ath6kl/sdio.c
@@ -345,17 +345,17 @@ static int ath6kl_sdio_alloc_prep_scat_req(struct ath6kl_sdio *ar_sdio,
 {
  struct hif_scatter_req *s_req;
  struct bus_request *bus_req;
- int i, scat_req_sz, scat_list_sz, sg_sz, buf_sz;
+ int i, scat_req_sz, scat_list_sz, size;
  u8 *virt_buf;
 
- scat_list_sz = (n_scat_entry - 1) * sizeof(struct hif_scatter_item);
+ scat_list_sz = n_scat_entry * sizeof(struct hif_scatter_item);
  scat_req_sz = sizeof(*s_req) + scat_list_sz;
 
  if (!virt_scat)
-  sg_sz = sizeof(struct scatterlist) * n_scat_entry;
+  size = sizeof(struct scatterlist) * n_scat_entry;
  else
-  buf_sz =  2 * L1_CACHE_BYTES +
-     ATH6KL_MAX_TRANSFER_SIZE_PER_SCATTER;
+  size =  2 * L1_CACHE_BYTES +
+   ATH6KL_MAX_TRANSFER_SIZE_PER_SCATTER;
 
  for (i = 0; i < n_scat_req; i++) {
   /* allocate the scatter request */
@@ -364,7 +364,7 @@ static int ath6kl_sdio_alloc_prep_scat_req(struct ath6kl_sdio *ar_sdio,
    return -ENOMEM;
 
   if (virt_scat) {
-   virt_buf = kzalloc(buf_sz, GFP_KERNEL);
+   virt_buf = kzalloc(size, GFP_KERNEL);
    if (!virt_buf) {
     kfree(s_req);
     return -ENOMEM;
@@ -374,7 +374,7 @@ static int ath6kl_sdio_alloc_prep_scat_req(struct ath6kl_sdio *ar_sdio,
     (u8 *)L1_CACHE_ALIGN((unsigned long)virt_buf);
   } else {
    /* allocate sglist */
-   s_req->sgentries = kzalloc(sg_sz, GFP_KERNEL);
+   s_req->sgentries = kzalloc(size, GFP_KERNEL);
 
    if (!s_req->sgentries) {
     kfree(s_req);
@@ -425,8 +425,9 @@ static int ath6kl_sdio_read_write_sync(struct ath6kl *ar, u32 addr, u8 *buf,
    memcpy(tbuf, buf, len);
 
   bounced = true;
- } else
+ } else {
   tbuf = buf;
+ }
 
  ret = ath6kl_sdio_io(ar_sdio->func, request, addr, tbuf, len);
  if ((request & HIF_READ) && bounced)
@@ -441,9 +442,9 @@ static int ath6kl_sdio_read_write_sync(struct ath6kl *ar, u32 addr, u8 *buf,
 static void __ath6kl_sdio_write_async(struct ath6kl_sdio *ar_sdio,
           struct bus_request *req)
 {
- if (req->scat_req)
+ if (req->scat_req) {
   ath6kl_sdio_scat_rw(ar_sdio, req);
- else {
+ } else {
   void *context;
   int status;
 
@@ -656,7 +657,6 @@ static void ath6kl_sdio_scatter_req_add(struct ath6kl *ar,
  list_add_tail(&s_req->list, &ar_sdio->scat_req);
 
  spin_unlock_bh(&ar_sdio->scat_lock);
-
 }
 
 /* scatter gather read write request */
@@ -674,9 +674,9 @@ static int ath6kl_sdio_async_rw_scatter(struct ath6kl *ar,
      "hif-scatter: total len: %d scatter entries: %d\n",
      scat_req->len, scat_req->scat_entries);
 
- if (request & HIF_SYNCHRONOUS)
+ if (request & HIF_SYNCHRONOUS) {
   status = ath6kl_sdio_scat_rw(ar_sdio, scat_req->busrequest);
- else {
+ } else {
   spin_lock_bh(&ar_sdio->wr_async_lock);
   list_add_tail(&scat_req->busrequest->list, &ar_sdio->wr_asyncq);
   spin_unlock_bh(&ar_sdio->wr_async_lock);
@@ -856,7 +856,6 @@ static int ath6kl_sdio_suspend(struct ath6kl *ar, struct cfg80211_wowlan *wow)
 
  if (ar->suspend_mode == WLAN_POWER_STATE_WOW ||
      (!ar->suspend_mode && wow)) {
-
   ret = ath6kl_set_sdio_pm_caps(ar);
   if (ret)
    goto cut_pwr;
@@ -878,7 +877,6 @@ static int ath6kl_sdio_suspend(struct ath6kl *ar, struct cfg80211_wowlan *wow)
 
  if (ar->suspend_mode == WLAN_POWER_STATE_DEEP_SLEEP ||
      !ar->suspend_mode || try_deepsleep) {
-
   flags = sdio_get_host_pm_caps(func);
   if (!(flags & MMC_PM_KEEP_POWER))
    goto cut_pwr;
@@ -1061,7 +1059,6 @@ static int ath6kl_sdio_bmi_credits(struct ath6kl *ar)
 
  timeout = jiffies + msecs_to_jiffies(BMI_COMMUNICATION_TIMEOUT);
  while (time_before(jiffies, timeout) && !ar->bmi.cmd_credits) {
-
   /*
    * Hit the credit counter with a 4-byte access, the first byte
    * read will hit the counter and cause a decrement, while the
diff --git a/drivers/net/wireless/ath/ath6kl/target.h b/drivers/net/wireless/ath/ath6kl/target.h
index a580a62..d5eeeae 100644
--- a/drivers/net/wireless/ath/ath6kl/target.h
+++ b/drivers/net/wireless/ath/ath6kl/target.h
@@ -289,7 +289,7 @@ struct host_interest {
  u32 hi_hp_rx_traffic_ratio;                    /* 0xd8 */
 
  /* test applications flags */
- u32 hi_test_apps_related    ;                  /* 0xdc */
+ u32 hi_test_apps_related;                      /* 0xdc */
  /* location of test script */
  u32 hi_ota_testscript;                         /* 0xe0 */
  /* location of CAL data */
diff --git a/drivers/net/wireless/ath/ath6kl/testmode.c b/drivers/net/wireless/ath/ath6kl/testmode.c
index acc9aa8..d67170e 100644
--- a/drivers/net/wireless/ath/ath6kl/testmode.c
+++ b/drivers/net/wireless/ath/ath6kl/testmode.c
@@ -66,7 +66,8 @@ nla_put_failure:
  ath6kl_warn("nla_put failed on testmode rx skb!\n");
 }
 
-int ath6kl_tm_cmd(struct wiphy *wiphy, void *data, int len)
+int ath6kl_tm_cmd(struct wiphy *wiphy, struct wireless_dev *wdev,
+    void *data, int len)
 {
  struct ath6kl *ar = wiphy_priv(wiphy);
  struct nlattr *tb[ATH6KL_TM_ATTR_MAX + 1];
diff --git a/drivers/net/wireless/ath/ath6kl/testmode.h b/drivers/net/wireless/ath/ath6kl/testmode.h
index fe651d6..9fbcdec 100644
--- a/drivers/net/wireless/ath/ath6kl/testmode.h
+++ b/drivers/net/wireless/ath/ath6kl/testmode.h
@@ -20,7 +20,8 @@
 #ifdef CONFIG_NL80211_TESTMODE
 
 void ath6kl_tm_rx_event(struct ath6kl *ar, void *buf, size_t buf_len);
-int ath6kl_tm_cmd(struct wiphy *wiphy, void *data, int len);
+int ath6kl_tm_cmd(struct wiphy *wiphy, struct wireless_dev *wdev,
+    void *data, int len);
 
 #else
 
@@ -29,7 +30,9 @@ static inline void ath6kl_tm_rx_event(struct ath6kl *ar, void *buf,
 {
 }
 
-static inline int ath6kl_tm_cmd(struct wiphy *wiphy, void *data, int len)
+static inline int ath6kl_tm_cmd(struct wiphy *wiphy,
+    struct wireless_dev *wdev,
+    void *data, int len)
 {
  return 0;
 }
diff --git a/drivers/net/wireless/ath/ath6kl/txrx.c b/drivers/net/wireless/ath/ath6kl/txrx.c
index ebb2404..40432fe 100644
--- a/drivers/net/wireless/ath/ath6kl/txrx.c
+++ b/drivers/net/wireless/ath/ath6kl/txrx.c
@@ -125,8 +125,9 @@ static bool ath6kl_process_uapsdq(struct ath6kl_sta *conn,
   *flags |= WMI_DATA_HDR_FLAGS_UAPSD;
   spin_unlock_bh(&conn->psq_lock);
   return false;
- } else if (!conn->apsd_info)
+ } else if (!conn->apsd_info) {
   return false;
+ }
 
  if (test_bit(WMM_ENABLED, &vif->flags)) {
   ether_type = be16_to_cpu(datap->h_proto);
@@ -316,8 +317,9 @@ int ath6kl_control_tx(void *devt, struct sk_buff *skb,
   cookie = NULL;
   ath6kl_err("wmi ctrl ep full, dropping pkt : 0x%p, len:%d\n",
       skb, skb->len);
- } else
+ } else {
   cookie = ath6kl_alloc_cookie(ar);
+ }
 
  if (cookie == NULL) {
   spin_unlock_bh(&ar->lock);
@@ -359,7 +361,7 @@ int ath6kl_data_tx(struct sk_buff *skb, struct net_device *dev)
  struct ath6kl_vif *vif = netdev_priv(dev);
  u32 map_no = 0;
  u16 htc_tag = ATH6KL_DATA_PKT_TAG;
- u8 ac = 99 ; /* initialize to unmapped ac */
+ u8 ac = 99; /* initialize to unmapped ac */
  bool chk_adhoc_ps_mapping = false;
  int ret;
  struct wmi_tx_meta_v2 meta_v2;
@@ -449,8 +451,9 @@ int ath6kl_data_tx(struct sk_buff *skb, struct net_device *dev)
    if (ret)
     goto fail_tx;
   }
- } else
+ } else {
   goto fail_tx;
+ }
 
  spin_lock_bh(&ar->lock);
 
@@ -702,7 +705,6 @@ void ath6kl_tx_complete(struct htc_target *target,
 
  /* reap completed packets */
  while (!list_empty(packet_queue)) {
-
   packet = list_first_entry(packet_queue, struct htc_packet,
        list);
   list_del(&packet->list);
@@ -1089,8 +1091,9 @@ static void aggr_deque_frms(struct aggr_info_conn *agg_conn, u8 tid,
    else
     skb_queue_tail(&rxtid->q, node->skb);
    node->skb = NULL;
-  } else
+  } else {
    stats->num_hole++;
+  }
 
   rxtid->seq_next = ATH6KL_NEXT_SEQ_NO(rxtid->seq_next);
   idx = AGGR_WIN_IDX(rxtid->seq_next, rxtid->hold_q_sz);
@@ -1211,7 +1214,7 @@ static bool aggr_process_recv_frm(struct aggr_info_conn *agg_conn, u8 tid,
   return is_queued;
 
  spin_lock_bh(&rxtid->lock);
- for (idx = 0 ; idx < rxtid->hold_q_sz; idx++) {
+ for (idx = 0; idx < rxtid->hold_q_sz; idx++) {
   if (rxtid->hold_q[idx].skb) {
    /*
     * There is a frame in the queue and no
@@ -1265,7 +1268,6 @@ static void ath6kl_uapsd_trigger_frame_rx(struct ath6kl_vif *vif,
  is_apsdq_empty_at_start = is_apsdq_empty;
 
  while ((!is_apsdq_empty) && (num_frames_to_deliver)) {
-
   spin_lock_bh(&conn->psq_lock);
   skb = skb_dequeue(&conn->apsdq);
   is_apsdq_empty = skb_queue_empty(&conn->apsdq);
@@ -1606,16 +1608,18 @@ void ath6kl_rx(struct htc_target *target, struct htc_packet *packet)
    if (!conn)
     return;
    aggr_conn = conn->aggr_conn;
-  } else
+  } else {
    aggr_conn = vif->aggr_cntxt->aggr_conn;
+  }
 
   if (aggr_process_recv_frm(aggr_conn, tid, seq_no,
        is_amsdu, skb)) {
    /* aggregation code will handle the skb */
    return;
   }
- } else if (!is_broadcast_ether_addr(datap->h_dest))
+ } else if (!is_broadcast_ether_addr(datap->h_dest)) {
   vif->net_stats.multicast++;
+ }
 
  ath6kl_deliver_frames_to_nw_stack(vif->ndev, skb);
 }
@@ -1710,8 +1714,9 @@ void aggr_recv_addba_req_evt(struct ath6kl_vif *vif, u8 tid_mux, u16 seq_no,
   sta = ath6kl_find_sta_by_aid(vif->ar, aid);
   if (sta)
    aggr_conn = sta->aggr_conn;
- } else
+ } else {
   aggr_conn = vif->aggr_cntxt->aggr_conn;
+ }
 
  if (!aggr_conn)
   return;
@@ -1766,7 +1771,6 @@ void aggr_conn_init(struct ath6kl_vif *vif, struct aggr_info *aggr_info,
   skb_queue_head_init(&rxtid->q);
   spin_lock_init(&rxtid->lock);
  }
-
 }
 
 struct aggr_info *aggr_init(struct ath6kl_vif *vif)
@@ -1806,8 +1810,9 @@ void aggr_recv_delba_req_evt(struct ath6kl_vif *vif, u8 tid_mux)
   sta = ath6kl_find_sta_by_aid(vif->ar, aid);
   if (sta)
    aggr_conn = sta->aggr_conn;
- } else
+ } else {
   aggr_conn = vif->aggr_cntxt->aggr_conn;
+ }
 
  if (!aggr_conn)
   return;
diff --git a/drivers/net/wireless/ath/ath6kl/usb.c b/drivers/net/wireless/ath/ath6kl/usb.c
index bed0d33..3afc5a4 100644
--- a/drivers/net/wireless/ath/ath6kl/usb.c
+++ b/drivers/net/wireless/ath/ath6kl/usb.c
@@ -24,7 +24,7 @@
 /* constants */
 #define TX_URB_COUNT            32
 #define RX_URB_COUNT            32
-#define ATH6KL_USB_RX_BUFFER_SIZE  1700
+#define ATH6KL_USB_RX_BUFFER_SIZE  4096
 
 /* tx/rx pipes for usb */
 enum ATH6KL_USB_PIPE_ID {
@@ -236,7 +236,6 @@ static void ath6kl_usb_free_pipe_resources(struct ath6kl_usb_pipe *pipe)
    break;
   kfree(urb_context);
  }
-
 }
 
 static void ath6kl_usb_cleanup_pipe_resources(struct ath6kl_usb *ar_usb)
@@ -245,7 +244,6 @@ static void ath6kl_usb_cleanup_pipe_resources(struct ath6kl_usb *ar_usb)
 
  for (i = 0; i < ATH6KL_USB_PIPE_MAX; i++)
   ath6kl_usb_free_pipe_resources(&ar_usb->pipes[i]);
-
 }
 
 static u8 ath6kl_usb_get_logical_pipe_num(struct ath6kl_usb *ar_usb,
@@ -481,8 +479,8 @@ static void ath6kl_usb_start_recv_pipes(struct ath6kl_usb *ar_usb)
   *  ATH6KL_USB_RX_BUFFER_SIZE);
   */
 
- ar_usb->pipes[ATH6KL_USB_PIPE_RX_DATA].urb_cnt_thresh =
-     ar_usb->pipes[ATH6KL_USB_PIPE_RX_DATA].urb_alloc / 2;
+ ar_usb->pipes[ATH6KL_USB_PIPE_RX_DATA].urb_cnt_thresh = 1;
+
  ath6kl_usb_post_recv_transfers(&ar_usb->pipes[ATH6KL_USB_PIPE_RX_DATA],
            ATH6KL_USB_RX_BUFFER_SIZE);
 }
@@ -1061,6 +1059,22 @@ static void ath6kl_usb_cleanup_scatter(struct ath6kl *ar)
  return;
 }
 
+static int ath6kl_usb_suspend(struct ath6kl *ar, struct cfg80211_wowlan *wow)
+{
+ /*
+  * cfg80211 suspend/WOW currently not supported for USB.
+  */
+ return 0;
+}
+
+static int ath6kl_usb_resume(struct ath6kl *ar)
+{
+ /*
+  * cfg80211 resume currently not supported for USB.
+  */
+ return 0;
+}
+
 static const struct ath6kl_hif_ops ath6kl_usb_ops = {
  .diag_read32 = ath6kl_usb_diag_read32,
  .diag_write32 = ath6kl_usb_diag_write32,
@@ -1074,6 +1088,8 @@ static const struct ath6kl_hif_ops ath6kl_usb_ops = {
  .pipe_map_service = ath6kl_usb_map_service_pipe,
  .pipe_get_free_queue_number = ath6kl_usb_get_free_queue_number,
  .cleanup_scatter = ath6kl_usb_cleanup_scatter,
+ .suspend = ath6kl_usb_suspend,
+ .resume = ath6kl_usb_resume,
 };
 
 /* ath6kl usb driver registered functions */
@@ -1152,7 +1168,7 @@ static void ath6kl_usb_remove(struct usb_interface *interface)
 
 #ifdef CONFIG_PM
 
-static int ath6kl_usb_suspend(struct usb_interface *interface,
+static int ath6kl_usb_pm_suspend(struct usb_interface *interface,
          pm_message_t message)
 {
  struct ath6kl_usb *device;
@@ -1162,7 +1178,7 @@ static int ath6kl_usb_suspend(struct usb_interface *interface,
  return 0;
 }
 
-static int ath6kl_usb_resume(struct usb_interface *interface)
+static int ath6kl_usb_pm_resume(struct usb_interface *interface)
 {
  struct ath6kl_usb *device;
  device = usb_get_intfdata(interface);
@@ -1175,7 +1191,7 @@ static int ath6kl_usb_resume(struct usb_interface *interface)
  return 0;
 }
 
-static int ath6kl_usb_reset_resume(struct usb_interface *intf)
+static int ath6kl_usb_pm_reset_resume(struct usb_interface *intf)
 {
  if (usb_get_intfdata(intf))
   ath6kl_usb_remove(intf);
@@ -1184,9 +1200,9 @@ static int ath6kl_usb_reset_resume(struct usb_interface *intf)
 
 #else
 
-#define ath6kl_usb_suspend NULL
-#define ath6kl_usb_resume NULL
-#define ath6kl_usb_reset_resume NULL
+#define ath6kl_usb_pm_suspend NULL
+#define ath6kl_usb_pm_resume NULL
+#define ath6kl_usb_pm_reset_resume NULL
 
 #endif
 
@@ -1201,9 +1217,9 @@ MODULE_DEVICE_TABLE(usb, ath6kl_usb_ids);
 static struct usb_driver ath6kl_usb_driver = {
  .name = "ath6kl_usb",
  .probe = ath6kl_usb_probe,
- .suspend = ath6kl_usb_suspend,
- .resume = ath6kl_usb_resume,
- .reset_resume = ath6kl_usb_reset_resume,
+ .suspend = ath6kl_usb_pm_suspend,
+ .resume = ath6kl_usb_pm_resume,
+ .reset_resume = ath6kl_usb_pm_reset_resume,
  .disconnect = ath6kl_usb_remove,
  .id_table = ath6kl_usb_ids,
  .supports_autosuspend = true,
diff --git a/drivers/net/wireless/ath/ath6kl/wmi.c b/drivers/net/wireless/ath/ath6kl/wmi.c
index 87aefb4..4d7f9e4 100644
--- a/drivers/net/wireless/ath/ath6kl/wmi.c
+++ b/drivers/net/wireless/ath/ath6kl/wmi.c
@@ -289,8 +289,9 @@ int ath6kl_wmi_implicit_create_pstream(struct wmi *wmi, u8 if_idx,
       ath6kl_wmi_determine_user_priority(((u8 *) llc_hdr) +
      sizeof(struct ath6kl_llc_snap_hdr),
      layer2_priority);
-  } else
+  } else {
    usr_pri = layer2_priority & 0x7;
+  }
 
   /*
    * Queue the EAPOL frames in the same WMM_AC_VO queue
@@ -359,8 +360,9 @@ int ath6kl_wmi_dot11_hdr_remove(struct wmi *wmi, struct sk_buff *skb)
   hdr_size = roundup(sizeof(struct ieee80211_qos_hdr),
        sizeof(u32));
   skb_pull(skb, hdr_size);
- } else if (sub_type == cpu_to_le16(IEEE80211_STYPE_DATA))
+ } else if (sub_type == cpu_to_le16(IEEE80211_STYPE_DATA)) {
   skb_pull(skb, sizeof(struct ieee80211_hdr_3addr));
+ }
 
  datap = skb->data;
  llc_hdr = (struct ath6kl_llc_snap_hdr *)(datap);
@@ -568,8 +570,8 @@ static int ath6kl_wmi_rx_probe_req_event_rx(struct wmi *wmi, u8 *datap, int len,
      dlen, freq, vif->probe_req_report);
 
  if (vif->probe_req_report || vif->nw_type == AP_NETWORK)
-  cfg80211_rx_mgmt(&vif->wdev, freq, 0,
-     ev->data, dlen, GFP_ATOMIC);
+  cfg80211_rx_mgmt(&vif->wdev, freq, 0, ev->data, dlen, 0,
+     GFP_ATOMIC);
 
  return 0;
 }
@@ -608,8 +610,7 @@ static int ath6kl_wmi_rx_action_event_rx(struct wmi *wmi, u8 *datap, int len,
   return -EINVAL;
  }
  ath6kl_dbg(ATH6KL_DBG_WMI, "rx_action: len=%u freq=%u\n", dlen, freq);
- cfg80211_rx_mgmt(&vif->wdev, freq, 0,
-    ev->data, dlen, GFP_ATOMIC);
+ cfg80211_rx_mgmt(&vif->wdev, freq, 0, ev->data, dlen, 0, GFP_ATOMIC);
 
  return 0;
 }
@@ -915,7 +916,7 @@ ath6kl_get_regpair(u16 regdmn)
   return NULL;
 
  for (i = 0; i < ARRAY_SIZE(regDomainPairs); i++) {
-  if (regDomainPairs[i].regDmnEnum == regdmn)
+  if (regDomainPairs[i].reg_domain == regdmn)
    return &regDomainPairs[i];
  }
 
@@ -937,7 +938,6 @@ ath6kl_regd_find_country_by_rd(u16 regdmn)
 
 static void ath6kl_wmi_regdomain_event(struct wmi *wmi, u8 *datap, int len)
 {
-
  struct ath6kl_wmi_regdomain *ev;
  struct country_code_to_enum_rd *country = NULL;
  struct reg_dmn_pair_mapping *regpair = NULL;
@@ -947,15 +947,14 @@ static void ath6kl_wmi_regdomain_event(struct wmi *wmi, u8 *datap, int len)
  ev = (struct ath6kl_wmi_regdomain *) datap;
  reg_code = le32_to_cpu(ev->reg_code);
 
- if ((reg_code >> ATH6KL_COUNTRY_RD_SHIFT) & COUNTRY_ERD_FLAG)
+ if ((reg_code >> ATH6KL_COUNTRY_RD_SHIFT) & COUNTRY_ERD_FLAG) {
   country = ath6kl_regd_find_country((u16) reg_code);
- else if (!(((u16) reg_code & WORLD_SKU_MASK) == WORLD_SKU_PREFIX)) {
-
+ } else if (!(((u16) reg_code & WORLD_SKU_MASK) == WORLD_SKU_PREFIX)) {
   regpair = ath6kl_get_regpair((u16) reg_code);
   country = ath6kl_regd_find_country_by_rd((u16) reg_code);
   if (regpair)
    ath6kl_dbg(ATH6KL_DBG_WMI, "Regpair used: 0x%0x\n",
-       regpair->regDmnEnum);
+       regpair->reg_domain);
   else
    ath6kl_warn("Regpair not found reg_code 0x%0x\n",
         reg_code);
@@ -1500,7 +1499,6 @@ static int ath6kl_wmi_cac_event_rx(struct wmi *wmi, u8 *datap, int len,
 
  if ((reply->cac_indication == CAC_INDICATION_ADMISSION_RESP) &&
      (reply->status_code != IEEE80211_TSPEC_STATUS_ADMISS_ACCEPTED)) {
-
   ts = (struct ieee80211_tspec_ie *) &(reply->tspec_suggestion);
   tsinfo = le16_to_cpu(ts->tsinfo);
   tsid = (tsinfo >> IEEE80211_WMM_IE_TSPEC_TID_SHIFT) &
@@ -1531,7 +1529,6 @@ static int ath6kl_wmi_cac_event_rx(struct wmi *wmi, u8 *datap, int len,
   * for delete qos stream from AP
   */
  else if (reply->cac_indication == CAC_INDICATION_DELETE) {
-
   ts = (struct ieee80211_tspec_ie *) &(reply->tspec_suggestion);
   tsinfo = le16_to_cpu(ts->tsinfo);
   ts_id = ((tsinfo >> IEEE80211_WMM_IE_TSPEC_TID_SHIFT) &
@@ -2323,7 +2320,7 @@ int ath6kl_wmi_addkey_cmd(struct wmi *wmi, u8 if_idx, u8 key_index,
  return ret;
 }
 
-int ath6kl_wmi_add_krk_cmd(struct wmi *wmi, u8 if_idx, u8 *krk)
+int ath6kl_wmi_add_krk_cmd(struct wmi *wmi, u8 if_idx, const u8 *krk)
 {
  struct sk_buff *skb;
  struct wmi_add_krk_cmd *cmd;
@@ -2480,7 +2477,6 @@ static int ath6kl_wmi_sync_point(struct wmi *wmi, u8 if_idx)
   goto free_data_skb;
 
  for (index = 0; index < num_pri_streams; index++) {
-
   if (WARN_ON(!data_sync_bufs[index].skb))
    goto free_data_skb;
 
@@ -2705,7 +2701,6 @@ static void ath6kl_wmi_relinquish_implicit_pstream_credits(struct wmi *wmi)
 
  for (i = 0; i < WMM_NUM_AC; i++) {
   if (stream_exist & (1 << i)) {
-
    /*
     * FIXME: Is this lock & unlock inside
     * for loop correct? may need rework.
@@ -2755,9 +2750,9 @@ static int ath6kl_set_bitrate_mask64(struct wmi *wmi, u8 if_idx,
     mask->control[band].legacy << 4;
 
   /* copy mcs rate mask */
-  mcsrate = mask->control[band].mcs[1];
+  mcsrate = mask->control[band].ht_mcs[1];
   mcsrate <<= 8;
-  mcsrate |= mask->control[band].mcs[0];
+  mcsrate |= mask->control[band].ht_mcs[0];
   ratemask[band] |= mcsrate << 12;
   ratemask[band] |= mcsrate << 28;
  }
@@ -2807,7 +2802,7 @@ static int ath6kl_set_bitrate_mask32(struct wmi *wmi, u8 if_idx,
     mask->control[band].legacy << 4;
 
   /* copy mcs rate mask */
-  mcsrate = mask->control[band].mcs[0];
+  mcsrate = mask->control[band].ht_mcs[0];
   ratemask[band] |= mcsrate << 12;
   ratemask[band] |= mcsrate << 20;
  }
@@ -2871,8 +2866,9 @@ int ath6kl_wmi_set_host_sleep_mode_cmd(struct wmi *wmi, u8 if_idx,
  if (host_mode == ATH6KL_HOST_MODE_ASLEEP) {
   ath6kl_wmi_relinquish_implicit_pstream_credits(wmi);
   cmd->asleep = cpu_to_le32(1);
- } else
+ } else {
   cmd->awake = cpu_to_le32(1);
+ }
 
  ret = ath6kl_wmi_cmd_send(wmi, if_idx, skb,
       WMI_SET_HOST_SLEEP_MODE_CMDID,
diff --git a/drivers/net/wireless/ath/ath6kl/wmi.h b/drivers/net/wireless/ath/ath6kl/wmi.h
index b5f2265..bb23fc0 100644
--- a/drivers/net/wireless/ath/ath6kl/wmi.h
+++ b/drivers/net/wireless/ath/ath6kl/wmi.h
@@ -898,7 +898,6 @@ struct wmi_start_scan_cmd {
  *  flags here
  */
 enum wmi_scan_ctrl_flags_bits {
-
  /* set if can scan in the connect cmd */
  CONNECT_SCAN_CTRL_FLAGS = 0x01,
 
@@ -1068,7 +1067,7 @@ struct wmi_power_mode_cmd {
 } __packed;
 
 /*
- * Policy to determnine whether power save failure event should be sent to
+ * Policy to determine whether power save failure event should be sent to
  * host during scanning
  */
 enum power_save_fail_event_policy {
@@ -2617,7 +2616,7 @@ int ath6kl_wmi_addkey_cmd(struct wmi *wmi, u8 if_idx, u8 key_index,
      u8 *key_material,
      u8 key_op_ctrl, u8 *mac_addr,
      enum wmi_sync_flag sync_flag);
-int ath6kl_wmi_add_krk_cmd(struct wmi *wmi, u8 if_idx, u8 *krk);
+int ath6kl_wmi_add_krk_cmd(struct wmi *wmi, u8 if_idx, const u8 *krk);
 int ath6kl_wmi_deletekey_cmd(struct wmi *wmi, u8 if_idx, u8 key_index);
 int ath6kl_wmi_setpmkid_cmd(struct wmi *wmi, u8 if_idx, const u8 *bssid,
        const u8 *pmkid, bool set);
diff --git a/drivers/net/wireless/ath/ath9k/Kconfig b/drivers/net/wireless/ath/ath9k/Kconfig
index 3c2cbc9..8fcc029 100644
--- a/drivers/net/wireless/ath/ath9k/Kconfig
+++ b/drivers/net/wireless/ath/ath9k/Kconfig
@@ -28,7 +28,7 @@ config ATH9K
    Atheros IEEE 802.11n AR5008, AR9001 and AR9002 family
    of chipsets. For a specific list of supported external
    cards, laptops that already ship with these cards and
-   APs that come with these cards refer to to ath9k wiki
+   APs that come with these cards refer to ath9k wiki
    products page:
 
    http://wireless.kernel.org/en/users/Drivers/ath9k/products
@@ -56,7 +56,7 @@ config ATH9K_AHB
 
 config ATH9K_DEBUGFS
  bool "Atheros ath9k debugging"
- depends on ATH9K
+ depends on ATH9K && DEBUG_FS
  select MAC80211_DEBUGFS
  select RELAY
  ---help---
@@ -65,6 +65,14 @@ config ATH9K_DEBUGFS
 
    Also required for changing debug message flags at run time.
 
+config ATH9K_STATION_STATISTICS
+ bool "Detailed station statistics"
+ depends on ATH9K && ATH9K_DEBUGFS && DEBUG_FS
+ select MAC80211_DEBUGFS
+ default n
+ ---help---
+   This option enables detailed statistics for association stations.
+
 config ATH9K_DFS_CERTIFIED
  bool "Atheros DFS support for certified platforms"
  depends on ATH9K && CFG80211_CERTIFICATION_ONUS
@@ -84,25 +92,43 @@ config ATH9K_DFS_CERTIFIED
    developed. At this point enabling this option won't do anything
    except increase code size.
 
-config ATH9K_MAC_DEBUG
- bool "Atheros MAC statistics"
- depends on ATH9K_DEBUGFS
- default y
+config ATH9K_TX99
+ bool "Atheros ath9k TX99 testing support"
+ depends on ATH9K_DEBUGFS && CFG80211_CERTIFICATION_ONUS
+ default n
  ---help---
-   This option enables collection of statistics for Rx/Tx status
-   data and some other MAC related statistics
-
-config ATH9K_LEGACY_RATE_CONTROL
- bool "Atheros ath9k rate control"
- depends on ATH9K
+   Say N. This should only be enabled on systems undergoing
+   certification testing and evaluation in a controlled environment.
+   Enabling this will only enable TX99 support, all other modes of
+   operation will be disabled.
+
+   TX99 support enables Specific Absorption Rate (SAR) testing.
+   SAR is the unit of measurement for the amount of radio frequency(RF)
+   absorbed by the body when using a wireless device. The RF exposure
+   limits used are expressed in the terms of SAR, which is a measure
+   of the electric and magnetic field strength and power density for
+   transmitters operating at frequencies from 300 kHz to 100 GHz.
+   Regulatory bodies around the world require that wireless device
+   be evaluated to meet the RF exposure limits set forth in the
+   governmental SAR regulations.
+
+config ATH9K_WOW
+ bool "Wake on Wireless LAN support (EXPERIMENTAL)"
+ depends on ATH9K && PM
  default n
  ---help---
-   Say Y, if you want to use the ath9k specific rate control
-   module instead of minstrel_ht. Be warned that there are various
-   issues with the ath9k RC and minstrel is a more robust algorithm.
-   Note that even if this option is selected, "ath9k_rate_control"
-   has to be passed to mac80211 using the module parameter,
-   ieee80211_default_rc_algo.
+   This option enables Wake on Wireless LAN support for certain cards.
+   Currently, AR9462 is supported.
+
+config ATH9K_RFKILL
+ bool "Atheros ath9k rfkill support" if EXPERT
+ depends on ATH9K
+ depends on RFKILL=y || RFKILL=ATH9K
+ default y
+ help
+   Say Y to have ath9k poll the RF-Kill GPIO every couple of
+   seconds. Turn off to save power, but enable it if you have
+   a platform that can toggle the RF-Kill GPIO.
 
 config ATH9K_HTC
        tristate "Atheros HTC based wireless cards support"
diff --git a/drivers/net/wireless/ath/ath9k/Makefile b/drivers/net/wireless/ath/ath9k/Makefile
index 75ee9e7..8fcd586 100644
--- a/drivers/net/wireless/ath/ath9k/Makefile
+++ b/drivers/net/wireless/ath/ath9k/Makefile
@@ -8,16 +8,17 @@ ath9k-y += beacon.o \
   antenna.o
 
 ath9k-$(CONFIG_ATH9K_BTCOEX_SUPPORT) += mci.o
-ath9k-$(CONFIG_ATH9K_LEGACY_RATE_CONTROL) += rc.o
 ath9k-$(CONFIG_ATH9K_PCI) += pci.o
 ath9k-$(CONFIG_ATH9K_AHB) += ahb.o
-ath9k-$(CONFIG_ATH9K_DEBUGFS) += debug.o
 ath9k-$(CONFIG_ATH9K_DFS_DEBUGFS) += dfs_debug.o
-ath9k-$(CONFIG_ATH9K_DFS_CERTIFIED) += \
-  dfs.o \
-  dfs_pattern_detector.o \
-  dfs_pri_detector.o
-ath9k-$(CONFIG_PM_SLEEP) += wow.o
+ath9k-$(CONFIG_ATH9K_DFS_CERTIFIED) += dfs.o
+ath9k-$(CONFIG_ATH9K_TX99) += tx99.o
+ath9k-$(CONFIG_ATH9K_WOW) += wow.o
+
+ath9k-$(CONFIG_ATH9K_DEBUGFS) += debug.o \
+     spectral.o
+
+ath9k-$(CONFIG_ATH9K_STATION_STATISTICS) += debug_sta.o
 
 obj-$(CONFIG_ATH9K) += ath9k.o
 
@@ -43,12 +44,17 @@ ath9k_hw-y:= \
   ar9003_eeprom.o \
   ar9003_paprd.o
 
+ath9k_hw-$(CONFIG_ATH9K_WOW) += ar9003_wow.o
+
 ath9k_hw-$(CONFIG_ATH9K_BTCOEX_SUPPORT) += btcoex.o \
         ar9003_mci.o
 obj-$(CONFIG_ATH9K_HW) += ath9k_hw.o
 
 obj-$(CONFIG_ATH9K_COMMON) += ath9k_common.o
-ath9k_common-y:= common.o
+ath9k_common-y:= common.o \
+   common-init.o \
+   common-beacon.o \
+   common-debug.o
 
 ath9k_htc-y += htc_hst.o \
   hif_usb.o \
diff --git a/drivers/net/wireless/ath/ath9k/ahb.c b/drivers/net/wireless/ath/ath9k/ahb.c
index d1ff3c2..be3eb2a 100644
--- a/drivers/net/wireless/ath/ath9k/ahb.c
+++ b/drivers/net/wireless/ath/ath9k/ahb.c
@@ -39,6 +39,10 @@ static const struct platform_device_id ath9k_platform_id_table[] = {
   .name = "qca955x_wmac",
   .driver_data = AR9300_DEVID_QCA955X,
  },
+ {
+  .name = "qca953x_wmac",
+  .driver_data = AR9300_DEVID_AR953X,
+ },
  {},
 };
 
@@ -54,7 +58,7 @@ static bool ath_ahb_eeprom_read(struct ath_common *common, u32 off, u16 *data)
  struct platform_device *pdev = to_platform_device(sc->dev);
  struct ath9k_platform_data *pdata;
 
- pdata = (struct ath9k_platform_data *) pdev->dev.platform_data;
+ pdata = dev_get_platdata(&pdev->dev);
  if (off >= (ARRAY_SIZE(pdata->eeprom_data))) {
   ath_err(common,
    "%s: flash read failed, offset %08x is out of range\n",
@@ -84,7 +88,7 @@ static int ath_ahb_probe(struct platform_device *pdev)
  struct ath_hw *ah;
  char hw_name[64];
 
- if (!pdev->dev.platform_data) {
+ if (!dev_get_platdata(&pdev->dev)) {
   dev_err(&pdev->dev, "no platform data specified\n");
   return -EINVAL;
  }
@@ -124,9 +128,6 @@ static int ath_ahb_probe(struct platform_device *pdev)
  sc->mem = mem;
  sc->irq = irq;
 
- /* Will be cleared in ath9k_start() */
- set_bit(SC_OP_INVALID, &sc->sc_flags);
-
  ret = request_irq(irq, ath_isr, IRQF_SHARED, "ath9k", sc);
  if (ret) {
   dev_err(&pdev->dev, "request_irq failed\n");
@@ -150,7 +151,6 @@ static int ath_ahb_probe(struct platform_device *pdev)
  free_irq(irq, sc);
  err_free_hw:
  ieee80211_free_hw(hw);
- platform_set_drvdata(pdev, NULL);
  return ret;
 }
 
@@ -164,7 +164,6 @@ static int ath_ahb_remove(struct platform_device *pdev)
   ath9k_deinit_device(sc);
   free_irq(sc->irq, sc);
   ieee80211_free_hw(sc->hw);
-  platform_set_drvdata(pdev, NULL);
  }
 
  return 0;
diff --git a/drivers/net/wireless/ath/ath9k/ani.c b/drivers/net/wireless/ath/ath9k/ani.c
index 7ecd40f..ba502a2 100644
--- a/drivers/net/wireless/ath/ath9k/ani.c
+++ b/drivers/net/wireless/ath/ath9k/ani.c
@@ -46,8 +46,8 @@ static const struct ani_ofdm_level_entry ofdm_level_table[] = {
  {  5,  4,  1  }, /* lvl 5 */
  {  6,  5,  1  }, /* lvl 6 */
  {  7,  6,  1  }, /* lvl 7 */
- {  7,  6,  0  }, /* lvl 8 */
- {  7,  7,  0  }  /* lvl 9 */
+ {  7,  7,  1  }, /* lvl 8 */
+ {  7,  8,  0  }  /* lvl 9 */
 };
 #define ATH9K_ANI_OFDM_NUM_LEVEL \
  ARRAY_SIZE(ofdm_level_table)
@@ -91,8 +91,8 @@ static const struct ani_cck_level_entry cck_level_table[] = {
  {  4,  0  }, /* lvl 4 */
  {  5,  0  }, /* lvl 5 */
  {  6,  0  }, /* lvl 6 */
- {  6,  0  }, /* lvl 7 (only for high rssi) */
- {  7,  0  }  /* lvl 8 (only for high rssi) */
+ {  7,  0  }, /* lvl 7 (only for high rssi) */
+ {  8,  0  }  /* lvl 8 (only for high rssi) */
 };
 
 #define ATH9K_ANI_CCK_NUM_LEVEL \
@@ -118,10 +118,10 @@ static void ath9k_ani_restart(struct ath_hw *ah)
 {
  struct ar5416AniState *aniState;
 
- if (!DO_ANI(ah))
+ if (!ah->curchan)
   return;
 
- aniState = &ah->curchan->ani;
+ aniState = &ah->ani;
  aniState->listenTime = 0;
 
  ENABLE_REGWRITE_BUFFER(ah);
@@ -143,7 +143,7 @@ static void ath9k_ani_restart(struct ath_hw *ah)
 static void ath9k_hw_set_ofdm_nil(struct ath_hw *ah, u8 immunityLevel,
       bool scan)
 {
- struct ar5416AniState *aniState = &ah->curchan->ani;
+ struct ar5416AniState *aniState = &ah->ani;
  struct ath_common *common = ath9k_hw_common(ah);
  const struct ani_ofdm_level_entry *entry_ofdm;
  const struct ani_cck_level_entry *entry_cck;
@@ -155,6 +155,9 @@ static void ath9k_hw_set_ofdm_nil(struct ath_hw *ah, u8 immunityLevel,
   ATH9K_ANI_RSSI_THR_LOW,
   ATH9K_ANI_RSSI_THR_HIGH);
 
+ if (AR_SREV_9100(ah) && immunityLevel < ATH9K_ANI_OFDM_DEF_LEVEL)
+  immunityLevel = ATH9K_ANI_OFDM_DEF_LEVEL;
+
  if (!scan)
   aniState->ofdmNoiseImmunityLevel = immunityLevel;
 
@@ -176,11 +179,26 @@ static void ath9k_hw_set_ofdm_nil(struct ath_hw *ah, u8 immunityLevel,
  if (ah->opmode == NL80211_IFTYPE_STATION &&
      BEACON_RSSI(ah) <= ATH9K_ANI_RSSI_THR_HIGH)
   weak_sig = true;
+ /*
+  * Newer chipsets are better at dealing with high PHY error counts -
+  * keep weak signal detection enabled when no RSSI threshold is
+  * available to determine if it is needed (mode != STA)
+  */
+ else if (AR_SREV_9300_20_OR_LATER(ah) &&
+   ah->opmode != NL80211_IFTYPE_STATION)
+  weak_sig = true;
+
+ /* Older chipsets are more sensitive to high PHY error counts */
+ else if (!AR_SREV_9300_20_OR_LATER(ah) &&
+   aniState->ofdmNoiseImmunityLevel >= 8)
+  weak_sig = false;
 
  if (aniState->ofdmWeakSigDetect != weak_sig)
-   ath9k_hw_ani_control(ah,
-    ATH9K_ANI_OFDM_WEAK_SIGNAL_DETECTION,
-    entry_ofdm->ofdm_weak_signal_on);
+  ath9k_hw_ani_control(ah, ATH9K_ANI_OFDM_WEAK_SIGNAL_DETECTION,
+         weak_sig);
+
+ if (!AR_SREV_9300_20_OR_LATER(ah))
+  return;
 
  if (aniState->ofdmNoiseImmunityLevel >= ATH9K_ANI_OFDM_DEF_LEVEL) {
   ah->config.ofdm_trig_high = ATH9K_ANI_OFDM_TRIG_HIGH;
@@ -195,10 +213,10 @@ static void ath9k_hw_ani_ofdm_err_trigger(struct ath_hw *ah)
 {
  struct ar5416AniState *aniState;
 
- if (!DO_ANI(ah))
+ if (!ah->curchan)
   return;
 
- aniState = &ah->curchan->ani;
+ aniState = &ah->ani;
 
  if (aniState->ofdmNoiseImmunityLevel < ATH9K_ANI_OFDM_MAX_LEVEL)
   ath9k_hw_set_ofdm_nil(ah, aniState->ofdmNoiseImmunityLevel + 1, false);
@@ -210,7 +228,7 @@ static void ath9k_hw_ani_ofdm_err_trigger(struct ath_hw *ah)
 static void ath9k_hw_set_cck_nil(struct ath_hw *ah, u_int8_t immunityLevel,
      bool scan)
 {
- struct ar5416AniState *aniState = &ah->curchan->ani;
+ struct ar5416AniState *aniState = &ah->ani;
  struct ath_common *common = ath9k_hw_common(ah);
  const struct ani_ofdm_level_entry *entry_ofdm;
  const struct ani_cck_level_entry *entry_cck;
@@ -220,6 +238,9 @@ static void ath9k_hw_set_cck_nil(struct ath_hw *ah, u_int8_t immunityLevel,
   BEACON_RSSI(ah), ATH9K_ANI_RSSI_THR_LOW,
   ATH9K_ANI_RSSI_THR_HIGH);
 
+ if (AR_SREV_9100(ah) && immunityLevel < ATH9K_ANI_CCK_DEF_LEVEL)
+  immunityLevel = ATH9K_ANI_CCK_DEF_LEVEL;
+
  if (ah->opmode == NL80211_IFTYPE_STATION &&
      BEACON_RSSI(ah) <= ATH9K_ANI_RSSI_THR_LOW &&
      immunityLevel > ATH9K_ANI_CCK_MAX_LEVEL_LOW_RSSI)
@@ -251,10 +272,10 @@ static void ath9k_hw_ani_cck_err_trigger(struct ath_hw *ah)
 {
  struct ar5416AniState *aniState;
 
- if (!DO_ANI(ah))
+ if (!ah->curchan)
   return;
 
- aniState = &ah->curchan->ani;
+ aniState = &ah->ani;
 
  if (aniState->cckNoiseImmunityLevel < ATH9K_ANI_CCK_MAX_LEVEL)
   ath9k_hw_set_cck_nil(ah, aniState->cckNoiseImmunityLevel + 1,
@@ -269,7 +290,7 @@ static void ath9k_hw_ani_lower_immunity(struct ath_hw *ah)
 {
  struct ar5416AniState *aniState;
 
- aniState = &ah->curchan->ani;
+ aniState = &ah->ani;
 
  /* lower OFDM noise immunity */
  if (aniState->ofdmNoiseImmunityLevel > 0 &&
@@ -292,31 +313,17 @@ static void ath9k_hw_ani_lower_immunity(struct ath_hw *ah)
  */
 void ath9k_ani_reset(struct ath_hw *ah, bool is_scanning)
 {
- struct ar5416AniState *aniState = &ah->curchan->ani;
+ struct ar5416AniState *aniState = &ah->ani;
  struct ath9k_channel *chan = ah->curchan;
  struct ath_common *common = ath9k_hw_common(ah);
  int ofdm_nil, cck_nil;
 
- if (!DO_ANI(ah))
+ if (!ah->curchan)
   return;
 
  BUG_ON(aniState == NULL);
  ah->stats.ast_ani_reset++;
 
- /* only allow a subset of functions in AP mode */
- if (ah->opmode == NL80211_IFTYPE_AP) {
-  if (IS_CHAN_2GHZ(chan)) {
-   ah->ani_function = (ATH9K_ANI_SPUR_IMMUNITY_LEVEL |
-         ATH9K_ANI_FIRSTEP_LEVEL);
-   if (AR_SREV_9300_20_OR_LATER(ah))
-    ah->ani_function |= ATH9K_ANI_MRC_CCK;
-  } else
-   ah->ani_function = 0;
- }
-
- /* always allow mode (on/off) to be controlled */
- ah->ani_function |= ATH9K_ANI_MODE;
-
  ofdm_nil = max_t(int, ATH9K_ANI_OFDM_DEF_LEVEL,
     aniState->ofdmNoiseImmunityLevel);
  cck_nil = max_t(int, ATH9K_ANI_CCK_DEF_LEVEL,
@@ -336,10 +343,9 @@ void ath9k_ani_reset(struct ath_hw *ah, bool is_scanning)
       aniState->cckNoiseImmunityLevel !=
       ATH9K_ANI_CCK_DEF_LEVEL) {
    ath_dbg(common, ANI,
-    "Restore defaults: opmode %u chan %d Mhz/0x%x is_scanning=%d ofdm:%d cck:%d\n",
+    "Restore defaults: opmode %u chan %d Mhz is_scanning=%d ofdm:%d cck:%d\n",
     ah->opmode,
     chan->channel,
-    chan->channelFlags,
     is_scanning,
     aniState->ofdmNoiseImmunityLevel,
     aniState->cckNoiseImmunityLevel);
@@ -352,10 +358,9 @@ void ath9k_ani_reset(struct ath_hw *ah, bool is_scanning)
    * restore historical levels for this channel
    */
   ath_dbg(common, ANI,
-   "Restore history: opmode %u chan %d Mhz/0x%x is_scanning=%d ofdm:%d cck:%d\n",
+   "Restore history: opmode %u chan %d Mhz is_scanning=%d ofdm:%d cck:%d\n",
    ah->opmode,
    chan->channel,
-   chan->channelFlags,
    is_scanning,
    aniState->ofdmNoiseImmunityLevel,
    aniState->cckNoiseImmunityLevel);
@@ -363,24 +368,13 @@ void ath9k_ani_reset(struct ath_hw *ah, bool is_scanning)
  ath9k_hw_set_ofdm_nil(ah, ofdm_nil, is_scanning);
  ath9k_hw_set_cck_nil(ah, cck_nil, is_scanning);
 
- /*
-  * enable phy counters if hw supports or if not, enable phy
-  * interrupts (so we can count each one)
-  */
  ath9k_ani_restart(ah);
-
- ENABLE_REGWRITE_BUFFER(ah);
-
- REG_WRITE(ah, AR_PHY_ERR_MASK_1, AR_PHY_ERR_OFDM_TIMING);
- REG_WRITE(ah, AR_PHY_ERR_MASK_2, AR_PHY_ERR_CCK_TIMING);
-
- REGWRITE_BUFFER_FLUSH(ah);
 }
 
 static bool ath9k_hw_ani_read_counters(struct ath_hw *ah)
 {
  struct ath_common *common = ath9k_hw_common(ah);
- struct ar5416AniState *aniState = &ah->curchan->ani;
+ struct ar5416AniState *aniState = &ah->ani;
  u32 phyCnt1, phyCnt2;
  int32_t listenTime;
 
@@ -415,10 +409,10 @@ void ath9k_hw_ani_monitor(struct ath_hw *ah, struct ath9k_channel *chan)
  struct ath_common *common = ath9k_hw_common(ah);
  u32 ofdmPhyErrRate, cckPhyErrRate;
 
- if (!DO_ANI(ah))
+ if (!ah->curchan)
   return;
 
- aniState = &ah->curchan->ani;
+ aniState = &ah->ani;
  if (!ath9k_hw_ani_read_counters(ah))
   return;
 
@@ -490,33 +484,30 @@ EXPORT_SYMBOL(ath9k_hw_disable_mib_counters);
 void ath9k_hw_ani_init(struct ath_hw *ah)
 {
  struct ath_common *common = ath9k_hw_common(ah);
- int i;
+ struct ar5416AniState *ani = &ah->ani;
 
  ath_dbg(common, ANI, "Initialize ANI\n");
 
- ah->config.ofdm_trig_high = ATH9K_ANI_OFDM_TRIG_HIGH;
- ah->config.ofdm_trig_low = ATH9K_ANI_OFDM_TRIG_LOW;
-
- ah->config.cck_trig_high = ATH9K_ANI_CCK_TRIG_HIGH;
- ah->config.cck_trig_low = ATH9K_ANI_CCK_TRIG_LOW;
-
- for (i = 0; i < ARRAY_SIZE(ah->channels); i++) {
-  struct ath9k_channel *chan = &ah->channels[i];
-  struct ar5416AniState *ani = &chan->ani;
-
-  ani->spurImmunityLevel = ATH9K_ANI_SPUR_IMMUNE_LVL;
-
-  ani->firstepLevel = ATH9K_ANI_FIRSTEP_LVL;
-
-  ani->mrcCCK = AR_SREV_9300_20_OR_LATER(ah) ? true : false;
-
-  ani->ofdmsTurn = true;
-
-  ani->ofdmWeakSigDetect = ATH9K_ANI_USE_OFDM_WEAK_SIG;
-  ani->cckNoiseImmunityLevel = ATH9K_ANI_CCK_DEF_LEVEL;
-  ani->ofdmNoiseImmunityLevel = ATH9K_ANI_OFDM_DEF_LEVEL;
+ if (AR_SREV_9300_20_OR_LATER(ah)) {
+  ah->config.ofdm_trig_high = ATH9K_ANI_OFDM_TRIG_HIGH;
+  ah->config.ofdm_trig_low = ATH9K_ANI_OFDM_TRIG_LOW;
+  ah->config.cck_trig_high = ATH9K_ANI_CCK_TRIG_HIGH;
+  ah->config.cck_trig_low = ATH9K_ANI_CCK_TRIG_LOW;
+ } else {
+  ah->config.ofdm_trig_high = ATH9K_ANI_OFDM_TRIG_HIGH_OLD;
+  ah->config.ofdm_trig_low = ATH9K_ANI_OFDM_TRIG_LOW_OLD;
+  ah->config.cck_trig_high = ATH9K_ANI_CCK_TRIG_HIGH_OLD;
+  ah->config.cck_trig_low = ATH9K_ANI_CCK_TRIG_LOW_OLD;
  }
 
+ ani->spurImmunityLevel = ATH9K_ANI_SPUR_IMMUNE_LVL;
+ ani->firstepLevel = ATH9K_ANI_FIRSTEP_LVL;
+ ani->mrcCCK = AR_SREV_9300_20_OR_LATER(ah) ? true : false;
+ ani->ofdmsTurn = true;
+ ani->ofdmWeakSigDetect = true;
+ ani->cckNoiseImmunityLevel = ATH9K_ANI_CCK_DEF_LEVEL;
+ ani->ofdmNoiseImmunityLevel = ATH9K_ANI_OFDM_DEF_LEVEL;
+
  /*
   * since we expect some ongoing maintenance on the tables, let's sanity
   * check here default level should not modify INI setting.
@@ -524,9 +515,6 @@ void ath9k_hw_ani_init(struct ath_hw *ah)
  ah->aniperiod = ATH9K_ANI_PERIOD;
  ah->config.ani_poll_interval = ATH9K_ANI_POLLINTERVAL;
 
- if (ah->config.enable_ani)
-  ah->proc_phyerr |= HAL_PROCESS_ANI;
-
  ath9k_ani_restart(ah);
  ath9k_enable_mib_counters(ah);
 }
diff --git a/drivers/net/wireless/ath/ath9k/ani.h b/drivers/net/wireless/ath/ath9k/ani.h
index dddb136..c40965b 100644
--- a/drivers/net/wireless/ath/ath9k/ani.h
+++ b/drivers/net/wireless/ath/ath9k/ani.h
@@ -17,32 +17,23 @@
 #ifndef ANI_H
 #define ANI_H
 
-#define HAL_PROCESS_ANI           0x00000001
-
-#define DO_ANI(ah) (((ah)->proc_phyerr & HAL_PROCESS_ANI) && ah->curchan)
-
 #define BEACON_RSSI(ahp) (ahp->stats.avgbrssi)
 
 /* units are errors per second */
-#define ATH9K_ANI_OFDM_TRIG_HIGH          3500
+#define ATH9K_ANI_OFDM_TRIG_HIGH           3500
 #define ATH9K_ANI_OFDM_TRIG_HIGH_BELOW_INI 1000
+#define ATH9K_ANI_OFDM_TRIG_HIGH_OLD       500
 
-/* units are errors per second */
 #define ATH9K_ANI_OFDM_TRIG_LOW           400
 #define ATH9K_ANI_OFDM_TRIG_LOW_ABOVE_INI 900
+#define ATH9K_ANI_OFDM_TRIG_LOW_OLD       200
 
-/* units are errors per second */
 #define ATH9K_ANI_CCK_TRIG_HIGH           600
-
-/* units are errors per second */
+#define ATH9K_ANI_CCK_TRIG_HIGH_OLD       200
 #define ATH9K_ANI_CCK_TRIG_LOW            300
-
-#define ATH9K_ANI_NOISE_IMMUNE_LVL        4
-#define ATH9K_ANI_USE_OFDM_WEAK_SIG       true
-#define ATH9K_ANI_CCK_WEAK_SIG_THR        false
+#define ATH9K_ANI_CCK_TRIG_LOW_OLD        100
 
 #define ATH9K_ANI_SPUR_IMMUNE_LVL         3
-
 #define ATH9K_ANI_FIRSTEP_LVL             2
 
 #define ATH9K_ANI_RSSI_THR_HIGH           40
@@ -53,10 +44,6 @@
 /* in ms */
 #define ATH9K_ANI_POLLINTERVAL            1000
 
-#define HAL_NOISE_IMMUNE_MAX              4
-#define HAL_SPUR_IMMUNE_MAX               7
-#define HAL_FIRST_STEP_MAX                2
-
 #define ATH9K_SIG_FIRSTEP_SETTING_MIN     0
 #define ATH9K_SIG_FIRSTEP_SETTING_MAX     20
 #define ATH9K_SIG_SPUR_IMM_SETTING_MIN    0
@@ -65,15 +52,10 @@
 /* values here are relative to the INI */
 
 enum ath9k_ani_cmd {
- ATH9K_ANI_PRESENT = 0x1,
- ATH9K_ANI_NOISE_IMMUNITY_LEVEL = 0x2,
- ATH9K_ANI_OFDM_WEAK_SIGNAL_DETECTION = 0x4,
- ATH9K_ANI_CCK_WEAK_SIGNAL_THR = 0x8,
- ATH9K_ANI_FIRSTEP_LEVEL = 0x10,
- ATH9K_ANI_SPUR_IMMUNITY_LEVEL = 0x20,
- ATH9K_ANI_MODE = 0x40,
- ATH9K_ANI_PHYERR_RESET = 0x80,
- ATH9K_ANI_MRC_CCK = 0x100,
+ ATH9K_ANI_OFDM_WEAK_SIGNAL_DETECTION = 0x1,
+ ATH9K_ANI_FIRSTEP_LEVEL = 0x2,
+ ATH9K_ANI_SPUR_IMMUNITY_LEVEL = 0x4,
+ ATH9K_ANI_MRC_CCK = 0x8,
  ATH9K_ANI_ALL = 0xfff
 };
 
@@ -111,7 +93,7 @@ struct ar5416AniState {
  u8 mrcCCK;
  u8 spurImmunityLevel;
  u8 firstepLevel;
- u8 ofdmWeakSigDetect;
+ bool ofdmWeakSigDetect;
  u32 listenTime;
  u32 ofdmPhyErrCount;
  u32 cckPhyErrCount;
@@ -119,8 +101,6 @@ struct ar5416AniState {
 };
 
 struct ar5416Stats {
- u32 ast_ani_niup;
- u32 ast_ani_nidown;
  u32 ast_ani_spurup;
  u32 ast_ani_spurdown;
  u32 ast_ani_ofdmon;
diff --git a/drivers/net/wireless/ath/ath9k/antenna.c b/drivers/net/wireless/ath/ath9k/antenna.c
index 664844c..a366843 100644
--- a/drivers/net/wireless/ath/ath9k/antenna.c
+++ b/drivers/net/wireless/ath/ath9k/antenna.c
@@ -16,37 +16,119 @@
 
 #include "ath9k.h"
 
-static inline bool ath_is_alt_ant_ratio_better(int alt_ratio, int maxdelta,
+/*
+ * AR9285
+ * ======
+ *
+ * EEPROM has 2 4-bit fields containing the card configuration.
+ *
+ * antdiv_ctl1:
+ * ------------
+ * bb_enable_ant_div_lnadiv : 1
+ * bb_ant_div_alt_gaintb    : 1
+ * bb_ant_div_main_gaintb   : 1
+ * bb_enable_ant_fast_div   : 1
+ *
+ * antdiv_ctl2:
+ * -----------
+ * bb_ant_div_alt_lnaconf  : 2
+ * bb_ant_div_main_lnaconf : 2
+ *
+ * The EEPROM bits are used as follows:
+ * ------------------------------------
+ *
+ * bb_enable_ant_div_lnadiv      - Enable LNA path rx antenna diversity/combining.
+ *                                 Set in AR_PHY_MULTICHAIN_GAIN_CTL.
+ *
+ * bb_ant_div_[alt/main]_gaintb  - 0 -> Antenna config Alt/Main uses gaintable 0
+ *                                 1 -> Antenna config Alt/Main uses gaintable 1
+ *                                 Set in AR_PHY_MULTICHAIN_GAIN_CTL.
+ *
+ * bb_enable_ant_fast_div        - Enable fast antenna diversity.
+ *                                 Set in AR_PHY_CCK_DETECT.
+ *
+ * bb_ant_div_[alt/main]_lnaconf - Alt/Main LNA diversity/combining input config.
+ *                                 Set in AR_PHY_MULTICHAIN_GAIN_CTL.
+ *                                 10=LNA1
+ *                                 01=LNA2
+ *                                 11=LNA1+LNA2
+ *                                 00=LNA1-LNA2
+ *
+ * AR9485 / AR9565 / AR9331
+ * ========================
+ *
+ * The same bits are present in the EEPROM, but the location in the
+ * EEPROM is different (ant_div_control in ar9300_BaseExtension_1).
+ *
+ * ant_div_alt_lnaconf      ==> bit 0~1
+ * ant_div_main_lnaconf     ==> bit 2~3
+ * ant_div_alt_gaintb       ==> bit 4
+ * ant_div_main_gaintb      ==> bit 5
+ * enable_ant_div_lnadiv    ==> bit 6
+ * enable_ant_fast_div      ==> bit 7
+ */
+
+static inline bool ath_is_alt_ant_ratio_better(struct ath_ant_comb *antcomb,
+            int alt_ratio, int maxdelta,
             int mindelta, int main_rssi_avg,
             int alt_rssi_avg, int pkt_count)
 {
- return (((alt_ratio >= ATH_ANT_DIV_COMB_ALT_ANT_RATIO2) &&
-   (alt_rssi_avg > main_rssi_avg + maxdelta)) ||
-  (alt_rssi_avg > main_rssi_avg + mindelta)) && (pkt_count > 50);
+ if (pkt_count <= 50)
+  return false;
+
+ if (alt_rssi_avg > main_rssi_avg + mindelta)
+  return true;
+
+ if (alt_ratio >= antcomb->ant_ratio2 &&
+     alt_rssi_avg >= antcomb->low_rssi_thresh &&
+     (alt_rssi_avg > main_rssi_avg + maxdelta))
+  return true;
+
+ return false;
 }
 
-static inline bool ath_ant_div_comb_alt_check(u8 div_group, int alt_ratio,
-           int curr_main_set, int curr_alt_set,
-           int alt_rssi_avg, int main_rssi_avg)
+static inline bool ath_ant_div_comb_alt_check(struct ath_hw_antcomb_conf *conf,
+           struct ath_ant_comb *antcomb,
+           int alt_ratio, int alt_rssi_avg,
+           int main_rssi_avg)
 {
- bool result = false;
- switch (div_group) {
+ bool result, set1, set2;
+
+ result = set1 = set2 = false;
+
+ if (conf->main_lna_conf == ATH_ANT_DIV_COMB_LNA2 &&
+     conf->alt_lna_conf == ATH_ANT_DIV_COMB_LNA1)
+  set1 = true;
+
+ if (conf->main_lna_conf == ATH_ANT_DIV_COMB_LNA1 &&
+     conf->alt_lna_conf == ATH_ANT_DIV_COMB_LNA2)
+  set2 = true;
+
+ switch (conf->div_group) {
  case 0:
   if (alt_ratio > ATH_ANT_DIV_COMB_ALT_ANT_RATIO)
    result = true;
   break;
  case 1:
  case 2:
-  if ((((curr_main_set == ATH_ANT_DIV_COMB_LNA2) &&
-        (curr_alt_set == ATH_ANT_DIV_COMB_LNA1) &&
-        (alt_rssi_avg >= (main_rssi_avg - 5))) ||
-       ((curr_main_set == ATH_ANT_DIV_COMB_LNA1) &&
-        (curr_alt_set == ATH_ANT_DIV_COMB_LNA2) &&
-        (alt_rssi_avg >= (main_rssi_avg - 2)))) &&
-      (alt_rssi_avg >= 4))
+  if (alt_rssi_avg < 4 || alt_rssi_avg < antcomb->low_rssi_thresh)
+   break;
+
+  if ((set1 && (alt_rssi_avg >= (main_rssi_avg - 5))) ||
+      (set2 && (alt_rssi_avg >= (main_rssi_avg - 2))) ||
+      (alt_ratio > antcomb->ant_ratio))
    result = true;
-  else
-   result = false;
+
+  break;
+ case 3:
+  if (alt_rssi_avg < 4 || alt_rssi_avg < antcomb->low_rssi_thresh)
+   break;
+
+  if ((set1 && (alt_rssi_avg >= (main_rssi_avg - 3))) ||
+      (set2 && (alt_rssi_avg >= (main_rssi_avg + 3))) ||
+      (alt_ratio > antcomb->ant_ratio))
+   result = true;
+
   break;
  }
 
@@ -108,6 +190,74 @@ static void ath_lnaconf_alt_good_scan(struct ath_ant_comb *antcomb,
  }
 }
 
+static void ath_ant_set_alt_ratio(struct ath_ant_comb *antcomb,
+      struct ath_hw_antcomb_conf *conf)
+{
+ /* set alt to the conf with maximun ratio */
+ if (antcomb->first_ratio && antcomb->second_ratio) {
+  if (antcomb->rssi_second > antcomb->rssi_third) {
+   /* first alt*/
+   if ((antcomb->first_quick_scan_conf == ATH_ANT_DIV_COMB_LNA1) ||
+       (antcomb->first_quick_scan_conf == ATH_ANT_DIV_COMB_LNA2))
+    /* Set alt LNA1 or LNA2*/
+    if (conf->main_lna_conf == ATH_ANT_DIV_COMB_LNA2)
+     conf->alt_lna_conf = ATH_ANT_DIV_COMB_LNA1;
+    else
+     conf->alt_lna_conf = ATH_ANT_DIV_COMB_LNA2;
+   else
+    /* Set alt to A+B or A-B */
+    conf->alt_lna_conf =
+     antcomb->first_quick_scan_conf;
+  } else if ((antcomb->second_quick_scan_conf == ATH_ANT_DIV_COMB_LNA1) ||
+      (antcomb->second_quick_scan_conf == ATH_ANT_DIV_COMB_LNA2)) {
+   /* Set alt LNA1 or LNA2 */
+   if (conf->main_lna_conf == ATH_ANT_DIV_COMB_LNA2)
+    conf->alt_lna_conf = ATH_ANT_DIV_COMB_LNA1;
+   else
+    conf->alt_lna_conf = ATH_ANT_DIV_COMB_LNA2;
+  } else {
+   /* Set alt to A+B or A-B */
+   conf->alt_lna_conf = antcomb->second_quick_scan_conf;
+  }
+ } else if (antcomb->first_ratio) {
+  /* first alt */
+  if ((antcomb->first_quick_scan_conf == ATH_ANT_DIV_COMB_LNA1) ||
+      (antcomb->first_quick_scan_conf == ATH_ANT_DIV_COMB_LNA2))
+   /* Set alt LNA1 or LNA2 */
+   if (conf->main_lna_conf == ATH_ANT_DIV_COMB_LNA2)
+    conf->alt_lna_conf = ATH_ANT_DIV_COMB_LNA1;
+   else
+    conf->alt_lna_conf = ATH_ANT_DIV_COMB_LNA2;
+  else
+   /* Set alt to A+B or A-B */
+   conf->alt_lna_conf = antcomb->first_quick_scan_conf;
+ } else if (antcomb->second_ratio) {
+  /* second alt */
+  if ((antcomb->second_quick_scan_conf == ATH_ANT_DIV_COMB_LNA1) ||
+      (antcomb->second_quick_scan_conf == ATH_ANT_DIV_COMB_LNA2))
+   /* Set alt LNA1 or LNA2 */
+   if (conf->main_lna_conf == ATH_ANT_DIV_COMB_LNA2)
+    conf->alt_lna_conf = ATH_ANT_DIV_COMB_LNA1;
+   else
+    conf->alt_lna_conf = ATH_ANT_DIV_COMB_LNA2;
+  else
+   /* Set alt to A+B or A-B */
+   conf->alt_lna_conf = antcomb->second_quick_scan_conf;
+ } else {
+  /* main is largest */
+  if ((antcomb->main_conf == ATH_ANT_DIV_COMB_LNA1) ||
+      (antcomb->main_conf == ATH_ANT_DIV_COMB_LNA2))
+   /* Set alt LNA1 or LNA2 */
+   if (conf->main_lna_conf == ATH_ANT_DIV_COMB_LNA2)
+    conf->alt_lna_conf = ATH_ANT_DIV_COMB_LNA1;
+   else
+    conf->alt_lna_conf = ATH_ANT_DIV_COMB_LNA2;
+  else
+   /* Set alt to A+B or A-B */
+   conf->alt_lna_conf = antcomb->main_conf;
+ }
+}
+
 static void ath_select_ant_div_from_quick_scan(struct ath_ant_comb *antcomb,
            struct ath_hw_antcomb_conf *div_ant_conf,
            int main_rssi_avg, int alt_rssi_avg,
@@ -129,7 +279,7 @@ static void ath_select_ant_div_from_quick_scan(struct ath_ant_comb *antcomb,
 
   if (antcomb->main_conf == ATH_ANT_DIV_COMB_LNA1) {
    /* main is LNA1 */
-   if (ath_is_alt_ant_ratio_better(alt_ratio,
+   if (ath_is_alt_ant_ratio_better(antcomb, alt_ratio,
       ATH_ANT_DIV_COMB_LNA1_DELTA_HI,
       ATH_ANT_DIV_COMB_LNA1_DELTA_LOW,
       main_rssi_avg, alt_rssi_avg,
@@ -138,7 +288,7 @@ static void ath_select_ant_div_from_quick_scan(struct ath_ant_comb *antcomb,
    else
     antcomb->first_ratio = false;
   } else if (antcomb->main_conf == ATH_ANT_DIV_COMB_LNA2) {
-   if (ath_is_alt_ant_ratio_better(alt_ratio,
+   if (ath_is_alt_ant_ratio_better(antcomb, alt_ratio,
       ATH_ANT_DIV_COMB_LNA1_DELTA_MID,
       ATH_ANT_DIV_COMB_LNA1_DELTA_LOW,
       main_rssi_avg, alt_rssi_avg,
@@ -147,11 +297,11 @@ static void ath_select_ant_div_from_quick_scan(struct ath_ant_comb *antcomb,
    else
     antcomb->first_ratio = false;
   } else {
-   if ((((alt_ratio >= ATH_ANT_DIV_COMB_ALT_ANT_RATIO2) &&
-         (alt_rssi_avg > main_rssi_avg +
-          ATH_ANT_DIV_COMB_LNA1_DELTA_HI)) ||
-        (alt_rssi_avg > main_rssi_avg)) &&
-       (antcomb->total_pkt_count > 50))
+   if (ath_is_alt_ant_ratio_better(antcomb, alt_ratio,
+      ATH_ANT_DIV_COMB_LNA1_DELTA_HI,
+      0,
+      main_rssi_avg, alt_rssi_avg,
+      antcomb->total_pkt_count))
     antcomb->first_ratio = true;
    else
     antcomb->first_ratio = false;
@@ -164,27 +314,31 @@ static void ath_select_ant_div_from_quick_scan(struct ath_ant_comb *antcomb,
   antcomb->rssi_first = main_rssi_avg;
   antcomb->rssi_third = alt_rssi_avg;
 
-  if (antcomb->second_quick_scan_conf == ATH_ANT_DIV_COMB_LNA1)
+  switch(antcomb->second_quick_scan_conf) {
+  case ATH_ANT_DIV_COMB_LNA1:
    antcomb->rssi_lna1 = alt_rssi_avg;
-  else if (antcomb->second_quick_scan_conf ==
-    ATH_ANT_DIV_COMB_LNA2)
+   break;
+  case ATH_ANT_DIV_COMB_LNA2:
    antcomb->rssi_lna2 = alt_rssi_avg;
-  else if (antcomb->second_quick_scan_conf ==
-    ATH_ANT_DIV_COMB_LNA1_PLUS_LNA2) {
+   break;
+  case ATH_ANT_DIV_COMB_LNA1_PLUS_LNA2:
    if (antcomb->main_conf == ATH_ANT_DIV_COMB_LNA2)
     antcomb->rssi_lna2 = main_rssi_avg;
    else if (antcomb->main_conf == ATH_ANT_DIV_COMB_LNA1)
     antcomb->rssi_lna1 = main_rssi_avg;
+   break;
+  default:
+   break;
   }
 
   if (antcomb->rssi_lna2 > antcomb->rssi_lna1 +
-      ATH_ANT_DIV_COMB_LNA1_LNA2_SWITCH_DELTA)
+      div_ant_conf->lna1_lna2_switch_delta)
    div_ant_conf->main_lna_conf = ATH_ANT_DIV_COMB_LNA2;
   else
    div_ant_conf->main_lna_conf = ATH_ANT_DIV_COMB_LNA1;
 
   if (antcomb->main_conf == ATH_ANT_DIV_COMB_LNA1) {
-   if (ath_is_alt_ant_ratio_better(alt_ratio,
+   if (ath_is_alt_ant_ratio_better(antcomb, alt_ratio,
       ATH_ANT_DIV_COMB_LNA1_DELTA_HI,
       ATH_ANT_DIV_COMB_LNA1_DELTA_LOW,
       main_rssi_avg, alt_rssi_avg,
@@ -193,7 +347,7 @@ static void ath_select_ant_div_from_quick_scan(struct ath_ant_comb *antcomb,
    else
     antcomb->second_ratio = false;
   } else if (antcomb->main_conf == ATH_ANT_DIV_COMB_LNA2) {
-   if (ath_is_alt_ant_ratio_better(alt_ratio,
+   if (ath_is_alt_ant_ratio_better(antcomb, alt_ratio,
       ATH_ANT_DIV_COMB_LNA1_DELTA_MID,
       ATH_ANT_DIV_COMB_LNA1_DELTA_LOW,
       main_rssi_avg, alt_rssi_avg,
@@ -202,105 +356,18 @@ static void ath_select_ant_div_from_quick_scan(struct ath_ant_comb *antcomb,
    else
     antcomb->second_ratio = false;
   } else {
-   if ((((alt_ratio >= ATH_ANT_DIV_COMB_ALT_ANT_RATIO2) &&
-         (alt_rssi_avg > main_rssi_avg +
-          ATH_ANT_DIV_COMB_LNA1_DELTA_HI)) ||
-        (alt_rssi_avg > main_rssi_avg)) &&
-       (antcomb->total_pkt_count > 50))
+   if (ath_is_alt_ant_ratio_better(antcomb, alt_ratio,
+      ATH_ANT_DIV_COMB_LNA1_DELTA_HI,
+      0,
+      main_rssi_avg, alt_rssi_avg,
+      antcomb->total_pkt_count))
     antcomb->second_ratio = true;
    else
     antcomb->second_ratio = false;
   }
 
-  /* set alt to the conf with maximun ratio */
-  if (antcomb->first_ratio && antcomb->second_ratio) {
-   if (antcomb->rssi_second > antcomb->rssi_third) {
-    /* first alt*/
-    if ((antcomb->first_quick_scan_conf ==
-        ATH_ANT_DIV_COMB_LNA1) ||
-        (antcomb->first_quick_scan_conf ==
-        ATH_ANT_DIV_COMB_LNA2))
-     /* Set alt LNA1 or LNA2*/
-     if (div_ant_conf->main_lna_conf ==
-         ATH_ANT_DIV_COMB_LNA2)
-      div_ant_conf->alt_lna_conf =
-       ATH_ANT_DIV_COMB_LNA1;
-     else
-      div_ant_conf->alt_lna_conf =
-       ATH_ANT_DIV_COMB_LNA2;
-    else
-     /* Set alt to A+B or A-B */
-     div_ant_conf->alt_lna_conf =
-      antcomb->first_quick_scan_conf;
-   } else if ((antcomb->second_quick_scan_conf ==
-       ATH_ANT_DIV_COMB_LNA1) ||
-       (antcomb->second_quick_scan_conf ==
-       ATH_ANT_DIV_COMB_LNA2)) {
-    /* Set alt LNA1 or LNA2 */
-    if (div_ant_conf->main_lna_conf ==
-        ATH_ANT_DIV_COMB_LNA2)
-     div_ant_conf->alt_lna_conf =
-      ATH_ANT_DIV_COMB_LNA1;
-    else
-     div_ant_conf->alt_lna_conf =
-      ATH_ANT_DIV_COMB_LNA2;
-   } else {
-    /* Set alt to A+B or A-B */
-    div_ant_conf->alt_lna_conf =
-     antcomb->second_quick_scan_conf;
-   }
-  } else if (antcomb->first_ratio) {
-   /* first alt */
-   if ((antcomb->first_quick_scan_conf ==
-       ATH_ANT_DIV_COMB_LNA1) ||
-       (antcomb->first_quick_scan_conf ==
-       ATH_ANT_DIV_COMB_LNA2))
-     /* Set alt LNA1 or LNA2 */
-    if (div_ant_conf->main_lna_conf ==
-        ATH_ANT_DIV_COMB_LNA2)
-     div_ant_conf->alt_lna_conf =
-       ATH_ANT_DIV_COMB_LNA1;
-    else
-     div_ant_conf->alt_lna_conf =
-       ATH_ANT_DIV_COMB_LNA2;
-   else
-    /* Set alt to A+B or A-B */
-    div_ant_conf->alt_lna_conf =
-      antcomb->first_quick_scan_conf;
-  } else if (antcomb->second_ratio) {
-    /* second alt */
-   if ((antcomb->second_quick_scan_conf ==
-       ATH_ANT_DIV_COMB_LNA1) ||
-       (antcomb->second_quick_scan_conf ==
-       ATH_ANT_DIV_COMB_LNA2))
-    /* Set alt LNA1 or LNA2 */
-    if (div_ant_conf->main_lna_conf ==
-        ATH_ANT_DIV_COMB_LNA2)
-     div_ant_conf->alt_lna_conf =
-      ATH_ANT_DIV_COMB_LNA1;
-    else
-     div_ant_conf->alt_lna_conf =
-      ATH_ANT_DIV_COMB_LNA2;
-   else
-    /* Set alt to A+B or A-B */
-    div_ant_conf->alt_lna_conf =
-      antcomb->second_quick_scan_conf;
-  } else {
-   /* main is largest */
-   if ((antcomb->main_conf == ATH_ANT_DIV_COMB_LNA1) ||
-       (antcomb->main_conf == ATH_ANT_DIV_COMB_LNA2))
-    /* Set alt LNA1 or LNA2 */
-    if (div_ant_conf->main_lna_conf ==
-        ATH_ANT_DIV_COMB_LNA2)
-     div_ant_conf->alt_lna_conf =
-       ATH_ANT_DIV_COMB_LNA1;
-    else
-     div_ant_conf->alt_lna_conf =
-       ATH_ANT_DIV_COMB_LNA2;
-   else
-    /* Set alt to A+B or A-B */
-    div_ant_conf->alt_lna_conf = antcomb->main_conf;
-  }
+  ath_ant_set_alt_ratio(antcomb, div_ant_conf);
+
   break;
  default:
   break;
@@ -430,8 +497,7 @@ static void ath_ant_div_conf_fast_divbias(struct ath_hw_antcomb_conf *ant_conf,
    ant_conf->fast_div_bias = 0x1;
    break;
   case 0x10: /* LNA2 A-B */
-   if (!(antcomb->scan) &&
-    (alt_ratio > ATH_ANT_DIV_COMB_ALT_ANT_RATIO))
+   if (!antcomb->scan && (alt_ratio > antcomb->ant_ratio))
     ant_conf->fast_div_bias = 0x1;
    else
     ant_conf->fast_div_bias = 0x2;
@@ -440,15 +506,13 @@ static void ath_ant_div_conf_fast_divbias(struct ath_hw_antcomb_conf *ant_conf,
    ant_conf->fast_div_bias = 0x1;
    break;
   case 0x13: /* LNA2 A+B */
-   if (!(antcomb->scan) &&
-    (alt_ratio > ATH_ANT_DIV_COMB_ALT_ANT_RATIO))
+   if (!antcomb->scan && (alt_ratio > antcomb->ant_ratio))
     ant_conf->fast_div_bias = 0x1;
    else
     ant_conf->fast_div_bias = 0x2;
    break;
   case 0x20: /* LNA1 A-B */
-   if (!(antcomb->scan) &&
-    (alt_ratio > ATH_ANT_DIV_COMB_ALT_ANT_RATIO))
+   if (!antcomb->scan && (alt_ratio > antcomb->ant_ratio))
     ant_conf->fast_div_bias = 0x1;
    else
     ant_conf->fast_div_bias = 0x2;
@@ -457,8 +521,7 @@ static void ath_ant_div_conf_fast_divbias(struct ath_hw_antcomb_conf *ant_conf,
    ant_conf->fast_div_bias = 0x1;
    break;
   case 0x23: /* LNA1 A+B */
-   if (!(antcomb->scan) &&
-    (alt_ratio > ATH_ANT_DIV_COMB_ALT_ANT_RATIO))
+   if (!antcomb->scan && (alt_ratio > antcomb->ant_ratio))
     ant_conf->fast_div_bias = 0x1;
    else
     ant_conf->fast_div_bias = 0x2;
@@ -475,6 +538,9 @@ static void ath_ant_div_conf_fast_divbias(struct ath_hw_antcomb_conf *ant_conf,
   default:
    break;
   }
+
+  if (antcomb->fast_div_bias)
+   ant_conf->fast_div_bias = antcomb->fast_div_bias;
  } else if (ant_conf->div_group == 3) {
   switch ((ant_conf->main_lna_conf << 4) |
    ant_conf->alt_lna_conf) {
@@ -488,42 +554,22 @@ static void ath_ant_div_conf_fast_divbias(struct ath_hw_antcomb_conf *ant_conf,
    ant_conf->fast_div_bias = 0x1;
    break;
   case 0x10: /* LNA2 A-B */
-   if ((antcomb->scan == 0) &&
-       (alt_ratio > ATH_ANT_DIV_COMB_ALT_ANT_RATIO)) {
-    ant_conf->fast_div_bias = 0x3f;
-   } else {
-    ant_conf->fast_div_bias = 0x1;
-   }
+   ant_conf->fast_div_bias = 0x2;
    break;
   case 0x12: /* LNA2 LNA1 */
-   ant_conf->fast_div_bias = 0x39;
+   ant_conf->fast_div_bias = 0x3f;
    break;
   case 0x13: /* LNA2 A+B */
-   if ((antcomb->scan == 0) &&
-       (alt_ratio > ATH_ANT_DIV_COMB_ALT_ANT_RATIO)) {
-    ant_conf->fast_div_bias = 0x3f;
-   } else {
-    ant_conf->fast_div_bias = 0x1;
-   }
+   ant_conf->fast_div_bias = 0x2;
    break;
   case 0x20: /* LNA1 A-B */
-   if ((antcomb->scan == 0) &&
-       (alt_ratio > ATH_ANT_DIV_COMB_ALT_ANT_RATIO)) {
-    ant_conf->fast_div_bias = 0x3f;
-   } else {
-    ant_conf->fast_div_bias = 0x4;
-   }
+   ant_conf->fast_div_bias = 0x3;
    break;
   case 0x21: /* LNA1 LNA2 */
-   ant_conf->fast_div_bias = 0x6;
+   ant_conf->fast_div_bias = 0x3;
    break;
   case 0x23: /* LNA1 A+B */
-   if ((antcomb->scan == 0) &&
-       (alt_ratio > ATH_ANT_DIV_COMB_ALT_ANT_RATIO)) {
-    ant_conf->fast_div_bias = 0x3f;
-   } else {
-    ant_conf->fast_div_bias = 0x6;
-   }
+   ant_conf->fast_div_bias = 0x3;
    break;
   case 0x30: /* A+B A-B */
    ant_conf->fast_div_bias = 0x1;
@@ -540,50 +586,187 @@ static void ath_ant_div_conf_fast_divbias(struct ath_hw_antcomb_conf *ant_conf,
  }
 }
 
+static void ath_ant_try_scan(struct ath_ant_comb *antcomb,
+        struct ath_hw_antcomb_conf *conf,
+        int curr_alt_set, int alt_rssi_avg,
+        int main_rssi_avg)
+{
+ switch (curr_alt_set) {
+ case ATH_ANT_DIV_COMB_LNA2:
+  antcomb->rssi_lna2 = alt_rssi_avg;
+  antcomb->rssi_lna1 = main_rssi_avg;
+  antcomb->scan = true;
+  /* set to A+B */
+  conf->main_lna_conf = ATH_ANT_DIV_COMB_LNA1;
+  conf->alt_lna_conf = ATH_ANT_DIV_COMB_LNA1_PLUS_LNA2;
+  break;
+ case ATH_ANT_DIV_COMB_LNA1:
+  antcomb->rssi_lna1 = alt_rssi_avg;
+  antcomb->rssi_lna2 = main_rssi_avg;
+  antcomb->scan = true;
+  /* set to A+B */
+  conf->main_lna_conf = ATH_ANT_DIV_COMB_LNA2;
+  conf->alt_lna_conf = ATH_ANT_DIV_COMB_LNA1_PLUS_LNA2;
+  break;
+ case ATH_ANT_DIV_COMB_LNA1_PLUS_LNA2:
+  antcomb->rssi_add = alt_rssi_avg;
+  antcomb->scan = true;
+  /* set to A-B */
+  conf->alt_lna_conf = ATH_ANT_DIV_COMB_LNA1_MINUS_LNA2;
+  break;
+ case ATH_ANT_DIV_COMB_LNA1_MINUS_LNA2:
+  antcomb->rssi_sub = alt_rssi_avg;
+  antcomb->scan = false;
+  if (antcomb->rssi_lna2 >
+      (antcomb->rssi_lna1 + conf->lna1_lna2_switch_delta)) {
+   /* use LNA2 as main LNA */
+   if ((antcomb->rssi_add > antcomb->rssi_lna1) &&
+       (antcomb->rssi_add > antcomb->rssi_sub)) {
+    /* set to A+B */
+    conf->main_lna_conf = ATH_ANT_DIV_COMB_LNA2;
+    conf->alt_lna_conf = ATH_ANT_DIV_COMB_LNA1_PLUS_LNA2;
+   } else if (antcomb->rssi_sub >
+       antcomb->rssi_lna1) {
+    /* set to A-B */
+    conf->main_lna_conf = ATH_ANT_DIV_COMB_LNA2;
+    conf->alt_lna_conf = ATH_ANT_DIV_COMB_LNA1_MINUS_LNA2;
+   } else {
+    /* set to LNA1 */
+    conf->main_lna_conf = ATH_ANT_DIV_COMB_LNA2;
+    conf->alt_lna_conf = ATH_ANT_DIV_COMB_LNA1;
+   }
+  } else {
+   /* use LNA1 as main LNA */
+   if ((antcomb->rssi_add > antcomb->rssi_lna2) &&
+       (antcomb->rssi_add > antcomb->rssi_sub)) {
+    /* set to A+B */
+    conf->main_lna_conf = ATH_ANT_DIV_COMB_LNA1;
+    conf->alt_lna_conf = ATH_ANT_DIV_COMB_LNA1_PLUS_LNA2;
+   } else if (antcomb->rssi_sub >
+       antcomb->rssi_lna1) {
+    /* set to A-B */
+    conf->main_lna_conf = ATH_ANT_DIV_COMB_LNA1;
+    conf->alt_lna_conf = ATH_ANT_DIV_COMB_LNA1_MINUS_LNA2;
+   } else {
+    /* set to LNA2 */
+    conf->main_lna_conf = ATH_ANT_DIV_COMB_LNA1;
+    conf->alt_lna_conf = ATH_ANT_DIV_COMB_LNA2;
+   }
+  }
+  break;
+ default:
+  break;
+ }
+}
+
+static bool ath_ant_try_switch(struct ath_hw_antcomb_conf *div_ant_conf,
+          struct ath_ant_comb *antcomb,
+          int alt_ratio, int alt_rssi_avg,
+          int main_rssi_avg, int curr_main_set,
+          int curr_alt_set)
+{
+ bool ret = false;
+
+ if (ath_ant_div_comb_alt_check(div_ant_conf, antcomb, alt_ratio,
+           alt_rssi_avg, main_rssi_avg)) {
+  if (curr_alt_set == ATH_ANT_DIV_COMB_LNA2) {
+   /*
+    * Switch main and alt LNA.
+    */
+   div_ant_conf->main_lna_conf = ATH_ANT_DIV_COMB_LNA2;
+   div_ant_conf->alt_lna_conf = ATH_ANT_DIV_COMB_LNA1;
+  } else if (curr_alt_set == ATH_ANT_DIV_COMB_LNA1) {
+   div_ant_conf->main_lna_conf = ATH_ANT_DIV_COMB_LNA1;
+   div_ant_conf->alt_lna_conf = ATH_ANT_DIV_COMB_LNA2;
+  }
+
+  ret = true;
+ } else if ((curr_alt_set != ATH_ANT_DIV_COMB_LNA1) &&
+     (curr_alt_set != ATH_ANT_DIV_COMB_LNA2)) {
+  /*
+    Set alt to another LNA.
+  */
+  if (curr_main_set == ATH_ANT_DIV_COMB_LNA2)
+   div_ant_conf->alt_lna_conf = ATH_ANT_DIV_COMB_LNA1;
+  else if (curr_main_set == ATH_ANT_DIV_COMB_LNA1)
+   div_ant_conf->alt_lna_conf = ATH_ANT_DIV_COMB_LNA2;
+
+  ret = true;
+ }
+
+ return ret;
+}
+
+static bool ath_ant_short_scan_check(struct ath_ant_comb *antcomb)
+{
+ int alt_ratio;
+
+ if (!antcomb->scan || !antcomb->alt_good)
+  return false;
+
+ if (time_after(jiffies, antcomb->scan_start_time +
+         msecs_to_jiffies(ATH_ANT_DIV_COMB_SHORT_SCAN_INTR)))
+  return true;
+
+ if (antcomb->total_pkt_count == ATH_ANT_DIV_COMB_SHORT_SCAN_PKTCOUNT) {
+  alt_ratio = ((antcomb->alt_recv_cnt * 100) /
+        antcomb->total_pkt_count);
+  if (alt_ratio < antcomb->ant_ratio)
+   return true;
+ }
+
+ return false;
+}
+
 void ath_ant_comb_scan(struct ath_softc *sc, struct ath_rx_status *rs)
 {
  struct ath_hw_antcomb_conf div_ant_conf;
  struct ath_ant_comb *antcomb = &sc->ant_comb;
  int alt_ratio = 0, alt_rssi_avg = 0, main_rssi_avg = 0, curr_alt_set;
  int curr_main_set;
- int main_rssi = rs->rs_rssi_ctl0;
- int alt_rssi = rs->rs_rssi_ctl1;
+ int main_rssi = rs->rs_rssi_ctl[0];
+ int alt_rssi = rs->rs_rssi_ctl[1];
  int rx_ant_conf,  main_ant_conf;
- bool short_scan = false;
+ bool short_scan = false, ret;
 
- rx_ant_conf = (rs->rs_rssi_ctl2 >> ATH_ANT_RX_CURRENT_SHIFT) &
+ rx_ant_conf = (rs->rs_rssi_ctl[2] >> ATH_ANT_RX_CURRENT_SHIFT) &
          ATH_ANT_RX_MASK;
- main_ant_conf = (rs->rs_rssi_ctl2 >> ATH_ANT_RX_MAIN_SHIFT) &
+ main_ant_conf = (rs->rs_rssi_ctl[2] >> ATH_ANT_RX_MAIN_SHIFT) &
     ATH_ANT_RX_MASK;
 
+ if (alt_rssi >= antcomb->low_rssi_thresh) {
+  antcomb->ant_ratio = ATH_ANT_DIV_COMB_ALT_ANT_RATIO;
+  antcomb->ant_ratio2 = ATH_ANT_DIV_COMB_ALT_ANT_RATIO2;
+ } else {
+  antcomb->ant_ratio = ATH_ANT_DIV_COMB_ALT_ANT_RATIO_LOW_RSSI;
+  antcomb->ant_ratio2 = ATH_ANT_DIV_COMB_ALT_ANT_RATIO2_LOW_RSSI;
+ }
+
  /* Record packet only when both main_rssi and  alt_rssi is positive */
  if (main_rssi > 0 && alt_rssi > 0) {
   antcomb->total_pkt_count++;
   antcomb->main_total_rssi += main_rssi;
   antcomb->alt_total_rssi  += alt_rssi;
+
   if (main_ant_conf == rx_ant_conf)
    antcomb->main_recv_cnt++;
   else
    antcomb->alt_recv_cnt++;
  }
 
- /* Short scan check */
- if (antcomb->scan && antcomb->alt_good) {
-  if (time_after(jiffies, antcomb->scan_start_time +
-      msecs_to_jiffies(ATH_ANT_DIV_COMB_SHORT_SCAN_INTR)))
-   short_scan = true;
-  else
-   if (antcomb->total_pkt_count ==
-       ATH_ANT_DIV_COMB_SHORT_SCAN_PKTCOUNT) {
-    alt_ratio = ((antcomb->alt_recv_cnt * 100) /
-         antcomb->total_pkt_count);
-    if (alt_ratio < ATH_ANT_DIV_COMB_ALT_ANT_RATIO)
-     short_scan = true;
-   }
+ if (main_ant_conf == rx_ant_conf) {
+  ANT_STAT_INC(ANT_MAIN, recv_cnt);
+  ANT_LNA_INC(ANT_MAIN, rx_ant_conf);
+ } else {
+  ANT_STAT_INC(ANT_ALT, recv_cnt);
+  ANT_LNA_INC(ANT_ALT, rx_ant_conf);
  }
 
+ /* Short scan check */
+ short_scan = ath_ant_short_scan_check(antcomb);
+
  if (((antcomb->total_pkt_count < ATH_ANT_DIV_COMB_MAX_PKTCOUNT) ||
-     rs->rs_moreaggr) && !short_scan)
+      rs->rs_moreaggr) && !short_scan)
   return;
 
  if (antcomb->total_pkt_count) {
@@ -595,15 +778,13 @@ void ath_ant_comb_scan(struct ath_softc *sc, struct ath_rx_status *rs)
      antcomb->total_pkt_count);
  }
 
-
  ath9k_hw_antdiv_comb_conf_get(sc->sc_ah, &div_ant_conf);
  curr_alt_set = div_ant_conf.alt_lna_conf;
  curr_main_set = div_ant_conf.main_lna_conf;
-
  antcomb->count++;
 
  if (antcomb->count == ATH_ANT_DIV_COMB_MAX_COUNT) {
-  if (alt_ratio > ATH_ANT_DIV_COMB_ALT_ANT_RATIO) {
+  if (alt_ratio > antcomb->ant_ratio) {
    ath_lnaconf_alt_good_scan(antcomb, div_ant_conf,
         main_rssi_avg);
    antcomb->alt_good = true;
@@ -617,153 +798,47 @@ void ath_ant_comb_scan(struct ath_softc *sc, struct ath_rx_status *rs)
  }
 
  if (!antcomb->scan) {
-  if (ath_ant_div_comb_alt_check(div_ant_conf.div_group,
-     alt_ratio, curr_main_set, curr_alt_set,
-     alt_rssi_avg, main_rssi_avg)) {
-   if (curr_alt_set == ATH_ANT_DIV_COMB_LNA2) {
-    /* Switch main and alt LNA */
-    div_ant_conf.main_lna_conf =
-      ATH_ANT_DIV_COMB_LNA2;
-    div_ant_conf.alt_lna_conf  =
-      ATH_ANT_DIV_COMB_LNA1;
-   } else if (curr_alt_set == ATH_ANT_DIV_COMB_LNA1) {
-    div_ant_conf.main_lna_conf =
-      ATH_ANT_DIV_COMB_LNA1;
-    div_ant_conf.alt_lna_conf  =
-      ATH_ANT_DIV_COMB_LNA2;
-   }
-
-   goto div_comb_done;
-  } else if ((curr_alt_set != ATH_ANT_DIV_COMB_LNA1) &&
-      (curr_alt_set != ATH_ANT_DIV_COMB_LNA2)) {
-   /* Set alt to another LNA */
-   if (curr_main_set == ATH_ANT_DIV_COMB_LNA2)
-    div_ant_conf.alt_lna_conf =
-      ATH_ANT_DIV_COMB_LNA1;
-   else if (curr_main_set == ATH_ANT_DIV_COMB_LNA1)
-    div_ant_conf.alt_lna_conf =
-      ATH_ANT_DIV_COMB_LNA2;
-
-   goto div_comb_done;
-  }
-
-  if ((alt_rssi_avg < (main_rssi_avg +
-         div_ant_conf.lna1_lna2_delta)))
+  ret = ath_ant_try_switch(&div_ant_conf, antcomb, alt_ratio,
+      alt_rssi_avg, main_rssi_avg,
+      curr_main_set, curr_alt_set);
+  if (ret)
    goto div_comb_done;
  }
 
+ if (!antcomb->scan &&
+     (alt_rssi_avg < (main_rssi_avg + div_ant_conf.lna1_lna2_delta)))
+  goto div_comb_done;
+
  if (!antcomb->scan_not_start) {
-  switch (curr_alt_set) {
-  case ATH_ANT_DIV_COMB_LNA2:
-   antcomb->rssi_lna2 = alt_rssi_avg;
-   antcomb->rssi_lna1 = main_rssi_avg;
-   antcomb->scan = true;
-   /* set to A+B */
-   div_ant_conf.main_lna_conf =
-    ATH_ANT_DIV_COMB_LNA1;
-   div_ant_conf.alt_lna_conf  =
-    ATH_ANT_DIV_COMB_LNA1_PLUS_LNA2;
-   break;
-  case ATH_ANT_DIV_COMB_LNA1:
-   antcomb->rssi_lna1 = alt_rssi_avg;
-   antcomb->rssi_lna2 = main_rssi_avg;
-   antcomb->scan = true;
-   /* set to A+B */
-   div_ant_conf.main_lna_conf = ATH_ANT_DIV_COMB_LNA2;
-   div_ant_conf.alt_lna_conf  =
-    ATH_ANT_DIV_COMB_LNA1_PLUS_LNA2;
-   break;
-  case ATH_ANT_DIV_COMB_LNA1_PLUS_LNA2:
-   antcomb->rssi_add = alt_rssi_avg;
-   antcomb->scan = true;
-   /* set to A-B */
-   div_ant_conf.alt_lna_conf =
-    ATH_ANT_DIV_COMB_LNA1_MINUS_LNA2;
-   break;
-  case ATH_ANT_DIV_COMB_LNA1_MINUS_LNA2:
-   antcomb->rssi_sub = alt_rssi_avg;
-   antcomb->scan = false;
-   if (antcomb->rssi_lna2 >
-       (antcomb->rssi_lna1 +
-       ATH_ANT_DIV_COMB_LNA1_LNA2_SWITCH_DELTA)) {
-    /* use LNA2 as main LNA */
-    if ((antcomb->rssi_add > antcomb->rssi_lna1) &&
-        (antcomb->rssi_add > antcomb->rssi_sub)) {
-     /* set to A+B */
-     div_ant_conf.main_lna_conf =
-      ATH_ANT_DIV_COMB_LNA2;
-     div_ant_conf.alt_lna_conf  =
-      ATH_ANT_DIV_COMB_LNA1_PLUS_LNA2;
-    } else if (antcomb->rssi_sub >
-        antcomb->rssi_lna1) {
-     /* set to A-B */
-     div_ant_conf.main_lna_conf =
-      ATH_ANT_DIV_COMB_LNA2;
-     div_ant_conf.alt_lna_conf =
-      ATH_ANT_DIV_COMB_LNA1_MINUS_LNA2;
-    } else {
-     /* set to LNA1 */
-     div_ant_conf.main_lna_conf =
-      ATH_ANT_DIV_COMB_LNA2;
-     div_ant_conf.alt_lna_conf =
-      ATH_ANT_DIV_COMB_LNA1;
-    }
-   } else {
-    /* use LNA1 as main LNA */
-    if ((antcomb->rssi_add > antcomb->rssi_lna2) &&
-        (antcomb->rssi_add > antcomb->rssi_sub)) {
-     /* set to A+B */
-     div_ant_conf.main_lna_conf =
-      ATH_ANT_DIV_COMB_LNA1;
-     div_ant_conf.alt_lna_conf  =
-      ATH_ANT_DIV_COMB_LNA1_PLUS_LNA2;
-    } else if (antcomb->rssi_sub >
-        antcomb->rssi_lna1) {
-     /* set to A-B */
-     div_ant_conf.main_lna_conf =
-      ATH_ANT_DIV_COMB_LNA1;
-     div_ant_conf.alt_lna_conf =
-      ATH_ANT_DIV_COMB_LNA1_MINUS_LNA2;
-    } else {
-     /* set to LNA2 */
-     div_ant_conf.main_lna_conf =
-      ATH_ANT_DIV_COMB_LNA1;
-     div_ant_conf.alt_lna_conf =
-      ATH_ANT_DIV_COMB_LNA2;
-    }
-   }
-   break;
-  default:
-   break;
-  }
+  ath_ant_try_scan(antcomb, &div_ant_conf, curr_alt_set,
+     alt_rssi_avg, main_rssi_avg);
  } else {
   if (!antcomb->alt_good) {
    antcomb->scan_not_start = false;
    /* Set alt to another LNA */
    if (curr_main_set == ATH_ANT_DIV_COMB_LNA2) {
     div_ant_conf.main_lna_conf =
-      ATH_ANT_DIV_COMB_LNA2;
+     ATH_ANT_DIV_COMB_LNA2;
     div_ant_conf.alt_lna_conf =
-      ATH_ANT_DIV_COMB_LNA1;
+     ATH_ANT_DIV_COMB_LNA1;
    } else if (curr_main_set == ATH_ANT_DIV_COMB_LNA1) {
     div_ant_conf.main_lna_conf =
-      ATH_ANT_DIV_COMB_LNA1;
+     ATH_ANT_DIV_COMB_LNA1;
     div_ant_conf.alt_lna_conf =
-      ATH_ANT_DIV_COMB_LNA2;
+     ATH_ANT_DIV_COMB_LNA2;
    }
    goto div_comb_done;
   }
+  ath_select_ant_div_from_quick_scan(antcomb, &div_ant_conf,
+         main_rssi_avg, alt_rssi_avg,
+         alt_ratio);
+  antcomb->quick_scan_cnt++;
  }
 
- ath_select_ant_div_from_quick_scan(antcomb, &div_ant_conf,
-        main_rssi_avg, alt_rssi_avg,
-        alt_ratio);
-
- antcomb->quick_scan_cnt++;
-
 div_comb_done:
  ath_ant_div_conf_fast_divbias(&div_ant_conf, antcomb, alt_ratio);
  ath9k_hw_antdiv_comb_conf_set(sc->sc_ah, &div_ant_conf);
+ ath9k_debug_stat_ant(sc, &div_ant_conf, main_rssi_avg, alt_rssi_avg);
 
  antcomb->scan_start_time = jiffies;
  antcomb->total_pkt_count = 0;
@@ -772,26 +847,3 @@ div_comb_done:
  antcomb->main_recv_cnt = 0;
  antcomb->alt_recv_cnt = 0;
 }
-
-void ath_ant_comb_update(struct ath_softc *sc)
-{
- struct ath_hw *ah = sc->sc_ah;
- struct ath_common *common = ath9k_hw_common(ah);
- struct ath_hw_antcomb_conf div_ant_conf;
- u8 lna_conf;
-
- ath9k_hw_antdiv_comb_conf_get(ah, &div_ant_conf);
-
- if (sc->ant_rx == 1)
-  lna_conf = ATH_ANT_DIV_COMB_LNA1;
- else
-  lna_conf = ATH_ANT_DIV_COMB_LNA2;
-
- div_ant_conf.main_lna_conf = lna_conf;
- div_ant_conf.alt_lna_conf = lna_conf;
-
- ath9k_hw_antdiv_comb_conf_set(ah, &div_ant_conf);
-
- if (common->antenna_diversity)
-  ath9k_hw_antctrl_shared_chain_lnadiv(ah, true);
-}
diff --git a/drivers/net/wireless/ath/ath9k/ar5008_phy.c b/drivers/net/wireless/ath/ath9k/ar5008_phy.c
index 391da5a..00fb8ba 100644
--- a/drivers/net/wireless/ath/ath9k/ar5008_phy.c
+++ b/drivers/net/wireless/ath/ath9k/ar5008_phy.c
@@ -26,10 +26,6 @@ static const int firstep_table[] =
 /* level:  0   1   2   3   4   5   6   7   8  */
  { -4, -2,  0,  2,  4,  6,  8, 10, 12 }; /* lvl 0-8, default 2 */
 
-static const int cycpwrThr1_table[] =
-/* level:  0   1   2   3   4   5   6   7   8  */
- { -6, -4, -2,  0,  2,  4,  6,  8 };     /* lvl 0-7, default 3 */
-
 /*
  * register values to turn OFDM weak signal detection OFF
  */
@@ -610,7 +606,15 @@ static void ar5008_hw_override_ini(struct ath_hw *ah,
  REG_SET_BIT(ah, AR_DIAG_SW, (AR_DIAG_RX_DIS | AR_DIAG_RX_ABORT));
 
  if (AR_SREV_9280_20_OR_LATER(ah)) {
-  val = REG_READ(ah, AR_PCU_MISC_MODE2);
+  /*
+   * For AR9280 and above, there is a new feature that allows
+   * Multicast search based on both MAC Address and Key ID.
+   * By default, this feature is enabled. But since the driver
+   * is not using this feature, we switch it off; otherwise
+   * multicast search based on MAC addr only will fail.
+   */
+  val = REG_READ(ah, AR_PCU_MISC_MODE2) &
+   (~AR_ADHOC_MCAST_KEYID_ENABLE);
 
   if (!AR_SREV_9271(ah))
    val &= ~AR_PCU_MISC_MODE2_HWWAR1;
@@ -618,12 +622,11 @@ static void ar5008_hw_override_ini(struct ath_hw *ah,
   if (AR_SREV_9287_11_OR_LATER(ah))
    val = val & (~AR_PCU_MISC_MODE2_HWWAR2);
 
+  val |= AR_PCU_MISC_MODE2_CFP_IGNORE;
+
   REG_WRITE(ah, AR_PCU_MISC_MODE2, val);
  }
 
- REG_SET_BIT(ah, AR_PHY_CCK_DETECT,
-      AR_PHY_CCK_DETECT_BB_ENABLE_ANT_FAST_DIV);
-
  if (AR_SREV_9280_20_OR_LATER(ah))
   return;
  /*
@@ -659,14 +662,13 @@ static void ar5008_hw_set_channel_regs(struct ath_hw *ah,
  if (IS_CHAN_HT40(chan)) {
   phymode |= AR_PHY_FC_DYN2040_EN;
 
-  if ((chan->chanmode == CHANNEL_A_HT40PLUS) ||
-      (chan->chanmode == CHANNEL_G_HT40PLUS))
+  if (IS_CHAN_HT40PLUS(chan))
    phymode |= AR_PHY_FC_DYN2040_PRI_CH;
 
  }
  REG_WRITE(ah, AR_PHY_TURBO, phymode);
 
- ath9k_hw_set11nmac2040(ah);
+ ath9k_hw_set11nmac2040(ah, chan);
 
  ENABLE_REGWRITE_BUFFER(ah);
 
@@ -684,31 +686,12 @@ static int ar5008_hw_process_ini(struct ath_hw *ah,
  int i, regWrites = 0;
  u32 modesIndex, freqIndex;
 
- switch (chan->chanmode) {
- case CHANNEL_A:
- case CHANNEL_A_HT20:
-  modesIndex = 1;
-  freqIndex = 1;
-  break;
- case CHANNEL_A_HT40PLUS:
- case CHANNEL_A_HT40MINUS:
-  modesIndex = 2;
+ if (IS_CHAN_5GHZ(chan)) {
   freqIndex = 1;
-  break;
- case CHANNEL_G:
- case CHANNEL_G_HT20:
- case CHANNEL_B:
-  modesIndex = 4;
-  freqIndex = 2;
-  break;
- case CHANNEL_G_HT40PLUS:
- case CHANNEL_G_HT40MINUS:
-  modesIndex = 3;
+  modesIndex = IS_CHAN_HT40(chan) ? 2 : 1;
+ } else {
   freqIndex = 2;
-  break;
-
- default:
-  return -EINVAL;
+  modesIndex = IS_CHAN_HT40(chan) ? 3 : 4;
  }
 
  /*
@@ -807,8 +790,10 @@ static void ar5008_hw_set_rfmode(struct ath_hw *ah, struct ath9k_channel *chan)
  if (chan == NULL)
   return;
 
- rfMode |= (IS_CHAN_B(chan) || IS_CHAN_G(chan))
-  ? AR_PHY_MODE_DYNAMIC : AR_PHY_MODE_OFDM;
+ if (IS_CHAN_2GHZ(chan))
+  rfMode |= AR_PHY_MODE_DYNAMIC;
+ else
+  rfMode |= AR_PHY_MODE_OFDM;
 
  if (!AR_SREV_9280_20_OR_LATER(ah))
   rfMode |= (IS_CHAN_5GHZ(chan)) ?
@@ -931,8 +916,8 @@ static bool ar5008_hw_ani_control_new(struct ath_hw *ah,
 {
  struct ath_common *common = ath9k_hw_common(ah);
  struct ath9k_channel *chan = ah->curchan;
- struct ar5416AniState *aniState = &chan->ani;
- s32 value, value2;
+ struct ar5416AniState *aniState = &ah->ani;
+ s32 value;
 
  switch (cmd & ah->ani_function) {
  case ATH9K_ANI_OFDM_WEAK_SIGNAL_DETECTION:{
@@ -1019,42 +1004,9 @@ static bool ar5008_hw_ani_control_new(struct ath_hw *ah,
  case ATH9K_ANI_FIRSTEP_LEVEL:{
   u32 level = param;
 
-  if (level >= ARRAY_SIZE(firstep_table)) {
-   ath_dbg(common, ANI,
-    "ATH9K_ANI_FIRSTEP_LEVEL: level out of range (%u > %zu)\n",
-    level, ARRAY_SIZE(firstep_table));
-   return false;
-  }
-
-  /*
-   * make register setting relative to default
-   * from INI file & cap value
-   */
-  value = firstep_table[level] -
-   firstep_table[ATH9K_ANI_FIRSTEP_LVL] +
-   aniState->iniDef.firstep;
-  if (value < ATH9K_SIG_FIRSTEP_SETTING_MIN)
-   value = ATH9K_SIG_FIRSTEP_SETTING_MIN;
-  if (value > ATH9K_SIG_FIRSTEP_SETTING_MAX)
-   value = ATH9K_SIG_FIRSTEP_SETTING_MAX;
+  value = level;
   REG_RMW_FIELD(ah, AR_PHY_FIND_SIG,
-         AR_PHY_FIND_SIG_FIRSTEP,
-         value);
-  /*
-   * we need to set first step low register too
-   * make register setting relative to default
-   * from INI file & cap value
-   */
-  value2 = firstep_table[level] -
-    firstep_table[ATH9K_ANI_FIRSTEP_LVL] +
-    aniState->iniDef.firstepLow;
-  if (value2 < ATH9K_SIG_FIRSTEP_SETTING_MIN)
-   value2 = ATH9K_SIG_FIRSTEP_SETTING_MIN;
-  if (value2 > ATH9K_SIG_FIRSTEP_SETTING_MAX)
-   value2 = ATH9K_SIG_FIRSTEP_SETTING_MAX;
-
-  REG_RMW_FIELD(ah, AR_PHY_FIND_SIG_LOW,
-         AR_PHY_FIND_SIG_FIRSTEP_LOW, value2);
+         AR_PHY_FIND_SIG_FIRSTEP, value);
 
   if (level != aniState->firstepLevel) {
    ath_dbg(common, ANI,
@@ -1071,7 +1023,7 @@ static bool ar5008_hw_ani_control_new(struct ath_hw *ah,
     aniState->firstepLevel,
     level,
     ATH9K_ANI_FIRSTEP_LVL,
-    value2,
+    value,
     aniState->iniDef.firstepLow);
    if (level > aniState->firstepLevel)
     ah->stats.ast_ani_stepup++;
@@ -1084,41 +1036,13 @@ static bool ar5008_hw_ani_control_new(struct ath_hw *ah,
  case ATH9K_ANI_SPUR_IMMUNITY_LEVEL:{
   u32 level = param;
 
-  if (level >= ARRAY_SIZE(cycpwrThr1_table)) {
-   ath_dbg(common, ANI,
-    "ATH9K_ANI_SPUR_IMMUNITY_LEVEL: level out of range (%u > %zu)\n",
-    level, ARRAY_SIZE(cycpwrThr1_table));
-   return false;
-  }
-  /*
-   * make register setting relative to default
-   * from INI file & cap value
-   */
-  value = cycpwrThr1_table[level] -
-   cycpwrThr1_table[ATH9K_ANI_SPUR_IMMUNE_LVL] +
-   aniState->iniDef.cycpwrThr1;
-  if (value < ATH9K_SIG_SPUR_IMM_SETTING_MIN)
-   value = ATH9K_SIG_SPUR_IMM_SETTING_MIN;
-  if (value > ATH9K_SIG_SPUR_IMM_SETTING_MAX)
-   value = ATH9K_SIG_SPUR_IMM_SETTING_MAX;
+  value = (level + 1) * 2;
   REG_RMW_FIELD(ah, AR_PHY_TIMING5,
-         AR_PHY_TIMING5_CYCPWR_THR1,
-         value);
+         AR_PHY_TIMING5_CYCPWR_THR1, value);
 
-  /*
-   * set AR_PHY_EXT_CCA for extension channel
-   * make register setting relative to default
-   * from INI file & cap value
-   */
-  value2 = cycpwrThr1_table[level] -
-    cycpwrThr1_table[ATH9K_ANI_SPUR_IMMUNE_LVL] +
-    aniState->iniDef.cycpwrThr1Ext;
-  if (value2 < ATH9K_SIG_SPUR_IMM_SETTING_MIN)
-   value2 = ATH9K_SIG_SPUR_IMM_SETTING_MIN;
-  if (value2 > ATH9K_SIG_SPUR_IMM_SETTING_MAX)
-   value2 = ATH9K_SIG_SPUR_IMM_SETTING_MAX;
-  REG_RMW_FIELD(ah, AR_PHY_EXT_CCA,
-         AR_PHY_EXT_TIMING5_CYCPWR_THR1, value2);
+  if (IS_CHAN_HT40(ah->curchan))
+   REG_RMW_FIELD(ah, AR_PHY_EXT_CCA,
+          AR_PHY_EXT_TIMING5_CYCPWR_THR1, value);
 
   if (level != aniState->spurImmunityLevel) {
    ath_dbg(common, ANI,
@@ -1135,7 +1059,7 @@ static bool ar5008_hw_ani_control_new(struct ath_hw *ah,
     aniState->spurImmunityLevel,
     level,
     ATH9K_ANI_SPUR_IMMUNE_LVL,
-    value2,
+    value,
     aniState->iniDef.cycpwrThr1Ext);
    if (level > aniState->spurImmunityLevel)
     ah->stats.ast_ani_spurup++;
@@ -1152,8 +1076,6 @@ static bool ar5008_hw_ani_control_new(struct ath_hw *ah,
    */
   WARN_ON(1);
   break;
- case ATH9K_ANI_PRESENT:
-  break;
  default:
   ath_dbg(common, ANI, "invalid cmd %u\n", cmd);
   return false;
@@ -1207,18 +1129,17 @@ static void ar5008_hw_ani_cache_ini_regs(struct ath_hw *ah)
 {
  struct ath_common *common = ath9k_hw_common(ah);
  struct ath9k_channel *chan = ah->curchan;
- struct ar5416AniState *aniState = &chan->ani;
+ struct ar5416AniState *aniState = &ah->ani;
  struct ath9k_ani_default *iniDef;
  u32 val;
 
  iniDef = &aniState->iniDef;
 
- ath_dbg(common, ANI, "ver %d.%d opmode %u chan %d Mhz/0x%x\n",
+ ath_dbg(common, ANI, "ver %d.%d opmode %u chan %d Mhz\n",
   ah->hw_version.macVersion,
   ah->hw_version.macRev,
   ah->opmode,
-  chan->channel,
-  chan->channelFlags);
+  chan->channel);
 
  val = REG_READ(ah, AR_PHY_SFCORR);
  iniDef->m1Thresh = MS(val, AR_PHY_SFCORR_M1_THRESH);
@@ -1251,7 +1172,7 @@ static void ar5008_hw_ani_cache_ini_regs(struct ath_hw *ah)
  /* these levels just got reset to defaults by the INI */
  aniState->spurImmunityLevel = ATH9K_ANI_SPUR_IMMUNE_LVL;
  aniState->firstepLevel = ATH9K_ANI_FIRSTEP_LVL;
- aniState->ofdmWeakSigDetect = ATH9K_ANI_USE_OFDM_WEAK_SIG;
+ aniState->ofdmWeakSigDetect = true;
  aniState->mrcCCK = false; /* not available on pre AR9003 */
 }
 
diff --git a/drivers/net/wireless/ath/ath9k/ar9002_calib.c b/drivers/net/wireless/ath/ath9k/ar9002_calib.c
index 9f58974..cdc7400 100644
--- a/drivers/net/wireless/ath/ath9k/ar9002_calib.c
+++ b/drivers/net/wireless/ath/ath9k/ar9002_calib.c
@@ -33,15 +33,12 @@ static bool ar9002_hw_is_cal_supported(struct ath_hw *ah,
  bool supported = false;
  switch (ah->supp_cals & cal_type) {
  case IQ_MISMATCH_CAL:
-  /* Run IQ Mismatch for non-CCK only */
-  if (!IS_CHAN_B(chan))
-   supported = true;
+  supported = true;
   break;
  case ADC_GAIN_CAL:
  case ADC_DC_CAL:
   /* Run ADC Gain Cal for non-CCK & non 2GHz-HT20 only */
-  if (!IS_CHAN_B(chan) &&
-      !((IS_CHAN_2GHZ(chan) || IS_CHAN_A_FAST_CLOCK(ah, chan)) &&
+  if (!((IS_CHAN_2GHZ(chan) || IS_CHAN_A_FAST_CLOCK(ah, chan)) &&
         IS_CHAN_HT20(chan)))
    supported = true;
   break;
@@ -671,7 +668,7 @@ static bool ar9002_hw_calibrate(struct ath_hw *ah,
 
  nfcal = !!(REG_READ(ah, AR_PHY_AGC_CONTROL) & AR_PHY_AGC_CONTROL_NF);
  if (ah->caldata)
-  nfcal_pending = ah->caldata->nfcal_pending;
+  nfcal_pending = test_bit(NFCAL_PENDING, &ah->caldata->cal_flags);
 
  if (currCal && !nfcal &&
      (currCal->calState == CAL_RUNNING ||
@@ -861,7 +858,7 @@ static bool ar9002_hw_init_cal(struct ath_hw *ah, struct ath9k_channel *chan)
  ar9002_hw_pa_cal(ah, true);
 
  if (ah->caldata)
-  ah->caldata->nfcal_pending = true;
+  set_bit(NFCAL_PENDING, &ah->caldata->cal_flags);
 
  ah->cal_list = ah->cal_list_last = ah->cal_list_curr = NULL;
 
diff --git a/drivers/net/wireless/ath/ath9k/ar9002_hw.c b/drivers/net/wireless/ath/ath9k/ar9002_hw.c
index 830daa1..d480d2f 100644
--- a/drivers/net/wireless/ath/ath9k/ar9002_hw.c
+++ b/drivers/net/wireless/ath/ath9k/ar9002_hw.c
@@ -32,16 +32,8 @@ static int ar9002_hw_init_mode_regs(struct ath_hw *ah)
   return 0;
  }
 
- if (ah->config.pcie_clock_req)
-  INIT_INI_ARRAY(&ah->iniPcieSerdes,
-      ar9280PciePhy_clkreq_off_L1_9280);
- else
-  INIT_INI_ARRAY(&ah->iniPcieSerdes,
-      ar9280PciePhy_clkreq_always_on_L1_9280);
-#ifdef CONFIG_PM_SLEEP
-  INIT_INI_ARRAY(&ah->iniPcieSerdesWow,
-          ar9280PciePhy_awow);
-#endif
+ INIT_INI_ARRAY(&ah->iniPcieSerdes,
+         ar9280PciePhy_clkreq_always_on_L1_9280);
 
  if (AR_SREV_9287_11_OR_LATER(ah)) {
   INIT_INI_ARRAY(&ah->iniModes, ar9287Modes_9287_1_1);
@@ -273,13 +265,12 @@ static void ar9002_hw_configpcipowersave(struct ath_hw *ah,
    if (ah->config.pcie_waen & AR_WA_D3_L1_DISABLE)
     val |= AR_WA_D3_L1_DISABLE;
   } else {
-   if (((AR_SREV_9285(ah) ||
-         AR_SREV_9271(ah) ||
-         AR_SREV_9287(ah)) &&
-        (AR9285_WA_DEFAULT & AR_WA_D3_L1_DISABLE)) ||
-       (AR_SREV_9280(ah) &&
-        (AR9280_WA_DEFAULT & AR_WA_D3_L1_DISABLE))) {
-    val |= AR_WA_D3_L1_DISABLE;
+   if (AR_SREV_9285(ah) || AR_SREV_9271(ah) || AR_SREV_9287(ah)) {
+    if (AR9285_WA_DEFAULT & AR_WA_D3_L1_DISABLE)
+     val |= AR_WA_D3_L1_DISABLE;
+   } else if (AR_SREV_9280(ah)) {
+    if (AR9280_WA_DEFAULT & AR_WA_D3_L1_DISABLE)
+     val |= AR_WA_D3_L1_DISABLE;
    }
   }
 
@@ -301,24 +292,18 @@ static void ar9002_hw_configpcipowersave(struct ath_hw *ah,
  } else {
   if (ah->config.pcie_waen) {
    val = ah->config.pcie_waen;
-   if (!power_off)
-    val &= (~AR_WA_D3_L1_DISABLE);
+   val &= (~AR_WA_D3_L1_DISABLE);
   } else {
-   if (AR_SREV_9285(ah) ||
-       AR_SREV_9271(ah) ||
-       AR_SREV_9287(ah)) {
+   if (AR_SREV_9285(ah) || AR_SREV_9271(ah) || AR_SREV_9287(ah)) {
     val = AR9285_WA_DEFAULT;
-    if (!power_off)
-     val &= (~AR_WA_D3_L1_DISABLE);
-   }
-   else if (AR_SREV_9280(ah)) {
+    val &= (~AR_WA_D3_L1_DISABLE);
+   } else if (AR_SREV_9280(ah)) {
     /*
      * For AR9280 chips, bit 22 of 0x4004
      * needs to be set.
      */
     val = AR9280_WA_DEFAULT;
-    if (!power_off)
-     val &= (~AR_WA_D3_L1_DISABLE);
+    val &= (~AR_WA_D3_L1_DISABLE);
    } else {
     val = AR_WA_DEFAULT;
    }
@@ -398,6 +383,20 @@ void ar9002_hw_enable_async_fifo(struct ath_hw *ah)
  }
 }
 
+static void ar9002_hw_init_hang_checks(struct ath_hw *ah)
+{
+ if (AR_SREV_9100(ah) || AR_SREV_9160(ah)) {
+  ah->config.hw_hang_checks |= HW_BB_RIFS_HANG;
+  ah->config.hw_hang_checks |= HW_BB_DFS_HANG;
+ }
+
+ if (AR_SREV_9280(ah))
+  ah->config.hw_hang_checks |= HW_BB_RX_CLEAR_STUCK_HANG;
+
+ if (AR_SREV_5416(ah) || AR_SREV_9100(ah) || AR_SREV_9160(ah))
+  ah->config.hw_hang_checks |= HW_MAC_HANG;
+}
+
 /* Sets up the AR5008/AR9001/AR9002 hardware familiy callbacks */
 int ar9002_hw_attach_ops(struct ath_hw *ah)
 {
@@ -410,6 +409,7 @@ int ar9002_hw_attach_ops(struct ath_hw *ah)
   return ret;
 
  priv_ops->init_mode_gain_regs = ar9002_hw_init_mode_gain_regs;
+ priv_ops->init_hang_checks = ar9002_hw_init_hang_checks;
 
  ops->config_pci_powersave = ar9002_hw_configpcipowersave;
 
@@ -430,28 +430,10 @@ void ar9002_hw_load_ani_reg(struct ath_hw *ah, struct ath9k_channel *chan)
  u32 modesIndex;
  int i;
 
- switch (chan->chanmode) {
- case CHANNEL_A:
- case CHANNEL_A_HT20:
-  modesIndex = 1;
-  break;
- case CHANNEL_A_HT40PLUS:
- case CHANNEL_A_HT40MINUS:
-  modesIndex = 2;
-  break;
- case CHANNEL_G:
- case CHANNEL_G_HT20:
- case CHANNEL_B:
-  modesIndex = 4;
-  break;
- case CHANNEL_G_HT40PLUS:
- case CHANNEL_G_HT40MINUS:
-  modesIndex = 3;
-  break;
-
- default:
-  return;
- }
+ if (IS_CHAN_5GHZ(chan))
+  modesIndex = IS_CHAN_HT40(chan) ? 2 : 1;
+ else
+  modesIndex = IS_CHAN_HT40(chan) ? 3 : 4;
 
  ENABLE_REGWRITE_BUFFER(ah);
 
diff --git a/drivers/net/wireless/ath/ath9k/ar9002_initvals.h b/drivers/net/wireless/ath/ath9k/ar9002_initvals.h
index beb6162..4d18c66 100644
--- a/drivers/net/wireless/ath/ath9k/ar9002_initvals.h
+++ b/drivers/net/wireless/ath/ath9k/ar9002_initvals.h
@@ -925,20 +925,6 @@ static const u32 ar9280PciePhy_clkreq_always_on_L1_9280[][2] = {
  {0x00004044, 0x00000000},
 };
 
-static const u32 ar9280PciePhy_awow[][2] = {
- /* Addr      allmodes  */
- {0x00004040, 0x9248fd00},
- {0x00004040, 0x24924924},
- {0x00004040, 0xa8000019},
- {0x00004040, 0x13160820},
- {0x00004040, 0xe5980560},
- {0x00004040, 0xc01dcffd},
- {0x00004040, 0x1aaabe41},
- {0x00004040, 0xbe105554},
- {0x00004040, 0x00043007},
- {0x00004044, 0x00000000},
-};
-
 static const u32 ar9285Modes_9285_1_2[][5] = {
  /* Addr      5G_HT20     5G_HT40     2G_HT40     2G_HT20   */
  {0x00001030, 0x00000230, 0x00000460, 0x000002c0, 0x00000160},
diff --git a/drivers/net/wireless/ath/ath9k/ar9002_mac.c b/drivers/net/wireless/ath/ath9k/ar9002_mac.c
index 8d78253..741b38d 100644
--- a/drivers/net/wireless/ath/ath9k/ar9002_mac.c
+++ b/drivers/net/wireless/ath/ath9k/ar9002_mac.c
@@ -29,7 +29,8 @@ static void ar9002_hw_set_desc_link(void *ds, u32 ds_link)
  ((struct ath_desc*) ds)->ds_link = ds_link;
 }
 
-static bool ar9002_hw_get_isr(struct ath_hw *ah, enum ath9k_int *masked)
+static bool ar9002_hw_get_isr(struct ath_hw *ah, enum ath9k_int *masked,
+         u32 *sync_cause_p)
 {
  u32 isr = 0;
  u32 mask2 = 0;
@@ -76,9 +77,16 @@ static bool ar9002_hw_get_isr(struct ath_hw *ah, enum ath9k_int *masked)
     mask2 |= ATH9K_INT_CST;
    if (isr2 & AR_ISR_S2_TSFOOR)
     mask2 |= ATH9K_INT_TSFOOR;
+
+   if (!(pCap->hw_caps & ATH9K_HW_CAP_RAC_SUPPORTED)) {
+    REG_WRITE(ah, AR_ISR_S2, isr2);
+    isr &= ~AR_ISR_BCNMISC;
+   }
   }
 
-  isr = REG_READ(ah, AR_ISR_RAC);
+  if (pCap->hw_caps & ATH9K_HW_CAP_RAC_SUPPORTED)
+   isr = REG_READ(ah, AR_ISR_RAC);
+
   if (isr == 0xffffffff) {
    *masked = 0;
    return false;
@@ -97,11 +105,23 @@ static bool ar9002_hw_get_isr(struct ath_hw *ah, enum ath9k_int *masked)
 
    *masked |= ATH9K_INT_TX;
 
-   s0_s = REG_READ(ah, AR_ISR_S0_S);
+   if (pCap->hw_caps & ATH9K_HW_CAP_RAC_SUPPORTED) {
+    s0_s = REG_READ(ah, AR_ISR_S0_S);
+    s1_s = REG_READ(ah, AR_ISR_S1_S);
+   } else {
+    s0_s = REG_READ(ah, AR_ISR_S0);
+    REG_WRITE(ah, AR_ISR_S0, s0_s);
+    s1_s = REG_READ(ah, AR_ISR_S1);
+    REG_WRITE(ah, AR_ISR_S1, s1_s);
+
+    isr &= ~(AR_ISR_TXOK |
+      AR_ISR_TXDESC |
+      AR_ISR_TXERR |
+      AR_ISR_TXEOL);
+   }
+
    ah->intr_txqs |= MS(s0_s, AR_ISR_S0_QCU_TXOK);
    ah->intr_txqs |= MS(s0_s, AR_ISR_S0_QCU_TXDESC);
-
-   s1_s = REG_READ(ah, AR_ISR_S1_S);
    ah->intr_txqs |= MS(s1_s, AR_ISR_S1_QCU_TXERR);
    ah->intr_txqs |= MS(s1_s, AR_ISR_S1_QCU_TXEOL);
   }
@@ -114,13 +134,15 @@ static bool ar9002_hw_get_isr(struct ath_hw *ah, enum ath9k_int *masked)
   *masked |= mask2;
  }
 
- if (AR_SREV_9100(ah))
-  return true;
-
- if (isr & AR_ISR_GENTMR) {
+ if (!AR_SREV_9100(ah) && (isr & AR_ISR_GENTMR)) {
   u32 s5_s;
 
-  s5_s = REG_READ(ah, AR_ISR_S5_S);
+  if (pCap->hw_caps & ATH9K_HW_CAP_RAC_SUPPORTED) {
+   s5_s = REG_READ(ah, AR_ISR_S5_S);
+  } else {
+   s5_s = REG_READ(ah, AR_ISR_S5);
+  }
+
   ah->intr_gen_timer_trigger =
     MS(s5_s, AR_ISR_S5_GENTIMER_TRIG);
 
@@ -133,10 +155,24 @@ static bool ar9002_hw_get_isr(struct ath_hw *ah, enum ath9k_int *masked)
   if ((s5_s & AR_ISR_S5_TIM_TIMER) &&
       !(pCap->hw_caps & ATH9K_HW_CAP_AUTOSLEEP))
    *masked |= ATH9K_INT_TIM_TIMER;
+
+  if (!(pCap->hw_caps & ATH9K_HW_CAP_RAC_SUPPORTED)) {
+   REG_WRITE(ah, AR_ISR_S5, s5_s);
+   isr &= ~AR_ISR_GENTMR;
+  }
  }
 
+ if (!(pCap->hw_caps & ATH9K_HW_CAP_RAC_SUPPORTED)) {
+  REG_WRITE(ah, AR_ISR, isr);
+  REG_READ(ah, AR_ISR);
+ }
+
+ if (AR_SREV_9100(ah))
+  return true;
+
  if (sync_cause) {
-  ath9k_debug_sync_cause(common, sync_cause);
+  if (sync_cause_p)
+   *sync_cause_p = sync_cause;
   fatal_int =
    (sync_cause &
     (AR_INTR_SYNC_HOST1_FATAL | AR_INTR_SYNC_HOST1_PERR))
diff --git a/drivers/net/wireless/ath/ath9k/ar9002_phy.c b/drivers/net/wireless/ath/ath9k/ar9002_phy.c
index f400351..9a2afa2 100644
--- a/drivers/net/wireless/ath/ath9k/ar9002_phy.c
+++ b/drivers/net/wireless/ath/ath9k/ar9002_phy.c
@@ -201,7 +201,6 @@ static void ar9002_hw_spur_mitigate(struct ath_hw *ah,
  ath9k_hw_get_channel_centers(ah, chan, &centers);
  freq = centers.synth_center;
 
- ah->config.spurmode = SPUR_ENABLE_EEPROM;
  for (i = 0; i < AR_EEPROM_MODAL_SPURS; i++) {
   cur_bb_spur = ah->eep_ops->get_spur_channel(ah, i, is2GHz);
 
@@ -485,7 +484,7 @@ static void ar9002_hw_do_getnf(struct ath_hw *ah,
  if (IS_CHAN_HT40(ah->curchan))
   nfarray[3] = sign_extend32(nf, 8);
 
- if (AR_SREV_9285(ah) || AR_SREV_9271(ah))
+ if (!(ah->rxchainmask & BIT(1)))
   return;
 
  nf = MS(REG_READ(ah, AR_PHY_CH1_CCA), AR9280_PHY_CH1_MINCCA_PWR);
@@ -532,6 +531,7 @@ static void ar9002_hw_antdiv_comb_conf_get(struct ath_hw *ah,
      AR_PHY_9285_ANT_DIV_ALT_LNACONF_S;
  antconf->fast_div_bias = (regval & AR_PHY_9285_FAST_DIV_BIAS) >>
       AR_PHY_9285_FAST_DIV_BIAS_S;
+ antconf->lna1_lna2_switch_delta = -1;
  antconf->lna1_lna2_delta = -3;
  antconf->div_group = 0;
 }
@@ -555,6 +555,69 @@ static void ar9002_hw_antdiv_comb_conf_set(struct ath_hw *ah,
  REG_WRITE(ah, AR_PHY_MULTICHAIN_GAIN_CTL, regval);
 }
 
+#ifdef CONFIG_ATH9K_BTCOEX_SUPPORT
+
+static void ar9002_hw_set_bt_ant_diversity(struct ath_hw *ah, bool enable)
+{
+ struct ath_btcoex_hw *btcoex = &ah->btcoex_hw;
+ u8 antdiv_ctrl1, antdiv_ctrl2;
+ u32 regval;
+
+ if (enable) {
+  antdiv_ctrl1 = ATH_BT_COEX_ANTDIV_CONTROL1_ENABLE;
+  antdiv_ctrl2 = ATH_BT_COEX_ANTDIV_CONTROL2_ENABLE;
+
+  /*
+   * Don't disable BT ant to allow BB to control SWCOM.
+   */
+  btcoex->bt_coex_mode2 &= (~(AR_BT_DISABLE_BT_ANT));
+  REG_WRITE(ah, AR_BT_COEX_MODE2, btcoex->bt_coex_mode2);
+
+  REG_WRITE(ah, AR_PHY_SWITCH_COM, ATH_BT_COEX_ANT_DIV_SWITCH_COM);
+  REG_RMW(ah, AR_PHY_SWITCH_CHAIN_0, 0, 0xf0000000);
+ } else {
+  /*
+   * Disable antenna diversity, use LNA1 only.
+   */
+  antdiv_ctrl1 = ATH_BT_COEX_ANTDIV_CONTROL1_FIXED_A;
+  antdiv_ctrl2 = ATH_BT_COEX_ANTDIV_CONTROL2_FIXED_A;
+
+  /*
+   * Disable BT Ant. to allow concurrent BT and WLAN receive.
+   */
+  btcoex->bt_coex_mode2 |= AR_BT_DISABLE_BT_ANT;
+  REG_WRITE(ah, AR_BT_COEX_MODE2, btcoex->bt_coex_mode2);
+
+  /*
+   * Program SWCOM table to make sure RF switch always parks
+   * at BT side.
+   */
+  REG_WRITE(ah, AR_PHY_SWITCH_COM, 0);
+  REG_RMW(ah, AR_PHY_SWITCH_CHAIN_0, 0, 0xf0000000);
+ }
+
+ regval = REG_READ(ah, AR_PHY_MULTICHAIN_GAIN_CTL);
+ regval &= (~(AR_PHY_9285_ANT_DIV_CTL_ALL));
+        /*
+  * Clear ant_fast_div_bias [14:9] since for WB195,
+  * the main LNA is always LNA1.
+  */
+ regval &= (~(AR_PHY_9285_FAST_DIV_BIAS));
+ regval |= SM(antdiv_ctrl1, AR_PHY_9285_ANT_DIV_CTL);
+ regval |= SM(antdiv_ctrl2, AR_PHY_9285_ANT_DIV_ALT_LNACONF);
+ regval |= SM((antdiv_ctrl2 >> 2), AR_PHY_9285_ANT_DIV_MAIN_LNACONF);
+ regval |= SM((antdiv_ctrl1 >> 1), AR_PHY_9285_ANT_DIV_ALT_GAINTB);
+ regval |= SM((antdiv_ctrl1 >> 2), AR_PHY_9285_ANT_DIV_MAIN_GAINTB);
+ REG_WRITE(ah, AR_PHY_MULTICHAIN_GAIN_CTL, regval);
+
+ regval = REG_READ(ah, AR_PHY_CCK_DETECT);
+ regval &= (~AR_PHY_CCK_DETECT_BB_ENABLE_ANT_FAST_DIV);
+ regval |= SM((antdiv_ctrl1 >> 3), AR_PHY_CCK_DETECT_BB_ENABLE_ANT_FAST_DIV);
+ REG_WRITE(ah, AR_PHY_CCK_DETECT, regval);
+}
+
+#endif
+
 static void ar9002_hw_spectral_scan_config(struct ath_hw *ah,
         struct ath_spec_scan *param)
 {
@@ -616,6 +679,26 @@ static void ar9002_hw_spectral_scan_wait(struct ath_hw *ah)
  }
 }
 
+static void ar9002_hw_tx99_start(struct ath_hw *ah, u32 qnum)
+{
+ REG_SET_BIT(ah, 0x9864, 0x7f000);
+ REG_SET_BIT(ah, 0x9924, 0x7f00fe);
+ REG_CLR_BIT(ah, AR_DIAG_SW, AR_DIAG_RX_DIS);
+ REG_WRITE(ah, AR_CR, AR_CR_RXD);
+ REG_WRITE(ah, AR_DLCL_IFS(qnum), 0);
+ REG_WRITE(ah, AR_D_GBL_IFS_SIFS, 20);
+ REG_WRITE(ah, AR_D_GBL_IFS_EIFS, 20);
+ REG_WRITE(ah, AR_D_FPCTL, 0x10|qnum);
+ REG_WRITE(ah, AR_TIME_OUT, 0x00000400);
+ REG_WRITE(ah, AR_DRETRY_LIMIT(qnum), 0xffffffff);
+ REG_SET_BIT(ah, AR_QMISC(qnum), AR_Q_MISC_DCU_EARLY_TERM_REQ);
+}
+
+static void ar9002_hw_tx99_stop(struct ath_hw *ah)
+{
+ REG_SET_BIT(ah, AR_DIAG_SW, AR_DIAG_RX_DIS);
+}
+
 void ar9002_hw_attach_phy_ops(struct ath_hw *ah)
 {
  struct ath_hw_private_ops *priv_ops = ath9k_hw_private_ops(ah);
@@ -634,5 +717,11 @@ void ar9002_hw_attach_phy_ops(struct ath_hw *ah)
  ops->spectral_scan_trigger = ar9002_hw_spectral_scan_trigger;
  ops->spectral_scan_wait = ar9002_hw_spectral_scan_wait;
 
+#ifdef CONFIG_ATH9K_BTCOEX_SUPPORT
+ ops->set_bt_ant_diversity = ar9002_hw_set_bt_ant_diversity;
+#endif
+ ops->tx99_start = ar9002_hw_tx99_start;
+ ops->tx99_stop = ar9002_hw_tx99_stop;
+
  ar9002_hw_set_nf_limits(ah);
 }
diff --git a/drivers/net/wireless/ath/ath9k/ar9002_phy.h b/drivers/net/wireless/ath/ath9k/ar9002_phy.h
index f9eb2c3..6314ae2 100644
--- a/drivers/net/wireless/ath/ath9k/ar9002_phy.h
+++ b/drivers/net/wireless/ath/ath9k/ar9002_phy.h
@@ -317,13 +317,15 @@
 #define AR_PHY_9285_ANT_DIV_ALT_GAINTB_S    29
 #define AR_PHY_9285_ANT_DIV_MAIN_GAINTB     0x40000000
 #define AR_PHY_9285_ANT_DIV_MAIN_GAINTB_S   30
-#define AR_PHY_9285_ANT_DIV_LNA1            2
-#define AR_PHY_9285_ANT_DIV_LNA2            1
-#define AR_PHY_9285_ANT_DIV_LNA1_PLUS_LNA2  3
-#define AR_PHY_9285_ANT_DIV_LNA1_MINUS_LNA2 0
 #define AR_PHY_9285_ANT_DIV_GAINTB_0        0
 #define AR_PHY_9285_ANT_DIV_GAINTB_1        1
 
+#define ATH_BT_COEX_ANTDIV_CONTROL1_ENABLE  0x0b
+#define ATH_BT_COEX_ANTDIV_CONTROL2_ENABLE  0x09
+#define ATH_BT_COEX_ANTDIV_CONTROL1_FIXED_A 0x04
+#define ATH_BT_COEX_ANTDIV_CONTROL2_FIXED_A 0x09
+#define ATH_BT_COEX_ANT_DIV_SWITCH_COM      0x66666666
+
 #define AR_PHY_EXT_CCA0             0x99b8
 #define AR_PHY_EXT_CCA0_THRESH62    0x000000FF
 #define AR_PHY_EXT_CCA0_THRESH62_S  0
diff --git a/drivers/net/wireless/ath/ath9k/ar9003_2p2_initvals.h b/drivers/net/wireless/ath/ath9k/ar9003_2p2_initvals.h
index 7546b9a..c38399b 100644
--- a/drivers/net/wireless/ath/ath9k/ar9003_2p2_initvals.h
+++ b/drivers/net/wireless/ath/ath9k/ar9003_2p2_initvals.h
@@ -303,7 +303,7 @@ static const u32 ar9300_2p2_mac_postamble[][5] = {
  {0x000010b0, 0x00000e60, 0x00001cc0, 0x00007c70, 0x00003e38},
  {0x00008014, 0x03e803e8, 0x07d007d0, 0x10801600, 0x08400b00},
  {0x0000801c, 0x128d8027, 0x128d804f, 0x12e00057, 0x12e0002b},
- {0x00008120, 0x08f04800, 0x08f04800, 0x08f04810, 0x08f04810},
+ {0x00008120, 0x18f04800, 0x18f04800, 0x18f04810, 0x18f04810},
  {0x000081d0, 0x00003210, 0x00003210, 0x0000320a, 0x0000320a},
  {0x00008318, 0x00003e80, 0x00007d00, 0x00006880, 0x00003440},
 };
@@ -352,7 +352,7 @@ static const u32 ar9300_2p2_baseband_postamble[][5] = {
  {0x0000a288, 0x00000110, 0x00000110, 0x00000110, 0x00000110},
  {0x0000a28c, 0x00022222, 0x00022222, 0x00022222, 0x00022222},
  {0x0000a2c4, 0x00158d18, 0x00158d18, 0x00158d18, 0x00158d18},
- {0x0000a2d0, 0x00041981, 0x00041981, 0x00041981, 0x00041982},
+ {0x0000a2d0, 0x00041983, 0x00041983, 0x00041981, 0x00041982},
  {0x0000a2d8, 0x7999a83b, 0x7999a83b, 0x7999a83b, 0x7999a83b},
  {0x0000a358, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
  {0x0000a830, 0x0000019c, 0x0000019c, 0x0000019c, 0x0000019c},
@@ -378,9 +378,9 @@ static const u32 ar9300_2p2_baseband_core[][2] = {
  {0x00009814, 0x9280c00a},
  {0x00009818, 0x00000000},
  {0x0000981c, 0x00020028},
- {0x00009834, 0x6400a290},
+ {0x00009834, 0x6400a190},
  {0x00009838, 0x0108ecff},
- {0x0000983c, 0x0d000600},
+ {0x0000983c, 0x14000600},
  {0x00009880, 0x201fff00},
  {0x00009884, 0x00001042},
  {0x000098a4, 0x00200400},
@@ -401,7 +401,7 @@ static const u32 ar9300_2p2_baseband_core[][2] = {
  {0x00009d04, 0x40206c10},
  {0x00009d08, 0x009c4060},
  {0x00009d0c, 0x9883800a},
- {0x00009d10, 0x01834061},
+ {0x00009d10, 0x01884061},
  {0x00009d14, 0x00c0040b},
  {0x00009d18, 0x00000000},
  {0x00009e08, 0x0038230c},
@@ -410,7 +410,7 @@ static const u32 ar9300_2p2_baseband_core[][2] = {
  {0x00009e30, 0x06336f77},
  {0x00009e34, 0x6af6532f},
  {0x00009e38, 0x0cc80c00},
- {0x00009e40, 0x0d261820},
+ {0x00009e40, 0x0d261800},
  {0x00009e4c, 0x00001004},
  {0x00009e50, 0x00ff03f1},
  {0x00009e54, 0x00000000},
@@ -459,7 +459,7 @@ static const u32 ar9300_2p2_baseband_core[][2] = {
  {0x0000a3e8, 0x20202020},
  {0x0000a3ec, 0x20202020},
  {0x0000a3f0, 0x00000000},
- {0x0000a3f4, 0x00000246},
+ {0x0000a3f4, 0x00000000},
  {0x0000a3f8, 0x0c9bd380},
  {0x0000a3fc, 0x000f0f01},
  {0x0000a400, 0x8fa91f01},
@@ -534,107 +534,107 @@ static const u32 ar9300_2p2_baseband_core[][2] = {
 
 static const u32 ar9300Modes_high_power_tx_gain_table_2p2[][5] = {
  /* Addr      5G_HT20     5G_HT40     2G_HT40     2G_HT20   */
- {0x0000a2dc, 0x0380c7fc, 0x0380c7fc, 0x03aaa352, 0x03aaa352},
- {0x0000a2e0, 0x0000f800, 0x0000f800, 0x03ccc584, 0x03ccc584},
- {0x0000a2e4, 0x03ff0000, 0x03ff0000, 0x03f0f800, 0x03f0f800},
+ {0x0000a2dc, 0x000cfff0, 0x000cfff0, 0x03aaa352, 0x03aaa352},
+ {0x0000a2e0, 0x000f0000, 0x000f0000, 0x03ccc584, 0x03ccc584},
+ {0x0000a2e4, 0x03f00000, 0x03f00000, 0x03f0f800, 0x03f0f800},
  {0x0000a2e8, 0x00000000, 0x00000000, 0x03ff0000, 0x03ff0000},
- {0x0000a410, 0x000050d8, 0x000050d8, 0x000050d9, 0x000050d9},
- {0x0000a500, 0x00002220, 0x00002220, 0x00000000, 0x00000000},
- {0x0000a504, 0x04002222, 0x04002222, 0x04000002, 0x04000002},
- {0x0000a508, 0x09002421, 0x09002421, 0x08000004, 0x08000004},
- {0x0000a50c, 0x0d002621, 0x0d002621, 0x0b000200, 0x0b000200},
- {0x0000a510, 0x13004620, 0x13004620, 0x0f000202, 0x0f000202},
- {0x0000a514, 0x19004a20, 0x19004a20, 0x11000400, 0x11000400},
- {0x0000a518, 0x1d004e20, 0x1d004e20, 0x15000402, 0x15000402},
- {0x0000a51c, 0x21005420, 0x21005420, 0x19000404, 0x19000404},
- {0x0000a520, 0x26005e20, 0x26005e20, 0x1b000603, 0x1b000603},
- {0x0000a524, 0x2b005e40, 0x2b005e40, 0x1f000a02, 0x1f000a02},
- {0x0000a528, 0x2f005e42, 0x2f005e42, 0x23000a04, 0x23000a04},
- {0x0000a52c, 0x33005e44, 0x33005e44, 0x26000a20, 0x26000a20},
- {0x0000a530, 0x38005e65, 0x38005e65, 0x2a000e20, 0x2a000e20},
- {0x0000a534, 0x3c005e69, 0x3c005e69, 0x2e000e22, 0x2e000e22},
- {0x0000a538, 0x40005e6b, 0x40005e6b, 0x31000e24, 0x31000e24},
- {0x0000a53c, 0x44005e6d, 0x44005e6d, 0x34001640, 0x34001640},
- {0x0000a540, 0x49005e72, 0x49005e72, 0x38001660, 0x38001660},
- {0x0000a544, 0x4e005eb2, 0x4e005eb2, 0x3b001861, 0x3b001861},
- {0x0000a548, 0x53005f12, 0x53005f12, 0x3e001a81, 0x3e001a81},
- {0x0000a54c, 0x59025eb2, 0x59025eb2, 0x42001a83, 0x42001a83},
- {0x0000a550, 0x5e025f12, 0x5e025f12, 0x44001c84, 0x44001c84},
- {0x0000a554, 0x61027f12, 0x61027f12, 0x48001ce3, 0x48001ce3},
- {0x0000a558, 0x6702bf12, 0x6702bf12, 0x4c001ce5, 0x4c001ce5},
- {0x0000a55c, 0x6b02bf14, 0x6b02bf14, 0x50001ce9, 0x50001ce9},
- {0x0000a560, 0x6f02bf16, 0x6f02bf16, 0x54001ceb, 0x54001ceb},
- {0x0000a564, 0x6f02bf16, 0x6f02bf16, 0x56001eec, 0x56001eec},
- {0x0000a568, 0x6f02bf16, 0x6f02bf16, 0x56001eec, 0x56001eec},
- {0x0000a56c, 0x6f02bf16, 0x6f02bf16, 0x56001eec, 0x56001eec},
- {0x0000a570, 0x6f02bf16, 0x6f02bf16, 0x56001eec, 0x56001eec},
- {0x0000a574, 0x6f02bf16, 0x6f02bf16, 0x56001eec, 0x56001eec},
- {0x0000a578, 0x6f02bf16, 0x6f02bf16, 0x56001eec, 0x56001eec},
- {0x0000a57c, 0x6f02bf16, 0x6f02bf16, 0x56001eec, 0x56001eec},
- {0x0000a580, 0x00802220, 0x00802220, 0x00800000, 0x00800000},
- {0x0000a584, 0x04802222, 0x04802222, 0x04800002, 0x04800002},
- {0x0000a588, 0x09802421, 0x09802421, 0x08800004, 0x08800004},
- {0x0000a58c, 0x0d802621, 0x0d802621, 0x0b800200, 0x0b800200},
- {0x0000a590, 0x13804620, 0x13804620, 0x0f800202, 0x0f800202},
- {0x0000a594, 0x19804a20, 0x19804a20, 0x11800400, 0x11800400},
- {0x0000a598, 0x1d804e20, 0x1d804e20, 0x15800402, 0x15800402},
- {0x0000a59c, 0x21805420, 0x21805420, 0x19800404, 0x19800404},
- {0x0000a5a0, 0x26805e20, 0x26805e20, 0x1b800603, 0x1b800603},
- {0x0000a5a4, 0x2b805e40, 0x2b805e40, 0x1f800a02, 0x1f800a02},
- {0x0000a5a8, 0x2f805e42, 0x2f805e42, 0x23800a04, 0x23800a04},
- {0x0000a5ac, 0x33805e44, 0x33805e44, 0x26800a20, 0x26800a20},
- {0x0000a5b0, 0x38805e65, 0x38805e65, 0x2a800e20, 0x2a800e20},
- {0x0000a5b4, 0x3c805e69, 0x3c805e69, 0x2e800e22, 0x2e800e22},
- {0x0000a5b8, 0x40805e6b, 0x40805e6b, 0x31800e24, 0x31800e24},
- {0x0000a5bc, 0x44805e6d, 0x44805e6d, 0x34801640, 0x34801640},
- {0x0000a5c0, 0x49805e72, 0x49805e72, 0x38801660, 0x38801660},
- {0x0000a5c4, 0x4e805eb2, 0x4e805eb2, 0x3b801861, 0x3b801861},
- {0x0000a5c8, 0x53805f12, 0x53805f12, 0x3e801a81, 0x3e801a81},
- {0x0000a5cc, 0x59825eb2, 0x59825eb2, 0x42801a83, 0x42801a83},
- {0x0000a5d0, 0x5e825f12, 0x5e825f12, 0x44801c84, 0x44801c84},
- {0x0000a5d4, 0x61827f12, 0x61827f12, 0x48801ce3, 0x48801ce3},
- {0x0000a5d8, 0x6782bf12, 0x6782bf12, 0x4c801ce5, 0x4c801ce5},
- {0x0000a5dc, 0x6b82bf14, 0x6b82bf14, 0x50801ce9, 0x50801ce9},
- {0x0000a5e0, 0x6f82bf16, 0x6f82bf16, 0x54801ceb, 0x54801ceb},
- {0x0000a5e4, 0x6f82bf16, 0x6f82bf16, 0x56801eec, 0x56801eec},
- {0x0000a5e8, 0x6f82bf16, 0x6f82bf16, 0x56801eec, 0x56801eec},
- {0x0000a5ec, 0x6f82bf16, 0x6f82bf16, 0x56801eec, 0x56801eec},
- {0x0000a5f0, 0x6f82bf16, 0x6f82bf16, 0x56801eec, 0x56801eec},
- {0x0000a5f4, 0x6f82bf16, 0x6f82bf16, 0x56801eec, 0x56801eec},
- {0x0000a5f8, 0x6f82bf16, 0x6f82bf16, 0x56801eec, 0x56801eec},
- {0x0000a5fc, 0x6f82bf16, 0x6f82bf16, 0x56801eec, 0x56801eec},
+ {0x0000a410, 0x000050d9, 0x000050d9, 0x000050d9, 0x000050d9},
+ {0x0000a500, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
+ {0x0000a504, 0x06000003, 0x06000003, 0x04000002, 0x04000002},
+ {0x0000a508, 0x0a000020, 0x0a000020, 0x08000004, 0x08000004},
+ {0x0000a50c, 0x10000023, 0x10000023, 0x0b000200, 0x0b000200},
+ {0x0000a510, 0x15000028, 0x15000028, 0x0f000202, 0x0f000202},
+ {0x0000a514, 0x1b00002b, 0x1b00002b, 0x12000400, 0x12000400},
+ {0x0000a518, 0x1f020028, 0x1f020028, 0x16000402, 0x16000402},
+ {0x0000a51c, 0x2502002b, 0x2502002b, 0x19000404, 0x19000404},
+ {0x0000a520, 0x2a04002a, 0x2a04002a, 0x1c000603, 0x1c000603},
+ {0x0000a524, 0x2e06002a, 0x2e06002a, 0x21000a02, 0x21000a02},
+ {0x0000a528, 0x3302202d, 0x3302202d, 0x25000a04, 0x25000a04},
+ {0x0000a52c, 0x3804202c, 0x3804202c, 0x28000a20, 0x28000a20},
+ {0x0000a530, 0x3c06202c, 0x3c06202c, 0x2c000e20, 0x2c000e20},
+ {0x0000a534, 0x4108202d, 0x4108202d, 0x30000e22, 0x30000e22},
+ {0x0000a538, 0x4506402d, 0x4506402d, 0x34000e24, 0x34000e24},
+ {0x0000a53c, 0x4906222d, 0x4906222d, 0x38001640, 0x38001640},
+ {0x0000a540, 0x4d062231, 0x4d062231, 0x3c001660, 0x3c001660},
+ {0x0000a544, 0x50082231, 0x50082231, 0x3f001861, 0x3f001861},
+ {0x0000a548, 0x5608422e, 0x5608422e, 0x43001a81, 0x43001a81},
+ {0x0000a54c, 0x5e08442e, 0x5e08442e, 0x47001a83, 0x47001a83},
+ {0x0000a550, 0x620a4431, 0x620a4431, 0x4a001c84, 0x4a001c84},
+ {0x0000a554, 0x640a4432, 0x640a4432, 0x4e001ce3, 0x4e001ce3},
+ {0x0000a558, 0x680a4434, 0x680a4434, 0x52001ce5, 0x52001ce5},
+ {0x0000a55c, 0x6c0a6434, 0x6c0a6434, 0x56001ce9, 0x56001ce9},
+ {0x0000a560, 0x6f0a6633, 0x6f0a6633, 0x5a001ceb, 0x5a001ceb},
+ {0x0000a564, 0x730c6634, 0x730c6634, 0x5d001eec, 0x5d001eec},
+ {0x0000a568, 0x730c6634, 0x730c6634, 0x5d001eec, 0x5d001eec},
+ {0x0000a56c, 0x730c6634, 0x730c6634, 0x5d001eec, 0x5d001eec},
+ {0x0000a570, 0x730c6634, 0x730c6634, 0x5d001eec, 0x5d001eec},
+ {0x0000a574, 0x730c6634, 0x730c6634, 0x5d001eec, 0x5d001eec},
+ {0x0000a578, 0x730c6634, 0x730c6634, 0x5d001eec, 0x5d001eec},
+ {0x0000a57c, 0x730c6634, 0x730c6634, 0x5d001eec, 0x5d001eec},
+ {0x0000a580, 0x00800000, 0x00800000, 0x00800000, 0x00800000},
+ {0x0000a584, 0x06800003, 0x06800003, 0x04800002, 0x04800002},
+ {0x0000a588, 0x0a800020, 0x0a800020, 0x08800004, 0x08800004},
+ {0x0000a58c, 0x10800023, 0x10800023, 0x0b800200, 0x0b800200},
+ {0x0000a590, 0x15800028, 0x15800028, 0x0f800202, 0x0f800202},
+ {0x0000a594, 0x1b80002b, 0x1b80002b, 0x12800400, 0x12800400},
+ {0x0000a598, 0x1f820028, 0x1f820028, 0x16800402, 0x16800402},
+ {0x0000a59c, 0x2582002b, 0x2582002b, 0x19800404, 0x19800404},
+ {0x0000a5a0, 0x2a84002a, 0x2a84002a, 0x1c800603, 0x1c800603},
+ {0x0000a5a4, 0x2e86002a, 0x2e86002a, 0x21800a02, 0x21800a02},
+ {0x0000a5a8, 0x3382202d, 0x3382202d, 0x25800a04, 0x25800a04},
+ {0x0000a5ac, 0x3884202c, 0x3884202c, 0x28800a20, 0x28800a20},
+ {0x0000a5b0, 0x3c86202c, 0x3c86202c, 0x2c800e20, 0x2c800e20},
+ {0x0000a5b4, 0x4188202d, 0x4188202d, 0x30800e22, 0x30800e22},
+ {0x0000a5b8, 0x4586402d, 0x4586402d, 0x34800e24, 0x34800e24},
+ {0x0000a5bc, 0x4986222d, 0x4986222d, 0x38801640, 0x38801640},
+ {0x0000a5c0, 0x4d862231, 0x4d862231, 0x3c801660, 0x3c801660},
+ {0x0000a5c4, 0x50882231, 0x50882231, 0x3f801861, 0x3f801861},
+ {0x0000a5c8, 0x5688422e, 0x5688422e, 0x43801a81, 0x43801a81},
+ {0x0000a5cc, 0x5e88442e, 0x5e88442e, 0x47801a83, 0x47801a83},
+ {0x0000a5d0, 0x628a4431, 0x628a4431, 0x4a801c84, 0x4a801c84},
+ {0x0000a5d4, 0x648a4432, 0x648a4432, 0x4e801ce3, 0x4e801ce3},
+ {0x0000a5d8, 0x688a4434, 0x688a4434, 0x52801ce5, 0x52801ce5},
+ {0x0000a5dc, 0x6c8a6434, 0x6c8a6434, 0x56801ce9, 0x56801ce9},
+ {0x0000a5e0, 0x6f8a6633, 0x6f8a6633, 0x5a801ceb, 0x5a801ceb},
+ {0x0000a5e4, 0x738c6634, 0x738c6634, 0x5d801eec, 0x5d801eec},
+ {0x0000a5e8, 0x738c6634, 0x738c6634, 0x5d801eec, 0x5d801eec},
+ {0x0000a5ec, 0x738c6634, 0x738c6634, 0x5d801eec, 0x5d801eec},
+ {0x0000a5f0, 0x738c6634, 0x738c6634, 0x5d801eec, 0x5d801eec},
+ {0x0000a5f4, 0x738c6634, 0x738c6634, 0x5d801eec, 0x5d801eec},
+ {0x0000a5f8, 0x738c6634, 0x738c6634, 0x5d801eec, 0x5d801eec},
+ {0x0000a5fc, 0x738c6634, 0x738c6634, 0x5d801eec, 0x5d801eec},
  {0x0000a600, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
  {0x0000a604, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
- {0x0000a608, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
- {0x0000a60c, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
- {0x0000a610, 0x00804000, 0x00804000, 0x00000000, 0x00000000},
- {0x0000a614, 0x00804201, 0x00804201, 0x01404000, 0x01404000},
- {0x0000a618, 0x0280c802, 0x0280c802, 0x01404501, 0x01404501},
- {0x0000a61c, 0x0280ca03, 0x0280ca03, 0x02008501, 0x02008501},
- {0x0000a620, 0x04c15104, 0x04c15104, 0x0280ca03, 0x0280ca03},
- {0x0000a624, 0x04c15305, 0x04c15305, 0x03010c04, 0x03010c04},
- {0x0000a628, 0x04c15305, 0x04c15305, 0x04014c04, 0x04014c04},
- {0x0000a62c, 0x04c15305, 0x04c15305, 0x04015005, 0x04015005},
- {0x0000a630, 0x04c15305, 0x04c15305, 0x04015005, 0x04015005},
- {0x0000a634, 0x04c15305, 0x04c15305, 0x04015005, 0x04015005},
- {0x0000a638, 0x04c15305, 0x04c15305, 0x04015005, 0x04015005},
- {0x0000a63c, 0x04c15305, 0x04c15305, 0x04015005, 0x04015005},
- {0x0000b2dc, 0x0380c7fc, 0x0380c7fc, 0x03aaa352, 0x03aaa352},
- {0x0000b2e0, 0x0000f800, 0x0000f800, 0x03ccc584, 0x03ccc584},
- {0x0000b2e4, 0x03ff0000, 0x03ff0000, 0x03f0f800, 0x03f0f800},
+ {0x0000a608, 0x01804601, 0x01804601, 0x00000000, 0x00000000},
+ {0x0000a60c, 0x01804601, 0x01804601, 0x00000000, 0x00000000},
+ {0x0000a610, 0x01804601, 0x01804601, 0x00000000, 0x00000000},
+ {0x0000a614, 0x01804601, 0x01804601, 0x01404000, 0x01404000},
+ {0x0000a618, 0x01804601, 0x01804601, 0x01404501, 0x01404501},
+ {0x0000a61c, 0x01804601, 0x01804601, 0x02008501, 0x02008501},
+ {0x0000a620, 0x03408d02, 0x03408d02, 0x0280ca03, 0x0280ca03},
+ {0x0000a624, 0x0300cc03, 0x0300cc03, 0x03010c04, 0x03010c04},
+ {0x0000a628, 0x03410d04, 0x03410d04, 0x04014c04, 0x04014c04},
+ {0x0000a62c, 0x03410d04, 0x03410d04, 0x04015005, 0x04015005},
+ {0x0000a630, 0x03410d04, 0x03410d04, 0x04015005, 0x04015005},
+ {0x0000a634, 0x03410d04, 0x03410d04, 0x04015005, 0x04015005},
+ {0x0000a638, 0x03410d04, 0x03410d04, 0x04015005, 0x04015005},
+ {0x0000a63c, 0x03410d04, 0x03410d04, 0x04015005, 0x04015005},
+ {0x0000b2dc, 0x000cfff0, 0x000cfff0, 0x03aaa352, 0x03aaa352},
+ {0x0000b2e0, 0x000f0000, 0x000f0000, 0x03ccc584, 0x03ccc584},
+ {0x0000b2e4, 0x03f00000, 0x03f00000, 0x03f0f800, 0x03f0f800},
  {0x0000b2e8, 0x00000000, 0x00000000, 0x03ff0000, 0x03ff0000},
- {0x0000c2dc, 0x0380c7fc, 0x0380c7fc, 0x03aaa352, 0x03aaa352},
- {0x0000c2e0, 0x0000f800, 0x0000f800, 0x03ccc584, 0x03ccc584},
- {0x0000c2e4, 0x03ff0000, 0x03ff0000, 0x03f0f800, 0x03f0f800},
+ {0x0000c2dc, 0x000cfff0, 0x000cfff0, 0x03aaa352, 0x03aaa352},
+ {0x0000c2e0, 0x000f0000, 0x000f0000, 0x03ccc584, 0x03ccc584},
+ {0x0000c2e4, 0x03f00000, 0x03f00000, 0x03f0f800, 0x03f0f800},
  {0x0000c2e8, 0x00000000, 0x00000000, 0x03ff0000, 0x03ff0000},
  {0x00016044, 0x012492d4, 0x012492d4, 0x012492d4, 0x012492d4},
- {0x00016048, 0x66480001, 0x66480001, 0x66480001, 0x66480001},
+ {0x00016048, 0x61200001, 0x61200001, 0x66480001, 0x66480001},
  {0x00016068, 0x6db6db6c, 0x6db6db6c, 0x6db6db6c, 0x6db6db6c},
  {0x00016444, 0x012492d4, 0x012492d4, 0x012492d4, 0x012492d4},
- {0x00016448, 0x66480001, 0x66480001, 0x66480001, 0x66480001},
+ {0x00016448, 0x61200001, 0x61200001, 0x66480001, 0x66480001},
  {0x00016468, 0x6db6db6c, 0x6db6db6c, 0x6db6db6c, 0x6db6db6c},
  {0x00016844, 0x012492d4, 0x012492d4, 0x012492d4, 0x012492d4},
- {0x00016848, 0x66480001, 0x66480001, 0x66480001, 0x66480001},
+ {0x00016848, 0x61200001, 0x61200001, 0x66480001, 0x66480001},
  {0x00016868, 0x6db6db6c, 0x6db6db6c, 0x6db6db6c, 0x6db6db6c},
 };
 
@@ -644,7 +644,7 @@ static const u32 ar9300Modes_high_ob_db_tx_gain_table_2p2[][5] = {
  {0x0000a2e0, 0x0000f000, 0x0000f000, 0x03ccc584, 0x03ccc584},
  {0x0000a2e4, 0x01ff0000, 0x01ff0000, 0x03f0f800, 0x03f0f800},
  {0x0000a2e8, 0x00000000, 0x00000000, 0x03ff0000, 0x03ff0000},
- {0x0000a410, 0x000050d8, 0x000050d8, 0x000050d9, 0x000050d9},
+ {0x0000a410, 0x000050d4, 0x000050d4, 0x000050d9, 0x000050d9},
  {0x0000a500, 0x00002220, 0x00002220, 0x00000000, 0x00000000},
  {0x0000a504, 0x04002222, 0x04002222, 0x04000002, 0x04000002},
  {0x0000a508, 0x09002421, 0x09002421, 0x08000004, 0x08000004},
@@ -1086,8 +1086,8 @@ static const u32 ar9300Common_rx_gain_table_2p2[][2] = {
  {0x0000b074, 0x00000000},
  {0x0000b078, 0x00000000},
  {0x0000b07c, 0x00000000},
- {0x0000b080, 0x2a2d2f32},
- {0x0000b084, 0x21232328},
+ {0x0000b080, 0x23232323},
+ {0x0000b084, 0x21232323},
  {0x0000b088, 0x19191c1e},
  {0x0000b08c, 0x12141417},
  {0x0000b090, 0x07070e0e},
@@ -1385,9 +1385,9 @@ static const u32 ar9300_2p2_mac_core[][2] = {
  {0x000081f8, 0x00000000},
  {0x000081fc, 0x00000000},
  {0x00008240, 0x00100000},
- {0x00008244, 0x0010f424},
+ {0x00008244, 0x0010f400},
  {0x00008248, 0x00000800},
- {0x0000824c, 0x0001e848},
+ {0x0000824c, 0x0001e800},
  {0x00008250, 0x00000000},
  {0x00008254, 0x00000000},
  {0x00008258, 0x00000000},
@@ -1726,16 +1726,30 @@ static const u32 ar9300PciePhy_pll_on_clkreq_disable_L1_2p2[][2] = {
 
 static const u32 ar9300PciePhy_clkreq_enable_L1_2p2[][2] = {
  /* Addr      allmodes  */
- {0x00004040, 0x08253e5e},
+ {0x00004040, 0x0825365e},
  {0x00004040, 0x0008003b},
  {0x00004044, 0x00000000},
 };
 
 static const u32 ar9300PciePhy_clkreq_disable_L1_2p2[][2] = {
  /* Addr      allmodes  */
- {0x00004040, 0x08213e5e},
+ {0x00004040, 0x0821365e},
  {0x00004040, 0x0008003b},
  {0x00004044, 0x00000000},
 };
 
+static const u32 ar9300_2p2_baseband_core_txfir_coeff_japan_2484[][2] = {
+ /* Addr      allmodes  */
+ {0x0000a398, 0x00000000},
+ {0x0000a39c, 0x6f7f0301},
+ {0x0000a3a0, 0xca9228ee},
+};
+
+static const u32 ar9300_2p2_baseband_postamble_dfs_channel[][3] = {
+ /* Addr      5G          2G        */
+ {0x00009824, 0x5ac668d0, 0x5ac668d0},
+ {0x00009e0c, 0x6d4000e2, 0x6d4000e2},
+ {0x00009e14, 0x37b9625e, 0x37b9625e},
+};
+
 #endif /* INITVALS_9003_2P2_H */
diff --git a/drivers/net/wireless/ath/ath9k/ar9003_buffalo_initvals.h b/drivers/net/wireless/ath/ath9k/ar9003_buffalo_initvals.h
new file mode 100644
index 0000000..59cf738
--- /dev/null
+++ b/drivers/net/wireless/ath/ath9k/ar9003_buffalo_initvals.h
@@ -0,0 +1,126 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros Inc.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef INITVALS_9003_BUFFALO_H
+#define INITVALS_9003_BUFFALO_H
+
+static const u32 ar9300Modes_high_power_tx_gain_table_buffalo[][5] = {
+ /* Addr      5G_HT20     5G_HT40     2G_HT40     2G_HT20   */
+ {0x0000a2dc, 0x0380c7fc, 0x0380c7fc, 0x03aaa352, 0x03aaa352},
+ {0x0000a2e0, 0x0000f800, 0x0000f800, 0x03ccc584, 0x03ccc584},
+ {0x0000a2e4, 0x03ff0000, 0x03ff0000, 0x03f0f800, 0x03f0f800},
+ {0x0000a2e8, 0x00000000, 0x00000000, 0x03ff0000, 0x03ff0000},
+ {0x0000a410, 0x000050d8, 0x000050d8, 0x000050d9, 0x000050d9},
+ {0x0000a500, 0x00002220, 0x00002220, 0x00000000, 0x00000000},
+ {0x0000a504, 0x04002222, 0x04002222, 0x04000002, 0x04000002},
+ {0x0000a508, 0x09002421, 0x09002421, 0x08000004, 0x08000004},
+ {0x0000a50c, 0x0d002621, 0x0d002621, 0x0b000200, 0x0b000200},
+ {0x0000a510, 0x13004620, 0x13004620, 0x0f000202, 0x0f000202},
+ {0x0000a514, 0x19004a20, 0x19004a20, 0x11000400, 0x11000400},
+ {0x0000a518, 0x1d004e20, 0x1d004e20, 0x15000402, 0x15000402},
+ {0x0000a51c, 0x21005420, 0x21005420, 0x19000404, 0x19000404},
+ {0x0000a520, 0x26005e20, 0x26005e20, 0x1b000603, 0x1b000603},
+ {0x0000a524, 0x2b005e40, 0x2b005e40, 0x1f000a02, 0x1f000a02},
+ {0x0000a528, 0x2f005e42, 0x2f005e42, 0x23000a04, 0x23000a04},
+ {0x0000a52c, 0x33005e44, 0x33005e44, 0x26000a20, 0x26000a20},
+ {0x0000a530, 0x38005e65, 0x38005e65, 0x2a000e20, 0x2a000e20},
+ {0x0000a534, 0x3c005e69, 0x3c005e69, 0x2e000e22, 0x2e000e22},
+ {0x0000a538, 0x40005e6b, 0x40005e6b, 0x31000e24, 0x31000e24},
+ {0x0000a53c, 0x44005e6d, 0x44005e6d, 0x34001640, 0x34001640},
+ {0x0000a540, 0x49005e72, 0x49005e72, 0x38001660, 0x38001660},
+ {0x0000a544, 0x4e005eb2, 0x4e005eb2, 0x3b001861, 0x3b001861},
+ {0x0000a548, 0x53005f12, 0x53005f12, 0x3e001a81, 0x3e001a81},
+ {0x0000a54c, 0x59025eb2, 0x59025eb2, 0x42001a83, 0x42001a83},
+ {0x0000a550, 0x5e025f12, 0x5e025f12, 0x44001c84, 0x44001c84},
+ {0x0000a554, 0x61027f12, 0x61027f12, 0x48001ce3, 0x48001ce3},
+ {0x0000a558, 0x6702bf12, 0x6702bf12, 0x4c001ce5, 0x4c001ce5},
+ {0x0000a55c, 0x6b02bf14, 0x6b02bf14, 0x50001ce9, 0x50001ce9},
+ {0x0000a560, 0x6f02bf16, 0x6f02bf16, 0x54001ceb, 0x54001ceb},
+ {0x0000a564, 0x6f02bf16, 0x6f02bf16, 0x56001eec, 0x56001eec},
+ {0x0000a568, 0x6f02bf16, 0x6f02bf16, 0x56001eec, 0x56001eec},
+ {0x0000a56c, 0x6f02bf16, 0x6f02bf16, 0x56001eec, 0x56001eec},
+ {0x0000a570, 0x6f02bf16, 0x6f02bf16, 0x56001eec, 0x56001eec},
+ {0x0000a574, 0x6f02bf16, 0x6f02bf16, 0x56001eec, 0x56001eec},
+ {0x0000a578, 0x6f02bf16, 0x6f02bf16, 0x56001eec, 0x56001eec},
+ {0x0000a57c, 0x6f02bf16, 0x6f02bf16, 0x56001eec, 0x56001eec},
+ {0x0000a580, 0x00802220, 0x00802220, 0x00800000, 0x00800000},
+ {0x0000a584, 0x04802222, 0x04802222, 0x04800002, 0x04800002},
+ {0x0000a588, 0x09802421, 0x09802421, 0x08800004, 0x08800004},
+ {0x0000a58c, 0x0d802621, 0x0d802621, 0x0b800200, 0x0b800200},
+ {0x0000a590, 0x13804620, 0x13804620, 0x0f800202, 0x0f800202},
+ {0x0000a594, 0x19804a20, 0x19804a20, 0x11800400, 0x11800400},
+ {0x0000a598, 0x1d804e20, 0x1d804e20, 0x15800402, 0x15800402},
+ {0x0000a59c, 0x21805420, 0x21805420, 0x19800404, 0x19800404},
+ {0x0000a5a0, 0x26805e20, 0x26805e20, 0x1b800603, 0x1b800603},
+ {0x0000a5a4, 0x2b805e40, 0x2b805e40, 0x1f800a02, 0x1f800a02},
+ {0x0000a5a8, 0x2f805e42, 0x2f805e42, 0x23800a04, 0x23800a04},
+ {0x0000a5ac, 0x33805e44, 0x33805e44, 0x26800a20, 0x26800a20},
+ {0x0000a5b0, 0x38805e65, 0x38805e65, 0x2a800e20, 0x2a800e20},
+ {0x0000a5b4, 0x3c805e69, 0x3c805e69, 0x2e800e22, 0x2e800e22},
+ {0x0000a5b8, 0x40805e6b, 0x40805e6b, 0x31800e24, 0x31800e24},
+ {0x0000a5bc, 0x44805e6d, 0x44805e6d, 0x34801640, 0x34801640},
+ {0x0000a5c0, 0x49805e72, 0x49805e72, 0x38801660, 0x38801660},
+ {0x0000a5c4, 0x4e805eb2, 0x4e805eb2, 0x3b801861, 0x3b801861},
+ {0x0000a5c8, 0x53805f12, 0x53805f12, 0x3e801a81, 0x3e801a81},
+ {0x0000a5cc, 0x59825eb2, 0x59825eb2, 0x42801a83, 0x42801a83},
+ {0x0000a5d0, 0x5e825f12, 0x5e825f12, 0x44801c84, 0x44801c84},
+ {0x0000a5d4, 0x61827f12, 0x61827f12, 0x48801ce3, 0x48801ce3},
+ {0x0000a5d8, 0x6782bf12, 0x6782bf12, 0x4c801ce5, 0x4c801ce5},
+ {0x0000a5dc, 0x6b82bf14, 0x6b82bf14, 0x50801ce9, 0x50801ce9},
+ {0x0000a5e0, 0x6f82bf16, 0x6f82bf16, 0x54801ceb, 0x54801ceb},
+ {0x0000a5e4, 0x6f82bf16, 0x6f82bf16, 0x56801eec, 0x56801eec},
+ {0x0000a5e8, 0x6f82bf16, 0x6f82bf16, 0x56801eec, 0x56801eec},
+ {0x0000a5ec, 0x6f82bf16, 0x6f82bf16, 0x56801eec, 0x56801eec},
+ {0x0000a5f0, 0x6f82bf16, 0x6f82bf16, 0x56801eec, 0x56801eec},
+ {0x0000a5f4, 0x6f82bf16, 0x6f82bf16, 0x56801eec, 0x56801eec},
+ {0x0000a5f8, 0x6f82bf16, 0x6f82bf16, 0x56801eec, 0x56801eec},
+ {0x0000a5fc, 0x6f82bf16, 0x6f82bf16, 0x56801eec, 0x56801eec},
+ {0x0000a600, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
+ {0x0000a604, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
+ {0x0000a608, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
+ {0x0000a60c, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
+ {0x0000a610, 0x00804000, 0x00804000, 0x00000000, 0x00000000},
+ {0x0000a614, 0x00804201, 0x00804201, 0x01404000, 0x01404000},
+ {0x0000a618, 0x0280c802, 0x0280c802, 0x01404501, 0x01404501},
+ {0x0000a61c, 0x0280ca03, 0x0280ca03, 0x02008501, 0x02008501},
+ {0x0000a620, 0x04c15104, 0x04c15104, 0x0280ca03, 0x0280ca03},
+ {0x0000a624, 0x04c15305, 0x04c15305, 0x03010c04, 0x03010c04},
+ {0x0000a628, 0x04c15305, 0x04c15305, 0x04014c04, 0x04014c04},
+ {0x0000a62c, 0x04c15305, 0x04c15305, 0x04015005, 0x04015005},
+ {0x0000a630, 0x04c15305, 0x04c15305, 0x04015005, 0x04015005},
+ {0x0000a634, 0x04c15305, 0x04c15305, 0x04015005, 0x04015005},
+ {0x0000a638, 0x04c15305, 0x04c15305, 0x04015005, 0x04015005},
+ {0x0000a63c, 0x04c15305, 0x04c15305, 0x04015005, 0x04015005},
+ {0x0000b2dc, 0x0380c7fc, 0x0380c7fc, 0x03aaa352, 0x03aaa352},
+ {0x0000b2e0, 0x0000f800, 0x0000f800, 0x03ccc584, 0x03ccc584},
+ {0x0000b2e4, 0x03ff0000, 0x03ff0000, 0x03f0f800, 0x03f0f800},
+ {0x0000b2e8, 0x00000000, 0x00000000, 0x03ff0000, 0x03ff0000},
+ {0x0000c2dc, 0x0380c7fc, 0x0380c7fc, 0x03aaa352, 0x03aaa352},
+ {0x0000c2e0, 0x0000f800, 0x0000f800, 0x03ccc584, 0x03ccc584},
+ {0x0000c2e4, 0x03ff0000, 0x03ff0000, 0x03f0f800, 0x03f0f800},
+ {0x0000c2e8, 0x00000000, 0x00000000, 0x03ff0000, 0x03ff0000},
+ {0x00016044, 0x012492d4, 0x012492d4, 0x012492d4, 0x012492d4},
+ {0x00016048, 0x66480001, 0x66480001, 0x66480001, 0x66480001},
+ {0x00016068, 0x6db6db6c, 0x6db6db6c, 0x6db6db6c, 0x6db6db6c},
+ {0x00016444, 0x012492d4, 0x012492d4, 0x012492d4, 0x012492d4},
+ {0x00016448, 0x66480001, 0x66480001, 0x66480001, 0x66480001},
+ {0x00016468, 0x6db6db6c, 0x6db6db6c, 0x6db6db6c, 0x6db6db6c},
+ {0x00016844, 0x012492d4, 0x012492d4, 0x012492d4, 0x012492d4},
+ {0x00016848, 0x66480001, 0x66480001, 0x66480001, 0x66480001},
+ {0x00016868, 0x6db6db6c, 0x6db6db6c, 0x6db6db6c, 0x6db6db6c},
+};
+
+#endif /* INITVALS_9003_BUFFALO_H */
diff --git a/drivers/net/wireless/ath/ath9k/ar9003_calib.c b/drivers/net/wireless/ath/ath9k/ar9003_calib.c
index 6988e1d..ac8301e 100644
--- a/drivers/net/wireless/ath/ath9k/ar9003_calib.c
+++ b/drivers/net/wireless/ath/ath9k/ar9003_calib.c
@@ -23,10 +23,11 @@
 #define MAX_MEASUREMENT MAX_IQCAL_MEASUREMENT
 #define MAX_MAG_DELTA 11
 #define MAX_PHS_DELTA 10
+#define MAXIQCAL        3
 
 struct coeff {
- int mag_coeff[AR9300_MAX_CHAINS][MAX_MEASUREMENT];
- int phs_coeff[AR9300_MAX_CHAINS][MAX_MEASUREMENT];
+ int mag_coeff[AR9300_MAX_CHAINS][MAX_MEASUREMENT][MAXIQCAL];
+ int phs_coeff[AR9300_MAX_CHAINS][MAX_MEASUREMENT][MAXIQCAL];
  int iqc_coeff[2];
 };
 
@@ -326,6 +327,224 @@ static void ar9003_hw_init_cal_settings(struct ath_hw *ah)
  ah->supp_cals = IQ_MISMATCH_CAL;
 }
 
+#define OFF_UPPER_LT 24
+#define OFF_LOWER_LT 7
+
+static bool ar9003_hw_dynamic_osdac_selection(struct ath_hw *ah,
+           bool txiqcal_done)
+{
+ struct ath_common *common = ath9k_hw_common(ah);
+ int ch0_done, osdac_ch0, dc_off_ch0_i1, dc_off_ch0_q1, dc_off_ch0_i2,
+  dc_off_ch0_q2, dc_off_ch0_i3, dc_off_ch0_q3;
+ int ch1_done, osdac_ch1, dc_off_ch1_i1, dc_off_ch1_q1, dc_off_ch1_i2,
+  dc_off_ch1_q2, dc_off_ch1_i3, dc_off_ch1_q3;
+ int ch2_done, osdac_ch2, dc_off_ch2_i1, dc_off_ch2_q1, dc_off_ch2_i2,
+  dc_off_ch2_q2, dc_off_ch2_i3, dc_off_ch2_q3;
+ bool status;
+ u32 temp, val;
+
+ /*
+  * Clear offset and IQ calibration, run AGC cal.
+  */
+ REG_CLR_BIT(ah, AR_PHY_AGC_CONTROL,
+      AR_PHY_AGC_CONTROL_OFFSET_CAL);
+ REG_CLR_BIT(ah, AR_PHY_TX_IQCAL_CONTROL_0,
+      AR_PHY_TX_IQCAL_CONTROL_0_ENABLE_TXIQ_CAL);
+ REG_WRITE(ah, AR_PHY_AGC_CONTROL,
+    REG_READ(ah, AR_PHY_AGC_CONTROL) | AR_PHY_AGC_CONTROL_CAL);
+
+ status = ath9k_hw_wait(ah, AR_PHY_AGC_CONTROL,
+          AR_PHY_AGC_CONTROL_CAL,
+          0, AH_WAIT_TIMEOUT);
+ if (!status) {
+  ath_dbg(common, CALIBRATE,
+   "AGC cal without offset cal failed to complete in 1ms");
+  return false;
+ }
+
+ /*
+  * Allow only offset calibration and disable the others
+  * (Carrier Leak calibration, TX Filter calibration and
+  *  Peak Detector offset calibration).
+  */
+ REG_SET_BIT(ah, AR_PHY_AGC_CONTROL,
+      AR_PHY_AGC_CONTROL_OFFSET_CAL);
+ REG_CLR_BIT(ah, AR_PHY_CL_CAL_CTL,
+      AR_PHY_CL_CAL_ENABLE);
+ REG_CLR_BIT(ah, AR_PHY_AGC_CONTROL,
+      AR_PHY_AGC_CONTROL_FLTR_CAL);
+ REG_CLR_BIT(ah, AR_PHY_AGC_CONTROL,
+      AR_PHY_AGC_CONTROL_PKDET_CAL);
+
+ ch0_done = 0;
+ ch1_done = 0;
+ ch2_done = 0;
+
+ while ((ch0_done == 0) || (ch1_done == 0) || (ch2_done == 0)) {
+  osdac_ch0 = (REG_READ(ah, AR_PHY_65NM_CH0_BB1) >> 30) & 0x3;
+  osdac_ch1 = (REG_READ(ah, AR_PHY_65NM_CH1_BB1) >> 30) & 0x3;
+  osdac_ch2 = (REG_READ(ah, AR_PHY_65NM_CH2_BB1) >> 30) & 0x3;
+
+  REG_SET_BIT(ah, AR_PHY_ACTIVE, AR_PHY_ACTIVE_EN);
+
+  REG_WRITE(ah, AR_PHY_AGC_CONTROL,
+     REG_READ(ah, AR_PHY_AGC_CONTROL) | AR_PHY_AGC_CONTROL_CAL);
+
+  status = ath9k_hw_wait(ah, AR_PHY_AGC_CONTROL,
+           AR_PHY_AGC_CONTROL_CAL,
+           0, AH_WAIT_TIMEOUT);
+  if (!status) {
+   ath_dbg(common, CALIBRATE,
+    "DC offset cal failed to complete in 1ms");
+   return false;
+  }
+
+  REG_CLR_BIT(ah, AR_PHY_ACTIVE, AR_PHY_ACTIVE_EN);
+
+  /*
+   * High gain.
+   */
+  REG_WRITE(ah, AR_PHY_65NM_CH0_BB3,
+     ((REG_READ(ah, AR_PHY_65NM_CH0_BB3) & 0xfffffcff) | (1 << 8)));
+  REG_WRITE(ah, AR_PHY_65NM_CH1_BB3,
+     ((REG_READ(ah, AR_PHY_65NM_CH1_BB3) & 0xfffffcff) | (1 << 8)));
+  REG_WRITE(ah, AR_PHY_65NM_CH2_BB3,
+     ((REG_READ(ah, AR_PHY_65NM_CH2_BB3) & 0xfffffcff) | (1 << 8)));
+
+  temp = REG_READ(ah, AR_PHY_65NM_CH0_BB3);
+  dc_off_ch0_i1 = (temp >> 26) & 0x1f;
+  dc_off_ch0_q1 = (temp >> 21) & 0x1f;
+
+  temp = REG_READ(ah, AR_PHY_65NM_CH1_BB3);
+  dc_off_ch1_i1 = (temp >> 26) & 0x1f;
+  dc_off_ch1_q1 = (temp >> 21) & 0x1f;
+
+  temp = REG_READ(ah, AR_PHY_65NM_CH2_BB3);
+  dc_off_ch2_i1 = (temp >> 26) & 0x1f;
+  dc_off_ch2_q1 = (temp >> 21) & 0x1f;
+
+  /*
+   * Low gain.
+   */
+  REG_WRITE(ah, AR_PHY_65NM_CH0_BB3,
+     ((REG_READ(ah, AR_PHY_65NM_CH0_BB3) & 0xfffffcff) | (2 << 8)));
+  REG_WRITE(ah, AR_PHY_65NM_CH1_BB3,
+     ((REG_READ(ah, AR_PHY_65NM_CH1_BB3) & 0xfffffcff) | (2 << 8)));
+  REG_WRITE(ah, AR_PHY_65NM_CH2_BB3,
+     ((REG_READ(ah, AR_PHY_65NM_CH2_BB3) & 0xfffffcff) | (2 << 8)));
+
+  temp = REG_READ(ah, AR_PHY_65NM_CH0_BB3);
+  dc_off_ch0_i2 = (temp >> 26) & 0x1f;
+  dc_off_ch0_q2 = (temp >> 21) & 0x1f;
+
+  temp = REG_READ(ah, AR_PHY_65NM_CH1_BB3);
+  dc_off_ch1_i2 = (temp >> 26) & 0x1f;
+  dc_off_ch1_q2 = (temp >> 21) & 0x1f;
+
+  temp = REG_READ(ah, AR_PHY_65NM_CH2_BB3);
+  dc_off_ch2_i2 = (temp >> 26) & 0x1f;
+  dc_off_ch2_q2 = (temp >> 21) & 0x1f;
+
+  /*
+   * Loopback.
+   */
+  REG_WRITE(ah, AR_PHY_65NM_CH0_BB3,
+     ((REG_READ(ah, AR_PHY_65NM_CH0_BB3) & 0xfffffcff) | (3 << 8)));
+  REG_WRITE(ah, AR_PHY_65NM_CH1_BB3,
+     ((REG_READ(ah, AR_PHY_65NM_CH1_BB3) & 0xfffffcff) | (3 << 8)));
+  REG_WRITE(ah, AR_PHY_65NM_CH2_BB3,
+     ((REG_READ(ah, AR_PHY_65NM_CH2_BB3) & 0xfffffcff) | (3 << 8)));
+
+  temp = REG_READ(ah, AR_PHY_65NM_CH0_BB3);
+  dc_off_ch0_i3 = (temp >> 26) & 0x1f;
+  dc_off_ch0_q3 = (temp >> 21) & 0x1f;
+
+  temp = REG_READ(ah, AR_PHY_65NM_CH1_BB3);
+  dc_off_ch1_i3 = (temp >> 26) & 0x1f;
+  dc_off_ch1_q3 = (temp >> 21) & 0x1f;
+
+  temp = REG_READ(ah, AR_PHY_65NM_CH2_BB3);
+  dc_off_ch2_i3 = (temp >> 26) & 0x1f;
+  dc_off_ch2_q3 = (temp >> 21) & 0x1f;
+
+  if ((dc_off_ch0_i1 > OFF_UPPER_LT) || (dc_off_ch0_i1 < OFF_LOWER_LT) ||
+      (dc_off_ch0_i2 > OFF_UPPER_LT) || (dc_off_ch0_i2 < OFF_LOWER_LT) ||
+      (dc_off_ch0_i3 > OFF_UPPER_LT) || (dc_off_ch0_i3 < OFF_LOWER_LT) ||
+      (dc_off_ch0_q1 > OFF_UPPER_LT) || (dc_off_ch0_q1 < OFF_LOWER_LT) ||
+      (dc_off_ch0_q2 > OFF_UPPER_LT) || (dc_off_ch0_q2 < OFF_LOWER_LT) ||
+      (dc_off_ch0_q3 > OFF_UPPER_LT) || (dc_off_ch0_q3 < OFF_LOWER_LT)) {
+   if (osdac_ch0 == 3) {
+    ch0_done = 1;
+   } else {
+    osdac_ch0++;
+
+    val = REG_READ(ah, AR_PHY_65NM_CH0_BB1) & 0x3fffffff;
+    val |= (osdac_ch0 << 30);
+    REG_WRITE(ah, AR_PHY_65NM_CH0_BB1, val);
+
+    ch0_done = 0;
+   }
+  } else {
+   ch0_done = 1;
+  }
+
+  if ((dc_off_ch1_i1 > OFF_UPPER_LT) || (dc_off_ch1_i1 < OFF_LOWER_LT) ||
+      (dc_off_ch1_i2 > OFF_UPPER_LT) || (dc_off_ch1_i2 < OFF_LOWER_LT) ||
+      (dc_off_ch1_i3 > OFF_UPPER_LT) || (dc_off_ch1_i3 < OFF_LOWER_LT) ||
+      (dc_off_ch1_q1 > OFF_UPPER_LT) || (dc_off_ch1_q1 < OFF_LOWER_LT) ||
+      (dc_off_ch1_q2 > OFF_UPPER_LT) || (dc_off_ch1_q2 < OFF_LOWER_LT) ||
+      (dc_off_ch1_q3 > OFF_UPPER_LT) || (dc_off_ch1_q3 < OFF_LOWER_LT)) {
+   if (osdac_ch1 == 3) {
+    ch1_done = 1;
+   } else {
+    osdac_ch1++;
+
+    val = REG_READ(ah, AR_PHY_65NM_CH1_BB1) & 0x3fffffff;
+    val |= (osdac_ch1 << 30);
+    REG_WRITE(ah, AR_PHY_65NM_CH1_BB1, val);
+
+    ch1_done = 0;
+   }
+  } else {
+   ch1_done = 1;
+  }
+
+  if ((dc_off_ch2_i1 > OFF_UPPER_LT) || (dc_off_ch2_i1 < OFF_LOWER_LT) ||
+      (dc_off_ch2_i2 > OFF_UPPER_LT) || (dc_off_ch2_i2 < OFF_LOWER_LT) ||
+      (dc_off_ch2_i3 > OFF_UPPER_LT) || (dc_off_ch2_i3 < OFF_LOWER_LT) ||
+      (dc_off_ch2_q1 > OFF_UPPER_LT) || (dc_off_ch2_q1 < OFF_LOWER_LT) ||
+      (dc_off_ch2_q2 > OFF_UPPER_LT) || (dc_off_ch2_q2 < OFF_LOWER_LT) ||
+      (dc_off_ch2_q3 > OFF_UPPER_LT) || (dc_off_ch2_q3 < OFF_LOWER_LT)) {
+   if (osdac_ch2 == 3) {
+    ch2_done = 1;
+   } else {
+    osdac_ch2++;
+
+    val = REG_READ(ah, AR_PHY_65NM_CH2_BB1) & 0x3fffffff;
+    val |= (osdac_ch2 << 30);
+    REG_WRITE(ah, AR_PHY_65NM_CH2_BB1, val);
+
+    ch2_done = 0;
+   }
+  } else {
+   ch2_done = 1;
+  }
+ }
+
+ REG_CLR_BIT(ah, AR_PHY_AGC_CONTROL,
+      AR_PHY_AGC_CONTROL_OFFSET_CAL);
+ REG_SET_BIT(ah, AR_PHY_ACTIVE, AR_PHY_ACTIVE_EN);
+
+ /*
+  * We don't need to check txiqcal_done here since it is always
+  * set for AR9550.
+  */
+ REG_SET_BIT(ah, AR_PHY_TX_IQCAL_CONTROL_0,
+      AR_PHY_TX_IQCAL_CONTROL_0_ENABLE_TXIQ_CAL);
+
+ return true;
+}
+
 /*
  * solve 4x4 linear equation used in loopback iq cal.
  */
@@ -347,7 +566,7 @@ static bool ar9003_hw_solve_iq_cal(struct ath_hw *ah,
  const s32 result_shift = 1 << 15;
  struct ath_common *common = ath9k_hw_common(ah);
 
- f2 = (f1 * f1 + f3 * f3) / result_shift;
+ f2 = ((f1 >> 3) * (f1 >> 3) + (f3 >> 3) * (f3 >> 3)) >> 9;
 
  if (!f2) {
   ath_dbg(common, CALIBRATE, "Divide by 0\n");
@@ -437,9 +656,6 @@ static bool ar9003_hw_calc_iq_corr(struct ath_hw *ah,
  if (i2_m_q2_a0_d1 > 0x800)
   i2_m_q2_a0_d1 = -((0xfff - i2_m_q2_a0_d1) + 1);
 
- if (i2_p_q2_a0_d1 > 0x800)
-  i2_p_q2_a0_d1 = -((0xfff - i2_p_q2_a0_d1) + 1);
-
  if (iq_corr_a0_d1 > 0x800)
   iq_corr_a0_d1 = -((0xfff - iq_corr_a0_d1) + 1);
 
@@ -482,6 +698,19 @@ static bool ar9003_hw_calc_iq_corr(struct ath_hw *ah,
   return false;
  }
 
+ if ((i2_p_q2_a0_d0 < 1024) || (i2_p_q2_a0_d0 > 2047) ||
+            (i2_p_q2_a1_d0 < 0) || (i2_p_q2_a1_d1 < 0) ||
+            (i2_p_q2_a0_d0 <= i2_m_q2_a0_d0) ||
+            (i2_p_q2_a0_d0 <= iq_corr_a0_d0) ||
+            (i2_p_q2_a0_d1 <= i2_m_q2_a0_d1) ||
+            (i2_p_q2_a0_d1 <= iq_corr_a0_d1) ||
+            (i2_p_q2_a1_d0 <= i2_m_q2_a1_d0) ||
+            (i2_p_q2_a1_d0 <= iq_corr_a1_d0) ||
+            (i2_p_q2_a1_d1 <= i2_m_q2_a1_d1) ||
+            (i2_p_q2_a1_d1 <= iq_corr_a1_d1)) {
+  return false;
+ }
+
  mag_a0_d0 = (i2_m_q2_a0_d0 * res_scale) / i2_p_q2_a0_d0;
  phs_a0_d0 = (iq_corr_a0_d0 * res_scale) / i2_p_q2_a0_d0;
 
@@ -569,7 +798,7 @@ static bool ar9003_hw_calc_iq_corr(struct ath_hw *ah,
  if (q_q_coff > 63)
   q_q_coff = 63;
 
- iqc_coeff[0] = (q_q_coff * 128) + q_i_coff;
+ iqc_coeff[0] = (q_q_coff * 128) + (0x7f & q_i_coff);
 
  ath_dbg(common, CALIBRATE, "tx chain %d: iq corr coeff=%x\n",
   chain_idx, iqc_coeff[0]);
@@ -600,7 +829,7 @@ static bool ar9003_hw_calc_iq_corr(struct ath_hw *ah,
  if (q_q_coff > 63)
   q_q_coff = 63;
 
- iqc_coeff[1] = (q_q_coff * 128) + q_i_coff;
+ iqc_coeff[1] = (q_q_coff * 128) + (0x7f & q_i_coff);
 
  ath_dbg(common, CALIBRATE, "rx chain %d: iq corr coeff=%x\n",
   chain_idx, iqc_coeff[1]);
@@ -608,7 +837,8 @@ static bool ar9003_hw_calc_iq_corr(struct ath_hw *ah,
  return true;
 }
 
-static void ar9003_hw_detect_outlier(int *mp_coeff, int nmeasurement,
+static void ar9003_hw_detect_outlier(int mp_coeff[][MAXIQCAL],
+         int nmeasurement,
          int max_delta)
 {
  int mp_max = -64, max_idx = 0;
@@ -617,20 +847,20 @@ static void ar9003_hw_detect_outlier(int *mp_coeff, int nmeasurement,
 
  /* find min/max mismatch across all calibrated gains */
  for (i = 0; i < nmeasurement; i++) {
-  if (mp_coeff[i] > mp_max) {
-   mp_max = mp_coeff[i];
+  if (mp_coeff[i][0] > mp_max) {
+   mp_max = mp_coeff[i][0];
    max_idx = i;
-  } else if (mp_coeff[i] < mp_min) {
-   mp_min = mp_coeff[i];
+  } else if (mp_coeff[i][0] < mp_min) {
+   mp_min = mp_coeff[i][0];
    min_idx = i;
   }
  }
 
  /* find average (exclude max abs value) */
  for (i = 0; i < nmeasurement; i++) {
-  if ((abs(mp_coeff[i]) < abs(mp_max)) ||
-      (abs(mp_coeff[i]) < abs(mp_min))) {
-   mp_avg += mp_coeff[i];
+  if ((abs(mp_coeff[i][0]) < abs(mp_max)) ||
+      (abs(mp_coeff[i][0]) < abs(mp_min))) {
+   mp_avg += mp_coeff[i][0];
    mp_count++;
   }
  }
@@ -642,7 +872,7 @@ static void ar9003_hw_detect_outlier(int *mp_coeff, int nmeasurement,
  if (mp_count)
   mp_avg /= mp_count;
  else
-  mp_avg = mp_coeff[nmeasurement - 1];
+  mp_avg = mp_coeff[nmeasurement - 1][0];
 
  /* detect outlier */
  if (abs(mp_max - mp_min) > max_delta) {
@@ -651,15 +881,16 @@ static void ar9003_hw_detect_outlier(int *mp_coeff, int nmeasurement,
   else
    outlier_idx = min_idx;
 
-  mp_coeff[outlier_idx] = mp_avg;
+  mp_coeff[outlier_idx][0] = mp_avg;
  }
 }
 
-static void ar9003_hw_tx_iqcal_load_avg_2_passes(struct ath_hw *ah,
-       struct coeff *coeff,
-       bool is_reusable)
+static void ar9003_hw_tx_iq_cal_outlier_detection(struct ath_hw *ah,
+        struct coeff *coeff,
+        bool is_reusable)
 {
  int i, im, nmeasurement;
+ int magnitude, phase;
  u32 tx_corr_coeff[MAX_MEASUREMENT][AR9300_MAX_CHAINS];
  struct ath9k_hw_cal_data *caldata = ah->caldata;
 
@@ -689,21 +920,30 @@ static void ar9003_hw_tx_iqcal_load_avg_2_passes(struct ath_hw *ah,
   if (nmeasurement > MAX_MEASUREMENT)
    nmeasurement = MAX_MEASUREMENT;
 
-  /* detect outlier only if nmeasurement > 1 */
-  if (nmeasurement > 1) {
-   /* Detect magnitude outlier */
-   ar9003_hw_detect_outlier(coeff->mag_coeff[i],
-     nmeasurement, MAX_MAG_DELTA);
-
-   /* Detect phase outlier */
-   ar9003_hw_detect_outlier(coeff->phs_coeff[i],
-     nmeasurement, MAX_PHS_DELTA);
+  /*
+   * Skip normal outlier detection for AR9550.
+   */
+  if (!AR_SREV_9550(ah)) {
+   /* detect outlier only if nmeasurement > 1 */
+   if (nmeasurement > 1) {
+    /* Detect magnitude outlier */
+    ar9003_hw_detect_outlier(coeff->mag_coeff[i],
+        nmeasurement,
+        MAX_MAG_DELTA);
+
+    /* Detect phase outlier */
+    ar9003_hw_detect_outlier(coeff->phs_coeff[i],
+        nmeasurement,
+        MAX_PHS_DELTA);
+   }
   }
 
   for (im = 0; im < nmeasurement; im++) {
+   magnitude = coeff->mag_coeff[i][im][0];
+   phase = coeff->phs_coeff[i][im][0];
 
-   coeff->iqc_coeff[0] = (coeff->mag_coeff[i][im] & 0x7f) |
-    ((coeff->phs_coeff[i][im] & 0x7f) << 7);
+   coeff->iqc_coeff[0] =
+    (phase & 0x7f) | ((magnitude & 0x7f) << 7);
 
    if ((im % 2) == 0)
     REG_RMW_FIELD(ah, tx_corr_coeff[im][i],
@@ -727,8 +967,12 @@ static void ar9003_hw_tx_iqcal_load_avg_2_passes(struct ath_hw *ah,
  REG_RMW_FIELD(ah, AR_PHY_RX_IQCAL_CORR_B0,
         AR_PHY_RX_IQCAL_CORR_B0_LOOPBACK_IQCORR_EN, 0x1);
 
- if (caldata)
-  caldata->done_txiqcal_once = is_reusable;
+ if (caldata) {
+  if (is_reusable)
+   set_bit(TXIQCAL_DONE, &caldata->cal_flags);
+  else
+   clear_bit(TXIQCAL_DONE, &caldata->cal_flags);
+ }
 
  return;
 }
@@ -756,7 +1000,63 @@ static bool ar9003_hw_tx_iq_cal_run(struct ath_hw *ah)
  return true;
 }
 
-static void ar9003_hw_tx_iq_cal_post_proc(struct ath_hw *ah, bool is_reusable)
+static void __ar955x_tx_iq_cal_sort(struct ath_hw *ah,
+        struct coeff *coeff,
+        int i, int nmeasurement)
+{
+ struct ath_common *common = ath9k_hw_common(ah);
+ int im, ix, iy, temp;
+
+ for (im = 0; im < nmeasurement; im++) {
+  for (ix = 0; ix < MAXIQCAL - 1; ix++) {
+   for (iy = ix + 1; iy <= MAXIQCAL - 1; iy++) {
+    if (coeff->mag_coeff[i][im][iy] <
+        coeff->mag_coeff[i][im][ix]) {
+     temp = coeff->mag_coeff[i][im][ix];
+     coeff->mag_coeff[i][im][ix] =
+      coeff->mag_coeff[i][im][iy];
+     coeff->mag_coeff[i][im][iy] = temp;
+    }
+    if (coeff->phs_coeff[i][im][iy] <
+        coeff->phs_coeff[i][im][ix]) {
+     temp = coeff->phs_coeff[i][im][ix];
+     coeff->phs_coeff[i][im][ix] =
+      coeff->phs_coeff[i][im][iy];
+     coeff->phs_coeff[i][im][iy] = temp;
+    }
+   }
+  }
+  coeff->mag_coeff[i][im][0] = coeff->mag_coeff[i][im][MAXIQCAL / 2];
+  coeff->phs_coeff[i][im][0] = coeff->phs_coeff[i][im][MAXIQCAL / 2];
+
+  ath_dbg(common, CALIBRATE,
+   "IQCAL: Median [ch%d][gain%d]: mag = %d phase = %d\n",
+   i, im,
+   coeff->mag_coeff[i][im][0],
+   coeff->phs_coeff[i][im][0]);
+ }
+}
+
+static bool ar955x_tx_iq_cal_median(struct ath_hw *ah,
+        struct coeff *coeff,
+        int iqcal_idx,
+        int nmeasurement)
+{
+ int i;
+
+ if ((iqcal_idx + 1) != MAXIQCAL)
+  return false;
+
+ for (i = 0; i < AR9300_MAX_CHAINS; i++) {
+  __ar955x_tx_iq_cal_sort(ah, coeff, i, nmeasurement);
+ }
+
+ return true;
+}
+
+static void ar9003_hw_tx_iq_cal_post_proc(struct ath_hw *ah,
+       int iqcal_idx,
+       bool is_reusable)
 {
  struct ath_common *common = ath9k_hw_common(ah);
  const u32 txiqcal_status[AR9300_MAX_CHAINS] = {
@@ -769,10 +1069,11 @@ static void ar9003_hw_tx_iq_cal_post_proc(struct ath_hw *ah, bool is_reusable)
   AR_PHY_CHAN_INFO_TAB_1,
   AR_PHY_CHAN_INFO_TAB_2,
  };
- struct coeff coeff;
+ static struct coeff coeff;
  s32 iq_res[6];
  int i, im, j;
- int nmeasurement;
+ int nmeasurement = 0;
+ bool outlier_detect = true;
 
  for (i = 0; i < AR9300_MAX_CHAINS; i++) {
   if (!(ah->txchainmask & (1 << i)))
@@ -830,17 +1131,23 @@ static void ar9003_hw_tx_iq_cal_post_proc(struct ath_hw *ah, bool is_reusable)
     goto tx_iqcal_fail;
    }
 
-   coeff.mag_coeff[i][im] = coeff.iqc_coeff[0] & 0x7f;
-   coeff.phs_coeff[i][im] =
+   coeff.phs_coeff[i][im][iqcal_idx] =
+    coeff.iqc_coeff[0] & 0x7f;
+   coeff.mag_coeff[i][im][iqcal_idx] =
     (coeff.iqc_coeff[0] >> 7) & 0x7f;
 
-   if (coeff.mag_coeff[i][im] > 63)
-    coeff.mag_coeff[i][im] -= 128;
-   if (coeff.phs_coeff[i][im] > 63)
-    coeff.phs_coeff[i][im] -= 128;
+   if (coeff.mag_coeff[i][im][iqcal_idx] > 63)
+    coeff.mag_coeff[i][im][iqcal_idx] -= 128;
+   if (coeff.phs_coeff[i][im][iqcal_idx] > 63)
+    coeff.phs_coeff[i][im][iqcal_idx] -= 128;
   }
  }
- ar9003_hw_tx_iqcal_load_avg_2_passes(ah, &coeff, is_reusable);
+
+ if (AR_SREV_9550(ah))
+  outlier_detect = ar955x_tx_iq_cal_median(ah, &coeff,
+        iqcal_idx, nmeasurement);
+ if (outlier_detect)
+  ar9003_hw_tx_iq_cal_outlier_detection(ah, &coeff, is_reusable);
 
  return;
 
@@ -894,7 +1201,7 @@ static void ar9003_hw_tx_iq_cal_reload(struct ath_hw *ah)
 
 static void ar9003_hw_manual_peak_cal(struct ath_hw *ah, u8 chain, bool is_2g)
 {
- int offset[8], total = 0, test;
+ int offset[8] = {0}, total = 0, test;
  int agc_out, i;
 
  REG_RMW_FIELD(ah, AR_PHY_65NM_RXRF_GAINSTAGES(chain),
@@ -919,12 +1226,18 @@ static void ar9003_hw_manual_peak_cal(struct ath_hw *ah, u8 chain, bool is_2g)
         AR_PHY_65NM_RXRF_AGC_AGC_ON_OVR, 0x1);
  REG_RMW_FIELD(ah, AR_PHY_65NM_RXRF_AGC(chain),
         AR_PHY_65NM_RXRF_AGC_AGC_CAL_OVR, 0x1);
- if (is_2g)
-  REG_RMW_FIELD(ah, AR_PHY_65NM_RXRF_AGC(chain),
-         AR_PHY_65NM_RXRF_AGC_AGC2G_DBDAC_OVR, 0x0);
- else
+
+ if (AR_SREV_9330_11(ah)) {
   REG_RMW_FIELD(ah, AR_PHY_65NM_RXRF_AGC(chain),
-         AR_PHY_65NM_RXRF_AGC_AGC5G_DBDAC_OVR, 0x0);
+         AR_PHY_65NM_RXRF_AGC_AGC2G_CALDAC_OVR, 0x0);
+ } else {
+  if (is_2g)
+   REG_RMW_FIELD(ah, AR_PHY_65NM_RXRF_AGC(chain),
+          AR_PHY_65NM_RXRF_AGC_AGC2G_DBDAC_OVR, 0x0);
+  else
+   REG_RMW_FIELD(ah, AR_PHY_65NM_RXRF_AGC(chain),
+          AR_PHY_65NM_RXRF_AGC_AGC5G_DBDAC_OVR, 0x0);
+ }
 
  for (i = 6; i > 0; i--) {
   offset[i] = BIT(i - 1);
@@ -960,19 +1273,45 @@ static void ar9003_hw_manual_peak_cal(struct ath_hw *ah, u8 chain, bool is_2g)
         AR_PHY_65NM_RXRF_AGC_AGC_CAL_OVR, 0);
 }
 
-static void ar9003_hw_do_manual_peak_cal(struct ath_hw *ah,
-      struct ath9k_channel *chan)
+static void ar9003_hw_do_pcoem_manual_peak_cal(struct ath_hw *ah,
+            struct ath9k_channel *chan,
+            bool run_rtt_cal)
 {
+ struct ath9k_hw_cal_data *caldata = ah->caldata;
  int i;
 
  if (!AR_SREV_9462(ah) && !AR_SREV_9565(ah) && !AR_SREV_9485(ah))
   return;
 
+ if ((ah->caps.hw_caps & ATH9K_HW_CAP_RTT) && !run_rtt_cal)
+  return;
+
  for (i = 0; i < AR9300_MAX_CHAINS; i++) {
   if (!(ah->rxchainmask & (1 << i)))
    continue;
   ar9003_hw_manual_peak_cal(ah, i, IS_CHAN_2GHZ(chan));
  }
+
+ if (caldata)
+  set_bit(SW_PKDET_DONE, &caldata->cal_flags);
+
+ if ((ah->caps.hw_caps & ATH9K_HW_CAP_RTT) && caldata) {
+  if (IS_CHAN_2GHZ(chan)){
+   caldata->caldac[0] = REG_READ_FIELD(ah,
+          AR_PHY_65NM_RXRF_AGC(0),
+          AR_PHY_65NM_RXRF_AGC_AGC2G_CALDAC_OVR);
+   caldata->caldac[1] = REG_READ_FIELD(ah,
+          AR_PHY_65NM_RXRF_AGC(1),
+          AR_PHY_65NM_RXRF_AGC_AGC2G_CALDAC_OVR);
+  } else {
+   caldata->caldac[0] = REG_READ_FIELD(ah,
+          AR_PHY_65NM_RXRF_AGC(0),
+          AR_PHY_65NM_RXRF_AGC_AGC5G_CALDAC_OVR);
+   caldata->caldac[1] = REG_READ_FIELD(ah,
+          AR_PHY_65NM_RXRF_AGC(1),
+          AR_PHY_65NM_RXRF_AGC_AGC5G_CALDAC_OVR);
+  }
+ }
 }
 
 static void ar9003_hw_cl_cal_post_proc(struct ath_hw *ah, bool is_reusable)
@@ -990,7 +1329,7 @@ static void ar9003_hw_cl_cal_post_proc(struct ath_hw *ah, bool is_reusable)
  txclcal_done = !!(REG_READ(ah, AR_PHY_AGC_CONTROL) &
      AR_PHY_AGC_CONTROL_CLC_SUCCESS);
 
- if (caldata->done_txclcal_once) {
+ if (test_bit(TXCLCAL_DONE, &caldata->cal_flags)) {
   for (i = 0; i < AR9300_MAX_CHAINS; i++) {
    if (!(ah->txchainmask & (1 << i)))
     continue;
@@ -1006,19 +1345,20 @@ static void ar9003_hw_cl_cal_post_proc(struct ath_hw *ah, bool is_reusable)
     caldata->tx_clcal[i][j] =
      REG_READ(ah, CL_TAB_ENTRY(cl_idx[i]));
   }
-  caldata->done_txclcal_once = true;
+  set_bit(TXCLCAL_DONE, &caldata->cal_flags);
  }
 }
 
-static bool ar9003_hw_init_cal(struct ath_hw *ah,
-          struct ath9k_channel *chan)
+static bool ar9003_hw_init_cal_pcoem(struct ath_hw *ah,
+         struct ath9k_channel *chan)
 {
  struct ath_common *common = ath9k_hw_common(ah);
  struct ath9k_hw_cal_data *caldata = ah->caldata;
  bool txiqcal_done = false;
  bool is_reusable = true, status = true;
- bool run_rtt_cal = false, run_agc_cal, sep_iq_cal = false;
+ bool run_rtt_cal = false, run_agc_cal;
  bool rtt = !!(ah->caps.hw_caps & ATH9K_HW_CAP_RTT);
+ u32 rx_delay = 0;
  u32 agc_ctrl = 0, agc_supp_cals = AR_PHY_AGC_CONTROL_OFFSET_CAL |
        AR_PHY_AGC_CONTROL_FLTR_CAL   |
        AR_PHY_AGC_CONTROL_PKDET_CAL;
@@ -1042,17 +1382,22 @@ static bool ar9003_hw_init_cal(struct ath_hw *ah,
   ar9003_hw_rtt_clear_hist(ah);
  }
 
- if (rtt && !run_rtt_cal) {
-  agc_ctrl = REG_READ(ah, AR_PHY_AGC_CONTROL);
-  agc_supp_cals &= agc_ctrl;
-  agc_ctrl &= ~(AR_PHY_AGC_CONTROL_OFFSET_CAL |
-        AR_PHY_AGC_CONTROL_FLTR_CAL |
-        AR_PHY_AGC_CONTROL_PKDET_CAL);
-  REG_WRITE(ah, AR_PHY_AGC_CONTROL, agc_ctrl);
+ if (rtt) {
+  if (!run_rtt_cal) {
+   agc_ctrl = REG_READ(ah, AR_PHY_AGC_CONTROL);
+   agc_supp_cals &= agc_ctrl;
+   agc_ctrl &= ~(AR_PHY_AGC_CONTROL_OFFSET_CAL |
+          AR_PHY_AGC_CONTROL_FLTR_CAL |
+          AR_PHY_AGC_CONTROL_PKDET_CAL);
+   REG_WRITE(ah, AR_PHY_AGC_CONTROL, agc_ctrl);
+  } else {
+   if (ah->ah_flags & AH_FASTCC)
+    run_agc_cal = true;
+  }
  }
 
  if (ah->enabled_cals & TX_CL_CAL) {
-  if (caldata && caldata->done_txclcal_once)
+  if (caldata && test_bit(TXCLCAL_DONE, &caldata->cal_flags))
    REG_CLR_BIT(ah, AR_PHY_CL_CAL_CTL,
         AR_PHY_CL_CAL_ENABLE);
   else {
@@ -1076,26 +1421,25 @@ static bool ar9003_hw_init_cal(struct ath_hw *ah,
   * AGC calibration
   */
  if (ah->enabled_cals & TX_IQ_ON_AGC_CAL) {
-  if (caldata && !caldata->done_txiqcal_once)
+  if (caldata && !test_bit(TXIQCAL_DONE, &caldata->cal_flags))
    REG_SET_BIT(ah, AR_PHY_TX_IQCAL_CONTROL_0,
         AR_PHY_TX_IQCAL_CONTROL_0_ENABLE_TXIQ_CAL);
   else
    REG_CLR_BIT(ah, AR_PHY_TX_IQCAL_CONTROL_0,
         AR_PHY_TX_IQCAL_CONTROL_0_ENABLE_TXIQ_CAL);
   txiqcal_done = run_agc_cal = true;
- } else if (caldata && !caldata->done_txiqcal_once) {
-  run_agc_cal = true;
-  sep_iq_cal = true;
  }
 
 skip_tx_iqcal:
  if (ath9k_hw_mci_is_enabled(ah) && IS_CHAN_2GHZ(chan) && run_agc_cal)
   ar9003_mci_init_cal_req(ah, &is_reusable);
 
- if (sep_iq_cal) {
-  txiqcal_done = ar9003_hw_tx_iq_cal_run(ah);
+ if (REG_READ(ah, AR_PHY_CL_CAL_CTL) & AR_PHY_CL_CAL_ENABLE) {
+  rx_delay = REG_READ(ah, AR_PHY_RX_DELAY);
+  /* Disable BB_active */
   REG_WRITE(ah, AR_PHY_ACTIVE, AR_PHY_ACTIVE_DIS);
   udelay(5);
+  REG_WRITE(ah, AR_PHY_RX_DELAY, AR_PHY_RX_DELAY_DELAY);
   REG_WRITE(ah, AR_PHY_ACTIVE, AR_PHY_ACTIVE_EN);
  }
 
@@ -1110,7 +1454,12 @@ skip_tx_iqcal:
            AR_PHY_AGC_CONTROL_CAL,
            0, AH_WAIT_TIMEOUT);
 
-  ar9003_hw_do_manual_peak_cal(ah, chan);
+  ar9003_hw_do_pcoem_manual_peak_cal(ah, chan, run_rtt_cal);
+ }
+
+ if (REG_READ(ah, AR_PHY_CL_CAL_CTL) & AR_PHY_CL_CAL_ENABLE) {
+  REG_WRITE(ah, AR_PHY_RX_DELAY, rx_delay);
+  udelay(5);
  }
 
  if (ath9k_hw_mci_is_enabled(ah) && IS_CHAN_2GHZ(chan) && run_agc_cal)
@@ -1132,20 +1481,24 @@ skip_tx_iqcal:
  }
 
  if (txiqcal_done)
-  ar9003_hw_tx_iq_cal_post_proc(ah, is_reusable);
- else if (caldata && caldata->done_txiqcal_once)
+  ar9003_hw_tx_iq_cal_post_proc(ah, 0, is_reusable);
+ else if (caldata && test_bit(TXIQCAL_DONE, &caldata->cal_flags))
   ar9003_hw_tx_iq_cal_reload(ah);
 
  ar9003_hw_cl_cal_post_proc(ah, is_reusable);
 
  if (run_rtt_cal && caldata) {
   if (is_reusable) {
-   if (!ath9k_hw_rfbus_req(ah))
+   if (!ath9k_hw_rfbus_req(ah)) {
     ath_err(ath9k_hw_common(ah),
      "Could not stop baseband\n");
-   else
+   } else {
     ar9003_hw_rtt_fill_hist(ah);
 
+    if (test_bit(SW_PKDET_DONE, &caldata->cal_flags))
+     ar9003_hw_rtt_load_hist(ah);
+   }
+
    ath9k_hw_rfbus_done(ah);
   }
 
@@ -1174,13 +1527,156 @@ skip_tx_iqcal:
  return true;
 }
 
+static bool do_ar9003_agc_cal(struct ath_hw *ah)
+{
+ struct ath_common *common = ath9k_hw_common(ah);
+ bool status;
+
+ REG_WRITE(ah, AR_PHY_AGC_CONTROL,
+    REG_READ(ah, AR_PHY_AGC_CONTROL) |
+    AR_PHY_AGC_CONTROL_CAL);
+
+ status = ath9k_hw_wait(ah, AR_PHY_AGC_CONTROL,
+          AR_PHY_AGC_CONTROL_CAL,
+          0, AH_WAIT_TIMEOUT);
+ if (!status) {
+  ath_dbg(common, CALIBRATE,
+   "offset calibration failed to complete in %d ms,"
+   "noisy environment?\n",
+   AH_WAIT_TIMEOUT / 1000);
+  return false;
+ }
+
+ return true;
+}
+
+static bool ar9003_hw_init_cal_soc(struct ath_hw *ah,
+       struct ath9k_channel *chan)
+{
+ struct ath_common *common = ath9k_hw_common(ah);
+ struct ath9k_hw_cal_data *caldata = ah->caldata;
+ bool txiqcal_done = false;
+ bool status = true;
+ bool run_agc_cal = false, sep_iq_cal = false;
+ int i = 0;
+
+ /* Use chip chainmask only for calibration */
+ ar9003_hw_set_chain_masks(ah, ah->caps.rx_chainmask, ah->caps.tx_chainmask);
+
+ if (ah->enabled_cals & TX_CL_CAL) {
+  REG_SET_BIT(ah, AR_PHY_CL_CAL_CTL, AR_PHY_CL_CAL_ENABLE);
+  run_agc_cal = true;
+ }
+
+ if (IS_CHAN_HALF_RATE(chan) || IS_CHAN_QUARTER_RATE(chan))
+  goto skip_tx_iqcal;
+
+ /* Do Tx IQ Calibration */
+ REG_RMW_FIELD(ah, AR_PHY_TX_IQCAL_CONTROL_1,
+        AR_PHY_TX_IQCAL_CONTROL_1_IQCORR_I_Q_COFF_DELPT,
+        DELPT);
+
+ /*
+  * For AR9485 or later chips, TxIQ cal runs as part of
+  * AGC calibration. Specifically, AR9550 in SoC chips.
+  */
+ if (ah->enabled_cals & TX_IQ_ON_AGC_CAL) {
+  if (REG_READ_FIELD(ah, AR_PHY_TX_IQCAL_CONTROL_0,
+       AR_PHY_TX_IQCAL_CONTROL_0_ENABLE_TXIQ_CAL)) {
+    txiqcal_done = true;
+  } else {
+   txiqcal_done = false;
+  }
+  run_agc_cal = true;
+ } else {
+  sep_iq_cal = true;
+  run_agc_cal = true;
+ }
+
+ /*
+  * In the SoC family, this will run for AR9300, AR9331 and AR9340.
+  */
+ if (sep_iq_cal) {
+  txiqcal_done = ar9003_hw_tx_iq_cal_run(ah);
+  REG_WRITE(ah, AR_PHY_ACTIVE, AR_PHY_ACTIVE_DIS);
+  udelay(5);
+  REG_WRITE(ah, AR_PHY_ACTIVE, AR_PHY_ACTIVE_EN);
+ }
+
+ if (AR_SREV_9550(ah) && IS_CHAN_2GHZ(chan)) {
+  if (!ar9003_hw_dynamic_osdac_selection(ah, txiqcal_done))
+   return false;
+ }
+
+skip_tx_iqcal:
+ if (run_agc_cal || !(ah->ah_flags & AH_FASTCC)) {
+  if (AR_SREV_9330_11(ah))
+   ar9003_hw_manual_peak_cal(ah, 0, IS_CHAN_2GHZ(chan));
+
+  /*
+   * For non-AR9550 chips, we just trigger AGC calibration
+   * in the HW, poll for completion and then process
+   * the results.
+   *
+   * For AR955x, we run it multiple times and use
+   * median IQ correction.
+   */
+  if (!AR_SREV_9550(ah)) {
+   status = do_ar9003_agc_cal(ah);
+   if (!status)
+    return false;
+
+   if (txiqcal_done)
+    ar9003_hw_tx_iq_cal_post_proc(ah, 0, false);
+  } else {
+   if (!txiqcal_done) {
+    status = do_ar9003_agc_cal(ah);
+    if (!status)
+     return false;
+   } else {
+    for (i = 0; i < MAXIQCAL; i++) {
+     status = do_ar9003_agc_cal(ah);
+     if (!status)
+      return false;
+     ar9003_hw_tx_iq_cal_post_proc(ah, i, false);
+    }
+   }
+  }
+ }
+
+ /* Revert chainmask to runtime parameters */
+ ar9003_hw_set_chain_masks(ah, ah->rxchainmask, ah->txchainmask);
+
+ /* Initialize list pointers */
+ ah->cal_list = ah->cal_list_last = ah->cal_list_curr = NULL;
+
+ INIT_CAL(&ah->iq_caldata);
+ INSERT_CAL(ah, &ah->iq_caldata);
+ ath_dbg(common, CALIBRATE, "enabling IQ Calibration\n");
+
+ /* Initialize current pointer to first element in list */
+ ah->cal_list_curr = ah->cal_list;
+
+ if (ah->cal_list_curr)
+  ath9k_hw_reset_calibration(ah, ah->cal_list_curr);
+
+ if (caldata)
+  caldata->CalValid = 0;
+
+ return true;
+}
+
 void ar9003_hw_attach_calib_ops(struct ath_hw *ah)
 {
  struct ath_hw_private_ops *priv_ops = ath9k_hw_private_ops(ah);
  struct ath_hw_ops *ops = ath9k_hw_ops(ah);
 
+ if (AR_SREV_9485(ah) || AR_SREV_9462(ah) || AR_SREV_9565(ah))
+  priv_ops->init_cal = ar9003_hw_init_cal_pcoem;
+ else
+  priv_ops->init_cal = ar9003_hw_init_cal_soc;
+
  priv_ops->init_cal_settings = ar9003_hw_init_cal_settings;
- priv_ops->init_cal = ar9003_hw_init_cal;
  priv_ops->setup_calibration = ar9003_hw_setup_calibration;
 
  ops->calibrate = ar9003_hw_calibrate;
diff --git a/drivers/net/wireless/ath/ath9k/ar9003_eeprom.c b/drivers/net/wireless/ath/ath9k/ar9003_eeprom.c
index eae23b9..235053b 100644
--- a/drivers/net/wireless/ath/ath9k/ar9003_eeprom.c
+++ b/drivers/net/wireless/ath/ath9k/ar9003_eeprom.c
@@ -23,8 +23,8 @@
 #define COMP_HDR_LEN 4
 #define COMP_CKSUM_LEN 2
 
-#define LE16(x) __constant_cpu_to_le16(x)
-#define LE32(x) __constant_cpu_to_le32(x)
+#define LE16(x) cpu_to_le16(x)
+#define LE32(x) cpu_to_le32(x)
 
 /* Local defines to distinguish between extension and control CTL's */
 #define EXT_ADDITIVE (0x8000)
@@ -131,6 +131,7 @@ static const struct ar9300_eeprom ar9300_default = {
   .thresh62 = 28,
   .papdRateMaskHt20 = LE32(0x0cf0e0e0),
   .papdRateMaskHt40 = LE32(0x6cf0e0e0),
+  .switchcomspdt = 0,
   .xlna_bias_strength = 0,
   .futureModal = {
    0, 0, 0, 0, 0, 0, 0,
@@ -138,7 +139,7 @@ static const struct ar9300_eeprom ar9300_default = {
   },
  .base_ext1 = {
   .ant_div_control = 0,
-  .future = {0, 0, 0},
+  .future = {0, 0},
   .tempslopextension = {0, 0, 0, 0, 0, 0, 0, 0}
  },
  .calFreqPier2G = {
@@ -333,6 +334,7 @@ static const struct ar9300_eeprom ar9300_default = {
   .thresh62 = 28,
   .papdRateMaskHt20 = LE32(0x0c80c080),
   .papdRateMaskHt40 = LE32(0x0080c080),
+  .switchcomspdt = 0,
   .xlna_bias_strength = 0,
   .futureModal = {
    0, 0, 0, 0, 0, 0, 0,
@@ -707,6 +709,7 @@ static const struct ar9300_eeprom ar9300_x113 = {
   .thresh62 = 28,
   .papdRateMaskHt20 = LE32(0x0c80c080),
   .papdRateMaskHt40 = LE32(0x0080c080),
+  .switchcomspdt = 0,
   .xlna_bias_strength = 0,
   .futureModal = {
    0, 0, 0, 0, 0, 0, 0,
@@ -714,7 +717,7 @@ static const struct ar9300_eeprom ar9300_x113 = {
   },
   .base_ext1 = {
   .ant_div_control = 0,
-  .future = {0, 0, 0},
+  .future = {0, 0},
   .tempslopextension = {0, 0, 0, 0, 0, 0, 0, 0}
   },
  .calFreqPier2G = {
@@ -909,6 +912,7 @@ static const struct ar9300_eeprom ar9300_x113 = {
   .thresh62 = 28,
   .papdRateMaskHt20 = LE32(0x0cf0e0e0),
   .papdRateMaskHt40 = LE32(0x6cf0e0e0),
+  .switchcomspdt = 0,
   .xlna_bias_strength = 0,
   .futureModal = {
    0, 0, 0, 0, 0, 0, 0,
@@ -1284,6 +1288,7 @@ static const struct ar9300_eeprom ar9300_h112 = {
   .thresh62 = 28,
   .papdRateMaskHt20 = LE32(0x0c80c080),
   .papdRateMaskHt40 = LE32(0x0080c080),
+  .switchcomspdt = 0,
   .xlna_bias_strength = 0,
   .futureModal = {
    0, 0, 0, 0, 0, 0, 0,
@@ -1291,7 +1296,7 @@ static const struct ar9300_eeprom ar9300_h112 = {
  },
  .base_ext1 = {
   .ant_div_control = 0,
-  .future = {0, 0, 0},
+  .future = {0, 0},
   .tempslopextension = {0, 0, 0, 0, 0, 0, 0, 0}
  },
  .calFreqPier2G = {
@@ -1486,6 +1491,7 @@ static const struct ar9300_eeprom ar9300_h112 = {
   .thresh62 = 28,
   .papdRateMaskHt20 = LE32(0x0cf0e0e0),
   .papdRateMaskHt40 = LE32(0x6cf0e0e0),
+  .switchcomspdt = 0,
   .xlna_bias_strength = 0,
   .futureModal = {
    0, 0, 0, 0, 0, 0, 0,
@@ -1861,6 +1867,7 @@ static const struct ar9300_eeprom ar9300_x112 = {
   .thresh62 = 28,
   .papdRateMaskHt20 = LE32(0x0c80c080),
   .papdRateMaskHt40 = LE32(0x0080c080),
+  .switchcomspdt = 0,
   .xlna_bias_strength = 0,
   .futureModal = {
    0, 0, 0, 0, 0, 0, 0,
@@ -1868,7 +1875,7 @@ static const struct ar9300_eeprom ar9300_x112 = {
  },
  .base_ext1 = {
   .ant_div_control = 0,
-  .future = {0, 0, 0},
+  .future = {0, 0},
   .tempslopextension = {0, 0, 0, 0, 0, 0, 0, 0}
  },
  .calFreqPier2G = {
@@ -2063,6 +2070,7 @@ static const struct ar9300_eeprom ar9300_x112 = {
   .thresh62 = 28,
   .papdRateMaskHt20 = LE32(0x0cf0e0e0),
   .papdRateMaskHt40 = LE32(0x6cf0e0e0),
+  .switchcomspdt = 0,
   .xlna_bias_strength = 0,
   .futureModal = {
    0, 0, 0, 0, 0, 0, 0,
@@ -2437,6 +2445,7 @@ static const struct ar9300_eeprom ar9300_h116 = {
   .thresh62 = 28,
   .papdRateMaskHt20 = LE32(0x0c80C080),
   .papdRateMaskHt40 = LE32(0x0080C080),
+  .switchcomspdt = 0,
   .xlna_bias_strength = 0,
   .futureModal = {
    0, 0, 0, 0, 0, 0, 0,
@@ -2444,7 +2453,7 @@ static const struct ar9300_eeprom ar9300_h116 = {
   },
   .base_ext1 = {
   .ant_div_control = 0,
-  .future = {0, 0, 0},
+  .future = {0, 0},
   .tempslopextension = {0, 0, 0, 0, 0, 0, 0, 0}
   },
  .calFreqPier2G = {
@@ -2639,6 +2648,7 @@ static const struct ar9300_eeprom ar9300_h116 = {
   .thresh62 = 28,
   .papdRateMaskHt20 = LE32(0x0cf0e0e0),
   .papdRateMaskHt40 = LE32(0x6cf0e0e0),
+  .switchcomspdt = 0,
   .xlna_bias_strength = 0,
   .futureModal = {
    0, 0, 0, 0, 0, 0, 0,
@@ -2991,7 +3001,10 @@ static u32 ath9k_hw_ar9300_get_eeprom(struct ath_hw *ah,
  case EEP_CHAIN_MASK_REDUCE:
   return (pBase->miscConfiguration >> 0x3) & 0x1;
  case EEP_ANT_DIV_CTL1:
-  return eep->base_ext1.ant_div_control;
+  if (AR_SREV_9565(ah))
+   return AR9300_EEP_ANTDIV_CONTROL_DEFAULT_VALUE;
+  else
+   return eep->base_ext1.ant_div_control;
  case EEP_ANTENNA_GAIN_5G:
   return eep->modalHeader5G.antennaGain;
  case EEP_ANTENNA_GAIN_2G:
@@ -3424,12 +3437,12 @@ static u32 ath9k_hw_ar9003_dump_eeprom(struct ath_hw *ah, bool dump_base_hdr,
  struct ar9300_base_eep_hdr *pBase;
 
  if (!dump_base_hdr) {
-  len += snprintf(buf + len, size - len,
-    "%20s :\n", "2GHz modal Header");
+  len += scnprintf(buf + len, size - len,
+     "%20s :\n", "2GHz modal Header");
   len = ar9003_dump_modal_eeprom(buf, len, size,
       &eep->modalHeader2G);
-  len += snprintf(buf + len, size - len,
-    "%20s :\n", "5GHz modal Header");
+  len += scnprintf(buf + len, size - len,
+     "%20s :\n", "5GHz modal Header");
   len = ar9003_dump_modal_eeprom(buf, len, size,
       &eep->modalHeader5G);
   goto out;
@@ -3479,8 +3492,8 @@ static u32 ath9k_hw_ar9003_dump_eeprom(struct ath_hw *ah, bool dump_base_hdr,
  PR_EEP("Rx Gain", pBase->txrxgain & 0xf);
  PR_EEP("SW Reg", le32_to_cpu(pBase->swreg));
 
- len += snprintf(buf + len, size - len, "%20s : %pM\n", "MacAddress",
-   ah->eeprom.ar9300_eep.macAddr);
+ len += scnprintf(buf + len, size - len, "%20s : %pM\n", "MacAddress",
+    ah->eeprom.ar9300_eep.macAddr);
 out:
  if (len > size)
   len = size;
@@ -3541,13 +3554,12 @@ static u16 ar9003_switch_com_spdt_get(struct ath_hw *ah, bool is2ghz)
  return le16_to_cpu(ar9003_modal_header(ah, is2ghz)->switchcomspdt);
 }
 
-
-static u32 ar9003_hw_ant_ctrl_common_get(struct ath_hw *ah, bool is2ghz)
+u32 ar9003_hw_ant_ctrl_common_get(struct ath_hw *ah, bool is2ghz)
 {
  return le32_to_cpu(ar9003_modal_header(ah, is2ghz)->antCtrlCommon);
 }
 
-static u32 ar9003_hw_ant_ctrl_common_2_get(struct ath_hw *ah, bool is2ghz)
+u32 ar9003_hw_ant_ctrl_common_2_get(struct ath_hw *ah, bool is2ghz)
 {
  return le32_to_cpu(ar9003_modal_header(ah, is2ghz)->antCtrlCommon2);
 }
@@ -3561,6 +3573,7 @@ static u16 ar9003_hw_ant_ctrl_chain_get(struct ath_hw *ah, int chain,
 
 static void ar9003_hw_ant_ctrl_apply(struct ath_hw *ah, bool is2ghz)
 {
+ struct ath_common *common = ath9k_hw_common(ah);
  struct ath9k_hw_capabilities *pCap = &ah->caps;
  int chain;
  u32 regval, value, gpio;
@@ -3585,7 +3598,7 @@ static void ar9003_hw_ant_ctrl_apply(struct ath_hw *ah, bool is2ghz)
  if (AR_SREV_9462(ah) || AR_SREV_9565(ah)) {
   REG_RMW_FIELD(ah, AR_PHY_SWITCH_COM,
     AR_SWITCH_TABLE_COM_AR9462_ALL, value);
- } else if (AR_SREV_9550(ah)) {
+ } else if (AR_SREV_9550(ah) || AR_SREV_9531(ah)) {
   REG_RMW_FIELD(ah, AR_PHY_SWITCH_COM,
     AR_SWITCH_TABLE_COM_AR9550_ALL, value);
  } else
@@ -3606,7 +3619,7 @@ static void ar9003_hw_ant_ctrl_apply(struct ath_hw *ah, bool is2ghz)
   *   7:4 R/W  SWITCH_TABLE_COM_SPDT_WLAN_IDLE
   * SWITCH_TABLE_COM_SPDT_WLAN_IDLE
   */
- if (AR_SREV_9462_20(ah) || AR_SREV_9565(ah)) {
+ if (AR_SREV_9462_20_OR_LATER(ah) || AR_SREV_9565(ah)) {
   value = ar9003_switch_com_spdt_get(ah, is2ghz);
   REG_RMW_FIELD(ah, AR_PHY_GLB_CONTROL,
     AR_SWITCH_TABLE_COM_SPDT_ALL, value);
@@ -3614,6 +3627,11 @@ static void ar9003_hw_ant_ctrl_apply(struct ath_hw *ah, bool is2ghz)
  }
 
  value = ar9003_hw_ant_ctrl_common_2_get(ah, is2ghz);
+ if (AR_SREV_9485(ah) && common->bt_ant_diversity) {
+  value &= ~AR_SWITCH_TABLE_COM2_ALL;
+  value |= ah->config.ant_ctrl_comm2g_switch_enable;
+
+ }
  REG_RMW_FIELD(ah, AR_PHY_SWITCH_COM_2, AR_SWITCH_TABLE_COM2_ALL, value);
 
  if ((AR_SREV_9462(ah)) && (ah->rxchainmask == 0x2)) {
@@ -3645,21 +3663,43 @@ static void ar9003_hw_ant_ctrl_apply(struct ath_hw *ah, bool is2ghz)
   regval &= (~AR_PHY_ANT_DIV_LNADIV);
   regval |= ((value >> 6) & 0x1) << AR_PHY_ANT_DIV_LNADIV_S;
 
+  if (AR_SREV_9485(ah) && common->bt_ant_diversity)
+   regval |= AR_ANT_DIV_ENABLE;
+
   if (AR_SREV_9565(ah)) {
-   if (ah->shared_chain_lnadiv) {
+   if (common->bt_ant_diversity) {
     regval |= (1 << AR_PHY_ANT_SW_RX_PROT_S);
+
+    REG_SET_BIT(ah, AR_PHY_RESTART,
+         AR_PHY_RESTART_ENABLE_DIV_M2FLAG);
+
+    /* Force WLAN LNA diversity ON */
+    REG_SET_BIT(ah, AR_BTCOEX_WL_LNADIV,
+         AR_BTCOEX_WL_LNADIV_FORCE_ON);
    } else {
     regval &= ~(1 << AR_PHY_ANT_DIV_LNADIV_S);
     regval &= ~(1 << AR_PHY_ANT_SW_RX_PROT_S);
+
+    REG_CLR_BIT(ah, AR_PHY_MC_GAIN_CTRL,
+         (1 << AR_PHY_ANT_SW_RX_PROT_S));
+
+    /* Force WLAN LNA diversity OFF */
+    REG_CLR_BIT(ah, AR_BTCOEX_WL_LNADIV,
+         AR_BTCOEX_WL_LNADIV_FORCE_ON);
    }
   }
 
   REG_WRITE(ah, AR_PHY_MC_GAIN_CTRL, regval);
 
-  /*enable fast_div */
+  /* enable fast_div */
   regval = REG_READ(ah, AR_PHY_CCK_DETECT);
   regval &= (~AR_FAST_DIV_ENABLE);
   regval |= ((value >> 7) & 0x1) << AR_FAST_DIV_ENABLE_S;
+
+  if ((AR_SREV_9485(ah) || AR_SREV_9565(ah))
+      && common->bt_ant_diversity)
+   regval |= AR_FAST_DIV_ENABLE;
+
   REG_WRITE(ah, AR_PHY_CCK_DETECT, regval);
 
   if (pCap->hw_caps & ATH9K_HW_CAP_ANT_DIV_COMB) {
@@ -3673,9 +3713,9 @@ static void ar9003_hw_ant_ctrl_apply(struct ath_hw *ah, bool is2ghz)
          AR_PHY_ANT_DIV_ALT_GAINTB |
          AR_PHY_ANT_DIV_MAIN_GAINTB));
    /* by default use LNA1 for the main antenna */
-   regval |= (AR_PHY_ANT_DIV_LNA1 <<
+   regval |= (ATH_ANT_DIV_COMB_LNA1 <<
        AR_PHY_ANT_DIV_MAIN_LNACONF_S);
-   regval |= (AR_PHY_ANT_DIV_LNA2 <<
+   regval |= (ATH_ANT_DIV_COMB_LNA2 <<
        AR_PHY_ANT_DIV_ALT_LNACONF_S);
    REG_WRITE(ah, AR_PHY_MC_GAIN_CTRL, regval);
   }
@@ -3813,6 +3853,11 @@ static void ar9003_hw_atten_apply(struct ath_hw *ah, struct ath9k_channel *chan)
    else
     value = ar9003_hw_atten_chain_get_margin(ah, i, chan);
 
+   if (ah->config.alt_mingainidx)
+    REG_RMW_FIELD(ah, AR_PHY_EXT_ATTEN_CTL_0,
+           AR_PHY_EXT_ATTEN_CTL_XATTEN1_MARGIN,
+           value);
+
    REG_RMW_FIELD(ah, ext_atten_reg[i],
           AR_PHY_EXT_ATTEN_CTL_XATTEN1_MARGIN,
           value);
@@ -3930,7 +3975,7 @@ static void ar9003_hw_apply_tuning_caps(struct ath_hw *ah)
  struct ar9300_eeprom *eep = &ah->eeprom.ar9300_eep;
  u8 tuning_caps_param = eep->baseEepHeader.params_for_tuning_caps[0];
 
- if (AR_SREV_9485(ah) || AR_SREV_9330(ah) || AR_SREV_9340(ah))
+ if (AR_SREV_9340(ah) || AR_SREV_9531(ah))
   return;
 
  if (eep->baseEepHeader.featureEnable & 0x40) {
@@ -3949,18 +3994,20 @@ static void ar9003_hw_quick_drop_apply(struct ath_hw *ah, u16 freq)
  int quick_drop;
  s32 t[3], f[3] = {5180, 5500, 5785};
 
- if (!(pBase->miscConfiguration & BIT(1)))
+ if (!(pBase->miscConfiguration & BIT(4)))
   return;
 
- if (freq < 4000)
-  quick_drop = eep->modalHeader2G.quick_drop;
- else {
-  t[0] = eep->base_ext1.quick_drop_low;
-  t[1] = eep->modalHeader5G.quick_drop;
-  t[2] = eep->base_ext1.quick_drop_high;
-  quick_drop = ar9003_hw_power_interpolate(freq, f, t, 3);
+ if (AR_SREV_9300(ah) || AR_SREV_9580(ah) || AR_SREV_9340(ah)) {
+  if (freq < 4000) {
+   quick_drop = eep->modalHeader2G.quick_drop;
+  } else {
+   t[0] = eep->base_ext1.quick_drop_low;
+   t[1] = eep->modalHeader5G.quick_drop;
+   t[2] = eep->base_ext1.quick_drop_high;
+   quick_drop = ar9003_hw_power_interpolate(freq, f, t, 3);
+  }
+  REG_RMW_FIELD(ah, AR_PHY_AGC, AR_PHY_AGC_QUICK_DROP, quick_drop);
  }
- REG_RMW_FIELD(ah, AR_PHY_AGC, AR_PHY_AGC_QUICK_DROP, quick_drop);
 }
 
 static void ar9003_hw_txend_to_xpa_off_apply(struct ath_hw *ah, bool is2ghz)
@@ -3983,7 +4030,10 @@ static void ar9003_hw_xpa_timing_control_apply(struct ath_hw *ah, bool is2ghz)
  if (!(eep->baseEepHeader.featureEnable & 0x80))
   return;
 
- if (!AR_SREV_9300(ah) && !AR_SREV_9340(ah) && !AR_SREV_9580(ah))
+ if (!AR_SREV_9300(ah) &&
+     !AR_SREV_9340(ah) &&
+     !AR_SREV_9580(ah) &&
+     !AR_SREV_9531(ah))
   return;
 
  xpa_ctl = ar9003_modal_header(ah, is2ghz)->txFrameToXpaOn;
@@ -4000,7 +4050,7 @@ static void ar9003_hw_xlna_bias_strength_apply(struct ath_hw *ah, bool is2ghz)
  struct ar9300_eeprom *eep = &ah->eeprom.ar9300_eep;
  u8 bias;
 
- if (!(eep->baseEepHeader.featureEnable & 0x40))
+ if (!(eep->baseEepHeader.miscConfiguration & 0x40))
   return;
 
  if (!AR_SREV_9300(ah))
@@ -4059,8 +4109,9 @@ static void ar9003_hw_thermo_cal_apply(struct ath_hw *ah)
 {
  u32 data, ko, kg;
 
- if (!AR_SREV_9462_20(ah))
+ if (!AR_SREV_9462_20_OR_LATER(ah))
   return;
+
  ar9300_otp_read_word(ah, 1, &data);
  ko = data & 0xff;
  kg = (data >> 8) & 0xff;
@@ -4073,6 +4124,37 @@ static void ar9003_hw_thermo_cal_apply(struct ath_hw *ah)
  }
 }
 
+static void ar9003_hw_apply_minccapwr_thresh(struct ath_hw *ah,
+          bool is2ghz)
+{
+ struct ar9300_eeprom *eep = &ah->eeprom.ar9300_eep;
+ const u_int32_t cca_ctrl[AR9300_MAX_CHAINS] = {
+  AR_PHY_CCA_CTRL_0,
+  AR_PHY_CCA_CTRL_1,
+  AR_PHY_CCA_CTRL_2,
+ };
+ int chain;
+ u32 val;
+
+ if (is2ghz) {
+  if (!(eep->base_ext1.misc_enable & BIT(2)))
+   return;
+ } else {
+  if (!(eep->base_ext1.misc_enable & BIT(3)))
+   return;
+ }
+
+ for (chain = 0; chain < AR9300_MAX_CHAINS; chain++) {
+  if (!(ah->caps.tx_chainmask & BIT(chain)))
+   continue;
+
+  val = ar9003_modal_header(ah, is2ghz)->noiseFloorThreshCh[chain];
+  REG_RMW_FIELD(ah, cca_ctrl[chain],
+         AR_PHY_EXT_CCA0_THRESH62_1, val);
+ }
+
+}
+
 static void ath9k_hw_ar9300_set_board_values(struct ath_hw *ah,
           struct ath9k_channel *chan)
 {
@@ -4084,9 +4166,10 @@ static void ath9k_hw_ar9300_set_board_values(struct ath_hw *ah,
  ar9003_hw_xlna_bias_strength_apply(ah, is2ghz);
  ar9003_hw_atten_apply(ah, chan);
  ar9003_hw_quick_drop_apply(ah, chan->channel);
- if (!AR_SREV_9330(ah) && !AR_SREV_9340(ah) && !AR_SREV_9550(ah))
+ if (!AR_SREV_9330(ah) && !AR_SREV_9340(ah) && !AR_SREV_9531(ah))
   ar9003_hw_internal_regulator_apply(ah);
  ar9003_hw_apply_tuning_caps(ah);
+ ar9003_hw_apply_minccapwr_thresh(ah, chan);
  ar9003_hw_txend_to_xpa_off_apply(ah, is2ghz);
  ar9003_hw_thermometer_apply(ah);
  ar9003_hw_thermo_cal_apply(ah);
@@ -4562,7 +4645,7 @@ static void ar9003_hw_get_target_power_eeprom(struct ath_hw *ah,
        is2GHz);
 
  for (i = 0; i < ar9300RateSize; i++) {
-  ath_dbg(common, EEPROM, "TPC[%02d] 0x%08x\n",
+  ath_dbg(common, REGULATORY, "TPC[%02d] 0x%08x\n",
    i, targetPowerValT2[i]);
  }
 }
@@ -4708,51 +4791,62 @@ static void ar9003_hw_power_control_override(struct ath_hw *ah,
  }
 
 tempslope:
- if (AR_SREV_9550(ah)) {
+ if (AR_SREV_9550(ah) || AR_SREV_9531(ah)) {
+  u8 txmask = (eep->baseEepHeader.txrxMask & 0xf0) >> 4;
+
   /*
    * AR955x has tempSlope register for each chain.
    * Check whether temp_compensation feature is enabled or not.
    */
   if (eep->baseEepHeader.featureEnable & 0x1) {
    if (frequency < 4000) {
-    REG_RMW_FIELD(ah, AR_PHY_TPC_19,
-           AR_PHY_TPC_19_ALPHA_THERM,
-           eep->base_ext2.tempSlopeLow);
-    REG_RMW_FIELD(ah, AR_PHY_TPC_19_B1,
-           AR_PHY_TPC_19_ALPHA_THERM,
-           temp_slope);
-    REG_RMW_FIELD(ah, AR_PHY_TPC_19_B2,
-           AR_PHY_TPC_19_ALPHA_THERM,
-           eep->base_ext2.tempSlopeHigh);
+    if (txmask & BIT(0))
+     REG_RMW_FIELD(ah, AR_PHY_TPC_19,
+            AR_PHY_TPC_19_ALPHA_THERM,
+            eep->base_ext2.tempSlopeLow);
+    if (txmask & BIT(1))
+     REG_RMW_FIELD(ah, AR_PHY_TPC_19_B1,
+            AR_PHY_TPC_19_ALPHA_THERM,
+            temp_slope);
+    if (txmask & BIT(2))
+     REG_RMW_FIELD(ah, AR_PHY_TPC_19_B2,
+            AR_PHY_TPC_19_ALPHA_THERM,
+            eep->base_ext2.tempSlopeHigh);
    } else {
-    REG_RMW_FIELD(ah, AR_PHY_TPC_19,
-           AR_PHY_TPC_19_ALPHA_THERM,
-           temp_slope);
-    REG_RMW_FIELD(ah, AR_PHY_TPC_19_B1,
-           AR_PHY_TPC_19_ALPHA_THERM,
-           temp_slope1);
-    REG_RMW_FIELD(ah, AR_PHY_TPC_19_B2,
-           AR_PHY_TPC_19_ALPHA_THERM,
-           temp_slope2);
+    if (txmask & BIT(0))
+     REG_RMW_FIELD(ah, AR_PHY_TPC_19,
+            AR_PHY_TPC_19_ALPHA_THERM,
+            temp_slope);
+    if (txmask & BIT(1))
+     REG_RMW_FIELD(ah, AR_PHY_TPC_19_B1,
+            AR_PHY_TPC_19_ALPHA_THERM,
+            temp_slope1);
+    if (txmask & BIT(2))
+     REG_RMW_FIELD(ah, AR_PHY_TPC_19_B2,
+            AR_PHY_TPC_19_ALPHA_THERM,
+            temp_slope2);
    }
   } else {
    /*
     * If temp compensation is not enabled,
     * set all registers to 0.
     */
-   REG_RMW_FIELD(ah, AR_PHY_TPC_19,
-          AR_PHY_TPC_19_ALPHA_THERM, 0);
-   REG_RMW_FIELD(ah, AR_PHY_TPC_19_B1,
-          AR_PHY_TPC_19_ALPHA_THERM, 0);
-   REG_RMW_FIELD(ah, AR_PHY_TPC_19_B2,
-          AR_PHY_TPC_19_ALPHA_THERM, 0);
+   if (txmask & BIT(0))
+    REG_RMW_FIELD(ah, AR_PHY_TPC_19,
+           AR_PHY_TPC_19_ALPHA_THERM, 0);
+   if (txmask & BIT(1))
+    REG_RMW_FIELD(ah, AR_PHY_TPC_19_B1,
+           AR_PHY_TPC_19_ALPHA_THERM, 0);
+   if (txmask & BIT(2))
+    REG_RMW_FIELD(ah, AR_PHY_TPC_19_B2,
+           AR_PHY_TPC_19_ALPHA_THERM, 0);
   }
  } else {
   REG_RMW_FIELD(ah, AR_PHY_TPC_19,
          AR_PHY_TPC_19_ALPHA_THERM, temp_slope);
  }
 
- if (AR_SREV_9462_20(ah))
+ if (AR_SREV_9462_20_OR_LATER(ah))
   REG_RMW_FIELD(ah, AR_PHY_TPC_19_B1,
          AR_PHY_TPC_19_B1_ALPHA_THERM, temp_slope);
 
@@ -4982,6 +5076,10 @@ static u16 ar9003_hw_get_max_edge_power(struct ar9300_eeprom *eep,
    break;
   }
  }
+
+ if (is2GHz && !twiceMaxEdgePower)
+  twiceMaxEdgePower = 60;
+
  return twiceMaxEdgePower;
 }
 
@@ -5288,7 +5386,7 @@ static void ath9k_hw_ar9300_set_txpower(struct ath_hw *ah,
   return;
 
  for (i = 0; i < ar9300RateSize; i++) {
-  ath_dbg(common, EEPROM, "TPC[%02d] 0x%08x\n",
+  ath_dbg(common, REGULATORY, "TPC[%02d] 0x%08x\n",
    i, targetPowerValT2[i]);
  }
 
diff --git a/drivers/net/wireless/ath/ath9k/ar9003_eeprom.h b/drivers/net/wireless/ath/ath9k/ar9003_eeprom.h
index 874f657..694ca2e 100644
--- a/drivers/net/wireless/ath/ath9k/ar9003_eeprom.h
+++ b/drivers/net/wireless/ath/ath9k/ar9003_eeprom.h
@@ -52,6 +52,8 @@
 #define AR9300_PAPRD_SCALE_2  0x70000000
 #define AR9300_PAPRD_SCALE_2_S  28
 
+#define AR9300_EEP_ANTDIV_CONTROL_DEFAULT_VALUE 0xc9
+
 /* Delta from which to start power to pdadc table */
 /* This offset is used in both open loop and closed loop power control
  * schemes. In open loop power control, it is not really needed, but for
@@ -268,10 +270,20 @@ struct cal_ctl_data_5g {
  u8 ctlEdges[AR9300_NUM_BAND_EDGES_5G];
 } __packed;
 
+#define MAX_BASE_EXTENSION_FUTURE 2
+
 struct ar9300_BaseExtension_1 {
  u8 ant_div_control;
- u8 future[3];
- u8 tempslopextension[8];
+ u8 future[MAX_BASE_EXTENSION_FUTURE];
+ /*
+  * misc_enable:
+  *
+  * BIT 0   - TX Gain Cap enable.
+  * BIT 1   - Uncompressed Checksum enable.
+  * BIT 2/3 - MinCCApwr enable 2g/5g.
+  */
+ u8 misc_enable;
+ int8_t tempslopextension[8];
  int8_t quick_drop_low;
  int8_t quick_drop_high;
 } __packed;
@@ -334,6 +346,8 @@ struct ar9300_eeprom {
 
 s32 ar9003_hw_get_tx_gain_idx(struct ath_hw *ah);
 s32 ar9003_hw_get_rx_gain_idx(struct ath_hw *ah);
+u32 ar9003_hw_ant_ctrl_common_get(struct ath_hw *ah, bool is2ghz);
+u32 ar9003_hw_ant_ctrl_common_2_get(struct ath_hw *ah, bool is2ghz);
 
 u8 *ar9003_get_spur_chan_ptr(struct ath_hw *ah, bool is_2ghz);
 
diff --git a/drivers/net/wireless/ath/ath9k/ar9003_hw.c b/drivers/net/wireless/ath/ath9k/ar9003_hw.c
index a3523c9..ec1da0c 100644
--- a/drivers/net/wireless/ath/ath9k/ar9003_hw.c
+++ b/drivers/net/wireless/ath/ath9k/ar9003_hw.c
@@ -17,6 +17,7 @@
 #include "hw.h"
 #include "ar9003_mac.h"
 #include "ar9003_2p2_initvals.h"
+#include "ar9003_buffalo_initvals.h"
 #include "ar9485_initvals.h"
 #include "ar9340_initvals.h"
 #include "ar9330_1p1_initvals.h"
@@ -24,7 +25,10 @@
 #include "ar955x_1p0_initvals.h"
 #include "ar9580_1p0_initvals.h"
 #include "ar9462_2p0_initvals.h"
+#include "ar9462_2p1_initvals.h"
 #include "ar9565_1p0_initvals.h"
+#include "ar9565_1p1_initvals.h"
+#include "ar953x_initvals.h"
 
 /* General hardware code for the AR9003 hadware family */
 
@@ -147,12 +151,16 @@ static void ar9003_hw_init_mode_regs(struct ath_hw *ah)
     ar9340Modes_high_ob_db_tx_gain_table_1p0);
 
   INIT_INI_ARRAY(&ah->iniModesFastClock,
-    ar9340Modes_fast_clock_1p0);
+          ar9340Modes_fast_clock_1p0);
+  INIT_INI_ARRAY(&ah->iniCckfirJapan2484,
+          ar9340_1p0_baseband_core_txfir_coeff_japan_2484);
+  INIT_INI_ARRAY(&ah->ini_dfs,
+          ar9340_1p0_baseband_postamble_dfs_channel);
 
   if (!ah->is_clk_25mhz)
    INIT_INI_ARRAY(&ah->iniAdditional,
            ar9340_1p0_radio_core_40M);
- } else if (AR_SREV_9485_11(ah)) {
+ } else if (AR_SREV_9485_11_OR_LATER(ah)) {
   /* mac */
   INIT_INI_ARRAY(&ah->iniMac[ATH_INI_CORE],
     ar9485_1_1_mac_core);
@@ -186,17 +194,46 @@ static void ar9003_hw_init_mode_regs(struct ath_hw *ah)
   INIT_INI_ARRAY(&ah->iniCckfirJapan2484,
           ar9485_1_1_baseband_core_txfir_coeff_japan_2484);
 
-  /* Load PCIE SERDES settings from INI */
-
-  /* Awake Setting */
-
+  if (ah->config.no_pll_pwrsave) {
+   INIT_INI_ARRAY(&ah->iniPcieSerdes,
+           ar9485_1_1_pcie_phy_clkreq_disable_L1);
+   INIT_INI_ARRAY(&ah->iniPcieSerdesLowPower,
+           ar9485_1_1_pcie_phy_clkreq_disable_L1);
+  } else {
+   INIT_INI_ARRAY(&ah->iniPcieSerdes,
+           ar9485_1_1_pll_on_cdr_on_clkreq_disable_L1);
+   INIT_INI_ARRAY(&ah->iniPcieSerdesLowPower,
+           ar9485_1_1_pll_on_cdr_on_clkreq_disable_L1);
+  }
+ } else if (AR_SREV_9462_21(ah)) {
+  INIT_INI_ARRAY(&ah->iniMac[ATH_INI_CORE],
+          ar9462_2p1_mac_core);
+  INIT_INI_ARRAY(&ah->iniMac[ATH_INI_POST],
+          ar9462_2p1_mac_postamble);
+  INIT_INI_ARRAY(&ah->iniBB[ATH_INI_CORE],
+          ar9462_2p1_baseband_core);
+  INIT_INI_ARRAY(&ah->iniBB[ATH_INI_POST],
+          ar9462_2p1_baseband_postamble);
+  INIT_INI_ARRAY(&ah->iniRadio[ATH_INI_CORE],
+          ar9462_2p1_radio_core);
+  INIT_INI_ARRAY(&ah->iniRadio[ATH_INI_POST],
+          ar9462_2p1_radio_postamble);
+  INIT_INI_ARRAY(&ah->ini_radio_post_sys2ant,
+          ar9462_2p1_radio_postamble_sys2ant);
+  INIT_INI_ARRAY(&ah->iniSOC[ATH_INI_PRE],
+          ar9462_2p1_soc_preamble);
+  INIT_INI_ARRAY(&ah->iniSOC[ATH_INI_POST],
+          ar9462_2p1_soc_postamble);
+  INIT_INI_ARRAY(&ah->iniModesRxGain,
+          ar9462_2p1_common_rx_gain);
+  INIT_INI_ARRAY(&ah->iniModesFastClock,
+          ar9462_2p1_modes_fast_clock);
+  INIT_INI_ARRAY(&ah->iniCckfirJapan2484,
+          ar9462_2p1_baseband_core_txfir_coeff_japan_2484);
   INIT_INI_ARRAY(&ah->iniPcieSerdes,
-    ar9485_1_1_pcie_phy_clkreq_disable_L1);
-
-  /* Sleep Setting */
-
+          ar9462_2p1_pciephy_clkreq_disable_L1);
   INIT_INI_ARRAY(&ah->iniPcieSerdesLowPower,
-    ar9485_1_1_pcie_phy_clkreq_disable_L1);
+          ar9462_2p1_pciephy_clkreq_disable_L1);
  } else if (AR_SREV_9462_20(ah)) {
 
   INIT_INI_ARRAY(&ah->iniMac[ATH_INI_CORE], ar9462_2p0_mac_core);
@@ -221,18 +258,18 @@ static void ar9003_hw_init_mode_regs(struct ath_hw *ah)
     ar9462_2p0_soc_postamble);
 
   INIT_INI_ARRAY(&ah->iniModesRxGain,
-    ar9462_common_rx_gain_table_2p0);
+    ar9462_2p0_common_rx_gain);
 
   /* Awake -> Sleep Setting */
   INIT_INI_ARRAY(&ah->iniPcieSerdes,
-          ar9462_pciephy_clkreq_disable_L1_2p0);
+          ar9462_2p0_pciephy_clkreq_disable_L1);
   /* Sleep -> Awake Setting */
   INIT_INI_ARRAY(&ah->iniPcieSerdesLowPower,
-          ar9462_pciephy_clkreq_disable_L1_2p0);
+          ar9462_2p0_pciephy_clkreq_disable_L1);
 
   /* Fast clock modal settings */
   INIT_INI_ARRAY(&ah->iniModesFastClock,
-    ar9462_modes_fast_clock_2p0);
+    ar9462_2p0_modes_fast_clock);
 
   INIT_INI_ARRAY(&ah->iniCckfirJapan2484,
           ar9462_2p0_baseband_core_txfir_coeff_japan_2484);
@@ -272,6 +309,31 @@ static void ar9003_hw_init_mode_regs(struct ath_hw *ah)
   /* Fast clock modal settings */
   INIT_INI_ARRAY(&ah->iniModesFastClock,
     ar955x_1p0_modes_fast_clock);
+ } else if (AR_SREV_9531(ah)) {
+  INIT_INI_ARRAY(&ah->iniMac[ATH_INI_CORE],
+          qca953x_1p0_mac_core);
+  INIT_INI_ARRAY(&ah->iniMac[ATH_INI_POST],
+          qca953x_1p0_mac_postamble);
+  INIT_INI_ARRAY(&ah->iniBB[ATH_INI_CORE],
+          qca953x_1p0_baseband_core);
+  INIT_INI_ARRAY(&ah->iniBB[ATH_INI_POST],
+          qca953x_1p0_baseband_postamble);
+  INIT_INI_ARRAY(&ah->iniRadio[ATH_INI_CORE],
+          qca953x_1p0_radio_core);
+  INIT_INI_ARRAY(&ah->iniRadio[ATH_INI_POST],
+          qca953x_1p0_radio_postamble);
+  INIT_INI_ARRAY(&ah->iniSOC[ATH_INI_PRE],
+          qca953x_1p0_soc_preamble);
+  INIT_INI_ARRAY(&ah->iniSOC[ATH_INI_POST],
+          qca953x_1p0_soc_postamble);
+  INIT_INI_ARRAY(&ah->iniModesRxGain,
+          qca953x_1p0_common_wo_xlna_rx_gain_table);
+  INIT_INI_ARRAY(&ah->ini_modes_rx_gain_bounds,
+          qca953x_1p0_common_wo_xlna_rx_gain_bounds);
+  INIT_INI_ARRAY(&ah->iniModesTxGain,
+          qca953x_1p0_modes_no_xpa_tx_gain_table);
+  INIT_INI_ARRAY(&ah->iniModesFastClock,
+          qca953x_1p0_modes_fast_clock);
  } else if (AR_SREV_9580(ah)) {
   /* mac */
   INIT_INI_ARRAY(&ah->iniMac[ATH_INI_CORE],
@@ -304,7 +366,46 @@ static void ar9003_hw_init_mode_regs(struct ath_hw *ah)
     ar9580_1p0_low_ob_db_tx_gain_table);
 
   INIT_INI_ARRAY(&ah->iniModesFastClock,
-    ar9580_1p0_modes_fast_clock);
+          ar9580_1p0_modes_fast_clock);
+  INIT_INI_ARRAY(&ah->iniCckfirJapan2484,
+          ar9580_1p0_baseband_core_txfir_coeff_japan_2484);
+  INIT_INI_ARRAY(&ah->ini_dfs,
+          ar9580_1p0_baseband_postamble_dfs_channel);
+ } else if (AR_SREV_9565_11_OR_LATER(ah)) {
+  INIT_INI_ARRAY(&ah->iniMac[ATH_INI_CORE],
+          ar9565_1p1_mac_core);
+  INIT_INI_ARRAY(&ah->iniMac[ATH_INI_POST],
+          ar9565_1p1_mac_postamble);
+
+  INIT_INI_ARRAY(&ah->iniBB[ATH_INI_CORE],
+          ar9565_1p1_baseband_core);
+  INIT_INI_ARRAY(&ah->iniBB[ATH_INI_POST],
+          ar9565_1p1_baseband_postamble);
+
+  INIT_INI_ARRAY(&ah->iniRadio[ATH_INI_CORE],
+          ar9565_1p1_radio_core);
+  INIT_INI_ARRAY(&ah->iniRadio[ATH_INI_POST],
+          ar9565_1p1_radio_postamble);
+
+  INIT_INI_ARRAY(&ah->iniSOC[ATH_INI_PRE],
+          ar9565_1p1_soc_preamble);
+  INIT_INI_ARRAY(&ah->iniSOC[ATH_INI_POST],
+          ar9565_1p1_soc_postamble);
+
+  INIT_INI_ARRAY(&ah->iniModesRxGain,
+          ar9565_1p1_Common_rx_gain_table);
+  INIT_INI_ARRAY(&ah->iniModesTxGain,
+          ar9565_1p1_Modes_lowest_ob_db_tx_gain_table);
+
+  INIT_INI_ARRAY(&ah->iniPcieSerdes,
+          ar9565_1p1_pciephy_clkreq_disable_L1);
+  INIT_INI_ARRAY(&ah->iniPcieSerdesLowPower,
+          ar9565_1p1_pciephy_clkreq_disable_L1);
+
+  INIT_INI_ARRAY(&ah->iniModesFastClock,
+    ar9565_1p1_modes_fast_clock);
+  INIT_INI_ARRAY(&ah->iniCckfirJapan2484,
+          ar9565_1p1_baseband_core_txfir_coeff_japan_2484);
  } else if (AR_SREV_9565(ah)) {
   INIT_INI_ARRAY(&ah->iniMac[ATH_INI_CORE],
           ar9565_1p0_mac_core);
@@ -338,6 +439,8 @@ static void ar9003_hw_init_mode_regs(struct ath_hw *ah)
 
   INIT_INI_ARRAY(&ah->iniModesFastClock,
     ar9565_1p0_modes_fast_clock);
+  INIT_INI_ARRAY(&ah->iniCckfirJapan2484,
+          ar9565_1p0_baseband_core_txfir_coeff_japan_2484);
  } else {
   /* mac */
   INIT_INI_ARRAY(&ah->iniMac[ATH_INI_CORE],
@@ -383,7 +486,11 @@ static void ar9003_hw_init_mode_regs(struct ath_hw *ah)
 
   /* Fast clock modal settings */
   INIT_INI_ARRAY(&ah->iniModesFastClock,
-    ar9300Modes_fast_clock_2p2);
+          ar9300Modes_fast_clock_2p2);
+  INIT_INI_ARRAY(&ah->iniCckfirJapan2484,
+          ar9300_2p2_baseband_core_txfir_coeff_japan_2484);
+  INIT_INI_ARRAY(&ah->ini_dfs,
+          ar9300_2p2_baseband_postamble_dfs_channel);
  }
 }
 
@@ -398,18 +505,27 @@ static void ar9003_tx_gain_table_mode0(struct ath_hw *ah)
  else if (AR_SREV_9340(ah))
   INIT_INI_ARRAY(&ah->iniModesTxGain,
    ar9340Modes_lowest_ob_db_tx_gain_table_1p0);
- else if (AR_SREV_9485_11(ah))
+ else if (AR_SREV_9485_11_OR_LATER(ah))
   INIT_INI_ARRAY(&ah->iniModesTxGain,
    ar9485_modes_lowest_ob_db_tx_gain_1_1);
  else if (AR_SREV_9550(ah))
   INIT_INI_ARRAY(&ah->iniModesTxGain,
    ar955x_1p0_modes_xpa_tx_gain_table);
+ else if (AR_SREV_9531(ah))
+  INIT_INI_ARRAY(&ah->iniModesTxGain,
+   qca953x_1p0_modes_xpa_tx_gain_table);
  else if (AR_SREV_9580(ah))
   INIT_INI_ARRAY(&ah->iniModesTxGain,
    ar9580_1p0_lowest_ob_db_tx_gain_table);
+ else if (AR_SREV_9462_21(ah))
+  INIT_INI_ARRAY(&ah->iniModesTxGain,
+   ar9462_2p1_modes_low_ob_db_tx_gain);
  else if (AR_SREV_9462_20(ah))
   INIT_INI_ARRAY(&ah->iniModesTxGain,
-   ar9462_modes_low_ob_db_tx_gain_table_2p0);
+   ar9462_2p0_modes_low_ob_db_tx_gain);
+ else if (AR_SREV_9565_11(ah))
+  INIT_INI_ARRAY(&ah->iniModesTxGain,
+          ar9565_1p1_modes_low_ob_db_tx_gain_table);
  else if (AR_SREV_9565(ah))
   INIT_INI_ARRAY(&ah->iniModesTxGain,
           ar9565_1p0_modes_low_ob_db_tx_gain_table);
@@ -429,7 +545,7 @@ static void ar9003_tx_gain_table_mode1(struct ath_hw *ah)
  else if (AR_SREV_9340(ah))
   INIT_INI_ARRAY(&ah->iniModesTxGain,
    ar9340Modes_high_ob_db_tx_gain_table_1p0);
- else if (AR_SREV_9485_11(ah))
+ else if (AR_SREV_9485_11_OR_LATER(ah))
   INIT_INI_ARRAY(&ah->iniModesTxGain,
    ar9485Modes_high_ob_db_tx_gain_1_1);
  else if (AR_SREV_9580(ah))
@@ -438,9 +554,22 @@ static void ar9003_tx_gain_table_mode1(struct ath_hw *ah)
  else if (AR_SREV_9550(ah))
   INIT_INI_ARRAY(&ah->iniModesTxGain,
    ar955x_1p0_modes_no_xpa_tx_gain_table);
+ else if (AR_SREV_9531(ah)) {
+  if (AR_SREV_9531_11(ah))
+   INIT_INI_ARRAY(&ah->iniModesTxGain,
+           qca953x_1p1_modes_no_xpa_tx_gain_table);
+  else
+   INIT_INI_ARRAY(&ah->iniModesTxGain,
+           qca953x_1p0_modes_no_xpa_tx_gain_table);
+ } else if (AR_SREV_9462_21(ah))
+  INIT_INI_ARRAY(&ah->iniModesTxGain,
+   ar9462_2p1_modes_high_ob_db_tx_gain);
  else if (AR_SREV_9462_20(ah))
   INIT_INI_ARRAY(&ah->iniModesTxGain,
-   ar9462_modes_high_ob_db_tx_gain_table_2p0);
+   ar9462_2p0_modes_high_ob_db_tx_gain);
+ else if (AR_SREV_9565_11(ah))
+  INIT_INI_ARRAY(&ah->iniModesTxGain,
+          ar9565_1p1_modes_high_ob_db_tx_gain_table);
  else if (AR_SREV_9565(ah))
   INIT_INI_ARRAY(&ah->iniModesTxGain,
           ar9565_1p0_modes_high_ob_db_tx_gain_table);
@@ -460,12 +589,15 @@ static void ar9003_tx_gain_table_mode2(struct ath_hw *ah)
  else if (AR_SREV_9340(ah))
   INIT_INI_ARRAY(&ah->iniModesTxGain,
    ar9340Modes_low_ob_db_tx_gain_table_1p0);
- else if (AR_SREV_9485_11(ah))
+ else if (AR_SREV_9485_11_OR_LATER(ah))
   INIT_INI_ARRAY(&ah->iniModesTxGain,
    ar9485Modes_low_ob_db_tx_gain_1_1);
  else if (AR_SREV_9580(ah))
   INIT_INI_ARRAY(&ah->iniModesTxGain,
    ar9580_1p0_low_ob_db_tx_gain_table);
+ else if (AR_SREV_9565_11(ah))
+  INIT_INI_ARRAY(&ah->iniModesTxGain,
+          ar9565_1p1_modes_low_ob_db_tx_gain_table);
  else if (AR_SREV_9565(ah))
   INIT_INI_ARRAY(&ah->iniModesTxGain,
           ar9565_1p0_modes_low_ob_db_tx_gain_table);
@@ -485,18 +617,26 @@ static void ar9003_tx_gain_table_mode3(struct ath_hw *ah)
  else if (AR_SREV_9340(ah))
   INIT_INI_ARRAY(&ah->iniModesTxGain,
    ar9340Modes_high_power_tx_gain_table_1p0);
- else if (AR_SREV_9485_11(ah))
+ else if (AR_SREV_9485_11_OR_LATER(ah))
   INIT_INI_ARRAY(&ah->iniModesTxGain,
    ar9485Modes_high_power_tx_gain_1_1);
  else if (AR_SREV_9580(ah))
   INIT_INI_ARRAY(&ah->iniModesTxGain,
    ar9580_1p0_high_power_tx_gain_table);
+ else if (AR_SREV_9565_11(ah))
+  INIT_INI_ARRAY(&ah->iniModesTxGain,
+          ar9565_1p1_modes_high_power_tx_gain_table);
  else if (AR_SREV_9565(ah))
   INIT_INI_ARRAY(&ah->iniModesTxGain,
           ar9565_1p0_modes_high_power_tx_gain_table);
- else
-  INIT_INI_ARRAY(&ah->iniModesTxGain,
-   ar9300Modes_high_power_tx_gain_table_2p2);
+ else {
+  if (ah->config.tx_gain_buffalo)
+   INIT_INI_ARRAY(&ah->iniModesTxGain,
+           ar9300Modes_high_power_tx_gain_table_buffalo);
+  else
+   INIT_INI_ARRAY(&ah->iniModesTxGain,
+           ar9300Modes_high_power_tx_gain_table_2p2);
+ }
 }
 
 static void ar9003_tx_gain_table_mode4(struct ath_hw *ah)
@@ -507,6 +647,12 @@ static void ar9003_tx_gain_table_mode4(struct ath_hw *ah)
  else if (AR_SREV_9580(ah))
   INIT_INI_ARRAY(&ah->iniModesTxGain,
    ar9580_1p0_mixed_ob_db_tx_gain_table);
+ else if (AR_SREV_9462_21(ah))
+  INIT_INI_ARRAY(&ah->iniModesTxGain,
+         ar9462_2p1_modes_mix_ob_db_tx_gain);
+ else if (AR_SREV_9462_20(ah))
+  INIT_INI_ARRAY(&ah->iniModesTxGain,
+         ar9462_2p0_modes_mix_ob_db_tx_gain);
  else
   INIT_INI_ARRAY(&ah->iniModesTxGain,
    ar9300Modes_mixed_ob_db_tx_gain_table_2p2);
@@ -514,7 +660,7 @@ static void ar9003_tx_gain_table_mode4(struct ath_hw *ah)
 
 static void ar9003_tx_gain_table_mode5(struct ath_hw *ah)
 {
- if (AR_SREV_9485_11(ah))
+ if (AR_SREV_9485_11_OR_LATER(ah))
   INIT_INI_ARRAY(&ah->iniModesTxGain,
    ar9485Modes_green_ob_db_tx_gain_1_1);
  else if (AR_SREV_9340(ah))
@@ -533,7 +679,7 @@ static void ar9003_tx_gain_table_mode6(struct ath_hw *ah)
  if (AR_SREV_9340(ah))
   INIT_INI_ARRAY(&ah->iniModesTxGain,
    ar9340Modes_low_ob_db_and_spur_tx_gain_table_1p0);
- else if (AR_SREV_9485_11(ah))
+ else if (AR_SREV_9485_11_OR_LATER(ah))
   INIT_INI_ARRAY(&ah->iniModesTxGain,
    ar9485Modes_green_spur_ob_db_tx_gain_1_1);
  else if (AR_SREV_9580(ah))
@@ -541,6 +687,13 @@ static void ar9003_tx_gain_table_mode6(struct ath_hw *ah)
    ar9580_1p0_type6_tx_gain_table);
 }
 
+static void ar9003_tx_gain_table_mode7(struct ath_hw *ah)
+{
+ if (AR_SREV_9340(ah))
+  INIT_INI_ARRAY(&ah->iniModesTxGain,
+          ar9340_cus227_tx_gain_table_1p0);
+}
+
 typedef void (*ath_txgain_tab)(struct ath_hw *ah);
 
 static void ar9003_tx_gain_table_apply(struct ath_hw *ah)
@@ -553,6 +706,7 @@ static void ar9003_tx_gain_table_apply(struct ath_hw *ah)
   ar9003_tx_gain_table_mode4,
   ar9003_tx_gain_table_mode5,
   ar9003_tx_gain_table_mode6,
+  ar9003_tx_gain_table_mode7,
  };
  int idx = ar9003_hw_get_tx_gain_idx(ah);
 
@@ -573,7 +727,7 @@ static void ar9003_rx_gain_table_mode0(struct ath_hw *ah)
  else if (AR_SREV_9340(ah))
   INIT_INI_ARRAY(&ah->iniModesRxGain,
     ar9340Common_rx_gain_table_1p0);
- else if (AR_SREV_9485_11(ah))
+ else if (AR_SREV_9485_11_OR_LATER(ah))
   INIT_INI_ARRAY(&ah->iniModesRxGain,
           ar9485_common_rx_gain_1_1);
  else if (AR_SREV_9550(ah)) {
@@ -581,12 +735,26 @@ static void ar9003_rx_gain_table_mode0(struct ath_hw *ah)
     ar955x_1p0_common_rx_gain_table);
   INIT_INI_ARRAY(&ah->ini_modes_rx_gain_bounds,
     ar955x_1p0_common_rx_gain_bounds);
+ } else if (AR_SREV_9531(ah)) {
+  INIT_INI_ARRAY(&ah->iniModesRxGain,
+          qca953x_1p0_common_rx_gain_table);
+  INIT_INI_ARRAY(&ah->ini_modes_rx_gain_bounds,
+          qca953x_1p0_common_rx_gain_bounds);
  } else if (AR_SREV_9580(ah))
   INIT_INI_ARRAY(&ah->iniModesRxGain,
     ar9580_1p0_rx_gain_table);
+ else if (AR_SREV_9462_21(ah))
+  INIT_INI_ARRAY(&ah->iniModesRxGain,
+    ar9462_2p1_common_rx_gain);
  else if (AR_SREV_9462_20(ah))
   INIT_INI_ARRAY(&ah->iniModesRxGain,
-    ar9462_common_rx_gain_table_2p0);
+    ar9462_2p0_common_rx_gain);
+ else if (AR_SREV_9565_11(ah))
+  INIT_INI_ARRAY(&ah->iniModesRxGain,
+          ar9565_1p1_Common_rx_gain_table);
+ else if (AR_SREV_9565(ah))
+  INIT_INI_ARRAY(&ah->iniModesRxGain,
+          ar9565_1p0_Common_rx_gain_table);
  else
   INIT_INI_ARRAY(&ah->iniModesRxGain,
     ar9300Common_rx_gain_table_2p2);
@@ -603,20 +771,31 @@ static void ar9003_rx_gain_table_mode1(struct ath_hw *ah)
  else if (AR_SREV_9340(ah))
   INIT_INI_ARRAY(&ah->iniModesRxGain,
    ar9340Common_wo_xlna_rx_gain_table_1p0);
- else if (AR_SREV_9485_11(ah))
+ else if (AR_SREV_9485_11_OR_LATER(ah))
   INIT_INI_ARRAY(&ah->iniModesRxGain,
    ar9485Common_wo_xlna_rx_gain_1_1);
+ else if (AR_SREV_9462_21(ah))
+  INIT_INI_ARRAY(&ah->iniModesRxGain,
+   ar9462_2p1_common_wo_xlna_rx_gain);
  else if (AR_SREV_9462_20(ah))
   INIT_INI_ARRAY(&ah->iniModesRxGain,
-   ar9462_common_wo_xlna_rx_gain_table_2p0);
+   ar9462_2p0_common_wo_xlna_rx_gain);
  else if (AR_SREV_9550(ah)) {
   INIT_INI_ARRAY(&ah->iniModesRxGain,
    ar955x_1p0_common_wo_xlna_rx_gain_table);
   INIT_INI_ARRAY(&ah->ini_modes_rx_gain_bounds,
    ar955x_1p0_common_wo_xlna_rx_gain_bounds);
+ } else if (AR_SREV_9531(ah)) {
+  INIT_INI_ARRAY(&ah->iniModesRxGain,
+          qca953x_1p0_common_wo_xlna_rx_gain_table);
+  INIT_INI_ARRAY(&ah->ini_modes_rx_gain_bounds,
+          qca953x_1p0_common_wo_xlna_rx_gain_bounds);
  } else if (AR_SREV_9580(ah))
   INIT_INI_ARRAY(&ah->iniModesRxGain,
    ar9580_1p0_wo_xlna_rx_gain_table);
+ else if (AR_SREV_9565_11(ah))
+  INIT_INI_ARRAY(&ah->iniModesRxGain,
+          ar9565_1p1_common_wo_xlna_rx_gain_table);
  else if (AR_SREV_9565(ah))
   INIT_INI_ARRAY(&ah->iniModesRxGain,
           ar9565_1p0_common_wo_xlna_rx_gain_table);
@@ -627,9 +806,40 @@ static void ar9003_rx_gain_table_mode1(struct ath_hw *ah)
 
 static void ar9003_rx_gain_table_mode2(struct ath_hw *ah)
 {
- if (AR_SREV_9462_20(ah))
+ if (AR_SREV_9462_21(ah)) {
+  INIT_INI_ARRAY(&ah->iniModesRxGain,
+          ar9462_2p1_common_mixed_rx_gain);
+  INIT_INI_ARRAY(&ah->ini_modes_rxgain_bb_core,
+          ar9462_2p1_baseband_core_mix_rxgain);
+  INIT_INI_ARRAY(&ah->ini_modes_rxgain_bb_postamble,
+          ar9462_2p1_baseband_postamble_mix_rxgain);
+  INIT_INI_ARRAY(&ah->ini_modes_rxgain_5g_xlna,
+          ar9462_2p1_baseband_postamble_5g_xlna);
+ } else if (AR_SREV_9462_20(ah)) {
+  INIT_INI_ARRAY(&ah->iniModesRxGain,
+          ar9462_2p0_common_mixed_rx_gain);
+  INIT_INI_ARRAY(&ah->ini_modes_rxgain_bb_core,
+          ar9462_2p0_baseband_core_mix_rxgain);
+  INIT_INI_ARRAY(&ah->ini_modes_rxgain_bb_postamble,
+          ar9462_2p0_baseband_postamble_mix_rxgain);
+  INIT_INI_ARRAY(&ah->ini_modes_rxgain_5g_xlna,
+          ar9462_2p0_baseband_postamble_5g_xlna);
+ }
+}
+
+static void ar9003_rx_gain_table_mode3(struct ath_hw *ah)
+{
+ if (AR_SREV_9462_21(ah)) {
   INIT_INI_ARRAY(&ah->iniModesRxGain,
-          ar9462_common_mixed_rx_gain_table_2p0);
+          ar9462_2p1_common_5g_xlna_only_rxgain);
+  INIT_INI_ARRAY(&ah->ini_modes_rxgain_5g_xlna,
+          ar9462_2p1_baseband_postamble_5g_xlna);
+ } else if (AR_SREV_9462_20(ah)) {
+  INIT_INI_ARRAY(&ah->iniModesRxGain,
+          ar9462_2p0_common_5g_xlna_only_rxgain);
+  INIT_INI_ARRAY(&ah->ini_modes_rxgain_5g_xlna,
+          ar9462_2p0_baseband_postamble_5g_xlna);
+ }
 }
 
 static void ar9003_rx_gain_table_apply(struct ath_hw *ah)
@@ -645,6 +855,9 @@ static void ar9003_rx_gain_table_apply(struct ath_hw *ah)
  case 2:
   ar9003_rx_gain_table_mode2(ah);
   break;
+ case 3:
+  ar9003_rx_gain_table_mode3(ah);
+  break;
  }
 }
 
@@ -667,35 +880,153 @@ static void ar9003_hw_init_mode_gain_regs(struct ath_hw *ah)
 static void ar9003_hw_configpcipowersave(struct ath_hw *ah,
       bool power_off)
 {
+ unsigned int i;
+ struct ar5416IniArray *array;
+
+ /*
+  * Increase L1 Entry Latency. Some WB222 boards don't have
+  * this change in eeprom/OTP.
+  *
+  */
+ if (AR_SREV_9462(ah)) {
+  u32 val = ah->config.aspm_l1_fix;
+  if ((val & 0xff000000) == 0x17000000) {
+   val &= 0x00ffffff;
+   val |= 0x27000000;
+   REG_WRITE(ah, 0x570c, val);
+  }
+ }
+
  /* Nothing to do on restore for 11N */
  if (!power_off /* !restore */) {
   /* set bit 19 to allow forcing of pcie core into L1 state */
   REG_SET_BIT(ah, AR_PCIE_PM_CTRL, AR_PCIE_PM_CTRL_ENA);
-
-  /* Several PCIe massages to ensure proper behaviour */
-  if (ah->config.pcie_waen)
-   REG_WRITE(ah, AR_WA, ah->config.pcie_waen);
-  else
-   REG_WRITE(ah, AR_WA, ah->WARegVal);
+  REG_WRITE(ah, AR_WA, ah->WARegVal);
  }
 
  /*
   * Configire PCIE after Ini init. SERDES values now come from ini file
   * This enables PCIe low power mode.
   */
- if (ah->config.pcieSerDesWrite) {
-  unsigned int i;
-  struct ar5416IniArray *array;
+ array = power_off ? &ah->iniPcieSerdes :
+  &ah->iniPcieSerdesLowPower;
 
-  array = power_off ? &ah->iniPcieSerdes :
-        &ah->iniPcieSerdesLowPower;
+ for (i = 0; i < array->ia_rows; i++) {
+  REG_WRITE(ah,
+     INI_RA(array, i, 0),
+     INI_RA(array, i, 1));
+ }
+}
+
+static void ar9003_hw_init_hang_checks(struct ath_hw *ah)
+{
+ /*
+  * All chips support detection of BB/MAC hangs.
+  */
+ ah->config.hw_hang_checks |= HW_BB_WATCHDOG;
+ ah->config.hw_hang_checks |= HW_MAC_HANG;
+
+ /*
+  * This is not required for AR9580 1.0
+  */
+ if (AR_SREV_9300_22(ah))
+  ah->config.hw_hang_checks |= HW_PHYRESTART_CLC_WAR;
+
+ if (AR_SREV_9330(ah))
+  ah->bb_watchdog_timeout_ms = 85;
+ else
+  ah->bb_watchdog_timeout_ms = 25;
+}
+
+/*
+ * MAC HW hang check
+ * =================
+ *
+ * Signature: dcu_chain_state is 0x6 and dcu_complete_state is 0x1.
+ *
+ * The state of each DCU chain (mapped to TX queues) is available from these
+ * DMA debug registers:
+ *
+ * Chain 0 state : Bits 4:0   of AR_DMADBG_4
+ * Chain 1 state : Bits 9:5   of AR_DMADBG_4
+ * Chain 2 state : Bits 14:10 of AR_DMADBG_4
+ * Chain 3 state : Bits 19:15 of AR_DMADBG_4
+ * Chain 4 state : Bits 24:20 of AR_DMADBG_4
+ * Chain 5 state : Bits 29:25 of AR_DMADBG_4
+ * Chain 6 state : Bits 4:0   of AR_DMADBG_5
+ * Chain 7 state : Bits 9:5   of AR_DMADBG_5
+ * Chain 8 state : Bits 14:10 of AR_DMADBG_5
+ * Chain 9 state : Bits 19:15 of AR_DMADBG_5
+ *
+ * The DCU chain state "0x6" means "WAIT_FRDONE" - wait for TX frame to be done.
+ */
+
+#define NUM_STATUS_READS 50
+
+static bool ath9k_hw_verify_hang(struct ath_hw *ah, unsigned int queue)
+{
+ u32 dma_dbg_chain, dma_dbg_complete;
+ u8 dcu_chain_state, dcu_complete_state;
+ int i;
+
+ for (i = 0; i < NUM_STATUS_READS; i++) {
+  if (queue < 6)
+   dma_dbg_chain = REG_READ(ah, AR_DMADBG_4);
+  else
+   dma_dbg_chain = REG_READ(ah, AR_DMADBG_5);
+
+  dma_dbg_complete = REG_READ(ah, AR_DMADBG_6);
+
+  dcu_chain_state = (dma_dbg_chain >> (5 * queue)) & 0x1f;
+  dcu_complete_state = dma_dbg_complete & 0x3;
+
+  if ((dcu_chain_state != 0x6) || (dcu_complete_state != 0x1))
+   return false;
+ }
+
+ ath_dbg(ath9k_hw_common(ah), RESET,
+  "MAC Hang signature found for queue: %d\n", queue);
+
+ return true;
+}
+
+static bool ar9003_hw_detect_mac_hang(struct ath_hw *ah)
+{
+ u32 dma_dbg_4, dma_dbg_5, dma_dbg_6, chk_dbg;
+ u8 dcu_chain_state, dcu_complete_state;
+ bool dcu_wait_frdone = false;
+ unsigned long chk_dcu = 0;
+ unsigned int i = 0;
+
+ dma_dbg_4 = REG_READ(ah, AR_DMADBG_4);
+ dma_dbg_5 = REG_READ(ah, AR_DMADBG_5);
+ dma_dbg_6 = REG_READ(ah, AR_DMADBG_6);
+
+ dcu_complete_state = dma_dbg_6 & 0x3;
+ if (dcu_complete_state != 0x1)
+  goto exit;
+
+ for (i = 0; i < ATH9K_NUM_TX_QUEUES; i++) {
+  if (i < 6)
+   chk_dbg = dma_dbg_4;
+  else
+   chk_dbg = dma_dbg_5;
+
+  dcu_chain_state = (chk_dbg >> (5 * i)) & 0x1f;
+  if (dcu_chain_state == 0x6) {
+   dcu_wait_frdone = true;
+   chk_dcu |= BIT(i);
+  }
+ }
 
-  for (i = 0; i < array->ia_rows; i++) {
-   REG_WRITE(ah,
-      INI_RA(array, i, 0),
-      INI_RA(array, i, 1));
+ if ((dcu_complete_state == 0x1) && dcu_wait_frdone) {
+  for_each_set_bit(i, &chk_dcu, ATH9K_NUM_TX_QUEUES) {
+   if (ath9k_hw_verify_hang(ah, i))
+    return true;
   }
  }
+exit:
+ return false;
 }
 
 /* Sets up the AR9003 hardware familiy callbacks */
@@ -706,6 +1037,8 @@ void ar9003_hw_attach_ops(struct ath_hw *ah)
 
  ar9003_hw_init_mode_regs(ah);
  priv_ops->init_mode_gain_regs = ar9003_hw_init_mode_gain_regs;
+ priv_ops->init_hang_checks = ar9003_hw_init_hang_checks;
+ priv_ops->detect_mac_hang = ar9003_hw_detect_mac_hang;
 
  ops->config_pci_powersave = ar9003_hw_configpcipowersave;
 
diff --git a/drivers/net/wireless/ath/ath9k/ar9003_mac.c b/drivers/net/wireless/ath/ath9k/ar9003_mac.c
index 301bf72..729ffbf 100644
--- a/drivers/net/wireless/ath/ath9k/ar9003_mac.c
+++ b/drivers/net/wireless/ath/ath9k/ar9003_mac.c
@@ -175,7 +175,8 @@ static void ar9003_hw_set_desc_link(void *ds, u32 ds_link)
  ads->ctl10 |= ar9003_calc_ptr_chksum(ads);
 }
 
-static bool ar9003_hw_get_isr(struct ath_hw *ah, enum ath9k_int *masked)
+static bool ar9003_hw_get_isr(struct ath_hw *ah, enum ath9k_int *masked,
+         u32 *sync_cause_p)
 {
  u32 isr = 0;
  u32 mask2 = 0;
@@ -310,7 +311,8 @@ static bool ar9003_hw_get_isr(struct ath_hw *ah, enum ath9k_int *masked)
   ar9003_mci_get_isr(ah, masked);
 
  if (sync_cause) {
-  ath9k_debug_sync_cause(common, sync_cause);
+  if (sync_cause_p)
+   *sync_cause_p = sync_cause;
   fatal_int =
    (sync_cause &
     (AR_INTR_SYNC_HOST1_FATAL | AR_INTR_SYNC_HOST1_PERR))
@@ -469,18 +471,19 @@ int ath9k_hw_process_rxdesc_edma(struct ath_hw *ah, struct ath_rx_status *rxs,
 
  rxs->rs_status = 0;
  rxs->rs_flags =  0;
+ rxs->flag =  0;
 
  rxs->rs_datalen = rxsp->status2 & AR_DataLen;
  rxs->rs_tstamp =  rxsp->status3;
 
  /* XXX: Keycache */
  rxs->rs_rssi = MS(rxsp->status5, AR_RxRSSICombined);
- rxs->rs_rssi_ctl0 = MS(rxsp->status1, AR_RxRSSIAnt00);
- rxs->rs_rssi_ctl1 = MS(rxsp->status1, AR_RxRSSIAnt01);
- rxs->rs_rssi_ctl2 = MS(rxsp->status1, AR_RxRSSIAnt02);
- rxs->rs_rssi_ext0 = MS(rxsp->status5, AR_RxRSSIAnt10);
- rxs->rs_rssi_ext1 = MS(rxsp->status5, AR_RxRSSIAnt11);
- rxs->rs_rssi_ext2 = MS(rxsp->status5, AR_RxRSSIAnt12);
+ rxs->rs_rssi_ctl[0] = MS(rxsp->status1, AR_RxRSSIAnt00);
+ rxs->rs_rssi_ctl[1] = MS(rxsp->status1, AR_RxRSSIAnt01);
+ rxs->rs_rssi_ctl[2] = MS(rxsp->status1, AR_RxRSSIAnt02);
+ rxs->rs_rssi_ext[0] = MS(rxsp->status5, AR_RxRSSIAnt10);
+ rxs->rs_rssi_ext[1] = MS(rxsp->status5, AR_RxRSSIAnt11);
+ rxs->rs_rssi_ext[2] = MS(rxsp->status5, AR_RxRSSIAnt12);
 
  if (rxsp->status11 & AR_RxKeyIdxValid)
   rxs->rs_keyix = MS(rxsp->status11, AR_KeyIdx);
@@ -490,11 +493,12 @@ int ath9k_hw_process_rxdesc_edma(struct ath_hw *ah, struct ath_rx_status *rxs,
  rxs->rs_rate = MS(rxsp->status1, AR_RxRate);
  rxs->rs_more = (rxsp->status2 & AR_RxMore) ? 1 : 0;
 
+ rxs->rs_firstaggr = (rxsp->status11 & AR_RxFirstAggr) ? 1 : 0;
  rxs->rs_isaggr = (rxsp->status11 & AR_RxAggr) ? 1 : 0;
  rxs->rs_moreaggr = (rxsp->status11 & AR_RxMoreAggr) ? 1 : 0;
  rxs->rs_antenna = (MS(rxsp->status4, AR_RxAntenna) & 0x7);
- rxs->rs_flags  = (rxsp->status4 & AR_GI) ? ATH9K_RX_GI : 0;
- rxs->rs_flags  |= (rxsp->status4 & AR_2040) ? ATH9K_RX_2040 : 0;
+ rxs->flag  |= (rxsp->status4 & AR_GI) ? RX_FLAG_SHORT_GI : 0;
+ rxs->flag  |= (rxsp->status4 & AR_2040) ? RX_FLAG_40MHZ : 0;
 
  rxs->evm0 = rxsp->status6;
  rxs->evm1 = rxsp->status7;
diff --git a/drivers/net/wireless/ath/ath9k/ar9003_mci.c b/drivers/net/wireless/ath/ath9k/ar9003_mci.c
index 8dd0692..7b94a6c 100644
--- a/drivers/net/wireless/ath/ath9k/ar9003_mci.c
+++ b/drivers/net/wireless/ath/ath9k/ar9003_mci.c
@@ -753,9 +753,9 @@ int ar9003_mci_end_reset(struct ath_hw *ah, struct ath9k_channel *chan,
       1 << AR_PHY_TIMING_CONTROL4_DO_GAIN_DC_IQ_CAL_SHIFT);
 
  if (caldata) {
-  caldata->done_txiqcal_once = false;
-  caldata->done_txclcal_once = false;
-  caldata->rtt_done = false;
+  clear_bit(TXIQCAL_DONE, &caldata->cal_flags);
+  clear_bit(TXCLCAL_DONE, &caldata->cal_flags);
+  clear_bit(RTT_DONE, &caldata->cal_flags);
  }
 
  if (!ath9k_hw_init_cal(ah, chan))
diff --git a/drivers/net/wireless/ath/ath9k/ar9003_paprd.c b/drivers/net/wireless/ath/ath9k/ar9003_paprd.c
index 09c1f9d..6343cc9 100644
--- a/drivers/net/wireless/ath/ath9k/ar9003_paprd.c
+++ b/drivers/net/wireless/ath/ath9k/ar9003_paprd.c
@@ -454,6 +454,8 @@ static bool create_pa_curve(u32 *data_L, u32 *data_U, u32 *pa_table, u16 *gain)
   if (accum_cnt <= thresh_accum_cnt)
    continue;
 
+  max_index++;
+
   /* sum(tx amplitude) */
   accum_tx = ((data_L[i] >> 16) & 0xffff) |
       ((data_U[i] & 0x7ff) << 16);
@@ -468,20 +470,21 @@ static bool create_pa_curve(u32 *data_L, u32 *data_U, u32 *pa_table, u16 *gain)
 
   accum_tx <<= scale_factor;
   accum_rx <<= scale_factor;
-  x_est[i + 1] = (((accum_tx + accum_cnt) / accum_cnt) + 32) >>
-      scale_factor;
+  x_est[max_index] =
+   (((accum_tx + accum_cnt) / accum_cnt) + 32) >>
+   scale_factor;
 
-  Y[i + 1] = ((((accum_rx + accum_cnt) / accum_cnt) + 32) >>
+  Y[max_index] =
+   ((((accum_rx + accum_cnt) / accum_cnt) + 32) >>
        scale_factor) +
-       (1 << scale_factor) * max_index + 16;
+   (1 << scale_factor) * i + 16;
 
   if (accum_ang >= (1 << 26))
    accum_ang -= 1 << 27;
 
-  theta[i + 1] = ((accum_ang * (1 << scale_factor)) + accum_cnt) /
-      accum_cnt;
-
-  max_index++;
+  theta[max_index] =
+   ((accum_ang * (1 << scale_factor)) + accum_cnt) /
+   accum_cnt;
  }
 
  /*
diff --git a/drivers/net/wireless/ath/ath9k/ar9003_phy.c b/drivers/net/wireless/ath/ath9k/ar9003_phy.c
index 3457ca5..8927fc3 100644
--- a/drivers/net/wireless/ath/ath9k/ar9003_phy.c
+++ b/drivers/net/wireless/ath/ath9k/ar9003_phy.c
@@ -103,7 +103,7 @@ static int ar9003_hw_set_channel(struct ath_hw *ah, struct ath9k_channel *chan)
    } else {
     channelSel = CHANSEL_2G(freq) >> 1;
    }
-  } else if (AR_SREV_9550(ah)) {
+  } else if (AR_SREV_9550(ah) || AR_SREV_9531(ah)) {
    if (ah->is_clk_25mhz)
     div = 75;
    else
@@ -118,7 +118,7 @@ static int ar9003_hw_set_channel(struct ath_hw *ah, struct ath9k_channel *chan)
   /* Set to 2G mode */
   bMode = 1;
  } else {
-  if ((AR_SREV_9340(ah) || AR_SREV_9550(ah)) &&
+  if ((AR_SREV_9340(ah) || AR_SREV_9550(ah) || AR_SREV_9531(ah)) &&
       ah->is_clk_25mhz) {
    channelSel = freq / 75;
    chan_frac = ((freq % 75) * 0x20000) / 75;
@@ -551,8 +551,7 @@ static void ar9003_hw_set_channel_regs(struct ath_hw *ah,
  if (IS_CHAN_HT40(chan)) {
   phymode |= AR_PHY_GC_DYN2040_EN;
   /* Configure control (primary) channel at +-10MHz */
-  if ((chan->chanmode == CHANNEL_A_HT40PLUS) ||
-      (chan->chanmode == CHANNEL_G_HT40PLUS))
+  if (IS_CHAN_HT40PLUS(chan))
    phymode |= AR_PHY_GC_DYN2040_PRI_CH;
 
  }
@@ -565,7 +564,7 @@ static void ar9003_hw_set_channel_regs(struct ath_hw *ah,
  REG_WRITE(ah, AR_PHY_GEN_CTRL, phymode);
 
  /* Configure MAC for 20/40 operation */
- ath9k_hw_set11nmac2040(ah);
+ ath9k_hw_set11nmac2040(ah, chan);
 
  /* global transmit timeout (25 TUs default)*/
  REG_WRITE(ah, AR_GTXTO, 25 << AR_GTXTO_TIMEOUT_LIMIT_S);
@@ -627,11 +626,27 @@ static void ar9003_hw_override_ini(struct ath_hw *ah)
   * MAC addr only will fail.
   */
  val = REG_READ(ah, AR_PCU_MISC_MODE2) & (~AR_ADHOC_MCAST_KEYID_ENABLE);
- REG_WRITE(ah, AR_PCU_MISC_MODE2,
-    val | AR_AGG_WEP_ENABLE_FIX | AR_AGG_WEP_ENABLE);
+ val |= AR_AGG_WEP_ENABLE_FIX |
+        AR_AGG_WEP_ENABLE |
+        AR_PCU_MISC_MODE2_CFP_IGNORE;
+ REG_WRITE(ah, AR_PCU_MISC_MODE2, val);
 
- REG_SET_BIT(ah, AR_PHY_CCK_DETECT,
-      AR_PHY_CCK_DETECT_BB_ENABLE_ANT_FAST_DIV);
+ if (AR_SREV_9462(ah) || AR_SREV_9565(ah)) {
+  REG_WRITE(ah, AR_GLB_SWREG_DISCONT_MODE,
+     AR_GLB_SWREG_DISCONT_EN_BT_WLAN);
+
+  if (REG_READ_FIELD(ah, AR_PHY_TX_IQCAL_CONTROL_0,
+       AR_PHY_TX_IQCAL_CONTROL_0_ENABLE_TXIQ_CAL))
+   ah->enabled_cals |= TX_IQ_CAL;
+  else
+   ah->enabled_cals &= ~TX_IQ_CAL;
+
+ }
+
+ if (REG_READ(ah, AR_PHY_CL_CAL_CTL) & AR_PHY_CL_CAL_ENABLE)
+  ah->enabled_cals |= TX_CL_CAL;
+ else
+  ah->enabled_cals &= ~TX_CL_CAL;
 }
 
 static void ar9003_hw_prog_ini(struct ath_hw *ah,
@@ -667,43 +682,72 @@ static int ar9550_hw_get_modes_txgain_index(struct ath_hw *ah,
 {
  int ret;
 
- switch (chan->chanmode) {
- case CHANNEL_A:
- case CHANNEL_A_HT20:
-  if (chan->channel <= 5350)
-   ret = 1;
-  else if ((chan->channel > 5350) && (chan->channel <= 5600))
-   ret = 3;
+ if (IS_CHAN_2GHZ(chan)) {
+  if (IS_CHAN_HT40(chan))
+   return 7;
   else
-   ret = 5;
-  break;
+   return 8;
+ }
 
- case CHANNEL_A_HT40PLUS:
- case CHANNEL_A_HT40MINUS:
-  if (chan->channel <= 5350)
-   ret = 2;
-  else if ((chan->channel > 5350) && (chan->channel <= 5600))
-   ret = 4;
-  else
-   ret = 6;
-  break;
+ if (chan->channel <= 5350)
+  ret = 1;
+ else if ((chan->channel > 5350) && (chan->channel <= 5600))
+  ret = 3;
+ else
+  ret = 5;
 
- case CHANNEL_G:
- case CHANNEL_G_HT20:
- case CHANNEL_B:
-  ret = 8;
-  break;
+ if (IS_CHAN_HT40(chan))
+  ret++;
 
- case CHANNEL_G_HT40PLUS:
- case CHANNEL_G_HT40MINUS:
-  ret = 7;
-  break;
+ return ret;
+}
 
- default:
-  ret = -EINVAL;
+static void ar9003_doubler_fix(struct ath_hw *ah)
+{
+ if (AR_SREV_9300(ah) || AR_SREV_9580(ah) || AR_SREV_9550(ah)) {
+  REG_RMW(ah, AR_PHY_65NM_CH0_RXTX2,
+   1 << AR_PHY_65NM_CH0_RXTX2_SYNTHON_MASK_S |
+   1 << AR_PHY_65NM_CH0_RXTX2_SYNTHOVR_MASK_S, 0);
+  REG_RMW(ah, AR_PHY_65NM_CH1_RXTX2,
+   1 << AR_PHY_65NM_CH0_RXTX2_SYNTHON_MASK_S |
+   1 << AR_PHY_65NM_CH0_RXTX2_SYNTHOVR_MASK_S, 0);
+  REG_RMW(ah, AR_PHY_65NM_CH2_RXTX2,
+   1 << AR_PHY_65NM_CH0_RXTX2_SYNTHON_MASK_S |
+   1 << AR_PHY_65NM_CH0_RXTX2_SYNTHOVR_MASK_S, 0);
+
+  udelay(200);
+
+  REG_CLR_BIT(ah, AR_PHY_65NM_CH0_RXTX2,
+       AR_PHY_65NM_CH0_RXTX2_SYNTHON_MASK);
+  REG_CLR_BIT(ah, AR_PHY_65NM_CH1_RXTX2,
+       AR_PHY_65NM_CH0_RXTX2_SYNTHON_MASK);
+  REG_CLR_BIT(ah, AR_PHY_65NM_CH2_RXTX2,
+       AR_PHY_65NM_CH0_RXTX2_SYNTHON_MASK);
+
+  udelay(1);
+
+  REG_RMW_FIELD(ah, AR_PHY_65NM_CH0_RXTX2,
+         AR_PHY_65NM_CH0_RXTX2_SYNTHON_MASK, 1);
+  REG_RMW_FIELD(ah, AR_PHY_65NM_CH1_RXTX2,
+         AR_PHY_65NM_CH0_RXTX2_SYNTHON_MASK, 1);
+  REG_RMW_FIELD(ah, AR_PHY_65NM_CH2_RXTX2,
+         AR_PHY_65NM_CH0_RXTX2_SYNTHON_MASK, 1);
+
+  udelay(200);
+
+  REG_RMW_FIELD(ah, AR_PHY_65NM_CH0_SYNTH12,
+         AR_PHY_65NM_CH0_SYNTH12_VREFMUL3, 0xf);
+
+  REG_RMW(ah, AR_PHY_65NM_CH0_RXTX2, 0,
+   1 << AR_PHY_65NM_CH0_RXTX2_SYNTHON_MASK_S |
+   1 << AR_PHY_65NM_CH0_RXTX2_SYNTHOVR_MASK_S);
+  REG_RMW(ah, AR_PHY_65NM_CH1_RXTX2, 0,
+   1 << AR_PHY_65NM_CH0_RXTX2_SYNTHON_MASK_S |
+   1 << AR_PHY_65NM_CH0_RXTX2_SYNTHOVR_MASK_S);
+  REG_RMW(ah, AR_PHY_65NM_CH2_RXTX2, 0,
+   1 << AR_PHY_65NM_CH0_RXTX2_SYNTHON_MASK_S |
+   1 << AR_PHY_65NM_CH0_RXTX2_SYNTHOVR_MASK_S);
  }
-
- return ret;
 }
 
 static int ar9003_hw_process_ini(struct ath_hw *ah,
@@ -712,49 +756,66 @@ static int ar9003_hw_process_ini(struct ath_hw *ah,
  unsigned int regWrites = 0, i;
  u32 modesIndex;
 
- switch (chan->chanmode) {
- case CHANNEL_A:
- case CHANNEL_A_HT20:
-  modesIndex = 1;
-  break;
- case CHANNEL_A_HT40PLUS:
- case CHANNEL_A_HT40MINUS:
-  modesIndex = 2;
-  break;
- case CHANNEL_G:
- case CHANNEL_G_HT20:
- case CHANNEL_B:
-  modesIndex = 4;
-  break;
- case CHANNEL_G_HT40PLUS:
- case CHANNEL_G_HT40MINUS:
-  modesIndex = 3;
-  break;
-
- default:
-  return -EINVAL;
- }
+ if (IS_CHAN_5GHZ(chan))
+  modesIndex = IS_CHAN_HT40(chan) ? 2 : 1;
+ else
+  modesIndex = IS_CHAN_HT40(chan) ? 3 : 4;
 
+ /*
+  * SOC, MAC, BB, RADIO initvals.
+  */
  for (i = 0; i < ATH_INI_NUM_SPLIT; i++) {
   ar9003_hw_prog_ini(ah, &ah->iniSOC[i], modesIndex);
   ar9003_hw_prog_ini(ah, &ah->iniMac[i], modesIndex);
   ar9003_hw_prog_ini(ah, &ah->iniBB[i], modesIndex);
   ar9003_hw_prog_ini(ah, &ah->iniRadio[i], modesIndex);
-  if (i == ATH_INI_POST && AR_SREV_9462_20(ah))
+  if (i == ATH_INI_POST && AR_SREV_9462_20_OR_LATER(ah))
    ar9003_hw_prog_ini(ah,
         &ah->ini_radio_post_sys2ant,
         modesIndex);
  }
 
+ ar9003_doubler_fix(ah);
+
+ /*
+  * RXGAIN initvals.
+  */
  REG_WRITE_ARRAY(&ah->iniModesRxGain, 1, regWrites);
+
+ if (AR_SREV_9462_20_OR_LATER(ah)) {
+  /*
+   * CUS217 mix LNA mode.
+   */
+  if (ar9003_hw_get_rx_gain_idx(ah) == 2) {
+   REG_WRITE_ARRAY(&ah->ini_modes_rxgain_bb_core,
+     1, regWrites);
+   REG_WRITE_ARRAY(&ah->ini_modes_rxgain_bb_postamble,
+     modesIndex, regWrites);
+  }
+
+  /*
+   * 5G-XLNA
+   */
+  if ((ar9003_hw_get_rx_gain_idx(ah) == 2) ||
+      (ar9003_hw_get_rx_gain_idx(ah) == 3)) {
+   REG_WRITE_ARRAY(&ah->ini_modes_rxgain_5g_xlna,
+     modesIndex, regWrites);
+  }
+ }
+
  if (AR_SREV_9550(ah))
   REG_WRITE_ARRAY(&ah->ini_modes_rx_gain_bounds, modesIndex,
     regWrites);
 
- if (AR_SREV_9550(ah)) {
-  int modes_txgain_index;
+ /*
+  * TXGAIN initvals.
+  */
+ if (AR_SREV_9550(ah) || AR_SREV_9531(ah)) {
+  int modes_txgain_index = 1;
+
+  if (AR_SREV_9550(ah))
+   modes_txgain_index = ar9550_hw_get_modes_txgain_index(ah, chan);
 
-  modes_txgain_index = ar9550_hw_get_modes_txgain_index(ah, chan);
   if (modes_txgain_index < 0)
    return -EINVAL;
 
@@ -772,34 +833,23 @@ static int ar9003_hw_process_ini(struct ath_hw *ah,
   REG_WRITE_ARRAY(&ah->iniModesFastClock,
     modesIndex, regWrites);
 
+ /*
+  * Clock frequency initvals.
+  */
  REG_WRITE_ARRAY(&ah->iniAdditional, 1, regWrites);
 
+ /*
+  * JAPAN regulatory.
+  */
  if (chan->channel == 2484)
   ar9003_hw_prog_ini(ah, &ah->iniCckfirJapan2484, 1);
 
- if (AR_SREV_9462(ah) || AR_SREV_9565(ah))
-  REG_WRITE(ah, AR_GLB_SWREG_DISCONT_MODE,
-     AR_GLB_SWREG_DISCONT_EN_BT_WLAN);
-
  ah->modes_index = modesIndex;
  ar9003_hw_override_ini(ah);
  ar9003_hw_set_channel_regs(ah, chan);
  ar9003_hw_set_chain_masks(ah, ah->rxchainmask, ah->txchainmask);
  ath9k_hw_apply_txpower(ah, chan, false);
 
- if (AR_SREV_9462(ah) || AR_SREV_9565(ah)) {
-  if (REG_READ_FIELD(ah, AR_PHY_TX_IQCAL_CONTROL_0,
-       AR_PHY_TX_IQCAL_CONTROL_0_ENABLE_TXIQ_CAL))
-   ah->enabled_cals |= TX_IQ_CAL;
-  else
-   ah->enabled_cals &= ~TX_IQ_CAL;
-
-  if (REG_READ(ah, AR_PHY_CL_CAL_CTL) & AR_PHY_CL_CAL_ENABLE)
-   ah->enabled_cals |= TX_CL_CAL;
-  else
-   ah->enabled_cals &= ~TX_CL_CAL;
- }
-
  return 0;
 }
 
@@ -811,15 +861,13 @@ static void ar9003_hw_set_rfmode(struct ath_hw *ah,
  if (chan == NULL)
   return;
 
- rfMode |= (IS_CHAN_B(chan) || IS_CHAN_G(chan))
-  ? AR_PHY_MODE_DYNAMIC : AR_PHY_MODE_OFDM;
+ if (IS_CHAN_2GHZ(chan))
+  rfMode |= AR_PHY_MODE_DYNAMIC;
+ else
+  rfMode |= AR_PHY_MODE_OFDM;
 
  if (IS_CHAN_A_FAST_CLOCK(ah, chan))
   rfMode |= (AR_PHY_MODE_DYNAMIC | AR_PHY_MODE_DYN_CCK_DISABLE);
- if (IS_CHAN_QUARTER_RATE(chan))
-  rfMode |= AR_PHY_MODE_QUARTER;
- if (IS_CHAN_HALF_RATE(chan))
-  rfMode |= AR_PHY_MODE_HALF;
 
  if (rfMode & (AR_PHY_MODE_QUARTER | AR_PHY_MODE_HALF))
   REG_RMW_FIELD(ah, AR_PHY_FRAME_CTL,
@@ -905,7 +953,12 @@ static bool ar9003_hw_ani_control(struct ath_hw *ah,
 {
  struct ath_common *common = ath9k_hw_common(ah);
  struct ath9k_channel *chan = ah->curchan;
- struct ar5416AniState *aniState = &chan->ani;
+ struct ar5416AniState *aniState = &ah->ani;
+ int m1ThreshLow, m2ThreshLow;
+ int m1Thresh, m2Thresh;
+ int m2CountThr, m2CountThrLow;
+ int m1ThreshLowExt, m2ThreshLowExt;
+ int m1ThreshExt, m2ThreshExt;
  s32 value, value2;
 
  switch (cmd & ah->ani_function) {
@@ -919,6 +972,61 @@ static bool ar9003_hw_ani_control(struct ath_hw *ah,
    */
   u32 on = param ? 1 : 0;
 
+  if (AR_SREV_9462(ah) || AR_SREV_9565(ah))
+   goto skip_ws_det;
+
+  m1ThreshLow = on ?
+   aniState->iniDef.m1ThreshLow : m1ThreshLow_off;
+  m2ThreshLow = on ?
+   aniState->iniDef.m2ThreshLow : m2ThreshLow_off;
+  m1Thresh = on ?
+   aniState->iniDef.m1Thresh : m1Thresh_off;
+  m2Thresh = on ?
+   aniState->iniDef.m2Thresh : m2Thresh_off;
+  m2CountThr = on ?
+   aniState->iniDef.m2CountThr : m2CountThr_off;
+  m2CountThrLow = on ?
+   aniState->iniDef.m2CountThrLow : m2CountThrLow_off;
+  m1ThreshLowExt = on ?
+   aniState->iniDef.m1ThreshLowExt : m1ThreshLowExt_off;
+  m2ThreshLowExt = on ?
+   aniState->iniDef.m2ThreshLowExt : m2ThreshLowExt_off;
+  m1ThreshExt = on ?
+   aniState->iniDef.m1ThreshExt : m1ThreshExt_off;
+  m2ThreshExt = on ?
+   aniState->iniDef.m2ThreshExt : m2ThreshExt_off;
+
+  REG_RMW_FIELD(ah, AR_PHY_SFCORR_LOW,
+         AR_PHY_SFCORR_LOW_M1_THRESH_LOW,
+         m1ThreshLow);
+  REG_RMW_FIELD(ah, AR_PHY_SFCORR_LOW,
+         AR_PHY_SFCORR_LOW_M2_THRESH_LOW,
+         m2ThreshLow);
+  REG_RMW_FIELD(ah, AR_PHY_SFCORR,
+         AR_PHY_SFCORR_M1_THRESH,
+         m1Thresh);
+  REG_RMW_FIELD(ah, AR_PHY_SFCORR,
+         AR_PHY_SFCORR_M2_THRESH,
+         m2Thresh);
+  REG_RMW_FIELD(ah, AR_PHY_SFCORR,
+         AR_PHY_SFCORR_M2COUNT_THR,
+         m2CountThr);
+  REG_RMW_FIELD(ah, AR_PHY_SFCORR_LOW,
+         AR_PHY_SFCORR_LOW_M2COUNT_THR_LOW,
+         m2CountThrLow);
+  REG_RMW_FIELD(ah, AR_PHY_SFCORR_EXT,
+         AR_PHY_SFCORR_EXT_M1_THRESH_LOW,
+         m1ThreshLowExt);
+  REG_RMW_FIELD(ah, AR_PHY_SFCORR_EXT,
+         AR_PHY_SFCORR_EXT_M2_THRESH_LOW,
+         m2ThreshLowExt);
+  REG_RMW_FIELD(ah, AR_PHY_SFCORR_EXT,
+         AR_PHY_SFCORR_EXT_M1_THRESH,
+         m1ThreshExt);
+  REG_RMW_FIELD(ah, AR_PHY_SFCORR_EXT,
+         AR_PHY_SFCORR_EXT_M2_THRESH,
+         m2ThreshExt);
+skip_ws_det:
   if (on)
    REG_SET_BIT(ah, AR_PHY_SFCORR_LOW,
         AR_PHY_SFCORR_LOW_USE_SELF_CORR_LOW);
@@ -1097,8 +1205,6 @@ static bool ar9003_hw_ani_control(struct ath_hw *ah,
   }
  break;
  }
- case ATH9K_ANI_PRESENT:
-  break;
  default:
   ath_dbg(common, ANI, "invalid cmd %u\n", cmd);
   return false;
@@ -1177,15 +1283,14 @@ static void ar9003_hw_ani_cache_ini_regs(struct ath_hw *ah)
  struct ath9k_ani_default *iniDef;
  u32 val;
 
- aniState = &ah->curchan->ani;
+ aniState = &ah->ani;
  iniDef = &aniState->iniDef;
 
- ath_dbg(common, ANI, "ver %d.%d opmode %u chan %d Mhz/0x%x\n",
+ ath_dbg(common, ANI, "ver %d.%d opmode %u chan %d Mhz\n",
   ah->hw_version.macVersion,
   ah->hw_version.macRev,
   ah->opmode,
-  chan->channel,
-  chan->channelFlags);
+  chan->channel);
 
  val = REG_READ(ah, AR_PHY_SFCORR);
  iniDef->m1Thresh = MS(val, AR_PHY_SFCORR_M1_THRESH);
@@ -1218,13 +1323,14 @@ static void ar9003_hw_ani_cache_ini_regs(struct ath_hw *ah)
  /* these levels just got reset to defaults by the INI */
  aniState->spurImmunityLevel = ATH9K_ANI_SPUR_IMMUNE_LVL;
  aniState->firstepLevel = ATH9K_ANI_FIRSTEP_LVL;
- aniState->ofdmWeakSigDetect = ATH9K_ANI_USE_OFDM_WEAK_SIG;
+ aniState->ofdmWeakSigDetect = true;
  aniState->mrcCCK = true;
 }
 
 static void ar9003_hw_set_radar_params(struct ath_hw *ah,
            struct ath_hw_radar_conf *conf)
 {
+ unsigned int regWrites = 0;
  u32 radar_0 = 0, radar_1 = 0;
 
  if (!conf) {
@@ -1251,6 +1357,11 @@ static void ar9003_hw_set_radar_params(struct ath_hw *ah,
   REG_SET_BIT(ah, AR_PHY_RADAR_EXT, AR_PHY_RADAR_EXT_ENA);
  else
   REG_CLR_BIT(ah, AR_PHY_RADAR_EXT, AR_PHY_RADAR_EXT_ENA);
+
+ if (AR_SREV_9300(ah) || AR_SREV_9340(ah) || AR_SREV_9580(ah)) {
+  REG_WRITE_ARRAY(&ah->ini_dfs,
+    IS_CHAN_HT40(ah->curchan) ? 2 : 1, regWrites);
+ }
 }
 
 static void ar9003_hw_set_radar_conf(struct ath_hw *ah)
@@ -1281,15 +1392,19 @@ static void ar9003_hw_antdiv_comb_conf_get(struct ath_hw *ah,
       AR_PHY_ANT_FAST_DIV_BIAS_S;
 
  if (AR_SREV_9330_11(ah)) {
+  antconf->lna1_lna2_switch_delta = -1;
   antconf->lna1_lna2_delta = -9;
   antconf->div_group = 1;
  } else if (AR_SREV_9485(ah)) {
+  antconf->lna1_lna2_switch_delta = -1;
   antconf->lna1_lna2_delta = -9;
   antconf->div_group = 2;
  } else if (AR_SREV_9565(ah)) {
-  antconf->lna1_lna2_delta = -3;
+  antconf->lna1_lna2_switch_delta = 3;
+  antconf->lna1_lna2_delta = -9;
   antconf->div_group = 3;
  } else {
+  antconf->lna1_lna2_switch_delta = -1;
   antconf->lna1_lna2_delta = -3;
   antconf->div_group = 0;
  }
@@ -1320,65 +1435,118 @@ static void ar9003_hw_antdiv_comb_conf_set(struct ath_hw *ah,
  REG_WRITE(ah, AR_PHY_MC_GAIN_CTRL, regval);
 }
 
-static void ar9003_hw_antctrl_shared_chain_lnadiv(struct ath_hw *ah,
-        bool enable)
+#ifdef CONFIG_ATH9K_BTCOEX_SUPPORT
+
+static void ar9003_hw_set_bt_ant_diversity(struct ath_hw *ah, bool enable)
 {
+ struct ath9k_hw_capabilities *pCap = &ah->caps;
  u8 ant_div_ctl1;
  u32 regval;
 
- if (!AR_SREV_9565(ah))
+ if (!AR_SREV_9485(ah) && !AR_SREV_9565(ah))
   return;
 
- ah->shared_chain_lnadiv = enable;
+ if (AR_SREV_9485(ah)) {
+  regval = ar9003_hw_ant_ctrl_common_2_get(ah,
+       IS_CHAN_2GHZ(ah->curchan));
+  if (enable) {
+   regval &= ~AR_SWITCH_TABLE_COM2_ALL;
+   regval |= ah->config.ant_ctrl_comm2g_switch_enable;
+  }
+  REG_RMW_FIELD(ah, AR_PHY_SWITCH_COM_2,
+         AR_SWITCH_TABLE_COM2_ALL, regval);
+ }
+
  ant_div_ctl1 = ah->eep_ops->get_eeprom(ah, EEP_ANT_DIV_CTL1);
 
+ /*
+  * Set MAIN/ALT LNA conf.
+  * Set MAIN/ALT gain_tb.
+  */
  regval = REG_READ(ah, AR_PHY_MC_GAIN_CTRL);
  regval &= (~AR_ANT_DIV_CTRL_ALL);
  regval |= (ant_div_ctl1 & 0x3f) << AR_ANT_DIV_CTRL_ALL_S;
- regval &= ~AR_PHY_ANT_DIV_LNADIV;
- regval |= ((ant_div_ctl1 >> 6) & 0x1) << AR_PHY_ANT_DIV_LNADIV_S;
-
- if (enable)
-  regval |= AR_ANT_DIV_ENABLE;
-
  REG_WRITE(ah, AR_PHY_MC_GAIN_CTRL, regval);
 
- regval = REG_READ(ah, AR_PHY_CCK_DETECT);
- regval &= ~AR_FAST_DIV_ENABLE;
- regval |= ((ant_div_ctl1 >> 7) & 0x1) << AR_FAST_DIV_ENABLE_S;
-
- if (enable)
-  regval |= AR_FAST_DIV_ENABLE;
+ if (AR_SREV_9485_11_OR_LATER(ah)) {
+  /*
+   * Enable LNA diversity.
+   */
+  regval = REG_READ(ah, AR_PHY_MC_GAIN_CTRL);
+  regval &= ~AR_PHY_ANT_DIV_LNADIV;
+  regval |= ((ant_div_ctl1 >> 6) & 0x1) << AR_PHY_ANT_DIV_LNADIV_S;
+  if (enable)
+   regval |= AR_ANT_DIV_ENABLE;
 
- REG_WRITE(ah, AR_PHY_CCK_DETECT, regval);
+  REG_WRITE(ah, AR_PHY_MC_GAIN_CTRL, regval);
 
- if (enable) {
-  REG_SET_BIT(ah, AR_PHY_MC_GAIN_CTRL,
-       (1 << AR_PHY_ANT_SW_RX_PROT_S));
-  if (ah->curchan && IS_CHAN_2GHZ(ah->curchan))
+  /*
+   * Enable fast antenna diversity.
+   */
+  regval = REG_READ(ah, AR_PHY_CCK_DETECT);
+  regval &= ~AR_FAST_DIV_ENABLE;
+  regval |= ((ant_div_ctl1 >> 7) & 0x1) << AR_FAST_DIV_ENABLE_S;
+  if (enable)
+   regval |= AR_FAST_DIV_ENABLE;
+
+  REG_WRITE(ah, AR_PHY_CCK_DETECT, regval);
+
+  if (pCap->hw_caps & ATH9K_HW_CAP_ANT_DIV_COMB) {
+   regval = REG_READ(ah, AR_PHY_MC_GAIN_CTRL);
+   regval &= (~(AR_PHY_ANT_DIV_MAIN_LNACONF |
+         AR_PHY_ANT_DIV_ALT_LNACONF |
+         AR_PHY_ANT_DIV_ALT_GAINTB |
+         AR_PHY_ANT_DIV_MAIN_GAINTB));
+   /*
+    * Set MAIN to LNA1 and ALT to LNA2 at the
+    * beginning.
+    */
+   regval |= (ATH_ANT_DIV_COMB_LNA1 <<
+       AR_PHY_ANT_DIV_MAIN_LNACONF_S);
+   regval |= (ATH_ANT_DIV_COMB_LNA2 <<
+       AR_PHY_ANT_DIV_ALT_LNACONF_S);
+   REG_WRITE(ah, AR_PHY_MC_GAIN_CTRL, regval);
+  }
+ } else if (AR_SREV_9565(ah)) {
+  if (enable) {
+   REG_SET_BIT(ah, AR_PHY_MC_GAIN_CTRL,
+        AR_ANT_DIV_ENABLE);
+   REG_SET_BIT(ah, AR_PHY_MC_GAIN_CTRL,
+        (1 << AR_PHY_ANT_SW_RX_PROT_S));
+   REG_SET_BIT(ah, AR_PHY_CCK_DETECT,
+        AR_FAST_DIV_ENABLE);
    REG_SET_BIT(ah, AR_PHY_RESTART,
         AR_PHY_RESTART_ENABLE_DIV_M2FLAG);
-  REG_SET_BIT(ah, AR_BTCOEX_WL_LNADIV,
-       AR_BTCOEX_WL_LNADIV_FORCE_ON);
- } else {
-  REG_CLR_BIT(ah, AR_PHY_MC_GAIN_CTRL, AR_ANT_DIV_ENABLE);
-  REG_CLR_BIT(ah, AR_PHY_MC_GAIN_CTRL,
-       (1 << AR_PHY_ANT_SW_RX_PROT_S));
-  REG_CLR_BIT(ah, AR_PHY_CCK_DETECT, AR_FAST_DIV_ENABLE);
-  REG_CLR_BIT(ah, AR_BTCOEX_WL_LNADIV,
-       AR_BTCOEX_WL_LNADIV_FORCE_ON);
-
-  regval = REG_READ(ah, AR_PHY_MC_GAIN_CTRL);
-  regval &= ~(AR_PHY_ANT_DIV_MAIN_LNACONF |
-   AR_PHY_ANT_DIV_ALT_LNACONF |
-   AR_PHY_ANT_DIV_MAIN_GAINTB |
-   AR_PHY_ANT_DIV_ALT_GAINTB);
-  regval |= (AR_PHY_ANT_DIV_LNA1 << AR_PHY_ANT_DIV_MAIN_LNACONF_S);
-  regval |= (AR_PHY_ANT_DIV_LNA2 << AR_PHY_ANT_DIV_ALT_LNACONF_S);
-  REG_WRITE(ah, AR_PHY_MC_GAIN_CTRL, regval);
+   REG_SET_BIT(ah, AR_BTCOEX_WL_LNADIV,
+        AR_BTCOEX_WL_LNADIV_FORCE_ON);
+  } else {
+   REG_CLR_BIT(ah, AR_PHY_MC_GAIN_CTRL,
+        AR_ANT_DIV_ENABLE);
+   REG_CLR_BIT(ah, AR_PHY_MC_GAIN_CTRL,
+        (1 << AR_PHY_ANT_SW_RX_PROT_S));
+   REG_CLR_BIT(ah, AR_PHY_CCK_DETECT,
+        AR_FAST_DIV_ENABLE);
+   REG_CLR_BIT(ah, AR_PHY_RESTART,
+        AR_PHY_RESTART_ENABLE_DIV_M2FLAG);
+   REG_CLR_BIT(ah, AR_BTCOEX_WL_LNADIV,
+        AR_BTCOEX_WL_LNADIV_FORCE_ON);
+
+   regval = REG_READ(ah, AR_PHY_MC_GAIN_CTRL);
+   regval &= ~(AR_PHY_ANT_DIV_MAIN_LNACONF |
+        AR_PHY_ANT_DIV_ALT_LNACONF |
+        AR_PHY_ANT_DIV_MAIN_GAINTB |
+        AR_PHY_ANT_DIV_ALT_GAINTB);
+   regval |= (ATH_ANT_DIV_COMB_LNA1 <<
+       AR_PHY_ANT_DIV_MAIN_LNACONF_S);
+   regval |= (ATH_ANT_DIV_COMB_LNA2 <<
+       AR_PHY_ANT_DIV_ALT_LNACONF_S);
+   REG_WRITE(ah, AR_PHY_MC_GAIN_CTRL, regval);
+  }
  }
 }
 
+#endif
+
 static int ar9003_hw_fast_chan_change(struct ath_hw *ah,
           struct ath9k_channel *chan,
           u8 *ini_reloaded)
@@ -1386,28 +1554,10 @@ static int ar9003_hw_fast_chan_change(struct ath_hw *ah,
  unsigned int regWrites = 0;
  u32 modesIndex;
 
- switch (chan->chanmode) {
- case CHANNEL_A:
- case CHANNEL_A_HT20:
-  modesIndex = 1;
-  break;
- case CHANNEL_A_HT40PLUS:
- case CHANNEL_A_HT40MINUS:
-  modesIndex = 2;
-  break;
- case CHANNEL_G:
- case CHANNEL_G_HT20:
- case CHANNEL_B:
-  modesIndex = 4;
-  break;
- case CHANNEL_G_HT40PLUS:
- case CHANNEL_G_HT40MINUS:
-  modesIndex = 3;
-  break;
-
- default:
-  return -EINVAL;
- }
+ if (IS_CHAN_5GHZ(chan))
+  modesIndex = IS_CHAN_HT40(chan) ? 2 : 1;
+ else
+  modesIndex = IS_CHAN_HT40(chan) ? 3 : 4;
 
  if (modesIndex == ah->modes_index) {
   *ini_reloaded = false;
@@ -1419,12 +1569,24 @@ static int ar9003_hw_fast_chan_change(struct ath_hw *ah,
  ar9003_hw_prog_ini(ah, &ah->iniBB[ATH_INI_POST], modesIndex);
  ar9003_hw_prog_ini(ah, &ah->iniRadio[ATH_INI_POST], modesIndex);
 
- if (AR_SREV_9462_20(ah))
+ if (AR_SREV_9462_20_OR_LATER(ah))
   ar9003_hw_prog_ini(ah, &ah->ini_radio_post_sys2ant,
        modesIndex);
 
  REG_WRITE_ARRAY(&ah->iniModesTxGain, modesIndex, regWrites);
 
+ if (AR_SREV_9462_20_OR_LATER(ah)) {
+  /*
+   * CUS217 mix LNA mode.
+   */
+  if (ar9003_hw_get_rx_gain_idx(ah) == 2) {
+   REG_WRITE_ARRAY(&ah->ini_modes_rxgain_bb_core,
+     1, regWrites);
+   REG_WRITE_ARRAY(&ah->ini_modes_rxgain_bb_postamble,
+     modesIndex, regWrites);
+  }
+ }
+
  /*
   * For 5GHz channels requiring Fast Clock, apply
   * different modal values.
@@ -1435,7 +1597,11 @@ static int ar9003_hw_fast_chan_change(struct ath_hw *ah,
  if (AR_SREV_9565(ah))
   REG_WRITE_ARRAY(&ah->iniModesFastClock, 1, regWrites);
 
- REG_WRITE_ARRAY(&ah->iniAdditional, 1, regWrites);
+ /*
+  * JAPAN regulatory.
+  */
+ if (chan->channel == 2484)
+  ar9003_hw_prog_ini(ah, &ah->iniCckfirJapan2484, 1);
 
  ah->modes_index = modesIndex;
  *ini_reloaded = true;
@@ -1506,6 +1672,98 @@ static void ar9003_hw_spectral_scan_wait(struct ath_hw *ah)
  }
 }
 
+static void ar9003_hw_tx99_start(struct ath_hw *ah, u32 qnum)
+{
+ REG_SET_BIT(ah, AR_PHY_TEST, PHY_AGC_CLR);
+ REG_SET_BIT(ah, 0x9864, 0x7f000);
+ REG_SET_BIT(ah, 0x9924, 0x7f00fe);
+ REG_CLR_BIT(ah, AR_DIAG_SW, AR_DIAG_RX_DIS);
+ REG_WRITE(ah, AR_CR, AR_CR_RXD);
+ REG_WRITE(ah, AR_DLCL_IFS(qnum), 0);
+ REG_WRITE(ah, AR_D_GBL_IFS_SIFS, 20); /* 50 OK */
+ REG_WRITE(ah, AR_D_GBL_IFS_EIFS, 20);
+ REG_WRITE(ah, AR_TIME_OUT, 0x00000400);
+ REG_WRITE(ah, AR_DRETRY_LIMIT(qnum), 0xffffffff);
+ REG_SET_BIT(ah, AR_QMISC(qnum), AR_Q_MISC_DCU_EARLY_TERM_REQ);
+}
+
+static void ar9003_hw_tx99_stop(struct ath_hw *ah)
+{
+ REG_CLR_BIT(ah, AR_PHY_TEST, PHY_AGC_CLR);
+ REG_SET_BIT(ah, AR_DIAG_SW, AR_DIAG_RX_DIS);
+}
+
+static void ar9003_hw_tx99_set_txpower(struct ath_hw *ah, u8 txpower)
+{
+ static s16 p_pwr_array[ar9300RateSize] = { 0 };
+ unsigned int i;
+
+ if (txpower <= MAX_RATE_POWER) {
+  for (i = 0; i < ar9300RateSize; i++)
+   p_pwr_array[i] = txpower;
+ } else {
+  for (i = 0; i < ar9300RateSize; i++)
+   p_pwr_array[i] = MAX_RATE_POWER;
+ }
+
+ REG_WRITE(ah, 0xa458, 0);
+
+ REG_WRITE(ah, 0xa3c0,
+    ATH9K_POW_SM(p_pwr_array[ALL_TARGET_LEGACY_6_24], 24) |
+    ATH9K_POW_SM(p_pwr_array[ALL_TARGET_LEGACY_6_24], 16) |
+    ATH9K_POW_SM(p_pwr_array[ALL_TARGET_LEGACY_6_24],  8) |
+    ATH9K_POW_SM(p_pwr_array[ALL_TARGET_LEGACY_6_24],  0));
+ REG_WRITE(ah, 0xa3c4,
+    ATH9K_POW_SM(p_pwr_array[ALL_TARGET_LEGACY_54],  24) |
+    ATH9K_POW_SM(p_pwr_array[ALL_TARGET_LEGACY_48],  16) |
+    ATH9K_POW_SM(p_pwr_array[ALL_TARGET_LEGACY_36],   8) |
+    ATH9K_POW_SM(p_pwr_array[ALL_TARGET_LEGACY_6_24], 0));
+ REG_WRITE(ah, 0xa3c8,
+    ATH9K_POW_SM(p_pwr_array[ALL_TARGET_LEGACY_1L_5L], 24) |
+    ATH9K_POW_SM(p_pwr_array[ALL_TARGET_LEGACY_1L_5L], 16) |
+    ATH9K_POW_SM(p_pwr_array[ALL_TARGET_LEGACY_1L_5L],  0));
+ REG_WRITE(ah, 0xa3cc,
+    ATH9K_POW_SM(p_pwr_array[ALL_TARGET_LEGACY_11S],   24) |
+    ATH9K_POW_SM(p_pwr_array[ALL_TARGET_LEGACY_11L],   16) |
+    ATH9K_POW_SM(p_pwr_array[ALL_TARGET_LEGACY_5S],     8) |
+    ATH9K_POW_SM(p_pwr_array[ALL_TARGET_LEGACY_1L_5L],  0));
+ REG_WRITE(ah, 0xa3d0,
+    ATH9K_POW_SM(p_pwr_array[ALL_TARGET_HT20_5],  24) |
+    ATH9K_POW_SM(p_pwr_array[ALL_TARGET_HT20_4],  16) |
+    ATH9K_POW_SM(p_pwr_array[ALL_TARGET_HT20_1_3_9_11_17_19], 8)|
+    ATH9K_POW_SM(p_pwr_array[ALL_TARGET_HT20_0_8_16], 0));
+ REG_WRITE(ah, 0xa3d4,
+    ATH9K_POW_SM(p_pwr_array[ALL_TARGET_HT20_13], 24) |
+    ATH9K_POW_SM(p_pwr_array[ALL_TARGET_HT20_12], 16) |
+    ATH9K_POW_SM(p_pwr_array[ALL_TARGET_HT20_7],   8) |
+    ATH9K_POW_SM(p_pwr_array[ALL_TARGET_HT20_6],   0));
+ REG_WRITE(ah, 0xa3e4,
+    ATH9K_POW_SM(p_pwr_array[ALL_TARGET_HT20_21], 24) |
+    ATH9K_POW_SM(p_pwr_array[ALL_TARGET_HT20_20], 16) |
+    ATH9K_POW_SM(p_pwr_array[ALL_TARGET_HT20_15],  8) |
+    ATH9K_POW_SM(p_pwr_array[ALL_TARGET_HT20_14],  0));
+ REG_WRITE(ah, 0xa3e8,
+    ATH9K_POW_SM(p_pwr_array[ALL_TARGET_HT40_23], 24) |
+    ATH9K_POW_SM(p_pwr_array[ALL_TARGET_HT40_22], 16) |
+    ATH9K_POW_SM(p_pwr_array[ALL_TARGET_HT20_23],  8) |
+    ATH9K_POW_SM(p_pwr_array[ALL_TARGET_HT20_22],  0));
+ REG_WRITE(ah, 0xa3d8,
+    ATH9K_POW_SM(p_pwr_array[ALL_TARGET_HT40_5], 24) |
+    ATH9K_POW_SM(p_pwr_array[ALL_TARGET_HT40_4], 16) |
+    ATH9K_POW_SM(p_pwr_array[ALL_TARGET_HT40_1_3_9_11_17_19], 8) |
+    ATH9K_POW_SM(p_pwr_array[ALL_TARGET_HT40_0_8_16], 0));
+ REG_WRITE(ah, 0xa3dc,
+    ATH9K_POW_SM(p_pwr_array[ALL_TARGET_HT40_13], 24) |
+    ATH9K_POW_SM(p_pwr_array[ALL_TARGET_HT40_12], 16) |
+    ATH9K_POW_SM(p_pwr_array[ALL_TARGET_HT40_7],   8) |
+    ATH9K_POW_SM(p_pwr_array[ALL_TARGET_HT40_6],   0));
+ REG_WRITE(ah, 0xa3ec,
+    ATH9K_POW_SM(p_pwr_array[ALL_TARGET_HT40_21], 24) |
+    ATH9K_POW_SM(p_pwr_array[ALL_TARGET_HT40_20], 16) |
+    ATH9K_POW_SM(p_pwr_array[ALL_TARGET_HT40_15],  8) |
+    ATH9K_POW_SM(p_pwr_array[ALL_TARGET_HT40_14],  0));
+}
+
 void ar9003_hw_attach_phy_ops(struct ath_hw *ah)
 {
  struct ath_hw_private_ops *priv_ops = ath9k_hw_private_ops(ah);
@@ -1538,16 +1796,84 @@ void ar9003_hw_attach_phy_ops(struct ath_hw *ah)
 
  ops->antdiv_comb_conf_get = ar9003_hw_antdiv_comb_conf_get;
  ops->antdiv_comb_conf_set = ar9003_hw_antdiv_comb_conf_set;
- ops->antctrl_shared_chain_lnadiv = ar9003_hw_antctrl_shared_chain_lnadiv;
  ops->spectral_scan_config = ar9003_hw_spectral_scan_config;
  ops->spectral_scan_trigger = ar9003_hw_spectral_scan_trigger;
  ops->spectral_scan_wait = ar9003_hw_spectral_scan_wait;
 
+#ifdef CONFIG_ATH9K_BTCOEX_SUPPORT
+ ops->set_bt_ant_diversity = ar9003_hw_set_bt_ant_diversity;
+#endif
+ ops->tx99_start = ar9003_hw_tx99_start;
+ ops->tx99_stop = ar9003_hw_tx99_stop;
+ ops->tx99_set_txpower = ar9003_hw_tx99_set_txpower;
+
  ar9003_hw_set_nf_limits(ah);
  ar9003_hw_set_radar_conf(ah);
  memcpy(ah->nf_regs, ar9300_cca_regs, sizeof(ah->nf_regs));
 }
 
+/*
+ * Baseband Watchdog signatures:
+ *
+ * 0x04000539: BB hang when operating in HT40 DFS Channel.
+ *             Full chip reset is not required, but a recovery
+ *             mechanism is needed.
+ *
+ * 0x1300000a: Related to CAC deafness.
+ *             Chip reset is not required.
+ *
+ * 0x0400000a: Related to CAC deafness.
+ *             Full chip reset is required.
+ *
+ * 0x04000b09: RX state machine gets into an illegal state
+ *             when a packet with unsupported rate is received.
+ *             Full chip reset is required and PHY_RESTART has
+ *             to be disabled.
+ *
+ * 0x04000409: Packet stuck on receive.
+ *             Full chip reset is required for all chips except AR9340.
+ */
+
+/*
+ * ar9003_hw_bb_watchdog_check(): Returns true if a chip reset is required.
+ */
+bool ar9003_hw_bb_watchdog_check(struct ath_hw *ah)
+{
+ u32 val;
+
+ switch(ah->bb_watchdog_last_status) {
+ case 0x04000539:
+  val = REG_READ(ah, AR_PHY_RADAR_0);
+  val &= (~AR_PHY_RADAR_0_FIRPWR);
+  val |= SM(0x7f, AR_PHY_RADAR_0_FIRPWR);
+  REG_WRITE(ah, AR_PHY_RADAR_0, val);
+  udelay(1);
+  val = REG_READ(ah, AR_PHY_RADAR_0);
+  val &= ~AR_PHY_RADAR_0_FIRPWR;
+  val |= SM(AR9300_DFS_FIRPWR, AR_PHY_RADAR_0_FIRPWR);
+  REG_WRITE(ah, AR_PHY_RADAR_0, val);
+
+  return false;
+ case 0x1300000a:
+  return false;
+ case 0x0400000a:
+ case 0x04000b09:
+  return true;
+ case 0x04000409:
+  if (AR_SREV_9340(ah) || AR_SREV_9531(ah))
+   return false;
+  else
+   return true;
+ default:
+  /*
+   * For any other unknown signatures, do a
+   * full chip reset.
+   */
+  return true;
+ }
+}
+EXPORT_SYMBOL(ar9003_hw_bb_watchdog_check);
+
 void ar9003_hw_bb_watchdog_config(struct ath_hw *ah)
 {
  struct ath_common *common = ath9k_hw_common(ah);
@@ -1664,6 +1990,7 @@ EXPORT_SYMBOL(ar9003_hw_bb_watchdog_dbg_info);
 
 void ar9003_hw_disable_phy_restart(struct ath_hw *ah)
 {
+ u8 result;
  u32 val;
 
  /* While receiving unsupported rate frame rx state machine
@@ -1671,15 +1998,13 @@ void ar9003_hw_disable_phy_restart(struct ath_hw *ah)
   * state, BB would go hang. If RXSM is in 0xb state after
   * first bb panic, ensure to disable the phy_restart.
   */
- if (!((MS(ah->bb_watchdog_last_status,
-    AR_PHY_WATCHDOG_RX_OFDM_SM) == 0xb) ||
-     ah->bb_hang_rx_ofdm))
-  return;
+ result = MS(ah->bb_watchdog_last_status, AR_PHY_WATCHDOG_RX_OFDM_SM);
 
- ah->bb_hang_rx_ofdm = true;
- val = REG_READ(ah, AR_PHY_RESTART);
- val &= ~AR_PHY_RESTART_ENA;
-
- REG_WRITE(ah, AR_PHY_RESTART, val);
+ if ((result == 0xb) || ah->bb_hang_rx_ofdm) {
+  ah->bb_hang_rx_ofdm = true;
+  val = REG_READ(ah, AR_PHY_RESTART);
+  val &= ~AR_PHY_RESTART_ENA;
+  REG_WRITE(ah, AR_PHY_RESTART, val);
+ }
 }
 EXPORT_SYMBOL(ar9003_hw_disable_phy_restart);
diff --git a/drivers/net/wireless/ath/ath9k/ar9003_phy.h b/drivers/net/wireless/ath/ath9k/ar9003_phy.h
index 5013c73..fd090b1 100644
--- a/drivers/net/wireless/ath/ath9k/ar9003_phy.h
+++ b/drivers/net/wireless/ath/ath9k/ar9003_phy.h
@@ -148,6 +148,8 @@
 #define AR_PHY_SFCORR_SPUR_SUBCHNL_SD_S   28
 #define AR_PHY_EXT_CCA_THRESH62 0x007F0000
 #define AR_PHY_EXT_CCA_THRESH62_S       16
+#define AR_PHY_EXTCHN_PWRTHR1_ANT_DIV_ALT_ANT_MINGAINIDX    0x0000FF00
+#define AR_PHY_EXTCHN_PWRTHR1_ANT_DIV_ALT_ANT_MINGAINIDX_S  8
 #define AR_PHY_EXT_MINCCA_PWR   0x01FF0000
 #define AR_PHY_EXT_MINCCA_PWR_S 16
 #define AR_PHY_EXT_CYCPWR_THR1 0x0000FE00L
@@ -268,7 +270,7 @@
 #define AR_PHY_AGC              (AR_AGC_BASE + 0x14)
 #define AR_PHY_EXT_ATTEN_CTL_0  (AR_AGC_BASE + 0x18)
 #define AR_PHY_CCA_0            (AR_AGC_BASE + 0x1c)
-#define AR_PHY_EXT_CCA0         (AR_AGC_BASE + 0x20)
+#define AR_PHY_CCA_CTRL_0       (AR_AGC_BASE + 0x20)
 #define AR_PHY_RESTART          (AR_AGC_BASE + 0x24)
 
 /*
@@ -296,11 +298,6 @@
 #define AR_PHY_ANT_DIV_MAIN_GAINTB              0x40000000
 #define AR_PHY_ANT_DIV_MAIN_GAINTB_S            30
 
-#define AR_PHY_ANT_DIV_LNA1_MINUS_LNA2          0x0
-#define AR_PHY_ANT_DIV_LNA2                     0x1
-#define AR_PHY_ANT_DIV_LNA1                     0x2
-#define AR_PHY_ANT_DIV_LNA1_PLUS_LNA2           0x3
-
 #define AR_PHY_EXTCHN_PWRTHR1   (AR_AGC_BASE + 0x2c)
 #define AR_PHY_EXT_CHN_WIN      (AR_AGC_BASE + 0x30)
 #define AR_PHY_20_40_DET_THR    (AR_AGC_BASE + 0x34)
@@ -341,13 +338,17 @@
 #define AR_PHY_CCA_NOM_VAL_9300_5GHZ          -115
 #define AR_PHY_CCA_MIN_GOOD_VAL_9300_2GHZ     -125
 #define AR_PHY_CCA_MIN_GOOD_VAL_9300_5GHZ     -125
-#define AR_PHY_CCA_MAX_GOOD_VAL_9300_2GHZ     -95
-#define AR_PHY_CCA_MAX_GOOD_VAL_9300_5GHZ     -100
+#define AR_PHY_CCA_MAX_GOOD_VAL_9300_2GHZ     -60
+#define AR_PHY_CCA_MAX_GOOD_VAL_9300_5GHZ     -60
+#define AR_PHY_CCA_MAX_GOOD_VAL_9300_FCC_2GHZ -95
+#define AR_PHY_CCA_MAX_GOOD_VAL_9300_FCC_5GHZ -100
 
 #define AR_PHY_CCA_NOM_VAL_9462_2GHZ          -127
 #define AR_PHY_CCA_MIN_GOOD_VAL_9462_2GHZ     -127
+#define AR_PHY_CCA_MAX_GOOD_VAL_9462_2GHZ     -60
 #define AR_PHY_CCA_NOM_VAL_9462_5GHZ          -127
 #define AR_PHY_CCA_MIN_GOOD_VAL_9462_5GHZ     -127
+#define AR_PHY_CCA_MAX_GOOD_VAL_9462_5GHZ     -60
 
 #define AR_PHY_CCA_NOM_VAL_9330_2GHZ          -118
 
@@ -396,6 +397,8 @@
 #define AR9280_PHY_CCA_THRESH62_S   12
 #define AR_PHY_EXT_CCA0_THRESH62    0x000000FF
 #define AR_PHY_EXT_CCA0_THRESH62_S  0
+#define AR_PHY_EXT_CCA0_THRESH62_1    0x000001FF
+#define AR_PHY_EXT_CCA0_THRESH62_1_S  0
 #define AR_PHY_CCK_DETECT_WEAK_SIG_THR_CCK          0x0000003F
 #define AR_PHY_CCK_DETECT_WEAK_SIG_THR_CCK_S        0
 #define AR_PHY_CCK_DETECT_ANT_SWITCH_TIME           0x00001FC0
@@ -655,13 +658,34 @@
 #define AR_PHY_SYNTH4_LONG_SHIFT_SELECT   ((AR_SREV_9462(ah) || AR_SREV_9565(ah)) ? 0x00000001 : 0x00000002)
 #define AR_PHY_SYNTH4_LONG_SHIFT_SELECT_S ((AR_SREV_9462(ah) || AR_SREV_9565(ah)) ? 0 : 1)
 #define AR_PHY_65NM_CH0_SYNTH7      0x16098
+#define AR_PHY_65NM_CH0_SYNTH12     0x160ac
 #define AR_PHY_65NM_CH0_BIAS1       0x160c0
 #define AR_PHY_65NM_CH0_BIAS2       0x160c4
 #define AR_PHY_65NM_CH0_BIAS4       0x160cc
+#define AR_PHY_65NM_CH0_RXTX2       0x16104
+#define AR_PHY_65NM_CH1_RXTX2       0x16504
+#define AR_PHY_65NM_CH2_RXTX2       0x16904
 #define AR_PHY_65NM_CH0_RXTX4       0x1610c
 #define AR_PHY_65NM_CH1_RXTX4       0x1650c
 #define AR_PHY_65NM_CH2_RXTX4       0x1690c
 
+#define AR_PHY_65NM_CH0_BB1         0x16140
+#define AR_PHY_65NM_CH0_BB2         0x16144
+#define AR_PHY_65NM_CH0_BB3         0x16148
+#define AR_PHY_65NM_CH1_BB1         0x16540
+#define AR_PHY_65NM_CH1_BB2         0x16544
+#define AR_PHY_65NM_CH1_BB3         0x16548
+#define AR_PHY_65NM_CH2_BB1         0x16940
+#define AR_PHY_65NM_CH2_BB2         0x16944
+#define AR_PHY_65NM_CH2_BB3         0x16948
+
+#define AR_PHY_65NM_CH0_SYNTH12_VREFMUL3           0x00780000
+#define AR_PHY_65NM_CH0_SYNTH12_VREFMUL3_S         19
+#define AR_PHY_65NM_CH0_RXTX2_SYNTHON_MASK         0x00000004
+#define AR_PHY_65NM_CH0_RXTX2_SYNTHON_MASK_S       2
+#define AR_PHY_65NM_CH0_RXTX2_SYNTHOVR_MASK        0x00000008
+#define AR_PHY_65NM_CH0_RXTX2_SYNTHOVR_MASK_S      3
+
 #define AR_CH0_TOP (AR_SREV_9300(ah) ? 0x16288 : \
     (((AR_SREV_9462(ah) || AR_SREV_9565(ah)) ? 0x1628c : 0x16280)))
 #define AR_CH0_TOP_XPABIASLVL (AR_SREV_9550(ah) ? 0x3c0 : 0x300)
@@ -954,7 +978,7 @@
 #define AR_PHY_TPC_5_B1         (AR_SM1_BASE + 0x208)
 #define AR_PHY_TPC_6_B1         (AR_SM1_BASE + 0x20c)
 #define AR_PHY_TPC_11_B1        (AR_SM1_BASE + 0x220)
-#define AR_PHY_PDADC_TAB_1 (AR_SM1_BASE + (AR_SREV_AR9462(ah) ? \
+#define AR_PHY_PDADC_TAB_1 (AR_SM1_BASE + (AR_SREV_9462_20_OR_LATER(ah) ? \
      0x280 : 0x240))
 #define AR_PHY_TPC_19_B1 (AR_SM1_BASE + 0x240)
 #define AR_PHY_TPC_19_B1_ALPHA_THERM  0xff
@@ -1048,7 +1072,7 @@
 #define AR_GLB_GPIO_CONTROL (AR_GLB_BASE)
 #define AR_PHY_GLB_CONTROL (AR_GLB_BASE + 0x44)
 #define AR_GLB_SCRATCH(_ah) (AR_GLB_BASE + \
-     (AR_SREV_9462_20(_ah) ? 0x4c : 0x50))
+     (AR_SREV_9462_20_OR_LATER(_ah) ? 0x4c : 0x50))
 #define AR_GLB_STATUS  (AR_GLB_BASE + 0x48)
 
 /*
@@ -1319,4 +1343,6 @@
 #define AR_PHY_65NM_RXRF_AGC_AGC_OUT                   0x00000004
 #define AR_PHY_65NM_RXRF_AGC_AGC_OUT_S                 2
 
+#define AR9300_DFS_FIRPWR -28
+
 #endif  /* AR9003_PHY_H */
diff --git a/drivers/net/wireless/ath/ath9k/ar9003_rtt.c b/drivers/net/wireless/ath/ath9k/ar9003_rtt.c
index 74de353..9344188 100644
--- a/drivers/net/wireless/ath/ath9k/ar9003_rtt.c
+++ b/drivers/net/wireless/ath/ath9k/ar9003_rtt.c
@@ -118,6 +118,27 @@ void ar9003_hw_rtt_load_hist(struct ath_hw *ah)
  }
 }
 
+static void ar9003_hw_patch_rtt(struct ath_hw *ah, int index, int chain)
+{
+ int agc, caldac;
+
+ if (!test_bit(SW_PKDET_DONE, &ah->caldata->cal_flags))
+  return;
+
+ if ((index != 5) || (chain >= 2))
+  return;
+
+ agc = REG_READ_FIELD(ah, AR_PHY_65NM_RXRF_AGC(chain),
+        AR_PHY_65NM_RXRF_AGC_AGC_OVERRIDE);
+ if (!agc)
+  return;
+
+ caldac = ah->caldata->caldac[chain];
+ ah->caldata->rtt_table[chain][index] &= 0xFFFF05FF;
+ caldac = (caldac & 0x20) | ((caldac & 0x1F) << 7);
+ ah->caldata->rtt_table[chain][index] |= (caldac << 4);
+}
+
 static int ar9003_hw_rtt_fill_hist_entry(struct ath_hw *ah, u8 chain, u32 index)
 {
  u32 val;
@@ -155,13 +176,16 @@ void ar9003_hw_rtt_fill_hist(struct ath_hw *ah)
   for (i = 0; i < MAX_RTT_TABLE_ENTRY; i++) {
    ah->caldata->rtt_table[chain][i] =
     ar9003_hw_rtt_fill_hist_entry(ah, chain, i);
+
+   ar9003_hw_patch_rtt(ah, i, chain);
+
    ath_dbg(ath9k_hw_common(ah), CALIBRATE,
     "RTT value at idx %d, chain %d is: 0x%x\n",
     i, chain, ah->caldata->rtt_table[chain][i]);
   }
  }
 
- ah->caldata->rtt_done = true;
+ set_bit(RTT_DONE, &ah->caldata->cal_flags);
 }
 
 void ar9003_hw_rtt_clear_hist(struct ath_hw *ah)
@@ -176,7 +200,7 @@ void ar9003_hw_rtt_clear_hist(struct ath_hw *ah)
  }
 
  if (ah->caldata)
-  ah->caldata->rtt_done = false;
+  clear_bit(RTT_DONE, &ah->caldata->cal_flags);
 }
 
 bool ar9003_hw_rtt_restore(struct ath_hw *ah, struct ath9k_channel *chan)
@@ -186,11 +210,37 @@ bool ar9003_hw_rtt_restore(struct ath_hw *ah, struct ath9k_channel *chan)
  if (!ah->caldata)
   return false;
 
- if (!ah->caldata->rtt_done)
+ if (test_bit(SW_PKDET_DONE, &ah->caldata->cal_flags)) {
+  if (IS_CHAN_2GHZ(chan)){
+   REG_RMW_FIELD(ah, AR_PHY_65NM_RXRF_AGC(0),
+          AR_PHY_65NM_RXRF_AGC_AGC2G_CALDAC_OVR,
+          ah->caldata->caldac[0]);
+   REG_RMW_FIELD(ah, AR_PHY_65NM_RXRF_AGC(1),
+          AR_PHY_65NM_RXRF_AGC_AGC2G_CALDAC_OVR,
+          ah->caldata->caldac[1]);
+  } else {
+   REG_RMW_FIELD(ah, AR_PHY_65NM_RXRF_AGC(0),
+          AR_PHY_65NM_RXRF_AGC_AGC5G_CALDAC_OVR,
+          ah->caldata->caldac[0]);
+   REG_RMW_FIELD(ah, AR_PHY_65NM_RXRF_AGC(1),
+          AR_PHY_65NM_RXRF_AGC_AGC5G_CALDAC_OVR,
+          ah->caldata->caldac[1]);
+  }
+  REG_RMW_FIELD(ah, AR_PHY_65NM_RXRF_AGC(1),
+         AR_PHY_65NM_RXRF_AGC_AGC_OVERRIDE, 0x1);
+  REG_RMW_FIELD(ah, AR_PHY_65NM_RXRF_AGC(0),
+         AR_PHY_65NM_RXRF_AGC_AGC_OVERRIDE, 0x1);
+ }
+
+ if (!test_bit(RTT_DONE, &ah->caldata->cal_flags))
   return false;
 
  ar9003_hw_rtt_enable(ah);
- ar9003_hw_rtt_set_mask(ah, 0x10);
+
+ if (test_bit(SW_PKDET_DONE, &ah->caldata->cal_flags))
+  ar9003_hw_rtt_set_mask(ah, 0x30);
+ else
+  ar9003_hw_rtt_set_mask(ah, 0x10);
 
  if (!ath9k_hw_rfbus_req(ah)) {
   ath_err(ath9k_hw_common(ah), "Could not stop baseband\n");
diff --git a/drivers/net/wireless/ath/ath9k/ar9003_wow.c b/drivers/net/wireless/ath/ath9k/ar9003_wow.c
new file mode 100644
index 0000000..81c88dd
--- /dev/null
+++ b/drivers/net/wireless/ath/ath9k/ar9003_wow.c
@@ -0,0 +1,422 @@
+/*
+ * Copyright (c) 2012 Qualcomm Atheros, Inc.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <linux/export.h>
+#include "ath9k.h"
+#include "reg.h"
+#include "hw-ops.h"
+
+const char *ath9k_hw_wow_event_to_string(u32 wow_event)
+{
+ if (wow_event & AH_WOW_MAGIC_PATTERN_EN)
+  return "Magic pattern";
+ if (wow_event & AH_WOW_USER_PATTERN_EN)
+  return "User pattern";
+ if (wow_event & AH_WOW_LINK_CHANGE)
+  return "Link change";
+ if (wow_event & AH_WOW_BEACON_MISS)
+  return "Beacon miss";
+
+ return  "unknown reason";
+}
+EXPORT_SYMBOL(ath9k_hw_wow_event_to_string);
+
+static void ath9k_hw_set_powermode_wow_sleep(struct ath_hw *ah)
+{
+ struct ath_common *common = ath9k_hw_common(ah);
+
+ REG_SET_BIT(ah, AR_STA_ID1, AR_STA_ID1_PWR_SAV);
+
+ /* set rx disable bit */
+ REG_WRITE(ah, AR_CR, AR_CR_RXD);
+
+ if (!ath9k_hw_wait(ah, AR_CR, AR_CR_RXE, 0, AH_WAIT_TIMEOUT)) {
+  ath_err(common, "Failed to stop Rx DMA in 10ms AR_CR=0x%08x AR_DIAG_SW=0x%08x\n",
+   REG_READ(ah, AR_CR), REG_READ(ah, AR_DIAG_SW));
+  return;
+ }
+
+ REG_WRITE(ah, AR_RTC_FORCE_WAKE, AR_RTC_FORCE_WAKE_ON_INT);
+}
+
+static void ath9k_wow_create_keep_alive_pattern(struct ath_hw *ah)
+{
+ struct ath_common *common = ath9k_hw_common(ah);
+ u8 sta_mac_addr[ETH_ALEN], ap_mac_addr[ETH_ALEN];
+ u32 ctl[13] = {0};
+ u32 data_word[KAL_NUM_DATA_WORDS];
+ u8 i;
+ u32 wow_ka_data_word0;
+
+ memcpy(sta_mac_addr, common->macaddr, ETH_ALEN);
+ memcpy(ap_mac_addr, common->curbssid, ETH_ALEN);
+
+ /* set the transmit buffer */
+ ctl[0] = (KAL_FRAME_LEN | (MAX_RATE_POWER << 16));
+ ctl[1] = 0;
+ ctl[3] = 0xb; /* OFDM_6M hardware value for this rate */
+ ctl[4] = 0;
+ ctl[7] = (ah->txchainmask) << 2;
+ ctl[2] = 0xf << 16; /* tx_tries 0 */
+
+ for (i = 0; i < KAL_NUM_DESC_WORDS; i++)
+  REG_WRITE(ah, (AR_WOW_KA_DESC_WORD2 + i * 4), ctl[i]);
+
+ REG_WRITE(ah, (AR_WOW_KA_DESC_WORD2 + i * 4), ctl[i]);
+
+ data_word[0] = (KAL_FRAME_TYPE << 2) | (KAL_FRAME_SUB_TYPE << 4) |
+         (KAL_TO_DS << 8) | (KAL_DURATION_ID << 16);
+ data_word[1] = (ap_mac_addr[3] << 24) | (ap_mac_addr[2] << 16) |
+         (ap_mac_addr[1] << 8) | (ap_mac_addr[0]);
+ data_word[2] = (sta_mac_addr[1] << 24) | (sta_mac_addr[0] << 16) |
+         (ap_mac_addr[5] << 8) | (ap_mac_addr[4]);
+ data_word[3] = (sta_mac_addr[5] << 24) | (sta_mac_addr[4] << 16) |
+         (sta_mac_addr[3] << 8) | (sta_mac_addr[2]);
+ data_word[4] = (ap_mac_addr[3] << 24) | (ap_mac_addr[2] << 16) |
+         (ap_mac_addr[1] << 8) | (ap_mac_addr[0]);
+ data_word[5] = (ap_mac_addr[5] << 8) | (ap_mac_addr[4]);
+
+ if (AR_SREV_9462_20(ah)) {
+  /* AR9462 2.0 has an extra descriptor word (time based
+   * discard) compared to other chips */
+  REG_WRITE(ah, (AR_WOW_KA_DESC_WORD2 + (12 * 4)), 0);
+  wow_ka_data_word0 = AR_WOW_TXBUF(13);
+ } else {
+  wow_ka_data_word0 = AR_WOW_TXBUF(12);
+ }
+
+ for (i = 0; i < KAL_NUM_DATA_WORDS; i++)
+  REG_WRITE(ah, (wow_ka_data_word0 + i*4), data_word[i]);
+
+}
+
+void ath9k_hw_wow_apply_pattern(struct ath_hw *ah, u8 *user_pattern,
+    u8 *user_mask, int pattern_count,
+    int pattern_len)
+{
+ int i;
+ u32 pattern_val, mask_val;
+ u32 set, clr;
+
+ /* FIXME: should check count by querying the hardware capability */
+ if (pattern_count >= MAX_NUM_PATTERN)
+  return;
+
+ REG_SET_BIT(ah, AR_WOW_PATTERN, BIT(pattern_count));
+
+ /* set the registers for pattern */
+ for (i = 0; i < MAX_PATTERN_SIZE; i += 4) {
+  memcpy(&pattern_val, user_pattern, 4);
+  REG_WRITE(ah, (AR_WOW_TB_PATTERN(pattern_count) + i),
+     pattern_val);
+  user_pattern += 4;
+ }
+
+ /* set the registers for mask */
+ for (i = 0; i < MAX_PATTERN_MASK_SIZE; i += 4) {
+  memcpy(&mask_val, user_mask, 4);
+  REG_WRITE(ah, (AR_WOW_TB_MASK(pattern_count) + i), mask_val);
+  user_mask += 4;
+ }
+
+ /* set the pattern length to be matched
+  *
+  * AR_WOW_LENGTH1_REG1
+  * bit 31:24 pattern 0 length
+  * bit 23:16 pattern 1 length
+  * bit 15:8 pattern 2 length
+  * bit 7:0 pattern 3 length
+  *
+  * AR_WOW_LENGTH1_REG2
+  * bit 31:24 pattern 4 length
+  * bit 23:16 pattern 5 length
+  * bit 15:8 pattern 6 length
+  * bit 7:0 pattern 7 length
+  *
+  * the below logic writes out the new
+  * pattern length for the corresponding
+  * pattern_count, while masking out the
+  * other fields
+  */
+
+ ah->wow_event_mask |= BIT(pattern_count + AR_WOW_PAT_FOUND_SHIFT);
+
+ if (pattern_count < 4) {
+  /* Pattern 0-3 uses AR_WOW_LENGTH1 register */
+  set = (pattern_len & AR_WOW_LENGTH_MAX) <<
+         AR_WOW_LEN1_SHIFT(pattern_count);
+  clr = AR_WOW_LENGTH1_MASK(pattern_count);
+  REG_RMW(ah, AR_WOW_LENGTH1, set, clr);
+ } else {
+  /* Pattern 4-7 uses AR_WOW_LENGTH2 register */
+  set = (pattern_len & AR_WOW_LENGTH_MAX) <<
+         AR_WOW_LEN2_SHIFT(pattern_count);
+  clr = AR_WOW_LENGTH2_MASK(pattern_count);
+  REG_RMW(ah, AR_WOW_LENGTH2, set, clr);
+ }
+
+}
+EXPORT_SYMBOL(ath9k_hw_wow_apply_pattern);
+
+u32 ath9k_hw_wow_wakeup(struct ath_hw *ah)
+{
+ u32 wow_status = 0;
+ u32 val = 0, rval;
+
+ /*
+  * read the WoW status register to know
+  * the wakeup reason
+  */
+ rval = REG_READ(ah, AR_WOW_PATTERN);
+ val = AR_WOW_STATUS(rval);
+
+ /*
+  * mask only the WoW events that we have enabled. Sometimes
+  * we have spurious WoW events from the AR_WOW_PATTERN
+  * register. This mask will clean it up.
+  */
+
+ val &= ah->wow_event_mask;
+
+ if (val) {
+  if (val & AR_WOW_MAGIC_PAT_FOUND)
+   wow_status |= AH_WOW_MAGIC_PATTERN_EN;
+  if (AR_WOW_PATTERN_FOUND(val))
+   wow_status |= AH_WOW_USER_PATTERN_EN;
+  if (val & AR_WOW_KEEP_ALIVE_FAIL)
+   wow_status |= AH_WOW_LINK_CHANGE;
+  if (val & AR_WOW_BEACON_FAIL)
+   wow_status |= AH_WOW_BEACON_MISS;
+ }
+
+ /*
+  * set and clear WOW_PME_CLEAR registers for the chip to
+  * generate next wow signal.
+  * disable D3 before accessing other registers ?
+  */
+
+ /* do we need to check the bit value 0x01000000 (7-10) ?? */
+ REG_RMW(ah, AR_PCIE_PM_CTRL, AR_PMCTRL_WOW_PME_CLR,
+  AR_PMCTRL_PWR_STATE_D1D3);
+
+ /*
+  * clear all events
+  */
+ REG_WRITE(ah, AR_WOW_PATTERN,
+    AR_WOW_CLEAR_EVENTS(REG_READ(ah, AR_WOW_PATTERN)));
+
+ /*
+  * restore the beacon threshold to init value
+  */
+ REG_WRITE(ah, AR_RSSI_THR, INIT_RSSI_THR);
+
+ /*
+  * Restore the way the PCI-E reset, Power-On-Reset, external
+  * PCIE_POR_SHORT pins are tied to its original value.
+  * Previously just before WoW sleep, we untie the PCI-E
+  * reset to our Chip's Power On Reset so that any PCI-E
+  * reset from the bus will not reset our chip
+  */
+ if (ah->is_pciexpress)
+  ath9k_hw_configpcipowersave(ah, false);
+
+ ah->wow_event_mask = 0;
+
+ return wow_status;
+}
+EXPORT_SYMBOL(ath9k_hw_wow_wakeup);
+
+void ath9k_hw_wow_enable(struct ath_hw *ah, u32 pattern_enable)
+{
+ u32 wow_event_mask;
+ u32 set, clr;
+
+ /*
+  * wow_event_mask is a mask to the AR_WOW_PATTERN register to
+  * indicate which WoW events we have enabled. The WoW events
+  * are from the 'pattern_enable' in this function and
+  * 'pattern_count' of ath9k_hw_wow_apply_pattern()
+  */
+ wow_event_mask = ah->wow_event_mask;
+
+ /*
+  * Untie Power-on-Reset from the PCI-E-Reset. When we are in
+  * WOW sleep, we do want the Reset from the PCI-E to disturb
+  * our hw state
+  */
+ if (ah->is_pciexpress) {
+  /*
+   * we need to untie the internal POR (power-on-reset)
+   * to the external PCI-E reset. We also need to tie
+   * the PCI-E Phy reset to the PCI-E reset.
+   */
+  set = AR_WA_RESET_EN | AR_WA_POR_SHORT;
+  clr = AR_WA_UNTIE_RESET_EN | AR_WA_D3_L1_DISABLE;
+  REG_RMW(ah, AR_WA, set, clr);
+ }
+
+ /*
+  * set the power states appropriately and enable PME
+  */
+ set = AR_PMCTRL_HOST_PME_EN | AR_PMCTRL_PWR_PM_CTRL_ENA |
+       AR_PMCTRL_AUX_PWR_DET | AR_PMCTRL_WOW_PME_CLR;
+
+ /*
+  * set and clear WOW_PME_CLEAR registers for the chip
+  * to generate next wow signal.
+  */
+ REG_SET_BIT(ah, AR_PCIE_PM_CTRL, set);
+ clr = AR_PMCTRL_WOW_PME_CLR;
+ REG_CLR_BIT(ah, AR_PCIE_PM_CTRL, clr);
+
+ /*
+  * Setup for:
+  * - beacon misses
+  * - magic pattern
+  * - keep alive timeout
+  * - pattern matching
+  */
+
+ /*
+  * Program default values for pattern backoff, aifs/slot/KAL count,
+  * beacon miss timeout, KAL timeout, etc.
+  */
+ set = AR_WOW_BACK_OFF_SHIFT(AR_WOW_PAT_BACKOFF);
+ REG_SET_BIT(ah, AR_WOW_PATTERN, set);
+
+ set = AR_WOW_AIFS_CNT(AR_WOW_CNT_AIFS_CNT) |
+       AR_WOW_SLOT_CNT(AR_WOW_CNT_SLOT_CNT) |
+       AR_WOW_KEEP_ALIVE_CNT(AR_WOW_CNT_KA_CNT);
+ REG_SET_BIT(ah, AR_WOW_COUNT, set);
+
+ if (pattern_enable & AH_WOW_BEACON_MISS)
+  set = AR_WOW_BEACON_TIMO;
+ /* We are not using beacon miss, program a large value */
+ else
+  set = AR_WOW_BEACON_TIMO_MAX;
+
+ REG_WRITE(ah, AR_WOW_BCN_TIMO, set);
+
+ /*
+  * Keep alive timo in ms except AR9280
+  */
+ if (!pattern_enable)
+  set = AR_WOW_KEEP_ALIVE_NEVER;
+ else
+  set = KAL_TIMEOUT * 32;
+
+ REG_WRITE(ah, AR_WOW_KEEP_ALIVE_TIMO, set);
+
+ /*
+  * Keep alive delay in us. based on 'power on clock',
+  * therefore in usec
+  */
+ set = KAL_DELAY * 1000;
+ REG_WRITE(ah, AR_WOW_KEEP_ALIVE_DELAY, set);
+
+ /*
+  * Create keep alive pattern to respond to beacons
+  */
+ ath9k_wow_create_keep_alive_pattern(ah);
+
+ /*
+  * Configure MAC WoW Registers
+  */
+ set = 0;
+ /* Send keep alive timeouts anyway */
+ clr = AR_WOW_KEEP_ALIVE_AUTO_DIS;
+
+ if (pattern_enable & AH_WOW_LINK_CHANGE)
+  wow_event_mask |= AR_WOW_KEEP_ALIVE_FAIL;
+ else
+  set = AR_WOW_KEEP_ALIVE_FAIL_DIS;
+
+ set = AR_WOW_KEEP_ALIVE_FAIL_DIS;
+ REG_RMW(ah, AR_WOW_KEEP_ALIVE, set, clr);
+
+ /*
+  * we are relying on a bmiss failure. ensure we have
+  * enough threshold to prevent false positives
+  */
+ REG_RMW_FIELD(ah, AR_RSSI_THR, AR_RSSI_THR_BM_THR,
+        AR_WOW_BMISSTHRESHOLD);
+
+ set = 0;
+ clr = 0;
+
+ if (pattern_enable & AH_WOW_BEACON_MISS) {
+  set = AR_WOW_BEACON_FAIL_EN;
+  wow_event_mask |= AR_WOW_BEACON_FAIL;
+ } else {
+  clr = AR_WOW_BEACON_FAIL_EN;
+ }
+
+ REG_RMW(ah, AR_WOW_BCN_EN, set, clr);
+
+ set = 0;
+ clr = 0;
+ /*
+  * Enable the magic packet registers
+  */
+ if (pattern_enable & AH_WOW_MAGIC_PATTERN_EN) {
+  set = AR_WOW_MAGIC_EN;
+  wow_event_mask |= AR_WOW_MAGIC_PAT_FOUND;
+ } else {
+  clr = AR_WOW_MAGIC_EN;
+ }
+ set |= AR_WOW_MAC_INTR_EN;
+ REG_RMW(ah, AR_WOW_PATTERN, set, clr);
+
+ REG_WRITE(ah, AR_WOW_PATTERN_MATCH_LT_256B,
+    AR_WOW_PATTERN_SUPPORTED);
+
+ /*
+  * Set the power states appropriately and enable PME
+  */
+ clr = 0;
+ set = AR_PMCTRL_PWR_STATE_D1D3 | AR_PMCTRL_HOST_PME_EN |
+       AR_PMCTRL_PWR_PM_CTRL_ENA;
+
+ clr = AR_PCIE_PM_CTRL_ENA;
+ REG_RMW(ah, AR_PCIE_PM_CTRL, set, clr);
+
+ /*
+  * this is needed to prevent the chip waking up
+  * the host within 3-4 seconds with certain
+  * platform/BIOS. The fix is to enable
+  * D1 & D3 to match original definition and
+  * also match the OTP value. Anyway this
+  * is more related to SW WOW.
+  */
+ clr = AR_PMCTRL_PWR_STATE_D1D3;
+ REG_CLR_BIT(ah, AR_PCIE_PM_CTRL, clr);
+
+ set = AR_PMCTRL_PWR_STATE_D1D3_REAL;
+ REG_SET_BIT(ah, AR_PCIE_PM_CTRL, set);
+
+ REG_CLR_BIT(ah, AR_STA_ID1, AR_STA_ID1_PRESERVE_SEQNUM);
+
+ /* to bring down WOW power low margin */
+ set = BIT(13);
+ REG_SET_BIT(ah, AR_PCIE_PHY_REG3, set);
+ /* HW WoW */
+ clr = BIT(5);
+ REG_CLR_BIT(ah, AR_PCU_MISC_MODE3, clr);
+
+ ath9k_hw_set_powermode_wow_sleep(ah);
+ ah->wow_event_mask = wow_event_mask;
+}
+EXPORT_SYMBOL(ath9k_hw_wow_enable);
diff --git a/drivers/net/wireless/ath/ath9k/ar9330_1p1_initvals.h b/drivers/net/wireless/ath/ath9k/ar9330_1p1_initvals.h
index 6e1756b..2c42ff0 100644
--- a/drivers/net/wireless/ath/ath9k/ar9330_1p1_initvals.h
+++ b/drivers/net/wireless/ath/ath9k/ar9330_1p1_initvals.h
@@ -18,6 +18,10 @@
 #ifndef INITVALS_9330_1P1_H
 #define INITVALS_9330_1P1_H
 
+#define ar9331_1p1_baseband_core_txfir_coeff_japan_2484 ar9300_2p2_baseband_core_txfir_coeff_japan_2484
+
+#define ar9331_modes_high_power_tx_gain_1p1 ar9331_modes_lowest_ob_db_tx_gain_1p1
+
 static const u32 ar9331_1p1_baseband_postamble[][5] = {
  /* Addr      5G_HT20     5G_HT40     2G_HT40     2G_HT20   */
  {0x00009810, 0xd00a8005, 0xd00a8005, 0xd00a8005, 0xd00a8005},
@@ -55,7 +59,7 @@ static const u32 ar9331_1p1_baseband_postamble[][5] = {
  {0x0000a284, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
  {0x0000a288, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
  {0x0000a28c, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
- {0x0000a2c4, 0x00158d18, 0x00158d18, 0x00158d18, 0x00158d18},
+ {0x0000a2c4, 0x00158d18, 0x00158d18, 0x00058d18, 0x00058d18},
  {0x0000a2d0, 0x00071982, 0x00071982, 0x00071982, 0x00071982},
  {0x0000a2d8, 0xf999a83a, 0xf999a83a, 0xf999a83a, 0xf999a83a},
  {0x0000a358, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
@@ -252,7 +256,7 @@ static const u32 ar9331_modes_low_ob_db_tx_gain_1p1[][5] = {
  {0x0000a2e0, 0xffffcc84, 0xffffcc84, 0xffffcc84, 0xffffcc84},
  {0x0000a2e4, 0xfffff000, 0xfffff000, 0xfffff000, 0xfffff000},
  {0x0000a2e8, 0xfffe0000, 0xfffe0000, 0xfffe0000, 0xfffe0000},
- {0x0000a410, 0x000050d7, 0x000050d7, 0x000050d0, 0x000050d0},
+ {0x0000a410, 0x000050d7, 0x000050d7, 0x000050d4, 0x000050d4},
  {0x0000a500, 0x00022200, 0x00022200, 0x00000000, 0x00000000},
  {0x0000a504, 0x05062002, 0x05062002, 0x04000002, 0x04000002},
  {0x0000a508, 0x0c002e00, 0x0c002e00, 0x08000004, 0x08000004},
@@ -337,8 +341,6 @@ static const u32 ar9331_modes_low_ob_db_tx_gain_1p1[][5] = {
  {0x00016284, 0x14d3f000, 0x14d3f000, 0x14d3f000, 0x14d3f000},
 };
 
-#define ar9331_1p1_baseband_core_txfir_coeff_japan_2484 ar9462_2p0_baseband_core_txfir_coeff_japan_2484
-
 static const u32 ar9331_1p1_xtal_25M[][2] = {
  /* Addr      allmodes  */
  {0x00007038, 0x000002f8},
@@ -373,17 +375,17 @@ static const u32 ar9331_1p1_radio_core[][2] = {
  {0x000160b4, 0x92480040},
  {0x000160c0, 0x006db6db},
  {0x000160c4, 0x0186db60},
- {0x000160c8, 0x6db4db6c},
+ {0x000160c8, 0x6db6db6c},
  {0x000160cc, 0x6de6c300},
  {0x000160d0, 0x14500820},
  {0x00016100, 0x04cb0001},
  {0x00016104, 0xfff80015},
  {0x00016108, 0x00080010},
  {0x0001610c, 0x00170000},
- {0x00016140, 0x10800000},
+ {0x00016140, 0x50804000},
  {0x00016144, 0x01884080},
  {0x00016148, 0x000080c0},
- {0x00016280, 0x01000015},
+ {0x00016280, 0x01001015},
  {0x00016284, 0x14d20000},
  {0x00016288, 0x00318000},
  {0x0001628c, 0x50000000},
@@ -590,7 +592,7 @@ static const u32 ar9331_1p1_baseband_core[][2] = {
  {0x00009e30, 0x06336f77},
  {0x00009e34, 0x6af6532f},
  {0x00009e38, 0x0cc80c00},
- {0x00009e40, 0x0d261820},
+ {0x00009e40, 0x0d261800},
  {0x00009e4c, 0x00001004},
  {0x00009e50, 0x00ff03f1},
  {0x00009fc0, 0x803e4788},
@@ -622,12 +624,12 @@ static const u32 ar9331_1p1_baseband_core[][2] = {
  {0x0000a370, 0x00000000},
  {0x0000a390, 0x00000001},
  {0x0000a394, 0x00000444},
- {0x0000a398, 0x001f0e0f},
- {0x0000a39c, 0x0075393f},
- {0x0000a3a0, 0xb79f6427},
- {0x0000a3a4, 0x00000000},
- {0x0000a3a8, 0xaaaaaaaa},
- {0x0000a3ac, 0x3c466478},
+ {0x0000a398, 0x00000000},
+ {0x0000a39c, 0x210d0401},
+ {0x0000a3a0, 0xab9a7144},
+ {0x0000a3a4, 0x00000011},
+ {0x0000a3a8, 0x3c3c003d},
+ {0x0000a3ac, 0x30310030},
  {0x0000a3c0, 0x20202020},
  {0x0000a3c4, 0x22222220},
  {0x0000a3c8, 0x20200020},
@@ -686,100 +688,18 @@ static const u32 ar9331_1p1_baseband_core[][2] = {
  {0x0000a7dc, 0x00000001},
 };
 
-static const u32 ar9331_modes_high_power_tx_gain_1p1[][5] = {
+static const u32 ar9331_1p1_mac_postamble[][5] = {
  /* Addr      5G_HT20     5G_HT40     2G_HT40     2G_HT20   */
- {0x0000a2d8, 0x7999a83a, 0x7999a83a, 0x7999a83a, 0x7999a83a},
- {0x0000a2dc, 0xffff2a52, 0xffff2a52, 0xffff2a52, 0xffff2a52},
- {0x0000a2e0, 0xffffcc84, 0xffffcc84, 0xffffcc84, 0xffffcc84},
- {0x0000a2e4, 0xfffff000, 0xfffff000, 0xfffff000, 0xfffff000},
- {0x0000a2e8, 0xfffe0000, 0xfffe0000, 0xfffe0000, 0xfffe0000},
- {0x0000a410, 0x000050d7, 0x000050d7, 0x000050d0, 0x000050d0},
- {0x0000a500, 0x00022200, 0x00022200, 0x00000000, 0x00000000},
- {0x0000a504, 0x05062002, 0x05062002, 0x04000002, 0x04000002},
- {0x0000a508, 0x0c002e00, 0x0c002e00, 0x08000004, 0x08000004},
- {0x0000a50c, 0x11062202, 0x11062202, 0x0d000200, 0x0d000200},
- {0x0000a510, 0x17022e00, 0x17022e00, 0x11000202, 0x11000202},
- {0x0000a514, 0x1d000ec2, 0x1d000ec2, 0x15000400, 0x15000400},
- {0x0000a518, 0x25020ec0, 0x25020ec0, 0x19000402, 0x19000402},
- {0x0000a51c, 0x2b020ec3, 0x2b020ec3, 0x1d000404, 0x1d000404},
- {0x0000a520, 0x2f001f04, 0x2f001f04, 0x23000a00, 0x23000a00},
- {0x0000a524, 0x35001fc4, 0x35001fc4, 0x27000a02, 0x27000a02},
- {0x0000a528, 0x3c022f04, 0x3c022f04, 0x2b000a04, 0x2b000a04},
- {0x0000a52c, 0x41023e85, 0x41023e85, 0x2d000a20, 0x2d000a20},
- {0x0000a530, 0x48023ec6, 0x48023ec6, 0x31000a22, 0x31000a22},
- {0x0000a534, 0x4d023f01, 0x4d023f01, 0x35000a24, 0x35000a24},
- {0x0000a538, 0x53023f4b, 0x53023f4b, 0x38000a43, 0x38000a43},
- {0x0000a53c, 0x5a027f09, 0x5a027f09, 0x3b000e42, 0x3b000e42},
- {0x0000a540, 0x5f027fc9, 0x5f027fc9, 0x3f000e44, 0x3f000e44},
- {0x0000a544, 0x6502feca, 0x6502feca, 0x42000e64, 0x42000e64},
- {0x0000a548, 0x6b02ff4a, 0x6b02ff4a, 0x46000e66, 0x46000e66},
- {0x0000a54c, 0x7203feca, 0x7203feca, 0x4a000ea6, 0x4a000ea6},
- {0x0000a550, 0x7703ff0b, 0x7703ff0b, 0x4a000ea6, 0x4a000ea6},
- {0x0000a554, 0x7d06ffcb, 0x7d06ffcb, 0x4a000ea6, 0x4a000ea6},
- {0x0000a558, 0x8407ff0b, 0x8407ff0b, 0x4a000ea6, 0x4a000ea6},
- {0x0000a55c, 0x8907ffcb, 0x8907ffcb, 0x4a000ea6, 0x4a000ea6},
- {0x0000a560, 0x900fff0b, 0x900fff0b, 0x4a000ea6, 0x4a000ea6},
- {0x0000a564, 0x960fffcb, 0x960fffcb, 0x4a000ea6, 0x4a000ea6},
- {0x0000a568, 0x9c1fff0b, 0x9c1fff0b, 0x4a000ea6, 0x4a000ea6},
- {0x0000a56c, 0x9c1fff0b, 0x9c1fff0b, 0x4a000ea6, 0x4a000ea6},
- {0x0000a570, 0x9c1fff0b, 0x9c1fff0b, 0x4a000ea6, 0x4a000ea6},
- {0x0000a574, 0x9c1fff0b, 0x9c1fff0b, 0x4a000ea6, 0x4a000ea6},
- {0x0000a578, 0x9c1fff0b, 0x9c1fff0b, 0x4a000ea6, 0x4a000ea6},
- {0x0000a57c, 0x9c1fff0b, 0x9c1fff0b, 0x4a000ea6, 0x4a000ea6},
- {0x0000a580, 0x00022200, 0x00022200, 0x00000000, 0x00000000},
- {0x0000a584, 0x05062002, 0x05062002, 0x04000002, 0x04000002},
- {0x0000a588, 0x0c002e00, 0x0c002e00, 0x08000004, 0x08000004},
- {0x0000a58c, 0x11062202, 0x11062202, 0x0b000200, 0x0b000200},
- {0x0000a590, 0x17022e00, 0x17022e00, 0x0f000202, 0x0f000202},
- {0x0000a594, 0x1d000ec2, 0x1d000ec2, 0x11000400, 0x11000400},
- {0x0000a598, 0x25020ec0, 0x25020ec0, 0x15000402, 0x15000402},
- {0x0000a59c, 0x2b020ec3, 0x2b020ec3, 0x19000404, 0x19000404},
- {0x0000a5a0, 0x2f001f04, 0x2f001f04, 0x1b000603, 0x1b000603},
- {0x0000a5a4, 0x35001fc4, 0x35001fc4, 0x1f000a02, 0x1f000a02},
- {0x0000a5a8, 0x3c022f04, 0x3c022f04, 0x23000a04, 0x23000a04},
- {0x0000a5ac, 0x41023e85, 0x41023e85, 0x26000a20, 0x26000a20},
- {0x0000a5b0, 0x48023ec6, 0x48023ec6, 0x2a000e20, 0x2a000e20},
- {0x0000a5b4, 0x4d023f01, 0x4d023f01, 0x2e000e22, 0x2e000e22},
- {0x0000a5b8, 0x53023f4b, 0x53023f4b, 0x31000e24, 0x31000e24},
- {0x0000a5bc, 0x5a027f09, 0x5a027f09, 0x34001640, 0x34001640},
- {0x0000a5c0, 0x5f027fc9, 0x5f027fc9, 0x38001660, 0x38001660},
- {0x0000a5c4, 0x6502feca, 0x6502feca, 0x3b001861, 0x3b001861},
- {0x0000a5c8, 0x6b02ff4a, 0x6b02ff4a, 0x3e001a81, 0x3e001a81},
- {0x0000a5cc, 0x7203feca, 0x7203feca, 0x42001a83, 0x42001a83},
- {0x0000a5d0, 0x7703ff0b, 0x7703ff0b, 0x44001c84, 0x44001c84},
- {0x0000a5d4, 0x7d06ffcb, 0x7d06ffcb, 0x48001ce3, 0x48001ce3},
- {0x0000a5d8, 0x8407ff0b, 0x8407ff0b, 0x4c001ce5, 0x4c001ce5},
- {0x0000a5dc, 0x8907ffcb, 0x8907ffcb, 0x50001ce9, 0x50001ce9},
- {0x0000a5e0, 0x900fff0b, 0x900fff0b, 0x54001ceb, 0x54001ceb},
- {0x0000a5e4, 0x960fffcb, 0x960fffcb, 0x56001eec, 0x56001eec},
- {0x0000a5e8, 0x9c1fff0b, 0x9c1fff0b, 0x56001eec, 0x56001eec},
- {0x0000a5ec, 0x9c1fff0b, 0x9c1fff0b, 0x56001eec, 0x56001eec},
- {0x0000a5f0, 0x9c1fff0b, 0x9c1fff0b, 0x56001eec, 0x56001eec},
- {0x0000a5f4, 0x9c1fff0b, 0x9c1fff0b, 0x56001eec, 0x56001eec},
- {0x0000a5f8, 0x9c1fff0b, 0x9c1fff0b, 0x56001eec, 0x56001eec},
- {0x0000a5fc, 0x9c1fff0b, 0x9c1fff0b, 0x56001eec, 0x56001eec},
- {0x0000a600, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
- {0x0000a604, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
- {0x0000a608, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
- {0x0000a60c, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
- {0x0000a610, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
- {0x0000a614, 0x01404000, 0x01404000, 0x01404000, 0x01404000},
- {0x0000a618, 0x01404501, 0x01404501, 0x01404501, 0x01404501},
- {0x0000a61c, 0x02008802, 0x02008802, 0x02008802, 0x02008802},
- {0x0000a620, 0x0280c802, 0x0280c802, 0x0280c802, 0x0280c802},
- {0x0000a624, 0x03010a03, 0x03010a03, 0x03010a03, 0x03010a03},
- {0x0000a628, 0x03010c04, 0x03010c04, 0x03010c04, 0x03010c04},
- {0x0000a62c, 0x03010c04, 0x03010c04, 0x03010c04, 0x03010c04},
- {0x0000a630, 0x03010c04, 0x03010c04, 0x03010c04, 0x03010c04},
- {0x0000a634, 0x03010c04, 0x03010c04, 0x03010c04, 0x03010c04},
- {0x0000a638, 0x03010c04, 0x03010c04, 0x03010c04, 0x03010c04},
- {0x0000a63c, 0x03010c04, 0x03010c04, 0x03010c04, 0x03010c04},
- {0x00016044, 0x034922db, 0x034922db, 0x034922db, 0x034922db},
- {0x00016284, 0x14d3f000, 0x14d3f000, 0x14d3f000, 0x14d3f000},
+ {0x00001030, 0x00000230, 0x00000460, 0x000002c0, 0x00000160},
+ {0x00001070, 0x00000168, 0x000002d0, 0x00000318, 0x0000018c},
+ {0x000010b0, 0x00000e60, 0x00001cc0, 0x00007c70, 0x00003e38},
+ {0x00008014, 0x03e803e8, 0x07d007d0, 0x10801600, 0x08400b00},
+ {0x0000801c, 0x128d8027, 0x128d804f, 0x12e00057, 0x12e0002b},
+ {0x00008120, 0x08f04800, 0x08f04800, 0x08f04810, 0x08f04810},
+ {0x000081d0, 0x00003210, 0x00003210, 0x0000320a, 0x0000320a},
+ {0x00008318, 0x00003e80, 0x00007d00, 0x00006880, 0x00003440},
 };
 
-#define ar9331_1p1_mac_postamble ar9300_2p2_mac_postamble
-
 static const u32 ar9331_1p1_soc_preamble[][2] = {
  /* Addr      allmodes  */
  {0x00007020, 0x00000000},
diff --git a/drivers/net/wireless/ath/ath9k/ar9330_1p2_initvals.h b/drivers/net/wireless/ath/ath9k/ar9330_1p2_initvals.h
index 57ed8a1..2154efc 100644
--- a/drivers/net/wireless/ath/ath9k/ar9330_1p2_initvals.h
+++ b/drivers/net/wireless/ath/ath9k/ar9330_1p2_initvals.h
@@ -18,6 +18,28 @@
 #ifndef INITVALS_9330_1P2_H
 #define INITVALS_9330_1P2_H
 
+#define ar9331_modes_high_power_tx_gain_1p2 ar9331_modes_high_ob_db_tx_gain_1p2
+
+#define ar9331_modes_low_ob_db_tx_gain_1p2 ar9331_modes_high_ob_db_tx_gain_1p2
+
+#define ar9331_modes_lowest_ob_db_tx_gain_1p2 ar9331_modes_high_ob_db_tx_gain_1p2
+
+#define ar9331_1p2_baseband_core_txfir_coeff_japan_2484 ar9331_1p1_baseband_core_txfir_coeff_japan_2484
+
+#define ar9331_1p2_xtal_25M ar9331_1p1_xtal_25M
+
+#define ar9331_1p2_xtal_40M ar9331_1p1_xtal_40M
+
+#define ar9331_1p2_soc_postamble ar9331_1p1_soc_postamble
+
+#define ar9331_1p2_mac_postamble ar9331_1p1_mac_postamble
+
+#define ar9331_1p2_soc_preamble ar9331_1p1_soc_preamble
+
+#define ar9331_1p2_mac_core ar9331_1p1_mac_core
+
+#define ar9331_common_wo_xlna_rx_gain_1p2 ar9331_common_wo_xlna_rx_gain_1p1
+
 static const u32 ar9331_modes_high_ob_db_tx_gain_1p2[][5] = {
  /* Addr      5G_HT20     5G_HT40     2G_HT40     2G_HT20   */
  {0x0000a410, 0x000050d7, 0x000050d7, 0x000050d7, 0x000050d7},
@@ -103,57 +125,6 @@ static const u32 ar9331_modes_high_ob_db_tx_gain_1p2[][5] = {
  {0x0000a63c, 0x04011004, 0x04011004, 0x04011004, 0x04011004},
 };
 
-#define ar9331_modes_high_power_tx_gain_1p2 ar9331_modes_high_ob_db_tx_gain_1p2
-
-#define ar9331_modes_low_ob_db_tx_gain_1p2 ar9331_modes_high_power_tx_gain_1p2
-
-#define ar9331_modes_lowest_ob_db_tx_gain_1p2 ar9331_modes_low_ob_db_tx_gain_1p2
-
-static const u32 ar9331_1p2_baseband_postamble[][5] = {
- /* Addr      5G_HT20     5G_HT40     2G_HT40     2G_HT20   */
- {0x00009810, 0xd00a8005, 0xd00a8005, 0xd00a8005, 0xd00a8005},
- {0x00009820, 0x206a002e, 0x206a002e, 0x206a002e, 0x206a002e},
- {0x00009824, 0x5ac640d0, 0x5ac640d0, 0x5ac640d0, 0x5ac640d0},
- {0x00009828, 0x06903081, 0x06903081, 0x06903881, 0x06903881},
- {0x0000982c, 0x05eea6d4, 0x05eea6d4, 0x05eea6d4, 0x05eea6d4},
- {0x00009830, 0x0000059c, 0x0000059c, 0x0000059c, 0x0000059c},
- {0x00009c00, 0x00000044, 0x00000044, 0x00000044, 0x00000044},
- {0x00009e00, 0x0372161e, 0x0372161e, 0x037216a4, 0x037216a4},
- {0x00009e04, 0x00182020, 0x00182020, 0x00182020, 0x00182020},
- {0x00009e0c, 0x6c4000e2, 0x6d4000e2, 0x6d4000e2, 0x6c4000e2},
- {0x00009e10, 0x7ec80d2e, 0x7ec80d2e, 0x7ec80d2e, 0x7ec80d2e},
- {0x00009e14, 0x31395d5e, 0x3139605e, 0x3139605e, 0x31395d5e},
- {0x00009e18, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
- {0x00009e1c, 0x0001cf9c, 0x0001cf9c, 0x00021f9c, 0x00021f9c},
- {0x00009e20, 0x000003b5, 0x000003b5, 0x000003ce, 0x000003ce},
- {0x00009e2c, 0x0000001c, 0x0000001c, 0x00003221, 0x00003221},
- {0x00009e3c, 0xcf946222, 0xcf946222, 0xcf946222, 0xcf946222},
- {0x00009e44, 0x02321e27, 0x02321e27, 0x02282324, 0x02282324},
- {0x00009e48, 0x5030201a, 0x5030201a, 0x50302010, 0x50302010},
- {0x00009fc8, 0x0003f000, 0x0003f000, 0x0001a000, 0x0001a000},
- {0x0000a204, 0x00003fc0, 0x00003fc4, 0x00003fc4, 0x00003fc0},
- {0x0000a208, 0x00000104, 0x00000104, 0x00000004, 0x00000004},
- {0x0000a230, 0x0000000a, 0x00000014, 0x00000016, 0x0000000b},
- {0x0000a234, 0x00000fff, 0x00000fff, 0x10000fff, 0x00000fff},
- {0x0000a238, 0xffb81018, 0xffb81018, 0xffb81018, 0xffb81018},
- {0x0000a250, 0x00000000, 0x00000000, 0x00000210, 0x00000108},
- {0x0000a254, 0x000007d0, 0x00000fa0, 0x00001130, 0x00000898},
- {0x0000a258, 0x02020002, 0x02020002, 0x02020002, 0x02020002},
- {0x0000a25c, 0x01000e0e, 0x01000e0e, 0x01000e0e, 0x01000e0e},
- {0x0000a260, 0x3a021501, 0x3a021501, 0x3a021501, 0x3a021501},
- {0x0000a264, 0x00000e0e, 0x00000e0e, 0x00000e0e, 0x00000e0e},
- {0x0000a280, 0x00000007, 0x00000007, 0x0000000b, 0x0000000b},
- {0x0000a284, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
- {0x0000a288, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
- {0x0000a28c, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
- {0x0000a2c4, 0x00158d18, 0x00158d18, 0x00158d18, 0x00158d18},
- {0x0000a2d0, 0x00071981, 0x00071981, 0x00071981, 0x00071981},
- {0x0000a2d8, 0xf999a83a, 0xf999a83a, 0xf999a83a, 0xf999a83a},
- {0x0000a358, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
- {0x0000ae04, 0x00802020, 0x00802020, 0x00802020, 0x00802020},
- {0x0000ae18, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
-};
-
 static const u32 ar9331_1p2_radio_core[][2] = {
  /* Addr      allmodes  */
  {0x00016000, 0x36db6db6},
@@ -219,24 +190,318 @@ static const u32 ar9331_1p2_radio_core[][2] = {
  {0x000163d4, 0x00000000},
 };
 
-#define ar9331_1p2_baseband_core_txfir_coeff_japan_2484 ar9331_1p1_baseband_core_txfir_coeff_japan_2484
-
-#define ar9331_1p2_xtal_25M ar9331_1p1_xtal_25M
-
-#define ar9331_1p2_xtal_40M ar9331_1p1_xtal_40M
-
-#define ar9331_1p2_baseband_core ar9331_1p1_baseband_core
-
-#define ar9331_1p2_soc_postamble ar9331_1p1_soc_postamble
-
-#define ar9331_1p2_mac_postamble ar9331_1p1_mac_postamble
-
-#define ar9331_1p2_soc_preamble ar9331_1p1_soc_preamble
-
-#define ar9331_1p2_mac_core ar9331_1p1_mac_core
+static const u32 ar9331_1p2_baseband_core[][2] = {
+ /* Addr      allmodes  */
+ {0x00009800, 0xafe68e30},
+ {0x00009804, 0xfd14e000},
+ {0x00009808, 0x9c0a8f6b},
+ {0x0000980c, 0x04800000},
+ {0x00009814, 0x9280c00a},
+ {0x00009818, 0x00000000},
+ {0x0000981c, 0x00020028},
+ {0x00009834, 0x5f3ca3de},
+ {0x00009838, 0x0108ecff},
+ {0x0000983c, 0x14750600},
+ {0x00009880, 0x201fff00},
+ {0x00009884, 0x00001042},
+ {0x000098a4, 0x00200400},
+ {0x000098b0, 0x32840bbe},
+ {0x000098d0, 0x004b6a8e},
+ {0x000098d4, 0x00000820},
+ {0x000098dc, 0x00000000},
+ {0x000098f0, 0x00000000},
+ {0x000098f4, 0x00000000},
+ {0x00009c04, 0x00000000},
+ {0x00009c08, 0x03200000},
+ {0x00009c0c, 0x00000000},
+ {0x00009c10, 0x00000000},
+ {0x00009c14, 0x00046384},
+ {0x00009c18, 0x05b6b440},
+ {0x00009c1c, 0x00b6b440},
+ {0x00009d00, 0xc080a333},
+ {0x00009d04, 0x40206c10},
+ {0x00009d08, 0x009c4060},
+ {0x00009d0c, 0x1883800a},
+ {0x00009d10, 0x01834061},
+ {0x00009d14, 0x00c00400},
+ {0x00009d18, 0x00000000},
+ {0x00009e08, 0x0038233c},
+ {0x00009e24, 0x9927b515},
+ {0x00009e28, 0x12ef0200},
+ {0x00009e30, 0x06336f77},
+ {0x00009e34, 0x6af6532f},
+ {0x00009e38, 0x0cc80c00},
+ {0x00009e40, 0x0d261800},
+ {0x00009e4c, 0x00001004},
+ {0x00009e50, 0x00ff03f1},
+ {0x00009fc0, 0x803e4788},
+ {0x00009fc4, 0x0001efb5},
+ {0x00009fcc, 0x40000014},
+ {0x0000a20c, 0x00000000},
+ {0x0000a220, 0x00000000},
+ {0x0000a224, 0x00000000},
+ {0x0000a228, 0x10002310},
+ {0x0000a23c, 0x00000000},
+ {0x0000a244, 0x0c000000},
+ {0x0000a2a0, 0x00000001},
+ {0x0000a2c0, 0x00000001},
+ {0x0000a2c8, 0x00000000},
+ {0x0000a2cc, 0x18c43433},
+ {0x0000a2d4, 0x00000000},
+ {0x0000a2dc, 0x00000000},
+ {0x0000a2e0, 0x00000000},
+ {0x0000a2e4, 0x00000000},
+ {0x0000a2e8, 0x00000000},
+ {0x0000a2ec, 0x00000000},
+ {0x0000a2f0, 0x00000000},
+ {0x0000a2f4, 0x00000000},
+ {0x0000a2f8, 0x00000000},
+ {0x0000a344, 0x00000000},
+ {0x0000a34c, 0x00000000},
+ {0x0000a350, 0x0000a000},
+ {0x0000a364, 0x00000000},
+ {0x0000a370, 0x00000000},
+ {0x0000a390, 0x00000001},
+ {0x0000a394, 0x00000444},
+ {0x0000a398, 0x001f0e0f},
+ {0x0000a39c, 0x0075393f},
+ {0x0000a3a0, 0xb79f6427},
+ {0x0000a3a4, 0x00000000},
+ {0x0000a3a8, 0xaaaaaaaa},
+ {0x0000a3ac, 0x3c466478},
+ {0x0000a3c0, 0x20202020},
+ {0x0000a3c4, 0x22222220},
+ {0x0000a3c8, 0x20200020},
+ {0x0000a3cc, 0x20202020},
+ {0x0000a3d0, 0x20202020},
+ {0x0000a3d4, 0x20202020},
+ {0x0000a3d8, 0x20202020},
+ {0x0000a3dc, 0x20202020},
+ {0x0000a3e0, 0x20202020},
+ {0x0000a3e4, 0x20202020},
+ {0x0000a3e8, 0x20202020},
+ {0x0000a3ec, 0x20202020},
+ {0x0000a3f0, 0x00000000},
+ {0x0000a3f4, 0x00000006},
+ {0x0000a3f8, 0x0cdbd380},
+ {0x0000a3fc, 0x000f0f01},
+ {0x0000a400, 0x8fa91f01},
+ {0x0000a404, 0x00000000},
+ {0x0000a408, 0x0e79e5c6},
+ {0x0000a40c, 0x00820820},
+ {0x0000a414, 0x1ce739ce},
+ {0x0000a418, 0x2d001dce},
+ {0x0000a41c, 0x1ce739ce},
+ {0x0000a420, 0x000001ce},
+ {0x0000a424, 0x1ce739ce},
+ {0x0000a428, 0x000001ce},
+ {0x0000a42c, 0x1ce739ce},
+ {0x0000a430, 0x1ce739ce},
+ {0x0000a434, 0x00000000},
+ {0x0000a438, 0x00001801},
+ {0x0000a43c, 0x00000000},
+ {0x0000a440, 0x00000000},
+ {0x0000a444, 0x00000000},
+ {0x0000a448, 0x04000000},
+ {0x0000a44c, 0x00000001},
+ {0x0000a450, 0x00010000},
+ {0x0000a458, 0x00000000},
+ {0x0000a640, 0x00000000},
+ {0x0000a644, 0x3fad9d74},
+ {0x0000a648, 0x0048060a},
+ {0x0000a64c, 0x00003c37},
+ {0x0000a670, 0x03020100},
+ {0x0000a674, 0x09080504},
+ {0x0000a678, 0x0d0c0b0a},
+ {0x0000a67c, 0x13121110},
+ {0x0000a680, 0x31301514},
+ {0x0000a684, 0x35343332},
+ {0x0000a688, 0x00000036},
+ {0x0000a690, 0x00000838},
+ {0x0000a7c0, 0x00000000},
+ {0x0000a7c4, 0xfffffffc},
+ {0x0000a7c8, 0x00000000},
+ {0x0000a7cc, 0x00000000},
+ {0x0000a7d0, 0x00000000},
+ {0x0000a7d4, 0x00000004},
+ {0x0000a7dc, 0x00000001},
+};
 
-#define ar9331_common_wo_xlna_rx_gain_1p2 ar9331_common_wo_xlna_rx_gain_1p1
+static const u32 ar9331_1p2_baseband_postamble[][5] = {
+ /* Addr      5G_HT20     5G_HT40     2G_HT40     2G_HT20   */
+ {0x00009810, 0xd00a8005, 0xd00a8005, 0xd00a8005, 0xd00a8005},
+ {0x00009820, 0x206a002e, 0x206a002e, 0x206a002e, 0x206a002e},
+ {0x00009824, 0x5ac640d0, 0x5ac640d0, 0x5ac640d0, 0x5ac640d0},
+ {0x00009828, 0x06903081, 0x06903081, 0x06903881, 0x06903881},
+ {0x0000982c, 0x05eea6d4, 0x05eea6d4, 0x05eea6d4, 0x05eea6d4},
+ {0x00009830, 0x0000059c, 0x0000059c, 0x0000059c, 0x0000059c},
+ {0x00009c00, 0x00000044, 0x00000044, 0x00000044, 0x00000044},
+ {0x00009e00, 0x0372161e, 0x0372161e, 0x037216a4, 0x037216a4},
+ {0x00009e04, 0x00182020, 0x00182020, 0x00182020, 0x00182020},
+ {0x00009e0c, 0x6c4000e2, 0x6d4000e2, 0x6d4000e2, 0x6c4000e2},
+ {0x00009e10, 0x7ec80d2e, 0x7ec80d2e, 0x7ec80d2e, 0x7ec80d2e},
+ {0x00009e14, 0x31395d5e, 0x3139605e, 0x3139605e, 0x31395d5e},
+ {0x00009e18, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
+ {0x00009e1c, 0x0001cf9c, 0x0001cf9c, 0x00021f9c, 0x00021f9c},
+ {0x00009e20, 0x000003b5, 0x000003b5, 0x000003ce, 0x000003ce},
+ {0x00009e2c, 0x0000001c, 0x0000001c, 0x00003221, 0x00003221},
+ {0x00009e3c, 0xcf946222, 0xcf946222, 0xcf946222, 0xcf946222},
+ {0x00009e44, 0x02321e27, 0x02321e27, 0x02282324, 0x02282324},
+ {0x00009e48, 0x5030201a, 0x5030201a, 0x50302010, 0x50302010},
+ {0x00009fc8, 0x0003f000, 0x0003f000, 0x0001a000, 0x0001a000},
+ {0x0000a204, 0x00003fc0, 0x00003fc4, 0x00003fc4, 0x00003fc0},
+ {0x0000a208, 0x00000104, 0x00000104, 0x00000004, 0x00000004},
+ {0x0000a230, 0x0000000a, 0x00000014, 0x00000016, 0x0000000b},
+ {0x0000a234, 0x00000fff, 0x00000fff, 0x10000fff, 0x00000fff},
+ {0x0000a238, 0xffb81018, 0xffb81018, 0xffb81018, 0xffb81018},
+ {0x0000a250, 0x00000000, 0x00000000, 0x00000210, 0x00000108},
+ {0x0000a254, 0x000007d0, 0x00000fa0, 0x00001130, 0x00000898},
+ {0x0000a258, 0x02020002, 0x02020002, 0x02020002, 0x02020002},
+ {0x0000a25c, 0x01000e0e, 0x01000e0e, 0x01000e0e, 0x01000e0e},
+ {0x0000a260, 0x3a021501, 0x3a021501, 0x3a021501, 0x3a021501},
+ {0x0000a264, 0x00000e0e, 0x00000e0e, 0x00000e0e, 0x00000e0e},
+ {0x0000a280, 0x00000007, 0x00000007, 0x0000000b, 0x0000000b},
+ {0x0000a284, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
+ {0x0000a288, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
+ {0x0000a28c, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
+ {0x0000a2c4, 0x00158d18, 0x00158d18, 0x00158d18, 0x00158d18},
+ {0x0000a2d0, 0x00071981, 0x00071981, 0x00071981, 0x00071981},
+ {0x0000a2d8, 0xf999a83a, 0xf999a83a, 0xf999a83a, 0xf999a83a},
+ {0x0000a358, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
+ {0x0000ae04, 0x00802020, 0x00802020, 0x00802020, 0x00802020},
+ {0x0000ae18, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
+};
 
-#define ar9331_common_rx_gain_1p2 ar9485_common_rx_gain_1_1
+static const u32 ar9331_common_rx_gain_1p2[][2] = {
+ /* Addr      allmodes  */
+ {0x0000a000, 0x00010000},
+ {0x0000a004, 0x00030002},
+ {0x0000a008, 0x00050004},
+ {0x0000a00c, 0x00810080},
+ {0x0000a010, 0x01800082},
+ {0x0000a014, 0x01820181},
+ {0x0000a018, 0x01840183},
+ {0x0000a01c, 0x01880185},
+ {0x0000a020, 0x018a0189},
+ {0x0000a024, 0x02850284},
+ {0x0000a028, 0x02890288},
+ {0x0000a02c, 0x03850384},
+ {0x0000a030, 0x03890388},
+ {0x0000a034, 0x038b038a},
+ {0x0000a038, 0x038d038c},
+ {0x0000a03c, 0x03910390},
+ {0x0000a040, 0x03930392},
+ {0x0000a044, 0x03950394},
+ {0x0000a048, 0x00000396},
+ {0x0000a04c, 0x00000000},
+ {0x0000a050, 0x00000000},
+ {0x0000a054, 0x00000000},
+ {0x0000a058, 0x00000000},
+ {0x0000a05c, 0x00000000},
+ {0x0000a060, 0x00000000},
+ {0x0000a064, 0x00000000},
+ {0x0000a068, 0x00000000},
+ {0x0000a06c, 0x00000000},
+ {0x0000a070, 0x00000000},
+ {0x0000a074, 0x00000000},
+ {0x0000a078, 0x00000000},
+ {0x0000a07c, 0x00000000},
+ {0x0000a080, 0x28282828},
+ {0x0000a084, 0x28282828},
+ {0x0000a088, 0x28282828},
+ {0x0000a08c, 0x28282828},
+ {0x0000a090, 0x28282828},
+ {0x0000a094, 0x21212128},
+ {0x0000a098, 0x171c1c1c},
+ {0x0000a09c, 0x02020212},
+ {0x0000a0a0, 0x00000202},
+ {0x0000a0a4, 0x00000000},
+ {0x0000a0a8, 0x00000000},
+ {0x0000a0ac, 0x00000000},
+ {0x0000a0b0, 0x00000000},
+ {0x0000a0b4, 0x00000000},
+ {0x0000a0b8, 0x00000000},
+ {0x0000a0bc, 0x00000000},
+ {0x0000a0c0, 0x001f0000},
+ {0x0000a0c4, 0x111f1100},
+ {0x0000a0c8, 0x111d111e},
+ {0x0000a0cc, 0x111b111c},
+ {0x0000a0d0, 0x22032204},
+ {0x0000a0d4, 0x22012202},
+ {0x0000a0d8, 0x221f2200},
+ {0x0000a0dc, 0x221d221e},
+ {0x0000a0e0, 0x33013302},
+ {0x0000a0e4, 0x331f3300},
+ {0x0000a0e8, 0x4402331e},
+ {0x0000a0ec, 0x44004401},
+ {0x0000a0f0, 0x441e441f},
+ {0x0000a0f4, 0x55015502},
+ {0x0000a0f8, 0x551f5500},
+ {0x0000a0fc, 0x6602551e},
+ {0x0000a100, 0x66006601},
+ {0x0000a104, 0x661e661f},
+ {0x0000a108, 0x7703661d},
+ {0x0000a10c, 0x77017702},
+ {0x0000a110, 0x00007700},
+ {0x0000a114, 0x00000000},
+ {0x0000a118, 0x00000000},
+ {0x0000a11c, 0x00000000},
+ {0x0000a120, 0x00000000},
+ {0x0000a124, 0x00000000},
+ {0x0000a128, 0x00000000},
+ {0x0000a12c, 0x00000000},
+ {0x0000a130, 0x00000000},
+ {0x0000a134, 0x00000000},
+ {0x0000a138, 0x00000000},
+ {0x0000a13c, 0x00000000},
+ {0x0000a140, 0x001f0000},
+ {0x0000a144, 0x111f1100},
+ {0x0000a148, 0x111d111e},
+ {0x0000a14c, 0x111b111c},
+ {0x0000a150, 0x22032204},
+ {0x0000a154, 0x22012202},
+ {0x0000a158, 0x221f2200},
+ {0x0000a15c, 0x221d221e},
+ {0x0000a160, 0x33013302},
+ {0x0000a164, 0x331f3300},
+ {0x0000a168, 0x4402331e},
+ {0x0000a16c, 0x44004401},
+ {0x0000a170, 0x441e441f},
+ {0x0000a174, 0x55015502},
+ {0x0000a178, 0x551f5500},
+ {0x0000a17c, 0x6602551e},
+ {0x0000a180, 0x66006601},
+ {0x0000a184, 0x661e661f},
+ {0x0000a188, 0x7703661d},
+ {0x0000a18c, 0x77017702},
+ {0x0000a190, 0x00007700},
+ {0x0000a194, 0x00000000},
+ {0x0000a198, 0x00000000},
+ {0x0000a19c, 0x00000000},
+ {0x0000a1a0, 0x00000000},
+ {0x0000a1a4, 0x00000000},
+ {0x0000a1a8, 0x00000000},
+ {0x0000a1ac, 0x00000000},
+ {0x0000a1b0, 0x00000000},
+ {0x0000a1b4, 0x00000000},
+ {0x0000a1b8, 0x00000000},
+ {0x0000a1bc, 0x00000000},
+ {0x0000a1c0, 0x00000000},
+ {0x0000a1c4, 0x00000000},
+ {0x0000a1c8, 0x00000000},
+ {0x0000a1cc, 0x00000000},
+ {0x0000a1d0, 0x00000000},
+ {0x0000a1d4, 0x00000000},
+ {0x0000a1d8, 0x00000000},
+ {0x0000a1dc, 0x00000000},
+ {0x0000a1e0, 0x00000000},
+ {0x0000a1e4, 0x00000000},
+ {0x0000a1e8, 0x00000000},
+ {0x0000a1ec, 0x00000000},
+ {0x0000a1f0, 0x00000396},
+ {0x0000a1f4, 0x00000396},
+ {0x0000a1f8, 0x00000396},
+ {0x0000a1fc, 0x00000296},
+};
 
 #endif /* INITVALS_9330_1P2_H */
diff --git a/drivers/net/wireless/ath/ath9k/ar9340_initvals.h b/drivers/net/wireless/ath/ath9k/ar9340_initvals.h
index 25db921..b995ffe 100644
--- a/drivers/net/wireless/ath/ath9k/ar9340_initvals.h
+++ b/drivers/net/wireless/ath/ath9k/ar9340_initvals.h
@@ -18,6 +18,20 @@
 #ifndef INITVALS_9340_H
 #define INITVALS_9340_H
 
+#define ar9340_1p0_mac_postamble ar9300_2p2_mac_postamble
+
+#define ar9340_1p0_soc_postamble ar9300_2p2_soc_postamble
+
+#define ar9340Modes_fast_clock_1p0 ar9300Modes_fast_clock_2p2
+
+#define ar9340Common_rx_gain_table_1p0 ar9300Common_rx_gain_table_2p2
+
+#define ar9340Common_wo_xlna_rx_gain_table_1p0 ar9300Common_wo_xlna_rx_gain_table_2p2
+
+#define ar9340_1p0_baseband_core_txfir_coeff_japan_2484 ar9300_2p2_baseband_core_txfir_coeff_japan_2484
+
+#define ar9340_1p0_baseband_postamble_dfs_channel ar9300_2p2_baseband_postamble_dfs_channel
+
 static const u32 ar9340_1p0_radio_postamble[][5] = {
  /* Addr      5G_HT20     5G_HT40     2G_HT40     2G_HT20   */
  {0x000160ac, 0xa4646800, 0xa4646800, 0xa4646800, 0xa4646800},
@@ -100,8 +114,6 @@ static const u32 ar9340Modes_lowest_ob_db_tx_gain_table_1p0[][5] = {
  {0x00016448, 0x24925266, 0x24925266, 0x24925266, 0x24925266},
 };
 
-#define ar9340Modes_fast_clock_1p0 ar9300Modes_fast_clock_2p2
-
 static const u32 ar9340_1p0_radio_core[][2] = {
  /* Addr      allmodes  */
  {0x00016000, 0x36db6db6},
@@ -215,16 +227,12 @@ static const u32 ar9340_1p0_radio_core_40M[][2] = {
  {0x0000824c, 0x0001e800},
 };
 
-#define ar9340_1p0_mac_postamble ar9300_2p2_mac_postamble
-
-#define ar9340_1p0_soc_postamble ar9300_2p2_soc_postamble
-
 static const u32 ar9340_1p0_baseband_postamble[][5] = {
  /* Addr      5G_HT20     5G_HT40     2G_HT40     2G_HT20   */
  {0x00009810, 0xd00a8005, 0xd00a8005, 0xd00a8011, 0xd00a8011},
  {0x00009820, 0x206a022e, 0x206a022e, 0x206a022e, 0x206a022e},
  {0x00009824, 0x5ac640d0, 0x5ac640d0, 0x5ac640d0, 0x5ac640d0},
- {0x00009828, 0x06903081, 0x06903081, 0x06903881, 0x06903881},
+ {0x00009828, 0x06903081, 0x06903081, 0x09103881, 0x09103881},
  {0x0000982c, 0x05eea6d4, 0x05eea6d4, 0x05eea6d4, 0x05eea6d4},
  {0x00009830, 0x0000059c, 0x0000059c, 0x0000119c, 0x0000119c},
  {0x00009c00, 0x000000c4, 0x000000c4, 0x000000c4, 0x000000c4},
@@ -310,7 +318,7 @@ static const u32 ar9340_1p0_baseband_core[][2] = {
  {0x00009e30, 0x06336f77},
  {0x00009e34, 0x6af6532f},
  {0x00009e38, 0x0cc80c00},
- {0x00009e40, 0x0d261820},
+ {0x00009e40, 0x0d261800},
  {0x00009e4c, 0x00001004},
  {0x00009e50, 0x00ff03f1},
  {0x00009e54, 0x00000000},
@@ -714,266 +722,6 @@ static const u32 ar9340Modes_ub124_tx_gain_table_1p0[][5] = {
  {0x0000b2e8, 0xfffe0000, 0xfffe0000, 0xfffc0000, 0xfffc0000},
 };
 
-static const u32 ar9340Common_rx_gain_table_1p0[][2] = {
- /* Addr      allmodes  */
- {0x0000a000, 0x00010000},
- {0x0000a004, 0x00030002},
- {0x0000a008, 0x00050004},
- {0x0000a00c, 0x00810080},
- {0x0000a010, 0x00830082},
- {0x0000a014, 0x01810180},
- {0x0000a018, 0x01830182},
- {0x0000a01c, 0x01850184},
- {0x0000a020, 0x01890188},
- {0x0000a024, 0x018b018a},
- {0x0000a028, 0x018d018c},
- {0x0000a02c, 0x01910190},
- {0x0000a030, 0x01930192},
- {0x0000a034, 0x01950194},
- {0x0000a038, 0x038a0196},
- {0x0000a03c, 0x038c038b},
- {0x0000a040, 0x0390038d},
- {0x0000a044, 0x03920391},
- {0x0000a048, 0x03940393},
- {0x0000a04c, 0x03960395},
- {0x0000a050, 0x00000000},
- {0x0000a054, 0x00000000},
- {0x0000a058, 0x00000000},
- {0x0000a05c, 0x00000000},
- {0x0000a060, 0x00000000},
- {0x0000a064, 0x00000000},
- {0x0000a068, 0x00000000},
- {0x0000a06c, 0x00000000},
- {0x0000a070, 0x00000000},
- {0x0000a074, 0x00000000},
- {0x0000a078, 0x00000000},
- {0x0000a07c, 0x00000000},
- {0x0000a080, 0x22222229},
- {0x0000a084, 0x1d1d1d1d},
- {0x0000a088, 0x1d1d1d1d},
- {0x0000a08c, 0x1d1d1d1d},
- {0x0000a090, 0x171d1d1d},
- {0x0000a094, 0x11111717},
- {0x0000a098, 0x00030311},
- {0x0000a09c, 0x00000000},
- {0x0000a0a0, 0x00000000},
- {0x0000a0a4, 0x00000000},
- {0x0000a0a8, 0x00000000},
- {0x0000a0ac, 0x00000000},
- {0x0000a0b0, 0x00000000},
- {0x0000a0b4, 0x00000000},
- {0x0000a0b8, 0x00000000},
- {0x0000a0bc, 0x00000000},
- {0x0000a0c0, 0x001f0000},
- {0x0000a0c4, 0x01000101},
- {0x0000a0c8, 0x011e011f},
- {0x0000a0cc, 0x011c011d},
- {0x0000a0d0, 0x02030204},
- {0x0000a0d4, 0x02010202},
- {0x0000a0d8, 0x021f0200},
- {0x0000a0dc, 0x0302021e},
- {0x0000a0e0, 0x03000301},
- {0x0000a0e4, 0x031e031f},
- {0x0000a0e8, 0x0402031d},
- {0x0000a0ec, 0x04000401},
- {0x0000a0f0, 0x041e041f},
- {0x0000a0f4, 0x0502041d},
- {0x0000a0f8, 0x05000501},
- {0x0000a0fc, 0x051e051f},
- {0x0000a100, 0x06010602},
- {0x0000a104, 0x061f0600},
- {0x0000a108, 0x061d061e},
- {0x0000a10c, 0x07020703},
- {0x0000a110, 0x07000701},
- {0x0000a114, 0x00000000},
- {0x0000a118, 0x00000000},
- {0x0000a11c, 0x00000000},
- {0x0000a120, 0x00000000},
- {0x0000a124, 0x00000000},
- {0x0000a128, 0x00000000},
- {0x0000a12c, 0x00000000},
- {0x0000a130, 0x00000000},
- {0x0000a134, 0x00000000},
- {0x0000a138, 0x00000000},
- {0x0000a13c, 0x00000000},
- {0x0000a140, 0x001f0000},
- {0x0000a144, 0x01000101},
- {0x0000a148, 0x011e011f},
- {0x0000a14c, 0x011c011d},
- {0x0000a150, 0x02030204},
- {0x0000a154, 0x02010202},
- {0x0000a158, 0x021f0200},
- {0x0000a15c, 0x0302021e},
- {0x0000a160, 0x03000301},
- {0x0000a164, 0x031e031f},
- {0x0000a168, 0x0402031d},
- {0x0000a16c, 0x04000401},
- {0x0000a170, 0x041e041f},
- {0x0000a174, 0x0502041d},
- {0x0000a178, 0x05000501},
- {0x0000a17c, 0x051e051f},
- {0x0000a180, 0x06010602},
- {0x0000a184, 0x061f0600},
- {0x0000a188, 0x061d061e},
- {0x0000a18c, 0x07020703},
- {0x0000a190, 0x07000701},
- {0x0000a194, 0x00000000},
- {0x0000a198, 0x00000000},
- {0x0000a19c, 0x00000000},
- {0x0000a1a0, 0x00000000},
- {0x0000a1a4, 0x00000000},
- {0x0000a1a8, 0x00000000},
- {0x0000a1ac, 0x00000000},
- {0x0000a1b0, 0x00000000},
- {0x0000a1b4, 0x00000000},
- {0x0000a1b8, 0x00000000},
- {0x0000a1bc, 0x00000000},
- {0x0000a1c0, 0x00000000},
- {0x0000a1c4, 0x00000000},
- {0x0000a1c8, 0x00000000},
- {0x0000a1cc, 0x00000000},
- {0x0000a1d0, 0x00000000},
- {0x0000a1d4, 0x00000000},
- {0x0000a1d8, 0x00000000},
- {0x0000a1dc, 0x00000000},
- {0x0000a1e0, 0x00000000},
- {0x0000a1e4, 0x00000000},
- {0x0000a1e8, 0x00000000},
- {0x0000a1ec, 0x00000000},
- {0x0000a1f0, 0x00000396},
- {0x0000a1f4, 0x00000396},
- {0x0000a1f8, 0x00000396},
- {0x0000a1fc, 0x00000196},
- {0x0000b000, 0x00010000},
- {0x0000b004, 0x00030002},
- {0x0000b008, 0x00050004},
- {0x0000b00c, 0x00810080},
- {0x0000b010, 0x00830082},
- {0x0000b014, 0x01810180},
- {0x0000b018, 0x01830182},
- {0x0000b01c, 0x01850184},
- {0x0000b020, 0x02810280},
- {0x0000b024, 0x02830282},
- {0x0000b028, 0x02850284},
- {0x0000b02c, 0x02890288},
- {0x0000b030, 0x028b028a},
- {0x0000b034, 0x0388028c},
- {0x0000b038, 0x038a0389},
- {0x0000b03c, 0x038c038b},
- {0x0000b040, 0x0390038d},
- {0x0000b044, 0x03920391},
- {0x0000b048, 0x03940393},
- {0x0000b04c, 0x03960395},
- {0x0000b050, 0x00000000},
- {0x0000b054, 0x00000000},
- {0x0000b058, 0x00000000},
- {0x0000b05c, 0x00000000},
- {0x0000b060, 0x00000000},
- {0x0000b064, 0x00000000},
- {0x0000b068, 0x00000000},
- {0x0000b06c, 0x00000000},
- {0x0000b070, 0x00000000},
- {0x0000b074, 0x00000000},
- {0x0000b078, 0x00000000},
- {0x0000b07c, 0x00000000},
- {0x0000b080, 0x23232323},
- {0x0000b084, 0x21232323},
- {0x0000b088, 0x19191c1e},
- {0x0000b08c, 0x12141417},
- {0x0000b090, 0x07070e0e},
- {0x0000b094, 0x03030305},
- {0x0000b098, 0x00000003},
- {0x0000b09c, 0x00000000},
- {0x0000b0a0, 0x00000000},
- {0x0000b0a4, 0x00000000},
- {0x0000b0a8, 0x00000000},
- {0x0000b0ac, 0x00000000},
- {0x0000b0b0, 0x00000000},
- {0x0000b0b4, 0x00000000},
- {0x0000b0b8, 0x00000000},
- {0x0000b0bc, 0x00000000},
- {0x0000b0c0, 0x003f0020},
- {0x0000b0c4, 0x00400041},
- {0x0000b0c8, 0x0140005f},
- {0x0000b0cc, 0x0160015f},
- {0x0000b0d0, 0x017e017f},
- {0x0000b0d4, 0x02410242},
- {0x0000b0d8, 0x025f0240},
- {0x0000b0dc, 0x027f0260},
- {0x0000b0e0, 0x0341027e},
- {0x0000b0e4, 0x035f0340},
- {0x0000b0e8, 0x037f0360},
- {0x0000b0ec, 0x04400441},
- {0x0000b0f0, 0x0460045f},
- {0x0000b0f4, 0x0541047f},
- {0x0000b0f8, 0x055f0540},
- {0x0000b0fc, 0x057f0560},
- {0x0000b100, 0x06400641},
- {0x0000b104, 0x0660065f},
- {0x0000b108, 0x067e067f},
- {0x0000b10c, 0x07410742},
- {0x0000b110, 0x075f0740},
- {0x0000b114, 0x077f0760},
- {0x0000b118, 0x07800781},
- {0x0000b11c, 0x07a0079f},
- {0x0000b120, 0x07c107bf},
- {0x0000b124, 0x000007c0},
- {0x0000b128, 0x00000000},
- {0x0000b12c, 0x00000000},
- {0x0000b130, 0x00000000},
- {0x0000b134, 0x00000000},
- {0x0000b138, 0x00000000},
- {0x0000b13c, 0x00000000},
- {0x0000b140, 0x003f0020},
- {0x0000b144, 0x00400041},
- {0x0000b148, 0x0140005f},
- {0x0000b14c, 0x0160015f},
- {0x0000b150, 0x017e017f},
- {0x0000b154, 0x02410242},
- {0x0000b158, 0x025f0240},
- {0x0000b15c, 0x027f0260},
- {0x0000b160, 0x0341027e},
- {0x0000b164, 0x035f0340},
- {0x0000b168, 0x037f0360},
- {0x0000b16c, 0x04400441},
- {0x0000b170, 0x0460045f},
- {0x0000b174, 0x0541047f},
- {0x0000b178, 0x055f0540},
- {0x0000b17c, 0x057f0560},
- {0x0000b180, 0x06400641},
- {0x0000b184, 0x0660065f},
- {0x0000b188, 0x067e067f},
- {0x0000b18c, 0x07410742},
- {0x0000b190, 0x075f0740},
- {0x0000b194, 0x077f0760},
- {0x0000b198, 0x07800781},
- {0x0000b19c, 0x07a0079f},
- {0x0000b1a0, 0x07c107bf},
- {0x0000b1a4, 0x000007c0},
- {0x0000b1a8, 0x00000000},
- {0x0000b1ac, 0x00000000},
- {0x0000b1b0, 0x00000000},
- {0x0000b1b4, 0x00000000},
- {0x0000b1b8, 0x00000000},
- {0x0000b1bc, 0x00000000},
- {0x0000b1c0, 0x00000000},
- {0x0000b1c4, 0x00000000},
- {0x0000b1c8, 0x00000000},
- {0x0000b1cc, 0x00000000},
- {0x0000b1d0, 0x00000000},
- {0x0000b1d4, 0x00000000},
- {0x0000b1d8, 0x00000000},
- {0x0000b1dc, 0x00000000},
- {0x0000b1e0, 0x00000000},
- {0x0000b1e4, 0x00000000},
- {0x0000b1e8, 0x00000000},
- {0x0000b1ec, 0x00000000},
- {0x0000b1f0, 0x00000396},
- {0x0000b1f4, 0x00000396},
- {0x0000b1f8, 0x00000396},
- {0x0000b1fc, 0x00000196},
-};
-
 static const u32 ar9340Modes_low_ob_db_tx_gain_table_1p0[][5] = {
  /* Addr      5G_HT20     5G_HT40     2G_HT40     2G_HT20   */
  {0x0000a2dc, 0x0380c7fc, 0x0380c7fc, 0x03aaa352, 0x03aaa352},
@@ -1437,8 +1185,6 @@ static const u32 ar9340_1p0_mac_core[][2] = {
  {0x000083d0, 0x000101ff},
 };
 
-#define ar9340Common_wo_xlna_rx_gain_table_1p0 ar9300Common_wo_xlna_rx_gain_table_2p2
-
 static const u32 ar9340_1p0_soc_preamble[][2] = {
  /* Addr      allmodes  */
  {0x00007008, 0x00000000},
@@ -1447,4 +1193,106 @@ static const u32 ar9340_1p0_soc_preamble[][2] = {
  {0x00007038, 0x000004c2},
 };
 
+static const u32 ar9340_cus227_tx_gain_table_1p0[][5] = {
+ /* Addr      5G_HT20     5G_HT40     2G_HT40     2G_HT20   */
+ {0x0000a2dc, 0x0380c7fc, 0x0380c7fc, 0x03aaa352, 0x03aaa352},
+ {0x0000a2e0, 0x0000f800, 0x0000f800, 0x03ccc584, 0x03ccc584},
+ {0x0000a2e4, 0x03ff0000, 0x03ff0000, 0x03f0f800, 0x03f0f800},
+ {0x0000a2e8, 0x00000000, 0x00000000, 0x03ff0000, 0x03ff0000},
+ {0x0000a410, 0x000050d9, 0x000050d9, 0x000050d9, 0x000050d9},
+ {0x0000a500, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
+ {0x0000a504, 0x06000003, 0x06000003, 0x04000002, 0x04000002},
+ {0x0000a508, 0x0a000020, 0x0a000020, 0x08000004, 0x08000004},
+ {0x0000a50c, 0x10000023, 0x10000023, 0x0b000200, 0x0b000200},
+ {0x0000a510, 0x16000220, 0x16000220, 0x0f000202, 0x0f000202},
+ {0x0000a514, 0x1c000223, 0x1c000223, 0x11000400, 0x11000400},
+ {0x0000a518, 0x21002220, 0x21002220, 0x15000402, 0x15000402},
+ {0x0000a51c, 0x27002223, 0x27002223, 0x19000404, 0x19000404},
+ {0x0000a520, 0x2c022220, 0x2c022220, 0x1b000603, 0x1b000603},
+ {0x0000a524, 0x30022222, 0x30022222, 0x1f000a02, 0x1f000a02},
+ {0x0000a528, 0x35022225, 0x35022225, 0x23000a04, 0x23000a04},
+ {0x0000a52c, 0x3b02222a, 0x3b02222a, 0x26000a20, 0x26000a20},
+ {0x0000a530, 0x3f02222c, 0x3f02222c, 0x2a000e20, 0x2a000e20},
+ {0x0000a534, 0x4202242a, 0x4202242a, 0x2e000e22, 0x2e000e22},
+ {0x0000a538, 0x4702244a, 0x4702244a, 0x31000e24, 0x31000e24},
+ {0x0000a53c, 0x4b02244c, 0x4b02244c, 0x34001640, 0x34001640},
+ {0x0000a540, 0x4e02246c, 0x4e02246c, 0x38001660, 0x38001660},
+ {0x0000a544, 0x5302266c, 0x5302266c, 0x3b001861, 0x3b001861},
+ {0x0000a548, 0x5702286c, 0x5702286c, 0x3e001a81, 0x3e001a81},
+ {0x0000a54c, 0x5c02486b, 0x5c02486b, 0x42001a83, 0x42001a83},
+ {0x0000a550, 0x61024a6c, 0x61024a6c, 0x44001c84, 0x44001c84},
+ {0x0000a554, 0x66026a6c, 0x66026a6c, 0x48001ce3, 0x48001ce3},
+ {0x0000a558, 0x6b026e6c, 0x6b026e6c, 0x4c001ce5, 0x4c001ce5},
+ {0x0000a55c, 0x7002708c, 0x7002708c, 0x50001ce9, 0x50001ce9},
+ {0x0000a560, 0x7302b08a, 0x7302b08a, 0x54001ceb, 0x54001ceb},
+ {0x0000a564, 0x7702b08c, 0x7702b08c, 0x56001eec, 0x56001eec},
+ {0x0000a568, 0x7702b08c, 0x7702b08c, 0x56001eec, 0x56001eec},
+ {0x0000a56c, 0x7702b08c, 0x7702b08c, 0x56001eec, 0x56001eec},
+ {0x0000a570, 0x7702b08c, 0x7702b08c, 0x56001eec, 0x56001eec},
+ {0x0000a574, 0x7702b08c, 0x7702b08c, 0x56001eec, 0x56001eec},
+ {0x0000a578, 0x7702b08c, 0x7702b08c, 0x56001eec, 0x56001eec},
+ {0x0000a57c, 0x7702b08c, 0x7702b08c, 0x56001eec, 0x56001eec},
+ {0x0000a580, 0x00800000, 0x00800000, 0x00800000, 0x00800000},
+ {0x0000a584, 0x06800003, 0x06800003, 0x04800002, 0x04800002},
+ {0x0000a588, 0x0a800020, 0x0a800020, 0x08800004, 0x08800004},
+ {0x0000a58c, 0x10800023, 0x10800023, 0x0b800200, 0x0b800200},
+ {0x0000a590, 0x16800220, 0x16800220, 0x0f800202, 0x0f800202},
+ {0x0000a594, 0x1c800223, 0x1c800223, 0x11800400, 0x11800400},
+ {0x0000a598, 0x21820220, 0x21820220, 0x15800402, 0x15800402},
+ {0x0000a59c, 0x27820223, 0x27820223, 0x19800404, 0x19800404},
+ {0x0000a5a0, 0x2b822220, 0x2b822220, 0x1b800603, 0x1b800603},
+ {0x0000a5a4, 0x2f822222, 0x2f822222, 0x1f800a02, 0x1f800a02},
+ {0x0000a5a8, 0x34822225, 0x34822225, 0x23800a04, 0x23800a04},
+ {0x0000a5ac, 0x3a82222a, 0x3a82222a, 0x26800a20, 0x26800a20},
+ {0x0000a5b0, 0x3e82222c, 0x3e82222c, 0x2a800e20, 0x2a800e20},
+ {0x0000a5b4, 0x4282242a, 0x4282242a, 0x2e800e22, 0x2e800e22},
+ {0x0000a5b8, 0x4782244a, 0x4782244a, 0x31800e24, 0x31800e24},
+ {0x0000a5bc, 0x4b82244c, 0x4b82244c, 0x34801640, 0x34801640},
+ {0x0000a5c0, 0x4e82246c, 0x4e82246c, 0x38801660, 0x38801660},
+ {0x0000a5c4, 0x5382266c, 0x5382266c, 0x3b801861, 0x3b801861},
+ {0x0000a5c8, 0x5782286c, 0x5782286c, 0x3e801a81, 0x3e801a81},
+ {0x0000a5cc, 0x5c84286b, 0x5c84286b, 0x42801a83, 0x42801a83},
+ {0x0000a5d0, 0x61842a6c, 0x61842a6c, 0x44801c84, 0x44801c84},
+ {0x0000a5d4, 0x66862a6c, 0x66862a6c, 0x48801ce3, 0x48801ce3},
+ {0x0000a5d8, 0x6b862e6c, 0x6b862e6c, 0x4c801ce5, 0x4c801ce5},
+ {0x0000a5dc, 0x7086308c, 0x7086308c, 0x50801ce9, 0x50801ce9},
+ {0x0000a5e0, 0x738a308a, 0x738a308a, 0x54801ceb, 0x54801ceb},
+ {0x0000a5e4, 0x778a308c, 0x778a308c, 0x56801eec, 0x56801eec},
+ {0x0000a5e8, 0x778a308c, 0x778a308c, 0x56801eec, 0x56801eec},
+ {0x0000a5ec, 0x778a308c, 0x778a308c, 0x56801eec, 0x56801eec},
+ {0x0000a5f0, 0x778a308c, 0x778a308c, 0x56801eec, 0x56801eec},
+ {0x0000a5f4, 0x778a308c, 0x778a308c, 0x56801eec, 0x56801eec},
+ {0x0000a5f8, 0x778a308c, 0x778a308c, 0x56801eec, 0x56801eec},
+ {0x0000a5fc, 0x778a308c, 0x778a308c, 0x56801eec, 0x56801eec},
+ {0x0000a600, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
+ {0x0000a604, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
+ {0x0000a608, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
+ {0x0000a60c, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
+ {0x0000a610, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
+ {0x0000a614, 0x01404000, 0x01404000, 0x01404000, 0x01404000},
+ {0x0000a618, 0x01404501, 0x01404501, 0x01404501, 0x01404501},
+ {0x0000a61c, 0x02008802, 0x02008802, 0x02008501, 0x02008501},
+ {0x0000a620, 0x0300cc03, 0x0300cc03, 0x0280ca03, 0x0280ca03},
+ {0x0000a624, 0x0300cc03, 0x0300cc03, 0x03010c04, 0x03010c04},
+ {0x0000a628, 0x0300cc03, 0x0300cc03, 0x04014c04, 0x04014c04},
+ {0x0000a62c, 0x03810c03, 0x03810c03, 0x04015005, 0x04015005},
+ {0x0000a630, 0x03810e04, 0x03810e04, 0x04015005, 0x04015005},
+ {0x0000a634, 0x03810e04, 0x03810e04, 0x04015005, 0x04015005},
+ {0x0000a638, 0x03810e04, 0x03810e04, 0x04015005, 0x04015005},
+ {0x0000a63c, 0x03810e04, 0x03810e04, 0x04015005, 0x04015005},
+ {0x0000b2dc, 0x0380c7fc, 0x0380c7fc, 0x03aaa352, 0x03aaa352},
+ {0x0000b2e0, 0x0000f800, 0x0000f800, 0x03ccc584, 0x03ccc584},
+ {0x0000b2e4, 0x03ff0000, 0x03ff0000, 0x03f0f800, 0x03f0f800},
+ {0x0000b2e8, 0x00000000, 0x00000000, 0x03ff0000, 0x03ff0000},
+ {0x00016044, 0x056db2db, 0x056db2db, 0x03b6d2e4, 0x03b6d2e4},
+ {0x00016048, 0x24925666, 0x24925666, 0x8e481266, 0x8e481266},
+ {0x00016280, 0x01000015, 0x01000015, 0x01001015, 0x01001015},
+ {0x00016288, 0x30318000, 0x30318000, 0x00318000, 0x00318000},
+ {0x00016444, 0x056db2db, 0x056db2db, 0x03b6d2e4, 0x03b6d2e4},
+ {0x00016448, 0x24925666, 0x24925666, 0x8e481266, 0x8e481266},
+ {0x0000a3a4, 0x00000011, 0x00000011, 0x00000011, 0x00000011},
+ {0x0000a3a8, 0x3c3c3c3c, 0x3c3c3c3c, 0x3c3c3c3c, 0x3c3c3c3c},
+ {0x0000a3ac, 0x30303030, 0x30303030, 0x30303030, 0x30303030},
+};
+
 #endif /* INITVALS_9340_H */
diff --git a/drivers/net/wireless/ath/ath9k/ar9462_2p0_initvals.h b/drivers/net/wireless/ath/ath9k/ar9462_2p0_initvals.h
index 999ab08..1b6b4d0 100644
--- a/drivers/net/wireless/ath/ath9k/ar9462_2p0_initvals.h
+++ b/drivers/net/wireless/ath/ath9k/ar9462_2p0_initvals.h
@@ -20,7 +20,15 @@
 
 /* AR9462 2.0 */
 
-static const u32 ar9462_modes_fast_clock_2p0[][3] = {
+#define ar9462_2p0_mac_postamble ar9331_1p1_mac_postamble
+
+#define ar9462_2p0_common_wo_xlna_rx_gain ar9300Common_wo_xlna_rx_gain_table_2p2
+
+#define ar9462_2p0_common_5g_xlna_only_rxgain ar9462_2p0_common_mixed_rx_gain
+
+#define ar9462_2p0_baseband_core_txfir_coeff_japan_2484 ar9300_2p2_baseband_core_txfir_coeff_japan_2484
+
+static const u32 ar9462_2p0_modes_fast_clock[][3] = {
  /* Addr      5G_HT20     5G_HT40   */
  {0x00001030, 0x00000268, 0x000004d0},
  {0x00001070, 0x0000018c, 0x00000318},
@@ -33,13 +41,6 @@ static const u32 ar9462_modes_fast_clock_2p0[][3] = {
  {0x0000a254, 0x00000898, 0x00001130},
 };
 
-static const u32 ar9462_pciephy_clkreq_enable_L1_2p0[][2] = {
- /* Addr      allmodes  */
- {0x00018c00, 0x18253ede},
- {0x00018c04, 0x000801d8},
- {0x00018c08, 0x0003780c},
-};
-
 static const u32 ar9462_2p0_baseband_postamble[][5] = {
  /* Addr      5G_HT20     5G_HT40     2G_HT40     2G_HT20   */
  {0x00009810, 0xd00a8005, 0xd00a8005, 0xd00a8011, 0xd00a800d},
@@ -56,7 +57,7 @@ static const u32 ar9462_2p0_baseband_postamble[][5] = {
  {0x00009e14, 0x37b95d5e, 0x37b9605e, 0x3236605e, 0x32365a5e},
  {0x00009e18, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
  {0x00009e1c, 0x0001cf9c, 0x0001cf9c, 0x00021f9c, 0x00021f9c},
- {0x00009e20, 0x000003b5, 0x000003b5, 0x000003ce, 0x000003ce},
+ {0x00009e20, 0x000003a5, 0x000003a5, 0x000003a5, 0x000003a5},
  {0x00009e2c, 0x0000001c, 0x0000001c, 0x00000021, 0x00000021},
  {0x00009e3c, 0xcf946220, 0xcf946220, 0xcfd5c782, 0xcfd5c282},
  {0x00009e44, 0x62321e27, 0x62321e27, 0xfe291e27, 0xfe291e27},
@@ -78,7 +79,7 @@ static const u32 ar9462_2p0_baseband_postamble[][5] = {
  {0x0000a284, 0x00000000, 0x00000000, 0x00000150, 0x00000150},
  {0x0000a288, 0x00000110, 0x00000110, 0x00000110, 0x00000110},
  {0x0000a28c, 0x00022222, 0x00022222, 0x00022222, 0x00022222},
- {0x0000a2c4, 0x00058d18, 0x00058d18, 0x00058d18, 0x00058d18},
+ {0x0000a2c4, 0x00158d18, 0x00158d18, 0x00158d18, 0x00158d18},
  {0x0000a2d0, 0x00041981, 0x00041981, 0x00041981, 0x00041982},
  {0x0000a2d8, 0x7999a83b, 0x7999a83b, 0x7999a83b, 0x7999a83b},
  {0x0000a358, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
@@ -95,11 +96,11 @@ static const u32 ar9462_2p0_baseband_postamble[][5] = {
  {0x0000ae04, 0x001c0000, 0x001c0000, 0x001c0000, 0x00100000},
  {0x0000ae18, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
  {0x0000ae1c, 0x0000019c, 0x0000019c, 0x0000019c, 0x0000019c},
- {0x0000ae20, 0x000001b5, 0x000001b5, 0x000001ce, 0x000001ce},
+ {0x0000ae20, 0x000001a6, 0x000001a6, 0x000001aa, 0x000001aa},
  {0x0000b284, 0x00000000, 0x00000000, 0x00000550, 0x00000550},
 };
 
-static const u32 ar9462_common_rx_gain_table_2p0[][2] = {
+static const u32 ar9462_2p0_common_rx_gain[][2] = {
  /* Addr      allmodes  */
  {0x0000a000, 0x00010000},
  {0x0000a004, 0x00030002},
@@ -359,20 +360,13 @@ static const u32 ar9462_common_rx_gain_table_2p0[][2] = {
  {0x0000b1fc, 0x00000196},
 };
 
-static const u32 ar9462_pciephy_clkreq_disable_L1_2p0[][2] = {
+static const u32 ar9462_2p0_pciephy_clkreq_disable_L1[][2] = {
  /* Addr      allmodes  */
  {0x00018c00, 0x18213ede},
  {0x00018c04, 0x000801d8},
  {0x00018c08, 0x0003780c},
 };
 
-static const u32 ar9462_pciephy_pll_on_clkreq_disable_L1_2p0[][2] = {
- /* Addr      allmodes  */
- {0x00018c00, 0x18212ede},
- {0x00018c04, 0x000801d8},
- {0x00018c08, 0x0003780c},
-};
-
 static const u32 ar9462_2p0_radio_postamble_sys2ant[][5] = {
  /* Addr      5G_HT20     5G_HT40     2G_HT40     2G_HT20   */
  {0x000160ac, 0xa4646c08, 0xa4646c08, 0x24645808, 0x24645808},
@@ -380,274 +374,7 @@ static const u32 ar9462_2p0_radio_postamble_sys2ant[][5] = {
  {0x00016540, 0x10804008, 0x10804008, 0x50804008, 0x50804008},
 };
 
-static const u32 ar9462_common_wo_xlna_rx_gain_table_2p0[][2] = {
- /* Addr      allmodes  */
- {0x0000a000, 0x00010000},
- {0x0000a004, 0x00030002},
- {0x0000a008, 0x00050004},
- {0x0000a00c, 0x00810080},
- {0x0000a010, 0x00830082},
- {0x0000a014, 0x01810180},
- {0x0000a018, 0x01830182},
- {0x0000a01c, 0x01850184},
- {0x0000a020, 0x01890188},
- {0x0000a024, 0x018b018a},
- {0x0000a028, 0x018d018c},
- {0x0000a02c, 0x03820190},
- {0x0000a030, 0x03840383},
- {0x0000a034, 0x03880385},
- {0x0000a038, 0x038a0389},
- {0x0000a03c, 0x038c038b},
- {0x0000a040, 0x0390038d},
- {0x0000a044, 0x03920391},
- {0x0000a048, 0x03940393},
- {0x0000a04c, 0x03960395},
- {0x0000a050, 0x00000000},
- {0x0000a054, 0x00000000},
- {0x0000a058, 0x00000000},
- {0x0000a05c, 0x00000000},
- {0x0000a060, 0x00000000},
- {0x0000a064, 0x00000000},
- {0x0000a068, 0x00000000},
- {0x0000a06c, 0x00000000},
- {0x0000a070, 0x00000000},
- {0x0000a074, 0x00000000},
- {0x0000a078, 0x00000000},
- {0x0000a07c, 0x00000000},
- {0x0000a080, 0x29292929},
- {0x0000a084, 0x29292929},
- {0x0000a088, 0x29292929},
- {0x0000a08c, 0x29292929},
- {0x0000a090, 0x22292929},
- {0x0000a094, 0x1d1d2222},
- {0x0000a098, 0x0c111117},
- {0x0000a09c, 0x00030303},
- {0x0000a0a0, 0x00000000},
- {0x0000a0a4, 0x00000000},
- {0x0000a0a8, 0x00000000},
- {0x0000a0ac, 0x00000000},
- {0x0000a0b0, 0x00000000},
- {0x0000a0b4, 0x00000000},
- {0x0000a0b8, 0x00000000},
- {0x0000a0bc, 0x00000000},
- {0x0000a0c0, 0x001f0000},
- {0x0000a0c4, 0x01000101},
- {0x0000a0c8, 0x011e011f},
- {0x0000a0cc, 0x011c011d},
- {0x0000a0d0, 0x02030204},
- {0x0000a0d4, 0x02010202},
- {0x0000a0d8, 0x021f0200},
- {0x0000a0dc, 0x0302021e},
- {0x0000a0e0, 0x03000301},
- {0x0000a0e4, 0x031e031f},
- {0x0000a0e8, 0x0402031d},
- {0x0000a0ec, 0x04000401},
- {0x0000a0f0, 0x041e041f},
- {0x0000a0f4, 0x0502041d},
- {0x0000a0f8, 0x05000501},
- {0x0000a0fc, 0x051e051f},
- {0x0000a100, 0x06010602},
- {0x0000a104, 0x061f0600},
- {0x0000a108, 0x061d061e},
- {0x0000a10c, 0x07020703},
- {0x0000a110, 0x07000701},
- {0x0000a114, 0x00000000},
- {0x0000a118, 0x00000000},
- {0x0000a11c, 0x00000000},
- {0x0000a120, 0x00000000},
- {0x0000a124, 0x00000000},
- {0x0000a128, 0x00000000},
- {0x0000a12c, 0x00000000},
- {0x0000a130, 0x00000000},
- {0x0000a134, 0x00000000},
- {0x0000a138, 0x00000000},
- {0x0000a13c, 0x00000000},
- {0x0000a140, 0x001f0000},
- {0x0000a144, 0x01000101},
- {0x0000a148, 0x011e011f},
- {0x0000a14c, 0x011c011d},
- {0x0000a150, 0x02030204},
- {0x0000a154, 0x02010202},
- {0x0000a158, 0x021f0200},
- {0x0000a15c, 0x0302021e},
- {0x0000a160, 0x03000301},
- {0x0000a164, 0x031e031f},
- {0x0000a168, 0x0402031d},
- {0x0000a16c, 0x04000401},
- {0x0000a170, 0x041e041f},
- {0x0000a174, 0x0502041d},
- {0x0000a178, 0x05000501},
- {0x0000a17c, 0x051e051f},
- {0x0000a180, 0x06010602},
- {0x0000a184, 0x061f0600},
- {0x0000a188, 0x061d061e},
- {0x0000a18c, 0x07020703},
- {0x0000a190, 0x07000701},
- {0x0000a194, 0x00000000},
- {0x0000a198, 0x00000000},
- {0x0000a19c, 0x00000000},
- {0x0000a1a0, 0x00000000},
- {0x0000a1a4, 0x00000000},
- {0x0000a1a8, 0x00000000},
- {0x0000a1ac, 0x00000000},
- {0x0000a1b0, 0x00000000},
- {0x0000a1b4, 0x00000000},
- {0x0000a1b8, 0x00000000},
- {0x0000a1bc, 0x00000000},
- {0x0000a1c0, 0x00000000},
- {0x0000a1c4, 0x00000000},
- {0x0000a1c8, 0x00000000},
- {0x0000a1cc, 0x00000000},
- {0x0000a1d0, 0x00000000},
- {0x0000a1d4, 0x00000000},
- {0x0000a1d8, 0x00000000},
- {0x0000a1dc, 0x00000000},
- {0x0000a1e0, 0x00000000},
- {0x0000a1e4, 0x00000000},
- {0x0000a1e8, 0x00000000},
- {0x0000a1ec, 0x00000000},
- {0x0000a1f0, 0x00000396},
- {0x0000a1f4, 0x00000396},
- {0x0000a1f8, 0x00000396},
- {0x0000a1fc, 0x00000196},
- {0x0000b000, 0x00010000},
- {0x0000b004, 0x00030002},
- {0x0000b008, 0x00050004},
- {0x0000b00c, 0x00810080},
- {0x0000b010, 0x00830082},
- {0x0000b014, 0x01810180},
- {0x0000b018, 0x01830182},
- {0x0000b01c, 0x01850184},
- {0x0000b020, 0x02810280},
- {0x0000b024, 0x02830282},
- {0x0000b028, 0x02850284},
- {0x0000b02c, 0x02890288},
- {0x0000b030, 0x028b028a},
- {0x0000b034, 0x0388028c},
- {0x0000b038, 0x038a0389},
- {0x0000b03c, 0x038c038b},
- {0x0000b040, 0x0390038d},
- {0x0000b044, 0x03920391},
- {0x0000b048, 0x03940393},
- {0x0000b04c, 0x03960395},
- {0x0000b050, 0x00000000},
- {0x0000b054, 0x00000000},
- {0x0000b058, 0x00000000},
- {0x0000b05c, 0x00000000},
- {0x0000b060, 0x00000000},
- {0x0000b064, 0x00000000},
- {0x0000b068, 0x00000000},
- {0x0000b06c, 0x00000000},
- {0x0000b070, 0x00000000},
- {0x0000b074, 0x00000000},
- {0x0000b078, 0x00000000},
- {0x0000b07c, 0x00000000},
- {0x0000b080, 0x32323232},
- {0x0000b084, 0x2f2f3232},
- {0x0000b088, 0x23282a2d},
- {0x0000b08c, 0x1c1e2123},
- {0x0000b090, 0x14171919},
- {0x0000b094, 0x0e0e1214},
- {0x0000b098, 0x03050707},
- {0x0000b09c, 0x00030303},
- {0x0000b0a0, 0x00000000},
- {0x0000b0a4, 0x00000000},
- {0x0000b0a8, 0x00000000},
- {0x0000b0ac, 0x00000000},
- {0x0000b0b0, 0x00000000},
- {0x0000b0b4, 0x00000000},
- {0x0000b0b8, 0x00000000},
- {0x0000b0bc, 0x00000000},
- {0x0000b0c0, 0x003f0020},
- {0x0000b0c4, 0x00400041},
- {0x0000b0c8, 0x0140005f},
- {0x0000b0cc, 0x0160015f},
- {0x0000b0d0, 0x017e017f},
- {0x0000b0d4, 0x02410242},
- {0x0000b0d8, 0x025f0240},
- {0x0000b0dc, 0x027f0260},
- {0x0000b0e0, 0x0341027e},
- {0x0000b0e4, 0x035f0340},
- {0x0000b0e8, 0x037f0360},
- {0x0000b0ec, 0x04400441},
- {0x0000b0f0, 0x0460045f},
- {0x0000b0f4, 0x0541047f},
- {0x0000b0f8, 0x055f0540},
- {0x0000b0fc, 0x057f0560},
- {0x0000b100, 0x06400641},
- {0x0000b104, 0x0660065f},
- {0x0000b108, 0x067e067f},
- {0x0000b10c, 0x07410742},
- {0x0000b110, 0x075f0740},
- {0x0000b114, 0x077f0760},
- {0x0000b118, 0x07800781},
- {0x0000b11c, 0x07a0079f},
- {0x0000b120, 0x07c107bf},
- {0x0000b124, 0x000007c0},
- {0x0000b128, 0x00000000},
- {0x0000b12c, 0x00000000},
- {0x0000b130, 0x00000000},
- {0x0000b134, 0x00000000},
- {0x0000b138, 0x00000000},
- {0x0000b13c, 0x00000000},
- {0x0000b140, 0x003f0020},
- {0x0000b144, 0x00400041},
- {0x0000b148, 0x0140005f},
- {0x0000b14c, 0x0160015f},
- {0x0000b150, 0x017e017f},
- {0x0000b154, 0x02410242},
- {0x0000b158, 0x025f0240},
- {0x0000b15c, 0x027f0260},
- {0x0000b160, 0x0341027e},
- {0x0000b164, 0x035f0340},
- {0x0000b168, 0x037f0360},
- {0x0000b16c, 0x04400441},
- {0x0000b170, 0x0460045f},
- {0x0000b174, 0x0541047f},
- {0x0000b178, 0x055f0540},
- {0x0000b17c, 0x057f0560},
- {0x0000b180, 0x06400641},
- {0x0000b184, 0x0660065f},
- {0x0000b188, 0x067e067f},
- {0x0000b18c, 0x07410742},
- {0x0000b190, 0x075f0740},
- {0x0000b194, 0x077f0760},
- {0x0000b198, 0x07800781},
- {0x0000b19c, 0x07a0079f},
- {0x0000b1a0, 0x07c107bf},
- {0x0000b1a4, 0x000007c0},
- {0x0000b1a8, 0x00000000},
- {0x0000b1ac, 0x00000000},
- {0x0000b1b0, 0x00000000},
- {0x0000b1b4, 0x00000000},
- {0x0000b1b8, 0x00000000},
- {0x0000b1bc, 0x00000000},
- {0x0000b1c0, 0x00000000},
- {0x0000b1c4, 0x00000000},
- {0x0000b1c8, 0x00000000},
- {0x0000b1cc, 0x00000000},
- {0x0000b1d0, 0x00000000},
- {0x0000b1d4, 0x00000000},
- {0x0000b1d8, 0x00000000},
- {0x0000b1dc, 0x00000000},
- {0x0000b1e0, 0x00000000},
- {0x0000b1e4, 0x00000000},
- {0x0000b1e8, 0x00000000},
- {0x0000b1ec, 0x00000000},
- {0x0000b1f0, 0x00000396},
- {0x0000b1f4, 0x00000396},
- {0x0000b1f8, 0x00000396},
- {0x0000b1fc, 0x00000196},
-};
-
-static const u32 ar9462_2p0_baseband_core_txfir_coeff_japan_2484[][2] = {
- /* Addr      allmodes  */
- {0x0000a398, 0x00000000},
- {0x0000a39c, 0x6f7f0301},
- {0x0000a3a0, 0xca9228ee},
-};
-
-static const u32 ar9462_modes_low_ob_db_tx_gain_table_2p0[][5] = {
+static const u32 ar9462_2p0_modes_low_ob_db_tx_gain[][5] = {
  /* Addr      5G_HT20     5G_HT40     2G_HT40     2G_HT20   */
  {0x000098bc, 0x00000002, 0x00000002, 0x00000002, 0x00000002},
  {0x0000a2dc, 0x0380c7fc, 0x0380c7fc, 0x03aaa352, 0x03aaa352},
@@ -879,7 +606,70 @@ static const u32 ar9462_2p0_radio_postamble[][5] = {
  {0x0001650c, 0x48000000, 0x40000000, 0x40000000, 0x40000000},
 };
 
-static const u32 ar9462_modes_high_ob_db_tx_gain_table_2p0[][5] = {
+static const u32 ar9462_2p0_modes_mix_ob_db_tx_gain[][5] = {
+ /* Addr      5G_HT20     5G_HT40     2G_HT40     2G_HT20   */
+ {0x000098bc, 0x00000002, 0x00000002, 0x00000002, 0x00000002},
+ {0x0000a2dc, 0x01feee00, 0x01feee00, 0x03aaa352, 0x03aaa352},
+ {0x0000a2e0, 0x0000f000, 0x0000f000, 0x03ccc584, 0x03ccc584},
+ {0x0000a2e4, 0x01ff0000, 0x01ff0000, 0x03f0f800, 0x03f0f800},
+ {0x0000a2e8, 0x00000000, 0x00000000, 0x03ff0000, 0x03ff0000},
+ {0x0000a410, 0x0000d0da, 0x0000d0da, 0x0000d0de, 0x0000d0de},
+ {0x0000a458, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
+ {0x0000a500, 0x00002220, 0x00002220, 0x00000000, 0x00000000},
+ {0x0000a504, 0x06002223, 0x06002223, 0x04000002, 0x04000002},
+ {0x0000a508, 0x0a022220, 0x0a022220, 0x08000004, 0x08000004},
+ {0x0000a50c, 0x0f022223, 0x0f022223, 0x0b000200, 0x0b000200},
+ {0x0000a510, 0x14022620, 0x14022620, 0x0f000202, 0x0f000202},
+ {0x0000a514, 0x18022622, 0x18022622, 0x12000400, 0x12000400},
+ {0x0000a518, 0x1b022822, 0x1b022822, 0x16000402, 0x16000402},
+ {0x0000a51c, 0x20022842, 0x20022842, 0x19000404, 0x19000404},
+ {0x0000a520, 0x22022c41, 0x22022c41, 0x1c000603, 0x1c000603},
+ {0x0000a524, 0x28023042, 0x28023042, 0x21000a02, 0x21000a02},
+ {0x0000a528, 0x2c023044, 0x2c023044, 0x25000a04, 0x25000a04},
+ {0x0000a52c, 0x2f023644, 0x2f023644, 0x28000a20, 0x28000a20},
+ {0x0000a530, 0x34025643, 0x34025643, 0x2c000e20, 0x2c000e20},
+ {0x0000a534, 0x38025a44, 0x38025a44, 0x30000e22, 0x30000e22},
+ {0x0000a538, 0x3b025e45, 0x3b025e45, 0x34000e24, 0x34000e24},
+ {0x0000a53c, 0x41025e4a, 0x41025e4a, 0x38001640, 0x38001640},
+ {0x0000a540, 0x48025e6c, 0x48025e6c, 0x3c001660, 0x3c001660},
+ {0x0000a544, 0x4e025e8e, 0x4e025e8e, 0x3f001861, 0x3f001861},
+ {0x0000a548, 0x55025eb3, 0x55025eb3, 0x43001a81, 0x43001a81},
+ {0x0000a54c, 0x58025ef3, 0x58025ef3, 0x47001a83, 0x47001a83},
+ {0x0000a550, 0x5d025ef6, 0x5d025ef6, 0x4a001c84, 0x4a001c84},
+ {0x0000a554, 0x62025f56, 0x62025f56, 0x4e001ce3, 0x4e001ce3},
+ {0x0000a558, 0x66027f56, 0x66027f56, 0x52001ce5, 0x52001ce5},
+ {0x0000a55c, 0x6a029f56, 0x6a029f56, 0x56001ce9, 0x56001ce9},
+ {0x0000a560, 0x70049f56, 0x70049f56, 0x5a001ceb, 0x5a001ceb},
+ {0x0000a564, 0x751ffff6, 0x751ffff6, 0x5c001eec, 0x5c001eec},
+ {0x0000a568, 0x751ffff6, 0x751ffff6, 0x5e001ef0, 0x5e001ef0},
+ {0x0000a56c, 0x751ffff6, 0x751ffff6, 0x60001ef4, 0x60001ef4},
+ {0x0000a570, 0x751ffff6, 0x751ffff6, 0x62001ff6, 0x62001ff6},
+ {0x0000a574, 0x751ffff6, 0x751ffff6, 0x62001ff6, 0x62001ff6},
+ {0x0000a578, 0x751ffff6, 0x751ffff6, 0x62001ff6, 0x62001ff6},
+ {0x0000a57c, 0x751ffff6, 0x751ffff6, 0x62001ff6, 0x62001ff6},
+ {0x0000a600, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
+ {0x0000a604, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
+ {0x0000a608, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
+ {0x0000a60c, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
+ {0x0000a610, 0x00804000, 0x00804000, 0x00000000, 0x00000000},
+ {0x0000a614, 0x00804201, 0x00804201, 0x01404000, 0x01404000},
+ {0x0000a618, 0x0280c802, 0x0280c802, 0x01404501, 0x01404501},
+ {0x0000a61c, 0x0280ca03, 0x0280ca03, 0x02008501, 0x02008501},
+ {0x0000a620, 0x04c15104, 0x04c15104, 0x0280ca03, 0x0280ca03},
+ {0x0000a624, 0x04c15305, 0x04c15305, 0x03010c04, 0x03010c04},
+ {0x0000a628, 0x04c15305, 0x04c15305, 0x04014c04, 0x04014c04},
+ {0x0000a62c, 0x04c15305, 0x04c15305, 0x04015005, 0x04015005},
+ {0x0000a630, 0x04c15305, 0x04c15305, 0x04015005, 0x04015005},
+ {0x0000a634, 0x04c15305, 0x04c15305, 0x04015005, 0x04015005},
+ {0x0000a638, 0x04c15305, 0x04c15305, 0x04015005, 0x04015005},
+ {0x0000a63c, 0x04c15305, 0x04c15305, 0x04015005, 0x04015005},
+ {0x0000b2dc, 0x01feee00, 0x01feee00, 0x03aaa352, 0x03aaa352},
+ {0x0000b2e0, 0x0000f000, 0x0000f000, 0x03ccc584, 0x03ccc584},
+ {0x0000b2e4, 0x01ff0000, 0x01ff0000, 0x03f0f800, 0x03f0f800},
+ {0x0000b2e8, 0x00000000, 0x00000000, 0x03ff0000, 0x03ff0000},
+};
+
+static const u32 ar9462_2p0_modes_high_ob_db_tx_gain[][5] = {
  /* Addr      5G_HT20     5G_HT40     2G_HT40     2G_HT20   */
  {0x000098bc, 0x00000002, 0x00000002, 0x00000002, 0x00000002},
  {0x0000a2dc, 0x01feee00, 0x01feee00, 0x03aaa352, 0x03aaa352},
@@ -1177,19 +967,7 @@ static const u32 ar9462_2p0_mac_core[][2] = {
  {0x000083d0, 0x000301ff},
 };
 
-static const u32 ar9462_2p0_mac_postamble[][5] = {
- /* Addr      5G_HT20     5G_HT40     2G_HT40     2G_HT20   */
- {0x00001030, 0x00000230, 0x00000460, 0x000002c0, 0x00000160},
- {0x00001070, 0x00000168, 0x000002d0, 0x00000318, 0x0000018c},
- {0x000010b0, 0x00000e60, 0x00001cc0, 0x00007c70, 0x00003e38},
- {0x00008014, 0x03e803e8, 0x07d007d0, 0x10801600, 0x08400b00},
- {0x0000801c, 0x128d8027, 0x128d804f, 0x12e00057, 0x12e0002b},
- {0x00008120, 0x08f04800, 0x08f04800, 0x08f04810, 0x08f04810},
- {0x000081d0, 0x00003210, 0x00003210, 0x0000320a, 0x0000320a},
- {0x00008318, 0x00003e80, 0x00007d00, 0x00006880, 0x00003440},
-};
-
-static const u32 ar9462_common_mixed_rx_gain_table_2p0[][2] = {
+static const u32 ar9462_2p0_common_mixed_rx_gain[][2] = {
  /* Addr      allmodes  */
  {0x0000a000, 0x00010000},
  {0x0000a004, 0x00030002},
@@ -1449,4 +1227,24 @@ static const u32 ar9462_common_mixed_rx_gain_table_2p0[][2] = {
  {0x0000b1fc, 0x00000196},
 };
 
+static const u32 ar9462_2p0_baseband_postamble_5g_xlna[][5] = {
+ /* Addr      5G_HT20     5G_HT40     2G_HT40     2G_HT20   */
+ {0x00009e3c, 0xcf946220, 0xcf946220, 0xcfd5c782, 0xcfd5c282},
+};
+
+static const u32 ar9462_2p0_baseband_core_mix_rxgain[][2] = {
+ /* Addr      allmodes  */
+ {0x00009fd0, 0x0a2d6b93},
+};
+
+static const u32 ar9462_2p0_baseband_postamble_mix_rxgain[][5] = {
+ /* Addr      5G_HT20     5G_HT40     2G_HT40     2G_HT20   */
+ {0x00009820, 0x206a022e, 0x206a022e, 0x206a01ae, 0x206a01ae},
+ {0x00009824, 0x63c640de, 0x5ac640d0, 0x63c640da, 0x63c640da},
+ {0x00009828, 0x0796be89, 0x0696b081, 0x0916be81, 0x0916be81},
+ {0x00009e0c, 0x6c4000e2, 0x6d4000e2, 0x6d4000d8, 0x6c4000d8},
+ {0x00009e10, 0x92c88d2e, 0x7ec88d2e, 0x7ec86d2e, 0x7ec86d2e},
+ {0x00009e14, 0x37b95d5e, 0x37b9605e, 0x3236605e, 0x32395c5e},
+};
+
 #endif /* INITVALS_9462_2P0_H */
diff --git a/drivers/net/wireless/ath/ath9k/ar9462_2p1_initvals.h b/drivers/net/wireless/ath/ath9k/ar9462_2p1_initvals.h
new file mode 100644
index 0000000..dc3adda
--- /dev/null
+++ b/drivers/net/wireless/ath/ath9k/ar9462_2p1_initvals.h
@@ -0,0 +1,291 @@
+/*
+ * Copyright (c) 2010-2011 Atheros Communications Inc.
+ * Copyright (c) 2011-2012 Qualcomm Atheros Inc.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef INITVALS_9462_2P1_H
+#define INITVALS_9462_2P1_H
+
+/* AR9462 2.1 */
+
+#define ar9462_2p1_mac_postamble ar9462_2p0_mac_postamble
+
+#define ar9462_2p1_baseband_core ar9462_2p0_baseband_core
+
+#define ar9462_2p1_radio_core ar9462_2p0_radio_core
+
+#define ar9462_2p1_radio_postamble ar9462_2p0_radio_postamble
+
+#define ar9462_2p1_soc_postamble ar9462_2p0_soc_postamble
+
+#define ar9462_2p1_radio_postamble_sys2ant ar9462_2p0_radio_postamble_sys2ant
+
+#define ar9462_2p1_common_rx_gain ar9462_2p0_common_rx_gain
+
+#define ar9462_2p1_common_mixed_rx_gain ar9462_2p0_common_mixed_rx_gain
+
+#define ar9462_2p1_common_5g_xlna_only_rxgain ar9462_2p0_common_5g_xlna_only_rxgain
+
+#define ar9462_2p1_baseband_core_mix_rxgain ar9462_2p0_baseband_core_mix_rxgain
+
+#define ar9462_2p1_baseband_postamble_mix_rxgain ar9462_2p0_baseband_postamble_mix_rxgain
+
+#define ar9462_2p1_baseband_postamble_5g_xlna ar9462_2p0_baseband_postamble_5g_xlna
+
+#define ar9462_2p1_common_wo_xlna_rx_gain ar9462_2p0_common_wo_xlna_rx_gain
+
+#define ar9462_2p1_modes_low_ob_db_tx_gain ar9462_2p0_modes_low_ob_db_tx_gain
+
+#define ar9462_2p1_modes_high_ob_db_tx_gain ar9462_2p0_modes_high_ob_db_tx_gain
+
+#define ar9462_2p1_modes_mix_ob_db_tx_gain ar9462_2p0_modes_mix_ob_db_tx_gain
+
+#define ar9462_2p1_modes_fast_clock ar9462_2p0_modes_fast_clock
+
+#define ar9462_2p1_baseband_core_txfir_coeff_japan_2484 ar9462_2p0_baseband_core_txfir_coeff_japan_2484
+
+#define ar9462_2p1_pciephy_clkreq_disable_L1 ar9462_2p0_pciephy_clkreq_disable_L1
+
+static const u32 ar9462_2p1_mac_core[][2] = {
+ /* Addr      allmodes  */
+ {0x00000008, 0x00000000},
+ {0x00000030, 0x000e0085},
+ {0x00000034, 0x00000005},
+ {0x00000040, 0x00000000},
+ {0x00000044, 0x00000000},
+ {0x00000048, 0x00000008},
+ {0x0000004c, 0x00000010},
+ {0x00000050, 0x00000000},
+ {0x00001040, 0x002ffc0f},
+ {0x00001044, 0x002ffc0f},
+ {0x00001048, 0x002ffc0f},
+ {0x0000104c, 0x002ffc0f},
+ {0x00001050, 0x002ffc0f},
+ {0x00001054, 0x002ffc0f},
+ {0x00001058, 0x002ffc0f},
+ {0x0000105c, 0x002ffc0f},
+ {0x00001060, 0x002ffc0f},
+ {0x00001064, 0x002ffc0f},
+ {0x000010f0, 0x00000100},
+ {0x00001270, 0x00000000},
+ {0x000012b0, 0x00000000},
+ {0x000012f0, 0x00000000},
+ {0x0000143c, 0x00000000},
+ {0x0000147c, 0x00000000},
+ {0x00001810, 0x0f000003},
+ {0x00008000, 0x00000000},
+ {0x00008004, 0x00000000},
+ {0x00008008, 0x00000000},
+ {0x0000800c, 0x00000000},
+ {0x00008018, 0x00000000},
+ {0x00008020, 0x00000000},
+ {0x00008038, 0x00000000},
+ {0x0000803c, 0x00080000},
+ {0x00008040, 0x00000000},
+ {0x00008044, 0x00000000},
+ {0x00008048, 0x00000000},
+ {0x0000804c, 0xffffffff},
+ {0x00008054, 0x00000000},
+ {0x00008058, 0x00000000},
+ {0x0000805c, 0x000fc78f},
+ {0x00008060, 0x0000000f},
+ {0x00008064, 0x00000000},
+ {0x00008070, 0x00000310},
+ {0x00008074, 0x00000020},
+ {0x00008078, 0x00000000},
+ {0x0000809c, 0x0000000f},
+ {0x000080a0, 0x00000000},
+ {0x000080a4, 0x02ff0000},
+ {0x000080a8, 0x0e070605},
+ {0x000080ac, 0x0000000d},
+ {0x000080b0, 0x00000000},
+ {0x000080b4, 0x00000000},
+ {0x000080b8, 0x00000000},
+ {0x000080bc, 0x00000000},
+ {0x000080c0, 0x2a800000},
+ {0x000080c4, 0x06900168},
+ {0x000080c8, 0x13881c20},
+ {0x000080cc, 0x01f40000},
+ {0x000080d0, 0x00252500},
+ {0x000080d4, 0x00b00005},
+ {0x000080d8, 0x00400002},
+ {0x000080dc, 0x00000000},
+ {0x000080e0, 0xffffffff},
+ {0x000080e4, 0x0000ffff},
+ {0x000080e8, 0x3f3f3f3f},
+ {0x000080ec, 0x00000000},
+ {0x000080f0, 0x00000000},
+ {0x000080f4, 0x00000000},
+ {0x000080fc, 0x00020000},
+ {0x00008100, 0x00000000},
+ {0x00008108, 0x00000052},
+ {0x0000810c, 0x00000000},
+ {0x00008110, 0x00000000},
+ {0x00008114, 0x000007ff},
+ {0x00008118, 0x000000aa},
+ {0x0000811c, 0x00003210},
+ {0x00008124, 0x00000000},
+ {0x00008128, 0x00000000},
+ {0x0000812c, 0x00000000},
+ {0x00008130, 0x00000000},
+ {0x00008134, 0x00000000},
+ {0x00008138, 0x00000000},
+ {0x0000813c, 0x0000ffff},
+ {0x00008144, 0xffffffff},
+ {0x00008168, 0x00000000},
+ {0x0000816c, 0x00000000},
+ {0x00008170, 0x18486e00},
+ {0x00008174, 0x33332210},
+ {0x00008178, 0x00000000},
+ {0x0000817c, 0x00020000},
+ {0x000081c4, 0x33332210},
+ {0x000081c8, 0x00000000},
+ {0x000081cc, 0x00000000},
+ {0x000081d4, 0x00000000},
+ {0x000081ec, 0x00000000},
+ {0x000081f0, 0x00000000},
+ {0x000081f4, 0x00000000},
+ {0x000081f8, 0x00000000},
+ {0x000081fc, 0x00000000},
+ {0x00008240, 0x00100000},
+ {0x00008244, 0x0010f400},
+ {0x00008248, 0x00000800},
+ {0x0000824c, 0x0001e800},
+ {0x00008250, 0x00000000},
+ {0x00008254, 0x00000000},
+ {0x00008258, 0x00000000},
+ {0x0000825c, 0x40000000},
+ {0x00008260, 0x00080922},
+ {0x00008264, 0x99c00010},
+ {0x00008268, 0xffffffff},
+ {0x0000826c, 0x0000ffff},
+ {0x00008270, 0x00000000},
+ {0x00008274, 0x40000000},
+ {0x00008278, 0x003e4180},
+ {0x0000827c, 0x00000004},
+ {0x00008284, 0x0000002c},
+ {0x00008288, 0x0000002c},
+ {0x0000828c, 0x000000ff},
+ {0x00008294, 0x00000000},
+ {0x00008298, 0x00000000},
+ {0x0000829c, 0x00000000},
+ {0x00008300, 0x00000140},
+ {0x00008314, 0x00000000},
+ {0x0000831c, 0x0000010d},
+ {0x00008328, 0x00000000},
+ {0x0000832c, 0x0000001f},
+ {0x00008330, 0x00000302},
+ {0x00008334, 0x00000700},
+ {0x00008338, 0xffff0000},
+ {0x0000833c, 0x02400000},
+ {0x00008340, 0x000107ff},
+ {0x00008344, 0xaa48107b},
+ {0x00008348, 0x008f0000},
+ {0x0000835c, 0x00000000},
+ {0x00008360, 0xffffffff},
+ {0x00008364, 0xffffffff},
+ {0x00008368, 0x00000000},
+ {0x00008370, 0x00000000},
+ {0x00008374, 0x000000ff},
+ {0x00008378, 0x00000000},
+ {0x0000837c, 0x00000000},
+ {0x00008380, 0xffffffff},
+ {0x00008384, 0xffffffff},
+ {0x00008390, 0xffffffff},
+ {0x00008394, 0xffffffff},
+ {0x00008398, 0x00000000},
+ {0x0000839c, 0x00000000},
+ {0x000083a4, 0x0000fa14},
+ {0x000083a8, 0x000f0c00},
+ {0x000083ac, 0x33332210},
+ {0x000083b0, 0x33332210},
+ {0x000083b4, 0x33332210},
+ {0x000083b8, 0x33332210},
+ {0x000083bc, 0x00000000},
+ {0x000083c0, 0x00000000},
+ {0x000083c4, 0x00000000},
+ {0x000083c8, 0x00000000},
+ {0x000083cc, 0x00000200},
+ {0x000083d0, 0x000301ff},
+};
+
+static const u32 ar9462_2p1_baseband_postamble[][5] = {
+ /* Addr      5G_HT20     5G_HT40     2G_HT40     2G_HT20   */
+ {0x00009810, 0xd00a8005, 0xd00a8005, 0xd00a8011, 0xd00a800d},
+ {0x00009820, 0x206a022e, 0x206a022e, 0x206a012e, 0x206a01ae},
+ {0x00009824, 0x63c640de, 0x5ac640d0, 0x5ac640d0, 0x63c640da},
+ {0x00009828, 0x0796be89, 0x0696b081, 0x0696b881, 0x09143e81},
+ {0x0000982c, 0x05eea6d4, 0x05eea6d4, 0x05eea6d4, 0x05eea6d4},
+ {0x00009830, 0x0000059c, 0x0000059c, 0x0000119c, 0x0000119c},
+ {0x00009c00, 0x000000c4, 0x000000c4, 0x000000c4, 0x000000c4},
+ {0x00009e00, 0x0372111a, 0x0372111a, 0x037216a0, 0x037216a2},
+ {0x00009e04, 0x001c2020, 0x001c2020, 0x001c2020, 0x001c2020},
+ {0x00009e0c, 0x6c4000e2, 0x6d4000e2, 0x6d4000e2, 0x6c4000d8},
+ {0x00009e10, 0x92c88d2e, 0x7ec88d2e, 0x7ec84d2e, 0x7ec86d2e},
+ {0x00009e14, 0x37b95d5e, 0x37b9605e, 0x3236605e, 0x32365a5e},
+ {0x00009e18, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
+ {0x00009e1c, 0x0001cf9c, 0x0001cf9c, 0x00021f9c, 0x00021f9c},
+ {0x00009e20, 0x000003a5, 0x000003a5, 0x000003a5, 0x000003a5},
+ {0x00009e2c, 0x0000001c, 0x0000001c, 0x00000021, 0x00000021},
+ {0x00009e3c, 0xcf946220, 0xcf946220, 0xcfd5c782, 0xcfd5c282},
+ {0x00009e44, 0x62321e27, 0x62321e27, 0xfe291e27, 0xfe291e27},
+ {0x00009e48, 0x5030201a, 0x5030201a, 0x50302012, 0x50302012},
+ {0x00009fc8, 0x0003f000, 0x0003f000, 0x0001a000, 0x0001a000},
+ {0x0000a204, 0x01318fc0, 0x01318fc4, 0x01318fc4, 0x01318fc0},
+ {0x0000a208, 0x00000104, 0x00000104, 0x00000004, 0x00000004},
+ {0x0000a22c, 0x01026a2f, 0x01026a27, 0x01026a2f, 0x01026a2f},
+ {0x0000a230, 0x0000400a, 0x00004014, 0x00004016, 0x0000400b},
+ {0x0000a234, 0x00000fff, 0x10000fff, 0x10000fff, 0x00000fff},
+ {0x0000a238, 0xffb81018, 0xffb81018, 0xffb81018, 0xffb81018},
+ {0x0000a250, 0x00000000, 0x00000000, 0x00000210, 0x00000108},
+ {0x0000a254, 0x000007d0, 0x00000fa0, 0x00001130, 0x00000898},
+ {0x0000a258, 0x02020002, 0x02020002, 0x02020002, 0x02020002},
+ {0x0000a25c, 0x01000e0e, 0x01000e0e, 0x01000e0e, 0x01000e0e},
+ {0x0000a260, 0x0a021501, 0x0a021501, 0x3a021501, 0x3a021501},
+ {0x0000a264, 0x00000e0e, 0x00000e0e, 0x00000e0e, 0x00000e0e},
+ {0x0000a280, 0x00000007, 0x00000007, 0x0000000b, 0x0000000b},
+ {0x0000a284, 0x00000000, 0x00000000, 0x00000150, 0x00000150},
+ {0x0000a288, 0x00000110, 0x00000110, 0x00000110, 0x00000110},
+ {0x0000a28c, 0x00022222, 0x00022222, 0x00022222, 0x00022222},
+ {0x0000a2c4, 0x00158d18, 0x00158d18, 0x00158d18, 0x00158d18},
+ {0x0000a2d0, 0x00041981, 0x00041981, 0x00041981, 0x00041982},
+ {0x0000a2d8, 0x7999a83b, 0x7999a83b, 0x7999a83b, 0x7999a83b},
+ {0x0000a358, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
+ {0x0000a3a4, 0x00000050, 0x00000050, 0x00000000, 0x00000000},
+ {0x0000a3a8, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaaa},
+ {0x0000a3ac, 0xaaaaaa00, 0xaa30aa30, 0xaaaaaa00, 0xaaaaaa00},
+ {0x0000a41c, 0x1ce739ce, 0x1ce739ce, 0x1ce739ce, 0x1ce739ce},
+ {0x0000a420, 0x000001ce, 0x000001ce, 0x000001ce, 0x000001ce},
+ {0x0000a424, 0x1ce739ce, 0x1ce739ce, 0x1ce739ce, 0x1ce739ce},
+ {0x0000a428, 0x000001ce, 0x000001ce, 0x000001ce, 0x000001ce},
+ {0x0000a42c, 0x1ce739ce, 0x1ce739ce, 0x1ce739ce, 0x1ce739ce},
+ {0x0000a430, 0x1ce739ce, 0x1ce739ce, 0x1ce739ce, 0x1ce739ce},
+ {0x0000a830, 0x0000019c, 0x0000019c, 0x0000019c, 0x0000019c},
+ {0x0000ae04, 0x001c0000, 0x001c0000, 0x001c0000, 0x00100000},
+ {0x0000ae18, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
+ {0x0000ae1c, 0x0000019c, 0x0000019c, 0x0000019c, 0x0000019c},
+ {0x0000ae20, 0x000001a6, 0x000001a6, 0x000001aa, 0x000001aa},
+ {0x0000b284, 0x00000000, 0x00000000, 0x00000550, 0x00000550},
+};
+
+static const u32 ar9462_2p1_soc_preamble[][2] = {
+ /* Addr      allmodes  */
+ {0x000040a4, 0x00a0c9c9},
+ {0x00007020, 0x00000000},
+ {0x00007034, 0x00000002},
+ {0x00007038, 0x000004c2},
+};
+
+#endif /* INITVALS_9462_2P1_H */
diff --git a/drivers/net/wireless/ath/ath9k/ar9485_initvals.h b/drivers/net/wireless/ath/ath9k/ar9485_initvals.h
index 88ff1d7..ce83ce4 100644
--- a/drivers/net/wireless/ath/ath9k/ar9485_initvals.h
+++ b/drivers/net/wireless/ath/ath9k/ar9485_initvals.h
@@ -20,20 +20,18 @@
 
 /* AR9485 1.1 */
 
-#define ar9485_1_1_mac_postamble ar9300_2p2_mac_postamble
+#define ar9485_modes_lowest_ob_db_tx_gain_1_1 ar9485Modes_low_ob_db_tx_gain_1_1
 
-static const u32 ar9485_1_1_pcie_phy_pll_on_clkreq_disable_L1[][2] = {
- /* Addr      allmodes  */
- {0x00018c00, 0x18012e5e},
- {0x00018c04, 0x000801d8},
- {0x00018c08, 0x0000080c},
-};
+#define ar9485_1_1_mac_postamble ar9331_1p1_mac_postamble
+
+#define ar9485_1_1_baseband_core_txfir_coeff_japan_2484 ar9300_2p2_baseband_core_txfir_coeff_japan_2484
 
 static const u32 ar9485Common_wo_xlna_rx_gain_1_1[][2] = {
  /* Addr      allmodes  */
  {0x00009e00, 0x037216a0},
  {0x00009e04, 0x00182020},
  {0x00009e18, 0x00000000},
+ {0x00009e20, 0x000003a8},
  {0x00009e2c, 0x00004121},
  {0x00009e44, 0x02282324},
  {0x0000a000, 0x00060005},
@@ -174,7 +172,7 @@ static const u32 ar9485Modes_high_power_tx_gain_1_1[][5] = {
  {0x0000a2e0, 0x00000000, 0x00000000, 0xfe2d3552, 0xfe2d3552},
  {0x0000a2e4, 0x00000000, 0x00000000, 0xfe2d3552, 0xfe2d3552},
  {0x0000a2e8, 0x00000000, 0x00000000, 0xfe2d3552, 0xfe2d3552},
- {0x0000a410, 0x000050d9, 0x000050d9, 0x000050d8, 0x000050d8},
+ {0x0000a410, 0x000050d9, 0x000050d9, 0x000050da, 0x000050da},
  {0x0000a458, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
  {0x0000a500, 0x00022200, 0x00022200, 0x00000000, 0x00000000},
  {0x0000a504, 0x05062002, 0x05062002, 0x04000002, 0x04000002},
@@ -200,14 +198,14 @@ static const u32 ar9485Modes_high_power_tx_gain_1_1[][5] = {
  {0x0000a554, 0x7d06ffcb, 0x7d06ffcb, 0x57001ce9, 0x57001ce9},
  {0x0000a558, 0x8407ff0b, 0x8407ff0b, 0x5a001ceb, 0x5a001ceb},
  {0x0000a55c, 0x8907ffcb, 0x8907ffcb, 0x5e001eeb, 0x5e001eeb},
- {0x0000a560, 0x900fff0b, 0x900fff0b, 0x5e001eeb, 0x5e001eeb},
- {0x0000a564, 0x960fffcb, 0x960fffcb, 0x5e001eeb, 0x5e001eeb},
- {0x0000a568, 0x9c1fff0b, 0x9c1fff0b, 0x5e001eeb, 0x5e001eeb},
- {0x0000a56c, 0x9c1fff0b, 0x9c1fff0b, 0x5e001eeb, 0x5e001eeb},
- {0x0000a570, 0x9c1fff0b, 0x9c1fff0b, 0x5e001eeb, 0x5e001eeb},
- {0x0000a574, 0x9c1fff0b, 0x9c1fff0b, 0x5e001eeb, 0x5e001eeb},
- {0x0000a578, 0x9c1fff0b, 0x9c1fff0b, 0x5e001eeb, 0x5e001eeb},
- {0x0000a57c, 0x9c1fff0b, 0x9c1fff0b, 0x5e001eeb, 0x5e001eeb},
+ {0x0000a560, 0x900fff0b, 0x900fff0b, 0x62001eee, 0x62001eee},
+ {0x0000a564, 0x960fffcb, 0x960fffcb, 0x66001ff6, 0x66001ff6},
+ {0x0000a568, 0x9c1fff0b, 0x9c1fff0b, 0x66001ff6, 0x66001ff6},
+ {0x0000a56c, 0x9c1fff0b, 0x9c1fff0b, 0x66001ff6, 0x66001ff6},
+ {0x0000a570, 0x9c1fff0b, 0x9c1fff0b, 0x66001ff6, 0x66001ff6},
+ {0x0000a574, 0x9c1fff0b, 0x9c1fff0b, 0x66001ff6, 0x66001ff6},
+ {0x0000a578, 0x9c1fff0b, 0x9c1fff0b, 0x66001ff6, 0x66001ff6},
+ {0x0000a57c, 0x9c1fff0b, 0x9c1fff0b, 0x66001ff6, 0x66001ff6},
  {0x0000a580, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
  {0x0000a584, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
  {0x0000a588, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
@@ -263,6 +261,11 @@ static const u32 ar9485Modes_high_power_tx_gain_1_1[][5] = {
 static const u32 ar9485Modes_green_ob_db_tx_gain_1_1[][5] = {
  /* Addr      5G_HT20     5G_HT40     2G_HT40     2G_HT20   */
  {0x000098bc, 0x00000003, 0x00000003, 0x00000003, 0x00000003},
+ {0x0000a2d8, 0xf999a83a, 0xf999a83a, 0x7999a83a, 0x7999a83a},
+ {0x0000a2dc, 0x00000000, 0x00000000, 0xfe2d3552, 0xfe2d3552},
+ {0x0000a2e0, 0x00000000, 0x00000000, 0xfe2d3552, 0xfe2d3552},
+ {0x0000a2e4, 0x00000000, 0x00000000, 0xfe2d3552, 0xfe2d3552},
+ {0x0000a2e8, 0x00000000, 0x00000000, 0xfe2d3552, 0xfe2d3552},
  {0x0000a410, 0x000050d9, 0x000050d9, 0x000050d8, 0x000050d8},
  {0x0000a458, 0x80000000, 0x80000000, 0x80000000, 0x80000000},
  {0x0000a500, 0x00022200, 0x00022200, 0x00000006, 0x00000006},
@@ -297,6 +300,22 @@ static const u32 ar9485Modes_green_ob_db_tx_gain_1_1[][5] = {
  {0x0000a574, 0x9c1fff0b, 0x9c1fff0b, 0x5e001eeb, 0x5e001eeb},
  {0x0000a578, 0x9c1fff0b, 0x9c1fff0b, 0x5e001eeb, 0x5e001eeb},
  {0x0000a57c, 0x9c1fff0b, 0x9c1fff0b, 0x5e001eeb, 0x5e001eeb},
+ {0x0000a580, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
+ {0x0000a584, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
+ {0x0000a588, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
+ {0x0000a58c, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
+ {0x0000a590, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
+ {0x0000a594, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
+ {0x0000a598, 0x00000000, 0x00000000, 0x01404501, 0x01404501},
+ {0x0000a59c, 0x00000000, 0x00000000, 0x02808a02, 0x02808a02},
+ {0x0000a5a0, 0x00000000, 0x00000000, 0x02808a02, 0x02808a02},
+ {0x0000a5a4, 0x00000000, 0x00000000, 0x02808803, 0x02808803},
+ {0x0000a5a8, 0x00000000, 0x00000000, 0x04c14b04, 0x04c14b04},
+ {0x0000a5ac, 0x00000000, 0x00000000, 0x04c15305, 0x04c15305},
+ {0x0000a5b0, 0x00000000, 0x00000000, 0x04c15305, 0x04c15305},
+ {0x0000a5b4, 0x00000000, 0x00000000, 0x04c15305, 0x04c15305},
+ {0x0000a5b8, 0x00000000, 0x00000000, 0x04c15305, 0x04c15305},
+ {0x0000a5bc, 0x00000000, 0x00000000, 0x04c15305, 0x04c15305},
  {0x0000b500, 0x0000001a, 0x0000001a, 0x0000001a, 0x0000001a},
  {0x0000b504, 0x0000001a, 0x0000001a, 0x0000001a, 0x0000001a},
  {0x0000b508, 0x0000001a, 0x0000001a, 0x0000001a, 0x0000001a},
@@ -341,7 +360,7 @@ static const u32 ar9485Modes_high_ob_db_tx_gain_1_1[][5] = {
  {0x0000a2e0, 0x00000000, 0x00000000, 0xffc63a84, 0xffc63a84},
  {0x0000a2e4, 0x00000000, 0x00000000, 0xfe0fc000, 0xfe0fc000},
  {0x0000a2e8, 0x00000000, 0x00000000, 0xfff00000, 0xfff00000},
- {0x0000a410, 0x000050d9, 0x000050d9, 0x000050d8, 0x000050d8},
+ {0x0000a410, 0x000050d9, 0x000050d9, 0x000050da, 0x000050da},
  {0x0000a458, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
  {0x0000a500, 0x00022200, 0x00022200, 0x00000000, 0x00000000},
  {0x0000a504, 0x05062002, 0x05062002, 0x04000002, 0x04000002},
@@ -367,14 +386,14 @@ static const u32 ar9485Modes_high_ob_db_tx_gain_1_1[][5] = {
  {0x0000a554, 0x7d06ffcb, 0x7d06ffcb, 0x57001ce9, 0x57001ce9},
  {0x0000a558, 0x8407ff0b, 0x8407ff0b, 0x5a001ceb, 0x5a001ceb},
  {0x0000a55c, 0x8907ffcb, 0x8907ffcb, 0x5e001eeb, 0x5e001eeb},
- {0x0000a560, 0x900fff0b, 0x900fff0b, 0x5e001eeb, 0x5e001eeb},
- {0x0000a564, 0x960fffcb, 0x960fffcb, 0x5e001eeb, 0x5e001eeb},
- {0x0000a568, 0x9c1fff0b, 0x9c1fff0b, 0x5e001eeb, 0x5e001eeb},
- {0x0000a56c, 0x9c1fff0b, 0x9c1fff0b, 0x5e001eeb, 0x5e001eeb},
- {0x0000a570, 0x9c1fff0b, 0x9c1fff0b, 0x5e001eeb, 0x5e001eeb},
- {0x0000a574, 0x9c1fff0b, 0x9c1fff0b, 0x5e001eeb, 0x5e001eeb},
- {0x0000a578, 0x9c1fff0b, 0x9c1fff0b, 0x5e001eeb, 0x5e001eeb},
- {0x0000a57c, 0x9c1fff0b, 0x9c1fff0b, 0x5e001eeb, 0x5e001eeb},
+ {0x0000a560, 0x900fff0b, 0x900fff0b, 0x62001eee, 0x62001eee},
+ {0x0000a564, 0x960fffcb, 0x960fffcb, 0x66001ff6, 0x66001ff6},
+ {0x0000a568, 0x9c1fff0b, 0x9c1fff0b, 0x66001ff6, 0x66001ff6},
+ {0x0000a56c, 0x9c1fff0b, 0x9c1fff0b, 0x66001ff6, 0x66001ff6},
+ {0x0000a570, 0x9c1fff0b, 0x9c1fff0b, 0x66001ff6, 0x66001ff6},
+ {0x0000a574, 0x9c1fff0b, 0x9c1fff0b, 0x66001ff6, 0x66001ff6},
+ {0x0000a578, 0x9c1fff0b, 0x9c1fff0b, 0x66001ff6, 0x66001ff6},
+ {0x0000a57c, 0x9c1fff0b, 0x9c1fff0b, 0x66001ff6, 0x66001ff6},
  {0x0000a580, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
  {0x0000a584, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
  {0x0000a588, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
@@ -521,12 +540,15 @@ static const u32 ar9485Modes_low_ob_db_tx_gain_1_1[][5] = {
  {0x00016048, 0x6c924260, 0x6c924260, 0x6c924260, 0x6c924260},
 };
 
-#define ar9485_modes_lowest_ob_db_tx_gain_1_1 ar9485Modes_low_ob_db_tx_gain_1_1
-
 static const u32 ar9485Modes_green_spur_ob_db_tx_gain_1_1[][5] = {
  /* Addr      5G_HT20     5G_HT40     2G_HT40     2G_HT20   */
  {0x000098bc, 0x00000003, 0x00000003, 0x00000003, 0x00000003},
- {0x0000a410, 0x000050d9, 0x000050d9, 0x000050d8, 0x000050d8},
+ {0x0000a2d8, 0xf999a83a, 0xf999a83a, 0x7999a83a, 0x7999a83a},
+ {0x0000a2dc, 0x00000000, 0x00000000, 0xffad452a, 0xffad452a},
+ {0x0000a2e0, 0x00000000, 0x00000000, 0xffc98634, 0xffc98634},
+ {0x0000a2e4, 0x00000000, 0x00000000, 0xfff60780, 0xfff60780},
+ {0x0000a2e8, 0x00000000, 0x00000000, 0xfffff800, 0xfffff800},
+ {0x0000a410, 0x000050d9, 0x000050d9, 0x000050d9, 0x000050d9},
  {0x0000a458, 0x80000000, 0x80000000, 0x80000000, 0x80000000},
  {0x0000a500, 0x00022200, 0x00022200, 0x00000006, 0x00000006},
  {0x0000a504, 0x05062002, 0x05062002, 0x03000201, 0x03000201},
@@ -543,23 +565,39 @@ static const u32 ar9485Modes_green_spur_ob_db_tx_gain_1_1[][5] = {
  {0x0000a530, 0x48023ec6, 0x48023ec6, 0x310006e0, 0x310006e0},
  {0x0000a534, 0x4d023f01, 0x4d023f01, 0x330006e0, 0x330006e0},
  {0x0000a538, 0x53023f4b, 0x53023f4b, 0x3e0008e3, 0x3e0008e3},
- {0x0000a53c, 0x5a027f09, 0x5a027f09, 0x410008e5, 0x410008e5},
- {0x0000a540, 0x5f027fc9, 0x5f027fc9, 0x430008e6, 0x430008e6},
- {0x0000a544, 0x6502feca, 0x6502feca, 0x4a0008ec, 0x4a0008ec},
- {0x0000a548, 0x6b02ff4a, 0x6b02ff4a, 0x4e0008f1, 0x4e0008f1},
- {0x0000a54c, 0x7203feca, 0x7203feca, 0x520008f3, 0x520008f3},
- {0x0000a550, 0x7703ff0b, 0x7703ff0b, 0x54000eed, 0x54000eed},
- {0x0000a554, 0x7d06ffcb, 0x7d06ffcb, 0x58000ef1, 0x58000ef1},
- {0x0000a558, 0x8407ff0b, 0x8407ff0b, 0x5c000ef3, 0x5c000ef3},
- {0x0000a55c, 0x8907ffcb, 0x8907ffcb, 0x60000ef5, 0x60000ef5},
- {0x0000a560, 0x900fff0b, 0x900fff0b, 0x62000ef6, 0x62000ef6},
- {0x0000a564, 0x960fffcb, 0x960fffcb, 0x62000ef6, 0x62000ef6},
- {0x0000a568, 0x9c1fff0b, 0x9c1fff0b, 0x62000ef6, 0x62000ef6},
- {0x0000a56c, 0x9c1fff0b, 0x9c1fff0b, 0x62000ef6, 0x62000ef6},
- {0x0000a570, 0x9c1fff0b, 0x9c1fff0b, 0x62000ef6, 0x62000ef6},
- {0x0000a574, 0x9c1fff0b, 0x9c1fff0b, 0x62000ef6, 0x62000ef6},
- {0x0000a578, 0x9c1fff0b, 0x9c1fff0b, 0x62000ef6, 0x62000ef6},
- {0x0000a57c, 0x9c1fff0b, 0x9c1fff0b, 0x62000ef6, 0x62000ef6},
+ {0x0000a53c, 0x5a027f09, 0x5a027f09, 0x430008e6, 0x430008e6},
+ {0x0000a540, 0x5f027fc9, 0x5f027fc9, 0x4a0008ec, 0x4a0008ec},
+ {0x0000a544, 0x6502feca, 0x6502feca, 0x4e0008f1, 0x4e0008f1},
+ {0x0000a548, 0x6b02ff4a, 0x6b02ff4a, 0x520008f3, 0x520008f3},
+ {0x0000a54c, 0x7203feca, 0x7203feca, 0x54000eed, 0x54000eed},
+ {0x0000a550, 0x7703ff0b, 0x7703ff0b, 0x58000ef1, 0x58000ef1},
+ {0x0000a554, 0x7d06ffcb, 0x7d06ffcb, 0x5c000ef3, 0x5c000ef3},
+ {0x0000a558, 0x8407ff0b, 0x8407ff0b, 0x62000ef6, 0x62000ef6},
+ {0x0000a55c, 0x8907ffcb, 0x8907ffcb, 0x66001ff0, 0x66001ff0},
+ {0x0000a560, 0x900fff0b, 0x900fff0b, 0x68001ff6, 0x68001ff6},
+ {0x0000a564, 0x960fffcb, 0x960fffcb, 0x68001ff6, 0x68001ff6},
+ {0x0000a568, 0x9c1fff0b, 0x9c1fff0b, 0x68001ff6, 0x68001ff6},
+ {0x0000a56c, 0x9c1fff0b, 0x9c1fff0b, 0x68001ff6, 0x68001ff6},
+ {0x0000a570, 0x9c1fff0b, 0x9c1fff0b, 0x68001ff6, 0x68001ff6},
+ {0x0000a574, 0x9c1fff0b, 0x9c1fff0b, 0x68001ff6, 0x68001ff6},
+ {0x0000a578, 0x9c1fff0b, 0x9c1fff0b, 0x68001ff6, 0x68001ff6},
+ {0x0000a57c, 0x9c1fff0b, 0x9c1fff0b, 0x68001ff6, 0x68001ff6},
+ {0x0000a580, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
+ {0x0000a584, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
+ {0x0000a588, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
+ {0x0000a58c, 0x00000000, 0x00000000, 0x01804000, 0x01804000},
+ {0x0000a590, 0x00000000, 0x00000000, 0x02808a02, 0x02808a02},
+ {0x0000a594, 0x00000000, 0x00000000, 0x0340ca02, 0x0340ca02},
+ {0x0000a598, 0x00000000, 0x00000000, 0x0340cd03, 0x0340cd03},
+ {0x0000a59c, 0x00000000, 0x00000000, 0x0340cd03, 0x0340cd03},
+ {0x0000a5a0, 0x00000000, 0x00000000, 0x06415304, 0x06415304},
+ {0x0000a5a4, 0x00000000, 0x00000000, 0x04c11905, 0x04c11905},
+ {0x0000a5a8, 0x00000000, 0x00000000, 0x06415905, 0x06415905},
+ {0x0000a5ac, 0x00000000, 0x00000000, 0x06415905, 0x06415905},
+ {0x0000a5b0, 0x00000000, 0x00000000, 0x06415905, 0x06415905},
+ {0x0000a5b4, 0x00000000, 0x00000000, 0x06415905, 0x06415905},
+ {0x0000a5b8, 0x00000000, 0x00000000, 0x06415905, 0x06415905},
+ {0x0000a5bc, 0x00000000, 0x00000000, 0x06415905, 0x06415905},
  {0x0000b500, 0x0000001a, 0x0000001a, 0x0000001a, 0x0000001a},
  {0x0000b504, 0x0000001a, 0x0000001a, 0x0000001a, 0x0000001a},
  {0x0000b508, 0x0000001a, 0x0000001a, 0x0000001a, 0x0000001a},
@@ -823,6 +861,7 @@ static const u32 ar9485_common_rx_gain_1_1[][2] = {
  {0x00009e00, 0x03721b20},
  {0x00009e04, 0x00082020},
  {0x00009e18, 0x0300501e},
+ {0x00009e20, 0x000003ba},
  {0x00009e2c, 0x00002e21},
  {0x00009e44, 0x02182324},
  {0x0000a000, 0x00060005},
@@ -955,20 +994,6 @@ static const u32 ar9485_common_rx_gain_1_1[][2] = {
  {0x0000a1fc, 0x00000296},
 };
 
-static const u32 ar9485_1_1_pcie_phy_pll_on_clkreq_enable_L1[][2] = {
- /* Addr      allmodes  */
- {0x00018c00, 0x18052e5e},
- {0x00018c04, 0x000801d8},
- {0x00018c08, 0x0000080c},
-};
-
-static const u32 ar9485_1_1_pcie_phy_clkreq_enable_L1[][2] = {
- /* Addr      allmodes  */
- {0x00018c00, 0x18053e5e},
- {0x00018c04, 0x000801d8},
- {0x00018c08, 0x0000080c},
-};
-
 static const u32 ar9485_1_1_soc_preamble[][2] = {
  /* Addr      allmodes  */
  {0x00004014, 0xba280400},
@@ -1001,7 +1026,6 @@ static const u32 ar9485_1_1_baseband_postamble[][5] = {
  {0x00009e10, 0x7ec88d2e, 0x7ec88d2e, 0x7ec80d2e, 0x7ec80d2e},
  {0x00009e14, 0x31395d53, 0x31396053, 0x312e6053, 0x312e5d53},
  {0x00009e1c, 0x0001cf9c, 0x0001cf9c, 0x00021f9c, 0x00021f9c},
- {0x00009e20, 0x000003b5, 0x000003b5, 0x000003ce, 0x000003ce},
  {0x00009e3c, 0xcf946220, 0xcf946220, 0xcf946222, 0xcf946222},
  {0x00009e48, 0x5030201a, 0x5030201a, 0x50302010, 0x50302010},
  {0x00009fc8, 0x0003f000, 0x0003f000, 0x0001a000, 0x0001a000},
@@ -1020,7 +1044,7 @@ static const u32 ar9485_1_1_baseband_postamble[][5] = {
  {0x0000a284, 0x00000000, 0x00000000, 0x000002a0, 0x000002a0},
  {0x0000a288, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
  {0x0000a28c, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
- {0x0000a2c4, 0x00158d18, 0x00158d18, 0x00058d18, 0x00058d18},
+ {0x0000a2c4, 0x00158d18, 0x00158d18, 0x00158d18, 0x00158d18},
  {0x0000a2d0, 0x00071981, 0x00071981, 0x00071982, 0x00071982},
  {0x0000a2d8, 0xf999a83a, 0xf999a83a, 0xf999a83a, 0xf999a83a},
  {0x0000a358, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
@@ -1028,13 +1052,6 @@ static const u32 ar9485_1_1_baseband_postamble[][5] = {
  {0x0000be18, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
 };
 
-static const u32 ar9485_1_1_pcie_phy_clkreq_disable_L1[][2] = {
- /* Addr      allmodes  */
- {0x00018c00, 0x18013e5e},
- {0x00018c04, 0x000801d8},
- {0x00018c08, 0x0000080c},
-};
-
 static const u32 ar9485_1_1_radio_postamble[][2] = {
  /* Addr      allmodes  */
  {0x0001609c, 0x0b283f31},
@@ -1206,6 +1223,18 @@ static const u32 ar9485_1_1_mac_core[][2] = {
  {0x000083d0, 0x000301ff},
 };
 
-#define ar9485_1_1_baseband_core_txfir_coeff_japan_2484 ar9462_2p0_baseband_core_txfir_coeff_japan_2484
+static const u32 ar9485_1_1_pcie_phy_clkreq_disable_L1[][2] = {
+ /* Addr      allmodes  */
+ {0x00018c00, 0x18013e5e},
+ {0x00018c04, 0x000801d8},
+ {0x00018c08, 0x0000080c},
+};
+
+static const u32 ar9485_1_1_pll_on_cdr_on_clkreq_disable_L1[][2] = {
+ /* Addr      allmodes  */
+ {0x00018c00, 0x1801265e},
+ {0x00018c04, 0x000801d8},
+ {0x00018c08, 0x0000080c},
+};
 
 #endif /* INITVALS_9485_H */
diff --git a/drivers/net/wireless/ath/ath9k/ar953x_initvals.h b/drivers/net/wireless/ath/ath9k/ar953x_initvals.h
new file mode 100644
index 0000000..8e5c3b9
--- /dev/null
+++ b/drivers/net/wireless/ath/ath9k/ar953x_initvals.h
@@ -0,0 +1,718 @@
+/*
+ * Copyright (c) 2010-2011 Atheros Communications Inc.
+ * Copyright (c) 2011-2012 Qualcomm Atheros Inc.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef INITVALS_953X_H
+#define INITVALS_953X_H
+
+#define qca953x_1p0_mac_postamble ar9300_2p2_mac_postamble
+
+#define qca953x_1p0_soc_postamble ar9300_2p2_soc_postamble
+
+#define qca953x_1p0_common_rx_gain_table ar9300Common_rx_gain_table_2p2
+
+#define qca953x_1p0_common_wo_xlna_rx_gain_table ar9300Common_wo_xlna_rx_gain_table_2p2
+
+#define qca953x_1p0_modes_fast_clock ar9300Modes_fast_clock_2p2
+
+static const u32 qca953x_1p0_mac_core[][2] = {
+ /* Addr      allmodes  */
+ {0x00000008, 0x00000000},
+ {0x00000030, 0x00020085},
+ {0x00000034, 0x00000005},
+ {0x00000040, 0x00000000},
+ {0x00000044, 0x00000000},
+ {0x00000048, 0x00000008},
+ {0x0000004c, 0x00000010},
+ {0x00000050, 0x00000000},
+ {0x00001040, 0x002ffc0f},
+ {0x00001044, 0x002ffc0f},
+ {0x00001048, 0x002ffc0f},
+ {0x0000104c, 0x002ffc0f},
+ {0x00001050, 0x002ffc0f},
+ {0x00001054, 0x002ffc0f},
+ {0x00001058, 0x002ffc0f},
+ {0x0000105c, 0x002ffc0f},
+ {0x00001060, 0x002ffc0f},
+ {0x00001064, 0x002ffc0f},
+ {0x000010f0, 0x00000100},
+ {0x00001270, 0x00000000},
+ {0x000012b0, 0x00000000},
+ {0x000012f0, 0x00000000},
+ {0x0000143c, 0x00000000},
+ {0x0000147c, 0x00000000},
+ {0x00008000, 0x00000000},
+ {0x00008004, 0x00000000},
+ {0x00008008, 0x00000000},
+ {0x0000800c, 0x00000000},
+ {0x00008018, 0x00000000},
+ {0x00008020, 0x00000000},
+ {0x00008038, 0x00000000},
+ {0x0000803c, 0x00000000},
+ {0x00008040, 0x00000000},
+ {0x00008044, 0x00000000},
+ {0x00008048, 0x00000000},
+ {0x0000804c, 0xffffffff},
+ {0x00008054, 0x00000000},
+ {0x00008058, 0x00000000},
+ {0x0000805c, 0x000fc78f},
+ {0x00008060, 0x0000000f},
+ {0x00008064, 0x00000000},
+ {0x00008070, 0x00000310},
+ {0x00008074, 0x00000020},
+ {0x00008078, 0x00000000},
+ {0x0000809c, 0x0000000f},
+ {0x000080a0, 0x00000000},
+ {0x000080a4, 0x02ff0000},
+ {0x000080a8, 0x0e070605},
+ {0x000080ac, 0x0000000d},
+ {0x000080b0, 0x00000000},
+ {0x000080b4, 0x00000000},
+ {0x000080b8, 0x00000000},
+ {0x000080bc, 0x00000000},
+ {0x000080c0, 0x2a800000},
+ {0x000080c4, 0x06900168},
+ {0x000080c8, 0x13881c22},
+ {0x000080cc, 0x01f40000},
+ {0x000080d0, 0x00252500},
+ {0x000080d4, 0x00a00000},
+ {0x000080d8, 0x00400000},
+ {0x000080dc, 0x00000000},
+ {0x000080e0, 0xffffffff},
+ {0x000080e4, 0x0000ffff},
+ {0x000080e8, 0x3f3f3f3f},
+ {0x000080ec, 0x00000000},
+ {0x000080f0, 0x00000000},
+ {0x000080f4, 0x00000000},
+ {0x000080fc, 0x00020000},
+ {0x00008100, 0x00000000},
+ {0x00008108, 0x00000052},
+ {0x0000810c, 0x00000000},
+ {0x00008110, 0x00000000},
+ {0x00008114, 0x000007ff},
+ {0x00008118, 0x000000aa},
+ {0x0000811c, 0x00003210},
+ {0x00008124, 0x00000000},
+ {0x00008128, 0x00000000},
+ {0x0000812c, 0x00000000},
+ {0x00008130, 0x00000000},
+ {0x00008134, 0x00000000},
+ {0x00008138, 0x00000000},
+ {0x0000813c, 0x0000ffff},
+ {0x00008140, 0x000000fe},
+ {0x00008144, 0xffffffff},
+ {0x00008168, 0x00000000},
+ {0x0000816c, 0x00000000},
+ {0x000081c0, 0x00000000},
+ {0x000081c4, 0x33332210},
+ {0x000081ec, 0x00000000},
+ {0x000081f0, 0x00000000},
+ {0x000081f4, 0x00000000},
+ {0x000081f8, 0x00000000},
+ {0x000081fc, 0x00000000},
+ {0x00008240, 0x00100000},
+ {0x00008244, 0x0010f3d7},
+ {0x00008248, 0x00000852},
+ {0x0000824c, 0x0001e7ae},
+ {0x00008250, 0x00000000},
+ {0x00008254, 0x00000000},
+ {0x00008258, 0x00000000},
+ {0x0000825c, 0x40000000},
+ {0x00008260, 0x00080922},
+ {0x00008264, 0x9d400010},
+ {0x00008268, 0xffffffff},
+ {0x0000826c, 0x0000ffff},
+ {0x00008270, 0x00000000},
+ {0x00008274, 0x40000000},
+ {0x00008278, 0x003e4180},
+ {0x0000827c, 0x00000004},
+ {0x00008284, 0x0000002c},
+ {0x00008288, 0x0000002c},
+ {0x0000828c, 0x000000ff},
+ {0x00008294, 0x00000000},
+ {0x00008298, 0x00000000},
+ {0x0000829c, 0x00000000},
+ {0x00008300, 0x00001d40},
+ {0x00008314, 0x00000000},
+ {0x0000831c, 0x0000010d},
+ {0x00008328, 0x00000000},
+ {0x0000832c, 0x0000001f},
+ {0x00008330, 0x00000302},
+ {0x00008334, 0x00000700},
+ {0x00008338, 0xffff0000},
+ {0x0000833c, 0x02400000},
+ {0x00008340, 0x000107ff},
+ {0x00008344, 0xaa48107b},
+ {0x00008348, 0x008f0000},
+ {0x0000835c, 0x00000000},
+ {0x00008360, 0xffffffff},
+ {0x00008364, 0xffffffff},
+ {0x00008368, 0x00000000},
+ {0x00008370, 0x00000000},
+ {0x00008374, 0x000000ff},
+ {0x00008378, 0x00000000},
+ {0x0000837c, 0x00000000},
+ {0x00008380, 0xffffffff},
+ {0x00008384, 0xffffffff},
+ {0x00008390, 0xffffffff},
+ {0x00008394, 0xffffffff},
+ {0x00008398, 0x00000000},
+ {0x0000839c, 0x00000000},
+ {0x000083a0, 0x00000000},
+ {0x000083a4, 0x0000fa14},
+ {0x000083a8, 0x000f0c00},
+ {0x000083ac, 0x33332210},
+ {0x000083b0, 0x33332210},
+ {0x000083b4, 0x33332210},
+ {0x000083b8, 0x33332210},
+ {0x000083bc, 0x00000000},
+ {0x000083c0, 0x00000000},
+ {0x000083c4, 0x00000000},
+ {0x000083c8, 0x00000000},
+ {0x000083cc, 0x00000200},
+ {0x000083d0, 0x8c7901ff},
+};
+
+static const u32 qca953x_1p0_baseband_core[][2] = {
+ /* Addr      allmodes  */
+ {0x00009800, 0xafe68e30},
+ {0x00009804, 0xfd14e000},
+ {0x00009808, 0x9c0a9f6b},
+ {0x0000980c, 0x04900000},
+ {0x00009814, 0x0280c00a},
+ {0x00009818, 0x00000000},
+ {0x0000981c, 0x00020028},
+ {0x00009834, 0x6400a190},
+ {0x00009838, 0x0108ecff},
+ {0x0000983c, 0x14000600},
+ {0x00009880, 0x201fff00},
+ {0x00009884, 0x00001042},
+ {0x000098a4, 0x00200400},
+ {0x000098b0, 0x32840bbe},
+ {0x000098bc, 0x00000002},
+ {0x000098d0, 0x004b6a8e},
+ {0x000098d4, 0x00000820},
+ {0x000098dc, 0x00000000},
+ {0x000098f0, 0x00000000},
+ {0x000098f4, 0x00000000},
+ {0x00009c04, 0xff55ff55},
+ {0x00009c08, 0x0320ff55},
+ {0x00009c0c, 0x00000000},
+ {0x00009c10, 0x00000000},
+ {0x00009c14, 0x00046384},
+ {0x00009c18, 0x05b6b440},
+ {0x00009c1c, 0x00b6b440},
+ {0x00009d00, 0xc080a333},
+ {0x00009d04, 0x40206c10},
+ {0x00009d08, 0x009c4060},
+ {0x00009d0c, 0x9883800a},
+ {0x00009d10, 0x01884061},
+ {0x00009d14, 0x00c0040b},
+ {0x00009d18, 0x00000000},
+ {0x00009e08, 0x0038230c},
+ {0x00009e24, 0x990bb515},
+ {0x00009e28, 0x0c6f0000},
+ {0x00009e30, 0x06336f77},
+ {0x00009e34, 0x6af6532f},
+ {0x00009e38, 0x0cc80c00},
+ {0x00009e40, 0x0d261820},
+ {0x00009e4c, 0x00001004},
+ {0x00009e50, 0x00ff03f1},
+ {0x00009fc0, 0x813e4788},
+ {0x00009fc4, 0x0001efb5},
+ {0x00009fcc, 0x40000014},
+ {0x00009fd0, 0x01193b91},
+ {0x0000a20c, 0x00000000},
+ {0x0000a220, 0x00000000},
+ {0x0000a224, 0x00000000},
+ {0x0000a228, 0x10002310},
+ {0x0000a23c, 0x00000000},
+ {0x0000a244, 0x0c000000},
+ {0x0000a248, 0x00000140},
+ {0x0000a2a0, 0x00000007},
+ {0x0000a2c0, 0x00000007},
+ {0x0000a2c8, 0x00000000},
+ {0x0000a2d4, 0x00000000},
+ {0x0000a2ec, 0x00000000},
+ {0x0000a2f0, 0x00000000},
+ {0x0000a2f4, 0x00000000},
+ {0x0000a2f8, 0x00000000},
+ {0x0000a344, 0x00000000},
+ {0x0000a34c, 0x00000000},
+ {0x0000a350, 0x0000a000},
+ {0x0000a364, 0x00000000},
+ {0x0000a370, 0x00000000},
+ {0x0000a390, 0x00000001},
+ {0x0000a394, 0x00000444},
+ {0x0000a398, 0x001f0e0f},
+ {0x0000a39c, 0x0075393f},
+ {0x0000a3a0, 0xb79f6427},
+ {0x0000a3a4, 0x000000ff},
+ {0x0000a3a8, 0x6a6a6a6a},
+ {0x0000a3ac, 0x6a6a6a6a},
+ {0x0000a3b0, 0x00c8641a},
+ {0x0000a3b4, 0x0000001a},
+ {0x0000a3b8, 0x0088642a},
+ {0x0000a3bc, 0x000001fa},
+ {0x0000a3c0, 0x20202020},
+ {0x0000a3c4, 0x22222220},
+ {0x0000a3c8, 0x20200020},
+ {0x0000a3cc, 0x20202020},
+ {0x0000a3d0, 0x20202020},
+ {0x0000a3d4, 0x20202020},
+ {0x0000a3d8, 0x20202020},
+ {0x0000a3dc, 0x20202020},
+ {0x0000a3e0, 0x20202020},
+ {0x0000a3e4, 0x20202020},
+ {0x0000a3e8, 0x20202020},
+ {0x0000a3ec, 0x20202020},
+ {0x0000a3f0, 0x00000000},
+ {0x0000a3f4, 0x00000000},
+ {0x0000a3f8, 0x0c9bd380},
+ {0x0000a3fc, 0x000f0f01},
+ {0x0000a400, 0x8fa91f01},
+ {0x0000a404, 0x00000000},
+ {0x0000a408, 0x0e79e5c6},
+ {0x0000a40c, 0x00820820},
+ {0x0000a414, 0x1ce42108},
+ {0x0000a418, 0x2d001dce},
+ {0x0000a41c, 0x1ce73908},
+ {0x0000a420, 0x000001ce},
+ {0x0000a424, 0x1ce738e7},
+ {0x0000a428, 0x000001ce},
+ {0x0000a42c, 0x1ce739ce},
+ {0x0000a430, 0x1ce739ce},
+ {0x0000a434, 0x00000000},
+ {0x0000a438, 0x00001801},
+ {0x0000a43c, 0x00100000},
+ {0x0000a444, 0x00000000},
+ {0x0000a448, 0x05000080},
+ {0x0000a44c, 0x00000001},
+ {0x0000a450, 0x00010000},
+ {0x0000a458, 0x00000000},
+ {0x0000a644, 0xbfad9d74},
+ {0x0000a648, 0x0048060a},
+ {0x0000a64c, 0x00003c37},
+ {0x0000a670, 0x03020100},
+ {0x0000a674, 0x09080504},
+ {0x0000a678, 0x0d0c0b0a},
+ {0x0000a67c, 0x13121110},
+ {0x0000a680, 0x31301514},
+ {0x0000a684, 0x35343332},
+ {0x0000a688, 0x00000036},
+ {0x0000a690, 0x08000838},
+ {0x0000a7cc, 0x00000000},
+ {0x0000a7d0, 0x00000000},
+ {0x0000a7d4, 0x00000004},
+ {0x0000a7dc, 0x00000000},
+ {0x0000a8d0, 0x004b6a8e},
+ {0x0000a8d4, 0x00000820},
+ {0x0000a8dc, 0x00000000},
+ {0x0000a8f0, 0x00000000},
+ {0x0000a8f4, 0x00000000},
+ {0x0000b2d0, 0x00000080},
+ {0x0000b2d4, 0x00000000},
+ {0x0000b2ec, 0x00000000},
+ {0x0000b2f0, 0x00000000},
+ {0x0000b2f4, 0x00000000},
+ {0x0000b2f8, 0x00000000},
+ {0x0000b408, 0x0e79e5c0},
+ {0x0000b40c, 0x00820820},
+ {0x0000b420, 0x00000000},
+};
+
+static const u32 qca953x_1p0_baseband_postamble[][5] = {
+ /* Addr      5G_HT20     5G_HT40     2G_HT40     2G_HT20   */
+ {0x00009810, 0xd00a8005, 0xd00a8005, 0xd00a8011, 0xd00a8011},
+ {0x00009820, 0x206a022e, 0x206a022e, 0x206a012e, 0x206a012e},
+ {0x00009824, 0x5ac640d0, 0x5ac640d0, 0x5ac640d0, 0x5ac640d0},
+ {0x00009828, 0x06903081, 0x06903081, 0x06903881, 0x06903881},
+ {0x0000982c, 0x05eea6d4, 0x05eea6d4, 0x05eea6d4, 0x05eea6d4},
+ {0x00009830, 0x0000059c, 0x0000059c, 0x0000119c, 0x0000119c},
+ {0x00009c00, 0x000000c4, 0x000000c4, 0x000000c4, 0x000000c4},
+ {0x00009e00, 0x0372111a, 0x0372111a, 0x037216a0, 0x037216a0},
+ {0x00009e04, 0x001c2020, 0x001c2020, 0x001c2020, 0x001c2020},
+ {0x00009e0c, 0x6c4000e2, 0x6d4000e2, 0x6d4000e2, 0x6c4000e2},
+ {0x00009e10, 0x7ec88d2e, 0x7ec88d2e, 0x7ec84d2e, 0x7ec84d2e},
+ {0x00009e14, 0x37b95d5e, 0x37b9605e, 0x3379605e, 0x33795d5e},
+ {0x00009e18, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
+ {0x00009e1c, 0x0001cf9c, 0x0001cf9c, 0x00021f9c, 0x00021f9c},
+ {0x00009e20, 0x000003b5, 0x000003b5, 0x000003ce, 0x000003ce},
+ {0x00009e2c, 0x0000001c, 0x0000001c, 0x00000021, 0x00000021},
+ {0x00009e3c, 0xcfa10820, 0xcfa10820, 0xcfa10822, 0xcfa10822},
+ {0x00009e44, 0xfe321e27, 0xfe321e27, 0xfe291e27, 0xfe291e27},
+ {0x00009e48, 0x5030201a, 0x5030201a, 0x50302012, 0x50302012},
+ {0x00009fc8, 0x0003f000, 0x0003f000, 0x0001a000, 0x0001a000},
+ {0x0000a204, 0x005c0ec0, 0x005c0ec4, 0x005c0ec4, 0x005c0ec0},
+ {0x0000a208, 0x00000104, 0x00000104, 0x00000004, 0x00000004},
+ {0x0000a22c, 0x07e26a2f, 0x07e26a2f, 0x01026a2f, 0x01026a2f},
+ {0x0000a230, 0x0000000a, 0x00000014, 0x00000016, 0x0000000b},
+ {0x0000a234, 0x00000fff, 0x10000fff, 0x10000fff, 0x00000fff},
+ {0x0000a238, 0xffb01018, 0xffb01018, 0xffb01018, 0xffb01018},
+ {0x0000a250, 0x00000000, 0x00000000, 0x00000210, 0x00000108},
+ {0x0000a254, 0x000007d0, 0x00000fa0, 0x00001130, 0x00000898},
+ {0x0000a258, 0x02020002, 0x02020002, 0x02020002, 0x02020002},
+ {0x0000a25c, 0x01000e0e, 0x01000e0e, 0x01010e0e, 0x01010e0e},
+ {0x0000a260, 0x0a021501, 0x0a021501, 0x3a021501, 0x3a021501},
+ {0x0000a264, 0x00000e0e, 0x00000e0e, 0x01000e0e, 0x01000e0e},
+ {0x0000a280, 0x00000007, 0x00000007, 0x0000000b, 0x0000000b},
+ {0x0000a284, 0x00000000, 0x00000000, 0x00000010, 0x00000010},
+ {0x0000a288, 0x00000110, 0x00000110, 0x00000110, 0x00000110},
+ {0x0000a28c, 0x00022222, 0x00022222, 0x00022222, 0x00022222},
+ {0x0000a2c4, 0x00158d18, 0x00158d18, 0x00158d18, 0x00158d18},
+ {0x0000a2cc, 0x18c50033, 0x18c43433, 0x18c41033, 0x18c44c33},
+ {0x0000a2d0, 0x00041982, 0x00041982, 0x00041982, 0x00041982},
+ {0x0000a2d8, 0x7999a83b, 0x7999a83b, 0x7999a83b, 0x7999a83b},
+ {0x0000a358, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
+ {0x0000a830, 0x0000019c, 0x0000019c, 0x0000019c, 0x0000019c},
+ {0x0000ae04, 0x001c0000, 0x001c0000, 0x001c0000, 0x001c0000},
+ {0x0000ae18, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
+ {0x0000ae1c, 0x0000019c, 0x0000019c, 0x0000019c, 0x0000019c},
+ {0x0000ae20, 0x000001b5, 0x000001b5, 0x000001ce, 0x000001ce},
+ {0x0000b284, 0x00000000, 0x00000000, 0x00000010, 0x00000010},
+};
+
+static const u32 qca953x_1p0_radio_core[][2] = {
+ /* Addr      allmodes  */
+ {0x00016000, 0x36db6db6},
+ {0x00016004, 0x6db6db40},
+ {0x00016008, 0x73f00000},
+ {0x0001600c, 0x00000000},
+ {0x00016040, 0x3f80fff8},
+ {0x0001604c, 0x000f0278},
+ {0x00016050, 0x8036db6c},
+ {0x00016054, 0x6db60000},
+ {0x00016080, 0x00080000},
+ {0x00016084, 0x0e48048c},
+ {0x00016088, 0x14214514},
+ {0x0001608c, 0x119f080a},
+ {0x00016090, 0x24926490},
+ {0x00016094, 0x00000000},
+ {0x000160a0, 0xc2108ffe},
+ {0x000160a4, 0x812fc370},
+ {0x000160a8, 0x423c8000},
+ {0x000160b4, 0x92480080},
+ {0x000160c0, 0x006db6d8},
+ {0x000160c4, 0x24b6db6c},
+ {0x000160c8, 0x6db6db6c},
+ {0x000160cc, 0x6db6fb7c},
+ {0x000160d0, 0x6db6da44},
+ {0x00016100, 0x07ff8001},
+ {0x00016108, 0x00080010},
+ {0x00016144, 0x01884080},
+ {0x00016148, 0x000080d8},
+ {0x00016280, 0x01000901},
+ {0x00016284, 0x15d30000},
+ {0x00016288, 0x00318000},
+ {0x0001628c, 0x50000000},
+ {0x00016380, 0x00000000},
+ {0x00016384, 0x00000000},
+ {0x00016388, 0x00800700},
+ {0x0001638c, 0x00800700},
+ {0x00016390, 0x00800700},
+ {0x00016394, 0x00000000},
+ {0x00016398, 0x00000000},
+ {0x0001639c, 0x00000000},
+ {0x000163a0, 0x00000001},
+ {0x000163a4, 0x00000001},
+ {0x000163a8, 0x00000000},
+ {0x000163ac, 0x00000000},
+ {0x000163b0, 0x00000000},
+ {0x000163b4, 0x00000000},
+ {0x000163b8, 0x00000000},
+ {0x000163bc, 0x00000000},
+ {0x000163c0, 0x000000a0},
+ {0x000163c4, 0x000c0000},
+ {0x000163c8, 0x14021402},
+ {0x000163cc, 0x00001402},
+ {0x000163d0, 0x00000000},
+ {0x000163d4, 0x00000000},
+ {0x00016400, 0x36db6db6},
+ {0x00016404, 0x6db6db40},
+ {0x00016408, 0x73f00000},
+ {0x0001640c, 0x00000000},
+ {0x00016440, 0x3f80fff8},
+ {0x0001644c, 0x000f0278},
+ {0x00016450, 0x8036db6c},
+ {0x00016454, 0x6db60000},
+ {0x00016500, 0x07ff8001},
+ {0x00016508, 0x00080010},
+ {0x00016544, 0x01884080},
+ {0x00016548, 0x000080d8},
+ {0x00016780, 0x00000000},
+ {0x00016784, 0x00000000},
+ {0x00016788, 0x00800700},
+ {0x0001678c, 0x00800700},
+ {0x00016790, 0x00800700},
+ {0x00016794, 0x00000000},
+ {0x00016798, 0x00000000},
+ {0x0001679c, 0x00000000},
+ {0x000167a0, 0x00000001},
+ {0x000167a4, 0x00000001},
+ {0x000167a8, 0x00000000},
+ {0x000167ac, 0x00000000},
+ {0x000167b0, 0x00000000},
+ {0x000167b4, 0x00000000},
+ {0x000167b8, 0x00000000},
+ {0x000167bc, 0x00000000},
+ {0x000167c0, 0x000000a0},
+ {0x000167c4, 0x000c0000},
+ {0x000167c8, 0x14021402},
+ {0x000167cc, 0x00001402},
+ {0x000167d0, 0x00000000},
+ {0x000167d4, 0x00000000},
+};
+
+static const u32 qca953x_1p0_radio_postamble[][5] = {
+ /* Addr      5G_HT20     5G_HT40     2G_HT40     2G_HT20   */
+ {0x00016098, 0xd2dd5554, 0xd2dd5554, 0xc4128f5c, 0xc4128f5c},
+ {0x0001609c, 0x0a566f3a, 0x0a566f3a, 0x0fd08f25, 0x0fd08f25},
+ {0x000160ac, 0xa4647c00, 0xa4647c00, 0x24646800, 0x24646800},
+ {0x000160b0, 0x01885f52, 0x01885f52, 0x00fe7f46, 0x00fe7f46},
+ {0x00016104, 0xb7a00001, 0xb7a00001, 0xfff80005, 0xfff80005},
+ {0x0001610c, 0xc0000000, 0xc0000000, 0x00000000, 0x00000000},
+ {0x00016140, 0x10804008, 0x10804008, 0x50804000, 0x50804000},
+ {0x00016504, 0xb7a00001, 0xb7a00001, 0xfff80001, 0xfff80001},
+ {0x0001650c, 0xc0000000, 0xc0000000, 0x00000000, 0x00000000},
+ {0x00016540, 0x10804008, 0x10804008, 0x50804000, 0x50804000},
+};
+
+static const u32 qca953x_1p0_soc_preamble[][2] = {
+ /* Addr      allmodes  */
+ {0x00007000, 0x00000000},
+ {0x00007004, 0x00000000},
+ {0x00007008, 0x00000000},
+ {0x0000700c, 0x00000000},
+ {0x0000701c, 0x00000000},
+ {0x00007020, 0x00000000},
+ {0x00007024, 0x00000000},
+ {0x00007028, 0x00000000},
+ {0x0000702c, 0x00000000},
+ {0x00007030, 0x00000000},
+ {0x00007034, 0x00000002},
+ {0x00007038, 0x000004c2},
+ {0x00007048, 0x00000000},
+};
+
+static const u32 qca953x_1p0_common_rx_gain_bounds[][5] = {
+ /* Addr      5G_HT20     5G_HT40     2G_HT40     2G_HT20   */
+ {0x00009e44, 0xfe321e27, 0xfe321e27, 0xfe291e27, 0xfe291e27},
+ {0x00009e48, 0x5030201a, 0x5030201a, 0x50302018, 0x50302018},
+};
+
+static const u32 qca953x_1p0_common_wo_xlna_rx_gain_bounds[][5] = {
+ /* Addr      5G_HT20     5G_HT40     2G_HT40     2G_HT20   */
+ {0x00009e44, 0xfe321e27, 0xfe321e27, 0xfe291e27, 0xfe291e27},
+ {0x00009e48, 0x5030201a, 0x5030201a, 0x50302012, 0x50302012},
+};
+
+static const u32 qca953x_1p0_modes_xpa_tx_gain_table[][2] = {
+ /* Addr      allmodes  */
+ {0x0000a2dc, 0xfffd5aaa},
+ {0x0000a2e0, 0xfffe9ccc},
+ {0x0000a2e4, 0xffffe0f0},
+ {0x0000a2e8, 0xfffcff00},
+ {0x0000a410, 0x000050da},
+ {0x0000a500, 0x00000000},
+ {0x0000a504, 0x04000002},
+ {0x0000a508, 0x08000004},
+ {0x0000a50c, 0x0c000006},
+ {0x0000a510, 0x0f00000a},
+ {0x0000a514, 0x1300000c},
+ {0x0000a518, 0x1700000e},
+ {0x0000a51c, 0x1b000064},
+ {0x0000a520, 0x1f000242},
+ {0x0000a524, 0x23000229},
+ {0x0000a528, 0x270002a2},
+ {0x0000a52c, 0x2c001203},
+ {0x0000a530, 0x30001803},
+ {0x0000a534, 0x33000881},
+ {0x0000a538, 0x38001809},
+ {0x0000a53c, 0x3a000814},
+ {0x0000a540, 0x3f001a0c},
+ {0x0000a544, 0x43001a0e},
+ {0x0000a548, 0x46001812},
+ {0x0000a54c, 0x49001884},
+ {0x0000a550, 0x4d001e84},
+ {0x0000a554, 0x50001e69},
+ {0x0000a558, 0x550006f4},
+ {0x0000a55c, 0x59000ad3},
+ {0x0000a560, 0x5e000ad5},
+ {0x0000a564, 0x61001ced},
+ {0x0000a568, 0x660018d4},
+ {0x0000a56c, 0x660018d4},
+ {0x0000a570, 0x660018d4},
+ {0x0000a574, 0x660018d4},
+ {0x0000a578, 0x660018d4},
+ {0x0000a57c, 0x660018d4},
+ {0x0000a600, 0x00000000},
+ {0x0000a604, 0x00000000},
+ {0x0000a608, 0x00000000},
+ {0x0000a60c, 0x03804000},
+ {0x0000a610, 0x0300ca02},
+ {0x0000a614, 0x00000e04},
+ {0x0000a618, 0x03014000},
+ {0x0000a61c, 0x00000000},
+ {0x0000a620, 0x00000000},
+ {0x0000a624, 0x03014000},
+ {0x0000a628, 0x03804c05},
+ {0x0000a62c, 0x0701de06},
+ {0x0000a630, 0x07819c07},
+ {0x0000a634, 0x0701dc07},
+ {0x0000a638, 0x0701dc07},
+ {0x0000a63c, 0x0701dc07},
+ {0x0000b2dc, 0xfffd5aaa},
+ {0x0000b2e0, 0xfffe9ccc},
+ {0x0000b2e4, 0xffffe0f0},
+ {0x0000b2e8, 0xfffcff00},
+ {0x00016044, 0x010002d4},
+ {0x00016048, 0x66482400},
+ {0x00016280, 0x01000015},
+ {0x00016444, 0x010002d4},
+ {0x00016448, 0x66482400},
+};
+
+static const u32 qca953x_1p0_modes_no_xpa_tx_gain_table[][2] = {
+ /* Addr      allmodes  */
+ {0x0000a2dc, 0xffd5f552},
+ {0x0000a2e0, 0xffe60664},
+ {0x0000a2e4, 0xfff80780},
+ {0x0000a2e8, 0xfffff800},
+ {0x0000a410, 0x000050d6},
+ {0x0000a500, 0x00060020},
+ {0x0000a504, 0x04060060},
+ {0x0000a508, 0x080600a0},
+ {0x0000a50c, 0x0c068020},
+ {0x0000a510, 0x10068060},
+ {0x0000a514, 0x140680a0},
+ {0x0000a518, 0x18090040},
+ {0x0000a51c, 0x1b090080},
+ {0x0000a520, 0x1f0900c0},
+ {0x0000a524, 0x240c0041},
+ {0x0000a528, 0x280d0021},
+ {0x0000a52c, 0x2d0f0061},
+ {0x0000a530, 0x310f00a1},
+ {0x0000a534, 0x350e00a2},
+ {0x0000a538, 0x360e80a2},
+ {0x0000a53c, 0x380f00a2},
+ {0x0000a540, 0x3b0e00a3},
+ {0x0000a544, 0x3d110083},
+ {0x0000a548, 0x3e1100a3},
+ {0x0000a54c, 0x401100e3},
+ {0x0000a550, 0x421380e3},
+ {0x0000a554, 0x431780e3},
+ {0x0000a558, 0x461f80e3},
+ {0x0000a55c, 0x461f80e3},
+ {0x0000a560, 0x461f80e3},
+ {0x0000a564, 0x461f80e3},
+ {0x0000a568, 0x461f80e3},
+ {0x0000a56c, 0x461f80e3},
+ {0x0000a570, 0x461f80e3},
+ {0x0000a574, 0x461f80e3},
+ {0x0000a578, 0x461f80e3},
+ {0x0000a57c, 0x461f80e3},
+ {0x0000a600, 0x00000000},
+ {0x0000a604, 0x00000000},
+ {0x0000a608, 0x00000000},
+ {0x0000a60c, 0x00804201},
+ {0x0000a610, 0x01008201},
+ {0x0000a614, 0x0180c402},
+ {0x0000a618, 0x0180c603},
+ {0x0000a61c, 0x0180c603},
+ {0x0000a620, 0x01c10603},
+ {0x0000a624, 0x01c10704},
+ {0x0000a628, 0x02c18b05},
+ {0x0000a62c, 0x0301cc07},
+ {0x0000a630, 0x0301cc07},
+ {0x0000a634, 0x0301cc07},
+ {0x0000a638, 0x0301cc07},
+ {0x0000a63c, 0x0301cc07},
+ {0x0000b2dc, 0xffd5f552},
+ {0x0000b2e0, 0xffe60664},
+ {0x0000b2e4, 0xfff80780},
+ {0x0000b2e8, 0xfffff800},
+ {0x00016044, 0x049242db},
+ {0x00016048, 0x6c927a70},
+ {0x00016444, 0x049242db},
+ {0x00016448, 0x6c927a70},
+};
+
+static const u32 qca953x_1p1_modes_no_xpa_tx_gain_table[][2] = {
+ /* Addr      allmodes  */
+ {0x0000a2dc, 0xffd5f552},
+ {0x0000a2e0, 0xffe60664},
+ {0x0000a2e4, 0xfff80780},
+ {0x0000a2e8, 0xfffff800},
+ {0x0000a410, 0x000050de},
+ {0x0000a500, 0x00000061},
+ {0x0000a504, 0x04000063},
+ {0x0000a508, 0x08000065},
+ {0x0000a50c, 0x0c000261},
+ {0x0000a510, 0x10000263},
+ {0x0000a514, 0x14000265},
+ {0x0000a518, 0x18000482},
+ {0x0000a51c, 0x1b000484},
+ {0x0000a520, 0x1f000486},
+ {0x0000a524, 0x240008c2},
+ {0x0000a528, 0x28000cc1},
+ {0x0000a52c, 0x2d000ce3},
+ {0x0000a530, 0x31000ce5},
+ {0x0000a534, 0x350010e5},
+ {0x0000a538, 0x360012e5},
+ {0x0000a53c, 0x380014e5},
+ {0x0000a540, 0x3b0018e5},
+ {0x0000a544, 0x3d001d04},
+ {0x0000a548, 0x3e001d05},
+ {0x0000a54c, 0x40001d07},
+ {0x0000a550, 0x42001f27},
+ {0x0000a554, 0x43001f67},
+ {0x0000a558, 0x46001fe7},
+ {0x0000a55c, 0x47001f2b},
+ {0x0000a560, 0x49001f0d},
+ {0x0000a564, 0x4b001ed2},
+ {0x0000a568, 0x4c001ed4},
+ {0x0000a56c, 0x4e001f15},
+ {0x0000a570, 0x4f001ff6},
+ {0x0000a574, 0x4f001ff6},
+ {0x0000a578, 0x4f001ff6},
+ {0x0000a57c, 0x4f001ff6},
+ {0x0000a600, 0x00000000},
+ {0x0000a604, 0x00000000},
+ {0x0000a608, 0x00000000},
+ {0x0000a60c, 0x00804201},
+ {0x0000a610, 0x01008201},
+ {0x0000a614, 0x0180c402},
+ {0x0000a618, 0x0180c603},
+ {0x0000a61c, 0x0180c603},
+ {0x0000a620, 0x01c10603},
+ {0x0000a624, 0x01c10704},
+ {0x0000a628, 0x02c18b05},
+ {0x0000a62c, 0x02c14c07},
+ {0x0000a630, 0x01008704},
+ {0x0000a634, 0x01c10402},
+ {0x0000a638, 0x0301cc07},
+ {0x0000a63c, 0x0301cc07},
+ {0x0000b2dc, 0xffd5f552},
+ {0x0000b2e0, 0xffe60664},
+ {0x0000b2e4, 0xfff80780},
+ {0x0000b2e8, 0xfffff800},
+ {0x00016044, 0x049242db},
+ {0x00016048, 0x6c927a70},
+ {0x00016444, 0x049242db},
+ {0x00016448, 0x6c927a70},
+};
+
+#endif /* INITVALS_953X_H */
diff --git a/drivers/net/wireless/ath/ath9k/ar955x_1p0_initvals.h b/drivers/net/wireless/ath/ath9k/ar955x_1p0_initvals.h
index ccc5b6c..74d8bc0 100644
--- a/drivers/net/wireless/ath/ath9k/ar955x_1p0_initvals.h
+++ b/drivers/net/wireless/ath/ath9k/ar955x_1p0_initvals.h
@@ -20,6 +20,14 @@
 
 /* AR955X 1.0 */
 
+#define ar955x_1p0_soc_postamble ar9300_2p2_soc_postamble
+
+#define ar955x_1p0_common_rx_gain_table ar9300Common_rx_gain_table_2p2
+
+#define ar955x_1p0_common_wo_xlna_rx_gain_table ar9300Common_wo_xlna_rx_gain_table_2p2
+
+#define ar955x_1p0_baseband_core_txfir_coeff_japan_2484 ar9300_2p2_baseband_core_txfir_coeff_japan_2484
+
 static const u32 ar955x_1p0_radio_postamble[][5] = {
  /* Addr      5G_HT20     5G_HT40     2G_HT40     2G_HT20   */
  {0x00016098, 0xd2dd5554, 0xd2dd5554, 0xd28b3330, 0xd28b3330},
@@ -37,13 +45,6 @@ static const u32 ar955x_1p0_radio_postamble[][5] = {
  {0x00016940, 0x10804008, 0x10804008, 0x10804008, 0x10804008},
 };
 
-static const u32 ar955x_1p0_baseband_core_txfir_coeff_japan_2484[][2] = {
- /* Addr      allmodes  */
- {0x0000a398, 0x00000000},
- {0x0000a39c, 0x6f7f0301},
- {0x0000a3a0, 0xca9228ee},
-};
-
 static const u32 ar955x_1p0_baseband_postamble[][5] = {
  /* Addr      5G_HT20     5G_HT40     2G_HT40     2G_HT20   */
  {0x00009810, 0xd00a8005, 0xd00a8005, 0xd00a8011, 0xd00a8011},
@@ -473,266 +474,6 @@ static const u32 ar955x_1p0_mac_core[][2] = {
  {0x000083d0, 0x8c7901ff},
 };
 
-static const u32 ar955x_1p0_common_rx_gain_table[][2] = {
- /* Addr      allmodes  */
- {0x0000a000, 0x00010000},
- {0x0000a004, 0x00030002},
- {0x0000a008, 0x00050004},
- {0x0000a00c, 0x00810080},
- {0x0000a010, 0x00830082},
- {0x0000a014, 0x01810180},
- {0x0000a018, 0x01830182},
- {0x0000a01c, 0x01850184},
- {0x0000a020, 0x01890188},
- {0x0000a024, 0x018b018a},
- {0x0000a028, 0x018d018c},
- {0x0000a02c, 0x01910190},
- {0x0000a030, 0x01930192},
- {0x0000a034, 0x01950194},
- {0x0000a038, 0x038a0196},
- {0x0000a03c, 0x038c038b},
- {0x0000a040, 0x0390038d},
- {0x0000a044, 0x03920391},
- {0x0000a048, 0x03940393},
- {0x0000a04c, 0x03960395},
- {0x0000a050, 0x00000000},
- {0x0000a054, 0x00000000},
- {0x0000a058, 0x00000000},
- {0x0000a05c, 0x00000000},
- {0x0000a060, 0x00000000},
- {0x0000a064, 0x00000000},
- {0x0000a068, 0x00000000},
- {0x0000a06c, 0x00000000},
- {0x0000a070, 0x00000000},
- {0x0000a074, 0x00000000},
- {0x0000a078, 0x00000000},
- {0x0000a07c, 0x00000000},
- {0x0000a080, 0x22222229},
- {0x0000a084, 0x1d1d1d1d},
- {0x0000a088, 0x1d1d1d1d},
- {0x0000a08c, 0x1d1d1d1d},
- {0x0000a090, 0x171d1d1d},
- {0x0000a094, 0x11111717},
- {0x0000a098, 0x00030311},
- {0x0000a09c, 0x00000000},
- {0x0000a0a0, 0x00000000},
- {0x0000a0a4, 0x00000000},
- {0x0000a0a8, 0x00000000},
- {0x0000a0ac, 0x00000000},
- {0x0000a0b0, 0x00000000},
- {0x0000a0b4, 0x00000000},
- {0x0000a0b8, 0x00000000},
- {0x0000a0bc, 0x00000000},
- {0x0000a0c0, 0x001f0000},
- {0x0000a0c4, 0x01000101},
- {0x0000a0c8, 0x011e011f},
- {0x0000a0cc, 0x011c011d},
- {0x0000a0d0, 0x02030204},
- {0x0000a0d4, 0x02010202},
- {0x0000a0d8, 0x021f0200},
- {0x0000a0dc, 0x0302021e},
- {0x0000a0e0, 0x03000301},
- {0x0000a0e4, 0x031e031f},
- {0x0000a0e8, 0x0402031d},
- {0x0000a0ec, 0x04000401},
- {0x0000a0f0, 0x041e041f},
- {0x0000a0f4, 0x0502041d},
- {0x0000a0f8, 0x05000501},
- {0x0000a0fc, 0x051e051f},
- {0x0000a100, 0x06010602},
- {0x0000a104, 0x061f0600},
- {0x0000a108, 0x061d061e},
- {0x0000a10c, 0x07020703},
- {0x0000a110, 0x07000701},
- {0x0000a114, 0x00000000},
- {0x0000a118, 0x00000000},
- {0x0000a11c, 0x00000000},
- {0x0000a120, 0x00000000},
- {0x0000a124, 0x00000000},
- {0x0000a128, 0x00000000},
- {0x0000a12c, 0x00000000},
- {0x0000a130, 0x00000000},
- {0x0000a134, 0x00000000},
- {0x0000a138, 0x00000000},
- {0x0000a13c, 0x00000000},
- {0x0000a140, 0x001f0000},
- {0x0000a144, 0x01000101},
- {0x0000a148, 0x011e011f},
- {0x0000a14c, 0x011c011d},
- {0x0000a150, 0x02030204},
- {0x0000a154, 0x02010202},
- {0x0000a158, 0x021f0200},
- {0x0000a15c, 0x0302021e},
- {0x0000a160, 0x03000301},
- {0x0000a164, 0x031e031f},
- {0x0000a168, 0x0402031d},
- {0x0000a16c, 0x04000401},
- {0x0000a170, 0x041e041f},
- {0x0000a174, 0x0502041d},
- {0x0000a178, 0x05000501},
- {0x0000a17c, 0x051e051f},
- {0x0000a180, 0x06010602},
- {0x0000a184, 0x061f0600},
- {0x0000a188, 0x061d061e},
- {0x0000a18c, 0x07020703},
- {0x0000a190, 0x07000701},
- {0x0000a194, 0x00000000},
- {0x0000a198, 0x00000000},
- {0x0000a19c, 0x00000000},
- {0x0000a1a0, 0x00000000},
- {0x0000a1a4, 0x00000000},
- {0x0000a1a8, 0x00000000},
- {0x0000a1ac, 0x00000000},
- {0x0000a1b0, 0x00000000},
- {0x0000a1b4, 0x00000000},
- {0x0000a1b8, 0x00000000},
- {0x0000a1bc, 0x00000000},
- {0x0000a1c0, 0x00000000},
- {0x0000a1c4, 0x00000000},
- {0x0000a1c8, 0x00000000},
- {0x0000a1cc, 0x00000000},
- {0x0000a1d0, 0x00000000},
- {0x0000a1d4, 0x00000000},
- {0x0000a1d8, 0x00000000},
- {0x0000a1dc, 0x00000000},
- {0x0000a1e0, 0x00000000},
- {0x0000a1e4, 0x00000000},
- {0x0000a1e8, 0x00000000},
- {0x0000a1ec, 0x00000000},
- {0x0000a1f0, 0x00000396},
- {0x0000a1f4, 0x00000396},
- {0x0000a1f8, 0x00000396},
- {0x0000a1fc, 0x00000196},
- {0x0000b000, 0x00010000},
- {0x0000b004, 0x00030002},
- {0x0000b008, 0x00050004},
- {0x0000b00c, 0x00810080},
- {0x0000b010, 0x00830082},
- {0x0000b014, 0x01810180},
- {0x0000b018, 0x01830182},
- {0x0000b01c, 0x01850184},
- {0x0000b020, 0x02810280},
- {0x0000b024, 0x02830282},
- {0x0000b028, 0x02850284},
- {0x0000b02c, 0x02890288},
- {0x0000b030, 0x028b028a},
- {0x0000b034, 0x0388028c},
- {0x0000b038, 0x038a0389},
- {0x0000b03c, 0x038c038b},
- {0x0000b040, 0x0390038d},
- {0x0000b044, 0x03920391},
- {0x0000b048, 0x03940393},
- {0x0000b04c, 0x03960395},
- {0x0000b050, 0x00000000},
- {0x0000b054, 0x00000000},
- {0x0000b058, 0x00000000},
- {0x0000b05c, 0x00000000},
- {0x0000b060, 0x00000000},
- {0x0000b064, 0x00000000},
- {0x0000b068, 0x00000000},
- {0x0000b06c, 0x00000000},
- {0x0000b070, 0x00000000},
- {0x0000b074, 0x00000000},
- {0x0000b078, 0x00000000},
- {0x0000b07c, 0x00000000},
- {0x0000b080, 0x23232323},
- {0x0000b084, 0x21232323},
- {0x0000b088, 0x19191c1e},
- {0x0000b08c, 0x12141417},
- {0x0000b090, 0x07070e0e},
- {0x0000b094, 0x03030305},
- {0x0000b098, 0x00000003},
- {0x0000b09c, 0x00000000},
- {0x0000b0a0, 0x00000000},
- {0x0000b0a4, 0x00000000},
- {0x0000b0a8, 0x00000000},
- {0x0000b0ac, 0x00000000},
- {0x0000b0b0, 0x00000000},
- {0x0000b0b4, 0x00000000},
- {0x0000b0b8, 0x00000000},
- {0x0000b0bc, 0x00000000},
- {0x0000b0c0, 0x003f0020},
- {0x0000b0c4, 0x00400041},
- {0x0000b0c8, 0x0140005f},
- {0x0000b0cc, 0x0160015f},
- {0x0000b0d0, 0x017e017f},
- {0x0000b0d4, 0x02410242},
- {0x0000b0d8, 0x025f0240},
- {0x0000b0dc, 0x027f0260},
- {0x0000b0e0, 0x0341027e},
- {0x0000b0e4, 0x035f0340},
- {0x0000b0e8, 0x037f0360},
- {0x0000b0ec, 0x04400441},
- {0x0000b0f0, 0x0460045f},
- {0x0000b0f4, 0x0541047f},
- {0x0000b0f8, 0x055f0540},
- {0x0000b0fc, 0x057f0560},
- {0x0000b100, 0x06400641},
- {0x0000b104, 0x0660065f},
- {0x0000b108, 0x067e067f},
- {0x0000b10c, 0x07410742},
- {0x0000b110, 0x075f0740},
- {0x0000b114, 0x077f0760},
- {0x0000b118, 0x07800781},
- {0x0000b11c, 0x07a0079f},
- {0x0000b120, 0x07c107bf},
- {0x0000b124, 0x000007c0},
- {0x0000b128, 0x00000000},
- {0x0000b12c, 0x00000000},
- {0x0000b130, 0x00000000},
- {0x0000b134, 0x00000000},
- {0x0000b138, 0x00000000},
- {0x0000b13c, 0x00000000},
- {0x0000b140, 0x003f0020},
- {0x0000b144, 0x00400041},
- {0x0000b148, 0x0140005f},
- {0x0000b14c, 0x0160015f},
- {0x0000b150, 0x017e017f},
- {0x0000b154, 0x02410242},
- {0x0000b158, 0x025f0240},
- {0x0000b15c, 0x027f0260},
- {0x0000b160, 0x0341027e},
- {0x0000b164, 0x035f0340},
- {0x0000b168, 0x037f0360},
- {0x0000b16c, 0x04400441},
- {0x0000b170, 0x0460045f},
- {0x0000b174, 0x0541047f},
- {0x0000b178, 0x055f0540},
- {0x0000b17c, 0x057f0560},
- {0x0000b180, 0x06400641},
- {0x0000b184, 0x0660065f},
- {0x0000b188, 0x067e067f},
- {0x0000b18c, 0x07410742},
- {0x0000b190, 0x075f0740},
- {0x0000b194, 0x077f0760},
- {0x0000b198, 0x07800781},
- {0x0000b19c, 0x07a0079f},
- {0x0000b1a0, 0x07c107bf},
- {0x0000b1a4, 0x000007c0},
- {0x0000b1a8, 0x00000000},
- {0x0000b1ac, 0x00000000},
- {0x0000b1b0, 0x00000000},
- {0x0000b1b4, 0x00000000},
- {0x0000b1b8, 0x00000000},
- {0x0000b1bc, 0x00000000},
- {0x0000b1c0, 0x00000000},
- {0x0000b1c4, 0x00000000},
- {0x0000b1c8, 0x00000000},
- {0x0000b1cc, 0x00000000},
- {0x0000b1d0, 0x00000000},
- {0x0000b1d4, 0x00000000},
- {0x0000b1d8, 0x00000000},
- {0x0000b1dc, 0x00000000},
- {0x0000b1e0, 0x00000000},
- {0x0000b1e4, 0x00000000},
- {0x0000b1e8, 0x00000000},
- {0x0000b1ec, 0x00000000},
- {0x0000b1f0, 0x00000396},
- {0x0000b1f4, 0x00000396},
- {0x0000b1f8, 0x00000396},
- {0x0000b1fc, 0x00000196},
-};
-
 static const u32 ar955x_1p0_baseband_core[][2] = {
  /* Addr      allmodes  */
  {0x00009800, 0xafe68e30},
@@ -891,266 +632,6 @@ static const u32 ar955x_1p0_baseband_core[][2] = {
  {0x0000c420, 0x00000000},
 };
 
-static const u32 ar955x_1p0_common_wo_xlna_rx_gain_table[][2] = {
- /* Addr      allmodes  */
- {0x0000a000, 0x00010000},
- {0x0000a004, 0x00030002},
- {0x0000a008, 0x00050004},
- {0x0000a00c, 0x00810080},
- {0x0000a010, 0x00830082},
- {0x0000a014, 0x01810180},
- {0x0000a018, 0x01830182},
- {0x0000a01c, 0x01850184},
- {0x0000a020, 0x01890188},
- {0x0000a024, 0x018b018a},
- {0x0000a028, 0x018d018c},
- {0x0000a02c, 0x03820190},
- {0x0000a030, 0x03840383},
- {0x0000a034, 0x03880385},
- {0x0000a038, 0x038a0389},
- {0x0000a03c, 0x038c038b},
- {0x0000a040, 0x0390038d},
- {0x0000a044, 0x03920391},
- {0x0000a048, 0x03940393},
- {0x0000a04c, 0x03960395},
- {0x0000a050, 0x00000000},
- {0x0000a054, 0x00000000},
- {0x0000a058, 0x00000000},
- {0x0000a05c, 0x00000000},
- {0x0000a060, 0x00000000},
- {0x0000a064, 0x00000000},
- {0x0000a068, 0x00000000},
- {0x0000a06c, 0x00000000},
- {0x0000a070, 0x00000000},
- {0x0000a074, 0x00000000},
- {0x0000a078, 0x00000000},
- {0x0000a07c, 0x00000000},
- {0x0000a080, 0x29292929},
- {0x0000a084, 0x29292929},
- {0x0000a088, 0x29292929},
- {0x0000a08c, 0x29292929},
- {0x0000a090, 0x22292929},
- {0x0000a094, 0x1d1d2222},
- {0x0000a098, 0x0c111117},
- {0x0000a09c, 0x00030303},
- {0x0000a0a0, 0x00000000},
- {0x0000a0a4, 0x00000000},
- {0x0000a0a8, 0x00000000},
- {0x0000a0ac, 0x00000000},
- {0x0000a0b0, 0x00000000},
- {0x0000a0b4, 0x00000000},
- {0x0000a0b8, 0x00000000},
- {0x0000a0bc, 0x00000000},
- {0x0000a0c0, 0x001f0000},
- {0x0000a0c4, 0x01000101},
- {0x0000a0c8, 0x011e011f},
- {0x0000a0cc, 0x011c011d},
- {0x0000a0d0, 0x02030204},
- {0x0000a0d4, 0x02010202},
- {0x0000a0d8, 0x021f0200},
- {0x0000a0dc, 0x0302021e},
- {0x0000a0e0, 0x03000301},
- {0x0000a0e4, 0x031e031f},
- {0x0000a0e8, 0x0402031d},
- {0x0000a0ec, 0x04000401},
- {0x0000a0f0, 0x041e041f},
- {0x0000a0f4, 0x0502041d},
- {0x0000a0f8, 0x05000501},
- {0x0000a0fc, 0x051e051f},
- {0x0000a100, 0x06010602},
- {0x0000a104, 0x061f0600},
- {0x0000a108, 0x061d061e},
- {0x0000a10c, 0x07020703},
- {0x0000a110, 0x07000701},
- {0x0000a114, 0x00000000},
- {0x0000a118, 0x00000000},
- {0x0000a11c, 0x00000000},
- {0x0000a120, 0x00000000},
- {0x0000a124, 0x00000000},
- {0x0000a128, 0x00000000},
- {0x0000a12c, 0x00000000},
- {0x0000a130, 0x00000000},
- {0x0000a134, 0x00000000},
- {0x0000a138, 0x00000000},
- {0x0000a13c, 0x00000000},
- {0x0000a140, 0x001f0000},
- {0x0000a144, 0x01000101},
- {0x0000a148, 0x011e011f},
- {0x0000a14c, 0x011c011d},
- {0x0000a150, 0x02030204},
- {0x0000a154, 0x02010202},
- {0x0000a158, 0x021f0200},
- {0x0000a15c, 0x0302021e},
- {0x0000a160, 0x03000301},
- {0x0000a164, 0x031e031f},
- {0x0000a168, 0x0402031d},
- {0x0000a16c, 0x04000401},
- {0x0000a170, 0x041e041f},
- {0x0000a174, 0x0502041d},
- {0x0000a178, 0x05000501},
- {0x0000a17c, 0x051e051f},
- {0x0000a180, 0x06010602},
- {0x0000a184, 0x061f0600},
- {0x0000a188, 0x061d061e},
- {0x0000a18c, 0x07020703},
- {0x0000a190, 0x07000701},
- {0x0000a194, 0x00000000},
- {0x0000a198, 0x00000000},
- {0x0000a19c, 0x00000000},
- {0x0000a1a0, 0x00000000},
- {0x0000a1a4, 0x00000000},
- {0x0000a1a8, 0x00000000},
- {0x0000a1ac, 0x00000000},
- {0x0000a1b0, 0x00000000},
- {0x0000a1b4, 0x00000000},
- {0x0000a1b8, 0x00000000},
- {0x0000a1bc, 0x00000000},
- {0x0000a1c0, 0x00000000},
- {0x0000a1c4, 0x00000000},
- {0x0000a1c8, 0x00000000},
- {0x0000a1cc, 0x00000000},
- {0x0000a1d0, 0x00000000},
- {0x0000a1d4, 0x00000000},
- {0x0000a1d8, 0x00000000},
- {0x0000a1dc, 0x00000000},
- {0x0000a1e0, 0x00000000},
- {0x0000a1e4, 0x00000000},
- {0x0000a1e8, 0x00000000},
- {0x0000a1ec, 0x00000000},
- {0x0000a1f0, 0x00000396},
- {0x0000a1f4, 0x00000396},
- {0x0000a1f8, 0x00000396},
- {0x0000a1fc, 0x00000196},
- {0x0000b000, 0x00010000},
- {0x0000b004, 0x00030002},
- {0x0000b008, 0x00050004},
- {0x0000b00c, 0x00810080},
- {0x0000b010, 0x00830082},
- {0x0000b014, 0x01810180},
- {0x0000b018, 0x01830182},
- {0x0000b01c, 0x01850184},
- {0x0000b020, 0x02810280},
- {0x0000b024, 0x02830282},
- {0x0000b028, 0x02850284},
- {0x0000b02c, 0x02890288},
- {0x0000b030, 0x028b028a},
- {0x0000b034, 0x0388028c},
- {0x0000b038, 0x038a0389},
- {0x0000b03c, 0x038c038b},
- {0x0000b040, 0x0390038d},
- {0x0000b044, 0x03920391},
- {0x0000b048, 0x03940393},
- {0x0000b04c, 0x03960395},
- {0x0000b050, 0x00000000},
- {0x0000b054, 0x00000000},
- {0x0000b058, 0x00000000},
- {0x0000b05c, 0x00000000},
- {0x0000b060, 0x00000000},
- {0x0000b064, 0x00000000},
- {0x0000b068, 0x00000000},
- {0x0000b06c, 0x00000000},
- {0x0000b070, 0x00000000},
- {0x0000b074, 0x00000000},
- {0x0000b078, 0x00000000},
- {0x0000b07c, 0x00000000},
- {0x0000b080, 0x32323232},
- {0x0000b084, 0x2f2f3232},
- {0x0000b088, 0x23282a2d},
- {0x0000b08c, 0x1c1e2123},
- {0x0000b090, 0x14171919},
- {0x0000b094, 0x0e0e1214},
- {0x0000b098, 0x03050707},
- {0x0000b09c, 0x00030303},
- {0x0000b0a0, 0x00000000},
- {0x0000b0a4, 0x00000000},
- {0x0000b0a8, 0x00000000},
- {0x0000b0ac, 0x00000000},
- {0x0000b0b0, 0x00000000},
- {0x0000b0b4, 0x00000000},
- {0x0000b0b8, 0x00000000},
- {0x0000b0bc, 0x00000000},
- {0x0000b0c0, 0x003f0020},
- {0x0000b0c4, 0x00400041},
- {0x0000b0c8, 0x0140005f},
- {0x0000b0cc, 0x0160015f},
- {0x0000b0d0, 0x017e017f},
- {0x0000b0d4, 0x02410242},
- {0x0000b0d8, 0x025f0240},
- {0x0000b0dc, 0x027f0260},
- {0x0000b0e0, 0x0341027e},
- {0x0000b0e4, 0x035f0340},
- {0x0000b0e8, 0x037f0360},
- {0x0000b0ec, 0x04400441},
- {0x0000b0f0, 0x0460045f},
- {0x0000b0f4, 0x0541047f},
- {0x0000b0f8, 0x055f0540},
- {0x0000b0fc, 0x057f0560},
- {0x0000b100, 0x06400641},
- {0x0000b104, 0x0660065f},
- {0x0000b108, 0x067e067f},
- {0x0000b10c, 0x07410742},
- {0x0000b110, 0x075f0740},
- {0x0000b114, 0x077f0760},
- {0x0000b118, 0x07800781},
- {0x0000b11c, 0x07a0079f},
- {0x0000b120, 0x07c107bf},
- {0x0000b124, 0x000007c0},
- {0x0000b128, 0x00000000},
- {0x0000b12c, 0x00000000},
- {0x0000b130, 0x00000000},
- {0x0000b134, 0x00000000},
- {0x0000b138, 0x00000000},
- {0x0000b13c, 0x00000000},
- {0x0000b140, 0x003f0020},
- {0x0000b144, 0x00400041},
- {0x0000b148, 0x0140005f},
- {0x0000b14c, 0x0160015f},
- {0x0000b150, 0x017e017f},
- {0x0000b154, 0x02410242},
- {0x0000b158, 0x025f0240},
- {0x0000b15c, 0x027f0260},
- {0x0000b160, 0x0341027e},
- {0x0000b164, 0x035f0340},
- {0x0000b168, 0x037f0360},
- {0x0000b16c, 0x04400441},
- {0x0000b170, 0x0460045f},
- {0x0000b174, 0x0541047f},
- {0x0000b178, 0x055f0540},
- {0x0000b17c, 0x057f0560},
- {0x0000b180, 0x06400641},
- {0x0000b184, 0x0660065f},
- {0x0000b188, 0x067e067f},
- {0x0000b18c, 0x07410742},
- {0x0000b190, 0x075f0740},
- {0x0000b194, 0x077f0760},
- {0x0000b198, 0x07800781},
- {0x0000b19c, 0x07a0079f},
- {0x0000b1a0, 0x07c107bf},
- {0x0000b1a4, 0x000007c0},
- {0x0000b1a8, 0x00000000},
- {0x0000b1ac, 0x00000000},
- {0x0000b1b0, 0x00000000},
- {0x0000b1b4, 0x00000000},
- {0x0000b1b8, 0x00000000},
- {0x0000b1bc, 0x00000000},
- {0x0000b1c0, 0x00000000},
- {0x0000b1c4, 0x00000000},
- {0x0000b1c8, 0x00000000},
- {0x0000b1cc, 0x00000000},
- {0x0000b1d0, 0x00000000},
- {0x0000b1d4, 0x00000000},
- {0x0000b1d8, 0x00000000},
- {0x0000b1dc, 0x00000000},
- {0x0000b1e0, 0x00000000},
- {0x0000b1e4, 0x00000000},
- {0x0000b1e8, 0x00000000},
- {0x0000b1ec, 0x00000000},
- {0x0000b1f0, 0x00000396},
- {0x0000b1f4, 0x00000396},
- {0x0000b1f8, 0x00000396},
- {0x0000b1fc, 0x00000196},
-};
-
 static const u32 ar955x_1p0_soc_preamble[][2] = {
  /* Addr      allmodes  */
  {0x00007000, 0x00000000},
@@ -1263,11 +744,6 @@ static const u32 ar955x_1p0_modes_no_xpa_tx_gain_table[][9] = {
  {0x00016848, 0x66482401, 0x66482401, 0x66482401, 0x66482401, 0x66482401, 0x66482401, 0x66482401, 0x66482401},
 };
 
-static const u32 ar955x_1p0_soc_postamble[][5] = {
- /* Addr      5G_HT20     5G_HT40     2G_HT40     2G_HT20   */
- {0x00007010, 0x00000023, 0x00000023, 0x00000023, 0x00000023},
-};
-
 static const u32 ar955x_1p0_modes_fast_clock[][3] = {
  /* Addr      5G_HT20     5G_HT40   */
  {0x00001030, 0x00000268, 0x000004d0},
diff --git a/drivers/net/wireless/ath/ath9k/ar9565_1p0_initvals.h b/drivers/net/wireless/ath/ath9k/ar9565_1p0_initvals.h
index e85a8b0..10d4a6c 100644
--- a/drivers/net/wireless/ath/ath9k/ar9565_1p0_initvals.h
+++ b/drivers/net/wireless/ath/ath9k/ar9565_1p0_initvals.h
@@ -20,6 +20,12 @@
 
 /* AR9565 1.0 */
 
+#define ar9565_1p0_mac_postamble ar9331_1p1_mac_postamble
+
+#define ar9565_1p0_Modes_lowest_ob_db_tx_gain_table ar9565_1p0_modes_low_ob_db_tx_gain_table
+
+#define ar9565_1p0_baseband_core_txfir_coeff_japan_2484 ar9300_2p2_baseband_core_txfir_coeff_japan_2484
+
 static const u32 ar9565_1p0_mac_core[][2] = {
  /* Addr      allmodes  */
  {0x00000008, 0x00000000},
@@ -182,18 +188,6 @@ static const u32 ar9565_1p0_mac_core[][2] = {
  {0x000083d0, 0x800301ff},
 };
 
-static const u32 ar9565_1p0_mac_postamble[][5] = {
- /* Addr      5G_HT20     5G_HT40     2G_HT40     2G_HT20   */
- {0x00001030, 0x00000230, 0x00000460, 0x000002c0, 0x00000160},
- {0x00001070, 0x00000168, 0x000002d0, 0x00000318, 0x0000018c},
- {0x000010b0, 0x00000e60, 0x00001cc0, 0x00007c70, 0x00003e38},
- {0x00008014, 0x03e803e8, 0x07d007d0, 0x10801600, 0x08400b00},
- {0x0000801c, 0x128d8027, 0x128d804f, 0x12e00057, 0x12e0002b},
- {0x00008120, 0x08f04800, 0x08f04800, 0x08f04810, 0x08f04810},
- {0x000081d0, 0x00003210, 0x00003210, 0x0000320a, 0x0000320a},
- {0x00008318, 0x00003e80, 0x00007d00, 0x00006880, 0x00003440},
-};
-
 static const u32 ar9565_1p0_baseband_core[][2] = {
  /* Addr      allmodes  */
  {0x00009800, 0xafe68e30},
@@ -272,9 +266,9 @@ static const u32 ar9565_1p0_baseband_core[][2] = {
  {0x0000a398, 0x001f0e0f},
  {0x0000a39c, 0x0075393f},
  {0x0000a3a0, 0xb79f6427},
- {0x0000a3a4, 0x00000000},
- {0x0000a3a8, 0xaaaaaaaa},
- {0x0000a3ac, 0x3c466478},
+ {0x0000a3a4, 0x00000011},
+ {0x0000a3a8, 0xaaaaaa6e},
+ {0x0000a3ac, 0x3c466455},
  {0x0000a3c0, 0x20202020},
  {0x0000a3c4, 0x22222220},
  {0x0000a3c8, 0x20200020},
@@ -295,11 +289,11 @@ static const u32 ar9565_1p0_baseband_core[][2] = {
  {0x0000a404, 0x00000000},
  {0x0000a408, 0x0e79e5c6},
  {0x0000a40c, 0x00820820},
- {0x0000a414, 0x1ce739ce},
+ {0x0000a414, 0x1ce739c5},
  {0x0000a418, 0x2d001dce},
- {0x0000a41c, 0x1ce739ce},
+ {0x0000a41c, 0x1ce739c5},
  {0x0000a420, 0x000001ce},
- {0x0000a424, 0x1ce739ce},
+ {0x0000a424, 0x1ce739c5},
  {0x0000a428, 0x000001ce},
  {0x0000a42c, 0x1ce739ce},
  {0x0000a430, 0x1ce739ce},
@@ -351,9 +345,9 @@ static const u32 ar9565_1p0_baseband_postamble[][5] = {
  {0x00009e14, 0x37b95d5e, 0x37b9605e, 0x3379605e, 0x33795d5e},
  {0x00009e18, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
  {0x00009e1c, 0x0001cf9c, 0x0001cf9c, 0x00021f9c, 0x00021f9c},
- {0x00009e20, 0x000003b5, 0x000003b5, 0x000003ce, 0x000003ce},
+ {0x00009e20, 0x000003b5, 0x000003b5, 0x000003a4, 0x000003a4},
  {0x00009e2c, 0x0000001c, 0x0000001c, 0x00000021, 0x00000021},
- {0x00009e3c, 0xcf946222, 0xcf946222, 0xcf946222, 0xcf946222},
+ {0x00009e3c, 0xcf946222, 0xcf946222, 0xcf946220, 0xcf946220},
  {0x00009e44, 0xfe321e27, 0xfe321e27, 0xfe291e27, 0xfe291e27},
  {0x00009e48, 0x5030201a, 0x5030201a, 0x50302012, 0x50302012},
  {0x00009fc8, 0x0003f000, 0x0003f000, 0x0001a000, 0x0001a000},
@@ -452,6 +446,7 @@ static const u32 ar9565_1p0_Common_rx_gain_table[][2] = {
  /* Addr      allmodes  */
  {0x00004050, 0x00300300},
  {0x0000406c, 0x00100000},
+ {0x00009e20, 0x000003b6},
  {0x0000a000, 0x00010000},
  {0x0000a004, 0x00030002},
  {0x0000a008, 0x00050004},
@@ -710,66 +705,6 @@ static const u32 ar9565_1p0_Common_rx_gain_table[][2] = {
  {0x0000b1fc, 0x00000196},
 };
 
-static const u32 ar9565_1p0_Modes_lowest_ob_db_tx_gain_table[][5] = {
- /* Addr      5G_HT20     5G_HT40     2G_HT40     2G_HT20   */
- {0x0000a2dc, 0xfc0a9380, 0xfc0a9380, 0xfdab5b52, 0xfdab5b52},
- {0x0000a2e0, 0xffecec00, 0xffecec00, 0xfd339c84, 0xfd339c84},
- {0x0000a2e4, 0xfc0f0000, 0xfc0f0000, 0xfec3e000, 0xfec3e000},
- {0x0000a2e8, 0xfc100000, 0xfc100000, 0xfffc0000, 0xfffc0000},
- {0x0000a410, 0x000050d9, 0x000050d9, 0x000050d9, 0x000050d9},
- {0x0000a500, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
- {0x0000a504, 0x06000003, 0x06000003, 0x04000002, 0x04000002},
- {0x0000a508, 0x0a000020, 0x0a000020, 0x08000004, 0x08000004},
- {0x0000a50c, 0x10000023, 0x10000023, 0x0b000200, 0x0b000200},
- {0x0000a510, 0x16000220, 0x16000220, 0x0f000202, 0x0f000202},
- {0x0000a514, 0x1c000223, 0x1c000223, 0x12000400, 0x12000400},
- {0x0000a518, 0x21020220, 0x21020220, 0x16000402, 0x16000402},
- {0x0000a51c, 0x27020223, 0x27020223, 0x19000404, 0x19000404},
- {0x0000a520, 0x2b022220, 0x2b022220, 0x1c000603, 0x1c000603},
- {0x0000a524, 0x2f022222, 0x2f022222, 0x21000a02, 0x21000a02},
- {0x0000a528, 0x34022225, 0x34022225, 0x25000a04, 0x25000a04},
- {0x0000a52c, 0x3a02222a, 0x3a02222a, 0x28000a20, 0x28000a20},
- {0x0000a530, 0x3e02222c, 0x3e02222c, 0x2c000e20, 0x2c000e20},
- {0x0000a534, 0x4202242a, 0x4202242a, 0x30000e22, 0x30000e22},
- {0x0000a538, 0x4702244a, 0x4702244a, 0x34000e24, 0x34000e24},
- {0x0000a53c, 0x4b02244c, 0x4b02244c, 0x38001640, 0x38001640},
- {0x0000a540, 0x4e02246c, 0x4e02246c, 0x3c001660, 0x3c001660},
- {0x0000a544, 0x5302266c, 0x5302266c, 0x3f001861, 0x3f001861},
- {0x0000a548, 0x5702286c, 0x5702286c, 0x43001a81, 0x43001a81},
- {0x0000a54c, 0x5c04286b, 0x5c04286b, 0x47001a83, 0x47001a83},
- {0x0000a550, 0x61042a6c, 0x61042a6c, 0x4a001c84, 0x4a001c84},
- {0x0000a554, 0x66062a6c, 0x66062a6c, 0x4e001ce3, 0x4e001ce3},
- {0x0000a558, 0x6b062e6c, 0x6b062e6c, 0x52001ce5, 0x52001ce5},
- {0x0000a55c, 0x7006308c, 0x7006308c, 0x56001ce9, 0x56001ce9},
- {0x0000a560, 0x730a308a, 0x730a308a, 0x5a001ceb, 0x5a001ceb},
- {0x0000a564, 0x770a308c, 0x770a308c, 0x5d001eec, 0x5d001eec},
- {0x0000a568, 0x770a308c, 0x770a308c, 0x5d001eec, 0x5d001eec},
- {0x0000a56c, 0x770a308c, 0x770a308c, 0x5d001eec, 0x5d001eec},
- {0x0000a570, 0x770a308c, 0x770a308c, 0x5d001eec, 0x5d001eec},
- {0x0000a574, 0x770a308c, 0x770a308c, 0x5d001eec, 0x5d001eec},
- {0x0000a578, 0x770a308c, 0x770a308c, 0x5d001eec, 0x5d001eec},
- {0x0000a57c, 0x770a308c, 0x770a308c, 0x5d001eec, 0x5d001eec},
- {0x0000a600, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
- {0x0000a604, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
- {0x0000a608, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
- {0x0000a60c, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
- {0x0000a610, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
- {0x0000a614, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
- {0x0000a618, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
- {0x0000a61c, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
- {0x0000a620, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
- {0x0000a624, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
- {0x0000a628, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
- {0x0000a62c, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
- {0x0000a630, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
- {0x0000a634, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
- {0x0000a638, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
- {0x0000a63c, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
- {0x00016044, 0x012482d4, 0x012482d4, 0x012482d4, 0x012482d4},
- {0x00016048, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
- {0x00016054, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
-};
-
 static const u32 ar9565_1p0_pciephy_clkreq_disable_L1[][2] = {
  /* Addr      allmodes  */
  {0x00018c00, 0x18212ede},
diff --git a/drivers/net/wireless/ath/ath9k/ar9565_1p1_initvals.h b/drivers/net/wireless/ath/ath9k/ar9565_1p1_initvals.h
new file mode 100644
index 0000000..5681053
--- /dev/null
+++ b/drivers/net/wireless/ath/ath9k/ar9565_1p1_initvals.h
@@ -0,0 +1,64 @@
+/*
+ * Copyright (c) 2010-2011 Atheros Communications Inc.
+ * Copyright (c) 2011-2012 Qualcomm Atheros Inc.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef INITVALS_9565_1P1_H
+#define INITVALS_9565_1P1_H
+
+/* AR9565 1.1 */
+
+#define ar9565_1p1_mac_core ar9565_1p0_mac_core
+
+#define ar9565_1p1_mac_postamble ar9565_1p0_mac_postamble
+
+#define ar9565_1p1_baseband_core ar9565_1p0_baseband_core
+
+#define ar9565_1p1_baseband_postamble ar9565_1p0_baseband_postamble
+
+#define ar9565_1p1_radio_core ar9565_1p0_radio_core
+
+#define ar9565_1p1_soc_preamble ar9565_1p0_soc_preamble
+
+#define ar9565_1p1_soc_postamble ar9565_1p0_soc_postamble
+
+#define ar9565_1p1_Common_rx_gain_table ar9565_1p0_Common_rx_gain_table
+
+#define ar9565_1p1_Modes_lowest_ob_db_tx_gain_table ar9565_1p0_Modes_lowest_ob_db_tx_gain_table
+
+#define ar9565_1p1_pciephy_clkreq_disable_L1 ar9565_1p0_pciephy_clkreq_disable_L1
+
+#define ar9565_1p1_modes_fast_clock ar9565_1p0_modes_fast_clock
+
+#define ar9565_1p1_common_wo_xlna_rx_gain_table ar9565_1p0_common_wo_xlna_rx_gain_table
+
+#define ar9565_1p1_modes_low_ob_db_tx_gain_table ar9565_1p0_modes_low_ob_db_tx_gain_table
+
+#define ar9565_1p1_modes_high_ob_db_tx_gain_table ar9565_1p0_modes_high_ob_db_tx_gain_table
+
+#define ar9565_1p1_modes_high_power_tx_gain_table ar9565_1p0_modes_high_power_tx_gain_table
+
+#define ar9565_1p1_baseband_core_txfir_coeff_japan_2484 ar9565_1p0_baseband_core_txfir_coeff_japan_2484
+
+static const u32 ar9565_1p1_radio_postamble[][5] = {
+ /* Addr      5G_HT20     5G_HT40     2G_HT40     2G_HT20   */
+ {0x0001609c, 0x0b8ee524, 0x0b8ee524, 0x0b8ee524, 0x0b8ee524},
+ {0x000160ac, 0xa4646c08, 0xa4646c08, 0x24645808, 0x24645808},
+ {0x000160b0, 0x01d67f70, 0x01d67f70, 0x01d67f70, 0x01d67f70},
+ {0x0001610c, 0x40000000, 0x40000000, 0x40000000, 0x40000000},
+ {0x00016140, 0x10804008, 0x10804008, 0x50804008, 0x50804008},
+};
+
+#endif /* INITVALS_9565_1P1_H */
diff --git a/drivers/net/wireless/ath/ath9k/ar9580_1p0_initvals.h b/drivers/net/wireless/ath/ath9k/ar9580_1p0_initvals.h
index bdee2ed..a5ca652 100644
--- a/drivers/net/wireless/ath/ath9k/ar9580_1p0_initvals.h
+++ b/drivers/net/wireless/ath/ath9k/ar9580_1p0_initvals.h
@@ -20,18 +20,34 @@
 
 /* AR9580 1.0 */
 
+#define ar9580_1p0_soc_preamble ar9300_2p2_soc_preamble
+
+#define ar9580_1p0_soc_postamble ar9300_2p2_soc_postamble
+
+#define ar9580_1p0_radio_core ar9300_2p2_radio_core
+
+#define ar9580_1p0_mac_postamble ar9300_2p2_mac_postamble
+
+#define ar9580_1p0_wo_xlna_rx_gain_table ar9300Common_wo_xlna_rx_gain_table_2p2
+
+#define ar9580_1p0_type5_tx_gain_table ar9300Modes_type5_tx_gain_table_2p2
+
+#define ar9580_1p0_high_ob_db_tx_gain_table ar9300Modes_high_ob_db_tx_gain_table_2p2
+
 #define ar9580_1p0_modes_fast_clock ar9300Modes_fast_clock_2p2
 
+#define ar9580_1p0_baseband_core_txfir_coeff_japan_2484 ar9300_2p2_baseband_core_txfir_coeff_japan_2484
+
 static const u32 ar9580_1p0_radio_postamble[][5] = {
  /* Addr      5G_HT20     5G_HT40     2G_HT40     2G_HT20   */
  {0x0001609c, 0x0dd08f29, 0x0dd08f29, 0x0b283f31, 0x0b283f31},
  {0x000160ac, 0xa4653c00, 0xa4653c00, 0x24652800, 0x24652800},
  {0x000160b0, 0x03284f3e, 0x03284f3e, 0x05d08f20, 0x05d08f20},
- {0x0001610c, 0x08000000, 0x00000000, 0x00000000, 0x00000000},
+ {0x0001610c, 0xc8000000, 0xc0000000, 0xc0000000, 0xc0000000},
  {0x00016140, 0x10804008, 0x10804008, 0x50804008, 0x50804008},
- {0x0001650c, 0x08000000, 0x00000000, 0x00000000, 0x00000000},
+ {0x0001650c, 0xc8000000, 0xc0000000, 0xc0000000, 0xc0000000},
  {0x00016540, 0x10804008, 0x10804008, 0x50804008, 0x50804008},
- {0x0001690c, 0x08000000, 0x00000000, 0x00000000, 0x00000000},
+ {0x0001690c, 0xc8000000, 0xc0000000, 0xc0000000, 0xc0000000},
  {0x00016940, 0x10804008, 0x10804008, 0x50804008, 0x50804008},
 };
 
@@ -41,12 +57,10 @@ static const u32 ar9580_1p0_baseband_core[][2] = {
  {0x00009804, 0xfd14e000},
  {0x00009808, 0x9c0a9f6b},
  {0x0000980c, 0x04900000},
- {0x00009814, 0x3280c00a},
- {0x00009818, 0x00000000},
  {0x0000981c, 0x00020028},
- {0x00009834, 0x6400a290},
+ {0x00009834, 0x6400a190},
  {0x00009838, 0x0108ecff},
- {0x0000983c, 0x0d000600},
+ {0x0000983c, 0x14000600},
  {0x00009880, 0x201fff00},
  {0x00009884, 0x00001042},
  {0x000098a4, 0x00200400},
@@ -67,7 +81,7 @@ static const u32 ar9580_1p0_baseband_core[][2] = {
  {0x00009d04, 0x40206c10},
  {0x00009d08, 0x009c4060},
  {0x00009d0c, 0x9883800a},
- {0x00009d10, 0x01834061},
+ {0x00009d10, 0x01884061},
  {0x00009d14, 0x00c0040b},
  {0x00009d18, 0x00000000},
  {0x00009e08, 0x0038230c},
@@ -76,7 +90,7 @@ static const u32 ar9580_1p0_baseband_core[][2] = {
  {0x00009e30, 0x06336f77},
  {0x00009e34, 0x6af6532f},
  {0x00009e38, 0x0cc80c00},
- {0x00009e40, 0x0d261820},
+ {0x00009e40, 0x0d261800},
  {0x00009e4c, 0x00001004},
  {0x00009e50, 0x00ff03f1},
  {0x00009e54, 0x00000000},
@@ -198,8 +212,6 @@ static const u32 ar9580_1p0_baseband_core[][2] = {
  {0x0000c420, 0x00000000},
 };
 
-#define ar9580_1p0_mac_postamble ar9300_2p2_mac_postamble
-
 static const u32 ar9580_1p0_low_ob_db_tx_gain_table[][5] = {
  /* Addr      5G_HT20     5G_HT40     2G_HT40     2G_HT20   */
  {0x0000a2dc, 0x0380c7fc, 0x0380c7fc, 0x03aaa352, 0x03aaa352},
@@ -306,7 +318,112 @@ static const u32 ar9580_1p0_low_ob_db_tx_gain_table[][5] = {
  {0x00016868, 0x6db6db6c, 0x6db6db6c, 0x6db6db6c, 0x6db6db6c},
 };
 
-#define ar9580_1p0_high_power_tx_gain_table ar9580_1p0_low_ob_db_tx_gain_table
+static const u32 ar9580_1p0_high_power_tx_gain_table[][5] = {
+ /* Addr      5G_HT20     5G_HT40     2G_HT40     2G_HT20   */
+ {0x0000a2dc, 0x000cfff0, 0x000cfff0, 0x03aaa352, 0x03aaa352},
+ {0x0000a2e0, 0x000f0000, 0x000f0000, 0x03ccc584, 0x03ccc584},
+ {0x0000a2e4, 0x03f00000, 0x03f00000, 0x03f0f800, 0x03f0f800},
+ {0x0000a2e8, 0x00000000, 0x00000000, 0x03ff0000, 0x03ff0000},
+ {0x0000a410, 0x000050d9, 0x000050d9, 0x000050d9, 0x000050d9},
+ {0x0000a500, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
+ {0x0000a504, 0x06000003, 0x06000003, 0x04000002, 0x04000002},
+ {0x0000a508, 0x0a000020, 0x0a000020, 0x08000004, 0x08000004},
+ {0x0000a50c, 0x10000023, 0x10000023, 0x0b000200, 0x0b000200},
+ {0x0000a510, 0x15000028, 0x15000028, 0x0f000202, 0x0f000202},
+ {0x0000a514, 0x1b00002b, 0x1b00002b, 0x12000400, 0x12000400},
+ {0x0000a518, 0x1f020028, 0x1f020028, 0x16000402, 0x16000402},
+ {0x0000a51c, 0x2502002b, 0x2502002b, 0x19000404, 0x19000404},
+ {0x0000a520, 0x2a04002a, 0x2a04002a, 0x1c000603, 0x1c000603},
+ {0x0000a524, 0x2e06002a, 0x2e06002a, 0x21000a02, 0x21000a02},
+ {0x0000a528, 0x3302202d, 0x3302202d, 0x25000a04, 0x25000a04},
+ {0x0000a52c, 0x3804202c, 0x3804202c, 0x28000a20, 0x28000a20},
+ {0x0000a530, 0x3c06202c, 0x3c06202c, 0x2c000e20, 0x2c000e20},
+ {0x0000a534, 0x4108202d, 0x4108202d, 0x30000e22, 0x30000e22},
+ {0x0000a538, 0x4506402d, 0x4506402d, 0x34000e24, 0x34000e24},
+ {0x0000a53c, 0x4906222d, 0x4906222d, 0x38001640, 0x38001640},
+ {0x0000a540, 0x4d062231, 0x4d062231, 0x3c001660, 0x3c001660},
+ {0x0000a544, 0x50082231, 0x50082231, 0x3f001861, 0x3f001861},
+ {0x0000a548, 0x5608422e, 0x5608422e, 0x43001a81, 0x43001a81},
+ {0x0000a54c, 0x5e08442e, 0x5e08442e, 0x47001a83, 0x47001a83},
+ {0x0000a550, 0x620a4431, 0x620a4431, 0x4a001c84, 0x4a001c84},
+ {0x0000a554, 0x640a4432, 0x640a4432, 0x4e001ce3, 0x4e001ce3},
+ {0x0000a558, 0x680a4434, 0x680a4434, 0x52001ce5, 0x52001ce5},
+ {0x0000a55c, 0x6c0a6434, 0x6c0a6434, 0x56001ce9, 0x56001ce9},
+ {0x0000a560, 0x6f0a6633, 0x6f0a6633, 0x5a001ceb, 0x5a001ceb},
+ {0x0000a564, 0x730c6634, 0x730c6634, 0x5d001eec, 0x5d001eec},
+ {0x0000a568, 0x730c6634, 0x730c6634, 0x5d001eec, 0x5d001eec},
+ {0x0000a56c, 0x730c6634, 0x730c6634, 0x5d001eec, 0x5d001eec},
+ {0x0000a570, 0x730c6634, 0x730c6634, 0x5d001eec, 0x5d001eec},
+ {0x0000a574, 0x730c6634, 0x730c6634, 0x5d001eec, 0x5d001eec},
+ {0x0000a578, 0x730c6634, 0x730c6634, 0x5d001eec, 0x5d001eec},
+ {0x0000a57c, 0x730c6634, 0x730c6634, 0x5d001eec, 0x5d001eec},
+ {0x0000a580, 0x00800000, 0x00800000, 0x00800000, 0x00800000},
+ {0x0000a584, 0x06800003, 0x06800003, 0x04800002, 0x04800002},
+ {0x0000a588, 0x0a800020, 0x0a800020, 0x08800004, 0x08800004},
+ {0x0000a58c, 0x10800023, 0x10800023, 0x0b800200, 0x0b800200},
+ {0x0000a590, 0x15800028, 0x15800028, 0x0f800202, 0x0f800202},
+ {0x0000a594, 0x1b80002b, 0x1b80002b, 0x12800400, 0x12800400},
+ {0x0000a598, 0x1f820028, 0x1f820028, 0x16800402, 0x16800402},
+ {0x0000a59c, 0x2582002b, 0x2582002b, 0x19800404, 0x19800404},
+ {0x0000a5a0, 0x2a84002a, 0x2a84002a, 0x1c800603, 0x1c800603},
+ {0x0000a5a4, 0x2e86002a, 0x2e86002a, 0x21800a02, 0x21800a02},
+ {0x0000a5a8, 0x3382202d, 0x3382202d, 0x25800a04, 0x25800a04},
+ {0x0000a5ac, 0x3884202c, 0x3884202c, 0x28800a20, 0x28800a20},
+ {0x0000a5b0, 0x3c86202c, 0x3c86202c, 0x2c800e20, 0x2c800e20},
+ {0x0000a5b4, 0x4188202d, 0x4188202d, 0x30800e22, 0x30800e22},
+ {0x0000a5b8, 0x4586402d, 0x4586402d, 0x34800e24, 0x34800e24},
+ {0x0000a5bc, 0x4986222d, 0x4986222d, 0x38801640, 0x38801640},
+ {0x0000a5c0, 0x4d862231, 0x4d862231, 0x3c801660, 0x3c801660},
+ {0x0000a5c4, 0x50882231, 0x50882231, 0x3f801861, 0x3f801861},
+ {0x0000a5c8, 0x5688422e, 0x5688422e, 0x43801a81, 0x43801a81},
+ {0x0000a5cc, 0x5a88442e, 0x5a88442e, 0x47801a83, 0x47801a83},
+ {0x0000a5d0, 0x5e8a4431, 0x5e8a4431, 0x4a801c84, 0x4a801c84},
+ {0x0000a5d4, 0x648a4432, 0x648a4432, 0x4e801ce3, 0x4e801ce3},
+ {0x0000a5d8, 0x688a4434, 0x688a4434, 0x52801ce5, 0x52801ce5},
+ {0x0000a5dc, 0x6c8a6434, 0x6c8a6434, 0x56801ce9, 0x56801ce9},
+ {0x0000a5e0, 0x6f8a6633, 0x6f8a6633, 0x5a801ceb, 0x5a801ceb},
+ {0x0000a5e4, 0x738c6634, 0x738c6634, 0x5d801eec, 0x5d801eec},
+ {0x0000a5e8, 0x738c6634, 0x738c6634, 0x5d801eec, 0x5d801eec},
+ {0x0000a5ec, 0x738c6634, 0x738c6634, 0x5d801eec, 0x5d801eec},
+ {0x0000a5f0, 0x738c6634, 0x738c6634, 0x5d801eec, 0x5d801eec},
+ {0x0000a5f4, 0x738c6634, 0x738c6634, 0x5d801eec, 0x5d801eec},
+ {0x0000a5f8, 0x738c6634, 0x738c6634, 0x5d801eec, 0x5d801eec},
+ {0x0000a5fc, 0x738c6634, 0x738c6634, 0x5d801eec, 0x5d801eec},
+ {0x0000a600, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
+ {0x0000a604, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
+ {0x0000a608, 0x01804601, 0x01804601, 0x00000000, 0x00000000},
+ {0x0000a60c, 0x01804601, 0x01804601, 0x00000000, 0x00000000},
+ {0x0000a610, 0x01804601, 0x01804601, 0x00000000, 0x00000000},
+ {0x0000a614, 0x01804601, 0x01804601, 0x01404000, 0x01404000},
+ {0x0000a618, 0x01804601, 0x01804601, 0x01404501, 0x01404501},
+ {0x0000a61c, 0x01804601, 0x01804601, 0x02008501, 0x02008501},
+ {0x0000a620, 0x03408d02, 0x03408d02, 0x0280ca03, 0x0280ca03},
+ {0x0000a624, 0x0300cc03, 0x0300cc03, 0x03010c04, 0x03010c04},
+ {0x0000a628, 0x03410d04, 0x03410d04, 0x04014c04, 0x04014c04},
+ {0x0000a62c, 0x03410d04, 0x03410d04, 0x04015005, 0x04015005},
+ {0x0000a630, 0x03410d04, 0x03410d04, 0x04015005, 0x04015005},
+ {0x0000a634, 0x03410d04, 0x03410d04, 0x04015005, 0x04015005},
+ {0x0000a638, 0x03410d04, 0x03410d04, 0x04015005, 0x04015005},
+ {0x0000a63c, 0x03410d04, 0x03410d04, 0x04015005, 0x04015005},
+ {0x0000b2dc, 0x000cfff0, 0x000cfff0, 0x03aaa352, 0x03aaa352},
+ {0x0000b2e0, 0x000f0000, 0x000f0000, 0x03ccc584, 0x03ccc584},
+ {0x0000b2e4, 0x03f00000, 0x03f00000, 0x03f0f800, 0x03f0f800},
+ {0x0000b2e8, 0x00000000, 0x00000000, 0x03ff0000, 0x03ff0000},
+ {0x0000c2dc, 0x000cfff0, 0x000cfff0, 0x03aaa352, 0x03aaa352},
+ {0x0000c2e0, 0x000f0000, 0x000f0000, 0x03ccc584, 0x03ccc584},
+ {0x0000c2e4, 0x03f00000, 0x03f00000, 0x03f0f800, 0x03f0f800},
+ {0x0000c2e8, 0x00000000, 0x00000000, 0x03ff0000, 0x03ff0000},
+ {0x00016044, 0x012492d4, 0x012492d4, 0x012492d4, 0x012492d4},
+ {0x00016048, 0x65240001, 0x65240001, 0x66480001, 0x66480001},
+ {0x00016068, 0x6db6db6c, 0x6db6db6c, 0x6db6db6c, 0x6db6db6c},
+ {0x00016288, 0x05a2040a, 0x05a2040a, 0x05a20408, 0x05a20408},
+ {0x00016444, 0x012492d4, 0x012492d4, 0x012492d4, 0x012492d4},
+ {0x00016448, 0x65240001, 0x65240001, 0x66480001, 0x66480001},
+ {0x00016468, 0x6db6db6c, 0x6db6db6c, 0x6db6db6c, 0x6db6db6c},
+ {0x00016844, 0x012492d4, 0x012492d4, 0x012492d4, 0x012492d4},
+ {0x00016848, 0x65240001, 0x65240001, 0x66480001, 0x66480001},
+ {0x00016868, 0x6db6db6c, 0x6db6db6c, 0x6db6db6c, 0x6db6db6c},
+};
 
 static const u32 ar9580_1p0_lowest_ob_db_tx_gain_table[][5] = {
  /* Addr      5G_HT20     5G_HT40     2G_HT40     2G_HT20   */
@@ -414,8 +531,6 @@ static const u32 ar9580_1p0_lowest_ob_db_tx_gain_table[][5] = {
  {0x00016868, 0x6db6db6c, 0x6db6db6c, 0x6db6db6c, 0x6db6db6c},
 };
 
-#define ar9580_1p0_baseband_core_txfir_coeff_japan_2484 ar9462_2p0_baseband_core_txfir_coeff_japan_2484
-
 static const u32 ar9580_1p0_mac_core[][2] = {
  /* Addr      allmodes  */
  {0x00000008, 0x00000000},
@@ -679,14 +794,6 @@ static const u32 ar9580_1p0_mixed_ob_db_tx_gain_table[][5] = {
  {0x00016868, 0x6db6db6c, 0x6db6db6c, 0x6db6db6c, 0x6db6db6c},
 };
 
-#define ar9580_1p0_wo_xlna_rx_gain_table ar9300Common_wo_xlna_rx_gain_table_2p2
-
-#define ar9580_1p0_soc_postamble ar9300_2p2_soc_postamble
-
-#define ar9580_1p0_high_ob_db_tx_gain_table ar9300Modes_high_ob_db_tx_gain_table_2p2
-
-#define ar9580_1p0_type5_tx_gain_table ar9300Modes_type5_tx_gain_table_2p2
-
 static const u32 ar9580_1p0_type6_tx_gain_table[][5] = {
  /* Addr      5G_HT20     5G_HT40     2G_HT40     2G_HT20   */
  {0x0000a2dc, 0x000cfff0, 0x000cfff0, 0x03aaa352, 0x03aaa352},
@@ -761,165 +868,271 @@ static const u32 ar9580_1p0_type6_tx_gain_table[][5] = {
  {0x00016868, 0x6db6db6c, 0x6db6db6c, 0x6db6db6c, 0x6db6db6c},
 };
 
-static const u32 ar9580_1p0_soc_preamble[][2] = {
+static const u32 ar9580_1p0_rx_gain_table[][2] = {
  /* Addr      allmodes  */
- {0x000040a4, 0x00a0c1c9},
- {0x00007008, 0x00000000},
- {0x00007020, 0x00000000},
- {0x00007034, 0x00000002},
- {0x00007038, 0x000004c2},
- {0x00007048, 0x00000008},
-};
-
-#define ar9580_1p0_rx_gain_table ar9462_common_rx_gain_table_2p0
-
-static const u32 ar9580_1p0_radio_core[][2] = {
- /* Addr      allmodes  */
- {0x00016000, 0x36db6db6},
- {0x00016004, 0x6db6db40},
- {0x00016008, 0x73f00000},
- {0x0001600c, 0x00000000},
- {0x00016040, 0x7f80fff8},
- {0x0001604c, 0x76d005b5},
- {0x00016050, 0x556cf031},
- {0x00016054, 0x13449440},
- {0x00016058, 0x0c51c92c},
- {0x0001605c, 0x3db7fffc},
- {0x00016060, 0xfffffffc},
- {0x00016064, 0x000f0278},
- {0x0001606c, 0x6db60000},
- {0x00016080, 0x00000000},
- {0x00016084, 0x0e48048c},
- {0x00016088, 0x54214514},
- {0x0001608c, 0x119f481e},
- {0x00016090, 0x24926490},
- {0x00016098, 0xd2888888},
- {0x000160a0, 0x0a108ffe},
- {0x000160a4, 0x812fc370},
- {0x000160a8, 0x423c8000},
- {0x000160b4, 0x92480080},
- {0x000160c0, 0x00adb6d0},
- {0x000160c4, 0x6db6db60},
- {0x000160c8, 0x6db6db6c},
- {0x000160cc, 0x01e6c000},
- {0x00016100, 0x3fffbe01},
- {0x00016104, 0xfff80000},
- {0x00016108, 0x00080010},
- {0x00016144, 0x02084080},
- {0x00016148, 0x00000000},
- {0x00016280, 0x058a0001},
- {0x00016284, 0x3d840208},
- {0x00016288, 0x05a20408},
- {0x0001628c, 0x00038c07},
- {0x00016290, 0x00000004},
- {0x00016294, 0x458aa14f},
- {0x00016380, 0x00000000},
- {0x00016384, 0x00000000},
- {0x00016388, 0x00800700},
- {0x0001638c, 0x00800700},
- {0x00016390, 0x00800700},
- {0x00016394, 0x00000000},
- {0x00016398, 0x00000000},
- {0x0001639c, 0x00000000},
- {0x000163a0, 0x00000001},
- {0x000163a4, 0x00000001},
- {0x000163a8, 0x00000000},
- {0x000163ac, 0x00000000},
- {0x000163b0, 0x00000000},
- {0x000163b4, 0x00000000},
- {0x000163b8, 0x00000000},
- {0x000163bc, 0x00000000},
- {0x000163c0, 0x000000a0},
- {0x000163c4, 0x000c0000},
- {0x000163c8, 0x14021402},
- {0x000163cc, 0x00001402},
- {0x000163d0, 0x00000000},
- {0x000163d4, 0x00000000},
- {0x00016400, 0x36db6db6},
- {0x00016404, 0x6db6db40},
- {0x00016408, 0x73f00000},
- {0x0001640c, 0x00000000},
- {0x00016440, 0x7f80fff8},
- {0x0001644c, 0x76d005b5},
- {0x00016450, 0x556cf031},
- {0x00016454, 0x13449440},
- {0x00016458, 0x0c51c92c},
- {0x0001645c, 0x3db7fffc},
- {0x00016460, 0xfffffffc},
- {0x00016464, 0x000f0278},
- {0x0001646c, 0x6db60000},
- {0x00016500, 0x3fffbe01},
- {0x00016504, 0xfff80000},
- {0x00016508, 0x00080010},
- {0x00016544, 0x02084080},
- {0x00016548, 0x00000000},
- {0x00016780, 0x00000000},
- {0x00016784, 0x00000000},
- {0x00016788, 0x00800700},
- {0x0001678c, 0x00800700},
- {0x00016790, 0x00800700},
- {0x00016794, 0x00000000},
- {0x00016798, 0x00000000},
- {0x0001679c, 0x00000000},
- {0x000167a0, 0x00000001},
- {0x000167a4, 0x00000001},
- {0x000167a8, 0x00000000},
- {0x000167ac, 0x00000000},
- {0x000167b0, 0x00000000},
- {0x000167b4, 0x00000000},
- {0x000167b8, 0x00000000},
- {0x000167bc, 0x00000000},
- {0x000167c0, 0x000000a0},
- {0x000167c4, 0x000c0000},
- {0x000167c8, 0x14021402},
- {0x000167cc, 0x00001402},
- {0x000167d0, 0x00000000},
- {0x000167d4, 0x00000000},
- {0x00016800, 0x36db6db6},
- {0x00016804, 0x6db6db40},
- {0x00016808, 0x73f00000},
- {0x0001680c, 0x00000000},
- {0x00016840, 0x7f80fff8},
- {0x0001684c, 0x76d005b5},
- {0x00016850, 0x556cf031},
- {0x00016854, 0x13449440},
- {0x00016858, 0x0c51c92c},
- {0x0001685c, 0x3db7fffc},
- {0x00016860, 0xfffffffc},
- {0x00016864, 0x000f0278},
- {0x0001686c, 0x6db60000},
- {0x00016900, 0x3fffbe01},
- {0x00016904, 0xfff80000},
- {0x00016908, 0x00080010},
- {0x00016944, 0x02084080},
- {0x00016948, 0x00000000},
- {0x00016b80, 0x00000000},
- {0x00016b84, 0x00000000},
- {0x00016b88, 0x00800700},
- {0x00016b8c, 0x00800700},
- {0x00016b90, 0x00800700},
- {0x00016b94, 0x00000000},
- {0x00016b98, 0x00000000},
- {0x00016b9c, 0x00000000},
- {0x00016ba0, 0x00000001},
- {0x00016ba4, 0x00000001},
- {0x00016ba8, 0x00000000},
- {0x00016bac, 0x00000000},
- {0x00016bb0, 0x00000000},
- {0x00016bb4, 0x00000000},
- {0x00016bb8, 0x00000000},
- {0x00016bbc, 0x00000000},
- {0x00016bc0, 0x000000a0},
- {0x00016bc4, 0x000c0000},
- {0x00016bc8, 0x14021402},
- {0x00016bcc, 0x00001402},
- {0x00016bd0, 0x00000000},
- {0x00016bd4, 0x00000000},
+ {0x0000a000, 0x00010000},
+ {0x0000a004, 0x00030002},
+ {0x0000a008, 0x00050004},
+ {0x0000a00c, 0x00810080},
+ {0x0000a010, 0x00830082},
+ {0x0000a014, 0x01810180},
+ {0x0000a018, 0x01830182},
+ {0x0000a01c, 0x01850184},
+ {0x0000a020, 0x01890188},
+ {0x0000a024, 0x018b018a},
+ {0x0000a028, 0x018d018c},
+ {0x0000a02c, 0x01910190},
+ {0x0000a030, 0x01930192},
+ {0x0000a034, 0x01950194},
+ {0x0000a038, 0x038a0196},
+ {0x0000a03c, 0x038c038b},
+ {0x0000a040, 0x0390038d},
+ {0x0000a044, 0x03920391},
+ {0x0000a048, 0x03940393},
+ {0x0000a04c, 0x03960395},
+ {0x0000a050, 0x00000000},
+ {0x0000a054, 0x00000000},
+ {0x0000a058, 0x00000000},
+ {0x0000a05c, 0x00000000},
+ {0x0000a060, 0x00000000},
+ {0x0000a064, 0x00000000},
+ {0x0000a068, 0x00000000},
+ {0x0000a06c, 0x00000000},
+ {0x0000a070, 0x00000000},
+ {0x0000a074, 0x00000000},
+ {0x0000a078, 0x00000000},
+ {0x0000a07c, 0x00000000},
+ {0x0000a080, 0x22222229},
+ {0x0000a084, 0x1d1d1d1d},
+ {0x0000a088, 0x1d1d1d1d},
+ {0x0000a08c, 0x1d1d1d1d},
+ {0x0000a090, 0x171d1d1d},
+ {0x0000a094, 0x11111717},
+ {0x0000a098, 0x00030311},
+ {0x0000a09c, 0x00000000},
+ {0x0000a0a0, 0x00000000},
+ {0x0000a0a4, 0x00000000},
+ {0x0000a0a8, 0x00000000},
+ {0x0000a0ac, 0x00000000},
+ {0x0000a0b0, 0x00000000},
+ {0x0000a0b4, 0x00000000},
+ {0x0000a0b8, 0x00000000},
+ {0x0000a0bc, 0x00000000},
+ {0x0000a0c0, 0x001f0000},
+ {0x0000a0c4, 0x01000101},
+ {0x0000a0c8, 0x011e011f},
+ {0x0000a0cc, 0x011c011d},
+ {0x0000a0d0, 0x02030204},
+ {0x0000a0d4, 0x02010202},
+ {0x0000a0d8, 0x021f0200},
+ {0x0000a0dc, 0x0302021e},
+ {0x0000a0e0, 0x03000301},
+ {0x0000a0e4, 0x031e031f},
+ {0x0000a0e8, 0x0402031d},
+ {0x0000a0ec, 0x04000401},
+ {0x0000a0f0, 0x041e041f},
+ {0x0000a0f4, 0x0502041d},
+ {0x0000a0f8, 0x05000501},
+ {0x0000a0fc, 0x051e051f},
+ {0x0000a100, 0x06010602},
+ {0x0000a104, 0x061f0600},
+ {0x0000a108, 0x061d061e},
+ {0x0000a10c, 0x07020703},
+ {0x0000a110, 0x07000701},
+ {0x0000a114, 0x00000000},
+ {0x0000a118, 0x00000000},
+ {0x0000a11c, 0x00000000},
+ {0x0000a120, 0x00000000},
+ {0x0000a124, 0x00000000},
+ {0x0000a128, 0x00000000},
+ {0x0000a12c, 0x00000000},
+ {0x0000a130, 0x00000000},
+ {0x0000a134, 0x00000000},
+ {0x0000a138, 0x00000000},
+ {0x0000a13c, 0x00000000},
+ {0x0000a140, 0x001f0000},
+ {0x0000a144, 0x01000101},
+ {0x0000a148, 0x011e011f},
+ {0x0000a14c, 0x011c011d},
+ {0x0000a150, 0x02030204},
+ {0x0000a154, 0x02010202},
+ {0x0000a158, 0x021f0200},
+ {0x0000a15c, 0x0302021e},
+ {0x0000a160, 0x03000301},
+ {0x0000a164, 0x031e031f},
+ {0x0000a168, 0x0402031d},
+ {0x0000a16c, 0x04000401},
+ {0x0000a170, 0x041e041f},
+ {0x0000a174, 0x0502041d},
+ {0x0000a178, 0x05000501},
+ {0x0000a17c, 0x051e051f},
+ {0x0000a180, 0x06010602},
+ {0x0000a184, 0x061f0600},
+ {0x0000a188, 0x061d061e},
+ {0x0000a18c, 0x07020703},
+ {0x0000a190, 0x07000701},
+ {0x0000a194, 0x00000000},
+ {0x0000a198, 0x00000000},
+ {0x0000a19c, 0x00000000},
+ {0x0000a1a0, 0x00000000},
+ {0x0000a1a4, 0x00000000},
+ {0x0000a1a8, 0x00000000},
+ {0x0000a1ac, 0x00000000},
+ {0x0000a1b0, 0x00000000},
+ {0x0000a1b4, 0x00000000},
+ {0x0000a1b8, 0x00000000},
+ {0x0000a1bc, 0x00000000},
+ {0x0000a1c0, 0x00000000},
+ {0x0000a1c4, 0x00000000},
+ {0x0000a1c8, 0x00000000},
+ {0x0000a1cc, 0x00000000},
+ {0x0000a1d0, 0x00000000},
+ {0x0000a1d4, 0x00000000},
+ {0x0000a1d8, 0x00000000},
+ {0x0000a1dc, 0x00000000},
+ {0x0000a1e0, 0x00000000},
+ {0x0000a1e4, 0x00000000},
+ {0x0000a1e8, 0x00000000},
+ {0x0000a1ec, 0x00000000},
+ {0x0000a1f0, 0x00000396},
+ {0x0000a1f4, 0x00000396},
+ {0x0000a1f8, 0x00000396},
+ {0x0000a1fc, 0x00000196},
+ {0x0000b000, 0x00010000},
+ {0x0000b004, 0x00030002},
+ {0x0000b008, 0x00050004},
+ {0x0000b00c, 0x00810080},
+ {0x0000b010, 0x00830082},
+ {0x0000b014, 0x01810180},
+ {0x0000b018, 0x01830182},
+ {0x0000b01c, 0x01850184},
+ {0x0000b020, 0x02810280},
+ {0x0000b024, 0x02830282},
+ {0x0000b028, 0x02850284},
+ {0x0000b02c, 0x02890288},
+ {0x0000b030, 0x028b028a},
+ {0x0000b034, 0x0388028c},
+ {0x0000b038, 0x038a0389},
+ {0x0000b03c, 0x038c038b},
+ {0x0000b040, 0x0390038d},
+ {0x0000b044, 0x03920391},
+ {0x0000b048, 0x03940393},
+ {0x0000b04c, 0x03960395},
+ {0x0000b050, 0x00000000},
+ {0x0000b054, 0x00000000},
+ {0x0000b058, 0x00000000},
+ {0x0000b05c, 0x00000000},
+ {0x0000b060, 0x00000000},
+ {0x0000b064, 0x00000000},
+ {0x0000b068, 0x00000000},
+ {0x0000b06c, 0x00000000},
+ {0x0000b070, 0x00000000},
+ {0x0000b074, 0x00000000},
+ {0x0000b078, 0x00000000},
+ {0x0000b07c, 0x00000000},
+ {0x0000b080, 0x23232323},
+ {0x0000b084, 0x21232323},
+ {0x0000b088, 0x19191c1e},
+ {0x0000b08c, 0x12141417},
+ {0x0000b090, 0x07070e0e},
+ {0x0000b094, 0x03030305},
+ {0x0000b098, 0x00000003},
+ {0x0000b09c, 0x00000000},
+ {0x0000b0a0, 0x00000000},
+ {0x0000b0a4, 0x00000000},
+ {0x0000b0a8, 0x00000000},
+ {0x0000b0ac, 0x00000000},
+ {0x0000b0b0, 0x00000000},
+ {0x0000b0b4, 0x00000000},
+ {0x0000b0b8, 0x00000000},
+ {0x0000b0bc, 0x00000000},
+ {0x0000b0c0, 0x003f0020},
+ {0x0000b0c4, 0x00400041},
+ {0x0000b0c8, 0x0140005f},
+ {0x0000b0cc, 0x0160015f},
+ {0x0000b0d0, 0x017e017f},
+ {0x0000b0d4, 0x02410242},
+ {0x0000b0d8, 0x025f0240},
+ {0x0000b0dc, 0x027f0260},
+ {0x0000b0e0, 0x0341027e},
+ {0x0000b0e4, 0x035f0340},
+ {0x0000b0e8, 0x037f0360},
+ {0x0000b0ec, 0x04400441},
+ {0x0000b0f0, 0x0460045f},
+ {0x0000b0f4, 0x0541047f},
+ {0x0000b0f8, 0x055f0540},
+ {0x0000b0fc, 0x057f0560},
+ {0x0000b100, 0x06400641},
+ {0x0000b104, 0x0660065f},
+ {0x0000b108, 0x067e067f},
+ {0x0000b10c, 0x07410742},
+ {0x0000b110, 0x075f0740},
+ {0x0000b114, 0x077f0760},
+ {0x0000b118, 0x07800781},
+ {0x0000b11c, 0x07a0079f},
+ {0x0000b120, 0x07c107bf},
+ {0x0000b124, 0x000007c0},
+ {0x0000b128, 0x00000000},
+ {0x0000b12c, 0x00000000},
+ {0x0000b130, 0x00000000},
+ {0x0000b134, 0x00000000},
+ {0x0000b138, 0x00000000},
+ {0x0000b13c, 0x00000000},
+ {0x0000b140, 0x003f0020},
+ {0x0000b144, 0x00400041},
+ {0x0000b148, 0x0140005f},
+ {0x0000b14c, 0x0160015f},
+ {0x0000b150, 0x017e017f},
+ {0x0000b154, 0x02410242},
+ {0x0000b158, 0x025f0240},
+ {0x0000b15c, 0x027f0260},
+ {0x0000b160, 0x0341027e},
+ {0x0000b164, 0x035f0340},
+ {0x0000b168, 0x037f0360},
+ {0x0000b16c, 0x04400441},
+ {0x0000b170, 0x0460045f},
+ {0x0000b174, 0x0541047f},
+ {0x0000b178, 0x055f0540},
+ {0x0000b17c, 0x057f0560},
+ {0x0000b180, 0x06400641},
+ {0x0000b184, 0x0660065f},
+ {0x0000b188, 0x067e067f},
+ {0x0000b18c, 0x07410742},
+ {0x0000b190, 0x075f0740},
+ {0x0000b194, 0x077f0760},
+ {0x0000b198, 0x07800781},
+ {0x0000b19c, 0x07a0079f},
+ {0x0000b1a0, 0x07c107bf},
+ {0x0000b1a4, 0x000007c0},
+ {0x0000b1a8, 0x00000000},
+ {0x0000b1ac, 0x00000000},
+ {0x0000b1b0, 0x00000000},
+ {0x0000b1b4, 0x00000000},
+ {0x0000b1b8, 0x00000000},
+ {0x0000b1bc, 0x00000000},
+ {0x0000b1c0, 0x00000000},
+ {0x0000b1c4, 0x00000000},
+ {0x0000b1c8, 0x00000000},
+ {0x0000b1cc, 0x00000000},
+ {0x0000b1d0, 0x00000000},
+ {0x0000b1d4, 0x00000000},
+ {0x0000b1d8, 0x00000000},
+ {0x0000b1dc, 0x00000000},
+ {0x0000b1e0, 0x00000000},
+ {0x0000b1e4, 0x00000000},
+ {0x0000b1e8, 0x00000000},
+ {0x0000b1ec, 0x00000000},
+ {0x0000b1f0, 0x00000396},
+ {0x0000b1f4, 0x00000396},
+ {0x0000b1f8, 0x00000396},
+ {0x0000b1fc, 0x00000196},
 };
 
 static const u32 ar9580_1p0_baseband_postamble[][5] = {
  /* Addr      5G_HT20     5G_HT40     2G_HT40     2G_HT20   */
  {0x00009810, 0xd00a8005, 0xd00a8005, 0xd00a8011, 0xd00a8011},
+ {0x00009814, 0x3280c00a, 0x3280c00a, 0x3280c00a, 0x3280c00a},
+ {0x00009818, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
  {0x00009820, 0x206a022e, 0x206a022e, 0x206a012e, 0x206a012e},
  {0x00009824, 0x5ac640d0, 0x5ac640d0, 0x5ac640d0, 0x5ac640d0},
  {0x00009828, 0x06903081, 0x06903081, 0x06903881, 0x06903881},
@@ -956,7 +1169,7 @@ static const u32 ar9580_1p0_baseband_postamble[][5] = {
  {0x0000a288, 0x00000110, 0x00000110, 0x00000110, 0x00000110},
  {0x0000a28c, 0x00022222, 0x00022222, 0x00022222, 0x00022222},
  {0x0000a2c4, 0x00158d18, 0x00158d18, 0x00158d18, 0x00158d18},
- {0x0000a2d0, 0x00041981, 0x00041981, 0x00041981, 0x00041982},
+ {0x0000a2d0, 0x00041983, 0x00041983, 0x00041981, 0x00041982},
  {0x0000a2d8, 0x7999a83b, 0x7999a83b, 0x7999a83b, 0x7999a83b},
  {0x0000a358, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
  {0x0000a830, 0x0000019c, 0x0000019c, 0x0000019c, 0x0000019c},
@@ -994,4 +1207,13 @@ static const u32 ar9580_1p0_pcie_phy_pll_on_clkreq[][2] = {
  {0x00004044, 0x00000000},
 };
 
+static const u32 ar9580_1p0_baseband_postamble_dfs_channel[][3] = {
+ /* Addr      5G          2G        */
+ {0x00009814, 0x3400c00f, 0x3400c00f},
+ {0x00009824, 0x5ac668d0, 0x5ac668d0},
+ {0x00009828, 0x06903080, 0x06903080},
+ {0x00009e0c, 0x6d4000e2, 0x6d4000e2},
+ {0x00009e14, 0x37b9625e, 0x37b9625e},
+};
+
 #endif /* INITVALS_9580_1P0_H */
diff --git a/drivers/net/wireless/ath/ath9k/ath9k.h b/drivers/net/wireless/ath/ath9k/ath9k.h
index 04d209b..2ca8f7e 100644
--- a/drivers/net/wireless/ath/ath9k/ath9k.h
+++ b/drivers/net/wireless/ath/ath9k/ath9k.h
@@ -23,79 +23,45 @@
 #include <linux/leds.h>
 #include <linux/completion.h>
 
-#include "debug.h"
 #include "common.h"
+#include "debug.h"
 #include "mci.h"
 #include "dfs.h"
-
-/*
- * Header for the ath9k.ko driver core *only* -- hw code nor any other driver
- * should rely on this file or its contents.
- */
+#include "spectral.h"
 
 struct ath_node;
 
-/* Macro to expand scalars to 64-bit objects */
-
-#define ito64(x) (sizeof(x) == 1) ?   \
- (((unsigned long long int)(x)) & (0xff)) : \
- (sizeof(x) == 2) ?    \
- (((unsigned long long int)(x)) & 0xffff) : \
- ((sizeof(x) == 4) ?    \
-  (((unsigned long long int)(x)) & 0xffffffff) : \
-  (unsigned long long int)(x))
-
-/* increment with wrap-around */
-#define INCR(_l, _sz)   do {   \
-  (_l)++;    \
-  (_l) &= ((_sz) - 1);  \
- } while (0)
-
-/* decrement with wrap-around */
-#define DECR(_l,  _sz)  do {   \
-  (_l)--;    \
-  (_l) &= ((_sz) - 1);  \
- } while (0)
-
-#define TSF_TO_TU(_h,_l) \
- ((((u32)(_h)) << 22) | (((u32)(_l)) >> 10))
-
-#define ATH_TXQ_SETUP(sc, i)        ((sc)->tx.txqsetup & (1<<i))
+extern struct ieee80211_ops ath9k_ops;
+extern int ath9k_modparam_nohwcrypt;
+extern int led_blink;
+extern bool is_ath9k_unloaded;
 
 struct ath_config {
  u16 txpowlimit;
- u8 cabqReadytime;
 };
 
 /*************************/
 /* Descriptor Management */
 /*************************/
 
+#define ATH_TXSTATUS_RING_SIZE 512
+
+/* Macro to expand scalars to 64-bit objects */
+#define ito64(x) (sizeof(x) == 1) ?   \
+ (((unsigned long long int)(x)) & (0xff)) : \
+ (sizeof(x) == 2) ?    \
+ (((unsigned long long int)(x)) & 0xffff) : \
+ ((sizeof(x) == 4) ?    \
+  (((unsigned long long int)(x)) & 0xffffffff) : \
+  (unsigned long long int)(x))
+
 #define ATH_TXBUF_RESET(_bf) do {    \
-  (_bf)->bf_stale = false;   \
   (_bf)->bf_lastbf = NULL;   \
   (_bf)->bf_next = NULL;    \
   memset(&((_bf)->bf_state), 0,   \
          sizeof(struct ath_buf_state));  \
  } while (0)
 
-/**
- * enum buffer_type - Buffer type flags
- *
- * @BUF_AMPDU: This buffer is an ampdu, as part of an aggregate (during TX)
- * @BUF_AGGR: Indicates whether the buffer can be aggregated
- * (used in aggregation scheduling)
- */
-enum buffer_type {
- BUF_AMPDU  = BIT(0),
- BUF_AGGR  = BIT(1),
-};
-
-#define bf_isampdu(bf)  (bf->bf_state.bf_type & BUF_AMPDU)
-#define bf_isaggr(bf)  (bf->bf_state.bf_type & BUF_AGGR)
-
-#define ATH_TXSTATUS_RING_SIZE 512
-
 #define DS2PHYS(_dd, _ds)      \
  ((_dd)->dd_desc_paddr + ((caddr_t)(_ds) - (caddr_t)(_dd)->dd_desc))
 #define ATH_DESC_4KB_BOUND_CHECK(_daddr) ((((_daddr) & 0xFFF) > 0xF7F) ? 1 : 0)
@@ -115,11 +81,20 @@ int ath_descdma_setup(struct ath_softc *sc, struct ath_descdma *dd,
 /* RX / TX */
 /***********/
 
+#define ATH_TXQ_SETUP(sc, i) ((sc)->tx.txqsetup & (1<<i))
+
+/* increment with wrap-around */
+#define INCR(_l, _sz)   do {   \
+  (_l)++;    \
+  (_l) &= ((_sz) - 1);  \
+ } while (0)
+
 #define ATH_RXBUF               512
 #define ATH_TXBUF               512
 #define ATH_TXBUF_RESERVE       5
 #define ATH_MAX_QDEPTH          (ATH_TXBUF / 4 - ATH_TXBUF_RESERVE)
 #define ATH_TXMAXTRY            13
+#define ATH_MAX_SW_RETRIES      30
 
 #define TID_TO_WME_AC(_tid)    \
  ((((_tid) == 0) || ((_tid) == 3)) ? IEEE80211_AC_BE : \
@@ -133,7 +108,14 @@ int ath_descdma_setup(struct ath_softc *sc, struct ath_descdma *dd,
 #define ATH_AGGR_ENCRYPTDELIM      10
 /* minimum h/w qdepth to be sustained to maximize aggregation */
 #define ATH_AGGR_MIN_QDEPTH        2
-#define ATH_AMPDU_SUBFRAME_DEFAULT 32
+/* minimum h/w qdepth for non-aggregated traffic */
+#define ATH_NON_AGGR_MIN_QDEPTH    8
+#define ATH_TX_COMPLETE_POLL_INT   1000
+#define ATH_TXFIFO_DEPTH           8
+#define ATH_TX_ERROR               0x01
+
+/* Stop tx traffic 1ms before the GO goes away */
+#define ATH_P2P_PS_STOP_TIME       1000
 
 #define IEEE80211_SEQ_SEQ_SHIFT    4
 #define IEEE80211_SEQ_MAX          4096
@@ -166,17 +148,15 @@ int ath_descdma_setup(struct ath_softc *sc, struct ath_descdma *dd,
 
 #define ATH_AN_2_TID(_an, _tidno)  (&(_an)->tid[(_tidno)])
 
-#define IS_CCK_RATE(rate) ((rate >= 0x18) && (rate <= 0x1e))
-
-#define ATH_TX_COMPLETE_POLL_INT 1000
+#define IS_HT_RATE(rate)   (rate & 0x80)
+#define IS_CCK_RATE(rate)  ((rate >= 0x18) && (rate <= 0x1e))
+#define IS_OFDM_RATE(rate) ((rate >= 0x8) && (rate <= 0xf))
 
-enum ATH_AGGR_STATUS {
- ATH_AGGR_DONE,
- ATH_AGGR_BAW_CLOSED,
- ATH_AGGR_LIMITED,
+enum {
+       WLAN_RC_PHY_OFDM,
+       WLAN_RC_PHY_CCK,
 };
 
-#define ATH_TXFIFO_DEPTH 8
 struct ath_txq {
  int mac80211_qnum; /* mac80211 queue number, -1 means not mac80211 Q */
  u32 axq_qnum; /* ath9k hardware queue number */
@@ -197,10 +177,10 @@ struct ath_txq {
 
 struct ath_atx_ac {
  struct ath_txq *txq;
- int sched;
  struct list_head list;
  struct list_head tid_q;
  bool clear_ps_filter;
+ bool sched;
 };
 
 struct ath_frame_info {
@@ -208,14 +188,39 @@ struct ath_frame_info {
  int framelen;
  enum ath9k_key_type keytype;
  u8 keyix;
- u8 retries;
  u8 rtscts_rate;
+ u8 retries : 7;
+ u8 baw_tracked : 1;
+};
+
+struct ath_rxbuf {
+ struct list_head list;
+ struct sk_buff *bf_mpdu;
+ void *bf_desc;
+ dma_addr_t bf_daddr;
+ dma_addr_t bf_buf_addr;
+};
+
+/**
+ * enum buffer_type - Buffer type flags
+ *
+ * @BUF_AMPDU: This buffer is an ampdu, as part of an aggregate (during TX)
+ * @BUF_AGGR: Indicates whether the buffer can be aggregated
+ * (used in aggregation scheduling)
+ */
+enum buffer_type {
+ BUF_AMPDU  = BIT(0),
+ BUF_AGGR  = BIT(1),
 };
 
+#define bf_isampdu(bf)  (bf->bf_state.bf_type & BUF_AMPDU)
+#define bf_isaggr(bf)  (bf->bf_state.bf_type & BUF_AGGR)
+
 struct ath_buf_state {
  u8 bf_type;
  u8 bfs_paprd;
  u8 ndelim;
+ bool stale;
  u16 seqno;
  unsigned long bfs_paprd_timestamp;
 };
@@ -229,7 +234,6 @@ struct ath_buf {
  void *bf_desc;   /* virtual addr of desc */
  dma_addr_t bf_daddr;  /* physical addr of desc */
  dma_addr_t bf_buf_addr; /* physical addr of data buffer, for DMA */
- bool bf_stale;
  struct ieee80211_tx_rate rates[4];
  struct ath_buf_state bf_state;
 };
@@ -237,18 +241,19 @@ struct ath_buf {
 struct ath_atx_tid {
  struct list_head list;
  struct sk_buff_head buf_q;
+ struct sk_buff_head retry_q;
  struct ath_node *an;
  struct ath_atx_ac *ac;
  unsigned long tx_buf[BITS_TO_LONGS(ATH_TID_MAX_BUFS)];
- int bar_index;
  u16 seq_start;
  u16 seq_next;
  u16 baw_size;
- int tidno;
+ u8 tidno;
  int baw_head;   /* first un-acked tx buffer */
  int baw_tail;   /* next unused tx buffer slot */
+
+ s8 bar_index;
  bool sched;
- bool paused;
  bool active;
 };
 
@@ -258,16 +263,18 @@ struct ath_node {
  struct ieee80211_vif *vif; /* interface with which we're associated */
  struct ath_atx_tid tid[IEEE80211_NUM_TIDS];
  struct ath_atx_ac ac[IEEE80211_NUM_ACS];
- int ps_key;
 
  u16 maxampdu;
  u8 mpdudensity;
+ s8 ps_key;
 
  bool sleeping;
+ bool no_ps_filter;
 
-#if defined(CONFIG_MAC80211_DEBUGFS) && defined(CONFIG_ATH9K_DEBUGFS)
- struct dentry *node_stat;
+#ifdef CONFIG_ATH9K_STATION_STATISTICS
+ struct ath_rx_rate_stats rx_rate_stats;
 #endif
+ u8 key_idx[4];
 };
 
 struct ath_tx_control {
@@ -277,7 +284,6 @@ struct ath_tx_control {
  struct ieee80211_sta *sta;
 };
 
-#define ATH_TX_ERROR        0x01
 
 /**
  * @txq_map:  Index is mac80211 queue number.  This is
@@ -292,6 +298,7 @@ struct ath_tx {
  struct ath_txq txq[ATH9K_NUM_TX_QUEUES];
  struct ath_descdma txdma;
  struct ath_txq *txq_map[IEEE80211_NUM_ACS];
+ struct ath_txq *uapsdq;
  u32 txq_max_pending[IEEE80211_NUM_ACS];
  u16 max_aggr_framelen[IEEE80211_NUM_ACS][4][32];
 };
@@ -312,7 +319,7 @@ struct ath_rx {
  struct ath_descdma rxdma;
  struct ath_rx_edma rx_edma[ATH9K_RX_QUEUE_MAX];
 
- struct ath_buf *buf_hold;
+ struct ath_rxbuf *buf_hold;
  struct sk_buff *frag;
 
  u32 ampdu_ref;
@@ -340,6 +347,8 @@ int ath_txq_update(struct ath_softc *sc, int qnum,
 void ath_update_max_aggr_framelen(struct ath_softc *sc, int queue, int txop);
 int ath_tx_start(struct ieee80211_hw *hw, struct sk_buff *skb,
    struct ath_tx_control *txctl);
+void ath_tx_cabq(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
+   struct sk_buff *skb);
 void ath_tx_tasklet(struct ath_softc *sc);
 void ath_tx_edma_tasklet(struct ath_softc *sc);
 int ath_tx_aggr_start(struct ath_softc *sc, struct ieee80211_sta *sta,
@@ -350,18 +359,44 @@ void ath_tx_aggr_resume(struct ath_softc *sc, struct ieee80211_sta *sta, u16 tid
 void ath_tx_aggr_wakeup(struct ath_softc *sc, struct ath_node *an);
 void ath_tx_aggr_sleep(struct ieee80211_sta *sta, struct ath_softc *sc,
          struct ath_node *an);
+void ath9k_release_buffered_frames(struct ieee80211_hw *hw,
+       struct ieee80211_sta *sta,
+       u16 tids, int nframes,
+       enum ieee80211_frame_release_type reason,
+       bool more_data);
 
 /********/
 /* VIFs */
 /********/
 
 struct ath_vif {
+ struct ieee80211_vif *vif;
+ struct ath_node mcast_node;
  int av_bslot;
  bool primary_sta_vif;
  __le64 tsf_adjust; /* TSF adjustment for staggered beacons */
  struct ath_buf *av_bcbuf;
+
+ /* P2P Client */
+ struct ieee80211_noa_data noa;
+};
+
+struct ath9k_vif_iter_data {
+ u8 hw_macaddr[ETH_ALEN]; /* address of the first vif */
+ u8 mask[ETH_ALEN]; /* bssid mask */
+ bool has_hw_macaddr;
+
+ int naps;      /* number of AP vifs */
+ int nmeshes;   /* number of mesh vifs */
+ int nstations; /* number of station vifs */
+ int nwds;      /* number of WDS vifs */
+ int nadhocs;   /* number of adhoc vifs */
 };
 
+void ath9k_calculate_iter_data(struct ieee80211_hw *hw,
+          struct ieee80211_vif *vif,
+          struct ath9k_vif_iter_data *iter_data);
+
 /*******************/
 /* Beacon Handling */
 /*******************/
@@ -375,17 +410,9 @@ struct ath_vif {
 #define ATH_BCBUF                8
 #define ATH_DEFAULT_BINTVAL      100 /* TU */
 #define ATH_DEFAULT_BMISS_LIMIT  10
-#define IEEE80211_MS_TO_TU(x)           (((x) * 1000) / 1024)
-
-struct ath_beacon_config {
- int beacon_interval;
- u16 listen_interval;
- u16 dtim_period;
- u16 bmiss_timeout;
- u8 dtim_count;
- bool enable_beacon;
- bool ibss_creator;
-};
+
+#define TSF_TO_TU(_h,_l) \
+ ((((u32)(_h)) << 22) | (((u32)(_l)) >> 10))
 
 struct ath_beacon {
  enum {
@@ -396,11 +423,9 @@ struct ath_beacon {
 
  u32 beaconq;
  u32 bmisscnt;
- u32 bc_tstamp;
  struct ieee80211_vif *bslot[ATH_BCBUF];
  int slottime;
  int slotupdate;
- struct ath9k_tx_queue_info beacon_qi;
  struct ath_descdma bdma;
  struct ath_txq *cabq;
  struct list_head bbuf;
@@ -410,13 +435,13 @@ struct ath_beacon {
 };
 
 void ath9k_beacon_tasklet(unsigned long data);
-bool ath9k_allow_beacon_config(struct ath_softc *sc, struct ieee80211_vif *vif);
 void ath9k_beacon_config(struct ath_softc *sc, struct ieee80211_vif *vif,
     u32 changed);
 void ath9k_beacon_assign_slot(struct ath_softc *sc, struct ieee80211_vif *vif);
 void ath9k_beacon_remove_slot(struct ath_softc *sc, struct ieee80211_vif *vif);
-void ath9k_set_tsfadjust(struct ath_softc *sc, struct ieee80211_vif *vif);
 void ath9k_set_beacon(struct ath_softc *sc);
+bool ath9k_csa_is_finished(struct ath_softc *sc, struct ieee80211_vif *vif);
+void ath9k_csa_update(struct ath_softc *sc);
 
 /*******************/
 /* Link Monitoring */
@@ -429,17 +454,14 @@ void ath9k_set_beacon(struct ath_softc *sc);
 #define ATH_LONG_CALINTERVAL_INT  1000    /* 1000 ms */
 #define ATH_LONG_CALINTERVAL      30000   /* 30 seconds */
 #define ATH_RESTART_CALINTERVAL   1200000 /* 20 minutes */
-#define ATH_ANI_MAX_SKIP_COUNT  10
-
-#define ATH_PAPRD_TIMEOUT 100 /* msecs */
-#define ATH_PLL_WORK_INTERVAL   100
+#define ATH_ANI_MAX_SKIP_COUNT    10
+#define ATH_PAPRD_TIMEOUT         100 /* msecs */
+#define ATH_PLL_WORK_INTERVAL     100
 
 void ath_tx_complete_poll_work(struct work_struct *work);
 void ath_reset_work(struct work_struct *work);
-void ath_hw_check(struct work_struct *work);
+bool ath_hw_check(struct ath_softc *sc);
 void ath_hw_pll_work(struct work_struct *work);
-void ath_rx_poll(unsigned long data);
-void ath_start_rx_poll(struct ath_softc *sc, u8 nbeacon);
 void ath_paprd_calibrate(struct work_struct *work);
 void ath_ani_calibrate(unsigned long data);
 void ath_start_ani(struct ath_softc *sc);
@@ -448,6 +470,9 @@ void ath_check_ani(struct ath_softc *sc);
 int ath_update_survey_stats(struct ath_softc *sc);
 void ath_update_survey_nf(struct ath_softc *sc, int channel);
 void ath9k_queue_reset(struct ath_softc *sc, enum ath_reset_type type);
+void ath_ps_full_sleep(unsigned long data);
+void ath9k_p2p_ps_timer(void *priv);
+void ath9k_update_p2p_ps(struct ath_softc *sc, struct ieee80211_vif *vif);
 
 /**********/
 /* BTCOEX */
@@ -455,8 +480,8 @@ void ath9k_queue_reset(struct ath_softc *sc, enum ath_reset_type type);
 
 #define ATH_DUMP_BTCOEX(_s, _val)    \
  do {       \
-  len += snprintf(buf + len, size - len,  \
-    "%20s : %10d\n", _s, (_val)); \
+  len += scnprintf(buf + len, size - len,  \
+     "%20s : %10d\n", _s, (_val)); \
  } while (0)
 
 enum bt_op_flags {
@@ -465,20 +490,19 @@ enum bt_op_flags {
 };
 
 struct ath_btcoex {
- bool hw_timer_enabled;
  spinlock_t btcoex_lock;
  struct timer_list period_timer; /* Timer for BT period */
+ struct timer_list no_stomp_timer;
  u32 bt_priority_cnt;
  unsigned long bt_priority_time;
  unsigned long op_flags;
  int bt_stomp_type; /* Types of BT stomping */
- u32 btcoex_no_stomp; /* in usec */
+ u32 btcoex_no_stomp; /* in msec */
  u32 btcoex_period; /* in msec */
- u32 btscan_no_stomp; /* in usec */
+ u32 btscan_no_stomp; /* in msec */
  u32 duty_cycle;
  u32 bt_wait_time;
  int rssi_count;
- struct ath_gen_timer *no_stomp_timer; /* Timer for no BT stomping */
  struct ath_mci_profile mci;
  u8 stomp_audio;
 };
@@ -526,12 +550,6 @@ static inline int ath9k_dump_btcoex(struct ath_softc *sc, u8 *buf, u32 size)
 }
 #endif /* CONFIG_ATH9K_BTCOEX_SUPPORT */
 
-struct ath9k_wow_pattern {
- u8 pattern_bytes[MAX_PATTERN_SIZE];
- u8 mask_bytes[MAX_PATTERN_SIZE];
- u32 pattern_len;
-};
-
 /********************/
 /*   LED Control    */
 /********************/
@@ -559,6 +577,40 @@ static inline void ath_fill_led_pin(struct ath_softc *sc)
 }
 #endif
 
+/************************/
+/* Wake on Wireless LAN */
+/************************/
+
+struct ath9k_wow_pattern {
+ u8 pattern_bytes[MAX_PATTERN_SIZE];
+ u8 mask_bytes[MAX_PATTERN_SIZE];
+ u32 pattern_len;
+};
+
+#ifdef CONFIG_ATH9K_WOW
+void ath9k_init_wow(struct ieee80211_hw *hw);
+int ath9k_suspend(struct ieee80211_hw *hw,
+    struct cfg80211_wowlan *wowlan);
+int ath9k_resume(struct ieee80211_hw *hw);
+void ath9k_set_wakeup(struct ieee80211_hw *hw, bool enabled);
+#else
+static inline void ath9k_init_wow(struct ieee80211_hw *hw)
+{
+}
+static inline int ath9k_suspend(struct ieee80211_hw *hw,
+    struct cfg80211_wowlan *wowlan)
+{
+ return 0;
+}
+static inline int ath9k_resume(struct ieee80211_hw *hw)
+{
+ return 0;
+}
+static inline void ath9k_set_wakeup(struct ieee80211_hw *hw, bool enabled)
+{
+}
+#endif /* CONFIG_ATH9K_WOW */
+
 /*******************************/
 /* Antenna diversity/combining */
 /*******************************/
@@ -574,19 +626,13 @@ static inline void ath_fill_led_pin(struct ath_softc *sc)
 #define ATH_ANT_DIV_COMB_MAX_COUNT 100
 #define ATH_ANT_DIV_COMB_ALT_ANT_RATIO 30
 #define ATH_ANT_DIV_COMB_ALT_ANT_RATIO2 20
+#define ATH_ANT_DIV_COMB_ALT_ANT_RATIO_LOW_RSSI 50
+#define ATH_ANT_DIV_COMB_ALT_ANT_RATIO2_LOW_RSSI 50
 
-#define ATH_ANT_DIV_COMB_LNA1_LNA2_SWITCH_DELTA -1
 #define ATH_ANT_DIV_COMB_LNA1_DELTA_HI -4
 #define ATH_ANT_DIV_COMB_LNA1_DELTA_MID -2
 #define ATH_ANT_DIV_COMB_LNA1_DELTA_LOW 2
 
-enum ath9k_ant_div_comb_lna_conf {
- ATH_ANT_DIV_COMB_LNA1_MINUS_LNA2,
- ATH_ANT_DIV_COMB_LNA2,
- ATH_ANT_DIV_COMB_LNA1,
- ATH_ANT_DIV_COMB_LNA1_PLUS_LNA2,
-};
-
 struct ath_ant_comb {
  u16 count;
  u16 total_pkt_count;
@@ -603,45 +649,50 @@ struct ath_ant_comb {
  int rssi_first;
  int rssi_second;
  int rssi_third;
+ int ant_ratio;
+ int ant_ratio2;
  bool alt_good;
  int quick_scan_cnt;
- int main_conf;
+ enum ath9k_ant_div_comb_lna_conf main_conf;
  enum ath9k_ant_div_comb_lna_conf first_quick_scan_conf;
  enum ath9k_ant_div_comb_lna_conf second_quick_scan_conf;
  bool first_ratio;
  bool second_ratio;
  unsigned long scan_start_time;
+
+ /*
+  * Card-specific config values.
+  */
+ int low_rssi_thresh;
+ int fast_div_bias;
 };
 
 void ath_ant_comb_scan(struct ath_softc *sc, struct ath_rx_status *rs);
-void ath_ant_comb_update(struct ath_softc *sc);
 
 /********************/
 /* Main driver core */
 /********************/
 
-#define ATH9K_PCI_CUS198 0x0001
+#define ATH9K_PCI_CUS198          0x0001
+#define ATH9K_PCI_CUS230          0x0002
+#define ATH9K_PCI_CUS217          0x0004
+#define ATH9K_PCI_CUS252          0x0008
+#define ATH9K_PCI_WOW             0x0010
+#define ATH9K_PCI_BT_ANT_DIV      0x0020
+#define ATH9K_PCI_D3_L1_WAR       0x0040
+#define ATH9K_PCI_AR9565_1ANT     0x0080
+#define ATH9K_PCI_AR9565_2ANT     0x0100
+#define ATH9K_PCI_NO_PLL_PWRSAVE  0x0200
+#define ATH9K_PCI_KILLER          0x0400
 
 /*
  * Default cache line size, in bytes.
  * Used when PCI device not fully initialized by bootrom/BIOS
 */
 #define DEFAULT_CACHELINE       32
-#define ATH_REGCLASSIDS_MAX     10
 #define ATH_CABQ_READY_TIME     80      /* % of beacon interval */
-#define ATH_MAX_SW_RETRIES      30
-#define ATH_CHAN_MAX            255
-
 #define ATH_TXPOWER_MAX         100     /* .5 dBm units */
-#define ATH_RATE_DUMMY_MARKER   0
-
-enum sc_op_flags {
- SC_OP_INVALID,
- SC_OP_BEACONS,
- SC_OP_ANI_RUN,
- SC_OP_PRIM_STA_VIF,
- SC_OP_HW_RESET,
-};
+#define MAX_GTT_CNT             5
 
 /* Powersave flags */
 #define PS_WAIT_FOR_BEACON        BIT(0)
@@ -651,37 +702,6 @@ enum sc_op_flags {
 #define PS_BEACON_SYNC            BIT(4)
 #define PS_WAIT_FOR_ANI           BIT(5)
 
-struct ath_rate_table;
-
-struct ath9k_vif_iter_data {
- u8 hw_macaddr[ETH_ALEN]; /* address of the first vif */
- u8 mask[ETH_ALEN]; /* bssid mask */
- bool has_hw_macaddr;
-
- int naps;      /* number of AP vifs */
- int nmeshes;   /* number of mesh vifs */
- int nstations; /* number of station vifs */
- int nwds;      /* number of WDS vifs */
- int nadhocs;   /* number of adhoc vifs */
-};
-
-/* enum spectral_mode:
- *
- * @SPECTRAL_DISABLED: spectral mode is disabled
- * @SPECTRAL_BACKGROUND: hardware sends samples when it is not busy with
- * something else.
- * @SPECTRAL_MANUAL: spectral scan is enabled, triggering for samples
- * is performed manually.
- * @SPECTRAL_CHANSCAN: Like manual, but also triggered when changing channels
- * during a channel scan.
- */
-enum spectral_mode {
- SPECTRAL_DISABLED = 0,
- SPECTRAL_BACKGROUND,
- SPECTRAL_MANUAL,
- SPECTRAL_CHANSCAN,
-};
-
 struct ath_softc {
  struct ieee80211_hw *hw;
  struct device *dev;
@@ -699,14 +719,16 @@ struct ath_softc {
  spinlock_t sc_pcu_lock;
  struct mutex mutex;
  struct work_struct paprd_work;
- struct work_struct hw_check_work;
  struct work_struct hw_reset_work;
  struct completion paprd_complete;
+ wait_queue_head_t tx_wait;
+
+ struct ath_gen_timer *p2p_ps_timer;
+ struct ath_vif *p2p_ps_vif;
 
- unsigned int hw_busy_count;
- unsigned long sc_flags;
  unsigned long driver_data;
 
+ u8 gtt_cnt;
  u32 intrstatus;
  u16 ps_flags; /* PS_* */
  u16 curtxpow;
@@ -720,7 +742,6 @@ struct ath_softc {
  struct ath_rx rx;
  struct ath_tx tx;
  struct ath_beacon beacon;
- struct ieee80211_supported_band sbands[IEEE80211_NUM_BANDS];
 
 #ifdef CONFIG_MAC80211_LEDS
  bool led_registered;
@@ -729,7 +750,6 @@ struct ath_softc {
 #endif
 
  struct ath9k_hw_cal_data caldata;
- int last_rssi;
 
 #ifdef CONFIG_ATH9K_DEBUGFS
  struct ath9k_debug debug;
@@ -737,7 +757,7 @@ struct ath_softc {
  struct ath_beacon_config cur_beacon_conf;
  struct delayed_work tx_complete_work;
  struct delayed_work hw_pll_work;
- struct timer_list rx_poll_timer;
+ struct timer_list sleep_timer;
 
 #ifdef CONFIG_ATH9K_BTCOEX_SUPPORT
  struct ath_btcoex btcoex;
@@ -750,173 +770,66 @@ struct ath_softc {
  struct ath_ant_comb ant_comb;
  u8 ant_tx, ant_rx;
  struct dfs_pattern_detector *dfs_detector;
+ u64 dfs_prev_pulse_ts;
  u32 wow_enabled;
  /* relay(fs) channel for spectral scan */
  struct rchan *rfs_chan_spec_scan;
  enum spectral_mode spectral_mode;
  struct ath_spec_scan spec_config;
- int scanning;
 
-#ifdef CONFIG_PM_SLEEP
+ struct ieee80211_vif *tx99_vif;
+ struct sk_buff *tx99_skb;
+ bool tx99_state;
+ s16 tx99_power;
+
+#ifdef CONFIG_ATH9K_WOW
  atomic_t wow_got_bmiss_intr;
  atomic_t wow_sleep_proc_intr; /* in the middle of WoW sleep ? */
  u32 wow_intr_before_sleep;
 #endif
 };
 
-#define SPECTRAL_SCAN_BITMASK  0x10
-/* Radar info packet format, used for DFS and spectral formats. */
-struct ath_radar_info {
- u8 pulse_length_pri;
- u8 pulse_length_ext;
- u8 pulse_bw_info;
-} __packed;
-
-/* The HT20 spectral data has 4 bytes of additional information at it's end.
- *
- * [7:0]: all bins {max_magnitude[1:0], bitmap_weight[5:0]}
- * [7:0]: all bins  max_magnitude[9:2]
- * [7:0]: all bins {max_index[5:0], max_magnitude[11:10]}
- * [3:0]: max_exp (shift amount to size max bin to 8-bit unsigned)
- */
-struct ath_ht20_mag_info {
- u8 all_bins[3];
- u8 max_exp;
-} __packed;
-
-#define SPECTRAL_HT20_NUM_BINS  56
-
-/* WARNING: don't actually use this struct! MAC may vary the amount of
- * data by -1/+2. This struct is for reference only.
- */
-struct ath_ht20_fft_packet {
- u8 data[SPECTRAL_HT20_NUM_BINS];
- struct ath_ht20_mag_info mag_info;
- struct ath_radar_info radar_info;
-} __packed;
-
-#define SPECTRAL_HT20_TOTAL_DATA_LEN (sizeof(struct ath_ht20_fft_packet))
-
-/* Dynamic 20/40 mode:
- *
- * [7:0]: lower bins {max_magnitude[1:0], bitmap_weight[5:0]}
- * [7:0]: lower bins  max_magnitude[9:2]
- * [7:0]: lower bins {max_index[5:0], max_magnitude[11:10]}
- * [7:0]: upper bins {max_magnitude[1:0], bitmap_weight[5:0]}
- * [7:0]: upper bins  max_magnitude[9:2]
- * [7:0]: upper bins {max_index[5:0], max_magnitude[11:10]}
- * [3:0]: max_exp (shift amount to size max bin to 8-bit unsigned)
- */
-struct ath_ht20_40_mag_info {
- u8 lower_bins[3];
- u8 upper_bins[3];
- u8 max_exp;
-} __packed;
-
-#define SPECTRAL_HT20_40_NUM_BINS  128
-
-/* WARNING: don't actually use this struct! MAC may vary the amount of
- * data. This struct is for reference only.
- */
-struct ath_ht20_40_fft_packet {
- u8 data[SPECTRAL_HT20_40_NUM_BINS];
- struct ath_ht20_40_mag_info mag_info;
- struct ath_radar_info radar_info;
-} __packed;
-
-
-#define SPECTRAL_HT20_40_TOTAL_DATA_LEN (sizeof(struct ath_ht20_40_fft_packet))
-
-/* grabs the max magnitude from the all/upper/lower bins */
-static inline u16 spectral_max_magnitude(u8 *bins)
-{
- return (bins[0] & 0xc0) >> 6 |
-        (bins[1] & 0xff) << 2 |
-        (bins[2] & 0x03) << 10;
-}
+/********/
+/* TX99 */
+/********/
 
-/* return the max magnitude from the all/upper/lower bins */
-static inline u8 spectral_max_index(u8 *bins)
+#ifdef CONFIG_ATH9K_TX99
+void ath9k_tx99_init_debug(struct ath_softc *sc);
+int ath9k_tx99_send(struct ath_softc *sc, struct sk_buff *skb,
+      struct ath_tx_control *txctl);
+#else
+static inline void ath9k_tx99_init_debug(struct ath_softc *sc)
 {
- s8 m = (bins[2] & 0xfc) >> 2;
-
- /* TODO: this still doesn't always report the right values ... */
- if (m > 32)
-  m |= 0xe0;
- else
-  m &= ~0xe0;
-
- return m + 29;
 }
-
-/* return the bitmap weight from the all/upper/lower bins */
-static inline u8 spectral_bitmap_weight(u8 *bins)
+static inline int ath9k_tx99_send(struct ath_softc *sc,
+      struct sk_buff *skb,
+      struct ath_tx_control *txctl)
 {
- return bins[0] & 0x3f;
+ return 0;
 }
-
-/* FFT sample format given to userspace via debugfs.
- *
- * Please keep the type/length at the front position and change
- * other fields after adding another sample type
- *
- * TODO: this might need rework when switching to nl80211-based
- * interface.
- */
-enum ath_fft_sample_type {
- ATH_FFT_SAMPLE_HT20 = 1,
-};
-
-struct fft_sample_tlv {
- u8 type; /* see ath_fft_sample */
- __be16 length;
- /* type dependent data follows */
-} __packed;
-
-struct fft_sample_ht20 {
- struct fft_sample_tlv tlv;
-
- u8 max_exp;
-
- __be16 freq;
- s8 rssi;
- s8 noise;
-
- __be16 max_magnitude;
- u8 max_index;
- u8 bitmap_weight;
-
- __be64 tsf;
-
- u8 data[SPECTRAL_HT20_NUM_BINS];
-} __packed;
-
-void ath9k_tasklet(unsigned long data);
-int ath_cabq_update(struct ath_softc *);
+#endif /* CONFIG_ATH9K_TX99 */
 
 static inline void ath_read_cachesize(struct ath_common *common, int *csz)
 {
  common->bus_ops->read_cachesize(common, csz);
 }
 
-extern struct ieee80211_ops ath9k_ops;
-extern int ath9k_modparam_nohwcrypt;
-extern int led_blink;
-extern bool is_ath9k_unloaded;
-
+void ath9k_tasklet(unsigned long data);
+int ath_cabq_update(struct ath_softc *);
 u8 ath9k_parse_mpdudensity(u8 mpdudensity);
 irqreturn_t ath_isr(int irq, void *dev);
+int ath_reset(struct ath_softc *sc);
+void ath_cancel_work(struct ath_softc *sc);
+void ath_restart_work(struct ath_softc *sc);
 int ath9k_init_device(u16 devid, struct ath_softc *sc,
       const struct ath_bus_ops *bus_ops);
 void ath9k_deinit_device(struct ath_softc *sc);
-void ath9k_set_hw_capab(struct ath_softc *sc, struct ieee80211_hw *hw);
 void ath9k_reload_chainmask_settings(struct ath_softc *sc);
-
-bool ath9k_uses_beacons(int type);
-void ath9k_spectral_scan_trigger(struct ieee80211_hw *hw);
-int ath9k_spectral_scan_config(struct ieee80211_hw *hw,
-          enum spectral_mode spectral_mode);
-
+u8 ath_txchainmask_reduction(struct ath_softc *sc, u8 chainmask, u32 rate);
+void ath_start_rfkill_poll(struct ath_softc *sc);
+void ath9k_rfkill_poll_state(struct ieee80211_hw *hw);
+void ath9k_ps_wakeup(struct ath_softc *sc);
+void ath9k_ps_restore(struct ath_softc *sc);
 
 #ifdef CONFIG_ATH9K_PCI
 int ath_pci_init(void);
@@ -934,15 +847,4 @@ static inline int ath_ahb_init(void) { return 0; };
 static inline void ath_ahb_exit(void) {};
 #endif
 
-void ath9k_ps_wakeup(struct ath_softc *sc);
-void ath9k_ps_restore(struct ath_softc *sc);
-
-u8 ath_txchainmask_reduction(struct ath_softc *sc, u8 chainmask, u32 rate);
-
-void ath_start_rfkill_poll(struct ath_softc *sc);
-extern void ath9k_rfkill_poll_state(struct ieee80211_hw *hw);
-void ath9k_calculate_iter_data(struct ieee80211_hw *hw,
-          struct ieee80211_vif *vif,
-          struct ath9k_vif_iter_data *iter_data);
-
 #endif /* ATH9K_H */
diff --git a/drivers/net/wireless/ath/ath9k/beacon.c b/drivers/net/wireless/ath/ath9k/beacon.c
index 2ff570f..e387f0b 100644
--- a/drivers/net/wireless/ath/ath9k/beacon.c
+++ b/drivers/net/wireless/ath/ath9k/beacon.c
@@ -39,7 +39,8 @@ static void ath9k_beaconq_config(struct ath_softc *sc)
 
  ath9k_hw_get_txq_props(ah, sc->beacon.beaconq, &qi);
 
- if (sc->sc_ah->opmode == NL80211_IFTYPE_AP) {
+ if (sc->sc_ah->opmode == NL80211_IFTYPE_AP ||
+     sc->sc_ah->opmode == NL80211_IFTYPE_MESH_POINT) {
   /* Always burst out beacon and CAB traffic. */
   qi.tqi_aifs = 1;
   qi.tqi_cwmin = 0;
@@ -79,7 +80,7 @@ static void ath9k_beacon_setup(struct ath_softc *sc, struct ieee80211_vif *vif,
  u8 chainmask = ah->txchainmask;
  u8 rate = 0;
 
- sband = &sc->sbands[common->hw->conf.chandef.chan->band];
+ sband = &common->sbands[common->hw->conf.chandef.chan->band];
  rate = sband->bitrates[rateidx].hw_value;
  if (vif->bss_conf.use_short_preamble)
   rate |= sband->bitrates[rateidx].hw_value_short;
@@ -107,23 +108,6 @@ static void ath9k_beacon_setup(struct ath_softc *sc, struct ieee80211_vif *vif,
  ath9k_hw_set_txdesc(ah, bf->bf_desc, &info);
 }
 
-static void ath9k_tx_cabq(struct ieee80211_hw *hw, struct sk_buff *skb)
-{
- struct ath_softc *sc = hw->priv;
- struct ath_common *common = ath9k_hw_common(sc->sc_ah);
- struct ath_tx_control txctl;
-
- memset(&txctl, 0, sizeof(struct ath_tx_control));
- txctl.txq = sc->beacon.cabq;
-
- ath_dbg(common, XMIT, "transmitting CABQ packet, skb: %p\n", skb);
-
- if (ath_tx_start(hw, skb, &txctl) != 0) {
-  ath_dbg(common, XMIT, "CABQ TX failed\n");
-  ieee80211_free_txskb(hw, skb);
- }
-}
-
 static struct ath_buf *ath9k_beacon_generate(struct ieee80211_hw *hw,
           struct ieee80211_vif *vif)
 {
@@ -205,10 +189,8 @@ static struct ath_buf *ath9k_beacon_generate(struct ieee80211_hw *hw,
 
  ath9k_beacon_setup(sc, vif, bf, info->control.rates[0].idx);
 
- while (skb) {
-  ath9k_tx_cabq(hw, skb);
-  skb = ieee80211_get_buffered_bc(hw, vif);
- }
+ if (skb)
+  ath_tx_cabq(hw, vif, skb);
 
  return bf;
 }
@@ -273,7 +255,8 @@ static int ath9k_beacon_choose_slot(struct ath_softc *sc)
  u64 tsf;
  int slot;
 
- if (sc->sc_ah->opmode != NL80211_IFTYPE_AP) {
+ if (sc->sc_ah->opmode != NL80211_IFTYPE_AP &&
+     sc->sc_ah->opmode != NL80211_IFTYPE_MESH_POINT) {
   ath_dbg(common, BEACON, "slot 0, tsf: %llu\n",
    ath9k_hw_gettsf64(sc->sc_ah));
   return 0;
@@ -291,23 +274,49 @@ static int ath9k_beacon_choose_slot(struct ath_softc *sc)
  return slot;
 }
 
-void ath9k_set_tsfadjust(struct ath_softc *sc, struct ieee80211_vif *vif)
+static void ath9k_set_tsfadjust(struct ath_softc *sc, struct ieee80211_vif *vif)
 {
  struct ath_common *common = ath9k_hw_common(sc->sc_ah);
  struct ath_beacon_config *cur_conf = &sc->cur_beacon_conf;
  struct ath_vif *avp = (void *)vif->drv_priv;
- u64 tsfadjust;
+ u32 tsfadjust;
 
  if (avp->av_bslot == 0)
   return;
 
- tsfadjust = cur_conf->beacon_interval * avp->av_bslot / ATH_BCBUF;
- avp->tsf_adjust = cpu_to_le64(TU_TO_USEC(tsfadjust));
+ tsfadjust = cur_conf->beacon_interval * avp->av_bslot;
+ tsfadjust = TU_TO_USEC(tsfadjust) / ATH_BCBUF;
+ avp->tsf_adjust = cpu_to_le64(tsfadjust);
 
  ath_dbg(common, CONFIG, "tsfadjust is: %llu for bslot: %d\n",
   (unsigned long long)tsfadjust, avp->av_bslot);
 }
 
+bool ath9k_csa_is_finished(struct ath_softc *sc, struct ieee80211_vif *vif)
+{
+ if (!vif || !vif->csa_active)
+  return false;
+
+ if (!ieee80211_csa_is_complete(vif))
+  return false;
+
+ ieee80211_csa_finish(vif);
+ return true;
+}
+
+static void ath9k_csa_update_vif(void *data, u8 *mac, struct ieee80211_vif *vif)
+{
+ struct ath_softc *sc = data;
+ ath9k_csa_is_finished(sc, vif);
+}
+
+void ath9k_csa_update(struct ath_softc *sc)
+{
+ ieee80211_iterate_active_interfaces_atomic(sc->hw,
+         IEEE80211_IFACE_ITER_NORMAL,
+         ath9k_csa_update_vif, sc);
+}
+
 void ath9k_beacon_tasklet(unsigned long data)
 {
  struct ath_softc *sc = (struct ath_softc *)data;
@@ -318,7 +327,7 @@ void ath9k_beacon_tasklet(unsigned long data)
  bool edma = !!(ah->caps.hw_caps & ATH9K_HW_CAP_EDMA);
  int slot;
 
- if (test_bit(SC_OP_HW_RESET, &sc->sc_flags)) {
+ if (test_bit(ATH_OP_HW_RESET, &common->op_flags)) {
   ath_dbg(common, RESET,
    "reset work is pending, skip beaconing now\n");
   return;
@@ -334,8 +343,16 @@ void ath9k_beacon_tasklet(unsigned long data)
  if (ath9k_hw_numtxpending(ah, sc->beacon.beaconq) != 0) {
   sc->beacon.bmisscnt++;
 
-  if (!ath9k_hw_check_alive(ah))
-   ieee80211_queue_work(sc->hw, &sc->hw_check_work);
+  ath9k_hw_check_nav(ah);
+
+  /*
+   * If the previous beacon has not been transmitted
+   * and a MAC/BB hang has been identified, return
+   * here because a chip reset would have been
+   * initiated.
+   */
+  if (!ath_hw_check(sc))
+   return;
 
   if (sc->beacon.bmisscnt < BSTUCK_THRESH * sc->nbcnvifs) {
    ath_dbg(common, BSTUCK,
@@ -356,6 +373,10 @@ void ath9k_beacon_tasklet(unsigned long data)
  slot = ath9k_beacon_choose_slot(sc);
  vif = sc->beacon.bslot[slot];
 
+ /* EDMA devices check that in the tx completion function. */
+ if (!edma && ath9k_csa_is_finished(sc, vif))
+  return;
+
  if (!vif || !vif->bss_conf.enable_beacon)
   return;
 
@@ -434,146 +455,18 @@ static void ath9k_beacon_config_ap(struct ath_softc *sc,
        struct ath_beacon_config *conf)
 {
  struct ath_hw *ah = sc->sc_ah;
- struct ath_common *common = ath9k_hw_common(ah);
- u32 nexttbtt, intval;
-
- /* NB: the beacon interval is kept internally in TU's */
- intval = TU_TO_USEC(conf->beacon_interval);
- intval /= ATH_BCBUF;
- nexttbtt = intval;
-
- if (conf->enable_beacon)
-  ah->imask |= ATH9K_INT_SWBA;
- else
-  ah->imask &= ~ATH9K_INT_SWBA;
 
- ath_dbg(common, BEACON,
-  "AP (%s) nexttbtt: %u intval: %u conf_intval: %u\n",
-  (conf->enable_beacon) ? "Enable" : "Disable",
-  nexttbtt, intval, conf->beacon_interval);
-
- ath9k_beacon_init(sc, nexttbtt, intval, true);
+ ath9k_cmn_beacon_config_ap(ah, conf, ATH_BCBUF);
+ ath9k_beacon_init(sc, conf->nexttbtt, conf->intval, false);
 }
 
-/*
- * This sets up the beacon timers according to the timestamp of the last
- * received beacon and the current TSF, configures PCF and DTIM
- * handling, programs the sleep registers so the hardware will wakeup in
- * time to receive beacons, and configures the beacon miss handling so
- * we'll receive a BMISS interrupt when we stop seeing beacons from the AP
- * we've associated with.
- */
-static void ath9k_beacon_config_sta(struct ath_softc *sc,
+static void ath9k_beacon_config_sta(struct ath_hw *ah,
         struct ath_beacon_config *conf)
 {
- struct ath_hw *ah = sc->sc_ah;
- struct ath_common *common = ath9k_hw_common(ah);
  struct ath9k_beacon_state bs;
- int dtimperiod, dtimcount, sleepduration;
- int cfpperiod, cfpcount;
- u32 nexttbtt = 0, intval, tsftu;
- u64 tsf;
- int num_beacons, offset, dtim_dec_count, cfp_dec_count;
 
- /* No need to configure beacon if we are not associated */
- if (!test_bit(SC_OP_PRIM_STA_VIF, &sc->sc_flags)) {
-  ath_dbg(common, BEACON,
-   "STA is not yet associated..skipping beacon config\n");
+ if (ath9k_cmn_beacon_config_sta(ah, conf, &bs) == -EPERM)
   return;
- }
-
- memset(&bs, 0, sizeof(bs));
- intval = conf->beacon_interval;
-
- /*
-  * Setup dtim and cfp parameters according to
-  * last beacon we received (which may be none).
-  */
- dtimperiod = conf->dtim_period;
- dtimcount = conf->dtim_count;
- if (dtimcount >= dtimperiod) /* NB: sanity check */
-  dtimcount = 0;
- cfpperiod = 1;   /* NB: no PCF support yet */
- cfpcount = 0;
-
- sleepduration = conf->listen_interval * intval;
-
- /*
-  * Pull nexttbtt forward to reflect the current
-  * TSF and calculate dtim+cfp state for the result.
-  */
- tsf = ath9k_hw_gettsf64(ah);
- tsftu = TSF_TO_TU(tsf>>32, tsf) + FUDGE;
-
- num_beacons = tsftu / intval + 1;
- offset = tsftu % intval;
- nexttbtt = tsftu - offset;
- if (offset)
-  nexttbtt += intval;
-
- /* DTIM Beacon every dtimperiod Beacon */
- dtim_dec_count = num_beacons % dtimperiod;
- /* CFP every cfpperiod DTIM Beacon */
- cfp_dec_count = (num_beacons / dtimperiod) % cfpperiod;
- if (dtim_dec_count)
-  cfp_dec_count++;
-
- dtimcount -= dtim_dec_count;
- if (dtimcount < 0)
-  dtimcount += dtimperiod;
-
- cfpcount -= cfp_dec_count;
- if (cfpcount < 0)
-  cfpcount += cfpperiod;
-
- bs.bs_intval = intval;
- bs.bs_nexttbtt = nexttbtt;
- bs.bs_dtimperiod = dtimperiod*intval;
- bs.bs_nextdtim = bs.bs_nexttbtt + dtimcount*intval;
- bs.bs_cfpperiod = cfpperiod*bs.bs_dtimperiod;
- bs.bs_cfpnext = bs.bs_nextdtim + cfpcount*bs.bs_dtimperiod;
- bs.bs_cfpmaxduration = 0;
-
- /*
-  * Calculate the number of consecutive beacons to miss* before taking
-  * a BMISS interrupt. The configuration is specified in TU so we only
-  * need calculate based on the beacon interval.  Note that we clamp the
-  * result to at most 15 beacons.
-  */
- if (sleepduration > intval) {
-  bs.bs_bmissthreshold = conf->listen_interval *
-   ATH_DEFAULT_BMISS_LIMIT / 2;
- } else {
-  bs.bs_bmissthreshold = DIV_ROUND_UP(conf->bmiss_timeout, intval);
-  if (bs.bs_bmissthreshold > 15)
-   bs.bs_bmissthreshold = 15;
-  else if (bs.bs_bmissthreshold <= 0)
-   bs.bs_bmissthreshold = 1;
- }
-
- /*
-  * Calculate sleep duration. The configuration is given in ms.
-  * We ensure a multiple of the beacon period is used. Also, if the sleep
-  * duration is greater than the DTIM period then it makes senses
-  * to make it a multiple of that.
-  *
-  * XXX fixed at 100ms
-  */
-
- bs.bs_sleepduration = roundup(IEEE80211_MS_TO_TU(100), sleepduration);
- if (bs.bs_sleepduration > bs.bs_dtimperiod)
-  bs.bs_sleepduration = bs.bs_dtimperiod;
-
- /* TSF out of range threshold fixed at 1 second */
- bs.bs_tsfoor_threshold = ATH9K_TSFOOR_THRESHOLD;
-
- ath_dbg(common, BEACON, "tsf: %llu tsftu: %u\n", tsf, tsftu);
- ath_dbg(common, BEACON,
-  "bmiss: %u sleep: %u cfp-period: %u maxdur: %u next: %u\n",
-  bs.bs_bmissthreshold, bs.bs_sleepduration,
-  bs.bs_cfpperiod, bs.bs_cfpmaxduration, bs.bs_cfpnext);
-
- /* Set the computed STA beacon timers */
 
  ath9k_hw_disable_interrupts(ah);
  ath9k_hw_set_sta_beacon_timers(ah, &bs);
@@ -588,53 +481,23 @@ static void ath9k_beacon_config_adhoc(struct ath_softc *sc,
 {
  struct ath_hw *ah = sc->sc_ah;
  struct ath_common *common = ath9k_hw_common(ah);
- u32 intval, nexttbtt;
 
  ath9k_reset_beacon_status(sc);
 
- intval = TU_TO_USEC(conf->beacon_interval);
+ ath9k_cmn_beacon_config_adhoc(ah, conf);
 
- if (conf->ibss_creator) {
-  nexttbtt = intval;
- } else {
-  u32 tbtt, offset, tsftu;
-  u64 tsf;
-
-  /*
-   * Pull nexttbtt forward to reflect the current
-   * sync'd TSF.
-   */
-  tsf = ath9k_hw_gettsf64(ah);
-  tsftu = TSF_TO_TU(tsf >> 32, tsf) + FUDGE;
-  offset = tsftu % conf->beacon_interval;
-  tbtt = tsftu - offset;
-  if (offset)
-   tbtt += conf->beacon_interval;
-
-  nexttbtt = TU_TO_USEC(tbtt);
- }
-
- if (conf->enable_beacon)
-  ah->imask |= ATH9K_INT_SWBA;
- else
-  ah->imask &= ~ATH9K_INT_SWBA;
-
- ath_dbg(common, BEACON,
-  "IBSS (%s) nexttbtt: %u intval: %u conf_intval: %u\n",
-  (conf->enable_beacon) ? "Enable" : "Disable",
-  nexttbtt, intval, conf->beacon_interval);
-
- ath9k_beacon_init(sc, nexttbtt, intval, conf->ibss_creator);
+ ath9k_beacon_init(sc, conf->nexttbtt, conf->intval, conf->ibss_creator);
 
  /*
   * Set the global 'beacon has been configured' flag for the
   * joiner case in IBSS mode.
   */
  if (!conf->ibss_creator && conf->enable_beacon)
-  set_bit(SC_OP_BEACONS, &sc->sc_flags);
+  set_bit(ATH_OP_BEACONS, &common->op_flags);
 }
 
-bool ath9k_allow_beacon_config(struct ath_softc *sc, struct ieee80211_vif *vif)
+static bool ath9k_allow_beacon_config(struct ath_softc *sc,
+          struct ieee80211_vif *vif)
 {
  struct ath_common *common = ath9k_hw_common(sc->sc_ah);
  struct ath_vif *avp = (void *)vif->drv_priv;
@@ -650,7 +513,7 @@ bool ath9k_allow_beacon_config(struct ath_softc *sc, struct ieee80211_vif *vif)
 
  if (sc->sc_ah->opmode == NL80211_IFTYPE_STATION) {
   if ((vif->type == NL80211_IFTYPE_STATION) &&
-      test_bit(SC_OP_BEACONS, &sc->sc_flags) &&
+      test_bit(ATH_OP_BEACONS, &common->op_flags) &&
       !avp->primary_sta_vif) {
    ath_dbg(common, CONFIG,
     "Beacon already configured for a station interface\n");
@@ -672,11 +535,8 @@ static void ath9k_cache_beacon_config(struct ath_softc *sc,
 
  cur_conf->beacon_interval = bss_conf->beacon_int;
  cur_conf->dtim_period = bss_conf->dtim_period;
- cur_conf->listen_interval = 1;
  cur_conf->dtim_count = 1;
  cur_conf->ibss_creator = bss_conf->ibss_creator;
- cur_conf->bmiss_timeout =
-  ATH_DEFAULT_BMISS_LIMIT * cur_conf->beacon_interval;
 
  /*
   * It looks like mac80211 may end up using beacon interval of zero in
@@ -687,6 +547,9 @@ static void ath9k_cache_beacon_config(struct ath_softc *sc,
  if (cur_conf->beacon_interval == 0)
   cur_conf->beacon_interval = 100;
 
+ cur_conf->bmiss_timeout =
+  ATH_DEFAULT_BMISS_LIMIT * cur_conf->beacon_interval;
+
  /*
   * We don't parse dtim period from mac80211 during the driver
   * initialization as it breaks association with hidden-ssid
@@ -702,15 +565,22 @@ void ath9k_beacon_config(struct ath_softc *sc, struct ieee80211_vif *vif,
 {
  struct ieee80211_bss_conf *bss_conf = &vif->bss_conf;
  struct ath_beacon_config *cur_conf = &sc->cur_beacon_conf;
+        struct ath_hw *ah = sc->sc_ah;
+        struct ath_common *common = ath9k_hw_common(ah);
  unsigned long flags;
  bool skip_beacon = false;
 
+ if (vif->type == NL80211_IFTYPE_AP)
+  ath9k_set_tsfadjust(sc, vif);
+
+ if (!ath9k_allow_beacon_config(sc, vif))
+  return;
+
  if (sc->sc_ah->opmode == NL80211_IFTYPE_STATION) {
   ath9k_cache_beacon_config(sc, bss_conf);
   ath9k_set_beacon(sc);
-  set_bit(SC_OP_BEACONS, &sc->sc_flags);
+  set_bit(ATH_OP_BEACONS, &common->op_flags);
   return;
-
  }
 
  /*
@@ -748,13 +618,13 @@ void ath9k_beacon_config(struct ath_softc *sc, struct ieee80211_vif *vif,
   }
 
   /*
-   * Do not set the SC_OP_BEACONS flag for IBSS joiner mode
+   * Do not set the ATH_OP_BEACONS flag for IBSS joiner mode
    * here, it is done in ath9k_beacon_config_adhoc().
    */
   if (cur_conf->enable_beacon && !skip_beacon)
-   set_bit(SC_OP_BEACONS, &sc->sc_flags);
+   set_bit(ATH_OP_BEACONS, &common->op_flags);
   else
-   clear_bit(SC_OP_BEACONS, &sc->sc_flags);
+   clear_bit(ATH_OP_BEACONS, &common->op_flags);
  }
 }
 
@@ -765,14 +635,14 @@ void ath9k_set_beacon(struct ath_softc *sc)
 
  switch (sc->sc_ah->opmode) {
  case NL80211_IFTYPE_AP:
+ case NL80211_IFTYPE_MESH_POINT:
   ath9k_beacon_config_ap(sc, cur_conf);
   break;
  case NL80211_IFTYPE_ADHOC:
- case NL80211_IFTYPE_MESH_POINT:
   ath9k_beacon_config_adhoc(sc, cur_conf);
   break;
  case NL80211_IFTYPE_STATION:
-  ath9k_beacon_config_sta(sc, cur_conf);
+  ath9k_beacon_config_sta(sc->sc_ah, cur_conf);
   break;
  default:
   ath_dbg(common, CONFIG, "Unsupported beaconing mode\n");
diff --git a/drivers/net/wireless/ath/ath9k/btcoex.c b/drivers/net/wireless/ath/ath9k/btcoex.c
index 9963b0b..3dfc2c7 100644
--- a/drivers/net/wireless/ath/ath9k/btcoex.c
+++ b/drivers/net/wireless/ath/ath9k/btcoex.c
@@ -66,7 +66,6 @@ void ath9k_hw_init_btcoex_hw(struct ath_hw *ah, int qnum)
   .bt_first_slot_time = 5,
   .bt_hold_rx_clear = true,
  };
- u32 i, idx;
  bool rxclear_polarity = ath_bt_config.bt_rxclear_polarity;
 
  if (AR_SREV_9300_20_OR_LATER(ah))
@@ -88,11 +87,6 @@ void ath9k_hw_init_btcoex_hw(struct ath_hw *ah, int qnum)
   SM(ath_bt_config.bt_hold_rx_clear, AR_BT_HOLD_RX_CLEAR) |
   SM(ATH_BTCOEX_BMISS_THRESH, AR_BT_BCN_MISS_THRESH) |
   AR_BT_DISABLE_BT_ANT;
-
- for (i = 0; i < 32; i++) {
-  idx = (debruijn32 << i) >> 27;
-  ah->hw_gen_timers.gen_timer_index[idx] = i;
- }
 }
 EXPORT_SYMBOL(ath9k_hw_init_btcoex_hw);
 
diff --git a/drivers/net/wireless/ath/ath9k/calib.c b/drivers/net/wireless/ath/ath9k/calib.c
index 5e8219a..278365b 100644
--- a/drivers/net/wireless/ath/ath9k/calib.c
+++ b/drivers/net/wireless/ath/ath9k/calib.c
@@ -63,13 +63,13 @@ static s16 ath9k_hw_get_default_nf(struct ath_hw *ah,
  return ath9k_hw_get_nf_limits(ah, chan)->nominal;
 }
 
-s16 ath9k_hw_getchan_noise(struct ath_hw *ah, struct ath9k_channel *chan)
+s16 ath9k_hw_getchan_noise(struct ath_hw *ah, struct ath9k_channel *chan,
+      s16 nf)
 {
  s8 noise = ATH_DEFAULT_NOISE_FLOOR;
 
- if (chan && chan->noisefloor) {
-  s8 delta = chan->noisefloor -
-      ATH9K_NF_CAL_NOISE_THRESH -
+ if (nf) {
+  s8 delta = nf - ATH9K_NF_CAL_NOISE_THRESH -
       ath9k_hw_get_default_nf(ah, chan);
   if (delta > 0)
    noise += delta;
@@ -119,7 +119,7 @@ static void ath9k_hw_update_nfcal_hist_buffer(struct ath_hw *ah,
    ath_dbg(common, CALIBRATE,
     "NFmid[%d] (%d) > MAX (%d), %s\n",
     i, h[i].privNF, limit->max,
-    (cal->nfcal_interference ?
+    (test_bit(NFCAL_INTF, &cal->cal_flags) ?
      "not corrected (due to interference)" :
      "correcting to MAX"));
 
@@ -130,7 +130,7 @@ static void ath9k_hw_update_nfcal_hist_buffer(struct ath_hw *ah,
     * we bypass this limit here in order to better deal
     * with our environment.
     */
-   if (!cal->nfcal_interference)
+   if (!test_bit(NFCAL_INTF, &cal->cal_flags))
     h[i].privNF = limit->max;
   }
  }
@@ -141,7 +141,7 @@ static void ath9k_hw_update_nfcal_hist_buffer(struct ath_hw *ah,
   * Re-enable the enforcement of the NF maximum again.
   */
  if (!high_nf_mid)
-  cal->nfcal_interference = false;
+  clear_bit(NFCAL_INTF, &cal->cal_flags);
 }
 
 static bool ath9k_hw_get_nf_thresh(struct ath_hw *ah,
@@ -186,7 +186,6 @@ void ath9k_hw_reset_calibration(struct ath_hw *ah,
 bool ath9k_hw_reset_calvalid(struct ath_hw *ah)
 {
  struct ath_common *common = ath9k_hw_common(ah);
- struct ieee80211_conf *conf = &common->hw->conf;
  struct ath9k_cal_list *currCal = ah->cal_list_curr;
 
  if (!ah->caldata)
@@ -208,7 +207,7 @@ bool ath9k_hw_reset_calvalid(struct ath_hw *ah)
   return true;
 
  ath_dbg(common, CALIBRATE, "Resetting Cal %d state for channel %u\n",
-  currCal->calData->calType, conf->chandef.chan->center_freq);
+  currCal->calData->calType, ah->curchan->chan->center_freq);
 
  ah->caldata->CalValid &= ~currCal->calData->calType;
  currCal->calState = CAL_WAITING;
@@ -220,7 +219,7 @@ EXPORT_SYMBOL(ath9k_hw_reset_calvalid);
 void ath9k_hw_start_nfcal(struct ath_hw *ah, bool update)
 {
  if (ah->caldata)
-  ah->caldata->nfcal_pending = true;
+  set_bit(NFCAL_PENDING, &ah->caldata->cal_flags);
 
  REG_SET_BIT(ah, AR_PHY_AGC_CONTROL,
       AR_PHY_AGC_CONTROL_ENABLE_NF);
@@ -242,7 +241,6 @@ void ath9k_hw_loadnf(struct ath_hw *ah, struct ath9k_channel *chan)
  int32_t val;
  u8 chainmask = (ah->rxchainmask << 3) | ah->rxchainmask;
  struct ath_common *common = ath9k_hw_common(ah);
- struct ieee80211_conf *conf = &common->hw->conf;
  s16 default_nf = ath9k_hw_get_default_nf(ah, chan);
 
  if (ah->caldata)
@@ -252,7 +250,7 @@ void ath9k_hw_loadnf(struct ath_hw *ah, struct ath9k_channel *chan)
   if (chainmask & (1 << i)) {
    s16 nfval;
 
-   if ((i >= AR5416_MAX_CHAINS) && !conf_is_ht40(conf))
+   if ((i >= AR5416_MAX_CHAINS) && !IS_CHAN_HT40(chan))
     continue;
 
    if (h)
@@ -314,7 +312,7 @@ void ath9k_hw_loadnf(struct ath_hw *ah, struct ath9k_channel *chan)
  ENABLE_REGWRITE_BUFFER(ah);
  for (i = 0; i < NUM_NF_READINGS; i++) {
   if (chainmask & (1 << i)) {
-   if ((i >= AR5416_MAX_CHAINS) && !conf_is_ht40(conf))
+   if ((i >= AR5416_MAX_CHAINS) && !IS_CHAN_HT40(chan))
     continue;
 
    val = REG_READ(ah, ah->nf_regs[i]);
@@ -391,10 +389,10 @@ bool ath9k_hw_getnf(struct ath_hw *ah, struct ath9k_channel *chan)
  }
 
  h = caldata->nfCalHist;
- caldata->nfcal_pending = false;
+ clear_bit(NFCAL_PENDING, &caldata->cal_flags);
  ath9k_hw_update_nfcal_hist_buffer(ah, caldata, nfarray);
  chan->noisefloor = h[0].privNF;
- ah->noise = ath9k_hw_getchan_noise(ah, chan);
+ ah->noise = ath9k_hw_getchan_noise(ah, chan, chan->noisefloor);
  return true;
 }
 EXPORT_SYMBOL(ath9k_hw_getnf);
@@ -408,7 +406,6 @@ void ath9k_init_nfcal_hist_buffer(struct ath_hw *ah,
 
  ah->caldata->channel = chan->channel;
  ah->caldata->channelFlags = chan->channelFlags;
- ah->caldata->chanmode = chan->chanmode;
  h = ah->caldata->nfCalHist;
  default_nf = ath9k_hw_get_default_nf(ah, chan);
  for (i = 0; i < NUM_NF_READINGS; i++) {
@@ -437,12 +434,12 @@ void ath9k_hw_bstuck_nfcal(struct ath_hw *ah)
   * the baseband update the internal NF value itself, similar to
   * what is being done after a full reset.
   */
- if (!caldata->nfcal_pending)
+ if (!test_bit(NFCAL_PENDING, &caldata->cal_flags))
   ath9k_hw_start_nfcal(ah, true);
  else if (!(REG_READ(ah, AR_PHY_AGC_CONTROL) & AR_PHY_AGC_CONTROL_NF))
   ath9k_hw_getnf(ah, ah->curchan);
 
- caldata->nfcal_interference = true;
+ set_bit(NFCAL_INTF, &caldata->cal_flags);
 }
 EXPORT_SYMBOL(ath9k_hw_bstuck_nfcal);
 
diff --git a/drivers/net/wireless/ath/ath9k/calib.h b/drivers/net/wireless/ath/ath9k/calib.h
index 3d70b8c..b8ed95e 100644
--- a/drivers/net/wireless/ath/ath9k/calib.h
+++ b/drivers/net/wireless/ath/ath9k/calib.h
@@ -116,7 +116,8 @@ void ath9k_init_nfcal_hist_buffer(struct ath_hw *ah,
 void ath9k_hw_bstuck_nfcal(struct ath_hw *ah);
 void ath9k_hw_reset_calibration(struct ath_hw *ah,
     struct ath9k_cal_list *currCal);
-s16 ath9k_hw_getchan_noise(struct ath_hw *ah, struct ath9k_channel *chan);
+s16 ath9k_hw_getchan_noise(struct ath_hw *ah, struct ath9k_channel *chan,
+      s16 nf);
 
 
 #endif /* CALIB_H */
diff --git a/drivers/net/wireless/ath/ath9k/common-beacon.c b/drivers/net/wireless/ath/ath9k/common-beacon.c
new file mode 100644
index 0000000..775d1d2
--- /dev/null
+++ b/drivers/net/wireless/ath/ath9k/common-beacon.c
@@ -0,0 +1,180 @@
+/*
+ * Copyright (c) 2008-2011 Atheros Communications Inc.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include "common.h"
+
+#define FUDGE 2
+
+/* Calculate the modulo of a 64 bit TSF snapshot with a TU divisor */
+static u32 ath9k_mod_tsf64_tu(u64 tsf, u32 div_tu)
+{
+ u32 tsf_mod, tsf_hi, tsf_lo, mod_hi, mod_lo;
+
+ tsf_mod = tsf & (BIT(10) - 1);
+ tsf_hi = tsf >> 32;
+ tsf_lo = ((u32) tsf) >> 10;
+
+ mod_hi = tsf_hi % div_tu;
+ mod_lo = ((mod_hi << 22) + tsf_lo) % div_tu;
+
+ return (mod_lo << 10) | tsf_mod;
+}
+
+static u32 ath9k_get_next_tbtt(struct ath_hw *ah, u64 tsf,
+          unsigned int interval)
+{
+ unsigned int offset;
+
+ tsf += TU_TO_USEC(FUDGE + ah->config.sw_beacon_response_time);
+ offset = ath9k_mod_tsf64_tu(tsf, interval);
+
+ return (u32) tsf + TU_TO_USEC(interval) - offset;
+}
+
+/*
+ * This sets up the beacon timers according to the timestamp of the last
+ * received beacon and the current TSF, configures PCF and DTIM
+ * handling, programs the sleep registers so the hardware will wakeup in
+ * time to receive beacons, and configures the beacon miss handling so
+ * we'll receive a BMISS interrupt when we stop seeing beacons from the AP
+ * we've associated with.
+ */
+int ath9k_cmn_beacon_config_sta(struct ath_hw *ah,
+     struct ath_beacon_config *conf,
+     struct ath9k_beacon_state *bs)
+{
+ struct ath_common *common = ath9k_hw_common(ah);
+ int dtim_intval;
+ u64 tsf;
+
+ /* No need to configure beacon if we are not associated */
+ if (!test_bit(ATH_OP_PRIM_STA_VIF, &common->op_flags)) {
+  ath_dbg(common, BEACON,
+   "STA is not yet associated..skipping beacon config\n");
+  return -EPERM;
+ }
+
+ memset(bs, 0, sizeof(*bs));
+ conf->intval = conf->beacon_interval;
+
+ /*
+  * Setup dtim parameters according to
+  * last beacon we received (which may be none).
+  */
+ dtim_intval = conf->intval * conf->dtim_period;
+
+ /*
+  * Pull nexttbtt forward to reflect the current
+  * TSF and calculate dtim state for the result.
+  */
+ tsf = ath9k_hw_gettsf64(ah);
+ conf->nexttbtt = ath9k_get_next_tbtt(ah, tsf, conf->intval);
+
+ bs->bs_intval = TU_TO_USEC(conf->intval);
+ bs->bs_dtimperiod = conf->dtim_period * bs->bs_intval;
+ bs->bs_nexttbtt = conf->nexttbtt;
+ bs->bs_nextdtim = conf->nexttbtt;
+ if (conf->dtim_period > 1)
+  bs->bs_nextdtim = ath9k_get_next_tbtt(ah, tsf, dtim_intval);
+
+ /*
+  * Calculate the number of consecutive beacons to miss* before taking
+  * a BMISS interrupt. The configuration is specified in TU so we only
+  * need calculate based on the beacon interval.  Note that we clamp the
+  * result to at most 15 beacons.
+  */
+ bs->bs_bmissthreshold = DIV_ROUND_UP(conf->bmiss_timeout, conf->intval);
+ if (bs->bs_bmissthreshold > 15)
+  bs->bs_bmissthreshold = 15;
+ else if (bs->bs_bmissthreshold <= 0)
+  bs->bs_bmissthreshold = 1;
+
+ /*
+  * Calculate sleep duration. The configuration is given in ms.
+  * We ensure a multiple of the beacon period is used. Also, if the sleep
+  * duration is greater than the DTIM period then it makes senses
+  * to make it a multiple of that.
+  *
+  * XXX fixed at 100ms
+  */
+
+ bs->bs_sleepduration = TU_TO_USEC(roundup(IEEE80211_MS_TO_TU(100),
+       conf->intval));
+ if (bs->bs_sleepduration > bs->bs_dtimperiod)
+  bs->bs_sleepduration = bs->bs_dtimperiod;
+
+ /* TSF out of range threshold fixed at 1 second */
+ bs->bs_tsfoor_threshold = ATH9K_TSFOOR_THRESHOLD;
+
+ ath_dbg(common, BEACON, "bmiss: %u sleep: %u\n",
+  bs->bs_bmissthreshold, bs->bs_sleepduration);
+ return 0;
+}
+EXPORT_SYMBOL(ath9k_cmn_beacon_config_sta);
+
+void ath9k_cmn_beacon_config_adhoc(struct ath_hw *ah,
+       struct ath_beacon_config *conf)
+{
+ struct ath_common *common = ath9k_hw_common(ah);
+
+ conf->intval = TU_TO_USEC(conf->beacon_interval);
+
+ if (conf->ibss_creator)
+  conf->nexttbtt = conf->intval;
+ else
+  conf->nexttbtt = ath9k_get_next_tbtt(ah, ath9k_hw_gettsf64(ah),
+            conf->beacon_interval);
+
+ if (conf->enable_beacon)
+  ah->imask |= ATH9K_INT_SWBA;
+ else
+  ah->imask &= ~ATH9K_INT_SWBA;
+
+ ath_dbg(common, BEACON,
+  "IBSS (%s) nexttbtt: %u intval: %u conf_intval: %u\n",
+  (conf->enable_beacon) ? "Enable" : "Disable",
+  conf->nexttbtt, conf->intval, conf->beacon_interval);
+}
+EXPORT_SYMBOL(ath9k_cmn_beacon_config_adhoc);
+
+/*
+ * For multi-bss ap support beacons are either staggered evenly over N slots or
+ * burst together.  For the former arrange for the SWBA to be delivered for each
+ * slot. Slots that are not occupied will generate nothing.
+ */
+void ath9k_cmn_beacon_config_ap(struct ath_hw *ah,
+    struct ath_beacon_config *conf,
+    unsigned int bc_buf)
+{
+ struct ath_common *common = ath9k_hw_common(ah);
+
+ /* NB: the beacon interval is kept internally in TU's */
+ conf->intval = TU_TO_USEC(conf->beacon_interval);
+ conf->intval /= bc_buf;
+ conf->nexttbtt = ath9k_get_next_tbtt(ah, ath9k_hw_gettsf64(ah),
+           conf->beacon_interval);
+
+ if (conf->enable_beacon)
+  ah->imask |= ATH9K_INT_SWBA;
+ else
+  ah->imask &= ~ATH9K_INT_SWBA;
+
+ ath_dbg(common, BEACON,
+  "AP (%s) nexttbtt: %u intval: %u conf_intval: %u\n",
+  (conf->enable_beacon) ? "Enable" : "Disable",
+  conf->nexttbtt, conf->intval, conf->beacon_interval);
+}
+EXPORT_SYMBOL(ath9k_cmn_beacon_config_ap);
diff --git a/drivers/net/wireless/ath/ath9k/common-beacon.h b/drivers/net/wireless/ath/ath9k/common-beacon.h
new file mode 100644
index 0000000..3665d27
--- /dev/null
+++ b/drivers/net/wireless/ath/ath9k/common-beacon.h
@@ -0,0 +1,26 @@
+/*
+ * Copyright (c) 2009-2011 Atheros Communications Inc.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+struct ath_beacon_config;
+
+int ath9k_cmn_beacon_config_sta(struct ath_hw *ah,
+    struct ath_beacon_config *conf,
+    struct ath9k_beacon_state *bs);
+void ath9k_cmn_beacon_config_adhoc(struct ath_hw *ah,
+       struct ath_beacon_config *conf);
+void ath9k_cmn_beacon_config_ap(struct ath_hw *ah,
+    struct ath_beacon_config *conf,
+    unsigned int bc_buf);
diff --git a/drivers/net/wireless/ath/ath9k/common-debug.c b/drivers/net/wireless/ath/ath9k/common-debug.c
new file mode 100644
index 0000000..3b289f9
--- /dev/null
+++ b/drivers/net/wireless/ath/ath9k/common-debug.c
@@ -0,0 +1,253 @@
+/*
+ * Copyright (c) 2008-2011 Atheros Communications Inc.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include "common.h"
+
+static ssize_t read_file_modal_eeprom(struct file *file, char __user *user_buf,
+          size_t count, loff_t *ppos)
+{
+ struct ath_hw *ah = file->private_data;
+ u32 len = 0, size = 6000;
+ char *buf;
+ size_t retval;
+
+ buf = kzalloc(size, GFP_KERNEL);
+ if (buf == NULL)
+  return -ENOMEM;
+
+ len = ah->eep_ops->dump_eeprom(ah, false, buf, len, size);
+
+ retval = simple_read_from_buffer(user_buf, count, ppos, buf, len);
+ kfree(buf);
+
+ return retval;
+}
+
+static const struct file_operations fops_modal_eeprom = {
+ .read = read_file_modal_eeprom,
+ .open = simple_open,
+ .owner = THIS_MODULE,
+ .llseek = default_llseek,
+};
+
+
+void ath9k_cmn_debug_modal_eeprom(struct dentry *debugfs_phy,
+      struct ath_hw *ah)
+{
+ debugfs_create_file("modal_eeprom", S_IRUSR, debugfs_phy, ah,
+       &fops_modal_eeprom);
+}
+EXPORT_SYMBOL(ath9k_cmn_debug_modal_eeprom);
+
+static ssize_t read_file_base_eeprom(struct file *file, char __user *user_buf,
+         size_t count, loff_t *ppos)
+{
+ struct ath_hw *ah = file->private_data;
+ u32 len = 0, size = 1500;
+ ssize_t retval = 0;
+ char *buf;
+
+ buf = kzalloc(size, GFP_KERNEL);
+ if (!buf)
+  return -ENOMEM;
+
+ len = ah->eep_ops->dump_eeprom(ah, true, buf, len, size);
+
+ retval = simple_read_from_buffer(user_buf, count, ppos, buf, len);
+ kfree(buf);
+
+ return retval;
+}
+
+static const struct file_operations fops_base_eeprom = {
+ .read = read_file_base_eeprom,
+ .open = simple_open,
+ .owner = THIS_MODULE,
+ .llseek = default_llseek,
+};
+
+void ath9k_cmn_debug_base_eeprom(struct dentry *debugfs_phy,
+     struct ath_hw *ah)
+{
+ debugfs_create_file("base_eeprom", S_IRUSR, debugfs_phy, ah,
+       &fops_base_eeprom);
+}
+EXPORT_SYMBOL(ath9k_cmn_debug_base_eeprom);
+
+void ath9k_cmn_debug_stat_rx(struct ath_rx_stats *rxstats,
+        struct ath_rx_status *rs)
+{
+#define RX_PHY_ERR_INC(c) rxstats->phy_err_stats[c]++
+#define RX_CMN_STAT_INC(c) (rxstats->c++)
+
+ RX_CMN_STAT_INC(rx_pkts_all);
+ rxstats->rx_bytes_all += rs->rs_datalen;
+
+ if (rs->rs_status & ATH9K_RXERR_CRC)
+  RX_CMN_STAT_INC(crc_err);
+ if (rs->rs_status & ATH9K_RXERR_DECRYPT)
+  RX_CMN_STAT_INC(decrypt_crc_err);
+ if (rs->rs_status & ATH9K_RXERR_MIC)
+  RX_CMN_STAT_INC(mic_err);
+ if (rs->rs_status & ATH9K_RX_DELIM_CRC_PRE)
+  RX_CMN_STAT_INC(pre_delim_crc_err);
+ if (rs->rs_status & ATH9K_RX_DELIM_CRC_POST)
+  RX_CMN_STAT_INC(post_delim_crc_err);
+ if (rs->rs_status & ATH9K_RX_DECRYPT_BUSY)
+  RX_CMN_STAT_INC(decrypt_busy_err);
+
+ if (rs->rs_status & ATH9K_RXERR_PHY) {
+  RX_CMN_STAT_INC(phy_err);
+  if (rs->rs_phyerr < ATH9K_PHYERR_MAX)
+   RX_PHY_ERR_INC(rs->rs_phyerr);
+ }
+
+#undef RX_CMN_STAT_INC
+#undef RX_PHY_ERR_INC
+}
+EXPORT_SYMBOL(ath9k_cmn_debug_stat_rx);
+
+static ssize_t read_file_recv(struct file *file, char __user *user_buf,
+         size_t count, loff_t *ppos)
+{
+#define RXS_ERR(s, e)     \
+ do {      \
+  len += scnprintf(buf + len, size - len, \
+     "%18s : %10u\n", s, \
+     rxstats->e);  \
+ } while (0)
+
+ struct ath_rx_stats *rxstats = file->private_data;
+ char *buf;
+ unsigned int len = 0, size = 1600;
+ ssize_t retval = 0;
+
+ buf = kzalloc(size, GFP_KERNEL);
+ if (buf == NULL)
+  return -ENOMEM;
+
+ RXS_ERR("PKTS-ALL", rx_pkts_all);
+ RXS_ERR("BYTES-ALL", rx_bytes_all);
+ RXS_ERR("BEACONS", rx_beacons);
+ RXS_ERR("FRAGS", rx_frags);
+ RXS_ERR("SPECTRAL", rx_spectral);
+
+ RXS_ERR("CRC ERR", crc_err);
+ RXS_ERR("DECRYPT CRC ERR", decrypt_crc_err);
+ RXS_ERR("PHY ERR", phy_err);
+ RXS_ERR("MIC ERR", mic_err);
+ RXS_ERR("PRE-DELIM CRC ERR", pre_delim_crc_err);
+ RXS_ERR("POST-DELIM CRC ERR", post_delim_crc_err);
+ RXS_ERR("DECRYPT BUSY ERR", decrypt_busy_err);
+ RXS_ERR("LENGTH-ERR", rx_len_err);
+ RXS_ERR("OOM-ERR", rx_oom_err);
+ RXS_ERR("RATE-ERR", rx_rate_err);
+ RXS_ERR("TOO-MANY-FRAGS", rx_too_many_frags_err);
+
+ if (len > size)
+  len = size;
+
+ retval = simple_read_from_buffer(user_buf, count, ppos, buf, len);
+ kfree(buf);
+
+ return retval;
+
+#undef RXS_ERR
+}
+
+static const struct file_operations fops_recv = {
+ .read = read_file_recv,
+ .open = simple_open,
+ .owner = THIS_MODULE,
+ .llseek = default_llseek,
+};
+
+void ath9k_cmn_debug_recv(struct dentry *debugfs_phy,
+     struct ath_rx_stats *rxstats)
+{
+ debugfs_create_file("recv", S_IRUSR, debugfs_phy, rxstats,
+       &fops_recv);
+}
+EXPORT_SYMBOL(ath9k_cmn_debug_recv);
+
+static ssize_t read_file_phy_err(struct file *file, char __user *user_buf,
+     size_t count, loff_t *ppos)
+{
+#define PHY_ERR(s, p) \
+ len += scnprintf(buf + len, size - len, "%22s : %10u\n", s, \
+    rxstats->phy_err_stats[p]);
+
+ struct ath_rx_stats *rxstats = file->private_data;
+ char *buf;
+ unsigned int len = 0, size = 1600;
+ ssize_t retval = 0;
+
+ buf = kzalloc(size, GFP_KERNEL);
+ if (buf == NULL)
+  return -ENOMEM;
+
+ PHY_ERR("UNDERRUN ERR", ATH9K_PHYERR_UNDERRUN);
+ PHY_ERR("TIMING ERR", ATH9K_PHYERR_TIMING);
+ PHY_ERR("PARITY ERR", ATH9K_PHYERR_PARITY);
+ PHY_ERR("RATE ERR", ATH9K_PHYERR_RATE);
+ PHY_ERR("LENGTH ERR", ATH9K_PHYERR_LENGTH);
+ PHY_ERR("RADAR ERR", ATH9K_PHYERR_RADAR);
+ PHY_ERR("SERVICE ERR", ATH9K_PHYERR_SERVICE);
+ PHY_ERR("TOR ERR", ATH9K_PHYERR_TOR);
+ PHY_ERR("OFDM-TIMING ERR", ATH9K_PHYERR_OFDM_TIMING);
+ PHY_ERR("OFDM-SIGNAL-PARITY ERR", ATH9K_PHYERR_OFDM_SIGNAL_PARITY);
+ PHY_ERR("OFDM-RATE ERR", ATH9K_PHYERR_OFDM_RATE_ILLEGAL);
+ PHY_ERR("OFDM-LENGTH ERR", ATH9K_PHYERR_OFDM_LENGTH_ILLEGAL);
+ PHY_ERR("OFDM-POWER-DROP ERR", ATH9K_PHYERR_OFDM_POWER_DROP);
+ PHY_ERR("OFDM-SERVICE ERR", ATH9K_PHYERR_OFDM_SERVICE);
+ PHY_ERR("OFDM-RESTART ERR", ATH9K_PHYERR_OFDM_RESTART);
+ PHY_ERR("FALSE-RADAR-EXT ERR", ATH9K_PHYERR_FALSE_RADAR_EXT);
+ PHY_ERR("CCK-TIMING ERR", ATH9K_PHYERR_CCK_TIMING);
+ PHY_ERR("CCK-HEADER-CRC ERR", ATH9K_PHYERR_CCK_HEADER_CRC);
+ PHY_ERR("CCK-RATE ERR", ATH9K_PHYERR_CCK_RATE_ILLEGAL);
+ PHY_ERR("CCK-SERVICE ERR", ATH9K_PHYERR_CCK_SERVICE);
+ PHY_ERR("CCK-RESTART ERR", ATH9K_PHYERR_CCK_RESTART);
+ PHY_ERR("CCK-LENGTH ERR", ATH9K_PHYERR_CCK_LENGTH_ILLEGAL);
+ PHY_ERR("CCK-POWER-DROP ERR", ATH9K_PHYERR_CCK_POWER_DROP);
+ PHY_ERR("HT-CRC ERR", ATH9K_PHYERR_HT_CRC_ERROR);
+ PHY_ERR("HT-LENGTH ERR", ATH9K_PHYERR_HT_LENGTH_ILLEGAL);
+ PHY_ERR("HT-RATE ERR", ATH9K_PHYERR_HT_RATE_ILLEGAL);
+
+ if (len > size)
+  len = size;
+
+ retval = simple_read_from_buffer(user_buf, count, ppos, buf, len);
+ kfree(buf);
+
+ return retval;
+
+#undef PHY_ERR
+}
+
+static const struct file_operations fops_phy_err = {
+ .read = read_file_phy_err,
+ .open = simple_open,
+ .owner = THIS_MODULE,
+ .llseek = default_llseek,
+};
+
+void ath9k_cmn_debug_phy_err(struct dentry *debugfs_phy,
+        struct ath_rx_stats *rxstats)
+{
+ debugfs_create_file("phy_err", S_IRUSR, debugfs_phy, rxstats,
+       &fops_phy_err);
+}
+EXPORT_SYMBOL(ath9k_cmn_debug_phy_err);
diff --git a/drivers/net/wireless/ath/ath9k/common-debug.h b/drivers/net/wireless/ath/ath9k/common-debug.h
new file mode 100644
index 0000000..7c97884
--- /dev/null
+++ b/drivers/net/wireless/ath/ath9k/common-debug.h
@@ -0,0 +1,72 @@
+/*
+ * Copyright (c) 2008-2011 Atheros Communications Inc.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+
+
+/**
+ * struct ath_rx_stats - RX Statistics
+ * @rx_pkts_all:  No. of total frames received, including ones that
+ may have had errors.
+ * @rx_bytes_all:  No. of total bytes received, including ones that
+ may have had errors.
+ * @crc_err: No. of frames with incorrect CRC value
+ * @decrypt_crc_err: No. of frames whose CRC check failed after
+ decryption process completed
+ * @phy_err: No. of frames whose reception failed because the PHY
+ encountered an error
+ * @mic_err: No. of frames with incorrect TKIP MIC verification failure
+ * @pre_delim_crc_err: Pre-Frame delimiter CRC error detections
+ * @post_delim_crc_err: Post-Frame delimiter CRC error detections
+ * @decrypt_busy_err: Decryption interruptions counter
+ * @phy_err_stats: Individual PHY error statistics
+ * @rx_len_err:  No. of frames discarded due to bad length.
+ * @rx_oom_err:  No. of frames dropped due to OOM issues.
+ * @rx_rate_err:  No. of frames dropped due to rate errors.
+ * @rx_too_many_frags_err:  Frames dropped due to too-many-frags received.
+ * @rx_beacons:  No. of beacons received.
+ * @rx_frags:  No. of rx-fragements received.
+ * @rx_spectral: No of spectral packets received.
+ */
+struct ath_rx_stats {
+ u32 rx_pkts_all;
+ u32 rx_bytes_all;
+ u32 crc_err;
+ u32 decrypt_crc_err;
+ u32 phy_err;
+ u32 mic_err;
+ u32 pre_delim_crc_err;
+ u32 post_delim_crc_err;
+ u32 decrypt_busy_err;
+ u32 phy_err_stats[ATH9K_PHYERR_MAX];
+ u32 rx_len_err;
+ u32 rx_oom_err;
+ u32 rx_rate_err;
+ u32 rx_too_many_frags_err;
+ u32 rx_beacons;
+ u32 rx_frags;
+ u32 rx_spectral;
+};
+
+void ath9k_cmn_debug_modal_eeprom(struct dentry *debugfs_phy,
+      struct ath_hw *ah);
+void ath9k_cmn_debug_base_eeprom(struct dentry *debugfs_phy,
+     struct ath_hw *ah);
+void ath9k_cmn_debug_stat_rx(struct ath_rx_stats *rxstats,
+        struct ath_rx_status *rs);
+void ath9k_cmn_debug_recv(struct dentry *debugfs_phy,
+     struct ath_rx_stats *rxstats);
+void ath9k_cmn_debug_phy_err(struct dentry *debugfs_phy,
+        struct ath_rx_stats *rxstats);
diff --git a/drivers/net/wireless/ath/ath9k/common-init.c b/drivers/net/wireless/ath/ath9k/common-init.c
new file mode 100644
index 0000000..a006c14
--- /dev/null
+++ b/drivers/net/wireless/ath/ath9k/common-init.c
@@ -0,0 +1,244 @@
+/*
+ * Copyright (c) 2008-2011 Atheros Communications Inc.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+/* We use the hw_value as an index into our private channel structure */
+
+#include "common.h"
+
+#define CHAN2G(_freq, _idx)  { \
+ .band = IEEE80211_BAND_2GHZ, \
+ .center_freq = (_freq), \
+ .hw_value = (_idx), \
+ .max_power = 20, \
+}
+
+#define CHAN5G(_freq, _idx) { \
+ .band = IEEE80211_BAND_5GHZ, \
+ .center_freq = (_freq), \
+ .hw_value = (_idx), \
+ .max_power = 20, \
+}
+
+/* Some 2 GHz radios are actually tunable on 2312-2732
+ * on 5 MHz steps, we support the channels which we know
+ * we have calibration data for all cards though to make
+ * this static */
+static const struct ieee80211_channel ath9k_2ghz_chantable[] = {
+ CHAN2G(2412, 0), /* Channel 1 */
+ CHAN2G(2417, 1), /* Channel 2 */
+ CHAN2G(2422, 2), /* Channel 3 */
+ CHAN2G(2427, 3), /* Channel 4 */
+ CHAN2G(2432, 4), /* Channel 5 */
+ CHAN2G(2437, 5), /* Channel 6 */
+ CHAN2G(2442, 6), /* Channel 7 */
+ CHAN2G(2447, 7), /* Channel 8 */
+ CHAN2G(2452, 8), /* Channel 9 */
+ CHAN2G(2457, 9), /* Channel 10 */
+ CHAN2G(2462, 10), /* Channel 11 */
+ CHAN2G(2467, 11), /* Channel 12 */
+ CHAN2G(2472, 12), /* Channel 13 */
+ CHAN2G(2484, 13), /* Channel 14 */
+};
+
+/* Some 5 GHz radios are actually tunable on XXXX-YYYY
+ * on 5 MHz steps, we support the channels which we know
+ * we have calibration data for all cards though to make
+ * this static */
+static const struct ieee80211_channel ath9k_5ghz_chantable[] = {
+ /* _We_ call this UNII 1 */
+ CHAN5G(5180, 14), /* Channel 36 */
+ CHAN5G(5200, 15), /* Channel 40 */
+ CHAN5G(5220, 16), /* Channel 44 */
+ CHAN5G(5240, 17), /* Channel 48 */
+ /* _We_ call this UNII 2 */
+ CHAN5G(5260, 18), /* Channel 52 */
+ CHAN5G(5280, 19), /* Channel 56 */
+ CHAN5G(5300, 20), /* Channel 60 */
+ CHAN5G(5320, 21), /* Channel 64 */
+ /* _We_ call this "Middle band" */
+ CHAN5G(5500, 22), /* Channel 100 */
+ CHAN5G(5520, 23), /* Channel 104 */
+ CHAN5G(5540, 24), /* Channel 108 */
+ CHAN5G(5560, 25), /* Channel 112 */
+ CHAN5G(5580, 26), /* Channel 116 */
+ CHAN5G(5600, 27), /* Channel 120 */
+ CHAN5G(5620, 28), /* Channel 124 */
+ CHAN5G(5640, 29), /* Channel 128 */
+ CHAN5G(5660, 30), /* Channel 132 */
+ CHAN5G(5680, 31), /* Channel 136 */
+ CHAN5G(5700, 32), /* Channel 140 */
+ /* _We_ call this UNII 3 */
+ CHAN5G(5745, 33), /* Channel 149 */
+ CHAN5G(5765, 34), /* Channel 153 */
+ CHAN5G(5785, 35), /* Channel 157 */
+ CHAN5G(5805, 36), /* Channel 161 */
+ CHAN5G(5825, 37), /* Channel 165 */
+};
+
+/* Atheros hardware rate code addition for short premble */
+#define SHPCHECK(__hw_rate, __flags) \
+ ((__flags & IEEE80211_RATE_SHORT_PREAMBLE) ? (__hw_rate | 0x04 ) : 0)
+
+#define RATE(_bitrate, _hw_rate, _flags) {              \
+ .bitrate        = (_bitrate),                   \
+ .flags          = (_flags),                     \
+ .hw_value       = (_hw_rate),                   \
+ .hw_value_short = (SHPCHECK(_hw_rate, _flags))  \
+}
+
+static struct ieee80211_rate ath9k_legacy_rates[] = {
+ RATE(10, 0x1b, 0),
+ RATE(20, 0x1a, IEEE80211_RATE_SHORT_PREAMBLE),
+ RATE(55, 0x19, IEEE80211_RATE_SHORT_PREAMBLE),
+ RATE(110, 0x18, IEEE80211_RATE_SHORT_PREAMBLE),
+ RATE(60, 0x0b, (IEEE80211_RATE_SUPPORTS_5MHZ |
+   IEEE80211_RATE_SUPPORTS_10MHZ)),
+ RATE(90, 0x0f, (IEEE80211_RATE_SUPPORTS_5MHZ |
+   IEEE80211_RATE_SUPPORTS_10MHZ)),
+ RATE(120, 0x0a, (IEEE80211_RATE_SUPPORTS_5MHZ |
+    IEEE80211_RATE_SUPPORTS_10MHZ)),
+ RATE(180, 0x0e, (IEEE80211_RATE_SUPPORTS_5MHZ |
+    IEEE80211_RATE_SUPPORTS_10MHZ)),
+ RATE(240, 0x09, (IEEE80211_RATE_SUPPORTS_5MHZ |
+    IEEE80211_RATE_SUPPORTS_10MHZ)),
+ RATE(360, 0x0d, (IEEE80211_RATE_SUPPORTS_5MHZ |
+    IEEE80211_RATE_SUPPORTS_10MHZ)),
+ RATE(480, 0x08, (IEEE80211_RATE_SUPPORTS_5MHZ |
+    IEEE80211_RATE_SUPPORTS_10MHZ)),
+ RATE(540, 0x0c, (IEEE80211_RATE_SUPPORTS_5MHZ |
+    IEEE80211_RATE_SUPPORTS_10MHZ)),
+};
+
+int ath9k_cmn_init_channels_rates(struct ath_common *common)
+{
+ struct ath_hw *ah = (struct ath_hw *)common->ah;
+ void *channels;
+
+ BUILD_BUG_ON(ARRAY_SIZE(ath9k_2ghz_chantable) +
+       ARRAY_SIZE(ath9k_5ghz_chantable) !=
+       ATH9K_NUM_CHANNELS);
+
+ if (ah->caps.hw_caps & ATH9K_HW_CAP_2GHZ) {
+  channels = devm_kzalloc(ah->dev,
+   sizeof(ath9k_2ghz_chantable), GFP_KERNEL);
+  if (!channels)
+      return -ENOMEM;
+
+  memcpy(channels, ath9k_2ghz_chantable,
+         sizeof(ath9k_2ghz_chantable));
+  common->sbands[IEEE80211_BAND_2GHZ].channels = channels;
+  common->sbands[IEEE80211_BAND_2GHZ].band = IEEE80211_BAND_2GHZ;
+  common->sbands[IEEE80211_BAND_2GHZ].n_channels =
+   ARRAY_SIZE(ath9k_2ghz_chantable);
+  common->sbands[IEEE80211_BAND_2GHZ].bitrates = ath9k_legacy_rates;
+  common->sbands[IEEE80211_BAND_2GHZ].n_bitrates =
+   ARRAY_SIZE(ath9k_legacy_rates);
+ }
+
+ if (ah->caps.hw_caps & ATH9K_HW_CAP_5GHZ) {
+  channels = devm_kzalloc(ah->dev,
+   sizeof(ath9k_5ghz_chantable), GFP_KERNEL);
+  if (!channels)
+   return -ENOMEM;
+
+  memcpy(channels, ath9k_5ghz_chantable,
+         sizeof(ath9k_5ghz_chantable));
+  common->sbands[IEEE80211_BAND_5GHZ].channels = channels;
+  common->sbands[IEEE80211_BAND_5GHZ].band = IEEE80211_BAND_5GHZ;
+  common->sbands[IEEE80211_BAND_5GHZ].n_channels =
+   ARRAY_SIZE(ath9k_5ghz_chantable);
+  common->sbands[IEEE80211_BAND_5GHZ].bitrates =
+   ath9k_legacy_rates + 4;
+  common->sbands[IEEE80211_BAND_5GHZ].n_bitrates =
+   ARRAY_SIZE(ath9k_legacy_rates) - 4;
+ }
+ return 0;
+}
+EXPORT_SYMBOL(ath9k_cmn_init_channels_rates);
+
+void ath9k_cmn_setup_ht_cap(struct ath_hw *ah,
+       struct ieee80211_sta_ht_cap *ht_info)
+{
+ struct ath_common *common = ath9k_hw_common(ah);
+ u8 tx_streams, rx_streams;
+ int i, max_streams;
+
+ ht_info->ht_supported = true;
+ ht_info->cap = IEEE80211_HT_CAP_SUP_WIDTH_20_40 |
+         IEEE80211_HT_CAP_SM_PS |
+         IEEE80211_HT_CAP_SGI_40 |
+         IEEE80211_HT_CAP_DSSSCCK40;
+
+ if (ah->caps.hw_caps & ATH9K_HW_CAP_LDPC)
+  ht_info->cap |= IEEE80211_HT_CAP_LDPC_CODING;
+
+ if (ah->caps.hw_caps & ATH9K_HW_CAP_SGI_20)
+  ht_info->cap |= IEEE80211_HT_CAP_SGI_20;
+
+ ht_info->ampdu_factor = IEEE80211_HT_MAX_AMPDU_64K;
+ ht_info->ampdu_density = IEEE80211_HT_MPDU_DENSITY_8;
+
+ if (AR_SREV_9271(ah) || AR_SREV_9330(ah) || AR_SREV_9485(ah) || AR_SREV_9565(ah))
+  max_streams = 1;
+ else if (AR_SREV_9462(ah))
+  max_streams = 2;
+ else if (AR_SREV_9300_20_OR_LATER(ah))
+  max_streams = 3;
+ else
+  max_streams = 2;
+
+ if (AR_SREV_9280_20_OR_LATER(ah)) {
+  if (max_streams >= 2)
+   ht_info->cap |= IEEE80211_HT_CAP_TX_STBC;
+  ht_info->cap |= (1 << IEEE80211_HT_CAP_RX_STBC_SHIFT);
+ }
+
+ /* set up supported mcs set */
+ memset(&ht_info->mcs, 0, sizeof(ht_info->mcs));
+ tx_streams = ath9k_cmn_count_streams(ah->txchainmask, max_streams);
+ rx_streams = ath9k_cmn_count_streams(ah->rxchainmask, max_streams);
+
+ ath_dbg(common, CONFIG, "TX streams %d, RX streams: %d\n",
+  tx_streams, rx_streams);
+
+ if (tx_streams != rx_streams) {
+  ht_info->mcs.tx_params |= IEEE80211_HT_MCS_TX_RX_DIFF;
+  ht_info->mcs.tx_params |= ((tx_streams - 1) <<
+    IEEE80211_HT_MCS_TX_MAX_STREAMS_SHIFT);
+ }
+
+ for (i = 0; i < rx_streams; i++)
+  ht_info->mcs.rx_mask[i] = 0xff;
+
+ ht_info->mcs.tx_params |= IEEE80211_HT_MCS_TX_DEFINED;
+}
+EXPORT_SYMBOL(ath9k_cmn_setup_ht_cap);
+
+void ath9k_cmn_reload_chainmask(struct ath_hw *ah)
+{
+ struct ath_common *common = ath9k_hw_common(ah);
+
+ if (!(ah->caps.hw_caps & ATH9K_HW_CAP_HT))
+  return;
+
+ if (ah->caps.hw_caps & ATH9K_HW_CAP_2GHZ)
+  ath9k_cmn_setup_ht_cap(ah,
+   &common->sbands[IEEE80211_BAND_2GHZ].ht_cap);
+ if (ah->caps.hw_caps & ATH9K_HW_CAP_5GHZ)
+  ath9k_cmn_setup_ht_cap(ah,
+   &common->sbands[IEEE80211_BAND_5GHZ].ht_cap);
+}
+EXPORT_SYMBOL(ath9k_cmn_reload_chainmask);
diff --git a/drivers/net/wireless/ath/ath9k/common-init.h b/drivers/net/wireless/ath/ath9k/common-init.h
new file mode 100644
index 0000000..ac03fca
--- /dev/null
+++ b/drivers/net/wireless/ath/ath9k/common-init.h
@@ -0,0 +1,20 @@
+/*
+ * Copyright (c) 2009-2011 Atheros Communications Inc.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+int ath9k_cmn_init_channels_rates(struct ath_common *common);
+void ath9k_cmn_setup_ht_cap(struct ath_hw *ah,
+       struct ieee80211_sta_ht_cap *ht_info);
+void ath9k_cmn_reload_chainmask(struct ath_hw *ah);
diff --git a/drivers/net/wireless/ath/ath9k/common.c b/drivers/net/wireless/ath/ath9k/common.c
index 344fdde..c6dd7f1 100644
--- a/drivers/net/wireless/ath/ath9k/common.c
+++ b/drivers/net/wireless/ath/ath9k/common.c
@@ -27,6 +27,250 @@ MODULE_AUTHOR("Atheros Communications");
 MODULE_DESCRIPTION("Shared library for Atheros wireless 802.11n LAN cards.");
 MODULE_LICENSE("Dual BSD/GPL");
 
+/* Assumes you've already done the endian to CPU conversion */
+bool ath9k_cmn_rx_accept(struct ath_common *common,
+    struct ieee80211_hdr *hdr,
+    struct ieee80211_rx_status *rxs,
+    struct ath_rx_status *rx_stats,
+    bool *decrypt_error,
+    unsigned int rxfilter)
+{
+ struct ath_hw *ah = common->ah;
+ bool is_mc, is_valid_tkip, strip_mic, mic_error;
+ __le16 fc;
+
+ fc = hdr->frame_control;
+
+ is_mc = !!is_multicast_ether_addr(hdr->addr1);
+ is_valid_tkip = rx_stats->rs_keyix != ATH9K_RXKEYIX_INVALID &&
+  test_bit(rx_stats->rs_keyix, common->tkip_keymap);
+ strip_mic = is_valid_tkip && ieee80211_is_data(fc) &&
+  ieee80211_has_protected(fc) &&
+  !(rx_stats->rs_status &
+  (ATH9K_RXERR_DECRYPT | ATH9K_RXERR_CRC | ATH9K_RXERR_MIC |
+   ATH9K_RXERR_KEYMISS));
+
+ /*
+  * Key miss events are only relevant for pairwise keys where the
+  * descriptor does contain a valid key index. This has been observed
+  * mostly with CCMP encryption.
+  */
+ if (rx_stats->rs_keyix == ATH9K_RXKEYIX_INVALID ||
+     !test_bit(rx_stats->rs_keyix, common->ccmp_keymap))
+  rx_stats->rs_status &= ~ATH9K_RXERR_KEYMISS;
+
+ mic_error = is_valid_tkip && !ieee80211_is_ctl(fc) &&
+  !ieee80211_has_morefrags(fc) &&
+  !(le16_to_cpu(hdr->seq_ctrl) & IEEE80211_SCTL_FRAG) &&
+  (rx_stats->rs_status & ATH9K_RXERR_MIC);
+
+ /*
+  * The rx_stats->rs_status will not be set until the end of the
+  * chained descriptors so it can be ignored if rs_more is set. The
+  * rs_more will be false at the last element of the chained
+  * descriptors.
+  */
+ if (rx_stats->rs_status != 0) {
+  u8 status_mask;
+
+  if (rx_stats->rs_status & ATH9K_RXERR_CRC) {
+   rxs->flag |= RX_FLAG_FAILED_FCS_CRC;
+   mic_error = false;
+  }
+
+  if ((rx_stats->rs_status & ATH9K_RXERR_DECRYPT) ||
+      (!is_mc && (rx_stats->rs_status & ATH9K_RXERR_KEYMISS))) {
+   *decrypt_error = true;
+   mic_error = false;
+  }
+
+
+  /*
+   * Reject error frames with the exception of
+   * decryption and MIC failures. For monitor mode,
+   * we also ignore the CRC error.
+   */
+  status_mask = ATH9K_RXERR_DECRYPT | ATH9K_RXERR_MIC |
+         ATH9K_RXERR_KEYMISS;
+
+  if (ah->is_monitoring && (rxfilter & FIF_FCSFAIL))
+   status_mask |= ATH9K_RXERR_CRC;
+
+  if (rx_stats->rs_status & ~status_mask)
+   return false;
+ }
+
+ /*
+  * For unicast frames the MIC error bit can have false positives,
+  * so all MIC error reports need to be validated in software.
+  * False negatives are not common, so skip software verification
+  * if the hardware considers the MIC valid.
+  */
+ if (strip_mic)
+  rxs->flag |= RX_FLAG_MMIC_STRIPPED;
+ else if (is_mc && mic_error)
+  rxs->flag |= RX_FLAG_MMIC_ERROR;
+
+ return true;
+}
+EXPORT_SYMBOL(ath9k_cmn_rx_accept);
+
+void ath9k_cmn_rx_skb_postprocess(struct ath_common *common,
+      struct sk_buff *skb,
+      struct ath_rx_status *rx_stats,
+      struct ieee80211_rx_status *rxs,
+      bool decrypt_error)
+{
+ struct ath_hw *ah = common->ah;
+ struct ieee80211_hdr *hdr;
+ int hdrlen, padpos, padsize;
+ u8 keyix;
+ __le16 fc;
+
+ /* see if any padding is done by the hw and remove it */
+ hdr = (struct ieee80211_hdr *) skb->data;
+ hdrlen = ieee80211_get_hdrlen_from_skb(skb);
+ fc = hdr->frame_control;
+ padpos = ieee80211_hdrlen(fc);
+
+ /* The MAC header is padded to have 32-bit boundary if the
+  * packet payload is non-zero. The general calculation for
+  * padsize would take into account odd header lengths:
+  * padsize = (4 - padpos % 4) % 4; However, since only
+  * even-length headers are used, padding can only be 0 or 2
+  * bytes and we can optimize this a bit. In addition, we must
+  * not try to remove padding from short control frames that do
+  * not have payload. */
+ padsize = padpos & 3;
+ if (padsize && skb->len>=padpos+padsize+FCS_LEN) {
+  memmove(skb->data + padsize, skb->data, padpos);
+  skb_pull(skb, padsize);
+ }
+
+ keyix = rx_stats->rs_keyix;
+
+ if (!(keyix == ATH9K_RXKEYIX_INVALID) && !decrypt_error &&
+     ieee80211_has_protected(fc)) {
+  rxs->flag |= RX_FLAG_DECRYPTED;
+ } else if (ieee80211_has_protected(fc)
+     && !decrypt_error && skb->len >= hdrlen + 4) {
+  keyix = skb->data[hdrlen + 3] >> 6;
+
+  if (test_bit(keyix, common->keymap))
+   rxs->flag |= RX_FLAG_DECRYPTED;
+ }
+ if (ah->sw_mgmt_crypto &&
+     (rxs->flag & RX_FLAG_DECRYPTED) &&
+     ieee80211_is_mgmt(fc))
+  /* Use software decrypt for management frames. */
+  rxs->flag &= ~RX_FLAG_DECRYPTED;
+}
+EXPORT_SYMBOL(ath9k_cmn_rx_skb_postprocess);
+
+int ath9k_cmn_process_rate(struct ath_common *common,
+      struct ieee80211_hw *hw,
+      struct ath_rx_status *rx_stats,
+      struct ieee80211_rx_status *rxs)
+{
+ struct ieee80211_supported_band *sband;
+ enum ieee80211_band band;
+ unsigned int i = 0;
+ struct ath_hw *ah = common->ah;
+
+ band = ah->curchan->chan->band;
+ sband = hw->wiphy->bands[band];
+
+ if (IS_CHAN_QUARTER_RATE(ah->curchan))
+  rxs->flag |= RX_FLAG_5MHZ;
+ else if (IS_CHAN_HALF_RATE(ah->curchan))
+  rxs->flag |= RX_FLAG_10MHZ;
+
+ if (rx_stats->rs_rate & 0x80) {
+  /* HT rate */
+  rxs->flag |= RX_FLAG_HT;
+  rxs->flag |= rx_stats->flag;
+  rxs->rate_idx = rx_stats->rs_rate & 0x7f;
+  return 0;
+ }
+
+ for (i = 0; i < sband->n_bitrates; i++) {
+  if (sband->bitrates[i].hw_value == rx_stats->rs_rate) {
+   rxs->rate_idx = i;
+   return 0;
+  }
+  if (sband->bitrates[i].hw_value_short == rx_stats->rs_rate) {
+   rxs->flag |= RX_FLAG_SHORTPRE;
+   rxs->rate_idx = i;
+   return 0;
+  }
+ }
+
+ return -EINVAL;
+}
+EXPORT_SYMBOL(ath9k_cmn_process_rate);
+
+void ath9k_cmn_process_rssi(struct ath_common *common,
+       struct ieee80211_hw *hw,
+       struct ath_rx_status *rx_stats,
+       struct ieee80211_rx_status *rxs)
+{
+ struct ath_hw *ah = common->ah;
+ int last_rssi;
+ int rssi = rx_stats->rs_rssi;
+ int i, j;
+
+ /*
+  * RSSI is not available for subframes in an A-MPDU.
+  */
+ if (rx_stats->rs_moreaggr) {
+  rxs->flag |= RX_FLAG_NO_SIGNAL_VAL;
+  return;
+ }
+
+ /*
+  * Check if the RSSI for the last subframe in an A-MPDU
+  * or an unaggregated frame is valid.
+  */
+ if (rx_stats->rs_rssi == ATH9K_RSSI_BAD) {
+  rxs->flag |= RX_FLAG_NO_SIGNAL_VAL;
+  return;
+ }
+
+ for (i = 0, j = 0; i < ARRAY_SIZE(rx_stats->rs_rssi_ctl); i++) {
+  s8 rssi;
+
+  if (!(ah->rxchainmask & BIT(i)))
+   continue;
+
+  rssi = rx_stats->rs_rssi_ctl[i];
+  if (rssi != ATH9K_RSSI_BAD) {
+      rxs->chains |= BIT(j);
+      rxs->chain_signal[j] = ah->noise + rssi;
+  }
+  j++;
+ }
+
+ /*
+  * Update Beacon RSSI, this is used by ANI.
+  */
+ if (rx_stats->is_mybeacon &&
+     ((ah->opmode == NL80211_IFTYPE_STATION) ||
+      (ah->opmode == NL80211_IFTYPE_ADHOC))) {
+  ATH_RSSI_LPF(common->last_rssi, rx_stats->rs_rssi);
+  last_rssi = common->last_rssi;
+
+  if (likely(last_rssi != ATH_RSSI_DUMMY_MARKER))
+   rssi = ATH_EP_RND(last_rssi, ATH_RSSI_EP_MULTIPLIER);
+  if (rssi < 0)
+   rssi = 0;
+
+  ah->stats.avgbrssi = rssi;
+ }
+
+ rxs->signal = ah->noise + rx_stats->rs_rssi;
+}
+EXPORT_SYMBOL(ath9k_cmn_process_rssi);
+
 int ath9k_cmn_get_hw_crypto_keytype(struct sk_buff *skb)
 {
  struct ieee80211_tx_info *tx_info = IEEE80211_SKB_CB(skb);
@@ -49,88 +293,62 @@ int ath9k_cmn_get_hw_crypto_keytype(struct sk_buff *skb)
 }
 EXPORT_SYMBOL(ath9k_cmn_get_hw_crypto_keytype);
 
-static u32 ath9k_get_extchanmode(struct ieee80211_channel *chan,
-     enum nl80211_channel_type channel_type)
-{
- u32 chanmode = 0;
-
- switch (chan->band) {
- case IEEE80211_BAND_2GHZ:
-  switch (channel_type) {
-  case NL80211_CHAN_NO_HT:
-  case NL80211_CHAN_HT20:
-   chanmode = CHANNEL_G_HT20;
-   break;
-  case NL80211_CHAN_HT40PLUS:
-   chanmode = CHANNEL_G_HT40PLUS;
-   break;
-  case NL80211_CHAN_HT40MINUS:
-   chanmode = CHANNEL_G_HT40MINUS;
-   break;
-  }
-  break;
- case IEEE80211_BAND_5GHZ:
-  switch (channel_type) {
-  case NL80211_CHAN_NO_HT:
-  case NL80211_CHAN_HT20:
-   chanmode = CHANNEL_A_HT20;
-   break;
-  case NL80211_CHAN_HT40PLUS:
-   chanmode = CHANNEL_A_HT40PLUS;
-   break;
-  case NL80211_CHAN_HT40MINUS:
-   chanmode = CHANNEL_A_HT40MINUS;
-   break;
-  }
-  break;
- default:
-  break;
- }
-
- return chanmode;
-}
-
 /*
  * Update internal channel flags.
  */
-void ath9k_cmn_update_ichannel(struct ath9k_channel *ichan,
-          struct ieee80211_channel *chan,
-          enum nl80211_channel_type channel_type)
+static void ath9k_cmn_update_ichannel(struct ath9k_channel *ichan,
+          struct cfg80211_chan_def *chandef)
 {
+ struct ieee80211_channel *chan = chandef->chan;
+ u16 flags = 0;
+
  ichan->channel = chan->center_freq;
  ichan->chan = chan;
 
- if (chan->band == IEEE80211_BAND_2GHZ) {
-  ichan->chanmode = CHANNEL_G;
-  ichan->channelFlags = CHANNEL_2GHZ | CHANNEL_OFDM;
- } else {
-  ichan->chanmode = CHANNEL_A;
-  ichan->channelFlags = CHANNEL_5GHZ | CHANNEL_OFDM;
+ if (chan->band == IEEE80211_BAND_5GHZ)
+  flags |= CHANNEL_5GHZ;
+
+ switch (chandef->width) {
+ case NL80211_CHAN_WIDTH_5:
+  flags |= CHANNEL_QUARTER;
+  break;
+ case NL80211_CHAN_WIDTH_10:
+  flags |= CHANNEL_HALF;
+  break;
+ case NL80211_CHAN_WIDTH_20_NOHT:
+  break;
+ case NL80211_CHAN_WIDTH_20:
+  flags |= CHANNEL_HT;
+  break;
+ case NL80211_CHAN_WIDTH_40:
+  if (chandef->center_freq1 > chandef->chan->center_freq)
+   flags |= CHANNEL_HT40PLUS | CHANNEL_HT;
+  else
+   flags |= CHANNEL_HT40MINUS | CHANNEL_HT;
+  break;
+ default:
+  WARN_ON(1);
  }
 
- if (channel_type != NL80211_CHAN_NO_HT)
-  ichan->chanmode = ath9k_get_extchanmode(chan, channel_type);
+ ichan->channelFlags = flags;
 }
-EXPORT_SYMBOL(ath9k_cmn_update_ichannel);
 
 /*
  * Get the internal channel reference.
  */
-struct ath9k_channel *ath9k_cmn_get_curchannel(struct ieee80211_hw *hw,
-            struct ath_hw *ah)
+struct ath9k_channel *ath9k_cmn_get_channel(struct ieee80211_hw *hw,
+         struct ath_hw *ah,
+         struct cfg80211_chan_def *chandef)
 {
- struct ieee80211_channel *curchan = hw->conf.chandef.chan;
+ struct ieee80211_channel *curchan = chandef->chan;
  struct ath9k_channel *channel;
- u8 chan_idx;
 
- chan_idx = curchan->hw_value;
- channel = &ah->channels[chan_idx];
- ath9k_cmn_update_ichannel(channel, curchan,
-      cfg80211_get_chandef_type(&hw->conf.chandef));
+ channel = &ah->channels[curchan->hw_value];
+ ath9k_cmn_update_ichannel(channel, chandef);
 
  return channel;
 }
-EXPORT_SYMBOL(ath9k_cmn_get_curchannel);
+EXPORT_SYMBOL(ath9k_cmn_get_channel);
 
 int ath9k_cmn_count_streams(unsigned int chainmask, int max)
 {
diff --git a/drivers/net/wireless/ath/ath9k/common.h b/drivers/net/wireless/ath/ath9k/common.h
index 207d069..ffc454b 100644
--- a/drivers/net/wireless/ath/ath9k/common.h
+++ b/drivers/net/wireless/ath/ath9k/common.h
@@ -21,6 +21,10 @@
 #include "hw.h"
 #include "hw-ops.h"
 
+#include "common-init.h"
+#include "common-beacon.h"
+#include "common-debug.h"
+
 /* Common header for Atheros 802.11n base driver cores */
 
 #define WME_BA_BMP_SIZE         64
@@ -42,12 +46,42 @@
 #define ATH_EP_RND(x, mul)       \
  (((x) + ((mul)/2)) / (mul))
 
+#define IEEE80211_MS_TO_TU(x)   (((x) * 1000) / 1024)
+
+struct ath_beacon_config {
+ int beacon_interval;
+ u16 dtim_period;
+ u16 bmiss_timeout;
+ u8 dtim_count;
+ bool enable_beacon;
+ bool ibss_creator;
+ u32 nexttbtt;
+ u32 intval;
+};
+
+bool ath9k_cmn_rx_accept(struct ath_common *common,
+    struct ieee80211_hdr *hdr,
+    struct ieee80211_rx_status *rxs,
+    struct ath_rx_status *rx_stats,
+    bool *decrypt_error,
+    unsigned int rxfilter);
+void ath9k_cmn_rx_skb_postprocess(struct ath_common *common,
+      struct sk_buff *skb,
+      struct ath_rx_status *rx_stats,
+      struct ieee80211_rx_status *rxs,
+      bool decrypt_error);
+int ath9k_cmn_process_rate(struct ath_common *common,
+      struct ieee80211_hw *hw,
+      struct ath_rx_status *rx_stats,
+      struct ieee80211_rx_status *rxs);
+void ath9k_cmn_process_rssi(struct ath_common *common,
+       struct ieee80211_hw *hw,
+       struct ath_rx_status *rx_stats,
+       struct ieee80211_rx_status *rxs);
 int ath9k_cmn_get_hw_crypto_keytype(struct sk_buff *skb);
-void ath9k_cmn_update_ichannel(struct ath9k_channel *ichan,
-          struct ieee80211_channel *chan,
-          enum nl80211_channel_type channel_type);
-struct ath9k_channel *ath9k_cmn_get_curchannel(struct ieee80211_hw *hw,
-            struct ath_hw *ah);
+struct ath9k_channel *ath9k_cmn_get_channel(struct ieee80211_hw *hw,
+         struct ath_hw *ah,
+         struct cfg80211_chan_def *chandef);
 int ath9k_cmn_count_streams(unsigned int chainmask, int max);
 void ath9k_cmn_btcoex_bt_stomp(struct ath_common *common,
       enum ath_stomp_type stomp_type);
diff --git a/drivers/net/wireless/ath/ath9k/debug.c b/drivers/net/wireless/ath/ath9k/debug.c
index b37eb8d..6cc42be 100644
--- a/drivers/net/wireless/ath/ath9k/debug.c
+++ b/drivers/net/wireless/ath/ath9k/debug.c
@@ -17,7 +17,6 @@
 #include <linux/slab.h>
 #include <linux/vmalloc.h>
 #include <linux/export.h>
-#include <linux/relay.h>
 #include <asm/unaligned.h>
 
 #include "ath9k.h"
@@ -27,6 +26,47 @@
 #define REG_READ_D(_ah, _reg) \
  ath9k_hw_common(_ah)->ops->read((_ah), (_reg))
 
+void ath9k_debug_sync_cause(struct ath_softc *sc, u32 sync_cause)
+{
+ if (sync_cause)
+  sc->debug.stats.istats.sync_cause_all++;
+ if (sync_cause & AR_INTR_SYNC_RTC_IRQ)
+  sc->debug.stats.istats.sync_rtc_irq++;
+ if (sync_cause & AR_INTR_SYNC_MAC_IRQ)
+  sc->debug.stats.istats.sync_mac_irq++;
+ if (sync_cause & AR_INTR_SYNC_EEPROM_ILLEGAL_ACCESS)
+  sc->debug.stats.istats.eeprom_illegal_access++;
+ if (sync_cause & AR_INTR_SYNC_APB_TIMEOUT)
+  sc->debug.stats.istats.apb_timeout++;
+ if (sync_cause & AR_INTR_SYNC_PCI_MODE_CONFLICT)
+  sc->debug.stats.istats.pci_mode_conflict++;
+ if (sync_cause & AR_INTR_SYNC_HOST1_FATAL)
+  sc->debug.stats.istats.host1_fatal++;
+ if (sync_cause & AR_INTR_SYNC_HOST1_PERR)
+  sc->debug.stats.istats.host1_perr++;
+ if (sync_cause & AR_INTR_SYNC_TRCV_FIFO_PERR)
+  sc->debug.stats.istats.trcv_fifo_perr++;
+ if (sync_cause & AR_INTR_SYNC_RADM_CPL_EP)
+  sc->debug.stats.istats.radm_cpl_ep++;
+ if (sync_cause & AR_INTR_SYNC_RADM_CPL_DLLP_ABORT)
+  sc->debug.stats.istats.radm_cpl_dllp_abort++;
+ if (sync_cause & AR_INTR_SYNC_RADM_CPL_TLP_ABORT)
+  sc->debug.stats.istats.radm_cpl_tlp_abort++;
+ if (sync_cause & AR_INTR_SYNC_RADM_CPL_ECRC_ERR)
+  sc->debug.stats.istats.radm_cpl_ecrc_err++;
+ if (sync_cause & AR_INTR_SYNC_RADM_CPL_TIMEOUT)
+  sc->debug.stats.istats.radm_cpl_timeout++;
+ if (sync_cause & AR_INTR_SYNC_LOCAL_TIMEOUT)
+  sc->debug.stats.istats.local_timeout++;
+ if (sync_cause & AR_INTR_SYNC_PM_ACCESS)
+  sc->debug.stats.istats.pm_access++;
+ if (sync_cause & AR_INTR_SYNC_MAC_AWAKE)
+  sc->debug.stats.istats.mac_awake++;
+ if (sync_cause & AR_INTR_SYNC_MAC_ASLEEP)
+  sc->debug.stats.istats.mac_asleep++;
+ if (sync_cause & AR_INTR_SYNC_MAC_SLEEP_ACCESS)
+  sc->debug.stats.istats.mac_sleep_access++;
+}
 
 static ssize_t ath9k_debugfs_read_buf(struct file *file, char __user *user_buf,
           size_t count, loff_t *ppos)
@@ -69,7 +109,7 @@ static ssize_t write_file_debug(struct file *file, const char __user *user_buf,
   return -EFAULT;
 
  buf[len] = '\0';
- if (strict_strtoul(buf, 0, &mask))
+ if (kstrtoul(buf, 0, &mask))
   return -EINVAL;
 
  common->debug_mask = mask;
@@ -88,67 +128,69 @@ static const struct file_operations fops_debug = {
 
 #define DMA_BUF_LEN 1024
 
-static ssize_t read_file_tx_chainmask(struct file *file, char __user *user_buf,
-        size_t count, loff_t *ppos)
-{
- struct ath_softc *sc = file->private_data;
- struct ath_hw *ah = sc->sc_ah;
- char buf[32];
- unsigned int len;
 
- len = sprintf(buf, "0x%08x\n", ah->txchainmask);
- return simple_read_from_buffer(user_buf, count, ppos, buf, len);
-}
-
-static ssize_t write_file_tx_chainmask(struct file *file, const char __user *user_buf,
+static ssize_t read_file_ani(struct file *file, char __user *user_buf,
         size_t count, loff_t *ppos)
 {
  struct ath_softc *sc = file->private_data;
+ struct ath_common *common = ath9k_hw_common(sc->sc_ah);
  struct ath_hw *ah = sc->sc_ah;
- unsigned long mask;
- char buf[32];
- ssize_t len;
+ unsigned int len = 0;
+ const unsigned int size = 1024;
+ ssize_t retval = 0;
+ char *buf;
+ int i;
+ struct {
+  const char *name;
+  unsigned int val;
+ } ani_info[] = {
+  { "ANI RESET", ah->stats.ast_ani_reset },
+  { "OFDM LEVEL", ah->ani.ofdmNoiseImmunityLevel },
+  { "CCK LEVEL", ah->ani.cckNoiseImmunityLevel },
+  { "SPUR UP", ah->stats.ast_ani_spurup },
+  { "SPUR DOWN", ah->stats.ast_ani_spurup },
+  { "OFDM WS-DET ON", ah->stats.ast_ani_ofdmon },
+  { "OFDM WS-DET OFF", ah->stats.ast_ani_ofdmoff },
+  { "MRC-CCK ON", ah->stats.ast_ani_ccklow },
+  { "MRC-CCK OFF", ah->stats.ast_ani_cckhigh },
+  { "FIR-STEP UP", ah->stats.ast_ani_stepup },
+  { "FIR-STEP DOWN", ah->stats.ast_ani_stepdown },
+  { "INV LISTENTIME", ah->stats.ast_ani_lneg_or_lzero },
+  { "OFDM ERRORS", ah->stats.ast_ani_ofdmerrs },
+  { "CCK ERRORS", ah->stats.ast_ani_cckerrs },
+ };
 
- len = min(count, sizeof(buf) - 1);
- if (copy_from_user(buf, user_buf, len))
-  return -EFAULT;
+ buf = kzalloc(size, GFP_KERNEL);
+ if (buf == NULL)
+  return -ENOMEM;
 
- buf[len] = '\0';
- if (strict_strtoul(buf, 0, &mask))
-  return -EINVAL;
+ len += scnprintf(buf + len, size - len, "%15s: %s\n", "ANI",
+    common->disable_ani ? "DISABLED" : "ENABLED");
 
- ah->txchainmask = mask;
- ah->caps.tx_chainmask = mask;
- return count;
-}
+ if (common->disable_ani)
+  goto exit;
 
-static const struct file_operations fops_tx_chainmask = {
- .read = read_file_tx_chainmask,
- .write = write_file_tx_chainmask,
- .open = simple_open,
- .owner = THIS_MODULE,
- .llseek = default_llseek,
-};
+ for (i = 0; i < ARRAY_SIZE(ani_info); i++)
+  len += scnprintf(buf + len, size - len, "%15s: %u\n",
+     ani_info[i].name, ani_info[i].val);
 
+exit:
+ if (len > size)
+  len = size;
 
-static ssize_t read_file_rx_chainmask(struct file *file, char __user *user_buf,
-        size_t count, loff_t *ppos)
-{
- struct ath_softc *sc = file->private_data;
- struct ath_hw *ah = sc->sc_ah;
- char buf[32];
- unsigned int len;
+ retval = simple_read_from_buffer(user_buf, count, ppos, buf, len);
+ kfree(buf);
 
- len = sprintf(buf, "0x%08x\n", ah->rxchainmask);
- return simple_read_from_buffer(user_buf, count, ppos, buf, len);
+ return retval;
 }
 
-static ssize_t write_file_rx_chainmask(struct file *file, const char __user *user_buf,
-        size_t count, loff_t *ppos)
+static ssize_t write_file_ani(struct file *file,
+         const char __user *user_buf,
+         size_t count, loff_t *ppos)
 {
  struct ath_softc *sc = file->private_data;
- struct ath_hw *ah = sc->sc_ah;
- unsigned long mask;
+ struct ath_common *common = ath9k_hw_common(sc->sc_ah);
+ unsigned long ani;
  char buf[32];
  ssize_t len;
 
@@ -157,41 +199,55 @@ static ssize_t write_file_rx_chainmask(struct file *file, const char __user *use
   return -EFAULT;
 
  buf[len] = '\0';
- if (strict_strtoul(buf, 0, &mask))
+ if (kstrtoul(buf, 0, &ani))
   return -EINVAL;
 
- ah->rxchainmask = mask;
- ah->caps.rx_chainmask = mask;
+ if (ani < 0 || ani > 1)
+  return -EINVAL;
+
+ common->disable_ani = !ani;
+
+ if (common->disable_ani) {
+  clear_bit(ATH_OP_ANI_RUN, &common->op_flags);
+  ath_stop_ani(sc);
+ } else {
+  ath_check_ani(sc);
+ }
+
  return count;
 }
 
-static const struct file_operations fops_rx_chainmask = {
- .read = read_file_rx_chainmask,
- .write = write_file_rx_chainmask,
+static const struct file_operations fops_ani = {
+ .read = read_file_ani,
+ .write = write_file_ani,
  .open = simple_open,
  .owner = THIS_MODULE,
  .llseek = default_llseek,
 };
 
-static ssize_t read_file_disable_ani(struct file *file, char __user *user_buf,
-        size_t count, loff_t *ppos)
+#ifdef CONFIG_ATH9K_BTCOEX_SUPPORT
+
+static ssize_t read_file_bt_ant_diversity(struct file *file,
+       char __user *user_buf,
+       size_t count, loff_t *ppos)
 {
  struct ath_softc *sc = file->private_data;
  struct ath_common *common = ath9k_hw_common(sc->sc_ah);
  char buf[32];
  unsigned int len;
 
- len = sprintf(buf, "%d\n", common->disable_ani);
+ len = sprintf(buf, "%d\n", common->bt_ant_diversity);
  return simple_read_from_buffer(user_buf, count, ppos, buf, len);
 }
 
-static ssize_t write_file_disable_ani(struct file *file,
-          const char __user *user_buf,
-          size_t count, loff_t *ppos)
+static ssize_t write_file_bt_ant_diversity(struct file *file,
+        const char __user *user_buf,
+        size_t count, loff_t *ppos)
 {
  struct ath_softc *sc = file->private_data;
  struct ath_common *common = ath9k_hw_common(sc->sc_ah);
- unsigned long disable_ani;
+ struct ath9k_hw_capabilities *pCap = &sc->sc_ah->caps;
+ unsigned long bt_ant_diversity;
  char buf[32];
  ssize_t len;
 
@@ -199,76 +255,147 @@ static ssize_t write_file_disable_ani(struct file *file,
  if (copy_from_user(buf, user_buf, len))
   return -EFAULT;
 
+ if (!(pCap->hw_caps & ATH9K_HW_CAP_BT_ANT_DIV))
+  goto exit;
+
  buf[len] = '\0';
- if (strict_strtoul(buf, 0, &disable_ani))
+ if (kstrtoul(buf, 0, &bt_ant_diversity))
   return -EINVAL;
 
- common->disable_ani = !!disable_ani;
-
- if (disable_ani) {
-  clear_bit(SC_OP_ANI_RUN, &sc->sc_flags);
-  ath_stop_ani(sc);
- } else {
-  ath_check_ani(sc);
- }
-
+ common->bt_ant_diversity = !!bt_ant_diversity;
+ ath9k_ps_wakeup(sc);
+ ath9k_hw_set_bt_ant_diversity(sc->sc_ah, common->bt_ant_diversity);
+ ath_dbg(common, CONFIG, "Enable WLAN/BT RX Antenna diversity: %d\n",
+  common->bt_ant_diversity);
+ ath9k_ps_restore(sc);
+exit:
  return count;
 }
 
-static const struct file_operations fops_disable_ani = {
- .read = read_file_disable_ani,
- .write = write_file_disable_ani,
+static const struct file_operations fops_bt_ant_diversity = {
+ .read = read_file_bt_ant_diversity,
+ .write = write_file_bt_ant_diversity,
  .open = simple_open,
  .owner = THIS_MODULE,
  .llseek = default_llseek,
 };
 
-static ssize_t read_file_ant_diversity(struct file *file, char __user *user_buf,
-           size_t count, loff_t *ppos)
+#endif
+
+void ath9k_debug_stat_ant(struct ath_softc *sc,
+     struct ath_hw_antcomb_conf *div_ant_conf,
+     int main_rssi_avg, int alt_rssi_avg)
 {
- struct ath_softc *sc = file->private_data;
- struct ath_common *common = ath9k_hw_common(sc->sc_ah);
- char buf[32];
- unsigned int len;
+ struct ath_antenna_stats *as_main = &sc->debug.stats.ant_stats[ANT_MAIN];
+ struct ath_antenna_stats *as_alt = &sc->debug.stats.ant_stats[ANT_ALT];
 
- len = sprintf(buf, "%d\n", common->antenna_diversity);
- return simple_read_from_buffer(user_buf, count, ppos, buf, len);
+ as_main->lna_attempt_cnt[div_ant_conf->main_lna_conf]++;
+ as_alt->lna_attempt_cnt[div_ant_conf->alt_lna_conf]++;
+
+ as_main->rssi_avg = main_rssi_avg;
+ as_alt->rssi_avg = alt_rssi_avg;
 }
 
-static ssize_t write_file_ant_diversity(struct file *file,
-     const char __user *user_buf,
-     size_t count, loff_t *ppos)
+static ssize_t read_file_antenna_diversity(struct file *file,
+        char __user *user_buf,
+        size_t count, loff_t *ppos)
 {
  struct ath_softc *sc = file->private_data;
- struct ath_common *common = ath9k_hw_common(sc->sc_ah);
- unsigned long antenna_diversity;
- char buf[32];
- ssize_t len;
+ struct ath_hw *ah = sc->sc_ah;
+ struct ath9k_hw_capabilities *pCap = &ah->caps;
+ struct ath_antenna_stats *as_main = &sc->debug.stats.ant_stats[ANT_MAIN];
+ struct ath_antenna_stats *as_alt = &sc->debug.stats.ant_stats[ANT_ALT];
+ struct ath_hw_antcomb_conf div_ant_conf;
+ unsigned int len = 0;
+ const unsigned int size = 1024;
+ ssize_t retval = 0;
+ char *buf;
+ static const char *lna_conf_str[4] = {
+  "LNA1_MINUS_LNA2", "LNA2", "LNA1", "LNA1_PLUS_LNA2"
+ };
 
- len = min(count, sizeof(buf) - 1);
- if (copy_from_user(buf, user_buf, len))
-  return -EFAULT;
+ buf = kzalloc(size, GFP_KERNEL);
+ if (buf == NULL)
+  return -ENOMEM;
 
- if (!AR_SREV_9565(sc->sc_ah))
+ if (!(pCap->hw_caps & ATH9K_HW_CAP_ANT_DIV_COMB)) {
+  len += scnprintf(buf + len, size - len, "%s\n",
+     "Antenna Diversity Combining is disabled");
   goto exit;
+ }
 
- buf[len] = '\0';
- if (strict_strtoul(buf, 0, &antenna_diversity))
-  return -EINVAL;
-
- common->antenna_diversity = !!antenna_diversity;
  ath9k_ps_wakeup(sc);
- ath_ant_comb_update(sc);
- ath_dbg(common, CONFIG, "Antenna diversity: %d\n",
-  common->antenna_diversity);
+ ath9k_hw_antdiv_comb_conf_get(ah, &div_ant_conf);
+ len += scnprintf(buf + len, size - len, "Current MAIN config : %s\n",
+    lna_conf_str[div_ant_conf.main_lna_conf]);
+ len += scnprintf(buf + len, size - len, "Current ALT config  : %s\n",
+    lna_conf_str[div_ant_conf.alt_lna_conf]);
+ len += scnprintf(buf + len, size - len, "Average MAIN RSSI   : %d\n",
+    as_main->rssi_avg);
+ len += scnprintf(buf + len, size - len, "Average ALT RSSI    : %d\n\n",
+    as_alt->rssi_avg);
  ath9k_ps_restore(sc);
+
+ len += scnprintf(buf + len, size - len, "Packet Receive Cnt:\n");
+ len += scnprintf(buf + len, size - len, "-------------------\n");
+
+ len += scnprintf(buf + len, size - len, "%30s%15s\n",
+    "MAIN", "ALT");
+ len += scnprintf(buf + len, size - len, "%-14s:%15d%15d\n",
+    "TOTAL COUNT",
+    as_main->recv_cnt,
+    as_alt->recv_cnt);
+ len += scnprintf(buf + len, size - len, "%-14s:%15d%15d\n",
+    "LNA1",
+    as_main->lna_recv_cnt[ATH_ANT_DIV_COMB_LNA1],
+    as_alt->lna_recv_cnt[ATH_ANT_DIV_COMB_LNA1]);
+ len += scnprintf(buf + len, size - len, "%-14s:%15d%15d\n",
+    "LNA2",
+    as_main->lna_recv_cnt[ATH_ANT_DIV_COMB_LNA2],
+    as_alt->lna_recv_cnt[ATH_ANT_DIV_COMB_LNA2]);
+ len += scnprintf(buf + len, size - len, "%-14s:%15d%15d\n",
+    "LNA1 + LNA2",
+    as_main->lna_recv_cnt[ATH_ANT_DIV_COMB_LNA1_PLUS_LNA2],
+    as_alt->lna_recv_cnt[ATH_ANT_DIV_COMB_LNA1_PLUS_LNA2]);
+ len += scnprintf(buf + len, size - len, "%-14s:%15d%15d\n",
+    "LNA1 - LNA2",
+    as_main->lna_recv_cnt[ATH_ANT_DIV_COMB_LNA1_MINUS_LNA2],
+    as_alt->lna_recv_cnt[ATH_ANT_DIV_COMB_LNA1_MINUS_LNA2]);
+
+ len += scnprintf(buf + len, size - len, "\nLNA Config Attempts:\n");
+ len += scnprintf(buf + len, size - len, "--------------------\n");
+
+ len += scnprintf(buf + len, size - len, "%30s%15s\n",
+    "MAIN", "ALT");
+ len += scnprintf(buf + len, size - len, "%-14s:%15d%15d\n",
+    "LNA1",
+    as_main->lna_attempt_cnt[ATH_ANT_DIV_COMB_LNA1],
+    as_alt->lna_attempt_cnt[ATH_ANT_DIV_COMB_LNA1]);
+ len += scnprintf(buf + len, size - len, "%-14s:%15d%15d\n",
+    "LNA2",
+    as_main->lna_attempt_cnt[ATH_ANT_DIV_COMB_LNA2],
+    as_alt->lna_attempt_cnt[ATH_ANT_DIV_COMB_LNA2]);
+ len += scnprintf(buf + len, size - len, "%-14s:%15d%15d\n",
+    "LNA1 + LNA2",
+    as_main->lna_attempt_cnt[ATH_ANT_DIV_COMB_LNA1_PLUS_LNA2],
+    as_alt->lna_attempt_cnt[ATH_ANT_DIV_COMB_LNA1_PLUS_LNA2]);
+ len += scnprintf(buf + len, size - len, "%-14s:%15d%15d\n",
+    "LNA1 - LNA2",
+    as_main->lna_attempt_cnt[ATH_ANT_DIV_COMB_LNA1_MINUS_LNA2],
+    as_alt->lna_attempt_cnt[ATH_ANT_DIV_COMB_LNA1_MINUS_LNA2]);
+
 exit:
- return count;
+ if (len > size)
+  len = size;
+
+ retval = simple_read_from_buffer(user_buf, count, ppos, buf, len);
+ kfree(buf);
+
+ return retval;
 }
 
-static const struct file_operations fops_ant_diversity = {
- .read = read_file_ant_diversity,
- .write = write_file_ant_diversity,
+static const struct file_operations fops_antenna_diversity = {
+ .read = read_file_antenna_diversity,
  .open = simple_open,
  .owner = THIS_MODULE,
  .llseek = default_llseek,
@@ -297,21 +424,21 @@ static ssize_t read_file_dma(struct file *file, char __user *user_buf,
      (AR_MACMISC_MISC_OBS_BUS_1 <<
       AR_MACMISC_MISC_OBS_BUS_MSB_S)));
 
- len += snprintf(buf + len, DMA_BUF_LEN - len,
-   "Raw DMA Debug values:\n");
+ len += scnprintf(buf + len, DMA_BUF_LEN - len,
+    "Raw DMA Debug values:\n");
 
  for (i = 0; i < ATH9K_NUM_DMA_DEBUG_REGS; i++) {
   if (i % 4 == 0)
-   len += snprintf(buf + len, DMA_BUF_LEN - len, "\n");
+   len += scnprintf(buf + len, DMA_BUF_LEN - len, "\n");
 
   val[i] = REG_READ_D(ah, AR_DMADBG_0 + (i * sizeof(u32)));
-  len += snprintf(buf + len, DMA_BUF_LEN - len, "%d: %08x ",
-    i, val[i]);
+  len += scnprintf(buf + len, DMA_BUF_LEN - len, "%d: %08x ",
+     i, val[i]);
  }
 
- len += snprintf(buf + len, DMA_BUF_LEN - len, "\n\n");
- len += snprintf(buf + len, DMA_BUF_LEN - len,
-   "Num QCU: chain_st fsp_ok fsp_st DCU: chain_st\n");
+ len += scnprintf(buf + len, DMA_BUF_LEN - len, "\n\n");
+ len += scnprintf(buf + len, DMA_BUF_LEN - len,
+    "Num QCU: chain_st fsp_ok fsp_st DCU: chain_st\n");
 
  for (i = 0; i < ATH9K_NUM_QUEUES; i++, qcuOffset += 4, dcuOffset += 5) {
   if (i == 8) {
@@ -324,39 +451,39 @@ static ssize_t read_file_dma(struct file *file, char __user *user_buf,
    dcuBase++;
   }
 
-  len += snprintf(buf + len, DMA_BUF_LEN - len,
-   "%2d          %2x      %1x     %2x           %2x\n",
-   i, (*qcuBase & (0x7 << qcuOffset)) >> qcuOffset,
-   (*qcuBase & (0x8 << qcuOffset)) >> (qcuOffset + 3),
-   val[2] & (0x7 << (i * 3)) >> (i * 3),
-   (*dcuBase & (0x1f << dcuOffset)) >> dcuOffset);
+  len += scnprintf(buf + len, DMA_BUF_LEN - len,
+    "%2d          %2x      %1x     %2x           %2x\n",
+    i, (*qcuBase & (0x7 << qcuOffset)) >> qcuOffset,
+    (*qcuBase & (0x8 << qcuOffset)) >> (qcuOffset + 3),
+    val[2] & (0x7 << (i * 3)) >> (i * 3),
+    (*dcuBase & (0x1f << dcuOffset)) >> dcuOffset);
  }
 
- len += snprintf(buf + len, DMA_BUF_LEN - len, "\n");
+ len += scnprintf(buf + len, DMA_BUF_LEN - len, "\n");
 
- len += snprintf(buf + len, DMA_BUF_LEN - len,
+ len += scnprintf(buf + len, DMA_BUF_LEN - len,
   "qcu_stitch state:   %2x    qcu_fetch state:        %2x\n",
   (val[3] & 0x003c0000) >> 18, (val[3] & 0x03c00000) >> 22);
- len += snprintf(buf + len, DMA_BUF_LEN - len,
+ len += scnprintf(buf + len, DMA_BUF_LEN - len,
   "qcu_complete state: %2x    dcu_complete state:     %2x\n",
   (val[3] & 0x1c000000) >> 26, (val[6] & 0x3));
- len += snprintf(buf + len, DMA_BUF_LEN - len,
+ len += scnprintf(buf + len, DMA_BUF_LEN - len,
   "dcu_arb state:      %2x    dcu_fp state:           %2x\n",
   (val[5] & 0x06000000) >> 25, (val[5] & 0x38000000) >> 27);
- len += snprintf(buf + len, DMA_BUF_LEN - len,
+ len += scnprintf(buf + len, DMA_BUF_LEN - len,
   "chan_idle_dur:     %3d    chan_idle_dur_valid:     %1d\n",
   (val[6] & 0x000003fc) >> 2, (val[6] & 0x00000400) >> 10);
- len += snprintf(buf + len, DMA_BUF_LEN - len,
+ len += scnprintf(buf + len, DMA_BUF_LEN - len,
   "txfifo_valid_0:      %1d    txfifo_valid_1:          %1d\n",
   (val[6] & 0x00000800) >> 11, (val[6] & 0x00001000) >> 12);
- len += snprintf(buf + len, DMA_BUF_LEN - len,
+ len += scnprintf(buf + len, DMA_BUF_LEN - len,
   "txfifo_dcu_num_0:   %2d    txfifo_dcu_num_1:       %2d\n",
   (val[6] & 0x0001e000) >> 13, (val[6] & 0x001e0000) >> 17);
 
- len += snprintf(buf + len, DMA_BUF_LEN - len, "pcu observe: 0x%x\n",
-   REG_READ_D(ah, AR_OBS_BUS_1));
- len += snprintf(buf + len, DMA_BUF_LEN - len,
-   "AR_CR: 0x%x\n", REG_READ_D(ah, AR_CR));
+ len += scnprintf(buf + len, DMA_BUF_LEN - len, "pcu observe: 0x%x\n",
+    REG_READ_D(ah, AR_OBS_BUS_1));
+ len += scnprintf(buf + len, DMA_BUF_LEN - len,
+    "AR_CR: 0x%x\n", REG_READ_D(ah, AR_CR));
 
  ath9k_ps_restore(sc);
 
@@ -442,9 +569,9 @@ static ssize_t read_file_interrupt(struct file *file, char __user *user_buf,
 
 #define PR_IS(a, s)      \
  do {       \
-  len += snprintf(buf + len, mxlen - len,  \
-    "%21s: %10u\n", a,  \
-    sc->debug.stats.istats.s); \
+  len += scnprintf(buf + len, mxlen - len, \
+     "%21s: %10u\n", a,  \
+     sc->debug.stats.istats.s); \
  } while (0)
 
  if (sc->sc_ah->caps.hw_caps & ATH9K_HW_CAP_EDMA) {
@@ -475,8 +602,8 @@ static ssize_t read_file_interrupt(struct file *file, char __user *user_buf,
  PR_IS("GENTIMER", gen_timer);
  PR_IS("TOTAL", total);
 
- len += snprintf(buf + len, mxlen - len,
-   "SYNC_CAUSE stats:\n");
+ len += scnprintf(buf + len, mxlen - len,
+    "SYNC_CAUSE stats:\n");
 
  PR_IS("Sync-All", sync_cause_all);
  PR_IS("RTC-IRQ", sync_rtc_irq);
@@ -560,16 +687,41 @@ static ssize_t read_file_xmit(struct file *file, char __user *user_buf,
  return retval;
 }
 
+static ssize_t print_queue(struct ath_softc *sc, struct ath_txq *txq,
+      char *buf, ssize_t size)
+{
+ ssize_t len = 0;
+
+ ath_txq_lock(sc, txq);
+
+ len += scnprintf(buf + len, size - len, "%s: %d ",
+    "qnum", txq->axq_qnum);
+ len += scnprintf(buf + len, size - len, "%s: %2d ",
+    "qdepth", txq->axq_depth);
+ len += scnprintf(buf + len, size - len, "%s: %2d ",
+    "ampdu-depth", txq->axq_ampdu_depth);
+ len += scnprintf(buf + len, size - len, "%s: %3d ",
+    "pending", txq->pending_frames);
+ len += scnprintf(buf + len, size - len, "%s: %d\n",
+    "stopped", txq->stopped);
+
+ ath_txq_unlock(sc, txq);
+ return len;
+}
+
 static ssize_t read_file_queues(struct file *file, char __user *user_buf,
     size_t count, loff_t *ppos)
 {
  struct ath_softc *sc = file->private_data;
  struct ath_txq *txq;
  char *buf;
- unsigned int len = 0, size = 1024;
+ unsigned int len = 0;
+ const unsigned int size = 1024;
  ssize_t retval = 0;
  int i;
- char *qname[4] = {"VO", "VI", "BE", "BK"};
+ static const char *qname[4] = {
+  "VO", "VI", "BE", "BK"
+ };
 
  buf = kzalloc(size, GFP_KERNEL);
  if (buf == NULL)
@@ -577,24 +729,13 @@ static ssize_t read_file_queues(struct file *file, char __user *user_buf,
 
  for (i = 0; i < IEEE80211_NUM_ACS; i++) {
   txq = sc->tx.txq_map[i];
-  len += snprintf(buf + len, size - len, "(%s): ", qname[i]);
-
-  ath_txq_lock(sc, txq);
-
-  len += snprintf(buf + len, size - len, "%s: %d ",
-    "qnum", txq->axq_qnum);
-  len += snprintf(buf + len, size - len, "%s: %2d ",
-    "qdepth", txq->axq_depth);
-  len += snprintf(buf + len, size - len, "%s: %2d ",
-    "ampdu-depth", txq->axq_ampdu_depth);
-  len += snprintf(buf + len, size - len, "%s: %3d ",
-    "pending", txq->pending_frames);
-  len += snprintf(buf + len, size - len, "%s: %d\n",
-    "stopped", txq->stopped);
-
-  ath_txq_unlock(sc, txq);
+  len += scnprintf(buf + len, size - len, "(%s):  ", qname[i]);
+  len += print_queue(sc, txq, buf + len, size - len);
  }
 
+ len += scnprintf(buf + len, size - len, "(CAB): ");
+ len += print_queue(sc, sc->beacon.cabq, buf + len, size - len);
+
  if (len > size)
   len = size;
 
@@ -617,80 +758,82 @@ static ssize_t read_file_misc(struct file *file, char __user *user_buf,
  unsigned int reg;
  u32 rxfilter;
 
- len += snprintf(buf + len, sizeof(buf) - len,
-   "BSSID: %pM\n", common->curbssid);
- len += snprintf(buf + len, sizeof(buf) - len,
-   "BSSID-MASK: %pM\n", common->bssidmask);
- len += snprintf(buf + len, sizeof(buf) - len,
-   "OPMODE: %s\n", ath_opmode_to_string(sc->sc_ah->opmode));
+ len += scnprintf(buf + len, sizeof(buf) - len,
+    "BSSID: %pM\n", common->curbssid);
+ len += scnprintf(buf + len, sizeof(buf) - len,
+    "BSSID-MASK: %pM\n", common->bssidmask);
+ len += scnprintf(buf + len, sizeof(buf) - len,
+    "OPMODE: %s\n",
+    ath_opmode_to_string(sc->sc_ah->opmode));
 
  ath9k_ps_wakeup(sc);
  rxfilter = ath9k_hw_getrxfilter(sc->sc_ah);
  ath9k_ps_restore(sc);
 
- len += snprintf(buf + len, sizeof(buf) - len,
-   "RXFILTER: 0x%x", rxfilter);
+ len += scnprintf(buf + len, sizeof(buf) - len,
+    "RXFILTER: 0x%x", rxfilter);
 
  if (rxfilter & ATH9K_RX_FILTER_UCAST)
-  len += snprintf(buf + len, sizeof(buf) - len, " UCAST");
+  len += scnprintf(buf + len, sizeof(buf) - len, " UCAST");
  if (rxfilter & ATH9K_RX_FILTER_MCAST)
-  len += snprintf(buf + len, sizeof(buf) - len, " MCAST");
+  len += scnprintf(buf + len, sizeof(buf) - len, " MCAST");
  if (rxfilter & ATH9K_RX_FILTER_BCAST)
-  len += snprintf(buf + len, sizeof(buf) - len, " BCAST");
+  len += scnprintf(buf + len, sizeof(buf) - len, " BCAST");
  if (rxfilter & ATH9K_RX_FILTER_CONTROL)
-  len += snprintf(buf + len, sizeof(buf) - len, " CONTROL");
+  len += scnprintf(buf + len, sizeof(buf) - len, " CONTROL");
  if (rxfilter & ATH9K_RX_FILTER_BEACON)
-  len += snprintf(buf + len, sizeof(buf) - len, " BEACON");
+  len += scnprintf(buf + len, sizeof(buf) - len, " BEACON");
  if (rxfilter & ATH9K_RX_FILTER_PROM)
-  len += snprintf(buf + len, sizeof(buf) - len, " PROM");
+  len += scnprintf(buf + len, sizeof(buf) - len, " PROM");
  if (rxfilter & ATH9K_RX_FILTER_PROBEREQ)
-  len += snprintf(buf + len, sizeof(buf) - len, " PROBEREQ");
+  len += scnprintf(buf + len, sizeof(buf) - len, " PROBEREQ");
  if (rxfilter & ATH9K_RX_FILTER_PHYERR)
-  len += snprintf(buf + len, sizeof(buf) - len, " PHYERR");
+  len += scnprintf(buf + len, sizeof(buf) - len, " PHYERR");
  if (rxfilter & ATH9K_RX_FILTER_MYBEACON)
-  len += snprintf(buf + len, sizeof(buf) - len, " MYBEACON");
+  len += scnprintf(buf + len, sizeof(buf) - len, " MYBEACON");
  if (rxfilter & ATH9K_RX_FILTER_COMP_BAR)
-  len += snprintf(buf + len, sizeof(buf) - len, " COMP_BAR");
+  len += scnprintf(buf + len, sizeof(buf) - len, " COMP_BAR");
  if (rxfilter & ATH9K_RX_FILTER_PSPOLL)
-  len += snprintf(buf + len, sizeof(buf) - len, " PSPOLL");
+  len += scnprintf(buf + len, sizeof(buf) - len, " PSPOLL");
  if (rxfilter & ATH9K_RX_FILTER_PHYRADAR)
-  len += snprintf(buf + len, sizeof(buf) - len, " PHYRADAR");
+  len += scnprintf(buf + len, sizeof(buf) - len, " PHYRADAR");
  if (rxfilter & ATH9K_RX_FILTER_MCAST_BCAST_ALL)
-  len += snprintf(buf + len, sizeof(buf) - len, " MCAST_BCAST_ALL");
+  len += scnprintf(buf + len, sizeof(buf) - len, " MCAST_BCAST_ALL");
  if (rxfilter & ATH9K_RX_FILTER_CONTROL_WRAPPER)
-  len += snprintf(buf + len, sizeof(buf) - len, " CONTROL_WRAPPER");
+  len += scnprintf(buf + len, sizeof(buf) - len, " CONTROL_WRAPPER");
 
- len += snprintf(buf + len, sizeof(buf) - len, "\n");
+ len += scnprintf(buf + len, sizeof(buf) - len, "\n");
 
  reg = sc->sc_ah->imask;
 
- len += snprintf(buf + len, sizeof(buf) - len, "INTERRUPT-MASK: 0x%x", reg);
+ len += scnprintf(buf + len, sizeof(buf) - len,
+    "INTERRUPT-MASK: 0x%x", reg);
 
  if (reg & ATH9K_INT_SWBA)
-  len += snprintf(buf + len, sizeof(buf) - len, " SWBA");
+  len += scnprintf(buf + len, sizeof(buf) - len, " SWBA");
  if (reg & ATH9K_INT_BMISS)
-  len += snprintf(buf + len, sizeof(buf) - len, " BMISS");
+  len += scnprintf(buf + len, sizeof(buf) - len, " BMISS");
  if (reg & ATH9K_INT_CST)
-  len += snprintf(buf + len, sizeof(buf) - len, " CST");
+  len += scnprintf(buf + len, sizeof(buf) - len, " CST");
  if (reg & ATH9K_INT_RX)
-  len += snprintf(buf + len, sizeof(buf) - len, " RX");
+  len += scnprintf(buf + len, sizeof(buf) - len, " RX");
  if (reg & ATH9K_INT_RXHP)
-  len += snprintf(buf + len, sizeof(buf) - len, " RXHP");
+  len += scnprintf(buf + len, sizeof(buf) - len, " RXHP");
  if (reg & ATH9K_INT_RXLP)
-  len += snprintf(buf + len, sizeof(buf) - len, " RXLP");
+  len += scnprintf(buf + len, sizeof(buf) - len, " RXLP");
  if (reg & ATH9K_INT_BB_WATCHDOG)
-  len += snprintf(buf + len, sizeof(buf) - len, " BB_WATCHDOG");
+  len += scnprintf(buf + len, sizeof(buf) - len, " BB_WATCHDOG");
 
- len += snprintf(buf + len, sizeof(buf) - len, "\n");
+ len += scnprintf(buf + len, sizeof(buf) - len, "\n");
 
  ath9k_calculate_iter_data(hw, NULL, &iter_data);
 
- len += snprintf(buf + len, sizeof(buf) - len,
-   "VIF-COUNTS: AP: %i STA: %i MESH: %i WDS: %i"
-   " ADHOC: %i TOTAL: %hi BEACON-VIF: %hi\n",
-   iter_data.naps, iter_data.nstations, iter_data.nmeshes,
-   iter_data.nwds, iter_data.nadhocs,
-   sc->nvifs, sc->nbcnvifs);
+ len += scnprintf(buf + len, sizeof(buf) - len,
+    "VIF-COUNTS: AP: %i STA: %i MESH: %i WDS: %i"
+    " ADHOC: %i TOTAL: %hi BEACON-VIF: %hi\n",
+    iter_data.naps, iter_data.nstations, iter_data.nmeshes,
+    iter_data.nwds, iter_data.nadhocs,
+    sc->nvifs, sc->nbcnvifs);
 
  if (len > sizeof(buf))
   len = sizeof(buf);
@@ -706,27 +849,33 @@ static ssize_t read_file_reset(struct file *file, char __user *user_buf,
  char buf[512];
  unsigned int len = 0;
 
- len += snprintf(buf + len, sizeof(buf) - len,
-   "%17s: %2d\n", "Baseband Hang",
-   sc->debug.stats.reset[RESET_TYPE_BB_HANG]);
- len += snprintf(buf + len, sizeof(buf) - len,
-   "%17s: %2d\n", "Baseband Watchdog",
-   sc->debug.stats.reset[RESET_TYPE_BB_WATCHDOG]);
- len += snprintf(buf + len, sizeof(buf) - len,
-   "%17s: %2d\n", "Fatal HW Error",
-   sc->debug.stats.reset[RESET_TYPE_FATAL_INT]);
- len += snprintf(buf + len, sizeof(buf) - len,
-   "%17s: %2d\n", "TX HW error",
-   sc->debug.stats.reset[RESET_TYPE_TX_ERROR]);
- len += snprintf(buf + len, sizeof(buf) - len,
-   "%17s: %2d\n", "TX Path Hang",
-   sc->debug.stats.reset[RESET_TYPE_TX_HANG]);
- len += snprintf(buf + len, sizeof(buf) - len,
-   "%17s: %2d\n", "PLL RX Hang",
-   sc->debug.stats.reset[RESET_TYPE_PLL_HANG]);
- len += snprintf(buf + len, sizeof(buf) - len,
-   "%17s: %2d\n", "MCI Reset",
-   sc->debug.stats.reset[RESET_TYPE_MCI]);
+ len += scnprintf(buf + len, sizeof(buf) - len,
+    "%17s: %2d\n", "Baseband Hang",
+    sc->debug.stats.reset[RESET_TYPE_BB_HANG]);
+ len += scnprintf(buf + len, sizeof(buf) - len,
+    "%17s: %2d\n", "Baseband Watchdog",
+    sc->debug.stats.reset[RESET_TYPE_BB_WATCHDOG]);
+ len += scnprintf(buf + len, sizeof(buf) - len,
+    "%17s: %2d\n", "Fatal HW Error",
+    sc->debug.stats.reset[RESET_TYPE_FATAL_INT]);
+ len += scnprintf(buf + len, sizeof(buf) - len,
+    "%17s: %2d\n", "TX HW error",
+    sc->debug.stats.reset[RESET_TYPE_TX_ERROR]);
+ len += scnprintf(buf + len, sizeof(buf) - len,
+    "%17s: %2d\n", "TX Path Hang",
+    sc->debug.stats.reset[RESET_TYPE_TX_HANG]);
+ len += scnprintf(buf + len, sizeof(buf) - len,
+    "%17s: %2d\n", "PLL RX Hang",
+    sc->debug.stats.reset[RESET_TYPE_PLL_HANG]);
+ len += scnprintf(buf + len, sizeof(buf) - len,
+    "%17s: %2d\n", "MAC Hang",
+    sc->debug.stats.reset[RESET_TYPE_MAC_HANG]);
+ len += scnprintf(buf + len, sizeof(buf) - len,
+    "%17s: %2d\n", "Stuck Beacon",
+    sc->debug.stats.reset[RESET_TYPE_BEACON_STUCK]);
+ len += scnprintf(buf + len, sizeof(buf) - len,
+    "%17s: %2d\n", "MCI Reset",
+    sc->debug.stats.reset[RESET_TYPE_MCI]);
 
  if (len > sizeof(buf))
   len = sizeof(buf);
@@ -738,8 +887,6 @@ void ath_debug_stat_tx(struct ath_softc *sc, struct ath_buf *bf,
          struct ath_tx_status *ts, struct ath_txq *txq,
          unsigned int flags)
 {
-#define TX_SAMP_DBG(c) (sc->debug.bb_mac_samp[sc->debug.sampidx].ts\
-   [sc->debug.tsidx].c)
  int qnum = txq->axq_qnum;
 
  TX_STAT_INC(qnum, tx_pkts_all);
@@ -771,37 +918,6 @@ void ath_debug_stat_tx(struct ath_softc *sc, struct ath_buf *bf,
   TX_STAT_INC(qnum, data_underrun);
  if (ts->ts_flags & ATH9K_TX_DELIM_UNDERRUN)
   TX_STAT_INC(qnum, delim_underrun);
-
-#ifdef CONFIG_ATH9K_MAC_DEBUG
- spin_lock(&sc->debug.samp_lock);
- TX_SAMP_DBG(jiffies) = jiffies;
- TX_SAMP_DBG(rssi_ctl0) = ts->ts_rssi_ctl0;
- TX_SAMP_DBG(rssi_ctl1) = ts->ts_rssi_ctl1;
- TX_SAMP_DBG(rssi_ctl2) = ts->ts_rssi_ctl2;
- TX_SAMP_DBG(rssi_ext0) = ts->ts_rssi_ext0;
- TX_SAMP_DBG(rssi_ext1) = ts->ts_rssi_ext1;
- TX_SAMP_DBG(rssi_ext2) = ts->ts_rssi_ext2;
- TX_SAMP_DBG(rateindex) = ts->ts_rateindex;
- TX_SAMP_DBG(isok) = !!(ts->ts_status & ATH9K_TXERR_MASK);
- TX_SAMP_DBG(rts_fail_cnt) = ts->ts_shortretry;
- TX_SAMP_DBG(data_fail_cnt) = ts->ts_longretry;
- TX_SAMP_DBG(rssi) = ts->ts_rssi;
- TX_SAMP_DBG(tid) = ts->tid;
- TX_SAMP_DBG(qid) = ts->qid;
-
- if (ts->ts_flags & ATH9K_TX_BA) {
-  TX_SAMP_DBG(ba_low) = ts->ba_low;
-  TX_SAMP_DBG(ba_high) = ts->ba_high;
- } else {
-  TX_SAMP_DBG(ba_low) = 0;
-  TX_SAMP_DBG(ba_high) = 0;
- }
-
- sc->debug.tsidx = (sc->debug.tsidx + 1) % ATH_DBG_MAX_SAMPLES;
- spin_unlock(&sc->debug.samp_lock);
-#endif
-
-#undef TX_SAMP_DBG
 }
 
 static const struct file_operations fops_xmit = {
@@ -832,428 +948,11 @@ static const struct file_operations fops_reset = {
  .llseek = default_llseek,
 };
 
-static ssize_t read_file_recv(struct file *file, char __user *user_buf,
-         size_t count, loff_t *ppos)
-{
-#define PHY_ERR(s, p) \
- len += snprintf(buf + len, size - len, "%22s : %10u\n", s, \
-   sc->debug.stats.rxstats.phy_err_stats[p]);
-
-#define RXS_ERR(s, e)         \
- do {          \
-  len += snprintf(buf + len, size - len,     \
-    "%22s : %10u\n", s,     \
-    sc->debug.stats.rxstats.e); \
- } while (0)
-
- struct ath_softc *sc = file->private_data;
- char *buf;
- unsigned int len = 0, size = 1600;
- ssize_t retval = 0;
-
- buf = kzalloc(size, GFP_KERNEL);
- if (buf == NULL)
-  return -ENOMEM;
-
- RXS_ERR("CRC ERR", crc_err);
- RXS_ERR("DECRYPT CRC ERR", decrypt_crc_err);
- RXS_ERR("PHY ERR", phy_err);
- RXS_ERR("MIC ERR", mic_err);
- RXS_ERR("PRE-DELIM CRC ERR", pre_delim_crc_err);
- RXS_ERR("POST-DELIM CRC ERR", post_delim_crc_err);
- RXS_ERR("DECRYPT BUSY ERR", decrypt_busy_err);
- RXS_ERR("RX-LENGTH-ERR", rx_len_err);
- RXS_ERR("RX-OOM-ERR", rx_oom_err);
- RXS_ERR("RX-RATE-ERR", rx_rate_err);
- RXS_ERR("RX-TOO-MANY-FRAGS", rx_too_many_frags_err);
-
- PHY_ERR("UNDERRUN ERR", ATH9K_PHYERR_UNDERRUN);
- PHY_ERR("TIMING ERR", ATH9K_PHYERR_TIMING);
- PHY_ERR("PARITY ERR", ATH9K_PHYERR_PARITY);
- PHY_ERR("RATE ERR", ATH9K_PHYERR_RATE);
- PHY_ERR("LENGTH ERR", ATH9K_PHYERR_LENGTH);
- PHY_ERR("RADAR ERR", ATH9K_PHYERR_RADAR);
- PHY_ERR("SERVICE ERR", ATH9K_PHYERR_SERVICE);
- PHY_ERR("TOR ERR", ATH9K_PHYERR_TOR);
- PHY_ERR("OFDM-TIMING ERR", ATH9K_PHYERR_OFDM_TIMING);
- PHY_ERR("OFDM-SIGNAL-PARITY ERR", ATH9K_PHYERR_OFDM_SIGNAL_PARITY);
- PHY_ERR("OFDM-RATE ERR", ATH9K_PHYERR_OFDM_RATE_ILLEGAL);
- PHY_ERR("OFDM-LENGTH ERR", ATH9K_PHYERR_OFDM_LENGTH_ILLEGAL);
- PHY_ERR("OFDM-POWER-DROP ERR", ATH9K_PHYERR_OFDM_POWER_DROP);
- PHY_ERR("OFDM-SERVICE ERR", ATH9K_PHYERR_OFDM_SERVICE);
- PHY_ERR("OFDM-RESTART ERR", ATH9K_PHYERR_OFDM_RESTART);
- PHY_ERR("FALSE-RADAR-EXT ERR", ATH9K_PHYERR_FALSE_RADAR_EXT);
- PHY_ERR("CCK-TIMING ERR", ATH9K_PHYERR_CCK_TIMING);
- PHY_ERR("CCK-HEADER-CRC ERR", ATH9K_PHYERR_CCK_HEADER_CRC);
- PHY_ERR("CCK-RATE ERR", ATH9K_PHYERR_CCK_RATE_ILLEGAL);
- PHY_ERR("CCK-SERVICE ERR", ATH9K_PHYERR_CCK_SERVICE);
- PHY_ERR("CCK-RESTART ERR", ATH9K_PHYERR_CCK_RESTART);
- PHY_ERR("CCK-LENGTH ERR", ATH9K_PHYERR_CCK_LENGTH_ILLEGAL);
- PHY_ERR("CCK-POWER-DROP ERR", ATH9K_PHYERR_CCK_POWER_DROP);
- PHY_ERR("HT-CRC ERR", ATH9K_PHYERR_HT_CRC_ERROR);
- PHY_ERR("HT-LENGTH ERR", ATH9K_PHYERR_HT_LENGTH_ILLEGAL);
- PHY_ERR("HT-RATE ERR", ATH9K_PHYERR_HT_RATE_ILLEGAL);
-
- RXS_ERR("RX-Pkts-All", rx_pkts_all);
- RXS_ERR("RX-Bytes-All", rx_bytes_all);
- RXS_ERR("RX-Beacons", rx_beacons);
- RXS_ERR("RX-Frags", rx_frags);
- RXS_ERR("RX-Spectral", rx_spectral);
-
- if (len > size)
-  len = size;
-
- retval = simple_read_from_buffer(user_buf, count, ppos, buf, len);
- kfree(buf);
-
- return retval;
-
-#undef RXS_ERR
-#undef PHY_ERR
-}
-
 void ath_debug_stat_rx(struct ath_softc *sc, struct ath_rx_status *rs)
 {
-#define RX_PHY_ERR_INC(c) sc->debug.stats.rxstats.phy_err_stats[c]++
-#define RX_SAMP_DBG(c) (sc->debug.bb_mac_samp[sc->debug.sampidx].rs\
-   [sc->debug.rsidx].c)
-
- RX_STAT_INC(rx_pkts_all);
- sc->debug.stats.rxstats.rx_bytes_all += rs->rs_datalen;
-
- if (rs->rs_status & ATH9K_RXERR_CRC)
-  RX_STAT_INC(crc_err);
- if (rs->rs_status & ATH9K_RXERR_DECRYPT)
-  RX_STAT_INC(decrypt_crc_err);
- if (rs->rs_status & ATH9K_RXERR_MIC)
-  RX_STAT_INC(mic_err);
- if (rs->rs_status & ATH9K_RX_DELIM_CRC_PRE)
-  RX_STAT_INC(pre_delim_crc_err);
- if (rs->rs_status & ATH9K_RX_DELIM_CRC_POST)
-  RX_STAT_INC(post_delim_crc_err);
- if (rs->rs_status & ATH9K_RX_DECRYPT_BUSY)
-  RX_STAT_INC(decrypt_busy_err);
-
- if (rs->rs_status & ATH9K_RXERR_PHY) {
-  RX_STAT_INC(phy_err);
-  if (rs->rs_phyerr < ATH9K_PHYERR_MAX)
-   RX_PHY_ERR_INC(rs->rs_phyerr);
- }
-
-#ifdef CONFIG_ATH9K_MAC_DEBUG
- spin_lock(&sc->debug.samp_lock);
- RX_SAMP_DBG(jiffies) = jiffies;
- RX_SAMP_DBG(rssi_ctl0) = rs->rs_rssi_ctl0;
- RX_SAMP_DBG(rssi_ctl1) = rs->rs_rssi_ctl1;
- RX_SAMP_DBG(rssi_ctl2) = rs->rs_rssi_ctl2;
- RX_SAMP_DBG(rssi_ext0) = rs->rs_rssi_ext0;
- RX_SAMP_DBG(rssi_ext1) = rs->rs_rssi_ext1;
- RX_SAMP_DBG(rssi_ext2) = rs->rs_rssi_ext2;
- RX_SAMP_DBG(antenna) = rs->rs_antenna;
- RX_SAMP_DBG(rssi) = rs->rs_rssi;
- RX_SAMP_DBG(rate) = rs->rs_rate;
- RX_SAMP_DBG(is_mybeacon) = rs->is_mybeacon;
-
- sc->debug.rsidx = (sc->debug.rsidx + 1) % ATH_DBG_MAX_SAMPLES;
- spin_unlock(&sc->debug.samp_lock);
-
-#endif
-
-#undef RX_PHY_ERR_INC
-#undef RX_SAMP_DBG
-}
-
-static const struct file_operations fops_recv = {
- .read = read_file_recv,
- .open = simple_open,
- .owner = THIS_MODULE,
- .llseek = default_llseek,
-};
-
-static ssize_t read_file_spec_scan_ctl(struct file *file, char __user *user_buf,
-           size_t count, loff_t *ppos)
-{
- struct ath_softc *sc = file->private_data;
- char *mode = "";
- unsigned int len;
-
- switch (sc->spectral_mode) {
- case SPECTRAL_DISABLED:
-  mode = "disable";
-  break;
- case SPECTRAL_BACKGROUND:
-  mode = "background";
-  break;
- case SPECTRAL_CHANSCAN:
-  mode = "chanscan";
-  break;
- case SPECTRAL_MANUAL:
-  mode = "manual";
-  break;
- }
- len = strlen(mode);
- return simple_read_from_buffer(user_buf, count, ppos, mode, len);
-}
-
-static ssize_t write_file_spec_scan_ctl(struct file *file,
-     const char __user *user_buf,
-     size_t count, loff_t *ppos)
-{
- struct ath_softc *sc = file->private_data;
- struct ath_common *common = ath9k_hw_common(sc->sc_ah);
- char buf[32];
- ssize_t len;
-
- len = min(count, sizeof(buf) - 1);
- if (copy_from_user(buf, user_buf, len))
-  return -EFAULT;
-
- buf[len] = '\0';
-
- if (strncmp("trigger", buf, 7) == 0) {
-  ath9k_spectral_scan_trigger(sc->hw);
- } else if (strncmp("background", buf, 9) == 0) {
-  ath9k_spectral_scan_config(sc->hw, SPECTRAL_BACKGROUND);
-  ath_dbg(common, CONFIG, "spectral scan: background mode enabled\n");
- } else if (strncmp("chanscan", buf, 8) == 0) {
-  ath9k_spectral_scan_config(sc->hw, SPECTRAL_CHANSCAN);
-  ath_dbg(common, CONFIG, "spectral scan: channel scan mode enabled\n");
- } else if (strncmp("manual", buf, 6) == 0) {
-  ath9k_spectral_scan_config(sc->hw, SPECTRAL_MANUAL);
-  ath_dbg(common, CONFIG, "spectral scan: manual mode enabled\n");
- } else if (strncmp("disable", buf, 7) == 0) {
-  ath9k_spectral_scan_config(sc->hw, SPECTRAL_DISABLED);
-  ath_dbg(common, CONFIG, "spectral scan: disabled\n");
- } else {
-  return -EINVAL;
- }
-
- return count;
-}
-
-static const struct file_operations fops_spec_scan_ctl = {
- .read = read_file_spec_scan_ctl,
- .write = write_file_spec_scan_ctl,
- .open = simple_open,
- .owner = THIS_MODULE,
- .llseek = default_llseek,
-};
-
-static ssize_t read_file_spectral_short_repeat(struct file *file,
-            char __user *user_buf,
-            size_t count, loff_t *ppos)
-{
- struct ath_softc *sc = file->private_data;
- char buf[32];
- unsigned int len;
-
- len = sprintf(buf, "%d\n", sc->spec_config.short_repeat);
- return simple_read_from_buffer(user_buf, count, ppos, buf, len);
-}
-
-static ssize_t write_file_spectral_short_repeat(struct file *file,
-      const char __user *user_buf,
-      size_t count, loff_t *ppos)
-{
- struct ath_softc *sc = file->private_data;
- unsigned long val;
- char buf[32];
- ssize_t len;
-
- len = min(count, sizeof(buf) - 1);
- if (copy_from_user(buf, user_buf, len))
-  return -EFAULT;
-
- buf[len] = '\0';
- if (kstrtoul(buf, 0, &val))
-  return -EINVAL;
-
- if (val < 0 || val > 1)
-  return -EINVAL;
-
- sc->spec_config.short_repeat = val;
- return count;
-}
-
-static const struct file_operations fops_spectral_short_repeat = {
- .read = read_file_spectral_short_repeat,
- .write = write_file_spectral_short_repeat,
- .open = simple_open,
- .owner = THIS_MODULE,
- .llseek = default_llseek,
-};
-
-static ssize_t read_file_spectral_count(struct file *file,
-     char __user *user_buf,
-     size_t count, loff_t *ppos)
-{
- struct ath_softc *sc = file->private_data;
- char buf[32];
- unsigned int len;
-
- len = sprintf(buf, "%d\n", sc->spec_config.count);
- return simple_read_from_buffer(user_buf, count, ppos, buf, len);
+ ath9k_cmn_debug_stat_rx(&sc->debug.stats.rxstats, rs);
 }
 
-static ssize_t write_file_spectral_count(struct file *file,
-      const char __user *user_buf,
-      size_t count, loff_t *ppos)
-{
- struct ath_softc *sc = file->private_data;
- unsigned long val;
- char buf[32];
- ssize_t len;
-
- len = min(count, sizeof(buf) - 1);
- if (copy_from_user(buf, user_buf, len))
-  return -EFAULT;
-
- buf[len] = '\0';
- if (kstrtoul(buf, 0, &val))
-  return -EINVAL;
-
- if (val < 0 || val > 255)
-  return -EINVAL;
-
- sc->spec_config.count = val;
- return count;
-}
-
-static const struct file_operations fops_spectral_count = {
- .read = read_file_spectral_count,
- .write = write_file_spectral_count,
- .open = simple_open,
- .owner = THIS_MODULE,
- .llseek = default_llseek,
-};
-
-static ssize_t read_file_spectral_period(struct file *file,
-      char __user *user_buf,
-      size_t count, loff_t *ppos)
-{
- struct ath_softc *sc = file->private_data;
- char buf[32];
- unsigned int len;
-
- len = sprintf(buf, "%d\n", sc->spec_config.period);
- return simple_read_from_buffer(user_buf, count, ppos, buf, len);
-}
-
-static ssize_t write_file_spectral_period(struct file *file,
-       const char __user *user_buf,
-       size_t count, loff_t *ppos)
-{
- struct ath_softc *sc = file->private_data;
- unsigned long val;
- char buf[32];
- ssize_t len;
-
- len = min(count, sizeof(buf) - 1);
- if (copy_from_user(buf, user_buf, len))
-  return -EFAULT;
-
- buf[len] = '\0';
- if (kstrtoul(buf, 0, &val))
-  return -EINVAL;
-
- if (val < 0 || val > 255)
-  return -EINVAL;
-
- sc->spec_config.period = val;
- return count;
-}
-
-static const struct file_operations fops_spectral_period = {
- .read = read_file_spectral_period,
- .write = write_file_spectral_period,
- .open = simple_open,
- .owner = THIS_MODULE,
- .llseek = default_llseek,
-};
-
-static ssize_t read_file_spectral_fft_period(struct file *file,
-          char __user *user_buf,
-          size_t count, loff_t *ppos)
-{
- struct ath_softc *sc = file->private_data;
- char buf[32];
- unsigned int len;
-
- len = sprintf(buf, "%d\n", sc->spec_config.fft_period);
- return simple_read_from_buffer(user_buf, count, ppos, buf, len);
-}
-
-static ssize_t write_file_spectral_fft_period(struct file *file,
-           const char __user *user_buf,
-           size_t count, loff_t *ppos)
-{
- struct ath_softc *sc = file->private_data;
- unsigned long val;
- char buf[32];
- ssize_t len;
-
- len = min(count, sizeof(buf) - 1);
- if (copy_from_user(buf, user_buf, len))
-  return -EFAULT;
-
- buf[len] = '\0';
- if (kstrtoul(buf, 0, &val))
-  return -EINVAL;
-
- if (val < 0 || val > 15)
-  return -EINVAL;
-
- sc->spec_config.fft_period = val;
- return count;
-}
-
-static const struct file_operations fops_spectral_fft_period = {
- .read = read_file_spectral_fft_period,
- .write = write_file_spectral_fft_period,
- .open = simple_open,
- .owner = THIS_MODULE,
- .llseek = default_llseek,
-};
-
-static struct dentry *create_buf_file_handler(const char *filename,
-           struct dentry *parent,
-           umode_t mode,
-           struct rchan_buf *buf,
-           int *is_global)
-{
- struct dentry *buf_file;
-
- buf_file = debugfs_create_file(filename, mode, parent, buf,
-           &relay_file_operations);
- *is_global = 1;
- return buf_file;
-}
-
-static int remove_buf_file_handler(struct dentry *dentry)
-{
- debugfs_remove(dentry);
-
- return 0;
-}
-
-void ath_debug_send_fft_sample(struct ath_softc *sc,
-          struct fft_sample_tlv *fft_sample_tlv)
-{
- int length;
- if (!sc->rfs_chan_spec_scan)
-  return;
-
- length = __be16_to_cpu(fft_sample_tlv->length) +
-   sizeof(*fft_sample_tlv);
- relay_write(sc->rfs_chan_spec_scan, fft_sample_tlv, length);
-}
-
-static struct rchan_callbacks rfs_spec_scan_cb = {
- .create_buf_file = create_buf_file_handler,
- .remove_buf_file = remove_buf_file_handler,
-};
-
-
 static ssize_t read_file_regidx(struct file *file, char __user *user_buf,
                                 size_t count, loff_t *ppos)
 {
@@ -1278,7 +977,7 @@ static ssize_t write_file_regidx(struct file *file, const char __user *user_buf,
   return -EFAULT;
 
  buf[len] = '\0';
- if (strict_strtoul(buf, 0, &regidx))
+ if (kstrtoul(buf, 0, &regidx))
   return -EINVAL;
 
  sc->debug.regidx = regidx;
@@ -1323,7 +1022,7 @@ static ssize_t write_file_regval(struct file *file, const char __user *user_buf,
   return -EFAULT;
 
  buf[len] = '\0';
- if (strict_strtoul(buf, 0, &regval))
+ if (kstrtoul(buf, 0, &regval))
   return -EINVAL;
 
  ath9k_ps_wakeup(sc);
@@ -1395,22 +1094,22 @@ static ssize_t read_file_dump_nfcal(struct file *file, char __user *user_buf,
  if (!buf)
   return -ENOMEM;
 
- len += snprintf(buf + len, size - len,
-   "Channel Noise Floor : %d\n", ah->noise);
- len += snprintf(buf + len, size - len,
-   "Chain | privNF | # Readings | NF Readings\n");
+ len += scnprintf(buf + len, size - len,
+    "Channel Noise Floor : %d\n", ah->noise);
+ len += scnprintf(buf + len, size - len,
+    "Chain | privNF | # Readings | NF Readings\n");
  for (i = 0; i < NUM_NF_READINGS; i++) {
   if (!(chainmask & (1 << i)) ||
       ((i >= AR5416_MAX_CHAINS) && !conf_is_ht40(conf)))
    continue;
 
   nread = AR_PHY_CCA_FILTERWINDOW_LENGTH - h[i].invalidNFcount;
-  len += snprintf(buf + len, size - len, " %d\t %d\t %d\t\t",
-    i, h[i].privNF, nread);
+  len += scnprintf(buf + len, size - len, " %d\t %d\t %d\t\t",
+     i, h[i].privNF, nread);
   for (j = 0; j < nread; j++)
-   len += snprintf(buf + len, size - len,
-     " %d", h[i].nfCalBuffer[j]);
-  len += snprintf(buf + len, size - len, "\n");
+   len += scnprintf(buf + len, size - len,
+      " %d", h[i].nfCalBuffer[j]);
+  len += scnprintf(buf + len, size - len, "\n");
  }
 
  if (len > size)
@@ -1429,339 +1128,6 @@ static const struct file_operations fops_dump_nfcal = {
  .llseek = default_llseek,
 };
 
-static ssize_t read_file_base_eeprom(struct file *file, char __user *user_buf,
-         size_t count, loff_t *ppos)
-{
- struct ath_softc *sc = file->private_data;
- struct ath_hw *ah = sc->sc_ah;
- u32 len = 0, size = 1500;
- ssize_t retval = 0;
- char *buf;
-
- buf = kzalloc(size, GFP_KERNEL);
- if (!buf)
-  return -ENOMEM;
-
- len = ah->eep_ops->dump_eeprom(ah, true, buf, len, size);
-
- retval = simple_read_from_buffer(user_buf, count, ppos, buf, len);
- kfree(buf);
-
- return retval;
-}
-
-static const struct file_operations fops_base_eeprom = {
- .read = read_file_base_eeprom,
- .open = simple_open,
- .owner = THIS_MODULE,
- .llseek = default_llseek,
-};
-
-static ssize_t read_file_modal_eeprom(struct file *file, char __user *user_buf,
-          size_t count, loff_t *ppos)
-{
- struct ath_softc *sc = file->private_data;
- struct ath_hw *ah = sc->sc_ah;
- u32 len = 0, size = 6000;
- char *buf;
- size_t retval;
-
- buf = kzalloc(size, GFP_KERNEL);
- if (buf == NULL)
-  return -ENOMEM;
-
- len = ah->eep_ops->dump_eeprom(ah, false, buf, len, size);
-
- retval = simple_read_from_buffer(user_buf, count, ppos, buf, len);
- kfree(buf);
-
- return retval;
-}
-
-static const struct file_operations fops_modal_eeprom = {
- .read = read_file_modal_eeprom,
- .open = simple_open,
- .owner = THIS_MODULE,
- .llseek = default_llseek,
-};
-
-#ifdef CONFIG_ATH9K_MAC_DEBUG
-
-void ath9k_debug_samp_bb_mac(struct ath_softc *sc)
-{
-#define ATH_SAMP_DBG(c) (sc->debug.bb_mac_samp[sc->debug.sampidx].c)
- struct ath_hw *ah = sc->sc_ah;
- struct ath_common *common = ath9k_hw_common(ah);
- unsigned long flags;
- int i;
-
- ath9k_ps_wakeup(sc);
-
- spin_lock_bh(&sc->debug.samp_lock);
-
- spin_lock_irqsave(&common->cc_lock, flags);
- ath_hw_cycle_counters_update(common);
-
- ATH_SAMP_DBG(cc.cycles) = common->cc_ani.cycles;
- ATH_SAMP_DBG(cc.rx_busy) = common->cc_ani.rx_busy;
- ATH_SAMP_DBG(cc.rx_frame) = common->cc_ani.rx_frame;
- ATH_SAMP_DBG(cc.tx_frame) = common->cc_ani.tx_frame;
- spin_unlock_irqrestore(&common->cc_lock, flags);
-
- ATH_SAMP_DBG(noise) = ah->noise;
-
- REG_WRITE_D(ah, AR_MACMISC,
-    ((AR_MACMISC_DMA_OBS_LINE_8 << AR_MACMISC_DMA_OBS_S) |
-     (AR_MACMISC_MISC_OBS_BUS_1 <<
-      AR_MACMISC_MISC_OBS_BUS_MSB_S)));
-
- for (i = 0; i < ATH9K_NUM_DMA_DEBUG_REGS; i++)
-  ATH_SAMP_DBG(dma_dbg_reg_vals[i]) = REG_READ_D(ah,
-    AR_DMADBG_0 + (i * sizeof(u32)));
-
- ATH_SAMP_DBG(pcu_obs) = REG_READ_D(ah, AR_OBS_BUS_1);
- ATH_SAMP_DBG(pcu_cr) = REG_READ_D(ah, AR_CR);
-
- memcpy(ATH_SAMP_DBG(nfCalHist), sc->caldata.nfCalHist,
-   sizeof(ATH_SAMP_DBG(nfCalHist)));
-
- sc->debug.sampidx = (sc->debug.sampidx + 1) % ATH_DBG_MAX_SAMPLES;
- spin_unlock_bh(&sc->debug.samp_lock);
- ath9k_ps_restore(sc);
-
-#undef ATH_SAMP_DBG
-}
-
-static int open_file_bb_mac_samps(struct inode *inode, struct file *file)
-{
-#define ATH_SAMP_DBG(c) bb_mac_samp[sampidx].c
- struct ath_softc *sc = inode->i_private;
- struct ath_hw *ah = sc->sc_ah;
- struct ath_common *common = ath9k_hw_common(ah);
- struct ieee80211_conf *conf = &common->hw->conf;
- struct ath_dbg_bb_mac_samp *bb_mac_samp;
- struct ath9k_nfcal_hist *h;
- int i, j, qcuOffset = 0, dcuOffset = 0;
- u32 *qcuBase, *dcuBase, size = 30000, len = 0;
- u32 sampidx = 0;
- u8 *buf;
- u8 chainmask = (ah->rxchainmask << 3) | ah->rxchainmask;
- u8 nread;
-
- if (test_bit(SC_OP_INVALID, &sc->sc_flags))
-  return -EAGAIN;
-
- buf = vmalloc(size);
- if (!buf)
-  return -ENOMEM;
- bb_mac_samp = vmalloc(sizeof(*bb_mac_samp) * ATH_DBG_MAX_SAMPLES);
- if (!bb_mac_samp) {
-  vfree(buf);
-  return -ENOMEM;
- }
- /* Account the current state too */
- ath9k_debug_samp_bb_mac(sc);
-
- spin_lock_bh(&sc->debug.samp_lock);
- memcpy(bb_mac_samp, sc->debug.bb_mac_samp,
-   sizeof(*bb_mac_samp) * ATH_DBG_MAX_SAMPLES);
- len += snprintf(buf + len, size - len,
-   "Current Sample Index: %d\n", sc->debug.sampidx);
- spin_unlock_bh(&sc->debug.samp_lock);
-
- len += snprintf(buf + len, size - len,
-   "Raw DMA Debug Dump:\n");
- len += snprintf(buf + len, size - len, "Sample |\t");
- for (i = 0; i < ATH9K_NUM_DMA_DEBUG_REGS; i++)
-  len += snprintf(buf + len, size - len, " DMA Reg%d |\t", i);
- len += snprintf(buf + len, size - len, "\n");
-
- for (sampidx = 0; sampidx < ATH_DBG_MAX_SAMPLES; sampidx++) {
-  len += snprintf(buf + len, size - len, "%d\t", sampidx);
-
-  for (i = 0; i < ATH9K_NUM_DMA_DEBUG_REGS; i++)
-   len += snprintf(buf + len, size - len, " %08x\t",
-     ATH_SAMP_DBG(dma_dbg_reg_vals[i]));
-  len += snprintf(buf + len, size - len, "\n");
- }
- len += snprintf(buf + len, size - len, "\n");
-
- len += snprintf(buf + len, size - len,
-   "Sample Num QCU: chain_st fsp_ok fsp_st DCU: chain_st\n");
- for (sampidx = 0; sampidx < ATH_DBG_MAX_SAMPLES; sampidx++) {
-  qcuBase = &ATH_SAMP_DBG(dma_dbg_reg_vals[0]);
-  dcuBase = &ATH_SAMP_DBG(dma_dbg_reg_vals[4]);
-
-  for (i = 0; i < ATH9K_NUM_QUEUES; i++,
-    qcuOffset += 4, dcuOffset += 5) {
-   if (i == 8) {
-    qcuOffset = 0;
-    qcuBase++;
-   }
-
-   if (i == 6) {
-    dcuOffset = 0;
-    dcuBase++;
-   }
-   if (!sc->debug.stats.txstats[i].queued)
-    continue;
-
-   len += snprintf(buf + len, size - len,
-    "%4d %7d    %2x      %1x     %2x         %2x\n",
-    sampidx, i,
-    (*qcuBase & (0x7 << qcuOffset)) >> qcuOffset,
-    (*qcuBase & (0x8 << qcuOffset)) >>
-    (qcuOffset + 3),
-    ATH_SAMP_DBG(dma_dbg_reg_vals[2]) &
-    (0x7 << (i * 3)) >> (i * 3),
-    (*dcuBase & (0x1f << dcuOffset)) >> dcuOffset);
-  }
-  len += snprintf(buf + len, size - len, "\n");
- }
- len += snprintf(buf + len, size - len,
-   "samp qcu_sh qcu_fh qcu_comp dcu_comp dcu_arb dcu_fp "
-   "ch_idle_dur ch_idle_dur_val txfifo_val0 txfifo_val1 "
-   "txfifo_dcu0 txfifo_dcu1 pcu_obs AR_CR\n");
-
- for (sampidx = 0; sampidx < ATH_DBG_MAX_SAMPLES; sampidx++) {
-  qcuBase = &ATH_SAMP_DBG(dma_dbg_reg_vals[0]);
-  dcuBase = &ATH_SAMP_DBG(dma_dbg_reg_vals[4]);
-
-  len += snprintf(buf + len, size - len, "%4d %5x %5x ", sampidx,
-   (ATH_SAMP_DBG(dma_dbg_reg_vals[3]) & 0x003c0000) >> 18,
-   (ATH_SAMP_DBG(dma_dbg_reg_vals[3]) & 0x03c00000) >> 22);
-  len += snprintf(buf + len, size - len, "%7x %8x ",
-   (ATH_SAMP_DBG(dma_dbg_reg_vals[3]) & 0x1c000000) >> 26,
-   (ATH_SAMP_DBG(dma_dbg_reg_vals[6]) & 0x3));
-  len += snprintf(buf + len, size - len, "%7x %7x ",
-   (ATH_SAMP_DBG(dma_dbg_reg_vals[5]) & 0x06000000) >> 25,
-   (ATH_SAMP_DBG(dma_dbg_reg_vals[5]) & 0x38000000) >> 27);
-  len += snprintf(buf + len, size - len, "%7d %12d ",
-   (ATH_SAMP_DBG(dma_dbg_reg_vals[6]) & 0x000003fc) >> 2,
-   (ATH_SAMP_DBG(dma_dbg_reg_vals[6]) & 0x00000400) >> 10);
-  len += snprintf(buf + len, size - len, "%12d %12d ",
-   (ATH_SAMP_DBG(dma_dbg_reg_vals[6]) & 0x00000800) >> 11,
-   (ATH_SAMP_DBG(dma_dbg_reg_vals[6]) & 0x00001000) >> 12);
-  len += snprintf(buf + len, size - len, "%12d %12d ",
-   (ATH_SAMP_DBG(dma_dbg_reg_vals[6]) & 0x0001e000) >> 13,
-   (ATH_SAMP_DBG(dma_dbg_reg_vals[6]) & 0x001e0000) >> 17);
-  len += snprintf(buf + len, size - len, "0x%07x 0x%07x\n",
-    ATH_SAMP_DBG(pcu_obs), ATH_SAMP_DBG(pcu_cr));
- }
-
- len += snprintf(buf + len, size - len,
-   "Sample ChNoise Chain privNF #Reading Readings\n");
- for (sampidx = 0; sampidx < ATH_DBG_MAX_SAMPLES; sampidx++) {
-  h = ATH_SAMP_DBG(nfCalHist);
-  if (!ATH_SAMP_DBG(noise))
-   continue;
-
-  for (i = 0; i < NUM_NF_READINGS; i++) {
-   if (!(chainmask & (1 << i)) ||
-       ((i >= AR5416_MAX_CHAINS) && !conf_is_ht40(conf)))
-    continue;
-
-   nread = AR_PHY_CCA_FILTERWINDOW_LENGTH -
-    h[i].invalidNFcount;
-   len += snprintf(buf + len, size - len,
-     "%4d %5d %4d\t   %d\t %d\t",
-     sampidx, ATH_SAMP_DBG(noise),
-     i, h[i].privNF, nread);
-   for (j = 0; j < nread; j++)
-    len += snprintf(buf + len, size - len,
-     " %d", h[i].nfCalBuffer[j]);
-   len += snprintf(buf + len, size - len, "\n");
-  }
- }
- len += snprintf(buf + len, size - len, "\nCycle counters:\n"
-   "Sample Total    Rxbusy   Rxframes Txframes\n");
- for (sampidx = 0; sampidx < ATH_DBG_MAX_SAMPLES; sampidx++) {
-  if (!ATH_SAMP_DBG(cc.cycles))
-   continue;
-  len += snprintf(buf + len, size - len,
-    "%4d %08x %08x %08x %08x\n",
-    sampidx, ATH_SAMP_DBG(cc.cycles),
-    ATH_SAMP_DBG(cc.rx_busy),
-    ATH_SAMP_DBG(cc.rx_frame),
-    ATH_SAMP_DBG(cc.tx_frame));
- }
-
- len += snprintf(buf + len, size - len, "Tx status Dump :\n");
- len += snprintf(buf + len, size - len,
-   "Sample rssi:- ctl0 ctl1 ctl2 ext0 ext1 ext2 comb "
-   "isok rts_fail data_fail rate tid qid "
-     "ba_low  ba_high tx_before(ms)\n");
- for (sampidx = 0; sampidx < ATH_DBG_MAX_SAMPLES; sampidx++) {
-  for (i = 0; i < ATH_DBG_MAX_SAMPLES; i++) {
-   if (!ATH_SAMP_DBG(ts[i].jiffies))
-    continue;
-   len += snprintf(buf + len, size - len, "%-14d"
-    "%-4d %-4d %-4d %-4d %-4d %-4d %-4d %-4d %-8d "
-    "%-9d %-4d %-3d %-3d %08x %08x %-11d\n",
-    sampidx,
-    ATH_SAMP_DBG(ts[i].rssi_ctl0),
-    ATH_SAMP_DBG(ts[i].rssi_ctl1),
-    ATH_SAMP_DBG(ts[i].rssi_ctl2),
-    ATH_SAMP_DBG(ts[i].rssi_ext0),
-    ATH_SAMP_DBG(ts[i].rssi_ext1),
-    ATH_SAMP_DBG(ts[i].rssi_ext2),
-    ATH_SAMP_DBG(ts[i].rssi),
-    ATH_SAMP_DBG(ts[i].isok),
-    ATH_SAMP_DBG(ts[i].rts_fail_cnt),
-    ATH_SAMP_DBG(ts[i].data_fail_cnt),
-    ATH_SAMP_DBG(ts[i].rateindex),
-    ATH_SAMP_DBG(ts[i].tid),
-    ATH_SAMP_DBG(ts[i].qid),
-    ATH_SAMP_DBG(ts[i].ba_low),
-    ATH_SAMP_DBG(ts[i].ba_high),
-    jiffies_to_msecs(jiffies -
-     ATH_SAMP_DBG(ts[i].jiffies)));
-  }
- }
-
- len += snprintf(buf + len, size - len, "Rx status Dump :\n");
- len += snprintf(buf + len, size - len, "Sample rssi:- ctl0 ctl1 ctl2 "
-   "ext0 ext1 ext2 comb beacon ant rate rx_before(ms)\n");
- for (sampidx = 0; sampidx < ATH_DBG_MAX_SAMPLES; sampidx++) {
-  for (i = 0; i < ATH_DBG_MAX_SAMPLES; i++) {
-   if (!ATH_SAMP_DBG(rs[i].jiffies))
-    continue;
-   len += snprintf(buf + len, size - len, "%-14d"
-    "%-4d %-4d %-4d %-4d %-4d %-4d %-4d %-9s %-2d %02x %-13d\n",
-    sampidx,
-    ATH_SAMP_DBG(rs[i].rssi_ctl0),
-    ATH_SAMP_DBG(rs[i].rssi_ctl1),
-    ATH_SAMP_DBG(rs[i].rssi_ctl2),
-    ATH_SAMP_DBG(rs[i].rssi_ext0),
-    ATH_SAMP_DBG(rs[i].rssi_ext1),
-    ATH_SAMP_DBG(rs[i].rssi_ext2),
-    ATH_SAMP_DBG(rs[i].rssi),
-    ATH_SAMP_DBG(rs[i].is_mybeacon) ?
-    "True" : "False",
-    ATH_SAMP_DBG(rs[i].antenna),
-    ATH_SAMP_DBG(rs[i].rate),
-    jiffies_to_msecs(jiffies -
-     ATH_SAMP_DBG(rs[i].jiffies)));
-  }
- }
-
- vfree(bb_mac_samp);
- file->private_data = buf;
-
- return 0;
-#undef ATH_SAMP_DBG
-}
-
-static const struct file_operations fops_samps = {
- .open = open_file_bb_mac_samps,
- .read = ath9k_debugfs_read_buf,
- .release = ath9k_debugfs_release_buf,
- .owner = THIS_MODULE,
- .llseek = default_llseek,
-};
-
-#endif
-
 #ifdef CONFIG_ATH9K_BTCOEX_SUPPORT
 static ssize_t read_file_btcoex(struct file *file, char __user *user_buf,
     size_t count, loff_t *ppos)
@@ -1776,8 +1142,8 @@ static ssize_t read_file_btcoex(struct file *file, char __user *user_buf,
   return -ENOMEM;
 
  if (!sc->sc_ah->common.btcoex_enabled) {
-  len = snprintf(buf, size, "%s\n",
-          "BTCOEX is disabled");
+  len = scnprintf(buf, size, "%s\n",
+    "BTCOEX is disabled");
   goto exit;
  }
 
@@ -1797,96 +1163,6 @@ static const struct file_operations fops_btcoex = {
 };
 #endif
 
-static ssize_t read_file_node_stat(struct file *file, char __user *user_buf,
-       size_t count, loff_t *ppos)
-{
- struct ath_node *an = file->private_data;
- struct ath_softc *sc = an->sc;
- struct ath_atx_tid *tid;
- struct ath_atx_ac *ac;
- struct ath_txq *txq;
- u32 len = 0, size = 4096;
- char *buf;
- size_t retval;
- int tidno, acno;
-
- buf = kzalloc(size, GFP_KERNEL);
- if (buf == NULL)
-  return -ENOMEM;
-
- if (!an->sta->ht_cap.ht_supported) {
-  len = snprintf(buf, size, "%s\n",
-          "HT not supported");
-  goto exit;
- }
-
- len = snprintf(buf, size, "Max-AMPDU: %d\n",
-         an->maxampdu);
- len += snprintf(buf + len, size - len, "MPDU Density: %d\n\n",
-   an->mpdudensity);
-
- len += snprintf(buf + len, size - len,
-   "%2s%7s\n", "AC", "SCHED");
-
- for (acno = 0, ac = &an->ac[acno];
-      acno < IEEE80211_NUM_ACS; acno++, ac++) {
-  txq = ac->txq;
-  ath_txq_lock(sc, txq);
-  len += snprintf(buf + len, size - len,
-    "%2d%7d\n",
-    acno, ac->sched);
-  ath_txq_unlock(sc, txq);
- }
-
- len += snprintf(buf + len, size - len,
-   "\n%3s%11s%10s%10s%10s%10s%9s%6s%8s\n",
-   "TID", "SEQ_START", "SEQ_NEXT", "BAW_SIZE",
-   "BAW_HEAD", "BAW_TAIL", "BAR_IDX", "SCHED", "PAUSED");
-
- for (tidno = 0, tid = &an->tid[tidno];
-      tidno < IEEE80211_NUM_TIDS; tidno++, tid++) {
-  txq = tid->ac->txq;
-  ath_txq_lock(sc, txq);
-  len += snprintf(buf + len, size - len,
-    "%3d%11d%10d%10d%10d%10d%9d%6d%8d\n",
-    tid->tidno, tid->seq_start, tid->seq_next,
-    tid->baw_size, tid->baw_head, tid->baw_tail,
-    tid->bar_index, tid->sched, tid->paused);
-  ath_txq_unlock(sc, txq);
- }
-exit:
- retval = simple_read_from_buffer(user_buf, count, ppos, buf, len);
- kfree(buf);
-
- return retval;
-}
-
-static const struct file_operations fops_node_stat = {
- .read = read_file_node_stat,
- .open = simple_open,
- .owner = THIS_MODULE,
- .llseek = default_llseek,
-};
-
-void ath9k_sta_add_debugfs(struct ieee80211_hw *hw,
-      struct ieee80211_vif *vif,
-      struct ieee80211_sta *sta,
-      struct dentry *dir)
-{
- struct ath_node *an = (struct ath_node *)sta->drv_priv;
- an->node_stat = debugfs_create_file("node_stat", S_IRUGO,
-         dir, an, &fops_node_stat);
-}
-
-void ath9k_sta_remove_debugfs(struct ieee80211_hw *hw,
-         struct ieee80211_vif *vif,
-         struct ieee80211_sta *sta,
-         struct dentry *dir)
-{
- struct ath_node *an = (struct ath_node *)sta->drv_priv;
- debugfs_remove(an->node_stat);
-}
-
 /* Ethtool support for get-stats */
 
 #define AMKSTR(nm) #nm "_BE", #nm "_BK", #nm "_VI", #nm "_VO"
@@ -2010,10 +1286,7 @@ void ath9k_get_et_stats(struct ieee80211_hw *hw,
 
 void ath9k_deinit_debug(struct ath_softc *sc)
 {
- if (config_enabled(CONFIG_ATH9K_DEBUGFS) && sc->rfs_chan_spec_scan) {
-  relay_close(sc->rfs_chan_spec_scan);
-  sc->rfs_chan_spec_scan = NULL;
- }
+ ath9k_spectral_deinit_debug(sc);
 }
 
 int ath9k_init_debug(struct ath_hw *ah)
@@ -2032,6 +1305,8 @@ int ath9k_init_debug(struct ath_hw *ah)
 #endif
 
  ath9k_dfs_init_debug(sc);
+ ath9k_tx99_init_debug(sc);
+ ath9k_spectral_init_debug(sc);
 
  debugfs_create_file("dma", S_IRUSR, sc->debug.debugfs_phy, sc,
        &fops_dma);
@@ -2053,14 +1328,16 @@ int ath9k_init_debug(struct ath_hw *ah)
        &fops_misc);
  debugfs_create_file("reset", S_IRUSR, sc->debug.debugfs_phy, sc,
        &fops_reset);
- debugfs_create_file("recv", S_IRUSR, sc->debug.debugfs_phy, sc,
-       &fops_recv);
- debugfs_create_file("rx_chainmask", S_IRUSR | S_IWUSR,
-       sc->debug.debugfs_phy, sc, &fops_rx_chainmask);
- debugfs_create_file("tx_chainmask", S_IRUSR | S_IWUSR,
-       sc->debug.debugfs_phy, sc, &fops_tx_chainmask);
- debugfs_create_file("disable_ani", S_IRUSR | S_IWUSR,
-       sc->debug.debugfs_phy, sc, &fops_disable_ani);
+
+ ath9k_cmn_debug_recv(sc->debug.debugfs_phy, &sc->debug.stats.rxstats);
+ ath9k_cmn_debug_phy_err(sc->debug.debugfs_phy, &sc->debug.stats.rxstats);
+
+ debugfs_create_u8("rx_chainmask", S_IRUSR, sc->debug.debugfs_phy,
+     &ah->rxchainmask);
+ debugfs_create_u8("tx_chainmask", S_IRUSR, sc->debug.debugfs_phy,
+     &ah->txchainmask);
+ debugfs_create_file("ani", S_IRUSR | S_IWUSR,
+       sc->debug.debugfs_phy, sc, &fops_ani);
  debugfs_create_bool("paprd", S_IRUSR | S_IWUSR, sc->debug.debugfs_phy,
        &sc->sc_ah->config.enable_paprd);
  debugfs_create_file("regidx", S_IRUSR | S_IWUSR, sc->debug.debugfs_phy,
@@ -2074,41 +1351,22 @@ int ath9k_init_debug(struct ath_hw *ah)
        &fops_regdump);
  debugfs_create_file("dump_nfcal", S_IRUSR, sc->debug.debugfs_phy, sc,
        &fops_dump_nfcal);
- debugfs_create_file("base_eeprom", S_IRUSR, sc->debug.debugfs_phy, sc,
-       &fops_base_eeprom);
- debugfs_create_file("modal_eeprom", S_IRUSR, sc->debug.debugfs_phy, sc,
-       &fops_modal_eeprom);
- sc->rfs_chan_spec_scan = relay_open("spectral_scan",
-         sc->debug.debugfs_phy,
-         1024, 256, &rfs_spec_scan_cb,
-         NULL);
- debugfs_create_file("spectral_scan_ctl", S_IRUSR | S_IWUSR,
-       sc->debug.debugfs_phy, sc,
-       &fops_spec_scan_ctl);
- debugfs_create_file("spectral_short_repeat", S_IRUSR | S_IWUSR,
-       sc->debug.debugfs_phy, sc,
-       &fops_spectral_short_repeat);
- debugfs_create_file("spectral_count", S_IRUSR | S_IWUSR,
-       sc->debug.debugfs_phy, sc, &fops_spectral_count);
- debugfs_create_file("spectral_period", S_IRUSR | S_IWUSR,
-       sc->debug.debugfs_phy, sc, &fops_spectral_period);
- debugfs_create_file("spectral_fft_period", S_IRUSR | S_IWUSR,
-       sc->debug.debugfs_phy, sc,
-       &fops_spectral_fft_period);
-
-#ifdef CONFIG_ATH9K_MAC_DEBUG
- debugfs_create_file("samples", S_IRUSR, sc->debug.debugfs_phy, sc,
-       &fops_samps);
-#endif
+
+ ath9k_cmn_debug_base_eeprom(sc->debug.debugfs_phy, sc->sc_ah);
+ ath9k_cmn_debug_modal_eeprom(sc->debug.debugfs_phy, sc->sc_ah);
+
  debugfs_create_u32("gpio_mask", S_IRUSR | S_IWUSR,
       sc->debug.debugfs_phy, &sc->sc_ah->gpio_mask);
  debugfs_create_u32("gpio_val", S_IRUSR | S_IWUSR,
       sc->debug.debugfs_phy, &sc->sc_ah->gpio_val);
- debugfs_create_file("diversity", S_IRUSR | S_IWUSR,
-       sc->debug.debugfs_phy, sc, &fops_ant_diversity);
+ debugfs_create_file("antenna_diversity", S_IRUSR,
+       sc->debug.debugfs_phy, sc, &fops_antenna_diversity);
 #ifdef CONFIG_ATH9K_BTCOEX_SUPPORT
+ debugfs_create_file("bt_ant_diversity", S_IRUSR | S_IWUSR,
+       sc->debug.debugfs_phy, sc, &fops_bt_ant_diversity);
  debugfs_create_file("btcoex", S_IRUSR, sc->debug.debugfs_phy, sc,
        &fops_btcoex);
 #endif
+
  return 0;
 }
diff --git a/drivers/net/wireless/ath/ath9k/debug.h b/drivers/net/wireless/ath/ath9k/debug.h
index 9d49aab..53ae15b 100644
--- a/drivers/net/wireless/ath/ath9k/debug.h
+++ b/drivers/net/wireless/ath/ath9k/debug.h
@@ -18,7 +18,6 @@
 #define DEBUG_H
 
 #include "hw.h"
-#include "rc.h"
 #include "dfs_debug.h"
 
 struct ath_txq;
@@ -27,10 +26,16 @@ struct fft_sample_tlv;
 
 #ifdef CONFIG_ATH9K_DEBUGFS
 #define TX_STAT_INC(q, c) sc->debug.stats.txstats[q].c++
+#define RX_STAT_INC(c) (sc->debug.stats.rxstats.c++)
 #define RESET_STAT_INC(sc, type) sc->debug.stats.reset[type]++
+#define ANT_STAT_INC(i, c) sc->debug.stats.ant_stats[i].c++
+#define ANT_LNA_INC(i, c) sc->debug.stats.ant_stats[i].lna_recv_cnt[c]++;
 #else
 #define TX_STAT_INC(q, c) do { } while (0)
+#define RX_STAT_INC(c)
 #define RESET_STAT_INC(sc, type) do { } while (0)
+#define ANT_STAT_INC(i, c) do { } while (0)
+#define ANT_LNA_INC(i, c) do { } while (0)
 #endif
 
 enum ath_reset_type {
@@ -38,6 +43,7 @@ enum ath_reset_type {
  RESET_TYPE_BB_WATCHDOG,
  RESET_TYPE_FATAL_INT,
  RESET_TYPE_TX_ERROR,
+ RESET_TYPE_TX_GTT,
  RESET_TYPE_TX_HANG,
  RESET_TYPE_PLL_HANG,
  RESET_TYPE_MAC_HANG,
@@ -189,58 +195,40 @@ struct ath_tx_stats {
 #define TXSTATS sc->debug.stats.txstats
 #define PR(str, elem)       \
  do {        \
-  len += snprintf(buf + len, size - len,   \
-    "%s%13u%11u%10u%10u\n", str,  \
-    TXSTATS[PR_QNUM(IEEE80211_AC_BE)].elem, \
-    TXSTATS[PR_QNUM(IEEE80211_AC_BK)].elem, \
-    TXSTATS[PR_QNUM(IEEE80211_AC_VI)].elem, \
-    TXSTATS[PR_QNUM(IEEE80211_AC_VO)].elem); \
+  len += scnprintf(buf + len, size - len,   \
+     "%s%13u%11u%10u%10u\n", str,  \
+     TXSTATS[PR_QNUM(IEEE80211_AC_BE)].elem,\
+     TXSTATS[PR_QNUM(IEEE80211_AC_BK)].elem,\
+     TXSTATS[PR_QNUM(IEEE80211_AC_VI)].elem,\
+     TXSTATS[PR_QNUM(IEEE80211_AC_VO)].elem); \
  } while(0)
 
-#define RX_STAT_INC(c) (sc->debug.stats.rxstats.c++)
+struct ath_rx_rate_stats {
+ struct {
+  u32 ht20_cnt;
+  u32 ht40_cnt;
+  u32 sgi_cnt;
+  u32 lgi_cnt;
+ } ht_stats[24];
 
-/**
- * struct ath_rx_stats - RX Statistics
- * @rx_pkts_all:  No. of total frames received, including ones that
- may have had errors.
- * @rx_bytes_all:  No. of total bytes received, including ones that
- may have had errors.
- * @crc_err: No. of frames with incorrect CRC value
- * @decrypt_crc_err: No. of frames whose CRC check failed after
- decryption process completed
- * @phy_err: No. of frames whose reception failed because the PHY
- encountered an error
- * @mic_err: No. of frames with incorrect TKIP MIC verification failure
- * @pre_delim_crc_err: Pre-Frame delimiter CRC error detections
- * @post_delim_crc_err: Post-Frame delimiter CRC error detections
- * @decrypt_busy_err: Decryption interruptions counter
- * @phy_err_stats: Individual PHY error statistics
- * @rx_len_err:  No. of frames discarded due to bad length.
- * @rx_oom_err:  No. of frames dropped due to OOM issues.
- * @rx_rate_err:  No. of frames dropped due to rate errors.
- * @rx_too_many_frags_err:  Frames dropped due to too-many-frags received.
- * @rx_beacons:  No. of beacons received.
- * @rx_frags:  No. of rx-fragements received.
- * @rx_spectral: No of spectral packets received.
- */
-struct ath_rx_stats {
- u32 rx_pkts_all;
- u32 rx_bytes_all;
- u32 crc_err;
- u32 decrypt_crc_err;
- u32 phy_err;
- u32 mic_err;
- u32 pre_delim_crc_err;
- u32 post_delim_crc_err;
- u32 decrypt_busy_err;
- u32 phy_err_stats[ATH9K_PHYERR_MAX];
- u32 rx_len_err;
- u32 rx_oom_err;
- u32 rx_rate_err;
- u32 rx_too_many_frags_err;
- u32 rx_beacons;
- u32 rx_frags;
- u32 rx_spectral;
+ struct {
+  u32 ofdm_cnt;
+ } ofdm_stats[8];
+
+ struct {
+  u32 cck_lp_cnt;
+  u32 cck_sp_cnt;
+ } cck_stats[4];
+};
+
+#define ANT_MAIN 0
+#define ANT_ALT  1
+
+struct ath_antenna_stats {
+ u32 recv_cnt;
+ u32 rssi_avg;
+ u32 lna_recv_cnt[4];
+ u32 lna_attempt_cnt[4];
 };
 
 struct ath_stats {
@@ -248,59 +236,14 @@ struct ath_stats {
  struct ath_tx_stats txstats[ATH9K_NUM_TX_QUEUES];
  struct ath_rx_stats rxstats;
  struct ath_dfs_stats dfs_stats;
+ struct ath_antenna_stats ant_stats[2];
  u32 reset[__RESET_TYPE_MAX];
 };
 
-#define ATH_DBG_MAX_SAMPLES 10
-struct ath_dbg_bb_mac_samp {
- u32 dma_dbg_reg_vals[ATH9K_NUM_DMA_DEBUG_REGS];
- u32 pcu_obs, pcu_cr, noise;
- struct {
-  u64 jiffies;
-  int8_t rssi_ctl0;
-  int8_t rssi_ctl1;
-  int8_t rssi_ctl2;
-  int8_t rssi_ext0;
-  int8_t rssi_ext1;
-  int8_t rssi_ext2;
-  int8_t rssi;
-  bool isok;
-  u8 rts_fail_cnt;
-  u8 data_fail_cnt;
-  u8 rateindex;
-  u8 qid;
-  u8 tid;
-  u32 ba_low;
-  u32 ba_high;
- } ts[ATH_DBG_MAX_SAMPLES];
- struct {
-  u64 jiffies;
-  int8_t rssi_ctl0;
-  int8_t rssi_ctl1;
-  int8_t rssi_ctl2;
-  int8_t rssi_ext0;
-  int8_t rssi_ext1;
-  int8_t rssi_ext2;
-  int8_t rssi;
-  bool is_mybeacon;
-  u8 antenna;
-  u8 rate;
- } rs[ATH_DBG_MAX_SAMPLES];
- struct ath_cycle_counters cc;
- struct ath9k_nfcal_hist nfCalHist[NUM_NF_READINGS];
-};
-
 struct ath9k_debug {
  struct dentry *debugfs_phy;
  u32 regidx;
  struct ath_stats stats;
-#ifdef CONFIG_ATH9K_MAC_DEBUG
- spinlock_t samp_lock;
- struct ath_dbg_bb_mac_samp bb_mac_samp[ATH_DBG_MAX_SAMPLES];
- u8 sampidx;
- u8 tsidx;
- u8 rsidx;
-#endif
 };
 
 int ath9k_init_debug(struct ath_hw *ah);
@@ -323,18 +266,13 @@ void ath9k_sta_add_debugfs(struct ieee80211_hw *hw,
       struct ieee80211_vif *vif,
       struct ieee80211_sta *sta,
       struct dentry *dir);
-void ath9k_sta_remove_debugfs(struct ieee80211_hw *hw,
-         struct ieee80211_vif *vif,
-         struct ieee80211_sta *sta,
-         struct dentry *dir);
-
-void ath_debug_send_fft_sample(struct ath_softc *sc,
-          struct fft_sample_tlv *fft_sample);
+void ath9k_debug_stat_ant(struct ath_softc *sc,
+     struct ath_hw_antcomb_conf *div_ant_conf,
+     int main_rssi_avg, int alt_rssi_avg);
+void ath9k_debug_sync_cause(struct ath_softc *sc, u32 sync_cause);
 
 #else
 
-#define RX_STAT_INC(c) /* NOP */
-
 static inline int ath9k_init_debug(struct ath_hw *ah)
 {
  return 0;
@@ -343,12 +281,10 @@ static inline int ath9k_init_debug(struct ath_hw *ah)
 static inline void ath9k_deinit_debug(struct ath_softc *sc)
 {
 }
-
 static inline void ath_debug_stat_interrupt(struct ath_softc *sc,
          enum ath9k_int status)
 {
 }
-
 static inline void ath_debug_stat_tx(struct ath_softc *sc,
          struct ath_buf *bf,
          struct ath_tx_status *ts,
@@ -356,25 +292,34 @@ static inline void ath_debug_stat_tx(struct ath_softc *sc,
          unsigned int flags)
 {
 }
-
 static inline void ath_debug_stat_rx(struct ath_softc *sc,
          struct ath_rx_status *rs)
 {
 }
+static inline void ath9k_debug_stat_ant(struct ath_softc *sc,
+     struct ath_hw_antcomb_conf *div_ant_conf,
+     int main_rssi_avg, int alt_rssi_avg)
+{
 
-#endif /* CONFIG_ATH9K_DEBUGFS */
+}
 
-#ifdef CONFIG_ATH9K_MAC_DEBUG
+static inline void
+ath9k_debug_sync_cause(struct ath_softc *sc, u32 sync_cause)
+{
+}
 
-void ath9k_debug_samp_bb_mac(struct ath_softc *sc);
+#endif /* CONFIG_ATH9K_DEBUGFS */
 
+#ifdef CONFIG_ATH9K_STATION_STATISTICS
+void ath_debug_rate_stats(struct ath_softc *sc,
+     struct ath_rx_status *rs,
+     struct sk_buff *skb);
 #else
-
-static inline void ath9k_debug_samp_bb_mac(struct ath_softc *sc)
+static inline void ath_debug_rate_stats(struct ath_softc *sc,
+     struct ath_rx_status *rs,
+     struct sk_buff *skb)
 {
 }
-
-#endif
-
+#endif /* CONFIG_ATH9K_STATION_STATISTICS */
 
 #endif /* DEBUG_H */
diff --git a/drivers/net/wireless/ath/ath9k/debug_sta.c b/drivers/net/wireless/ath/ath9k/debug_sta.c
new file mode 100644
index 0000000..ffca918
--- /dev/null
+++ b/drivers/net/wireless/ath/ath9k/debug_sta.c
@@ -0,0 +1,268 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include "ath9k.h"
+
+/*************/
+/* node_aggr */
+/*************/
+
+static ssize_t read_file_node_aggr(struct file *file, char __user *user_buf,
+       size_t count, loff_t *ppos)
+{
+ struct ath_node *an = file->private_data;
+ struct ath_softc *sc = an->sc;
+ struct ath_atx_tid *tid;
+ struct ath_atx_ac *ac;
+ struct ath_txq *txq;
+ u32 len = 0, size = 4096;
+ char *buf;
+ size_t retval;
+ int tidno, acno;
+
+ buf = kzalloc(size, GFP_KERNEL);
+ if (buf == NULL)
+  return -ENOMEM;
+
+ if (!an->sta->ht_cap.ht_supported) {
+  len = scnprintf(buf, size, "%s\n",
+    "HT not supported");
+  goto exit;
+ }
+
+ len = scnprintf(buf, size, "Max-AMPDU: %d\n",
+   an->maxampdu);
+ len += scnprintf(buf + len, size - len, "MPDU Density: %d\n\n",
+    an->mpdudensity);
+
+ len += scnprintf(buf + len, size - len,
+    "%2s%7s\n", "AC", "SCHED");
+
+ for (acno = 0, ac = &an->ac[acno];
+      acno < IEEE80211_NUM_ACS; acno++, ac++) {
+  txq = ac->txq;
+  ath_txq_lock(sc, txq);
+  len += scnprintf(buf + len, size - len,
+     "%2d%7d\n",
+     acno, ac->sched);
+  ath_txq_unlock(sc, txq);
+ }
+
+ len += scnprintf(buf + len, size - len,
+    "\n%3s%11s%10s%10s%10s%10s%9s%6s%8s\n",
+    "TID", "SEQ_START", "SEQ_NEXT", "BAW_SIZE",
+    "BAW_HEAD", "BAW_TAIL", "BAR_IDX", "SCHED", "PAUSED");
+
+ for (tidno = 0, tid = &an->tid[tidno];
+      tidno < IEEE80211_NUM_TIDS; tidno++, tid++) {
+  txq = tid->ac->txq;
+  ath_txq_lock(sc, txq);
+  if (tid->active) {
+   len += scnprintf(buf + len, size - len,
+      "%3d%11d%10d%10d%10d%10d%9d%6d\n",
+      tid->tidno,
+      tid->seq_start,
+      tid->seq_next,
+      tid->baw_size,
+      tid->baw_head,
+      tid->baw_tail,
+      tid->bar_index,
+      tid->sched);
+  }
+  ath_txq_unlock(sc, txq);
+ }
+exit:
+ retval = simple_read_from_buffer(user_buf, count, ppos, buf, len);
+ kfree(buf);
+
+ return retval;
+}
+
+static const struct file_operations fops_node_aggr = {
+ .read = read_file_node_aggr,
+ .open = simple_open,
+ .owner = THIS_MODULE,
+ .llseek = default_llseek,
+};
+
+/*************/
+/* node_recv */
+/*************/
+
+void ath_debug_rate_stats(struct ath_softc *sc,
+     struct ath_rx_status *rs,
+     struct sk_buff *skb)
+{
+ struct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;
+ struct ath_hw *ah = sc->sc_ah;
+ struct ieee80211_rx_status *rxs;
+ struct ath_rx_rate_stats *rstats;
+ struct ieee80211_sta *sta;
+ struct ath_node *an;
+
+ if (!ieee80211_is_data(hdr->frame_control))
+  return;
+
+ rcu_read_lock();
+
+ sta = ieee80211_find_sta_by_ifaddr(sc->hw, hdr->addr2, NULL);
+ if (!sta)
+  goto exit;
+
+ an = (struct ath_node *) sta->drv_priv;
+ rstats = &an->rx_rate_stats;
+ rxs = IEEE80211_SKB_RXCB(skb);
+
+ if (IS_HT_RATE(rs->rs_rate)) {
+  if (rxs->rate_idx >= ARRAY_SIZE(rstats->ht_stats))
+   goto exit;
+
+  if (rxs->flag & RX_FLAG_40MHZ)
+   rstats->ht_stats[rxs->rate_idx].ht40_cnt++;
+  else
+   rstats->ht_stats[rxs->rate_idx].ht20_cnt++;
+
+  if (rxs->flag & RX_FLAG_SHORT_GI)
+   rstats->ht_stats[rxs->rate_idx].sgi_cnt++;
+  else
+   rstats->ht_stats[rxs->rate_idx].lgi_cnt++;
+
+  goto exit;
+ }
+
+ if (IS_CCK_RATE(rs->rs_rate)) {
+  if (rxs->flag & RX_FLAG_SHORTPRE)
+   rstats->cck_stats[rxs->rate_idx].cck_sp_cnt++;
+  else
+   rstats->cck_stats[rxs->rate_idx].cck_lp_cnt++;
+
+  goto exit;
+ }
+
+ if (IS_OFDM_RATE(rs->rs_rate)) {
+  if (ah->curchan->chan->band == IEEE80211_BAND_2GHZ)
+   rstats->ofdm_stats[rxs->rate_idx - 4].ofdm_cnt++;
+  else
+   rstats->ofdm_stats[rxs->rate_idx].ofdm_cnt++;
+ }
+exit:
+ rcu_read_unlock();
+}
+
+#define PRINT_CCK_RATE(str, i, sp)     \
+ do {        \
+  len += scnprintf(buf + len, size - len,   \
+    "%11s : %10u\n",    \
+    str,      \
+    (sp) ? rstats->cck_stats[i].cck_sp_cnt : \
+    rstats->cck_stats[i].cck_lp_cnt);  \
+ } while (0)
+
+#define PRINT_OFDM_RATE(str, i)     \
+ do {       \
+  len += scnprintf(buf + len, size - len,  \
+    "%11s : %10u\n",   \
+    str,     \
+    rstats->ofdm_stats[i].ofdm_cnt); \
+ } while (0)
+
+static ssize_t read_file_node_recv(struct file *file, char __user *user_buf,
+       size_t count, loff_t *ppos)
+{
+ struct ath_node *an = file->private_data;
+ struct ath_softc *sc = an->sc;
+ struct ath_hw *ah = sc->sc_ah;
+ struct ath_rx_rate_stats *rstats;
+ struct ieee80211_sta *sta = an->sta;
+ enum ieee80211_band band;
+ u32 len = 0, size = 4096;
+ char *buf;
+ size_t retval;
+ int i;
+
+ buf = kzalloc(size, GFP_KERNEL);
+ if (buf == NULL)
+  return -ENOMEM;
+
+ band = ah->curchan->chan->band;
+ rstats = &an->rx_rate_stats;
+
+ if (!sta->ht_cap.ht_supported)
+  goto legacy;
+
+ len += scnprintf(buf + len, size - len,
+    "%24s%10s%10s%10s\n",
+    "HT20", "HT40", "SGI", "LGI");
+
+ for (i = 0; i < 24; i++) {
+  len += scnprintf(buf + len, size - len,
+     "%8s%3u : %10u%10u%10u%10u\n",
+     "MCS", i,
+     rstats->ht_stats[i].ht20_cnt,
+     rstats->ht_stats[i].ht40_cnt,
+     rstats->ht_stats[i].sgi_cnt,
+     rstats->ht_stats[i].lgi_cnt);
+ }
+
+ len += scnprintf(buf + len, size - len, "\n");
+
+legacy:
+ if (band == IEEE80211_BAND_2GHZ) {
+  PRINT_CCK_RATE("CCK-1M/LP", 0, false);
+  PRINT_CCK_RATE("CCK-2M/LP", 1, false);
+  PRINT_CCK_RATE("CCK-5.5M/LP", 2, false);
+  PRINT_CCK_RATE("CCK-11M/LP", 3, false);
+
+  PRINT_CCK_RATE("CCK-2M/SP", 1, true);
+  PRINT_CCK_RATE("CCK-5.5M/SP", 2, true);
+  PRINT_CCK_RATE("CCK-11M/SP", 3, true);
+ }
+
+ PRINT_OFDM_RATE("OFDM-6M", 0);
+ PRINT_OFDM_RATE("OFDM-9M", 1);
+ PRINT_OFDM_RATE("OFDM-12M", 2);
+ PRINT_OFDM_RATE("OFDM-18M", 3);
+ PRINT_OFDM_RATE("OFDM-24M", 4);
+ PRINT_OFDM_RATE("OFDM-36M", 5);
+ PRINT_OFDM_RATE("OFDM-48M", 6);
+ PRINT_OFDM_RATE("OFDM-54M", 7);
+
+ retval = simple_read_from_buffer(user_buf, count, ppos, buf, len);
+ kfree(buf);
+
+ return retval;
+}
+
+#undef PRINT_OFDM_RATE
+#undef PRINT_CCK_RATE
+
+static const struct file_operations fops_node_recv = {
+ .read = read_file_node_recv,
+ .open = simple_open,
+ .owner = THIS_MODULE,
+ .llseek = default_llseek,
+};
+
+void ath9k_sta_add_debugfs(struct ieee80211_hw *hw,
+      struct ieee80211_vif *vif,
+      struct ieee80211_sta *sta,
+      struct dentry *dir)
+{
+ struct ath_node *an = (struct ath_node *)sta->drv_priv;
+
+ debugfs_create_file("node_aggr", S_IRUGO, dir, an, &fops_node_aggr);
+ debugfs_create_file("node_recv", S_IRUGO, dir, an, &fops_node_recv);
+}
diff --git a/drivers/net/wireless/ath/ath9k/dfs.c b/drivers/net/wireless/ath/ath9k/dfs.c
index 7187d36..726271c 100644
--- a/drivers/net/wireless/ath/ath9k/dfs.c
+++ b/drivers/net/wireless/ath/ath9k/dfs.c
@@ -158,8 +158,8 @@ void ath9k_dfs_process_phyerr(struct ath_softc *sc, void *data,
   return;
  }
 
- ard.rssi = rs->rs_rssi_ctl0;
- ard.ext_rssi = rs->rs_rssi_ext0;
+ ard.rssi = rs->rs_rssi_ctl[0];
+ ard.ext_rssi = rs->rs_rssi_ext[0];
 
  /*
   * hardware stores this as 8 bit signed value.
@@ -178,12 +178,12 @@ void ath9k_dfs_process_phyerr(struct ath_softc *sc, void *data,
  pe.ts = mactime;
  if (ath9k_postprocess_radar_event(sc, &ard, &pe)) {
   struct dfs_pattern_detector *pd = sc->dfs_detector;
-  static u64 last_ts;
   ath_dbg(common, DFS,
    "ath9k_dfs_process_phyerr: channel=%d, ts=%llu, "
    "width=%d, rssi=%d, delta_ts=%llu\n",
-   pe.freq, pe.ts, pe.width, pe.rssi, pe.ts-last_ts);
-  last_ts = pe.ts;
+   pe.freq, pe.ts, pe.width, pe.rssi,
+   pe.ts - sc->dfs_prev_pulse_ts);
+  sc->dfs_prev_pulse_ts = pe.ts;
   DFS_STAT_INC(sc, pulses_processed);
   if (pd != NULL && pd->add_pulse(pd, &pe)) {
    DFS_STAT_INC(sc, radar_detected);
diff --git a/drivers/net/wireless/ath/ath9k/dfs.h b/drivers/net/wireless/ath/ath9k/dfs.h
index 3c839f0..c6fa3d5 100644
--- a/drivers/net/wireless/ath/ath9k/dfs.h
+++ b/drivers/net/wireless/ath/ath9k/dfs.h
@@ -17,7 +17,7 @@
 
 #ifndef ATH9K_DFS_H
 #define ATH9K_DFS_H
-#include "dfs_pattern_detector.h"
+#include "../dfs_pattern_detector.h"
 
 #if defined(CONFIG_ATH9K_DFS_CERTIFIED)
 /**
diff --git a/drivers/net/wireless/ath/ath9k/dfs_debug.c b/drivers/net/wireless/ath/ath9k/dfs_debug.c
index b7611b7..8824610 100644
--- a/drivers/net/wireless/ath/ath9k/dfs_debug.c
+++ b/drivers/net/wireless/ath/ath9k/dfs_debug.c
@@ -20,16 +20,16 @@
 
 #include "ath9k.h"
 #include "dfs_debug.h"
+#include "../dfs_pattern_detector.h"
 
-
-struct ath_dfs_pool_stats global_dfs_pool_stats = { 0 };
+static struct ath_dfs_pool_stats dfs_pool_stats = { 0 };
 
 #define ATH9K_DFS_STAT(s, p) \
- len += snprintf(buf + len, size - len, "%28s : %10u\n", s, \
-   sc->debug.stats.dfs_stats.p);
+ len += scnprintf(buf + len, size - len, "%28s : %10u\n", s, \
+    sc->debug.stats.dfs_stats.p);
 #define ATH9K_DFS_POOL_STAT(s, p) \
- len += snprintf(buf + len, size - len, "%28s : %10u\n", s, \
-   global_dfs_pool_stats.p);
+ len += scnprintf(buf + len, size - len, "%28s : %10u\n", s, \
+    dfs_pool_stats.p);
 
 static ssize_t read_file_dfs(struct file *file, char __user *user_buf,
         size_t count, loff_t *ppos)
@@ -44,12 +44,21 @@ static ssize_t read_file_dfs(struct file *file, char __user *user_buf,
  if (buf == NULL)
   return -ENOMEM;
 
- len += snprintf(buf + len, size - len, "DFS support for "
-   "macVersion = 0x%x, macRev = 0x%x: %s\n",
-   hw_ver->macVersion, hw_ver->macRev,
-   (sc->sc_ah->caps.hw_caps & ATH9K_HW_CAP_DFS) ?
+ len += scnprintf(buf + len, size - len, "DFS support for "
+    "macVersion = 0x%x, macRev = 0x%x: %s\n",
+    hw_ver->macVersion, hw_ver->macRev,
+    (sc->sc_ah->caps.hw_caps & ATH9K_HW_CAP_DFS) ?
      "enabled" : "disabled");
- len += snprintf(buf + len, size - len, "Pulse detector statistics:\n");
+
+ if (!sc->dfs_detector) {
+  len += scnprintf(buf + len, size - len,
+     "DFS detector not enabled\n");
+  goto exit;
+ }
+
+ dfs_pool_stats = sc->dfs_detector->get_stats(sc->dfs_detector);
+
+ len += scnprintf(buf + len, size - len, "Pulse detector statistics:\n");
  ATH9K_DFS_STAT("pulse events reported   ", pulses_total);
  ATH9K_DFS_STAT("invalid pulse events    ", pulses_no_dfs);
  ATH9K_DFS_STAT("DFS pulses detected     ", pulses_detected);
@@ -59,11 +68,12 @@ static ssize_t read_file_dfs(struct file *file, char __user *user_buf,
  ATH9K_DFS_STAT("Primary channel pulses  ", pri_phy_errors);
  ATH9K_DFS_STAT("Secondary channel pulses", ext_phy_errors);
  ATH9K_DFS_STAT("Dual channel pulses     ", dc_phy_errors);
- len += snprintf(buf + len, size - len, "Radar detector statistics "
-   "(current DFS region: %d)\n", sc->dfs_detector->region);
+ len += scnprintf(buf + len, size - len, "Radar detector statistics "
+    "(current DFS region: %d)\n",
+    sc->dfs_detector->region);
  ATH9K_DFS_STAT("Pulse events processed  ", pulses_processed);
  ATH9K_DFS_STAT("Radars detected         ", radar_detected);
- len += snprintf(buf + len, size - len, "Global Pool statistics:\n");
+ len += scnprintf(buf + len, size - len, "Global Pool statistics:\n");
  ATH9K_DFS_POOL_STAT("Pool references         ", pool_reference);
  ATH9K_DFS_POOL_STAT("Pulses allocated        ", pulse_allocated);
  ATH9K_DFS_POOL_STAT("Pulses alloc error      ", pulse_alloc_error);
@@ -72,6 +82,7 @@ static ssize_t read_file_dfs(struct file *file, char __user *user_buf,
  ATH9K_DFS_POOL_STAT("Seqs. alloc error       ", pseq_alloc_error);
  ATH9K_DFS_POOL_STAT("Seqs. in use            ", pseq_used);
 
+exit:
  if (len > size)
   len = size;
 
@@ -96,7 +107,7 @@ static ssize_t write_file_dfs(struct file *file, const char __user *user_buf,
   return -EFAULT;
 
  buf[len] = '\0';
- if (strict_strtoul(buf, 0, &val))
+ if (kstrtoul(buf, 0, &val))
   return -EINVAL;
 
  if (val == DFS_STATS_RESET_MAGIC)
diff --git a/drivers/net/wireless/ath/ath9k/dfs_debug.h b/drivers/net/wireless/ath/ath9k/dfs_debug.h
index e36810a..7936c91 100644
--- a/drivers/net/wireless/ath/ath9k/dfs_debug.h
+++ b/drivers/net/wireless/ath/ath9k/dfs_debug.h
@@ -21,6 +21,8 @@
 
 #include "hw.h"
 
+struct ath_softc;
+
 /**
  * struct ath_dfs_stats - DFS Statistics per wiphy
  * @pulses_total:     pulses reported by HW
@@ -51,25 +53,11 @@ struct ath_dfs_stats {
  u32 radar_detected;
 };
 
-/**
- * struct ath_dfs_pool_stats - DFS Statistics for global pools
- */
-struct ath_dfs_pool_stats {
- u32 pool_reference;
- u32 pulse_allocated;
- u32 pulse_alloc_error;
- u32 pulse_used;
- u32 pseq_allocated;
- u32 pseq_alloc_error;
- u32 pseq_used;
-};
 #if defined(CONFIG_ATH9K_DFS_DEBUGFS)
 
 #define DFS_STAT_INC(sc, c) (sc->debug.stats.dfs_stats.c++)
 void ath9k_dfs_init_debug(struct ath_softc *sc);
 
-#define DFS_POOL_STAT_INC(c) (global_dfs_pool_stats.c++)
-#define DFS_POOL_STAT_DEC(c) (global_dfs_pool_stats.c--)
 extern struct ath_dfs_pool_stats global_dfs_pool_stats;
 
 #else
@@ -77,8 +65,6 @@ extern struct ath_dfs_pool_stats global_dfs_pool_stats;
 #define DFS_STAT_INC(sc, c) do { } while (0)
 static inline void ath9k_dfs_init_debug(struct ath_softc *sc) { }
 
-#define DFS_POOL_STAT_INC(c) do { } while (0)
-#define DFS_POOL_STAT_DEC(c) do { } while (0)
 #endif /* CONFIG_ATH9K_DFS_DEBUGFS */
 
 #endif /* ATH9K_DFS_DEBUG_H */
diff --git a/drivers/net/wireless/ath/ath9k/eeprom_4k.c b/drivers/net/wireless/ath/ath9k/eeprom_4k.c
index c2bfd74..07b806c 100644
--- a/drivers/net/wireless/ath/ath9k/eeprom_4k.c
+++ b/drivers/net/wireless/ath/ath9k/eeprom_4k.c
@@ -129,10 +129,10 @@ static u32 ath9k_hw_4k_dump_eeprom(struct ath_hw *ah, bool dump_base_hdr,
  struct base_eep_header_4k *pBase = &eep->baseEepHeader;
 
  if (!dump_base_hdr) {
-  len += snprintf(buf + len, size - len,
-    "%20s :\n", "2GHz modal Header");
+  len += scnprintf(buf + len, size - len,
+     "%20s :\n", "2GHz modal Header");
   len = ath9k_dump_4k_modal_eeprom(buf, len, size,
-        &eep->modalHeader);
+       &eep->modalHeader);
   goto out;
  }
 
@@ -160,8 +160,8 @@ static u32 ath9k_hw_4k_dump_eeprom(struct ath_hw *ah, bool dump_base_hdr,
  PR_EEP("Cal Bin Build", (pBase->binBuildNumber >> 8) & 0xFF);
  PR_EEP("TX Gain type", pBase->txGainType);
 
- len += snprintf(buf + len, size - len, "%20s : %pM\n", "MacAddress",
-   pBase->macAddr);
+ len += scnprintf(buf + len, size - len, "%20s : %pM\n", "MacAddress",
+    pBase->macAddr);
 
 out:
  if (len > size)
@@ -812,6 +812,7 @@ static void ath9k_hw_4k_set_gain(struct ath_hw *ah,
 static void ath9k_hw_4k_set_board_values(struct ath_hw *ah,
       struct ath9k_channel *chan)
 {
+ struct ath9k_hw_capabilities *pCap = &ah->caps;
  struct modal_eep_4k_header *pModal;
  struct ar5416_eeprom_4k *eep = &ah->eeprom.map4k;
  struct base_eep_header_4k *pBase = &eep->baseEepHeader;
@@ -858,6 +859,24 @@ static void ath9k_hw_4k_set_board_values(struct ath_hw *ah,
 
   REG_WRITE(ah, AR_PHY_CCK_DETECT, regVal);
   regVal = REG_READ(ah, AR_PHY_CCK_DETECT);
+
+  if (pCap->hw_caps & ATH9K_HW_CAP_ANT_DIV_COMB) {
+   /*
+    * If diversity combining is enabled,
+    * set MAIN to LNA1 and ALT to LNA2 initially.
+    */
+   regVal = REG_READ(ah, AR_PHY_MULTICHAIN_GAIN_CTL);
+   regVal &= (~(AR_PHY_9285_ANT_DIV_MAIN_LNACONF |
+         AR_PHY_9285_ANT_DIV_ALT_LNACONF));
+
+   regVal |= (ATH_ANT_DIV_COMB_LNA1 <<
+       AR_PHY_9285_ANT_DIV_MAIN_LNACONF_S);
+   regVal |= (ATH_ANT_DIV_COMB_LNA2 <<
+       AR_PHY_9285_ANT_DIV_ALT_LNACONF_S);
+   regVal &= (~(AR_PHY_9285_FAST_DIV_BIAS));
+   regVal |= (0 << AR_PHY_9285_FAST_DIV_BIAS_S);
+   REG_WRITE(ah, AR_PHY_MULTICHAIN_GAIN_CTL, regVal);
+  }
  }
 
  if (pModal->version >= 2) {
@@ -1066,31 +1085,7 @@ static void ath9k_hw_4k_set_board_values(struct ath_hw *ah,
 
 static u16 ath9k_hw_4k_get_spur_channel(struct ath_hw *ah, u16 i, bool is2GHz)
 {
-#define EEP_MAP4K_SPURCHAN \
- (ah->eeprom.map4k.modalHeader.spurChans[i].spurChan)
- struct ath_common *common = ath9k_hw_common(ah);
-
- u16 spur_val = AR_NO_SPUR;
-
- ath_dbg(common, ANI, "Getting spur idx:%d is2Ghz:%d val:%x\n",
-  i, is2GHz, ah->config.spurchans[i][is2GHz]);
-
- switch (ah->config.spurmode) {
- case SPUR_DISABLE:
-  break;
- case SPUR_ENABLE_IOCTL:
-  spur_val = ah->config.spurchans[i][is2GHz];
-  ath_dbg(common, ANI, "Getting spur val from new loc. %d\n",
-   spur_val);
-  break;
- case SPUR_ENABLE_EEPROM:
-  spur_val = EEP_MAP4K_SPURCHAN;
-  break;
- }
-
- return spur_val;
-
-#undef EEP_MAP4K_SPURCHAN
+ return ah->eeprom.map4k.modalHeader.spurChans[i].spurChan;
 }
 
 const struct eeprom_ops eep_4k_ops = {
diff --git a/drivers/net/wireless/ath/ath9k/eeprom_9287.c b/drivers/net/wireless/ath/ath9k/eeprom_9287.c
index 3ae1f3d..5ba1385 100644
--- a/drivers/net/wireless/ath/ath9k/eeprom_9287.c
+++ b/drivers/net/wireless/ath/ath9k/eeprom_9287.c
@@ -125,8 +125,8 @@ static u32 ath9k_hw_ar9287_dump_eeprom(struct ath_hw *ah, bool dump_base_hdr,
  struct base_eep_ar9287_header *pBase = &eep->baseEepHeader;
 
  if (!dump_base_hdr) {
-  len += snprintf(buf + len, size - len,
-    "%20s :\n", "2GHz modal Header");
+  len += scnprintf(buf + len, size - len,
+     "%20s :\n", "2GHz modal Header");
   len = ar9287_dump_modal_eeprom(buf, len, size,
       &eep->modalHeader);
   goto out;
@@ -157,8 +157,8 @@ static u32 ath9k_hw_ar9287_dump_eeprom(struct ath_hw *ah, bool dump_base_hdr,
  PR_EEP("Power Table Offset", pBase->pwrTableOffset);
  PR_EEP("OpenLoop Power Ctrl", pBase->openLoopPwrCntl);
 
- len += snprintf(buf + len, size - len, "%20s : %pM\n", "MacAddress",
-   pBase->macAddr);
+ len += scnprintf(buf + len, size - len, "%20s : %pM\n", "MacAddress",
+    pBase->macAddr);
 
 out:
  if (len > size)
@@ -1004,31 +1004,7 @@ static void ath9k_hw_ar9287_set_board_values(struct ath_hw *ah,
 static u16 ath9k_hw_ar9287_get_spur_channel(struct ath_hw *ah,
          u16 i, bool is2GHz)
 {
-#define EEP_MAP9287_SPURCHAN \
- (ah->eeprom.map9287.modalHeader.spurChans[i].spurChan)
-
- struct ath_common *common = ath9k_hw_common(ah);
- u16 spur_val = AR_NO_SPUR;
-
- ath_dbg(common, ANI, "Getting spur idx:%d is2Ghz:%d val:%x\n",
-  i, is2GHz, ah->config.spurchans[i][is2GHz]);
-
- switch (ah->config.spurmode) {
- case SPUR_DISABLE:
-  break;
- case SPUR_ENABLE_IOCTL:
-  spur_val = ah->config.spurchans[i][is2GHz];
-  ath_dbg(common, ANI, "Getting spur val from new loc. %d\n",
-   spur_val);
-  break;
- case SPUR_ENABLE_EEPROM:
-  spur_val = EEP_MAP9287_SPURCHAN;
-  break;
- }
-
- return spur_val;
-
-#undef EEP_MAP9287_SPURCHAN
+ return ah->eeprom.map9287.modalHeader.spurChans[i].spurChan;
 }
 
 const struct eeprom_ops eep_ar9287_ops = {
diff --git a/drivers/net/wireless/ath/ath9k/eeprom_def.c b/drivers/net/wireless/ath/ath9k/eeprom_def.c
index 1c25368..3218ca9 100644
--- a/drivers/net/wireless/ath/ath9k/eeprom_def.c
+++ b/drivers/net/wireless/ath/ath9k/eeprom_def.c
@@ -205,12 +205,12 @@ static u32 ath9k_hw_def_dump_eeprom(struct ath_hw *ah, bool dump_base_hdr,
  struct base_eep_header *pBase = &eep->baseEepHeader;
 
  if (!dump_base_hdr) {
-  len += snprintf(buf + len, size - len,
-    "%20s :\n", "2GHz modal Header");
+  len += scnprintf(buf + len, size - len,
+     "%20s :\n", "2GHz modal Header");
   len = ath9k_def_dump_modal_eeprom(buf, len, size,
          &eep->modalHeader[0]);
-  len += snprintf(buf + len, size - len,
-    "%20s :\n", "5GHz modal Header");
+  len += scnprintf(buf + len, size - len,
+     "%20s :\n", "5GHz modal Header");
   len = ath9k_def_dump_modal_eeprom(buf, len, size,
          &eep->modalHeader[1]);
   goto out;
@@ -240,8 +240,8 @@ static u32 ath9k_hw_def_dump_eeprom(struct ath_hw *ah, bool dump_base_hdr,
  PR_EEP("Cal Bin Build", (pBase->binBuildNumber >> 8) & 0xFF);
  PR_EEP("OpenLoop Power Ctrl", pBase->openLoopPwrCntl);
 
- len += snprintf(buf + len, size - len, "%20s : %pM\n", "MacAddress",
-   pBase->macAddr);
+ len += scnprintf(buf + len, size - len, "%20s : %pM\n", "MacAddress",
+    pBase->macAddr);
 
 out:
  if (len > size)
@@ -1348,31 +1348,7 @@ static void ath9k_hw_def_set_txpower(struct ath_hw *ah,
 
 static u16 ath9k_hw_def_get_spur_channel(struct ath_hw *ah, u16 i, bool is2GHz)
 {
-#define EEP_DEF_SPURCHAN \
- (ah->eeprom.def.modalHeader[is2GHz].spurChans[i].spurChan)
- struct ath_common *common = ath9k_hw_common(ah);
-
- u16 spur_val = AR_NO_SPUR;
-
- ath_dbg(common, ANI, "Getting spur idx:%d is2Ghz:%d val:%x\n",
-  i, is2GHz, ah->config.spurchans[i][is2GHz]);
-
- switch (ah->config.spurmode) {
- case SPUR_DISABLE:
-  break;
- case SPUR_ENABLE_IOCTL:
-  spur_val = ah->config.spurchans[i][is2GHz];
-  ath_dbg(common, ANI, "Getting spur val from new loc. %d\n",
-   spur_val);
-  break;
- case SPUR_ENABLE_EEPROM:
-  spur_val = EEP_DEF_SPURCHAN;
-  break;
- }
-
- return spur_val;
-
-#undef EEP_DEF_SPURCHAN
+ return ah->eeprom.def.modalHeader[is2GHz].spurChans[i].spurChan;
 }
 
 const struct eeprom_ops eep_def_ops = {
diff --git a/drivers/net/wireless/ath/ath9k/gpio.c b/drivers/net/wireless/ath/ath9k/gpio.c
index 4b412aa..b1956bf 100644
--- a/drivers/net/wireless/ath/ath9k/gpio.c
+++ b/drivers/net/wireless/ath/ath9k/gpio.c
@@ -157,36 +157,6 @@ static void ath_detect_bt_priority(struct ath_softc *sc)
  }
 }
 
-static void ath9k_gen_timer_start(struct ath_hw *ah,
-      struct ath_gen_timer *timer,
-      u32 trig_timeout,
-      u32 timer_period)
-{
- ath9k_hw_gen_timer_start(ah, timer, trig_timeout, timer_period);
-
- if ((ah->imask & ATH9K_INT_GENTIMER) == 0) {
-  ath9k_hw_disable_interrupts(ah);
-  ah->imask |= ATH9K_INT_GENTIMER;
-  ath9k_hw_set_interrupts(ah);
-  ath9k_hw_enable_interrupts(ah);
- }
-}
-
-static void ath9k_gen_timer_stop(struct ath_hw *ah, struct ath_gen_timer *timer)
-{
- struct ath_gen_timer_table *timer_table = &ah->hw_gen_timers;
-
- ath9k_hw_gen_timer_stop(ah, timer);
-
- /* if no timer is enabled, turn off interrupt mask */
- if (timer_table->timer_mask.val == 0) {
-  ath9k_hw_disable_interrupts(ah);
-  ah->imask &= ~ATH9K_INT_GENTIMER;
-  ath9k_hw_set_interrupts(ah);
-  ath9k_hw_enable_interrupts(ah);
- }
-}
-
 static void ath_mci_ftp_adjust(struct ath_softc *sc)
 {
  struct ath_btcoex *btcoex = &sc->btcoex;
@@ -257,19 +227,9 @@ static void ath_btcoex_period_timer(unsigned long data)
 
  spin_unlock_bh(&btcoex->btcoex_lock);
 
- /*
-  * btcoex_period is in msec while (btocex/btscan_)no_stomp are in usec,
-  * ensure that we properly convert btcoex_period to usec
-  * for any comparision with (btcoex/btscan_)no_stomp.
-  */
- if (btcoex->btcoex_period * 1000 != btcoex->btcoex_no_stomp) {
-  if (btcoex->hw_timer_enabled)
-   ath9k_gen_timer_stop(ah, btcoex->no_stomp_timer);
-
-  ath9k_gen_timer_start(ah, btcoex->no_stomp_timer, timer_period,
-          timer_period * 10);
-  btcoex->hw_timer_enabled = true;
- }
+ if (btcoex->btcoex_period != btcoex->btcoex_no_stomp)
+  mod_timer(&btcoex->no_stomp_timer,
+    jiffies + msecs_to_jiffies(timer_period));
 
  ath9k_ps_restore(sc);
 
@@ -282,7 +242,7 @@ skip_hw_wakeup:
  * Generic tsf based hw timer which configures weight
  * registers to time slice between wlan and bt traffic
  */
-static void ath_btcoex_no_stomp_timer(void *arg)
+static void ath_btcoex_no_stomp_timer(unsigned long arg)
 {
  struct ath_softc *sc = (struct ath_softc *)arg;
  struct ath_hw *ah = sc->sc_ah;
@@ -311,24 +271,18 @@ static int ath_init_btcoex_timer(struct ath_softc *sc)
  struct ath_btcoex *btcoex = &sc->btcoex;
 
  btcoex->btcoex_period = ATH_BTCOEX_DEF_BT_PERIOD;
- btcoex->btcoex_no_stomp = (100 - ATH_BTCOEX_DEF_DUTY_CYCLE) * 1000 *
+ btcoex->btcoex_no_stomp = (100 - ATH_BTCOEX_DEF_DUTY_CYCLE) *
   btcoex->btcoex_period / 100;
- btcoex->btscan_no_stomp = (100 - ATH_BTCOEX_BTSCAN_DUTY_CYCLE) * 1000 *
+ btcoex->btscan_no_stomp = (100 - ATH_BTCOEX_BTSCAN_DUTY_CYCLE) *
        btcoex->btcoex_period / 100;
 
  setup_timer(&btcoex->period_timer, ath_btcoex_period_timer,
    (unsigned long) sc);
+ setup_timer(&btcoex->no_stomp_timer, ath_btcoex_no_stomp_timer,
+   (unsigned long) sc);
 
  spin_lock_init(&btcoex->btcoex_lock);
 
- btcoex->no_stomp_timer = ath_gen_timer_alloc(sc->sc_ah,
-   ath_btcoex_no_stomp_timer,
-   ath_btcoex_no_stomp_timer,
-   (void *) sc, AR_FIRST_NDP_TIMER);
-
- if (!btcoex->no_stomp_timer)
-  return -ENOMEM;
-
  return 0;
 }
 
@@ -343,10 +297,7 @@ void ath9k_btcoex_timer_resume(struct ath_softc *sc)
  ath_dbg(ath9k_hw_common(ah), BTCOEX, "Starting btcoex timers\n");
 
  /* make sure duty cycle timer is also stopped when resuming */
- if (btcoex->hw_timer_enabled) {
-  ath9k_gen_timer_stop(sc->sc_ah, btcoex->no_stomp_timer);
-  btcoex->hw_timer_enabled = false;
- }
+ del_timer_sync(&btcoex->no_stomp_timer);
 
  btcoex->bt_priority_cnt = 0;
  btcoex->bt_priority_time = jiffies;
@@ -363,24 +314,16 @@ void ath9k_btcoex_timer_resume(struct ath_softc *sc)
 void ath9k_btcoex_timer_pause(struct ath_softc *sc)
 {
  struct ath_btcoex *btcoex = &sc->btcoex;
- struct ath_hw *ah = sc->sc_ah;
 
  del_timer_sync(&btcoex->period_timer);
-
- if (btcoex->hw_timer_enabled) {
-  ath9k_gen_timer_stop(ah, btcoex->no_stomp_timer);
-  btcoex->hw_timer_enabled = false;
- }
+ del_timer_sync(&btcoex->no_stomp_timer);
 }
 
 void ath9k_btcoex_stop_gen_timer(struct ath_softc *sc)
 {
  struct ath_btcoex *btcoex = &sc->btcoex;
 
- if (btcoex->hw_timer_enabled) {
-  ath9k_gen_timer_stop(sc->sc_ah, btcoex->no_stomp_timer);
-  btcoex->hw_timer_enabled = false;
- }
+ del_timer_sync(&btcoex->no_stomp_timer);
 }
 
 u16 ath9k_btcoex_aggr_limit(struct ath_softc *sc, u32 max_4ms_framelen)
@@ -400,12 +343,6 @@ u16 ath9k_btcoex_aggr_limit(struct ath_softc *sc, u32 max_4ms_framelen)
 
 void ath9k_btcoex_handle_interrupt(struct ath_softc *sc, u32 status)
 {
- struct ath_hw *ah = sc->sc_ah;
-
- if (ath9k_hw_get_btcoex_scheme(ah) == ATH_BTCOEX_CFG_3WIRE)
-  if (status & ATH9K_INT_GENTIMER)
-   ath_gen_timer_isr(sc->sc_ah);
-
  if (status & ATH9K_INT_MCI)
   ath_mci_intr(sc);
 }
@@ -447,10 +384,6 @@ void ath9k_deinit_btcoex(struct ath_softc *sc)
 {
  struct ath_hw *ah = sc->sc_ah;
 
-        if ((sc->btcoex.no_stomp_timer) &&
-     ath9k_hw_get_btcoex_scheme(sc->sc_ah) == ATH_BTCOEX_CFG_3WIRE)
-  ath_gen_timer_free(sc->sc_ah, sc->btcoex.no_stomp_timer);
-
  if (ath9k_hw_mci_is_enabled(ah))
   ath_mci_cleanup(sc);
 }
@@ -522,22 +455,22 @@ static int ath9k_dump_mci_btcoex(struct ath_softc *sc, u8 *buf, u32 size)
  ATH_DUMP_BTCOEX("Concurrent Tx", btcoex_hw->mci.concur_tx);
  ATH_DUMP_BTCOEX("Concurrent RSSI cnt", btcoex->rssi_count);
 
- len += snprintf(buf + len, size - len, "BT Weights: ");
+ len += scnprintf(buf + len, size - len, "BT Weights: ");
  for (i = 0; i < AR9300_NUM_BT_WEIGHTS; i++)
-  len += snprintf(buf + len, size - len, "%08x ",
-    btcoex_hw->bt_weight[i]);
- len += snprintf(buf + len, size - len, "\n");
- len += snprintf(buf + len, size - len, "WLAN Weights: ");
+  len += scnprintf(buf + len, size - len, "%08x ",
+     btcoex_hw->bt_weight[i]);
+ len += scnprintf(buf + len, size - len, "\n");
+ len += scnprintf(buf + len, size - len, "WLAN Weights: ");
  for (i = 0; i < AR9300_NUM_BT_WEIGHTS; i++)
-  len += snprintf(buf + len, size - len, "%08x ",
-    btcoex_hw->wlan_weight[i]);
- len += snprintf(buf + len, size - len, "\n");
- len += snprintf(buf + len, size - len, "Tx Priorities: ");
+  len += scnprintf(buf + len, size - len, "%08x ",
+     btcoex_hw->wlan_weight[i]);
+ len += scnprintf(buf + len, size - len, "\n");
+ len += scnprintf(buf + len, size - len, "Tx Priorities: ");
  for (i = 0; i < ATH_BTCOEX_STOMP_MAX; i++)
-  len += snprintf(buf + len, size - len, "%08x ",
+  len += scnprintf(buf + len, size - len, "%08x ",
     btcoex_hw->tx_prio[i]);
 
- len += snprintf(buf + len, size - len, "\n");
+ len += scnprintf(buf + len, size - len, "\n");
 
  return len;
 }
diff --git a/drivers/net/wireless/ath/ath9k/hif_usb.c b/drivers/net/wireless/ath/ath9k/hif_usb.c
index 75a6376..8e7153b 100644
--- a/drivers/net/wireless/ath/ath9k/hif_usb.c
+++ b/drivers/net/wireless/ath/ath9k/hif_usb.c
@@ -54,6 +54,8 @@ static struct usb_device_id ath9k_hif_usb_ids[] = {
    .driver_info = AR9280_USB },  /* SMC Networks */
  { USB_DEVICE(0x0411, 0x017f),
    .driver_info = AR9280_USB },  /* Sony UWA-BR100 */
+ { USB_DEVICE(0x0411, 0x0197),
+   .driver_info = AR9280_USB },  /* Buffalo WLI-UV-AG300P */
  { USB_DEVICE(0x04da, 0x3904),
    .driver_info = AR9280_USB },
 
@@ -115,10 +117,10 @@ static int hif_usb_send_regout(struct hif_device_usb *hif_dev,
  cmd->skb = skb;
  cmd->hif_dev = hif_dev;
 
- usb_fill_bulk_urb(urb, hif_dev->udev,
-    usb_sndbulkpipe(hif_dev->udev, USB_REG_OUT_PIPE),
+ usb_fill_int_urb(urb, hif_dev->udev,
+    usb_sndintpipe(hif_dev->udev, USB_REG_OUT_PIPE),
     skb->data, skb->len,
-    hif_usb_regout_cb, cmd);
+    hif_usb_regout_cb, cmd, 1);
 
  usb_anchor_urb(urb, &hif_dev->regout_submitted);
  ret = usb_submit_urb(urb, GFP_KERNEL);
@@ -234,10 +236,15 @@ static inline void ath9k_skb_queue_complete(struct hif_device_usb *hif_dev,
  struct sk_buff *skb;
 
  while ((skb = __skb_dequeue(queue)) != NULL) {
+#ifdef CONFIG_ATH9K_HTC_DEBUGFS
+  int ln = skb->len;
+#endif
   ath9k_htc_txcompletion_cb(hif_dev->htc_handle,
        skb, txok);
-  if (txok)
+  if (txok) {
    TX_STAT_INC(skb_success);
+   TX_STAT_ADD(skb_success_bytes, ln);
+  }
   else
    TX_STAT_INC(skb_failed);
  }
@@ -620,6 +627,7 @@ static void ath9k_hif_usb_rx_stream(struct hif_device_usb *hif_dev,
 
 err:
  for (i = 0; i < pool_index; i++) {
+  RX_STAT_ADD(skb_completed_bytes, skb_pool[i]->len);
   ath9k_htc_rx_msg(hif_dev->htc_handle, skb_pool[i],
      skb_pool[i]->len, USB_WLAN_RX_PIPE);
   RX_STAT_INC(skb_completed);
@@ -717,11 +725,11 @@ static void ath9k_hif_usb_reg_in_cb(struct urb *urb)
    return;
   }
 
-  usb_fill_bulk_urb(urb, hif_dev->udev,
-     usb_rcvbulkpipe(hif_dev->udev,
+  usb_fill_int_urb(urb, hif_dev->udev,
+     usb_rcvintpipe(hif_dev->udev,
        USB_REG_IN_PIPE),
      nskb->data, MAX_REG_IN_BUF_SIZE,
-     ath9k_hif_usb_reg_in_cb, nskb);
+     ath9k_hif_usb_reg_in_cb, nskb, 1);
  }
 
 resubmit:
@@ -903,11 +911,11 @@ static int ath9k_hif_usb_alloc_reg_in_urbs(struct hif_device_usb *hif_dev)
    goto err_skb;
   }
 
-  usb_fill_bulk_urb(urb, hif_dev->udev,
-      usb_rcvbulkpipe(hif_dev->udev,
+  usb_fill_int_urb(urb, hif_dev->udev,
+      usb_rcvintpipe(hif_dev->udev,
         USB_REG_IN_PIPE),
       skb->data, MAX_REG_IN_BUF_SIZE,
-      ath9k_hif_usb_reg_in_cb, skb);
+      ath9k_hif_usb_reg_in_cb, skb, 1);
 
   /* Anchor URB */
   usb_anchor_urb(urb, &hif_dev->reg_in_submitted);
@@ -1025,9 +1033,7 @@ static int ath9k_hif_usb_download_fw(struct hif_device_usb *hif_dev)
 
 static int ath9k_hif_usb_dev_init(struct hif_device_usb *hif_dev)
 {
- struct usb_host_interface *alt = &hif_dev->interface->altsetting[0];
- struct usb_endpoint_descriptor *endp;
- int ret, idx;
+ int ret;
 
  ret = ath9k_hif_usb_download_fw(hif_dev);
  if (ret) {
@@ -1037,20 +1043,6 @@ static int ath9k_hif_usb_dev_init(struct hif_device_usb *hif_dev)
   return ret;
  }
 
- /* On downloading the firmware to the target, the USB descriptor of EP4
-  * is 'patched' to change the type of the endpoint to Bulk. This will
-  * bring down CPU usage during the scan period.
-  */
- for (idx = 0; idx < alt->desc.bNumEndpoints; idx++) {
-  endp = &alt->endpoint[idx].desc;
-  if ((endp->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK)
-    == USB_ENDPOINT_XFER_INT) {
-   endp->bmAttributes &= ~USB_ENDPOINT_XFERTYPE_MASK;
-   endp->bmAttributes |= USB_ENDPOINT_XFER_BULK;
-   endp->bInterval = 0;
-  }
- }
-
  /* Alloc URBs */
  ret = ath9k_hif_usb_alloc_urbs(hif_dev);
  if (ret) {
@@ -1076,7 +1068,7 @@ static void ath9k_hif_usb_firmware_fail(struct hif_device_usb *hif_dev)
  struct device *dev = &hif_dev->udev->dev;
  struct device *parent = dev->parent;
 
- complete(&hif_dev->fw_done);
+ complete_all(&hif_dev->fw_done);
 
  if (parent)
   device_lock(parent);
@@ -1125,7 +1117,7 @@ static void ath9k_hif_usb_firmware_cb(const struct firmware *fw, void *context)
 
  release_firmware(fw);
  hif_dev->flags |= HIF_USB_READY;
- complete(&hif_dev->fw_done);
+ complete_all(&hif_dev->fw_done);
 
  return;
 
@@ -1262,7 +1254,7 @@ static void ath9k_hif_usb_reboot(struct usb_device *udev)
  if (!buf)
   return;
 
- ret = usb_bulk_msg(udev, usb_sndbulkpipe(udev, USB_REG_OUT_PIPE),
+ ret = usb_interrupt_msg(udev, usb_sndintpipe(udev, USB_REG_OUT_PIPE),
       buf, 4, NULL, HZ);
  if (ret)
   dev_err(&udev->dev, "ath9k_htc: USB reboot failed\n");
@@ -1312,7 +1304,10 @@ static int ath9k_hif_usb_suspend(struct usb_interface *interface,
  if (!(hif_dev->flags & HIF_USB_START))
   ath9k_htc_suspend(hif_dev->htc_handle);
 
- ath9k_hif_usb_dealloc_urbs(hif_dev);
+ wait_for_completion(&hif_dev->fw_done);
+
+ if (hif_dev->flags & HIF_USB_READY)
+  ath9k_hif_usb_dealloc_urbs(hif_dev);
 
  return 0;
 }
diff --git a/drivers/net/wireless/ath/ath9k/htc.h b/drivers/net/wireless/ath/ath9k/htc.h
index d3b099d..09a5d72 100644
--- a/drivers/net/wireless/ath/ath9k/htc.h
+++ b/drivers/net/wireless/ath/ath9k/htc.h
@@ -39,7 +39,6 @@
 #define ATH_RESTART_CALINTERVAL   1200000 /* 20 minutes */
 
 #define ATH_DEFAULT_BMISS_LIMIT 10
-#define IEEE80211_MS_TO_TU(x)   (((x) * 1000) / 1024)
 #define TSF_TO_TU(_h, _l) \
  ((((u32)(_h)) << 22) | (((u32)(_l)) >> 10))
 
@@ -142,6 +141,7 @@ struct ath9k_htc_target_aggr {
 #define WLAN_RC_40_FLAG  0x02
 #define WLAN_RC_SGI_FLAG 0x04
 #define WLAN_RC_HT_FLAG  0x08
+#define ATH_RC_TX_STBC_FLAG 0x20
 
 struct ath9k_htc_rateset {
  u8 rs_nrates;
@@ -208,6 +208,9 @@ struct ath9k_htc_target_rx_stats {
   case NL80211_IFTYPE_AP:  \
    _priv->num_ap_vif++; \
    break;   \
+  case NL80211_IFTYPE_MESH_POINT: \
+   _priv->num_mbss_vif++; \
+   break;   \
   default:   \
    break;   \
   }    \
@@ -224,6 +227,9 @@ struct ath9k_htc_target_rx_stats {
   case NL80211_IFTYPE_AP:  \
    _priv->num_ap_vif--; \
    break;   \
+  case NL80211_IFTYPE_MESH_POINT: \
+   _priv->num_mbss_vif--; \
+   break;   \
   default:   \
    break;   \
   }    \
@@ -255,6 +261,8 @@ enum tid_aggr_state {
 struct ath9k_htc_sta {
  u8 index;
  enum tid_aggr_state tid_state[ATH9K_HTC_MAX_TID];
+ struct work_struct rc_update_work;
+ struct ath9k_htc_priv *htc_priv;
 };
 
 #define ATH9K_HTC_RXBUF 256
@@ -268,7 +276,6 @@ struct ath9k_htc_rxbuf {
 };
 
 struct ath9k_htc_rx {
- int last_rssi; /* FIXME: per-STA */
  struct list_head rxbuf;
  spinlock_t rxbuflock;
 };
@@ -317,54 +324,61 @@ static inline struct ath9k_htc_tx_ctl *HTC_SKB_CB(struct sk_buff *skb)
 #ifdef CONFIG_ATH9K_HTC_DEBUGFS
 
 #define TX_STAT_INC(c) (hif_dev->htc_handle->drv_priv->debug.tx_stats.c++)
-#define RX_STAT_INC(c) (hif_dev->htc_handle->drv_priv->debug.rx_stats.c++)
+#define TX_STAT_ADD(c, a) (hif_dev->htc_handle->drv_priv->debug.tx_stats.c += a)
+#define RX_STAT_INC(c) (hif_dev->htc_handle->drv_priv->debug.skbrx_stats.c++)
+#define RX_STAT_ADD(c, a) (hif_dev->htc_handle->drv_priv->debug.skbrx_stats.c += a)
 #define CAB_STAT_INC   priv->debug.tx_stats.cab_queued++
 
 #define TX_QSTAT_INC(q) (priv->debug.tx_stats.queue_stats[q]++)
 
 void ath9k_htc_err_stat_rx(struct ath9k_htc_priv *priv,
-      struct ath_htc_rx_status *rxs);
+      struct ath_rx_status *rs);
 
 struct ath_tx_stats {
  u32 buf_queued;
  u32 buf_completed;
  u32 skb_queued;
  u32 skb_success;
+ u32 skb_success_bytes;
  u32 skb_failed;
  u32 cab_queued;
  u32 queue_stats[IEEE80211_NUM_ACS];
 };
 
-struct ath_rx_stats {
+struct ath_skbrx_stats {
  u32 skb_allocated;
  u32 skb_completed;
+ u32 skb_completed_bytes;
  u32 skb_dropped;
- u32 err_crc;
- u32 err_decrypt_crc;
- u32 err_mic;
- u32 err_pre_delim;
- u32 err_post_delim;
- u32 err_decrypt_busy;
- u32 err_phy;
- u32 err_phy_stats[ATH9K_PHYERR_MAX];
 };
 
 struct ath9k_debug {
  struct dentry *debugfs_phy;
  struct ath_tx_stats tx_stats;
  struct ath_rx_stats rx_stats;
+ struct ath_skbrx_stats skbrx_stats;
 };
 
+void ath9k_htc_get_et_strings(struct ieee80211_hw *hw,
+         struct ieee80211_vif *vif,
+         u32 sset, u8 *data);
+int ath9k_htc_get_et_sset_count(struct ieee80211_hw *hw,
+    struct ieee80211_vif *vif, int sset);
+void ath9k_htc_get_et_stats(struct ieee80211_hw *hw,
+       struct ieee80211_vif *vif,
+       struct ethtool_stats *stats, u64 *data);
 #else
 
 #define TX_STAT_INC(c) do { } while (0)
+#define TX_STAT_ADD(c, a) do { } while (0)
 #define RX_STAT_INC(c) do { } while (0)
+#define RX_STAT_ADD(c, a) do { } while (0)
 #define CAB_STAT_INC   do { } while (0)
 
 #define TX_QSTAT_INC(c) do { } while (0)
 
 static inline void ath9k_htc_err_stat_rx(struct ath9k_htc_priv *priv,
-      struct ath_htc_rx_status *rxs)
+      struct ath_rx_status *rs)
 {
 }
 
@@ -384,12 +398,18 @@ static inline void ath9k_htc_err_stat_rx(struct ath9k_htc_priv *priv,
 #define DEFAULT_SWBA_RESPONSE 40 /* in TUs */
 #define MIN_SWBA_RESPONSE     10 /* in TUs */
 
-struct htc_beacon_config {
+struct htc_beacon {
+ enum {
+  OK,  /* no change needed */
+  UPDATE,  /* update pending */
+  COMMIT  /* beacon sent, commit change */
+ } updateslot;  /* slot time update fsm */
+
  struct ieee80211_vif *bslot[ATH9K_HTC_MAX_BCN_VIF];
- u16 beacon_interval;
- u16 dtim_period;
- u16 bmiss_timeout;
- u32 bmiss_cnt;
+ u32 bmisscnt;
+ u32 beaconq;
+ int slottime;
+ int slotupdate;
 };
 
 struct ath_btcoex {
@@ -417,12 +437,8 @@ static inline void ath9k_htc_stop_btcoex(struct ath9k_htc_priv *priv)
 }
 #endif /* CONFIG_ATH9K_BTCOEX_SUPPORT */
 
-#define OP_INVALID     BIT(0)
-#define OP_SCANNING     BIT(1)
-#define OP_ENABLE_BEACON           BIT(2)
 #define OP_BT_PRIORITY_DETECTED    BIT(3)
 #define OP_BT_SCAN                 BIT(4)
-#define OP_ANI_RUNNING             BIT(5)
 #define OP_TSF_RESET               BIT(6)
 
 struct ath9k_htc_priv {
@@ -450,6 +466,7 @@ struct ath9k_htc_priv {
  u8 sta_slot;
  u8 vif_sta_pos[ATH9K_HTC_MAX_VIF];
  u8 num_ibss_vif;
+ u8 num_mbss_vif;
  u8 num_sta_vif;
  u8 num_sta_assoc_vif;
  u8 num_ap_vif;
@@ -464,10 +481,10 @@ struct ath9k_htc_priv {
  unsigned long op_flags;
 
  struct ath9k_hw_cal_data caldata;
- struct ieee80211_supported_band sbands[IEEE80211_NUM_BANDS];
 
  spinlock_t beacon_lock;
- struct htc_beacon_config cur_beacon_conf;
+ struct ath_beacon_config cur_beacon_conf;
+ struct htc_beacon beacon;
 
  struct ath9k_htc_rx rx;
  struct ath9k_htc_tx tx;
@@ -492,7 +509,6 @@ struct ath9k_htc_priv {
  struct work_struct led_work;
 #endif
 
- int beaconq;
  int cabq;
  int hwq_map[IEEE80211_NUM_ACS];
 
@@ -575,11 +591,18 @@ bool ath9k_htc_setpower(struct ath9k_htc_priv *priv,
 void ath9k_start_rfkill_poll(struct ath9k_htc_priv *priv);
 void ath9k_htc_rfkill_poll_state(struct ieee80211_hw *hw);
 
+struct base_eep_header *ath9k_htc_get_eeprom_base(struct ath9k_htc_priv *priv);
+
 #ifdef CONFIG_MAC80211_LEDS
+void ath9k_configure_leds(struct ath9k_htc_priv *priv);
 void ath9k_init_leds(struct ath9k_htc_priv *priv);
 void ath9k_deinit_leds(struct ath9k_htc_priv *priv);
 void ath9k_led_work(struct work_struct *work);
 #else
+static inline void ath9k_configure_leds(struct ath9k_htc_priv *priv)
+{
+}
+
 static inline void ath9k_init_leds(struct ath9k_htc_priv *priv)
 {
 }
diff --git a/drivers/net/wireless/ath/ath9k/htc_drv_beacon.c b/drivers/net/wireless/ath/ath9k/htc_drv_beacon.c
index f13f458..e8b6ec3 100644
--- a/drivers/net/wireless/ath/ath9k/htc_drv_beacon.c
+++ b/drivers/net/wireless/ath/ath9k/htc_drv_beacon.c
@@ -26,9 +26,10 @@ void ath9k_htc_beaconq_config(struct ath9k_htc_priv *priv)
  memset(&qi, 0, sizeof(struct ath9k_tx_queue_info));
  memset(&qi_be, 0, sizeof(struct ath9k_tx_queue_info));
 
- ath9k_hw_get_txq_props(ah, priv->beaconq, &qi);
+ ath9k_hw_get_txq_props(ah, priv->beacon.beaconq, &qi);
 
- if (priv->ah->opmode == NL80211_IFTYPE_AP) {
+ if (priv->ah->opmode == NL80211_IFTYPE_AP ||
+     priv->ah->opmode == NL80211_IFTYPE_MESH_POINT) {
   qi.tqi_aifs = 1;
   qi.tqi_cwmin = 0;
   qi.tqi_cwmax = 0;
@@ -53,235 +54,78 @@ void ath9k_htc_beaconq_config(struct ath9k_htc_priv *priv)
 
  }
 
- if (!ath9k_hw_set_txq_props(ah, priv->beaconq, &qi)) {
+ if (!ath9k_hw_set_txq_props(ah, priv->beacon.beaconq, &qi)) {
   ath_err(ath9k_hw_common(ah),
-   "Unable to update beacon queue %u!\n", priv->beaconq);
+   "Unable to update beacon queue %u!\n", priv->beacon.beaconq);
  } else {
-  ath9k_hw_resettxqueue(ah, priv->beaconq);
+  ath9k_hw_resettxqueue(ah, priv->beacon.beaconq);
  }
 }
 
-
-static void ath9k_htc_beacon_config_sta(struct ath9k_htc_priv *priv,
-     struct htc_beacon_config *bss_conf)
+/*
+ * Both nexttbtt and intval have to be in usecs.
+ */
+static void ath9k_htc_beacon_init(struct ath9k_htc_priv *priv,
+      struct ath_beacon_config *conf,
+      bool reset_tsf)
 {
- struct ath_common *common = ath9k_hw_common(priv->ah);
- struct ath9k_beacon_state bs;
- enum ath9k_int imask = 0;
- int dtimperiod, dtimcount, sleepduration;
- int cfpperiod, cfpcount, bmiss_timeout;
- u32 nexttbtt = 0, intval, tsftu;
- __be32 htc_imask = 0;
- u64 tsf;
- int num_beacons, offset, dtim_dec_count, cfp_dec_count;
+ struct ath_hw *ah = priv->ah;
  int ret __attribute__ ((unused));
+ __be32 htc_imask = 0;
  u8 cmd_rsp;
 
- memset(&bs, 0, sizeof(bs));
-
- intval = bss_conf->beacon_interval;
- bmiss_timeout = (ATH_DEFAULT_BMISS_LIMIT * bss_conf->beacon_interval);
-
- /*
-  * Setup dtim and cfp parameters according to
-  * last beacon we received (which may be none).
-  */
- dtimperiod = bss_conf->dtim_period;
- if (dtimperiod <= 0)  /* NB: 0 if not known */
-  dtimperiod = 1;
- dtimcount = 1;
- if (dtimcount >= dtimperiod) /* NB: sanity check */
-  dtimcount = 0;
- cfpperiod = 1;   /* NB: no PCF support yet */
- cfpcount = 0;
-
- sleepduration = intval;
- if (sleepduration <= 0)
-  sleepduration = intval;
-
- /*
-  * Pull nexttbtt forward to reflect the current
-  * TSF and calculate dtim+cfp state for the result.
-  */
- tsf = ath9k_hw_gettsf64(priv->ah);
- tsftu = TSF_TO_TU(tsf>>32, tsf) + FUDGE;
-
- num_beacons = tsftu / intval + 1;
- offset = tsftu % intval;
- nexttbtt = tsftu - offset;
- if (offset)
-  nexttbtt += intval;
-
- /* DTIM Beacon every dtimperiod Beacon */
- dtim_dec_count = num_beacons % dtimperiod;
- /* CFP every cfpperiod DTIM Beacon */
- cfp_dec_count = (num_beacons / dtimperiod) % cfpperiod;
- if (dtim_dec_count)
-  cfp_dec_count++;
-
- dtimcount -= dtim_dec_count;
- if (dtimcount < 0)
-  dtimcount += dtimperiod;
-
- cfpcount -= cfp_dec_count;
- if (cfpcount < 0)
-  cfpcount += cfpperiod;
-
- bs.bs_intval = intval;
- bs.bs_nexttbtt = nexttbtt;
- bs.bs_dtimperiod = dtimperiod*intval;
- bs.bs_nextdtim = bs.bs_nexttbtt + dtimcount*intval;
- bs.bs_cfpperiod = cfpperiod*bs.bs_dtimperiod;
- bs.bs_cfpnext = bs.bs_nextdtim + cfpcount*bs.bs_dtimperiod;
- bs.bs_cfpmaxduration = 0;
-
- /*
-  * Calculate the number of consecutive beacons to miss* before taking
-  * a BMISS interrupt. The configuration is specified in TU so we only
-  * need calculate based on the beacon interval.  Note that we clamp the
-  * result to at most 15 beacons.
-  */
- if (sleepduration > intval) {
-  bs.bs_bmissthreshold = ATH_DEFAULT_BMISS_LIMIT / 2;
- } else {
-  bs.bs_bmissthreshold = DIV_ROUND_UP(bmiss_timeout, intval);
-  if (bs.bs_bmissthreshold > 15)
-   bs.bs_bmissthreshold = 15;
-  else if (bs.bs_bmissthreshold <= 0)
-   bs.bs_bmissthreshold = 1;
- }
-
- /*
-  * Calculate sleep duration. The configuration is given in ms.
-  * We ensure a multiple of the beacon period is used. Also, if the sleep
-  * duration is greater than the DTIM period then it makes senses
-  * to make it a multiple of that.
-  *
-  * XXX fixed at 100ms
-  */
-
- bs.bs_sleepduration = roundup(IEEE80211_MS_TO_TU(100), sleepduration);
- if (bs.bs_sleepduration > bs.bs_dtimperiod)
-  bs.bs_sleepduration = bs.bs_dtimperiod;
-
- /* TSF out of range threshold fixed at 1 second */
- bs.bs_tsfoor_threshold = ATH9K_TSFOOR_THRESHOLD;
-
- ath_dbg(common, CONFIG, "intval: %u tsf: %llu tsftu: %u\n",
-  intval, tsf, tsftu);
- ath_dbg(common, CONFIG,
-  "bmiss: %u sleep: %u cfp-period: %u maxdur: %u next: %u\n",
-  bs.bs_bmissthreshold, bs.bs_sleepduration,
-  bs.bs_cfpperiod, bs.bs_cfpmaxduration, bs.bs_cfpnext);
-
- /* Set the computed STA beacon timers */
+ if (conf->intval >= TU_TO_USEC(DEFAULT_SWBA_RESPONSE))
+  ah->config.sw_beacon_response_time = DEFAULT_SWBA_RESPONSE;
+ else
+  ah->config.sw_beacon_response_time = MIN_SWBA_RESPONSE;
 
  WMI_CMD(WMI_DISABLE_INTR_CMDID);
- ath9k_hw_set_sta_beacon_timers(priv->ah, &bs);
- imask |= ATH9K_INT_BMISS;
- htc_imask = cpu_to_be32(imask);
+ if (reset_tsf)
+  ath9k_hw_reset_tsf(ah);
+ ath9k_htc_beaconq_config(priv);
+ ath9k_hw_beaconinit(ah, conf->nexttbtt, conf->intval);
+ priv->beacon.bmisscnt = 0;
+ htc_imask = cpu_to_be32(ah->imask);
  WMI_CMD_BUF(WMI_ENABLE_INTR_CMDID, &htc_imask);
 }
 
-static void ath9k_htc_beacon_config_ap(struct ath9k_htc_priv *priv,
-           struct htc_beacon_config *bss_conf)
+static void ath9k_htc_beacon_config_sta(struct ath9k_htc_priv *priv,
+     struct ath_beacon_config *bss_conf)
 {
- struct ath_common *common = ath9k_hw_common(priv->ah);
+ struct ath9k_beacon_state bs;
  enum ath9k_int imask = 0;
- u32 nexttbtt, intval, tsftu;
  __be32 htc_imask = 0;
  int ret __attribute__ ((unused));
  u8 cmd_rsp;
- u64 tsf;
 
- intval = bss_conf->beacon_interval;
- intval /= ATH9K_HTC_MAX_BCN_VIF;
- nexttbtt = intval;
-
- /*
-  * To reduce beacon misses under heavy TX load,
-  * set the beacon response time to a larger value.
-  */
- if (intval > DEFAULT_SWBA_RESPONSE)
-  priv->ah->config.sw_beacon_response_time = DEFAULT_SWBA_RESPONSE;
- else
-  priv->ah->config.sw_beacon_response_time = MIN_SWBA_RESPONSE;
-
- if (test_bit(OP_TSF_RESET, &priv->op_flags)) {
-  ath9k_hw_reset_tsf(priv->ah);
-  clear_bit(OP_TSF_RESET, &priv->op_flags);
- } else {
-  /*
-   * Pull nexttbtt forward to reflect the current TSF.
-   */
-  tsf = ath9k_hw_gettsf64(priv->ah);
-  tsftu = TSF_TO_TU(tsf >> 32, tsf) + FUDGE;
-  do {
-   nexttbtt += intval;
-  } while (nexttbtt < tsftu);
- }
-
- if (test_bit(OP_ENABLE_BEACON, &priv->op_flags))
-  imask |= ATH9K_INT_SWBA;
-
- ath_dbg(common, CONFIG,
-  "AP Beacon config, intval: %d, nexttbtt: %u, resp_time: %d imask: 0x%x\n",
-  bss_conf->beacon_interval, nexttbtt,
-  priv->ah->config.sw_beacon_response_time, imask);
-
- ath9k_htc_beaconq_config(priv);
+ if (ath9k_cmn_beacon_config_sta(priv->ah, bss_conf, &bs) == -EPERM)
+  return;
 
  WMI_CMD(WMI_DISABLE_INTR_CMDID);
- ath9k_hw_beaconinit(priv->ah, TU_TO_USEC(nexttbtt), TU_TO_USEC(intval));
- priv->cur_beacon_conf.bmiss_cnt = 0;
+ ath9k_hw_set_sta_beacon_timers(priv->ah, &bs);
+ imask |= ATH9K_INT_BMISS;
  htc_imask = cpu_to_be32(imask);
  WMI_CMD_BUF(WMI_ENABLE_INTR_CMDID, &htc_imask);
 }
 
-static void ath9k_htc_beacon_config_adhoc(struct ath9k_htc_priv *priv,
-       struct htc_beacon_config *bss_conf)
+static void ath9k_htc_beacon_config_ap(struct ath9k_htc_priv *priv,
+           struct ath_beacon_config *conf)
 {
- struct ath_common *common = ath9k_hw_common(priv->ah);
- enum ath9k_int imask = 0;
- u32 nexttbtt, intval, tsftu;
- __be32 htc_imask = 0;
- int ret __attribute__ ((unused));
- u8 cmd_rsp;
- u64 tsf;
-
- intval = bss_conf->beacon_interval;
- nexttbtt = intval;
-
- /*
-  * Pull nexttbtt forward to reflect the current TSF.
-  */
- tsf = ath9k_hw_gettsf64(priv->ah);
- tsftu = TSF_TO_TU(tsf >> 32, tsf) + FUDGE;
- do {
-  nexttbtt += intval;
- } while (nexttbtt < tsftu);
-
- /*
-  * Only one IBSS interfce is allowed.
-  */
- if (intval > DEFAULT_SWBA_RESPONSE)
-  priv->ah->config.sw_beacon_response_time = DEFAULT_SWBA_RESPONSE;
- else
-  priv->ah->config.sw_beacon_response_time = MIN_SWBA_RESPONSE;
+ struct ath_hw *ah = priv->ah;
+ ah->imask = 0;
 
- if (test_bit(OP_ENABLE_BEACON, &priv->op_flags))
-  imask |= ATH9K_INT_SWBA;
+ ath9k_cmn_beacon_config_ap(ah, conf, ATH9K_HTC_MAX_BCN_VIF);
+ ath9k_htc_beacon_init(priv, conf, false);
+}
 
- ath_dbg(common, CONFIG,
-  "IBSS Beacon config, intval: %d, nexttbtt: %u, resp_time: %d, imask: 0x%x\n",
-  bss_conf->beacon_interval, nexttbtt,
-  priv->ah->config.sw_beacon_response_time, imask);
+static void ath9k_htc_beacon_config_adhoc(struct ath9k_htc_priv *priv,
+       struct ath_beacon_config *conf)
+{
+ struct ath_hw *ah = priv->ah;
+ ah->imask = 0;
 
- WMI_CMD(WMI_DISABLE_INTR_CMDID);
- ath9k_hw_beaconinit(priv->ah, TU_TO_USEC(nexttbtt), TU_TO_USEC(intval));
- priv->cur_beacon_conf.bmiss_cnt = 0;
- htc_imask = cpu_to_be32(imask);
- WMI_CMD_BUF(WMI_ENABLE_INTR_CMDID, &htc_imask);
+ ath9k_cmn_beacon_config_adhoc(ah, conf);
+ ath9k_htc_beacon_init(priv, conf, conf->ibss_creator);
 }
 
 void ath9k_htc_beaconep(void *drv_priv, struct sk_buff *skb,
@@ -301,7 +145,7 @@ static void ath9k_htc_send_buffered(struct ath9k_htc_priv *priv,
 
  spin_lock_bh(&priv->beacon_lock);
 
- vif = priv->cur_beacon_conf.bslot[slot];
+ vif = priv->beacon.bslot[slot];
 
  skb = ieee80211_get_buffered_bc(priv->hw, vif);
 
@@ -362,10 +206,10 @@ static void ath9k_htc_send_beacon(struct ath9k_htc_priv *priv,
 
  spin_lock_bh(&priv->beacon_lock);
 
- vif = priv->cur_beacon_conf.bslot[slot];
+ vif = priv->beacon.bslot[slot];
  avp = (struct ath9k_htc_vif *)vif->drv_priv;
 
- if (unlikely(test_bit(OP_SCANNING, &priv->op_flags))) {
+ if (unlikely(test_bit(ATH_OP_SCANNING, &common->op_flags))) {
   spin_unlock_bh(&priv->beacon_lock);
   return;
  }
@@ -445,8 +289,8 @@ void ath9k_htc_swba(struct ath9k_htc_priv *priv,
  int slot;
 
  if (swba->beacon_pending != 0) {
-  priv->cur_beacon_conf.bmiss_cnt++;
-  if (priv->cur_beacon_conf.bmiss_cnt > BSTUCK_THRESHOLD) {
+  priv->beacon.bmisscnt++;
+  if (priv->beacon.bmisscnt > BSTUCK_THRESHOLD) {
    ath_dbg(common, BSTUCK, "Beacon stuck, HW reset\n");
    ieee80211_queue_work(priv->hw,
           &priv->fatal_work);
@@ -454,16 +298,16 @@ void ath9k_htc_swba(struct ath9k_htc_priv *priv,
   return;
  }
 
- if (priv->cur_beacon_conf.bmiss_cnt) {
+ if (priv->beacon.bmisscnt) {
   ath_dbg(common, BSTUCK,
    "Resuming beacon xmit after %u misses\n",
-   priv->cur_beacon_conf.bmiss_cnt);
-  priv->cur_beacon_conf.bmiss_cnt = 0;
+   priv->beacon.bmisscnt);
+  priv->beacon.bmisscnt = 0;
  }
 
  slot = ath9k_htc_choose_bslot(priv, swba);
  spin_lock_bh(&priv->beacon_lock);
- if (priv->cur_beacon_conf.bslot[slot] == NULL) {
+ if (priv->beacon.bslot[slot] == NULL) {
   spin_unlock_bh(&priv->beacon_lock);
   return;
  }
@@ -482,13 +326,13 @@ void ath9k_htc_assign_bslot(struct ath9k_htc_priv *priv,
 
  spin_lock_bh(&priv->beacon_lock);
  for (i = 0; i < ATH9K_HTC_MAX_BCN_VIF; i++) {
-  if (priv->cur_beacon_conf.bslot[i] == NULL) {
+  if (priv->beacon.bslot[i] == NULL) {
    avp->bslot = i;
    break;
   }
  }
 
- priv->cur_beacon_conf.bslot[avp->bslot] = vif;
+ priv->beacon.bslot[avp->bslot] = vif;
  spin_unlock_bh(&priv->beacon_lock);
 
  ath_dbg(common, CONFIG, "Added interface at beacon slot: %d\n",
@@ -502,7 +346,7 @@ void ath9k_htc_remove_bslot(struct ath9k_htc_priv *priv,
  struct ath9k_htc_vif *avp = (struct ath9k_htc_vif *)vif->drv_priv;
 
  spin_lock_bh(&priv->beacon_lock);
- priv->cur_beacon_conf.bslot[avp->bslot] = NULL;
+ priv->beacon.bslot[avp->bslot] = NULL;
  spin_unlock_bh(&priv->beacon_lock);
 
  ath_dbg(common, CONFIG, "Removed interface at beacon slot: %d\n",
@@ -518,7 +362,7 @@ void ath9k_htc_set_tsfadjust(struct ath9k_htc_priv *priv,
 {
  struct ath_common *common = ath9k_hw_common(priv->ah);
  struct ath9k_htc_vif *avp = (struct ath9k_htc_vif *)vif->drv_priv;
- struct htc_beacon_config *cur_conf = &priv->cur_beacon_conf;
+ struct ath_beacon_config *cur_conf = &priv->cur_beacon_conf;
  u64 tsfadjust;
 
  if (avp->bslot == 0)
@@ -550,7 +394,7 @@ static bool ath9k_htc_check_beacon_config(struct ath9k_htc_priv *priv,
        struct ieee80211_vif *vif)
 {
  struct ath_common *common = ath9k_hw_common(priv->ah);
- struct htc_beacon_config *cur_conf = &priv->cur_beacon_conf;
+ struct ath_beacon_config *cur_conf = &priv->cur_beacon_conf;
  struct ieee80211_bss_conf *bss_conf = &vif->bss_conf;
  bool beacon_configured;
 
@@ -605,7 +449,7 @@ void ath9k_htc_beacon_config(struct ath9k_htc_priv *priv,
         struct ieee80211_vif *vif)
 {
  struct ath_common *common = ath9k_hw_common(priv->ah);
- struct htc_beacon_config *cur_conf = &priv->cur_beacon_conf;
+ struct ath_beacon_config *cur_conf = &priv->cur_beacon_conf;
  struct ieee80211_bss_conf *bss_conf = &vif->bss_conf;
  struct ath9k_htc_vif *avp = (struct ath9k_htc_vif *) vif->drv_priv;
 
@@ -628,6 +472,7 @@ void ath9k_htc_beacon_config(struct ath9k_htc_priv *priv,
  case NL80211_IFTYPE_ADHOC:
   ath9k_htc_beacon_config_adhoc(priv, cur_conf);
   break;
+ case NL80211_IFTYPE_MESH_POINT:
  case NL80211_IFTYPE_AP:
   ath9k_htc_beacon_config_ap(priv, cur_conf);
   break;
@@ -640,7 +485,7 @@ void ath9k_htc_beacon_config(struct ath9k_htc_priv *priv,
 void ath9k_htc_beacon_reconfig(struct ath9k_htc_priv *priv)
 {
  struct ath_common *common = ath9k_hw_common(priv->ah);
- struct htc_beacon_config *cur_conf = &priv->cur_beacon_conf;
+ struct ath_beacon_config *cur_conf = &priv->cur_beacon_conf;
 
  switch (priv->ah->opmode) {
  case NL80211_IFTYPE_STATION:
@@ -649,6 +494,7 @@ void ath9k_htc_beacon_reconfig(struct ath9k_htc_priv *priv)
  case NL80211_IFTYPE_ADHOC:
   ath9k_htc_beacon_config_adhoc(priv, cur_conf);
   break;
+ case NL80211_IFTYPE_MESH_POINT:
  case NL80211_IFTYPE_AP:
   ath9k_htc_beacon_config_ap(priv, cur_conf);
   break;
diff --git a/drivers/net/wireless/ath/ath9k/htc_drv_debug.c b/drivers/net/wireless/ath/ath9k/htc_drv_debug.c
index 87110de..8b529e4 100644
--- a/drivers/net/wireless/ath/ath9k/htc_drv_debug.c
+++ b/drivers/net/wireless/ath/ath9k/htc_drv_debug.c
@@ -37,29 +37,29 @@ static ssize_t read_file_tgt_int_stats(struct file *file, char __user *user_buf,
 
  ath9k_htc_ps_restore(priv);
 
- len += snprintf(buf + len, sizeof(buf) - len,
-   "%20s : %10u\n", "RX",
-   be32_to_cpu(cmd_rsp.rx));
+ len += scnprintf(buf + len, sizeof(buf) - len,
+    "%20s : %10u\n", "RX",
+    be32_to_cpu(cmd_rsp.rx));
 
- len += snprintf(buf + len, sizeof(buf) - len,
-   "%20s : %10u\n", "RXORN",
-   be32_to_cpu(cmd_rsp.rxorn));
+ len += scnprintf(buf + len, sizeof(buf) - len,
+    "%20s : %10u\n", "RXORN",
+    be32_to_cpu(cmd_rsp.rxorn));
 
- len += snprintf(buf + len, sizeof(buf) - len,
-   "%20s : %10u\n", "RXEOL",
-   be32_to_cpu(cmd_rsp.rxeol));
+ len += scnprintf(buf + len, sizeof(buf) - len,
+    "%20s : %10u\n", "RXEOL",
+    be32_to_cpu(cmd_rsp.rxeol));
 
- len += snprintf(buf + len, sizeof(buf) - len,
-   "%20s : %10u\n", "TXURN",
-   be32_to_cpu(cmd_rsp.txurn));
+ len += scnprintf(buf + len, sizeof(buf) - len,
+    "%20s : %10u\n", "TXURN",
+    be32_to_cpu(cmd_rsp.txurn));
 
- len += snprintf(buf + len, sizeof(buf) - len,
-   "%20s : %10u\n", "TXTO",
-   be32_to_cpu(cmd_rsp.txto));
+ len += scnprintf(buf + len, sizeof(buf) - len,
+    "%20s : %10u\n", "TXTO",
+    be32_to_cpu(cmd_rsp.txto));
 
- len += snprintf(buf + len, sizeof(buf) - len,
-   "%20s : %10u\n", "CST",
-   be32_to_cpu(cmd_rsp.cst));
+ len += scnprintf(buf + len, sizeof(buf) - len,
+    "%20s : %10u\n", "CST",
+    be32_to_cpu(cmd_rsp.cst));
 
  if (len > sizeof(buf))
   len = sizeof(buf);
@@ -95,41 +95,41 @@ static ssize_t read_file_tgt_tx_stats(struct file *file, char __user *user_buf,
 
  ath9k_htc_ps_restore(priv);
 
- len += snprintf(buf + len, sizeof(buf) - len,
-   "%20s : %10u\n", "Xretries",
-   be32_to_cpu(cmd_rsp.xretries));
+ len += scnprintf(buf + len, sizeof(buf) - len,
+    "%20s : %10u\n", "Xretries",
+    be32_to_cpu(cmd_rsp.xretries));
 
- len += snprintf(buf + len, sizeof(buf) - len,
-   "%20s : %10u\n", "FifoErr",
-   be32_to_cpu(cmd_rsp.fifoerr));
+ len += scnprintf(buf + len, sizeof(buf) - len,
+    "%20s : %10u\n", "FifoErr",
+    be32_to_cpu(cmd_rsp.fifoerr));
 
- len += snprintf(buf + len, sizeof(buf) - len,
-   "%20s : %10u\n", "Filtered",
-   be32_to_cpu(cmd_rsp.filtered));
+ len += scnprintf(buf + len, sizeof(buf) - len,
+    "%20s : %10u\n", "Filtered",
+    be32_to_cpu(cmd_rsp.filtered));
 
- len += snprintf(buf + len, sizeof(buf) - len,
-   "%20s : %10u\n", "TimerExp",
-   be32_to_cpu(cmd_rsp.timer_exp));
+ len += scnprintf(buf + len, sizeof(buf) - len,
+    "%20s : %10u\n", "TimerExp",
+    be32_to_cpu(cmd_rsp.timer_exp));
 
- len += snprintf(buf + len, sizeof(buf) - len,
-   "%20s : %10u\n", "ShortRetries",
-   be32_to_cpu(cmd_rsp.shortretries));
+ len += scnprintf(buf + len, sizeof(buf) - len,
+    "%20s : %10u\n", "ShortRetries",
+    be32_to_cpu(cmd_rsp.shortretries));
 
- len += snprintf(buf + len, sizeof(buf) - len,
-   "%20s : %10u\n", "LongRetries",
-   be32_to_cpu(cmd_rsp.longretries));
+ len += scnprintf(buf + len, sizeof(buf) - len,
+    "%20s : %10u\n", "LongRetries",
+    be32_to_cpu(cmd_rsp.longretries));
 
- len += snprintf(buf + len, sizeof(buf) - len,
-   "%20s : %10u\n", "QueueNull",
-   be32_to_cpu(cmd_rsp.qnull));
+ len += scnprintf(buf + len, sizeof(buf) - len,
+    "%20s : %10u\n", "QueueNull",
+    be32_to_cpu(cmd_rsp.qnull));
 
- len += snprintf(buf + len, sizeof(buf) - len,
-   "%20s : %10u\n", "EncapFail",
-   be32_to_cpu(cmd_rsp.encap_fail));
+ len += scnprintf(buf + len, sizeof(buf) - len,
+    "%20s : %10u\n", "EncapFail",
+    be32_to_cpu(cmd_rsp.encap_fail));
 
- len += snprintf(buf + len, sizeof(buf) - len,
-   "%20s : %10u\n", "NoBuf",
-   be32_to_cpu(cmd_rsp.nobuf));
+ len += scnprintf(buf + len, sizeof(buf) - len,
+    "%20s : %10u\n", "NoBuf",
+    be32_to_cpu(cmd_rsp.nobuf));
 
  if (len > sizeof(buf))
   len = sizeof(buf);
@@ -165,17 +165,17 @@ static ssize_t read_file_tgt_rx_stats(struct file *file, char __user *user_buf,
 
  ath9k_htc_ps_restore(priv);
 
- len += snprintf(buf + len, sizeof(buf) - len,
-   "%20s : %10u\n", "NoBuf",
-   be32_to_cpu(cmd_rsp.nobuf));
+ len += scnprintf(buf + len, sizeof(buf) - len,
+    "%20s : %10u\n", "NoBuf",
+    be32_to_cpu(cmd_rsp.nobuf));
 
- len += snprintf(buf + len, sizeof(buf) - len,
-   "%20s : %10u\n", "HostSend",
-   be32_to_cpu(cmd_rsp.host_send));
+ len += scnprintf(buf + len, sizeof(buf) - len,
+    "%20s : %10u\n", "HostSend",
+    be32_to_cpu(cmd_rsp.host_send));
 
- len += snprintf(buf + len, sizeof(buf) - len,
-   "%20s : %10u\n", "HostDone",
-   be32_to_cpu(cmd_rsp.host_done));
+ len += scnprintf(buf + len, sizeof(buf) - len,
+    "%20s : %10u\n", "HostDone",
+    be32_to_cpu(cmd_rsp.host_done));
 
  if (len > sizeof(buf))
   len = sizeof(buf);
@@ -197,37 +197,37 @@ static ssize_t read_file_xmit(struct file *file, char __user *user_buf,
  char buf[512];
  unsigned int len = 0;
 
- len += snprintf(buf + len, sizeof(buf) - len,
-   "%20s : %10u\n", "Buffers queued",
-   priv->debug.tx_stats.buf_queued);
- len += snprintf(buf + len, sizeof(buf) - len,
-   "%20s : %10u\n", "Buffers completed",
-   priv->debug.tx_stats.buf_completed);
- len += snprintf(buf + len, sizeof(buf) - len,
-   "%20s : %10u\n", "SKBs queued",
-   priv->debug.tx_stats.skb_queued);
- len += snprintf(buf + len, sizeof(buf) - len,
-   "%20s : %10u\n", "SKBs success",
-   priv->debug.tx_stats.skb_success);
- len += snprintf(buf + len, sizeof(buf) - len,
-   "%20s : %10u\n", "SKBs failed",
-   priv->debug.tx_stats.skb_failed);
- len += snprintf(buf + len, sizeof(buf) - len,
-   "%20s : %10u\n", "CAB queued",
-   priv->debug.tx_stats.cab_queued);
-
- len += snprintf(buf + len, sizeof(buf) - len,
-   "%20s : %10u\n", "BE queued",
-   priv->debug.tx_stats.queue_stats[IEEE80211_AC_BE]);
- len += snprintf(buf + len, sizeof(buf) - len,
-   "%20s : %10u\n", "BK queued",
-   priv->debug.tx_stats.queue_stats[IEEE80211_AC_BK]);
- len += snprintf(buf + len, sizeof(buf) - len,
-   "%20s : %10u\n", "VI queued",
-   priv->debug.tx_stats.queue_stats[IEEE80211_AC_VI]);
- len += snprintf(buf + len, sizeof(buf) - len,
-   "%20s : %10u\n", "VO queued",
-   priv->debug.tx_stats.queue_stats[IEEE80211_AC_VO]);
+ len += scnprintf(buf + len, sizeof(buf) - len,
+    "%20s : %10u\n", "Buffers queued",
+    priv->debug.tx_stats.buf_queued);
+ len += scnprintf(buf + len, sizeof(buf) - len,
+    "%20s : %10u\n", "Buffers completed",
+    priv->debug.tx_stats.buf_completed);
+ len += scnprintf(buf + len, sizeof(buf) - len,
+    "%20s : %10u\n", "SKBs queued",
+    priv->debug.tx_stats.skb_queued);
+ len += scnprintf(buf + len, sizeof(buf) - len,
+    "%20s : %10u\n", "SKBs success",
+    priv->debug.tx_stats.skb_success);
+ len += scnprintf(buf + len, sizeof(buf) - len,
+    "%20s : %10u\n", "SKBs failed",
+    priv->debug.tx_stats.skb_failed);
+ len += scnprintf(buf + len, sizeof(buf) - len,
+    "%20s : %10u\n", "CAB queued",
+    priv->debug.tx_stats.cab_queued);
+
+ len += scnprintf(buf + len, sizeof(buf) - len,
+    "%20s : %10u\n", "BE queued",
+    priv->debug.tx_stats.queue_stats[IEEE80211_AC_BE]);
+ len += scnprintf(buf + len, sizeof(buf) - len,
+    "%20s : %10u\n", "BK queued",
+    priv->debug.tx_stats.queue_stats[IEEE80211_AC_BK]);
+ len += scnprintf(buf + len, sizeof(buf) - len,
+    "%20s : %10u\n", "VI queued",
+    priv->debug.tx_stats.queue_stats[IEEE80211_AC_VI]);
+ len += scnprintf(buf + len, sizeof(buf) - len,
+    "%20s : %10u\n", "VO queued",
+    priv->debug.tx_stats.queue_stats[IEEE80211_AC_VO]);
 
  if (len > sizeof(buf))
   len = sizeof(buf);
@@ -243,39 +243,14 @@ static const struct file_operations fops_xmit = {
 };
 
 void ath9k_htc_err_stat_rx(struct ath9k_htc_priv *priv,
-      struct ath_htc_rx_status *rxs)
+        struct ath_rx_status *rs)
 {
-#define RX_PHY_ERR_INC(c) priv->debug.rx_stats.err_phy_stats[c]++
-
- if (rxs->rs_status & ATH9K_RXERR_CRC)
-  priv->debug.rx_stats.err_crc++;
- if (rxs->rs_status & ATH9K_RXERR_DECRYPT)
-  priv->debug.rx_stats.err_decrypt_crc++;
- if (rxs->rs_status & ATH9K_RXERR_MIC)
-  priv->debug.rx_stats.err_mic++;
- if (rxs->rs_status & ATH9K_RX_DELIM_CRC_PRE)
-  priv->debug.rx_stats.err_pre_delim++;
- if (rxs->rs_status & ATH9K_RX_DELIM_CRC_POST)
-  priv->debug.rx_stats.err_post_delim++;
- if (rxs->rs_status & ATH9K_RX_DECRYPT_BUSY)
-  priv->debug.rx_stats.err_decrypt_busy++;
-
- if (rxs->rs_status & ATH9K_RXERR_PHY) {
-  priv->debug.rx_stats.err_phy++;
-  if (rxs->rs_phyerr < ATH9K_PHYERR_MAX)
-   RX_PHY_ERR_INC(rxs->rs_phyerr);
- }
-
-#undef RX_PHY_ERR_INC
+ ath9k_cmn_debug_stat_rx(&priv->debug.rx_stats, rs);
 }
 
-static ssize_t read_file_recv(struct file *file, char __user *user_buf,
+static ssize_t read_file_skb_rx(struct file *file, char __user *user_buf,
          size_t count, loff_t *ppos)
 {
-#define PHY_ERR(s, p)       \
- len += snprintf(buf + len, size - len, "%20s : %10u\n", s, \
-   priv->debug.rx_stats.err_phy_stats[p]);
-
  struct ath9k_htc_priv *priv = file->private_data;
  char *buf;
  unsigned int len = 0, size = 1500;
@@ -285,65 +260,15 @@ static ssize_t read_file_recv(struct file *file, char __user *user_buf,
  if (buf == NULL)
   return -ENOMEM;
 
- len += snprintf(buf + len, size - len,
-   "%20s : %10u\n", "SKBs allocated",
-   priv->debug.rx_stats.skb_allocated);
- len += snprintf(buf + len, size - len,
-   "%20s : %10u\n", "SKBs completed",
-   priv->debug.rx_stats.skb_completed);
- len += snprintf(buf + len, size - len,
-   "%20s : %10u\n", "SKBs Dropped",
-   priv->debug.rx_stats.skb_dropped);
-
- len += snprintf(buf + len, size - len,
-   "%20s : %10u\n", "CRC ERR",
-   priv->debug.rx_stats.err_crc);
- len += snprintf(buf + len, size - len,
-   "%20s : %10u\n", "DECRYPT CRC ERR",
-   priv->debug.rx_stats.err_decrypt_crc);
- len += snprintf(buf + len, size - len,
-   "%20s : %10u\n", "MIC ERR",
-   priv->debug.rx_stats.err_mic);
- len += snprintf(buf + len, size - len,
-   "%20s : %10u\n", "PRE-DELIM CRC ERR",
-   priv->debug.rx_stats.err_pre_delim);
- len += snprintf(buf + len, size - len,
-   "%20s : %10u\n", "POST-DELIM CRC ERR",
-   priv->debug.rx_stats.err_post_delim);
- len += snprintf(buf + len, size - len,
-   "%20s : %10u\n", "DECRYPT BUSY ERR",
-   priv->debug.rx_stats.err_decrypt_busy);
- len += snprintf(buf + len, size - len,
-   "%20s : %10u\n", "TOTAL PHY ERR",
-   priv->debug.rx_stats.err_phy);
-
-
- PHY_ERR("UNDERRUN", ATH9K_PHYERR_UNDERRUN);
- PHY_ERR("TIMING", ATH9K_PHYERR_TIMING);
- PHY_ERR("PARITY", ATH9K_PHYERR_PARITY);
- PHY_ERR("RATE", ATH9K_PHYERR_RATE);
- PHY_ERR("LENGTH", ATH9K_PHYERR_LENGTH);
- PHY_ERR("RADAR", ATH9K_PHYERR_RADAR);
- PHY_ERR("SERVICE", ATH9K_PHYERR_SERVICE);
- PHY_ERR("TOR", ATH9K_PHYERR_TOR);
- PHY_ERR("OFDM-TIMING", ATH9K_PHYERR_OFDM_TIMING);
- PHY_ERR("OFDM-SIGNAL-PARITY", ATH9K_PHYERR_OFDM_SIGNAL_PARITY);
- PHY_ERR("OFDM-RATE", ATH9K_PHYERR_OFDM_RATE_ILLEGAL);
- PHY_ERR("OFDM-LENGTH", ATH9K_PHYERR_OFDM_LENGTH_ILLEGAL);
- PHY_ERR("OFDM-POWER-DROP", ATH9K_PHYERR_OFDM_POWER_DROP);
- PHY_ERR("OFDM-SERVICE", ATH9K_PHYERR_OFDM_SERVICE);
- PHY_ERR("OFDM-RESTART", ATH9K_PHYERR_OFDM_RESTART);
- PHY_ERR("FALSE-RADAR-EXT", ATH9K_PHYERR_FALSE_RADAR_EXT);
- PHY_ERR("CCK-TIMING", ATH9K_PHYERR_CCK_TIMING);
- PHY_ERR("CCK-HEADER-CRC", ATH9K_PHYERR_CCK_HEADER_CRC);
- PHY_ERR("CCK-RATE", ATH9K_PHYERR_CCK_RATE_ILLEGAL);
- PHY_ERR("CCK-SERVICE", ATH9K_PHYERR_CCK_SERVICE);
- PHY_ERR("CCK-RESTART", ATH9K_PHYERR_CCK_RESTART);
- PHY_ERR("CCK-LENGTH", ATH9K_PHYERR_CCK_LENGTH_ILLEGAL);
- PHY_ERR("CCK-POWER-DROP", ATH9K_PHYERR_CCK_POWER_DROP);
- PHY_ERR("HT-CRC", ATH9K_PHYERR_HT_CRC_ERROR);
- PHY_ERR("HT-LENGTH", ATH9K_PHYERR_HT_LENGTH_ILLEGAL);
- PHY_ERR("HT-RATE", ATH9K_PHYERR_HT_RATE_ILLEGAL);
+ len += scnprintf(buf + len, size - len,
+    "%20s : %10u\n", "SKBs allocated",
+    priv->debug.skbrx_stats.skb_allocated);
+ len += scnprintf(buf + len, size - len,
+    "%20s : %10u\n", "SKBs completed",
+    priv->debug.skbrx_stats.skb_completed);
+ len += scnprintf(buf + len, size - len,
+    "%20s : %10u\n", "SKBs Dropped",
+    priv->debug.skbrx_stats.skb_dropped);
 
  if (len > size)
   len = size;
@@ -352,12 +277,10 @@ static ssize_t read_file_recv(struct file *file, char __user *user_buf,
  kfree(buf);
 
  return retval;
-
-#undef PHY_ERR
 }
 
-static const struct file_operations fops_recv = {
- .read = read_file_recv,
+static const struct file_operations fops_skb_rx = {
+ .read = read_file_skb_rx,
  .open = simple_open,
  .owner = THIS_MODULE,
  .llseek = default_llseek,
@@ -372,16 +295,16 @@ static ssize_t read_file_slot(struct file *file, char __user *user_buf,
 
  spin_lock_bh(&priv->tx.tx_lock);
 
- len += snprintf(buf + len, sizeof(buf) - len, "TX slot bitmap : ");
+ len += scnprintf(buf + len, sizeof(buf) - len, "TX slot bitmap : ");
 
  len += bitmap_scnprintf(buf + len, sizeof(buf) - len,
           priv->tx.tx_slot, MAX_TX_BUF_NUM);
 
- len += snprintf(buf + len, sizeof(buf) - len, "\n");
+ len += scnprintf(buf + len, sizeof(buf) - len, "\n");
 
- len += snprintf(buf + len, sizeof(buf) - len,
-   "Used slots     : %d\n",
-   bitmap_weight(priv->tx.tx_slot, MAX_TX_BUF_NUM));
+ len += scnprintf(buf + len, sizeof(buf) - len,
+    "Used slots     : %d\n",
+    bitmap_weight(priv->tx.tx_slot, MAX_TX_BUF_NUM));
 
  spin_unlock_bh(&priv->tx.tx_lock);
 
@@ -405,30 +328,30 @@ static ssize_t read_file_queue(struct file *file, char __user *user_buf,
  char buf[512];
  unsigned int len = 0;
 
- len += snprintf(buf + len, sizeof(buf) - len, "%20s : %10u\n",
-   "Mgmt endpoint", skb_queue_len(&priv->tx.mgmt_ep_queue));
+ len += scnprintf(buf + len, sizeof(buf) - len, "%20s : %10u\n",
+    "Mgmt endpoint", skb_queue_len(&priv->tx.mgmt_ep_queue));
 
- len += snprintf(buf + len, sizeof(buf) - len, "%20s : %10u\n",
-   "Cab endpoint", skb_queue_len(&priv->tx.cab_ep_queue));
+ len += scnprintf(buf + len, sizeof(buf) - len, "%20s : %10u\n",
+    "Cab endpoint", skb_queue_len(&priv->tx.cab_ep_queue));
 
- len += snprintf(buf + len, sizeof(buf) - len, "%20s : %10u\n",
-   "Data BE endpoint", skb_queue_len(&priv->tx.data_be_queue));
+ len += scnprintf(buf + len, sizeof(buf) - len, "%20s : %10u\n",
+    "Data BE endpoint", skb_queue_len(&priv->tx.data_be_queue));
 
- len += snprintf(buf + len, sizeof(buf) - len, "%20s : %10u\n",
-   "Data BK endpoint", skb_queue_len(&priv->tx.data_bk_queue));
+ len += scnprintf(buf + len, sizeof(buf) - len, "%20s : %10u\n",
+    "Data BK endpoint", skb_queue_len(&priv->tx.data_bk_queue));
 
- len += snprintf(buf + len, sizeof(buf) - len, "%20s : %10u\n",
-   "Data VI endpoint", skb_queue_len(&priv->tx.data_vi_queue));
+ len += scnprintf(buf + len, sizeof(buf) - len, "%20s : %10u\n",
+    "Data VI endpoint", skb_queue_len(&priv->tx.data_vi_queue));
 
- len += snprintf(buf + len, sizeof(buf) - len, "%20s : %10u\n",
-   "Data VO endpoint", skb_queue_len(&priv->tx.data_vo_queue));
+ len += scnprintf(buf + len, sizeof(buf) - len, "%20s : %10u\n",
+    "Data VO endpoint", skb_queue_len(&priv->tx.data_vo_queue));
 
- len += snprintf(buf + len, sizeof(buf) - len, "%20s : %10u\n",
-   "Failed queue", skb_queue_len(&priv->tx.tx_failed));
+ len += scnprintf(buf + len, sizeof(buf) - len, "%20s : %10u\n",
+    "Failed queue", skb_queue_len(&priv->tx.tx_failed));
 
  spin_lock_bh(&priv->tx.tx_lock);
- len += snprintf(buf + len, sizeof(buf) - len, "%20s : %10u\n",
-   "Queued count", priv->tx.queued_cnt);
+ len += scnprintf(buf + len, sizeof(buf) - len, "%20s : %10u\n",
+    "Queued count", priv->tx.queued_cnt);
  spin_unlock_bh(&priv->tx.tx_lock);
 
  if (len > sizeof(buf))
@@ -471,7 +394,7 @@ static ssize_t write_file_debug(struct file *file, const char __user *user_buf,
   return -EFAULT;
 
  buf[len] = '\0';
- if (strict_strtoul(buf, 0, &mask))
+ if (kstrtoul(buf, 0, &mask))
   return -EINVAL;
 
  common->debug_mask = mask;
@@ -486,435 +409,87 @@ static const struct file_operations fops_debug = {
  .llseek = default_llseek,
 };
 
-static ssize_t read_file_base_eeprom(struct file *file, char __user *user_buf,
-         size_t count, loff_t *ppos)
-{
- struct ath9k_htc_priv *priv = file->private_data;
- struct ath_common *common = ath9k_hw_common(priv->ah);
- struct base_eep_header *pBase = NULL;
- unsigned int len = 0, size = 1500;
- ssize_t retval = 0;
- char *buf;
-
- /*
-  * This can be done since all the 3 EEPROM families have the
-  * same base header upto a certain point, and we are interested in
-  * the data only upto that point.
-  */
-
- if (AR_SREV_9271(priv->ah))
-  pBase = (struct base_eep_header *)
-   &priv->ah->eeprom.map4k.baseEepHeader;
- else if (priv->ah->hw_version.usbdev == AR9280_USB)
-  pBase = (struct base_eep_header *)
-   &priv->ah->eeprom.def.baseEepHeader;
- else if (priv->ah->hw_version.usbdev == AR9287_USB)
-  pBase = (struct base_eep_header *)
-   &priv->ah->eeprom.map9287.baseEepHeader;
-
- if (pBase == NULL) {
-  ath_err(common, "Unknown EEPROM type\n");
-  return 0;
- }
-
- buf = kzalloc(size, GFP_KERNEL);
- if (buf == NULL)
-  return -ENOMEM;
-
- len += snprintf(buf + len, size - len,
-   "%20s : %10d\n", "Major Version",
-   pBase->version >> 12);
- len += snprintf(buf + len, size - len,
-   "%20s : %10d\n", "Minor Version",
-   pBase->version & 0xFFF);
- len += snprintf(buf + len, size - len,
-   "%20s : %10d\n", "Checksum",
-   pBase->checksum);
- len += snprintf(buf + len, size - len,
-   "%20s : %10d\n", "Length",
-   pBase->length);
- len += snprintf(buf + len, size - len,
-   "%20s : %10d\n", "RegDomain1",
-   pBase->regDmn[0]);
- len += snprintf(buf + len, size - len,
-   "%20s : %10d\n", "RegDomain2",
-   pBase->regDmn[1]);
- len += snprintf(buf + len, size - len,
-   "%20s : %10d\n",
-   "TX Mask", pBase->txMask);
- len += snprintf(buf + len, size - len,
-   "%20s : %10d\n",
-   "RX Mask", pBase->rxMask);
- len += snprintf(buf + len, size - len,
-   "%20s : %10d\n",
-   "Allow 5GHz",
-   !!(pBase->opCapFlags & AR5416_OPFLAGS_11A));
- len += snprintf(buf + len, size - len,
-   "%20s : %10d\n",
-   "Allow 2GHz",
-   !!(pBase->opCapFlags & AR5416_OPFLAGS_11G));
- len += snprintf(buf + len, size - len,
-   "%20s : %10d\n",
-   "Disable 2GHz HT20",
-   !!(pBase->opCapFlags & AR5416_OPFLAGS_N_2G_HT20));
- len += snprintf(buf + len, size - len,
-   "%20s : %10d\n",
-   "Disable 2GHz HT40",
-   !!(pBase->opCapFlags & AR5416_OPFLAGS_N_2G_HT40));
- len += snprintf(buf + len, size - len,
-   "%20s : %10d\n",
-   "Disable 5Ghz HT20",
-   !!(pBase->opCapFlags & AR5416_OPFLAGS_N_5G_HT20));
- len += snprintf(buf + len, size - len,
-   "%20s : %10d\n",
-   "Disable 5Ghz HT40",
-   !!(pBase->opCapFlags & AR5416_OPFLAGS_N_5G_HT40));
- len += snprintf(buf + len, size - len,
-   "%20s : %10d\n",
-   "Big Endian",
-   !!(pBase->eepMisc & 0x01));
- len += snprintf(buf + len, size - len,
-   "%20s : %10d\n",
-   "Cal Bin Major Ver",
-   (pBase->binBuildNumber >> 24) & 0xFF);
- len += snprintf(buf + len, size - len,
-   "%20s : %10d\n",
-   "Cal Bin Minor Ver",
-   (pBase->binBuildNumber >> 16) & 0xFF);
- len += snprintf(buf + len, size - len,
-   "%20s : %10d\n",
-   "Cal Bin Build",
-   (pBase->binBuildNumber >> 8) & 0xFF);
-
- /*
-  * UB91 specific data.
-  */
- if (AR_SREV_9271(priv->ah)) {
-  struct base_eep_header_4k *pBase4k =
-   &priv->ah->eeprom.map4k.baseEepHeader;
-
-  len += snprintf(buf + len, size - len,
-    "%20s : %10d\n",
-    "TX Gain type",
-    pBase4k->txGainType);
- }
-
- /*
-  * UB95 specific data.
-  */
- if (priv->ah->hw_version.usbdev == AR9287_USB) {
-  struct base_eep_ar9287_header *pBase9287 =
-   &priv->ah->eeprom.map9287.baseEepHeader;
-
-  len += snprintf(buf + len, size - len,
-    "%20s : %10ddB\n",
-    "Power Table Offset",
-    pBase9287->pwrTableOffset);
-
-  len += snprintf(buf + len, size - len,
-    "%20s : %10d\n",
-    "OpenLoop Power Ctrl",
-    pBase9287->openLoopPwrCntl);
- }
+/* Ethtool support for get-stats */
+#define AMKSTR(nm) #nm "_BE", #nm "_BK", #nm "_VI", #nm "_VO"
+static const char ath9k_htc_gstrings_stats[][ETH_GSTRING_LEN] = {
+ "tx_pkts_nic",
+ "tx_bytes_nic",
+ "rx_pkts_nic",
+ "rx_bytes_nic",
 
- len += snprintf(buf + len, size - len, "%20s : %pM\n", "MacAddress",
-   pBase->macAddr);
- if (len > size)
-  len = size;
+ AMKSTR(d_tx_pkts),
 
- retval = simple_read_from_buffer(user_buf, count, ppos, buf, len);
- kfree(buf);
+ "d_rx_crc_err",
+ "d_rx_decrypt_crc_err",
+ "d_rx_phy_err",
+ "d_rx_mic_err",
+ "d_rx_pre_delim_crc_err",
+ "d_rx_post_delim_crc_err",
+ "d_rx_decrypt_busy_err",
 
- return retval;
-}
+ "d_rx_phyerr_radar",
+ "d_rx_phyerr_ofdm_timing",
+ "d_rx_phyerr_cck_timing",
 
-static const struct file_operations fops_base_eeprom = {
- .read = read_file_base_eeprom,
- .open = simple_open,
- .owner = THIS_MODULE,
- .llseek = default_llseek,
 };
+#define ATH9K_HTC_SSTATS_LEN ARRAY_SIZE(ath9k_htc_gstrings_stats)
 
-static ssize_t read_4k_modal_eeprom(struct file *file,
-        char __user *user_buf,
-        size_t count, loff_t *ppos)
+void ath9k_htc_get_et_strings(struct ieee80211_hw *hw,
+         struct ieee80211_vif *vif,
+         u32 sset, u8 *data)
 {
-#define PR_EEP(_s, _val)      \
- do {        \
-  len += snprintf(buf + len, size - len, "%20s : %10d\n", \
-    _s, (_val));    \
- } while (0)
-
- struct ath9k_htc_priv *priv = file->private_data;
- struct modal_eep_4k_header *pModal = &priv->ah->eeprom.map4k.modalHeader;
- unsigned int len = 0, size = 2048;
- ssize_t retval = 0;
- char *buf;
-
- buf = kzalloc(size, GFP_KERNEL);
- if (buf == NULL)
-  return -ENOMEM;
-
- PR_EEP("Chain0 Ant. Control", pModal->antCtrlChain[0]);
- PR_EEP("Ant. Common Control", pModal->antCtrlCommon);
- PR_EEP("Chain0 Ant. Gain", pModal->antennaGainCh[0]);
- PR_EEP("Switch Settle", pModal->switchSettling);
- PR_EEP("Chain0 TxRxAtten", pModal->txRxAttenCh[0]);
- PR_EEP("Chain0 RxTxMargin", pModal->rxTxMarginCh[0]);
- PR_EEP("ADC Desired size", pModal->adcDesiredSize);
- PR_EEP("PGA Desired size", pModal->pgaDesiredSize);
- PR_EEP("Chain0 xlna Gain", pModal->xlnaGainCh[0]);
- PR_EEP("txEndToXpaOff", pModal->txEndToXpaOff);
- PR_EEP("txEndToRxOn", pModal->txEndToRxOn);
- PR_EEP("txFrameToXpaOn", pModal->txFrameToXpaOn);
- PR_EEP("CCA Threshold)", pModal->thresh62);
- PR_EEP("Chain0 NF Threshold", pModal->noiseFloorThreshCh[0]);
- PR_EEP("xpdGain", pModal->xpdGain);
- PR_EEP("External PD", pModal->xpd);
- PR_EEP("Chain0 I Coefficient", pModal->iqCalICh[0]);
- PR_EEP("Chain0 Q Coefficient", pModal->iqCalQCh[0]);
- PR_EEP("pdGainOverlap", pModal->pdGainOverlap);
- PR_EEP("O/D Bias Version", pModal->version);
- PR_EEP("CCK OutputBias", pModal->ob_0);
- PR_EEP("BPSK OutputBias", pModal->ob_1);
- PR_EEP("QPSK OutputBias", pModal->ob_2);
- PR_EEP("16QAM OutputBias", pModal->ob_3);
- PR_EEP("64QAM OutputBias", pModal->ob_4);
- PR_EEP("CCK Driver1_Bias", pModal->db1_0);
- PR_EEP("BPSK Driver1_Bias", pModal->db1_1);
- PR_EEP("QPSK Driver1_Bias", pModal->db1_2);
- PR_EEP("16QAM Driver1_Bias", pModal->db1_3);
- PR_EEP("64QAM Driver1_Bias", pModal->db1_4);
- PR_EEP("CCK Driver2_Bias", pModal->db2_0);
- PR_EEP("BPSK Driver2_Bias", pModal->db2_1);
- PR_EEP("QPSK Driver2_Bias", pModal->db2_2);
- PR_EEP("16QAM Driver2_Bias", pModal->db2_3);
- PR_EEP("64QAM Driver2_Bias", pModal->db2_4);
- PR_EEP("xPA Bias Level", pModal->xpaBiasLvl);
- PR_EEP("txFrameToDataStart", pModal->txFrameToDataStart);
- PR_EEP("txFrameToPaOn", pModal->txFrameToPaOn);
- PR_EEP("HT40 Power Inc.", pModal->ht40PowerIncForPdadc);
- PR_EEP("Chain0 bswAtten", pModal->bswAtten[0]);
- PR_EEP("Chain0 bswMargin", pModal->bswMargin[0]);
- PR_EEP("HT40 Switch Settle", pModal->swSettleHt40);
- PR_EEP("Chain0 xatten2Db", pModal->xatten2Db[0]);
- PR_EEP("Chain0 xatten2Margin", pModal->xatten2Margin[0]);
- PR_EEP("Ant. Diversity ctl1", pModal->antdiv_ctl1);
- PR_EEP("Ant. Diversity ctl2", pModal->antdiv_ctl2);
- PR_EEP("TX Diversity", pModal->tx_diversity);
-
- if (len > size)
-  len = size;
-
- retval = simple_read_from_buffer(user_buf, count, ppos, buf, len);
- kfree(buf);
-
- return retval;
-
-#undef PR_EEP
+ if (sset == ETH_SS_STATS)
+  memcpy(data, *ath9k_htc_gstrings_stats,
+         sizeof(ath9k_htc_gstrings_stats));
 }
 
-static ssize_t read_def_modal_eeprom(struct file *file,
-         char __user *user_buf,
-         size_t count, loff_t *ppos)
+int ath9k_htc_get_et_sset_count(struct ieee80211_hw *hw,
+    struct ieee80211_vif *vif, int sset)
 {
-#define PR_EEP(_s, _val)      \
- do {        \
-  if (pBase->opCapFlags & AR5416_OPFLAGS_11G) {  \
-   pModal = &priv->ah->eeprom.def.modalHeader[1]; \
-   len += snprintf(buf + len, size - len, "%20s : %8d%7s", \
-     _s, (_val), "|");  \
-  }       \
-  if (pBase->opCapFlags & AR5416_OPFLAGS_11A) {  \
-   pModal = &priv->ah->eeprom.def.modalHeader[0]; \
-   len += snprintf(buf + len, size - len, "%9d\n", \
-     (_val));   \
-  }       \
- } while (0)
-
- struct ath9k_htc_priv *priv = file->private_data;
- struct base_eep_header *pBase = &priv->ah->eeprom.def.baseEepHeader;
- struct modal_eep_header *pModal = NULL;
- unsigned int len = 0, size = 3500;
- ssize_t retval = 0;
- char *buf;
-
- buf = kzalloc(size, GFP_KERNEL);
- if (buf == NULL)
-  return -ENOMEM;
-
- len += snprintf(buf + len, size - len,
-   "%31s %15s\n", "2G", "5G");
- len += snprintf(buf + len, size - len,
-   "%32s %16s\n", "====", "====\n");
-
- PR_EEP("Chain0 Ant. Control", pModal->antCtrlChain[0]);
- PR_EEP("Chain1 Ant. Control", pModal->antCtrlChain[1]);
- PR_EEP("Chain2 Ant. Control", pModal->antCtrlChain[2]);
- PR_EEP("Ant. Common Control", pModal->antCtrlCommon);
- PR_EEP("Chain0 Ant. Gain", pModal->antennaGainCh[0]);
- PR_EEP("Chain1 Ant. Gain", pModal->antennaGainCh[1]);
- PR_EEP("Chain2 Ant. Gain", pModal->antennaGainCh[2]);
- PR_EEP("Switch Settle", pModal->switchSettling);
- PR_EEP("Chain0 TxRxAtten", pModal->txRxAttenCh[0]);
- PR_EEP("Chain1 TxRxAtten", pModal->txRxAttenCh[1]);
- PR_EEP("Chain2 TxRxAtten", pModal->txRxAttenCh[2]);
- PR_EEP("Chain0 RxTxMargin", pModal->rxTxMarginCh[0]);
- PR_EEP("Chain1 RxTxMargin", pModal->rxTxMarginCh[1]);
- PR_EEP("Chain2 RxTxMargin", pModal->rxTxMarginCh[2]);
- PR_EEP("ADC Desired size", pModal->adcDesiredSize);
- PR_EEP("PGA Desired size", pModal->pgaDesiredSize);
- PR_EEP("Chain0 xlna Gain", pModal->xlnaGainCh[0]);
- PR_EEP("Chain1 xlna Gain", pModal->xlnaGainCh[1]);
- PR_EEP("Chain2 xlna Gain", pModal->xlnaGainCh[2]);
- PR_EEP("txEndToXpaOff", pModal->txEndToXpaOff);
- PR_EEP("txEndToRxOn", pModal->txEndToRxOn);
- PR_EEP("txFrameToXpaOn", pModal->txFrameToXpaOn);
- PR_EEP("CCA Threshold)", pModal->thresh62);
- PR_EEP("Chain0 NF Threshold", pModal->noiseFloorThreshCh[0]);
- PR_EEP("Chain1 NF Threshold", pModal->noiseFloorThreshCh[1]);
- PR_EEP("Chain2 NF Threshold", pModal->noiseFloorThreshCh[2]);
- PR_EEP("xpdGain", pModal->xpdGain);
- PR_EEP("External PD", pModal->xpd);
- PR_EEP("Chain0 I Coefficient", pModal->iqCalICh[0]);
- PR_EEP("Chain1 I Coefficient", pModal->iqCalICh[1]);
- PR_EEP("Chain2 I Coefficient", pModal->iqCalICh[2]);
- PR_EEP("Chain0 Q Coefficient", pModal->iqCalQCh[0]);
- PR_EEP("Chain1 Q Coefficient", pModal->iqCalQCh[1]);
- PR_EEP("Chain2 Q Coefficient", pModal->iqCalQCh[2]);
- PR_EEP("pdGainOverlap", pModal->pdGainOverlap);
- PR_EEP("Chain0 OutputBias", pModal->ob);
- PR_EEP("Chain0 DriverBias", pModal->db);
- PR_EEP("xPA Bias Level", pModal->xpaBiasLvl);
- PR_EEP("2chain pwr decrease", pModal->pwrDecreaseFor2Chain);
- PR_EEP("3chain pwr decrease", pModal->pwrDecreaseFor3Chain);
- PR_EEP("txFrameToDataStart", pModal->txFrameToDataStart);
- PR_EEP("txFrameToPaOn", pModal->txFrameToPaOn);
- PR_EEP("HT40 Power Inc.", pModal->ht40PowerIncForPdadc);
- PR_EEP("Chain0 bswAtten", pModal->bswAtten[0]);
- PR_EEP("Chain1 bswAtten", pModal->bswAtten[1]);
- PR_EEP("Chain2 bswAtten", pModal->bswAtten[2]);
- PR_EEP("Chain0 bswMargin", pModal->bswMargin[0]);
- PR_EEP("Chain1 bswMargin", pModal->bswMargin[1]);
- PR_EEP("Chain2 bswMargin", pModal->bswMargin[2]);
- PR_EEP("HT40 Switch Settle", pModal->swSettleHt40);
- PR_EEP("Chain0 xatten2Db", pModal->xatten2Db[0]);
- PR_EEP("Chain1 xatten2Db", pModal->xatten2Db[1]);
- PR_EEP("Chain2 xatten2Db", pModal->xatten2Db[2]);
- PR_EEP("Chain0 xatten2Margin", pModal->xatten2Margin[0]);
- PR_EEP("Chain1 xatten2Margin", pModal->xatten2Margin[1]);
- PR_EEP("Chain2 xatten2Margin", pModal->xatten2Margin[2]);
- PR_EEP("Chain1 OutputBias", pModal->ob_ch1);
- PR_EEP("Chain1 DriverBias", pModal->db_ch1);
- PR_EEP("LNA Control", pModal->lna_ctl);
- PR_EEP("XPA Bias Freq0", pModal->xpaBiasLvlFreq[0]);
- PR_EEP("XPA Bias Freq1", pModal->xpaBiasLvlFreq[1]);
- PR_EEP("XPA Bias Freq2", pModal->xpaBiasLvlFreq[2]);
-
- if (len > size)
-  len = size;
-
- retval = simple_read_from_buffer(user_buf, count, ppos, buf, len);
- kfree(buf);
-
- return retval;
-
-#undef PR_EEP
+ if (sset == ETH_SS_STATS)
+  return ATH9K_HTC_SSTATS_LEN;
+ return 0;
 }
 
-static ssize_t read_9287_modal_eeprom(struct file *file,
-          char __user *user_buf,
-          size_t count, loff_t *ppos)
+#define STXBASE priv->debug.tx_stats
+#define SRXBASE priv->debug.rx_stats
+#define SKBTXBASE priv->debug.tx_stats
+#define SKBRXBASE priv->debug.skbrx_stats
+#define ASTXQ(a)     \
+ data[i++] = STXBASE.a[IEEE80211_AC_BE];  \
+ data[i++] = STXBASE.a[IEEE80211_AC_BK];  \
+ data[i++] = STXBASE.a[IEEE80211_AC_VI];  \
+ data[i++] = STXBASE.a[IEEE80211_AC_VO]
+
+void ath9k_htc_get_et_stats(struct ieee80211_hw *hw,
+       struct ieee80211_vif *vif,
+       struct ethtool_stats *stats, u64 *data)
 {
-#define PR_EEP(_s, _val)      \
- do {        \
-  len += snprintf(buf + len, size - len, "%20s : %10d\n", \
-    _s, (_val));    \
- } while (0)
+ struct ath9k_htc_priv *priv = hw->priv;
+ int i = 0;
 
- struct ath9k_htc_priv *priv = file->private_data;
- struct modal_eep_ar9287_header *pModal = &priv->ah->eeprom.map9287.modalHeader;
- unsigned int len = 0, size = 3000;
- ssize_t retval = 0;
- char *buf;
+ data[i++] = SKBTXBASE.skb_success;
+ data[i++] = SKBTXBASE.skb_success_bytes;
+ data[i++] = SKBRXBASE.skb_completed;
+ data[i++] = SKBRXBASE.skb_completed_bytes;
 
- buf = kzalloc(size, GFP_KERNEL);
- if (buf == NULL)
-  return -ENOMEM;
-
- PR_EEP("Chain0 Ant. Control", pModal->antCtrlChain[0]);
- PR_EEP("Chain1 Ant. Control", pModal->antCtrlChain[1]);
- PR_EEP("Ant. Common Control", pModal->antCtrlCommon);
- PR_EEP("Chain0 Ant. Gain", pModal->antennaGainCh[0]);
- PR_EEP("Chain1 Ant. Gain", pModal->antennaGainCh[1]);
- PR_EEP("Switch Settle", pModal->switchSettling);
- PR_EEP("Chain0 TxRxAtten", pModal->txRxAttenCh[0]);
- PR_EEP("Chain1 TxRxAtten", pModal->txRxAttenCh[1]);
- PR_EEP("Chain0 RxTxMargin", pModal->rxTxMarginCh[0]);
- PR_EEP("Chain1 RxTxMargin", pModal->rxTxMarginCh[1]);
- PR_EEP("ADC Desired size", pModal->adcDesiredSize);
- PR_EEP("txEndToXpaOff", pModal->txEndToXpaOff);
- PR_EEP("txEndToRxOn", pModal->txEndToRxOn);
- PR_EEP("txFrameToXpaOn", pModal->txFrameToXpaOn);
- PR_EEP("CCA Threshold)", pModal->thresh62);
- PR_EEP("Chain0 NF Threshold", pModal->noiseFloorThreshCh[0]);
- PR_EEP("Chain1 NF Threshold", pModal->noiseFloorThreshCh[1]);
- PR_EEP("xpdGain", pModal->xpdGain);
- PR_EEP("External PD", pModal->xpd);
- PR_EEP("Chain0 I Coefficient", pModal->iqCalICh[0]);
- PR_EEP("Chain1 I Coefficient", pModal->iqCalICh[1]);
- PR_EEP("Chain0 Q Coefficient", pModal->iqCalQCh[0]);
- PR_EEP("Chain1 Q Coefficient", pModal->iqCalQCh[1]);
- PR_EEP("pdGainOverlap", pModal->pdGainOverlap);
- PR_EEP("xPA Bias Level", pModal->xpaBiasLvl);
- PR_EEP("txFrameToDataStart", pModal->txFrameToDataStart);
- PR_EEP("txFrameToPaOn", pModal->txFrameToPaOn);
- PR_EEP("HT40 Power Inc.", pModal->ht40PowerIncForPdadc);
- PR_EEP("Chain0 bswAtten", pModal->bswAtten[0]);
- PR_EEP("Chain1 bswAtten", pModal->bswAtten[1]);
- PR_EEP("Chain0 bswMargin", pModal->bswMargin[0]);
- PR_EEP("Chain1 bswMargin", pModal->bswMargin[1]);
- PR_EEP("HT40 Switch Settle", pModal->swSettleHt40);
- PR_EEP("AR92x7 Version", pModal->version);
- PR_EEP("DriverBias1", pModal->db1);
- PR_EEP("DriverBias2", pModal->db1);
- PR_EEP("CCK OutputBias", pModal->ob_cck);
- PR_EEP("PSK OutputBias", pModal->ob_psk);
- PR_EEP("QAM OutputBias", pModal->ob_qam);
- PR_EEP("PAL_OFF OutputBias", pModal->ob_pal_off);
-
- if (len > size)
-  len = size;
+ ASTXQ(queue_stats);
 
- retval = simple_read_from_buffer(user_buf, count, ppos, buf, len);
- kfree(buf);
+ data[i++] = SRXBASE.crc_err;
+ data[i++] = SRXBASE.decrypt_crc_err;
+ data[i++] = SRXBASE.phy_err;
+ data[i++] = SRXBASE.mic_err;
+ data[i++] = SRXBASE.pre_delim_crc_err;
+ data[i++] = SRXBASE.post_delim_crc_err;
+ data[i++] = SRXBASE.decrypt_busy_err;
 
- return retval;
+ data[i++] = SRXBASE.phy_err_stats[ATH9K_PHYERR_RADAR];
+ data[i++] = SRXBASE.phy_err_stats[ATH9K_PHYERR_OFDM_TIMING];
+ data[i++] = SRXBASE.phy_err_stats[ATH9K_PHYERR_CCK_TIMING];
 
-#undef PR_EEP
+ WARN_ON(i != ATH9K_HTC_SSTATS_LEN);
 }
 
-static ssize_t read_file_modal_eeprom(struct file *file, char __user *user_buf,
-          size_t count, loff_t *ppos)
-{
- struct ath9k_htc_priv *priv = file->private_data;
-
- if (AR_SREV_9271(priv->ah))
-  return read_4k_modal_eeprom(file, user_buf, count, ppos);
- else if (priv->ah->hw_version.usbdev == AR9280_USB)
-  return read_def_modal_eeprom(file, user_buf, count, ppos);
- else if (priv->ah->hw_version.usbdev == AR9287_USB)
-  return read_9287_modal_eeprom(file, user_buf, count, ppos);
-
- return 0;
-}
-
-static const struct file_operations fops_modal_eeprom = {
- .read = read_file_modal_eeprom,
- .open = simple_open,
- .owner = THIS_MODULE,
- .llseek = default_llseek,
-};
 
 int ath9k_htc_init_debug(struct ath_hw *ah)
 {
@@ -934,18 +509,21 @@ int ath9k_htc_init_debug(struct ath_hw *ah)
        priv, &fops_tgt_rx_stats);
  debugfs_create_file("xmit", S_IRUSR, priv->debug.debugfs_phy,
        priv, &fops_xmit);
- debugfs_create_file("recv", S_IRUSR, priv->debug.debugfs_phy,
-       priv, &fops_recv);
+ debugfs_create_file("skb_rx", S_IRUSR, priv->debug.debugfs_phy,
+       priv, &fops_skb_rx);
+
+ ath9k_cmn_debug_recv(priv->debug.debugfs_phy, &priv->debug.rx_stats);
+ ath9k_cmn_debug_phy_err(priv->debug.debugfs_phy, &priv->debug.rx_stats);
+
  debugfs_create_file("slot", S_IRUSR, priv->debug.debugfs_phy,
        priv, &fops_slot);
  debugfs_create_file("queue", S_IRUSR, priv->debug.debugfs_phy,
        priv, &fops_queue);
  debugfs_create_file("debug", S_IRUSR | S_IWUSR, priv->debug.debugfs_phy,
        priv, &fops_debug);
- debugfs_create_file("base_eeprom", S_IRUSR, priv->debug.debugfs_phy,
-       priv, &fops_base_eeprom);
- debugfs_create_file("modal_eeprom", S_IRUSR, priv->debug.debugfs_phy,
-       priv, &fops_modal_eeprom);
+
+ ath9k_cmn_debug_base_eeprom(priv->debug.debugfs_phy, priv->ah);
+ ath9k_cmn_debug_modal_eeprom(priv->debug.debugfs_phy, priv->ah);
 
  return 0;
 }
diff --git a/drivers/net/wireless/ath/ath9k/htc_drv_gpio.c b/drivers/net/wireless/ath/ath9k/htc_drv_gpio.c
index 105582d..50f74a2 100644
--- a/drivers/net/wireless/ath/ath9k/htc_drv_gpio.c
+++ b/drivers/net/wireless/ath/ath9k/htc_drv_gpio.c
@@ -255,6 +255,17 @@ void ath9k_deinit_leds(struct ath9k_htc_priv *priv)
  cancel_work_sync(&priv->led_work);
 }
 
+
+void ath9k_configure_leds(struct ath9k_htc_priv *priv)
+{
+ /* Configure gpio 1 for output */
+ ath9k_hw_cfg_output(priv->ah, priv->ah->led_pin,
+       AR_GPIO_OUTPUT_MUX_AS_OUTPUT);
+ /* LED off, active low */
+ ath9k_hw_set_gpio(priv->ah, priv->ah->led_pin, 1);
+
+}
+
 void ath9k_init_leds(struct ath9k_htc_priv *priv)
 {
  int ret;
@@ -268,11 +279,7 @@ void ath9k_init_leds(struct ath9k_htc_priv *priv)
  else
   priv->ah->led_pin = ATH_LED_PIN_DEF;
 
- /* Configure gpio 1 for output */
- ath9k_hw_cfg_output(priv->ah, priv->ah->led_pin,
-       AR_GPIO_OUTPUT_MUX_AS_OUTPUT);
- /* LED off, active low */
- ath9k_hw_set_gpio(priv->ah, priv->ah->led_pin, 1);
+ ath9k_configure_leds(priv);
 
  snprintf(priv->led_name, sizeof(priv->led_name),
   "ath9k_htc-%s", wiphy_name(priv->hw->wiphy));
diff --git a/drivers/net/wireless/ath/ath9k/htc_drv_init.c b/drivers/net/wireless/ath/ath9k/htc_drv_init.c
index 3b202ff..8a3bd5f 100644
--- a/drivers/net/wireless/ath/ath9k/htc_drv_init.c
+++ b/drivers/net/wireless/ath/ath9k/htc_drv_init.c
@@ -34,92 +34,9 @@ static int ath9k_htc_btcoex_enable;
 module_param_named(btcoex_enable, ath9k_htc_btcoex_enable, int, 0444);
 MODULE_PARM_DESC(btcoex_enable, "Enable wifi-BT coexistence");
 
-#define CHAN2G(_freq, _idx)  { \
- .center_freq = (_freq), \
- .hw_value = (_idx), \
- .max_power = 20, \
-}
-
-#define CHAN5G(_freq, _idx) { \
- .band = IEEE80211_BAND_5GHZ, \
- .center_freq = (_freq), \
- .hw_value = (_idx), \
- .max_power = 20, \
-}
-
-static struct ieee80211_channel ath9k_2ghz_channels[] = {
- CHAN2G(2412, 0), /* Channel 1 */
- CHAN2G(2417, 1), /* Channel 2 */
- CHAN2G(2422, 2), /* Channel 3 */
- CHAN2G(2427, 3), /* Channel 4 */
- CHAN2G(2432, 4), /* Channel 5 */
- CHAN2G(2437, 5), /* Channel 6 */
- CHAN2G(2442, 6), /* Channel 7 */
- CHAN2G(2447, 7), /* Channel 8 */
- CHAN2G(2452, 8), /* Channel 9 */
- CHAN2G(2457, 9), /* Channel 10 */
- CHAN2G(2462, 10), /* Channel 11 */
- CHAN2G(2467, 11), /* Channel 12 */
- CHAN2G(2472, 12), /* Channel 13 */
- CHAN2G(2484, 13), /* Channel 14 */
-};
-
-static struct ieee80211_channel ath9k_5ghz_channels[] = {
- /* _We_ call this UNII 1 */
- CHAN5G(5180, 14), /* Channel 36 */
- CHAN5G(5200, 15), /* Channel 40 */
- CHAN5G(5220, 16), /* Channel 44 */
- CHAN5G(5240, 17), /* Channel 48 */
- /* _We_ call this UNII 2 */
- CHAN5G(5260, 18), /* Channel 52 */
- CHAN5G(5280, 19), /* Channel 56 */
- CHAN5G(5300, 20), /* Channel 60 */
- CHAN5G(5320, 21), /* Channel 64 */
- /* _We_ call this "Middle band" */
- CHAN5G(5500, 22), /* Channel 100 */
- CHAN5G(5520, 23), /* Channel 104 */
- CHAN5G(5540, 24), /* Channel 108 */
- CHAN5G(5560, 25), /* Channel 112 */
- CHAN5G(5580, 26), /* Channel 116 */
- CHAN5G(5600, 27), /* Channel 120 */
- CHAN5G(5620, 28), /* Channel 124 */
- CHAN5G(5640, 29), /* Channel 128 */
- CHAN5G(5660, 30), /* Channel 132 */
- CHAN5G(5680, 31), /* Channel 136 */
- CHAN5G(5700, 32), /* Channel 140 */
- /* _We_ call this UNII 3 */
- CHAN5G(5745, 33), /* Channel 149 */
- CHAN5G(5765, 34), /* Channel 153 */
- CHAN5G(5785, 35), /* Channel 157 */
- CHAN5G(5805, 36), /* Channel 161 */
- CHAN5G(5825, 37), /* Channel 165 */
-};
-
-/* Atheros hardware rate code addition for short premble */
-#define SHPCHECK(__hw_rate, __flags) \
- ((__flags & IEEE80211_RATE_SHORT_PREAMBLE) ? (__hw_rate | 0x04) : 0)
-
-#define RATE(_bitrate, _hw_rate, _flags) {  \
- .bitrate = (_bitrate),   \
- .flags  = (_flags),   \
- .hw_value = (_hw_rate),   \
- .hw_value_short = (SHPCHECK(_hw_rate, _flags)) \
-}
-
-static struct ieee80211_rate ath9k_legacy_rates[] = {
- RATE(10, 0x1b, 0),
- RATE(20, 0x1a, IEEE80211_RATE_SHORT_PREAMBLE), /* shortp : 0x1e */
- RATE(55, 0x19, IEEE80211_RATE_SHORT_PREAMBLE), /* shortp: 0x1d */
- RATE(110, 0x18, IEEE80211_RATE_SHORT_PREAMBLE), /* short: 0x1c */
- RATE(60, 0x0b, 0),
- RATE(90, 0x0f, 0),
- RATE(120, 0x0a, 0),
- RATE(180, 0x0e, 0),
- RATE(240, 0x09, 0),
- RATE(360, 0x0d, 0),
- RATE(480, 0x08, 0),
- RATE(540, 0x0c, 0),
-};
+static int ath9k_ps_enable;
+module_param_named(ps_enable, ath9k_ps_enable, int, 0444);
+MODULE_PARM_DESC(ps_enable, "Enable WLAN PowerSave");
 
 #ifdef CONFIG_MAC80211_LEDS
 static const struct ieee80211_tpt_blink ath9k_htc_tpt_blink[] = {
@@ -339,6 +256,25 @@ static void ath9k_multi_regread(void *hw_priv, u32 *addr,
        }
 }
 
+static void ath9k_regwrite_multi(struct ath_common *common)
+{
+ struct ath9k_htc_priv *priv = (struct ath9k_htc_priv *) common->priv;
+ u32 rsp_status;
+ int r;
+
+ r = ath9k_wmi_cmd(priv->wmi, WMI_REG_WRITE_CMDID,
+     (u8 *) &priv->wmi->multi_write,
+     sizeof(struct register_write) * priv->wmi->multi_write_idx,
+     (u8 *) &rsp_status, sizeof(rsp_status),
+     100);
+ if (unlikely(r)) {
+  ath_dbg(common, WMI,
+   "REGISTER WRITE FAILED, multi len: %d\n",
+   priv->wmi->multi_write_idx);
+ }
+ priv->wmi->multi_write_idx = 0;
+}
+
 static void ath9k_regwrite_single(void *hw_priv, u32 val, u32 reg_offset)
 {
  struct ath_hw *ah = (struct ath_hw *) hw_priv;
@@ -365,8 +301,6 @@ static void ath9k_regwrite_buffer(void *hw_priv, u32 val, u32 reg_offset)
  struct ath_hw *ah = (struct ath_hw *) hw_priv;
  struct ath_common *common = ath9k_hw_common(ah);
  struct ath9k_htc_priv *priv = (struct ath9k_htc_priv *) common->priv;
- u32 rsp_status;
- int r;
 
  mutex_lock(&priv->wmi->multi_write_mutex);
 
@@ -379,19 +313,8 @@ static void ath9k_regwrite_buffer(void *hw_priv, u32 val, u32 reg_offset)
  priv->wmi->multi_write_idx++;
 
  /* If the buffer is full, send it out. */
- if (priv->wmi->multi_write_idx == MAX_CMD_NUMBER) {
-  r = ath9k_wmi_cmd(priv->wmi, WMI_REG_WRITE_CMDID,
-     (u8 *) &priv->wmi->multi_write,
-     sizeof(struct register_write) * priv->wmi->multi_write_idx,
-     (u8 *) &rsp_status, sizeof(rsp_status),
-     100);
-  if (unlikely(r)) {
-   ath_dbg(common, WMI,
-    "REGISTER WRITE FAILED, multi len: %d\n",
-    priv->wmi->multi_write_idx);
-  }
-  priv->wmi->multi_write_idx = 0;
- }
+ if (priv->wmi->multi_write_idx == MAX_CMD_NUMBER)
+  ath9k_regwrite_multi(common);
 
  mutex_unlock(&priv->wmi->multi_write_mutex);
 }
@@ -422,26 +345,13 @@ static void ath9k_regwrite_flush(void *hw_priv)
  struct ath_hw *ah = (struct ath_hw *) hw_priv;
  struct ath_common *common = ath9k_hw_common(ah);
  struct ath9k_htc_priv *priv = (struct ath9k_htc_priv *) common->priv;
- u32 rsp_status;
- int r;
 
  atomic_dec(&priv->wmi->mwrite_cnt);
 
  mutex_lock(&priv->wmi->multi_write_mutex);
 
- if (priv->wmi->multi_write_idx) {
-  r = ath9k_wmi_cmd(priv->wmi, WMI_REG_WRITE_CMDID,
-     (u8 *) &priv->wmi->multi_write,
-     sizeof(struct register_write) * priv->wmi->multi_write_idx,
-     (u8 *) &rsp_status, sizeof(rsp_status),
-     100);
-  if (unlikely(r)) {
-   ath_dbg(common, WMI,
-    "REGISTER WRITE FAILED, multi len: %d\n",
-    priv->wmi->multi_write_idx);
-  }
-  priv->wmi->multi_write_idx = 0;
- }
+ if (priv->wmi->multi_write_idx)
+  ath9k_regwrite_multi(common);
 
  mutex_unlock(&priv->wmi->multi_write_mutex);
 }
@@ -487,48 +397,6 @@ static const struct ath_bus_ops ath9k_usb_bus_ops = {
  .eeprom_read = ath_usb_eeprom_read,
 };
 
-static void setup_ht_cap(struct ath9k_htc_priv *priv,
-    struct ieee80211_sta_ht_cap *ht_info)
-{
- struct ath_common *common = ath9k_hw_common(priv->ah);
- u8 tx_streams, rx_streams;
- int i;
-
- ht_info->ht_supported = true;
- ht_info->cap = IEEE80211_HT_CAP_SUP_WIDTH_20_40 |
-         IEEE80211_HT_CAP_SM_PS |
-         IEEE80211_HT_CAP_SGI_40 |
-         IEEE80211_HT_CAP_DSSSCCK40;
-
- if (priv->ah->caps.hw_caps & ATH9K_HW_CAP_SGI_20)
-  ht_info->cap |= IEEE80211_HT_CAP_SGI_20;
-
- ht_info->cap |= (1 << IEEE80211_HT_CAP_RX_STBC_SHIFT);
-
- ht_info->ampdu_factor = IEEE80211_HT_MAX_AMPDU_64K;
- ht_info->ampdu_density = IEEE80211_HT_MPDU_DENSITY_8;
-
- memset(&ht_info->mcs, 0, sizeof(ht_info->mcs));
-
- /* ath9k_htc supports only 1 or 2 stream devices */
- tx_streams = ath9k_cmn_count_streams(priv->ah->txchainmask, 2);
- rx_streams = ath9k_cmn_count_streams(priv->ah->rxchainmask, 2);
-
- ath_dbg(common, CONFIG, "TX streams %d, RX streams: %d\n",
-  tx_streams, rx_streams);
-
- if (tx_streams != rx_streams) {
-  ht_info->mcs.tx_params |= IEEE80211_HT_MCS_TX_RX_DIFF;
-  ht_info->mcs.tx_params |= ((tx_streams - 1) <<
-        IEEE80211_HT_MCS_TX_MAX_STREAMS_SHIFT);
- }
-
- for (i = 0; i < rx_streams; i++)
-  ht_info->mcs.rx_mask[i] = 0xff;
-
- ht_info->mcs.tx_params |= IEEE80211_HT_MCS_TX_DEFINED;
-}
-
 static int ath9k_init_queues(struct ath9k_htc_priv *priv)
 {
  struct ath_common *common = ath9k_hw_common(priv->ah);
@@ -537,8 +405,8 @@ static int ath9k_init_queues(struct ath9k_htc_priv *priv)
  for (i = 0; i < ARRAY_SIZE(priv->hwq_map); i++)
   priv->hwq_map[i] = -1;
 
- priv->beaconq = ath9k_hw_beaconq_setup(priv->ah);
- if (priv->beaconq == -1) {
+ priv->beacon.beaconq = ath9k_hw_beaconq_setup(priv->ah);
+ if (priv->beacon.beaconq == -1) {
   ath_err(common, "Unable to setup BEACON xmit queue\n");
   goto err;
  }
@@ -573,37 +441,13 @@ err:
  return -EINVAL;
 }
 
-static void ath9k_init_channels_rates(struct ath9k_htc_priv *priv)
-{
- if (priv->ah->caps.hw_caps & ATH9K_HW_CAP_2GHZ) {
-  priv->sbands[IEEE80211_BAND_2GHZ].channels =
-   ath9k_2ghz_channels;
-  priv->sbands[IEEE80211_BAND_2GHZ].band = IEEE80211_BAND_2GHZ;
-  priv->sbands[IEEE80211_BAND_2GHZ].n_channels =
-   ARRAY_SIZE(ath9k_2ghz_channels);
-  priv->sbands[IEEE80211_BAND_2GHZ].bitrates = ath9k_legacy_rates;
-  priv->sbands[IEEE80211_BAND_2GHZ].n_bitrates =
-   ARRAY_SIZE(ath9k_legacy_rates);
- }
-
- if (priv->ah->caps.hw_caps & ATH9K_HW_CAP_5GHZ) {
-  priv->sbands[IEEE80211_BAND_5GHZ].channels = ath9k_5ghz_channels;
-  priv->sbands[IEEE80211_BAND_5GHZ].band = IEEE80211_BAND_5GHZ;
-  priv->sbands[IEEE80211_BAND_5GHZ].n_channels =
-   ARRAY_SIZE(ath9k_5ghz_channels);
-  priv->sbands[IEEE80211_BAND_5GHZ].bitrates =
-   ath9k_legacy_rates + 4;
-  priv->sbands[IEEE80211_BAND_5GHZ].n_bitrates =
-   ARRAY_SIZE(ath9k_legacy_rates) - 4;
- }
-}
-
 static void ath9k_init_misc(struct ath9k_htc_priv *priv)
 {
  struct ath_common *common = ath9k_hw_common(priv->ah);
 
  memcpy(common->bssidmask, ath_bcast_mac, ETH_ALEN);
 
+ common->last_rssi = ATH_RSSI_DUMMY_MARKER;
  priv->ah->opmode = NL80211_IFTYPE_STATION;
 }
 
@@ -615,12 +459,11 @@ static int ath9k_init_priv(struct ath9k_htc_priv *priv,
  struct ath_common *common;
  int i, ret = 0, csz = 0;
 
- set_bit(OP_INVALID, &priv->op_flags);
-
  ah = kzalloc(sizeof(struct ath_hw), GFP_KERNEL);
  if (!ah)
   return -ENOMEM;
 
+ ah->dev = priv->dev;
  ah->hw_version.devid = devid;
  ah->hw_version.usbdev = drv_info;
  ah->ah_flags |= AH_USE_EEPROM;
@@ -640,6 +483,7 @@ static int ath9k_init_priv(struct ath9k_htc_priv *priv,
  common->priv = priv;
  common->debug_mask = ath9k_debug;
  common->btcoex_enabled = ath9k_htc_btcoex_enable == 1;
+ set_bit(ATH_OP_INVALID, &common->op_flags);
 
  spin_lock_init(&priv->beacon_lock);
  spin_lock_init(&priv->tx.tx_lock);
@@ -675,10 +519,11 @@ static int ath9k_init_priv(struct ath9k_htc_priv *priv,
   goto err_queues;
 
  for (i = 0; i < ATH9K_HTC_MAX_BCN_VIF; i++)
-  priv->cur_beacon_conf.bslot[i] = NULL;
+  priv->beacon.bslot[i] = NULL;
+ priv->beacon.slottime = ATH9K_SLOT_TIME_9;
 
+ ath9k_cmn_init_channels_rates(common);
  ath9k_cmn_init_crypto(ah);
- ath9k_init_channels_rates(priv);
  ath9k_init_misc(priv);
  ath9k_htc_init_btcoex(priv, product);
 
@@ -698,6 +543,9 @@ static const struct ieee80211_iface_limit if_limits[] = {
  { .max = 2, .types = BIT(NL80211_IFTYPE_STATION) |
      BIT(NL80211_IFTYPE_P2P_CLIENT) },
  { .max = 2, .types = BIT(NL80211_IFTYPE_AP) |
+#ifdef CONFIG_MAC80211_MESH
+     BIT(NL80211_IFTYPE_MESH_POINT) |
+#endif
      BIT(NL80211_IFTYPE_P2P_GO) },
 };
 
@@ -711,24 +559,30 @@ static const struct ieee80211_iface_combination if_comb = {
 static void ath9k_set_hw_capab(struct ath9k_htc_priv *priv,
           struct ieee80211_hw *hw)
 {
+ struct ath_hw *ah = priv->ah;
  struct ath_common *common = ath9k_hw_common(priv->ah);
+ struct base_eep_header *pBase;
 
  hw->flags = IEEE80211_HW_SIGNAL_DBM |
   IEEE80211_HW_AMPDU_AGGREGATION |
   IEEE80211_HW_SPECTRUM_MGMT |
   IEEE80211_HW_HAS_RATE_CONTROL |
   IEEE80211_HW_RX_INCLUDES_FCS |
-  IEEE80211_HW_SUPPORTS_PS |
   IEEE80211_HW_PS_NULLFUNC_STACK |
   IEEE80211_HW_REPORTS_TX_ACK_STATUS |
+  IEEE80211_HW_MFP_CAPABLE |
   IEEE80211_HW_HOST_BROADCAST_PS_BUFFERING;
 
+ if (ath9k_ps_enable)
+  hw->flags |= IEEE80211_HW_SUPPORTS_PS;
+
  hw->wiphy->interface_modes =
   BIT(NL80211_IFTYPE_STATION) |
   BIT(NL80211_IFTYPE_ADHOC) |
   BIT(NL80211_IFTYPE_AP) |
   BIT(NL80211_IFTYPE_P2P_GO) |
-  BIT(NL80211_IFTYPE_P2P_CLIENT);
+  BIT(NL80211_IFTYPE_P2P_CLIENT) |
+  BIT(NL80211_IFTYPE_MESH_POINT);
 
  hw->wiphy->iface_combinations = &if_comb;
  hw->wiphy->n_iface_combinations = 1;
@@ -739,7 +593,6 @@ static void ath9k_set_hw_capab(struct ath9k_htc_priv *priv,
        WIPHY_FLAG_HAS_REMAIN_ON_CHANNEL;
 
  hw->queues = 4;
- hw->channel_change_time = 5000;
  hw->max_listen_interval = 1;
 
  hw->vif_data_size = sizeof(struct ath9k_htc_vif);
@@ -751,18 +604,17 @@ static void ath9k_set_hw_capab(struct ath9k_htc_priv *priv,
 
  if (priv->ah->caps.hw_caps & ATH9K_HW_CAP_2GHZ)
   hw->wiphy->bands[IEEE80211_BAND_2GHZ] =
-   &priv->sbands[IEEE80211_BAND_2GHZ];
+   &common->sbands[IEEE80211_BAND_2GHZ];
  if (priv->ah->caps.hw_caps & ATH9K_HW_CAP_5GHZ)
   hw->wiphy->bands[IEEE80211_BAND_5GHZ] =
-   &priv->sbands[IEEE80211_BAND_5GHZ];
-
- if (priv->ah->caps.hw_caps & ATH9K_HW_CAP_HT) {
-  if (priv->ah->caps.hw_caps & ATH9K_HW_CAP_2GHZ)
-   setup_ht_cap(priv,
-         &priv->sbands[IEEE80211_BAND_2GHZ].ht_cap);
-  if (priv->ah->caps.hw_caps & ATH9K_HW_CAP_5GHZ)
-   setup_ht_cap(priv,
-         &priv->sbands[IEEE80211_BAND_5GHZ].ht_cap);
+   &common->sbands[IEEE80211_BAND_5GHZ];
+
+ ath9k_cmn_reload_chainmask(ah);
+
+ pBase = ath9k_htc_get_eeprom_base(priv);
+ if (pBase) {
+  hw->wiphy->available_antennas_rx = pBase->rxMask;
+  hw->wiphy->available_antennas_tx = pBase->txMask;
  }
 
  SET_IEEE80211_PERM_ADDR(hw, common->macaddr);
@@ -985,6 +837,8 @@ int ath9k_htc_resume(struct htc_target *htc_handle)
 
  ret = ath9k_init_htc_services(priv, priv->ah->hw_version.devid,
           priv->ah->hw_version.usbdev);
+ ath9k_configure_leds(priv);
+
  return ret;
 }
 #endif
diff --git a/drivers/net/wireless/ath/ath9k/htc_drv_main.c b/drivers/net/wireless/ath/ath9k/htc_drv_main.c
index 21e7edc..5627917 100644
--- a/drivers/net/wireless/ath/ath9k/htc_drv_main.c
+++ b/drivers/net/wireless/ath/ath9k/htc_drv_main.c
@@ -24,30 +24,10 @@
 static enum htc_phymode ath9k_htc_get_curmode(struct ath9k_htc_priv *priv,
            struct ath9k_channel *ichan)
 {
- enum htc_phymode mode;
-
- mode = -EINVAL;
-
- switch (ichan->chanmode) {
- case CHANNEL_G:
- case CHANNEL_G_HT20:
- case CHANNEL_G_HT40PLUS:
- case CHANNEL_G_HT40MINUS:
-  mode = HTC_MODE_11NG;
-  break;
- case CHANNEL_A:
- case CHANNEL_A_HT20:
- case CHANNEL_A_HT40PLUS:
- case CHANNEL_A_HT40MINUS:
-  mode = HTC_MODE_11NA;
-  break;
- default:
-  break;
- }
+ if (IS_CHAN_5GHZ(ichan))
+  return HTC_MODE_11NA;
 
- WARN_ON(mode < 0);
-
- return mode;
+ return HTC_MODE_11NG;
 }
 
 bool ath9k_htc_setpower(struct ath9k_htc_priv *priv,
@@ -113,8 +93,12 @@ static void ath9k_htc_vif_iter(void *data, u8 *mac, struct ieee80211_vif *vif)
  struct ath9k_htc_priv *priv = data;
  struct ieee80211_bss_conf *bss_conf = &vif->bss_conf;
 
- if ((vif->type == NL80211_IFTYPE_AP) && bss_conf->enable_beacon)
+ if ((vif->type == NL80211_IFTYPE_AP ||
+      vif->type == NL80211_IFTYPE_MESH_POINT) &&
+     bss_conf->enable_beacon) {
   priv->reconfig_beacon = true;
+  priv->rearm_ani = true;
+ }
 
  if (bss_conf->assoc) {
   priv->rearm_ani = true;
@@ -189,6 +173,8 @@ static void ath9k_htc_set_opmode(struct ath9k_htc_priv *priv)
   priv->ah->opmode = NL80211_IFTYPE_ADHOC;
  else if (priv->num_ap_vif)
   priv->ah->opmode = NL80211_IFTYPE_AP;
+ else if (priv->num_mbss_vif)
+  priv->ah->opmode = NL80211_IFTYPE_MESH_POINT;
  else
   priv->ah->opmode = NL80211_IFTYPE_STATION;
 
@@ -266,13 +252,14 @@ static int ath9k_htc_set_channel(struct ath9k_htc_priv *priv,
  u8 cmd_rsp;
  int ret;
 
- if (test_bit(OP_INVALID, &priv->op_flags))
+ if (test_bit(ATH_OP_INVALID, &common->op_flags))
   return -EIO;
 
  fastcc = !!(hw->conf.flags & IEEE80211_CONF_OFFCHANNEL);
 
  ath9k_htc_ps_wakeup(priv);
 
+ ath9k_htc_stop_ani(priv);
  del_timer_sync(&priv->tx.cleanup_timer);
  ath9k_htc_tx_drain(priv);
 
@@ -320,7 +307,7 @@ static int ath9k_htc_set_channel(struct ath9k_htc_priv *priv,
 
  htc_start(priv->htc);
 
- if (!test_bit(OP_SCANNING, &priv->op_flags) &&
+ if (!test_bit(ATH_OP_SCANNING, &common->op_flags) &&
      !(hw->conf.flags & IEEE80211_CONF_OFFCHANNEL))
   ath9k_htc_vif_reconfig(priv);
 
@@ -632,6 +619,8 @@ static void ath9k_htc_setup_rate(struct ath9k_htc_priv *priv,
   trate->rates.ht_rates.rs_nrates = j;
 
   caps = WLAN_RC_HT_FLAG;
+  if (sta->ht_cap.cap & IEEE80211_HT_CAP_RX_STBC)
+   caps |= ATH_RC_TX_STBC_FLAG;
   if (sta->ht_cap.mcs.rx_mask[1])
    caps |= WLAN_RC_DS_FLAG;
   if ((sta->ht_cap.cap & IEEE80211_HT_CAP_SUP_WIDTH_20_40) &&
@@ -762,7 +751,7 @@ void ath9k_htc_start_ani(struct ath9k_htc_priv *priv)
  common->ani.shortcal_timer = timestamp;
  common->ani.checkani_timer = timestamp;
 
- set_bit(OP_ANI_RUNNING, &priv->op_flags);
+ set_bit(ATH_OP_ANI_RUN, &common->op_flags);
 
  ieee80211_queue_delayed_work(common->hw, &priv->ani_work,
          msecs_to_jiffies(ATH_ANI_POLLINTERVAL));
@@ -770,8 +759,9 @@ void ath9k_htc_start_ani(struct ath9k_htc_priv *priv)
 
 void ath9k_htc_stop_ani(struct ath9k_htc_priv *priv)
 {
+ struct ath_common *common = ath9k_hw_common(priv->ah);
  cancel_delayed_work_sync(&priv->ani_work);
- clear_bit(OP_ANI_RUNNING, &priv->op_flags);
+ clear_bit(ATH_OP_ANI_RUN, &common->op_flags);
 }
 
 void ath9k_htc_ani_work(struct work_struct *work)
@@ -819,8 +809,7 @@ void ath9k_htc_ani_work(struct work_struct *work)
  }
 
  /* Verify whether we must check ANI */
- if (ah->config.enable_ani &&
-     (timestamp - common->ani.checkani_timer) >= ATH_ANI_POLLINTERVAL) {
+ if ((timestamp - common->ani.checkani_timer) >= ATH_ANI_POLLINTERVAL) {
   aniflag = true;
   common->ani.checkani_timer = timestamp;
  }
@@ -850,8 +839,7 @@ set_timer:
  * short calibration and long calibration.
  */
  cal_interval = ATH_LONG_CALINTERVAL;
- if (ah->config.enable_ani)
-  cal_interval = min(cal_interval, (u32)ATH_ANI_POLLINTERVAL);
+ cal_interval = min(cal_interval, (u32)ATH_ANI_POLLINTERVAL);
  if (!common->ani.caldone)
   cal_interval = min(cal_interval, (u32)short_cal_interval);
 
@@ -931,7 +919,7 @@ static int ath9k_htc_start(struct ieee80211_hw *hw)
  WMI_CMD(WMI_FLUSH_RECV_CMDID);
 
  /* setup initial channel */
- init_channel = ath9k_cmn_get_curchannel(hw, ah);
+ init_channel = ath9k_cmn_get_channel(hw, ah, &hw->conf.chandef);
 
  ret = ath9k_hw_reset(ah, init_channel, ah->caldata, false);
  if (ret) {
@@ -958,7 +946,7 @@ static int ath9k_htc_start(struct ieee80211_hw *hw)
   ath_dbg(common, CONFIG,
    "Failed to update capability in target\n");
 
- clear_bit(OP_INVALID, &priv->op_flags);
+ clear_bit(ATH_OP_INVALID, &common->op_flags);
  htc_start(priv->htc);
 
  spin_lock_bh(&priv->tx.tx_lock);
@@ -987,7 +975,7 @@ static void ath9k_htc_stop(struct ieee80211_hw *hw)
 
  mutex_lock(&priv->mutex);
 
- if (test_bit(OP_INVALID, &priv->op_flags)) {
+ if (test_bit(ATH_OP_INVALID, &common->op_flags)) {
   ath_dbg(common, ANY, "Device not present\n");
   mutex_unlock(&priv->mutex);
   return;
@@ -1029,7 +1017,7 @@ static void ath9k_htc_stop(struct ieee80211_hw *hw)
  ath9k_htc_ps_restore(priv);
  ath9k_htc_setpower(priv, ATH9K_PM_FULL_SLEEP);
 
- set_bit(OP_INVALID, &priv->op_flags);
+ set_bit(ATH_OP_INVALID, &common->op_flags);
 
  ath_dbg(common, CONFIG, "Driver halt\n");
  mutex_unlock(&priv->mutex);
@@ -1061,6 +1049,9 @@ static int ath9k_htc_add_interface(struct ieee80211_hw *hw,
  case NL80211_IFTYPE_AP:
   hvif.opmode = HTC_M_HOSTAP;
   break;
+ case NL80211_IFTYPE_MESH_POINT:
+  hvif.opmode = HTC_M_WDS; /* close enough */
+  break;
  default:
   ath_err(common,
    "Interface type %d not yet supported\n", vif->type);
@@ -1093,13 +1084,14 @@ static int ath9k_htc_add_interface(struct ieee80211_hw *hw,
  INC_VIF(priv, vif->type);
 
  if ((vif->type == NL80211_IFTYPE_AP) ||
+     (vif->type == NL80211_IFTYPE_MESH_POINT) ||
      (vif->type == NL80211_IFTYPE_ADHOC))
   ath9k_htc_assign_bslot(priv, vif);
 
  ath9k_htc_set_opmode(priv);
 
  if ((priv->ah->opmode == NL80211_IFTYPE_AP) &&
-     !test_bit(OP_ANI_RUNNING, &priv->op_flags)) {
+     !test_bit(ATH_OP_ANI_RUN, &common->op_flags)) {
   ath9k_hw_set_tsfadjust(priv->ah, true);
   ath9k_htc_start_ani(priv);
  }
@@ -1143,6 +1135,7 @@ static void ath9k_htc_remove_interface(struct ieee80211_hw *hw,
  DEC_VIF(priv, vif->type);
 
  if ((vif->type == NL80211_IFTYPE_AP) ||
+      vif->type == NL80211_IFTYPE_MESH_POINT ||
      (vif->type == NL80211_IFTYPE_ADHOC))
   ath9k_htc_remove_bslot(priv, vif);
 
@@ -1203,17 +1196,12 @@ static int ath9k_htc_config(struct ieee80211_hw *hw, u32 changed)
 
  if ((changed & IEEE80211_CONF_CHANGE_CHANNEL) || chip_reset) {
   struct ieee80211_channel *curchan = hw->conf.chandef.chan;
-  enum nl80211_channel_type channel_type =
-   cfg80211_get_chandef_type(&hw->conf.chandef);
   int pos = curchan->hw_value;
 
   ath_dbg(common, CONFIG, "Set channel: %d MHz\n",
    curchan->center_freq);
 
-  ath9k_cmn_update_ichannel(&priv->ah->channels[pos],
-       hw->conf.chandef.chan,
-       channel_type);
-
+  ath9k_cmn_get_channel(hw, priv->ah, &hw->conf.chandef);
   if (ath9k_htc_set_channel(priv, hw, &priv->ah->channels[pos]) < 0) {
    ath_err(common, "Unable to set channel\n");
    ret = -EINVAL;
@@ -1261,13 +1249,14 @@ static void ath9k_htc_configure_filter(struct ieee80211_hw *hw,
            u64 multicast)
 {
  struct ath9k_htc_priv *priv = hw->priv;
+ struct ath_common *common = ath9k_hw_common(priv->ah);
  u32 rfilt;
 
  mutex_lock(&priv->mutex);
  changed_flags &= SUPPORTED_FILTERS;
  *total_flags &= SUPPORTED_FILTERS;
 
- if (test_bit(OP_INVALID, &priv->op_flags)) {
+ if (test_bit(ATH_OP_INVALID, &common->op_flags)) {
   ath_dbg(ath9k_hw_common(priv->ah), ANY,
    "Unable to configure filter on invalid state\n");
   mutex_unlock(&priv->mutex);
@@ -1286,18 +1275,50 @@ static void ath9k_htc_configure_filter(struct ieee80211_hw *hw,
  mutex_unlock(&priv->mutex);
 }
 
+static void ath9k_htc_sta_rc_update_work(struct work_struct *work)
+{
+ struct ath9k_htc_sta *ista =
+     container_of(work, struct ath9k_htc_sta, rc_update_work);
+ struct ieee80211_sta *sta =
+     container_of((void *)ista, struct ieee80211_sta, drv_priv);
+ struct ath9k_htc_priv *priv = ista->htc_priv;
+ struct ath_common *common = ath9k_hw_common(priv->ah);
+ struct ath9k_htc_target_rate trate;
+
+ mutex_lock(&priv->mutex);
+ ath9k_htc_ps_wakeup(priv);
+
+ memset(&trate, 0, sizeof(struct ath9k_htc_target_rate));
+ ath9k_htc_setup_rate(priv, sta, &trate);
+ if (!ath9k_htc_send_rate_cmd(priv, &trate))
+  ath_dbg(common, CONFIG,
+   "Supported rates for sta: %pM updated, rate caps: 0x%X\n",
+   sta->addr, be32_to_cpu(trate.capflags));
+ else
+  ath_dbg(common, CONFIG,
+   "Unable to update supported rates for sta: %pM\n",
+   sta->addr);
+
+ ath9k_htc_ps_restore(priv);
+ mutex_unlock(&priv->mutex);
+}
+
 static int ath9k_htc_sta_add(struct ieee80211_hw *hw,
         struct ieee80211_vif *vif,
         struct ieee80211_sta *sta)
 {
  struct ath9k_htc_priv *priv = hw->priv;
+ struct ath9k_htc_sta *ista = (struct ath9k_htc_sta *) sta->drv_priv;
  int ret;
 
  mutex_lock(&priv->mutex);
  ath9k_htc_ps_wakeup(priv);
  ret = ath9k_htc_add_station(priv, vif, sta);
- if (!ret)
+ if (!ret) {
+  INIT_WORK(&ista->rc_update_work, ath9k_htc_sta_rc_update_work);
+  ista->htc_priv = priv;
   ath9k_htc_init_rate(priv, sta);
+ }
  ath9k_htc_ps_restore(priv);
  mutex_unlock(&priv->mutex);
 
@@ -1309,12 +1330,13 @@ static int ath9k_htc_sta_remove(struct ieee80211_hw *hw,
     struct ieee80211_sta *sta)
 {
  struct ath9k_htc_priv *priv = hw->priv;
- struct ath9k_htc_sta *ista;
+ struct ath9k_htc_sta *ista = (struct ath9k_htc_sta *) sta->drv_priv;
  int ret;
 
+ cancel_work_sync(&ista->rc_update_work);
+
  mutex_lock(&priv->mutex);
  ath9k_htc_ps_wakeup(priv);
- ista = (struct ath9k_htc_sta *) sta->drv_priv;
  htc_sta_drain(priv->htc, ista->index);
  ret = ath9k_htc_remove_station(priv, vif, sta);
  ath9k_htc_ps_restore(priv);
@@ -1327,28 +1349,12 @@ static void ath9k_htc_sta_rc_update(struct ieee80211_hw *hw,
         struct ieee80211_vif *vif,
         struct ieee80211_sta *sta, u32 changed)
 {
- struct ath9k_htc_priv *priv = hw->priv;
- struct ath_common *common = ath9k_hw_common(priv->ah);
- struct ath9k_htc_target_rate trate;
-
- mutex_lock(&priv->mutex);
- ath9k_htc_ps_wakeup(priv);
+ struct ath9k_htc_sta *ista = (struct ath9k_htc_sta *) sta->drv_priv;
 
- if (changed & IEEE80211_RC_SUPP_RATES_CHANGED) {
-  memset(&trate, 0, sizeof(struct ath9k_htc_target_rate));
-  ath9k_htc_setup_rate(priv, sta, &trate);
-  if (!ath9k_htc_send_rate_cmd(priv, &trate))
-   ath_dbg(common, CONFIG,
-    "Supported rates for sta: %pM updated, rate caps: 0x%X\n",
-    sta->addr, be32_to_cpu(trate.capflags));
-  else
-   ath_dbg(common, CONFIG,
-    "Unable to update supported rates for sta: %pM\n",
-    sta->addr);
- }
+ if (!(changed & IEEE80211_RC_SUPP_RATES_CHANGED))
+  return;
 
- ath9k_htc_ps_restore(priv);
- mutex_unlock(&priv->mutex);
+ schedule_work(&ista->rc_update_work);
 }
 
 static int ath9k_htc_conf_tx(struct ieee80211_hw *hw,
@@ -1473,7 +1479,9 @@ static void ath9k_htc_bss_iter(void *data, u8 *mac, struct ieee80211_vif *vif)
 
  if ((vif->type == NL80211_IFTYPE_STATION) && bss_conf->assoc) {
   common->curaid = bss_conf->aid;
+  common->last_rssi = ATH_RSSI_DUMMY_MARKER;
   memcpy(common->curbssid, bss_conf->bssid, ETH_ALEN);
+  set_bit(ATH_OP_PRIM_STA_VIF, &common->op_flags);
  }
 }
 
@@ -1495,6 +1503,7 @@ static void ath9k_htc_bss_info_changed(struct ieee80211_hw *hw,
  struct ath9k_htc_priv *priv = hw->priv;
  struct ath_hw *ah = priv->ah;
  struct ath_common *common = ath9k_hw_common(ah);
+ int slottime;
 
  mutex_lock(&priv->mutex);
  ath9k_htc_ps_wakeup(priv);
@@ -1506,6 +1515,9 @@ static void ath9k_htc_bss_info_changed(struct ieee80211_hw *hw,
   bss_conf->assoc ?
    priv->num_sta_assoc_vif++ : priv->num_sta_assoc_vif--;
 
+  if (!bss_conf->assoc)
+   clear_bit(ATH_OP_PRIM_STA_VIF, &common->op_flags);
+
   if (priv->ah->opmode == NL80211_IFTYPE_STATION) {
    ath9k_htc_choose_set_bssid(priv);
    if (bss_conf->assoc && (priv->num_sta_assoc_vif == 1))
@@ -1527,32 +1539,36 @@ static void ath9k_htc_bss_info_changed(struct ieee80211_hw *hw,
   ath_dbg(common, CONFIG, "Beacon enabled for BSS: %pM\n",
    bss_conf->bssid);
   ath9k_htc_set_tsfadjust(priv, vif);
-  set_bit(OP_ENABLE_BEACON, &priv->op_flags);
+  priv->cur_beacon_conf.enable_beacon = 1;
   ath9k_htc_beacon_config(priv, vif);
  }
 
  if ((changed & BSS_CHANGED_BEACON_ENABLED) && !bss_conf->enable_beacon) {
   /*
    * Disable SWBA interrupt only if there are no
-   * AP/IBSS interfaces.
+   * concurrent AP/mesh or IBSS interfaces.
    */
-  if ((priv->num_ap_vif <= 1) || priv->num_ibss_vif) {
+  if ((priv->num_ap_vif + priv->num_mbss_vif <= 1) ||
+       priv->num_ibss_vif) {
    ath_dbg(common, CONFIG,
     "Beacon disabled for BSS: %pM\n",
     bss_conf->bssid);
-   clear_bit(OP_ENABLE_BEACON, &priv->op_flags);
+   priv->cur_beacon_conf.enable_beacon = 0;
    ath9k_htc_beacon_config(priv, vif);
   }
  }
 
  if (changed & BSS_CHANGED_BEACON_INT) {
   /*
-   * Reset the HW TSF for the first AP interface.
+   * Reset the HW TSF for the first AP or mesh interface.
    */
-  if ((priv->ah->opmode == NL80211_IFTYPE_AP) &&
-      (priv->nvifs == 1) &&
-      (priv->num_ap_vif == 1) &&
-      (vif->type == NL80211_IFTYPE_AP)) {
+  if (priv->nvifs == 1 &&
+      ((priv->ah->opmode == NL80211_IFTYPE_AP &&
+        vif->type == NL80211_IFTYPE_AP &&
+        priv->num_ap_vif == 1) ||
+      (priv->ah->opmode == NL80211_IFTYPE_MESH_POINT &&
+        vif->type == NL80211_IFTYPE_MESH_POINT &&
+        priv->num_mbss_vif == 1))) {
    set_bit(OP_TSF_RESET, &priv->op_flags);
   }
   ath_dbg(common, CONFIG,
@@ -1563,11 +1579,21 @@ static void ath9k_htc_bss_info_changed(struct ieee80211_hw *hw,
 
  if (changed & BSS_CHANGED_ERP_SLOT) {
   if (bss_conf->use_short_slot)
-   ah->slottime = 9;
+   slottime = 9;
   else
-   ah->slottime = 20;
-
-  ath9k_hw_init_global_settings(ah);
+   slottime = 20;
+  if (vif->type == NL80211_IFTYPE_AP) {
+   /*
+    * Defer update, so that connected stations can adjust
+    * their settings at the same time.
+    * See beacon.c for more details
+    */
+   priv->beacon.slottime = slottime;
+   priv->beacon.updateslot = UPDATE;
+  } else {
+   ah->slottime = slottime;
+   ath9k_hw_init_global_settings(ah);
+  }
  }
 
  if (changed & BSS_CHANGED_HT)
@@ -1664,10 +1690,11 @@ static int ath9k_htc_ampdu_action(struct ieee80211_hw *hw,
 static void ath9k_htc_sw_scan_start(struct ieee80211_hw *hw)
 {
  struct ath9k_htc_priv *priv = hw->priv;
+ struct ath_common *common = ath9k_hw_common(priv->ah);
 
  mutex_lock(&priv->mutex);
  spin_lock_bh(&priv->beacon_lock);
- set_bit(OP_SCANNING, &priv->op_flags);
+ set_bit(ATH_OP_SCANNING, &common->op_flags);
  spin_unlock_bh(&priv->beacon_lock);
  cancel_work_sync(&priv->ps_work);
  ath9k_htc_stop_ani(priv);
@@ -1677,10 +1704,11 @@ static void ath9k_htc_sw_scan_start(struct ieee80211_hw *hw)
 static void ath9k_htc_sw_scan_complete(struct ieee80211_hw *hw)
 {
  struct ath9k_htc_priv *priv = hw->priv;
+ struct ath_common *common = ath9k_hw_common(priv->ah);
 
  mutex_lock(&priv->mutex);
  spin_lock_bh(&priv->beacon_lock);
- clear_bit(OP_SCANNING, &priv->op_flags);
+ clear_bit(ATH_OP_SCANNING, &common->op_flags);
  spin_unlock_bh(&priv->beacon_lock);
  ath9k_htc_ps_wakeup(priv);
  ath9k_htc_vif_reconfig(priv);
@@ -1770,6 +1798,43 @@ static int ath9k_htc_get_stats(struct ieee80211_hw *hw,
  return 0;
 }
 
+struct base_eep_header *ath9k_htc_get_eeprom_base(struct ath9k_htc_priv *priv)
+{
+ struct base_eep_header *pBase = NULL;
+ /*
+  * This can be done since all the 3 EEPROM families have the
+  * same base header upto a certain point, and we are interested in
+  * the data only upto that point.
+  */
+
+ if (AR_SREV_9271(priv->ah))
+  pBase = (struct base_eep_header *)
+   &priv->ah->eeprom.map4k.baseEepHeader;
+ else if (priv->ah->hw_version.usbdev == AR9280_USB)
+  pBase = (struct base_eep_header *)
+   &priv->ah->eeprom.def.baseEepHeader;
+ else if (priv->ah->hw_version.usbdev == AR9287_USB)
+  pBase = (struct base_eep_header *)
+   &priv->ah->eeprom.map9287.baseEepHeader;
+ return pBase;
+}
+
+
+static int ath9k_htc_get_antenna(struct ieee80211_hw *hw, u32 *tx_ant,
+     u32 *rx_ant)
+{
+ struct ath9k_htc_priv *priv = hw->priv;
+ struct base_eep_header *pBase = ath9k_htc_get_eeprom_base(priv);
+ if (pBase) {
+  *tx_ant = pBase->txMask;
+  *rx_ant = pBase->rxMask;
+ } else {
+  *tx_ant = 0;
+  *rx_ant = 0;
+ }
+ return 0;
+}
+
 struct ieee80211_ops ath9k_htc_ops = {
  .tx                 = ath9k_htc_tx,
  .start              = ath9k_htc_start,
@@ -1795,4 +1860,11 @@ struct ieee80211_ops ath9k_htc_ops = {
  .set_coverage_class = ath9k_htc_set_coverage_class,
  .set_bitrate_mask   = ath9k_htc_set_bitrate_mask,
  .get_stats     = ath9k_htc_get_stats,
+ .get_antenna     = ath9k_htc_get_antenna,
+
+#ifdef CONFIG_ATH9K_HTC_DEBUGFS
+ .get_et_sset_count  = ath9k_htc_get_et_sset_count,
+ .get_et_stats       = ath9k_htc_get_et_stats,
+ .get_et_strings     = ath9k_htc_get_et_strings,
+#endif
 };
diff --git a/drivers/net/wireless/ath/ath9k/htc_drv_txrx.c b/drivers/net/wireless/ath/ath9k/htc_drv_txrx.c
index 417a089..bb86eb2 100644
--- a/drivers/net/wireless/ath/ath9k/htc_drv_txrx.c
+++ b/drivers/net/wireless/ath/ath9k/htc_drv_txrx.c
@@ -471,8 +471,11 @@ static void ath9k_htc_tx_process(struct ath9k_htc_priv *priv,
  if (!txok || !vif || !txs)
   goto send_mac80211;
 
- if (txs->ts_flags & ATH9K_HTC_TXSTAT_ACK)
+ if (txs->ts_flags & ATH9K_HTC_TXSTAT_ACK) {
   tx_info->flags |= IEEE80211_TX_STAT_ACK;
+  if (tx_info->flags & IEEE80211_TX_CTL_AMPDU)
+   tx_info->flags |= IEEE80211_TX_STAT_AMPDU;
+ }
 
  if (txs->ts_flags & ATH9K_HTC_TXSTAT_FILT)
   tx_info->flags |= IEEE80211_TX_STAT_TX_FILTERED;
@@ -897,7 +900,7 @@ u32 ath9k_htc_calcrxfilter(struct ath9k_htc_priv *priv)
  if (priv->rxfilter & FIF_PSPOLL)
   rfilt |= ATH9K_RX_FILTER_PSPOLL;
 
- if (priv->nvifs > 1)
+ if (priv->nvifs > 1 || priv->rxfilter & FIF_OTHER_BSS)
   rfilt |= ATH9K_RX_FILTER_MCAST_BCAST_ALL;
 
  return rfilt;
@@ -924,46 +927,43 @@ static void ath9k_htc_opmode_init(struct ath9k_htc_priv *priv)
 
 void ath9k_host_rx_init(struct ath9k_htc_priv *priv)
 {
+ struct ath_common *common = ath9k_hw_common(priv->ah);
  ath9k_hw_rxena(priv->ah);
  ath9k_htc_opmode_init(priv);
- ath9k_hw_startpcureceive(priv->ah, test_bit(OP_SCANNING, &priv->op_flags));
- priv->rx.last_rssi = ATH_RSSI_DUMMY_MARKER;
+ ath9k_hw_startpcureceive(priv->ah, test_bit(ATH_OP_SCANNING, &common->op_flags));
 }
 
-static void ath9k_process_rate(struct ieee80211_hw *hw,
-          struct ieee80211_rx_status *rxs,
-          u8 rx_rate, u8 rs_flags)
+static inline void convert_htc_flag(struct ath_rx_status *rx_stats,
+       struct ath_htc_rx_status *rxstatus)
 {
- struct ieee80211_supported_band *sband;
- enum ieee80211_band band;
- unsigned int i = 0;
-
- if (rx_rate & 0x80) {
-  /* HT rate */
-  rxs->flag |= RX_FLAG_HT;
-  if (rs_flags & ATH9K_RX_2040)
-   rxs->flag |= RX_FLAG_40MHZ;
-  if (rs_flags & ATH9K_RX_GI)
-   rxs->flag |= RX_FLAG_SHORT_GI;
-  rxs->rate_idx = rx_rate & 0x7f;
-  return;
- }
-
- band = hw->conf.chandef.chan->band;
- sband = hw->wiphy->bands[band];
-
- for (i = 0; i < sband->n_bitrates; i++) {
-  if (sband->bitrates[i].hw_value == rx_rate) {
-   rxs->rate_idx = i;
-   return;
-  }
-  if (sband->bitrates[i].hw_value_short == rx_rate) {
-   rxs->rate_idx = i;
-   rxs->flag |= RX_FLAG_SHORTPRE;
-   return;
-  }
- }
+ rx_stats->flag = 0;
+ if (rxstatus->rs_flags & ATH9K_RX_2040)
+  rx_stats->flag |= RX_FLAG_40MHZ;
+ if (rxstatus->rs_flags & ATH9K_RX_GI)
+  rx_stats->flag |= RX_FLAG_SHORT_GI;
+}
 
+static void rx_status_htc_to_ath(struct ath_rx_status *rx_stats,
+     struct ath_htc_rx_status *rxstatus)
+{
+ rx_stats->rs_datalen = rxstatus->rs_datalen;
+ rx_stats->rs_status = rxstatus->rs_status;
+ rx_stats->rs_phyerr = rxstatus->rs_phyerr;
+ rx_stats->rs_rssi = rxstatus->rs_rssi;
+ rx_stats->rs_keyix = rxstatus->rs_keyix;
+ rx_stats->rs_rate = rxstatus->rs_rate;
+ rx_stats->rs_antenna = rxstatus->rs_antenna;
+ rx_stats->rs_more = rxstatus->rs_more;
+
+ memcpy(rx_stats->rs_rssi_ctl, rxstatus->rs_rssi_ctl,
+  sizeof(rx_stats->rs_rssi_ctl));
+ memcpy(rx_stats->rs_rssi_ext, rxstatus->rs_rssi_ext,
+  sizeof(rx_stats->rs_rssi_ext));
+
+ rx_stats->rs_isaggr = rxstatus->rs_isaggr;
+ rx_stats->rs_moreaggr = rxstatus->rs_moreaggr;
+ rx_stats->rs_num_delims = rxstatus->rs_num_delims;
+ convert_htc_flag(rx_stats, rxstatus);
 }
 
 static bool ath9k_rx_prepare(struct ath9k_htc_priv *priv,
@@ -975,10 +975,10 @@ static bool ath9k_rx_prepare(struct ath9k_htc_priv *priv,
  struct ieee80211_hw *hw = priv->hw;
  struct sk_buff *skb = rxbuf->skb;
  struct ath_common *common = ath9k_hw_common(priv->ah);
+ struct ath_hw *ah = common->ah;
  struct ath_htc_rx_status *rxstatus;
- int hdrlen, padsize;
- int last_rssi = ATH_RSSI_DUMMY_MARKER;
- __le16 fc;
+ struct ath_rx_status rx_stats;
+ bool decrypt_error;
 
  if (skb->len < HTC_RX_FRAME_HEADER_SIZE) {
   ath_err(common, "Corrupted RX frame, dropping (len: %d)\n",
@@ -996,108 +996,41 @@ static bool ath9k_rx_prepare(struct ath9k_htc_priv *priv,
   goto rx_next;
  }
 
- ath9k_htc_err_stat_rx(priv, rxstatus);
-
  /* Get the RX status information */
- memcpy(&rxbuf->rxstatus, rxstatus, HTC_RX_FRAME_HEADER_SIZE);
- skb_pull(skb, HTC_RX_FRAME_HEADER_SIZE);
-
- hdr = (struct ieee80211_hdr *)skb->data;
- fc = hdr->frame_control;
- hdrlen = ieee80211_get_hdrlen_from_skb(skb);
-
- padsize = hdrlen & 3;
- if (padsize && skb->len >= hdrlen+padsize+FCS_LEN) {
-  memmove(skb->data + padsize, skb->data, hdrlen);
-  skb_pull(skb, padsize);
- }
 
  memset(rx_status, 0, sizeof(struct ieee80211_rx_status));
 
- if (rxbuf->rxstatus.rs_status != 0) {
-  if (rxbuf->rxstatus.rs_status & ATH9K_RXERR_CRC)
-   rx_status->flag |= RX_FLAG_FAILED_FCS_CRC;
-  if (rxbuf->rxstatus.rs_status & ATH9K_RXERR_PHY)
-   goto rx_next;
-
-  if (rxbuf->rxstatus.rs_status & ATH9K_RXERR_DECRYPT) {
-   /* FIXME */
-  } else if (rxbuf->rxstatus.rs_status & ATH9K_RXERR_MIC) {
-   if (ieee80211_is_ctl(fc))
-    /*
-     * Sometimes, we get invalid
-     * MIC failures on valid control frames.
-     * Remove these mic errors.
-     */
-    rxbuf->rxstatus.rs_status &= ~ATH9K_RXERR_MIC;
-   else
-    rx_status->flag |= RX_FLAG_MMIC_ERROR;
-  }
-
-  /*
-   * Reject error frames with the exception of
-   * decryption and MIC failures. For monitor mode,
-   * we also ignore the CRC error.
-   */
-  if (priv->ah->opmode == NL80211_IFTYPE_MONITOR) {
-   if (rxbuf->rxstatus.rs_status &
-       ~(ATH9K_RXERR_DECRYPT | ATH9K_RXERR_MIC |
-         ATH9K_RXERR_CRC))
-    goto rx_next;
-  } else {
-   if (rxbuf->rxstatus.rs_status &
-       ~(ATH9K_RXERR_DECRYPT | ATH9K_RXERR_MIC)) {
-    goto rx_next;
-   }
-  }
- }
-
- if (!(rxbuf->rxstatus.rs_status & ATH9K_RXERR_DECRYPT)) {
-  u8 keyix;
-  keyix = rxbuf->rxstatus.rs_keyix;
-  if (keyix != ATH9K_RXKEYIX_INVALID) {
-   rx_status->flag |= RX_FLAG_DECRYPTED;
-  } else if (ieee80211_has_protected(fc) &&
-      skb->len >= hdrlen + 4) {
-   keyix = skb->data[hdrlen + 3] >> 6;
-   if (test_bit(keyix, common->keymap))
-    rx_status->flag |= RX_FLAG_DECRYPTED;
-  }
- }
-
- ath9k_process_rate(hw, rx_status, rxbuf->rxstatus.rs_rate,
-      rxbuf->rxstatus.rs_flags);
-
- if (rxbuf->rxstatus.rs_rssi != ATH9K_RSSI_BAD &&
-     !rxbuf->rxstatus.rs_moreaggr)
-  ATH_RSSI_LPF(priv->rx.last_rssi,
-        rxbuf->rxstatus.rs_rssi);
-
- last_rssi = priv->rx.last_rssi;
+ /* Copy everything from ath_htc_rx_status (HTC_RX_FRAME_HEADER).
+  * After this, we can drop this part of skb. */
+ rx_status_htc_to_ath(&rx_stats, rxstatus);
+ ath9k_htc_err_stat_rx(priv, &rx_stats);
+ rx_status->mactime = be64_to_cpu(rxstatus->rs_tstamp);
+ skb_pull(skb, HTC_RX_FRAME_HEADER_SIZE);
 
- if (ieee80211_is_beacon(hdr->frame_control) &&
-     !is_zero_ether_addr(common->curbssid) &&
-     ether_addr_equal(hdr->addr3, common->curbssid)) {
-  s8 rssi = rxbuf->rxstatus.rs_rssi;
+ /*
+  * everything but the rate is checked here, the rate check is done
+  * separately to avoid doing two lookups for a rate for each frame.
+  */
+ hdr = (struct ieee80211_hdr *)skb->data;
+ if (!ath9k_cmn_rx_accept(common, hdr, rx_status, &rx_stats,
+   &decrypt_error, priv->rxfilter))
+  goto rx_next;
 
-  if (likely(last_rssi != ATH_RSSI_DUMMY_MARKER))
-   rssi = ATH_EP_RND(last_rssi, ATH_RSSI_EP_MULTIPLIER);
+ ath9k_cmn_rx_skb_postprocess(common, skb, &rx_stats,
+         rx_status, decrypt_error);
 
-  if (rssi < 0)
-   rssi = 0;
+ if (ath9k_cmn_process_rate(common, hw, &rx_stats, rx_status))
+  goto rx_next;
 
-  priv->ah->stats.avgbrssi = rssi;
- }
+ rx_stats.is_mybeacon = ath_is_mybeacon(common, hdr);
+ ath9k_cmn_process_rssi(common, hw, &rx_stats, rx_status);
 
- rx_status->mactime = be64_to_cpu(rxbuf->rxstatus.rs_tstamp);
- rx_status->band = hw->conf.chandef.chan->band;
- rx_status->freq = hw->conf.chandef.chan->center_freq;
- rx_status->signal =  rxbuf->rxstatus.rs_rssi + ATH_DEFAULT_NOISE_FLOOR;
- rx_status->antenna = rxbuf->rxstatus.rs_antenna;
+ rx_status->band = ah->curchan->chan->band;
+ rx_status->freq = ah->curchan->chan->center_freq;
+ rx_status->antenna = rx_stats.rs_antenna;
  rx_status->flag |= RX_FLAG_MACTIME_END;
 
  return true;
-
 rx_next:
  return false;
 }
diff --git a/drivers/net/wireless/ath/ath9k/htc_hst.c b/drivers/net/wireless/ath/ath9k/htc_hst.c
index aac4a40..a0ff5b6 100644
--- a/drivers/net/wireless/ath/ath9k/htc_hst.c
+++ b/drivers/net/wireless/ath/ath9k/htc_hst.c
@@ -358,6 +358,36 @@ ret:
   kfree_skb(skb);
 }
 
+static void ath9k_htc_fw_panic_report(struct htc_target *htc_handle,
+          struct sk_buff *skb)
+{
+ uint32_t *pattern = (uint32_t *)skb->data;
+
+ switch (*pattern) {
+ case 0x33221199:
+  {
+  struct htc_panic_bad_vaddr *htc_panic;
+  htc_panic = (struct htc_panic_bad_vaddr *) skb->data;
+  dev_err(htc_handle->dev, "ath: firmware panic! "
+   "exccause: 0x%08x; pc: 0x%08x; badvaddr: 0x%08x.\n",
+   htc_panic->exccause, htc_panic->pc,
+   htc_panic->badvaddr);
+  break;
+  }
+ case 0x33221299:
+  {
+  struct htc_panic_bad_epid *htc_panic;
+  htc_panic = (struct htc_panic_bad_epid *) skb->data;
+  dev_err(htc_handle->dev, "ath: firmware panic! "
+   "bad epid: 0x%08x\n", htc_panic->epid);
+  break;
+  }
+ default:
+  dev_err(htc_handle->dev, "ath: uknown panic pattern!\n");
+  break;
+ }
+}
+
 /*
  * HTC Messages are handled directly here and the obtained SKB
  * is freed.
@@ -379,6 +409,12 @@ void ath9k_htc_rx_msg(struct htc_target *htc_handle,
  htc_hdr = (struct htc_frame_hdr *) skb->data;
  epid = htc_hdr->endpoint_id;
 
+ if (epid == 0x99) {
+  ath9k_htc_fw_panic_report(htc_handle, skb);
+  kfree_skb(skb);
+  return;
+ }
+
  if (epid >= ENDPOINT_MAX) {
   if (pipe_id != USB_REG_IN_PIPE)
    dev_kfree_skb_any(skb);
diff --git a/drivers/net/wireless/ath/ath9k/htc_hst.h b/drivers/net/wireless/ath/ath9k/htc_hst.h
index e1ffbb6..06474cc 100644
--- a/drivers/net/wireless/ath/ath9k/htc_hst.h
+++ b/drivers/net/wireless/ath/ath9k/htc_hst.h
@@ -77,6 +77,18 @@ struct htc_config_pipe_msg {
  u8 credits;
 } __packed;
 
+struct htc_panic_bad_vaddr {
+ __be32 pattern;
+ __be32 exccause;
+ __be32 pc;
+ __be32 badvaddr;
+} __packed;
+
+struct htc_panic_bad_epid {
+ __be32 pattern;
+ __be32 epid;
+} __packed;
+
 struct htc_ep_callbacks {
  void *priv;
  void (*tx) (void *, struct sk_buff *, enum htc_endpoint_id, bool txok);
diff --git a/drivers/net/wireless/ath/ath9k/hw-ops.h b/drivers/net/wireless/ath/ath9k/hw-ops.h
index 14b7011..a47ea84 100644
--- a/drivers/net/wireless/ath/ath9k/hw-ops.h
+++ b/drivers/net/wireless/ath/ath9k/hw-ops.h
@@ -49,9 +49,10 @@ static inline bool ath9k_hw_calibrate(struct ath_hw *ah,
  return ath9k_hw_ops(ah)->calibrate(ah, chan, rxchainmask, longcal);
 }
 
-static inline bool ath9k_hw_getisr(struct ath_hw *ah, enum ath9k_int *masked)
+static inline bool ath9k_hw_getisr(struct ath_hw *ah, enum ath9k_int *masked,
+       u32 *sync_cause_p)
 {
- return ath9k_hw_ops(ah)->get_isr(ah, masked);
+ return ath9k_hw_ops(ah)->get_isr(ah, masked, sync_cause_p);
 }
 
 static inline void ath9k_hw_set_txdesc(struct ath_hw *ah, void *ds,
@@ -78,15 +79,49 @@ static inline void ath9k_hw_antdiv_comb_conf_set(struct ath_hw *ah,
  ath9k_hw_ops(ah)->antdiv_comb_conf_set(ah, antconf);
 }
 
-static inline void ath9k_hw_antctrl_shared_chain_lnadiv(struct ath_hw *ah,
-       bool enable)
+static inline void ath9k_hw_tx99_start(struct ath_hw *ah, u32 qnum)
 {
- if (ath9k_hw_ops(ah)->antctrl_shared_chain_lnadiv)
-  ath9k_hw_ops(ah)->antctrl_shared_chain_lnadiv(ah, enable);
+ ath9k_hw_ops(ah)->tx99_start(ah, qnum);
 }
 
+static inline void ath9k_hw_tx99_stop(struct ath_hw *ah)
+{
+ ath9k_hw_ops(ah)->tx99_stop(ah);
+}
+
+static inline void ath9k_hw_tx99_set_txpower(struct ath_hw *ah, u8 power)
+{
+ if (ath9k_hw_ops(ah)->tx99_set_txpower)
+  ath9k_hw_ops(ah)->tx99_set_txpower(ah, power);
+}
+
+#ifdef CONFIG_ATH9K_BTCOEX_SUPPORT
+
+static inline void ath9k_hw_set_bt_ant_diversity(struct ath_hw *ah, bool enable)
+{
+ if (ath9k_hw_ops(ah)->set_bt_ant_diversity)
+  ath9k_hw_ops(ah)->set_bt_ant_diversity(ah, enable);
+}
+
+#endif
+
 /* Private hardware call ops */
 
+static inline void ath9k_hw_init_hang_checks(struct ath_hw *ah)
+{
+ ath9k_hw_private_ops(ah)->init_hang_checks(ah);
+}
+
+static inline bool ath9k_hw_detect_mac_hang(struct ath_hw *ah)
+{
+ return ath9k_hw_private_ops(ah)->detect_mac_hang(ah);
+}
+
+static inline bool ath9k_hw_detect_bb_hang(struct ath_hw *ah)
+{
+ return ath9k_hw_private_ops(ah)->detect_bb_hang(ah);
+}
+
 /* PHY ops */
 
 static inline int ath9k_hw_rf_set_freq(struct ath_hw *ah,
@@ -212,4 +247,31 @@ static inline void ath9k_hw_set_radar_params(struct ath_hw *ah)
  ath9k_hw_private_ops(ah)->set_radar_params(ah, &ah->radar_conf);
 }
 
+static inline void ath9k_hw_init_cal_settings(struct ath_hw *ah)
+{
+ ath9k_hw_private_ops(ah)->init_cal_settings(ah);
+}
+
+static inline u32 ath9k_hw_compute_pll_control(struct ath_hw *ah,
+            struct ath9k_channel *chan)
+{
+ return ath9k_hw_private_ops(ah)->compute_pll_control(ah, chan);
+}
+
+static inline void ath9k_hw_init_mode_gain_regs(struct ath_hw *ah)
+{
+ if (!ath9k_hw_private_ops(ah)->init_mode_gain_regs)
+  return;
+
+ ath9k_hw_private_ops(ah)->init_mode_gain_regs(ah);
+}
+
+static inline void ath9k_hw_ani_cache_ini_regs(struct ath_hw *ah)
+{
+ if (!ath9k_hw_private_ops(ah)->ani_cache_ini_regs)
+  return;
+
+ ath9k_hw_private_ops(ah)->ani_cache_ini_regs(ah);
+}
+
 #endif /* ATH9K_HW_OPS_H */
diff --git a/drivers/net/wireless/ath/ath9k/hw.c b/drivers/net/wireless/ath/ath9k/hw.c
index b1d5037..2a8ed83 100644
--- a/drivers/net/wireless/ath/ath9k/hw.c
+++ b/drivers/net/wireless/ath/ath9k/hw.c
@@ -17,15 +17,15 @@
 #include <linux/io.h>
 #include <linux/slab.h>
 #include <linux/module.h>
+#include <linux/time.h>
+#include <linux/bitops.h>
 #include <asm/unaligned.h>
 
 #include "hw.h"
 #include "hw-ops.h"
-#include "rc.h"
 #include "ar9003_mac.h"
 #include "ar9003_mci.h"
 #include "ar9003_phy.h"
-#include "debug.h"
 #include "ath9k.h"
 
 static bool ath9k_hw_set_reset_reg(struct ath_hw *ah, u32 type);
@@ -35,124 +35,30 @@ MODULE_DESCRIPTION("Support for Atheros 802.11n wireless LAN cards.");
 MODULE_SUPPORTED_DEVICE("Atheros 802.11n WLAN cards");
 MODULE_LICENSE("Dual BSD/GPL");
 
-static int __init ath9k_init(void)
-{
- return 0;
-}
-module_init(ath9k_init);
-
-static void __exit ath9k_exit(void)
-{
- return;
-}
-module_exit(ath9k_exit);
-
-/* Private hardware callbacks */
-
-static void ath9k_hw_init_cal_settings(struct ath_hw *ah)
-{
- ath9k_hw_private_ops(ah)->init_cal_settings(ah);
-}
-
-static u32 ath9k_hw_compute_pll_control(struct ath_hw *ah,
-     struct ath9k_channel *chan)
-{
- return ath9k_hw_private_ops(ah)->compute_pll_control(ah, chan);
-}
-
-static void ath9k_hw_init_mode_gain_regs(struct ath_hw *ah)
-{
- if (!ath9k_hw_private_ops(ah)->init_mode_gain_regs)
-  return;
-
- ath9k_hw_private_ops(ah)->init_mode_gain_regs(ah);
-}
-
-static void ath9k_hw_ani_cache_ini_regs(struct ath_hw *ah)
-{
- /* You will not have this callback if using the old ANI */
- if (!ath9k_hw_private_ops(ah)->ani_cache_ini_regs)
-  return;
-
- ath9k_hw_private_ops(ah)->ani_cache_ini_regs(ah);
-}
-
-/********************/
-/* Helper Functions */
-/********************/
-
-#ifdef CONFIG_ATH9K_DEBUGFS
-
-void ath9k_debug_sync_cause(struct ath_common *common, u32 sync_cause)
-{
- struct ath_softc *sc = common->priv;
- if (sync_cause)
-  sc->debug.stats.istats.sync_cause_all++;
- if (sync_cause & AR_INTR_SYNC_RTC_IRQ)
-  sc->debug.stats.istats.sync_rtc_irq++;
- if (sync_cause & AR_INTR_SYNC_MAC_IRQ)
-  sc->debug.stats.istats.sync_mac_irq++;
- if (sync_cause & AR_INTR_SYNC_EEPROM_ILLEGAL_ACCESS)
-  sc->debug.stats.istats.eeprom_illegal_access++;
- if (sync_cause & AR_INTR_SYNC_APB_TIMEOUT)
-  sc->debug.stats.istats.apb_timeout++;
- if (sync_cause & AR_INTR_SYNC_PCI_MODE_CONFLICT)
-  sc->debug.stats.istats.pci_mode_conflict++;
- if (sync_cause & AR_INTR_SYNC_HOST1_FATAL)
-  sc->debug.stats.istats.host1_fatal++;
- if (sync_cause & AR_INTR_SYNC_HOST1_PERR)
-  sc->debug.stats.istats.host1_perr++;
- if (sync_cause & AR_INTR_SYNC_TRCV_FIFO_PERR)
-  sc->debug.stats.istats.trcv_fifo_perr++;
- if (sync_cause & AR_INTR_SYNC_RADM_CPL_EP)
-  sc->debug.stats.istats.radm_cpl_ep++;
- if (sync_cause & AR_INTR_SYNC_RADM_CPL_DLLP_ABORT)
-  sc->debug.stats.istats.radm_cpl_dllp_abort++;
- if (sync_cause & AR_INTR_SYNC_RADM_CPL_TLP_ABORT)
-  sc->debug.stats.istats.radm_cpl_tlp_abort++;
- if (sync_cause & AR_INTR_SYNC_RADM_CPL_ECRC_ERR)
-  sc->debug.stats.istats.radm_cpl_ecrc_err++;
- if (sync_cause & AR_INTR_SYNC_RADM_CPL_TIMEOUT)
-  sc->debug.stats.istats.radm_cpl_timeout++;
- if (sync_cause & AR_INTR_SYNC_LOCAL_TIMEOUT)
-  sc->debug.stats.istats.local_timeout++;
- if (sync_cause & AR_INTR_SYNC_PM_ACCESS)
-  sc->debug.stats.istats.pm_access++;
- if (sync_cause & AR_INTR_SYNC_MAC_AWAKE)
-  sc->debug.stats.istats.mac_awake++;
- if (sync_cause & AR_INTR_SYNC_MAC_ASLEEP)
-  sc->debug.stats.istats.mac_asleep++;
- if (sync_cause & AR_INTR_SYNC_MAC_SLEEP_ACCESS)
-  sc->debug.stats.istats.mac_sleep_access++;
-}
-#endif
-
-
 static void ath9k_hw_set_clockrate(struct ath_hw *ah)
 {
- struct ieee80211_conf *conf = &ath9k_hw_common(ah)->hw->conf;
  struct ath_common *common = ath9k_hw_common(ah);
+ struct ath9k_channel *chan = ah->curchan;
  unsigned int clockrate;
 
  /* AR9287 v1.3+ uses async FIFO and runs the MAC at 117 MHz */
  if (AR_SREV_9287(ah) && AR_SREV_9287_13_OR_LATER(ah))
   clockrate = 117;
- else if (!ah->curchan) /* should really check for CCK instead */
+ else if (!chan) /* should really check for CCK instead */
   clockrate = ATH9K_CLOCK_RATE_CCK;
- else if (conf->chandef.chan->band == IEEE80211_BAND_2GHZ)
+ else if (IS_CHAN_2GHZ(chan))
   clockrate = ATH9K_CLOCK_RATE_2GHZ_OFDM;
  else if (ah->caps.hw_caps & ATH9K_HW_CAP_FASTCLOCK)
   clockrate = ATH9K_CLOCK_FAST_RATE_5GHZ_OFDM;
  else
   clockrate = ATH9K_CLOCK_RATE_5GHZ_OFDM;
 
- if (conf_is_ht40(conf))
-  clockrate *= 2;
-
- if (ah->curchan) {
-  if (IS_CHAN_HALF_RATE(ah->curchan))
+ if (chan) {
+  if (IS_CHAN_HT40(chan))
+   clockrate *= 2;
+  if (IS_CHAN_HALF_RATE(chan))
    clockrate /= 2;
-  if (IS_CHAN_QUARTER_RATE(ah->curchan))
+  if (IS_CHAN_QUARTER_RATE(chan))
    clockrate /= 4;
  }
 
@@ -190,10 +96,7 @@ EXPORT_SYMBOL(ath9k_hw_wait);
 void ath9k_hw_synth_delay(struct ath_hw *ah, struct ath9k_channel *chan,
      int hw_delay)
 {
- if (IS_CHAN_B(chan))
-  hw_delay = (4 * hw_delay) / 22;
- else
-  hw_delay /= 10;
+ hw_delay /= 10;
 
  if (IS_CHAN_HALF_RATE(chan))
   hw_delay *= 2;
@@ -294,8 +197,7 @@ void ath9k_hw_get_channel_centers(struct ath_hw *ah,
   return;
  }
 
- if ((chan->chanmode == CHANNEL_A_HT40PLUS) ||
-     (chan->chanmode == CHANNEL_G_HT40PLUS)) {
+ if (IS_CHAN_HT40PLUS(chan)) {
   centers->synth_center =
    chan->channel + HT40_CHANNEL_CENTER_SHIFT;
   extoff = 1;
@@ -341,6 +243,11 @@ static void ath9k_hw_read_revisions(struct ath_hw *ah)
  case AR9300_DEVID_QCA955X:
   ah->hw_version.macVersion = AR_SREV_VERSION_9550;
   return;
+ case AR9300_DEVID_AR953X:
+  ah->hw_version.macVersion = AR_SREV_VERSION_9531;
+  if (ah->get_mac_revision)
+   ah->hw_version.macRev = ah->get_mac_revision();
+  return;
  }
 
  val = REG_READ(ah, AR_SREV) & AR_SREV_ID;
@@ -442,25 +349,22 @@ static bool ath9k_hw_chip_test(struct ath_hw *ah)
 
 static void ath9k_hw_init_config(struct ath_hw *ah)
 {
- int i;
+ struct ath_common *common = ath9k_hw_common(ah);
 
  ah->config.dma_beacon_response_time = 1;
  ah->config.sw_beacon_response_time = 6;
- ah->config.additional_swba_backoff = 0;
- ah->config.ack_6mb = 0x0;
  ah->config.cwm_ignore_extcca = 0;
- ah->config.pcie_clock_req = 0;
- ah->config.pcie_waen = 0;
  ah->config.analog_shiftreg = 1;
- ah->config.enable_ani = true;
-
- for (i = 0; i < AR_EEPROM_MODAL_SPURS; i++) {
-  ah->config.spurchans[i][0] = AR_NO_SPUR;
-  ah->config.spurchans[i][1] = AR_NO_SPUR;
- }
 
  ah->config.rx_intr_mitigation = true;
- ah->config.pcieSerDesWrite = true;
+
+ if (AR_SREV_9300_20_OR_LATER(ah)) {
+  ah->config.rimt_last = 500;
+  ah->config.rimt_first = 2000;
+ } else {
+  ah->config.rimt_last = 250;
+  ah->config.rimt_first = 700;
+ }
 
  /*
   * We need this for PCI devices only (Cardbus, PCI, miniPCI)
@@ -480,6 +384,24 @@ static void ath9k_hw_init_config(struct ath_hw *ah)
   */
  if (num_possible_cpus() > 1)
   ah->config.serialize_regmode = SER_REG_MODE_AUTO;
+
+ if (NR_CPUS > 1 && ah->config.serialize_regmode == SER_REG_MODE_AUTO) {
+  if (ah->hw_version.macVersion == AR_SREV_VERSION_5416_PCI ||
+      ((AR_SREV_9160(ah) || AR_SREV_9280(ah) || AR_SREV_9287(ah)) &&
+       !ah->is_pciexpress)) {
+   ah->config.serialize_regmode = SER_REG_MODE_ON;
+  } else {
+   ah->config.serialize_regmode = SER_REG_MODE_OFF;
+  }
+ }
+
+ ath_dbg(common, RESET, "serialize_regmode is %d\n",
+  ah->config.serialize_regmode);
+
+ if (AR_SREV_9285(ah) || AR_SREV_9271(ah))
+  ah->config.max_txtrig_level = MAX_TX_FIFO_THRESHOLD >> 1;
+ else
+  ah->config.max_txtrig_level = MAX_TX_FIFO_THRESHOLD;
 }
 
 static void ath9k_hw_init_defaults(struct ath_hw *ah)
@@ -492,16 +414,24 @@ static void ath9k_hw_init_defaults(struct ath_hw *ah)
  ah->hw_version.magic = AR5416_MAGIC;
  ah->hw_version.subvendorid = 0;
 
- ah->atim_window = 0;
- ah->sta_id1_defaults =
-  AR_STA_ID1_CRPT_MIC_ENABLE |
-  AR_STA_ID1_MCAST_KSRCH;
+ ah->sta_id1_defaults = AR_STA_ID1_CRPT_MIC_ENABLE |
+          AR_STA_ID1_MCAST_KSRCH;
  if (AR_SREV_9100(ah))
   ah->sta_id1_defaults |= AR_STA_ID1_AR9100_BA_FIX;
+
  ah->slottime = ATH9K_SLOT_TIME_9;
  ah->globaltxtimeout = (u32) -1;
  ah->power_mode = ATH9K_PM_UNDEFINED;
  ah->htc_reset_init = true;
+
+ ah->ani_function = ATH9K_ANI_ALL;
+ if (!AR_SREV_9300_20_OR_LATER(ah))
+  ah->ani_function &= ~ATH9K_ANI_MRC_CCK;
+
+ if (AR_SREV_9285(ah) || AR_SREV_9271(ah))
+  ah->tx_trig_level = (AR_FTRIG_256B >> AR_FTRIG_S);
+ else
+  ah->tx_trig_level = (AR_FTRIG_512B >> AR_FTRIG_S);
 }
 
 static int ath9k_hw_init_macaddr(struct ath_hw *ah)
@@ -549,8 +479,19 @@ static int ath9k_hw_post_init(struct ath_hw *ah)
   ah->eep_ops->get_eeprom_ver(ah),
   ah->eep_ops->get_eeprom_rev(ah));
 
- if (ah->config.enable_ani)
-  ath9k_hw_ani_init(ah);
+ ath9k_hw_ani_init(ah);
+
+ /*
+  * EEPROM needs to be initialized before we do this.
+  * This is required for regulatory compliance.
+  */
+ if (AR_SREV_9300_20_OR_LATER(ah)) {
+  u16 regdmn = ah->eep_ops->get_eeprom(ah, EEP_REG_0);
+  if ((regdmn & 0xF0) == CTL_FCC) {
+   ah->nf_2g.max = AR_PHY_CCA_MAX_GOOD_VAL_9300_FCC_2GHZ;
+   ah->nf_5g.max = AR_PHY_CCA_MAX_GOOD_VAL_9300_FCC_5GHZ;
+  }
+ }
 
  return 0;
 }
@@ -572,23 +513,47 @@ static int __ath9k_hw_init(struct ath_hw *ah)
 
  ath9k_hw_read_revisions(ah);
 
+ switch (ah->hw_version.macVersion) {
+ case AR_SREV_VERSION_5416_PCI:
+ case AR_SREV_VERSION_5416_PCIE:
+ case AR_SREV_VERSION_9160:
+ case AR_SREV_VERSION_9100:
+ case AR_SREV_VERSION_9280:
+ case AR_SREV_VERSION_9285:
+ case AR_SREV_VERSION_9287:
+ case AR_SREV_VERSION_9271:
+ case AR_SREV_VERSION_9300:
+ case AR_SREV_VERSION_9330:
+ case AR_SREV_VERSION_9485:
+ case AR_SREV_VERSION_9340:
+ case AR_SREV_VERSION_9462:
+ case AR_SREV_VERSION_9550:
+ case AR_SREV_VERSION_9565:
+ case AR_SREV_VERSION_9531:
+  break;
+ default:
+  ath_err(common,
+   "Mac Chip Rev 0x%02x.%x is not supported by this driver\n",
+   ah->hw_version.macVersion, ah->hw_version.macRev);
+  return -EOPNOTSUPP;
+ }
+
  /*
   * Read back AR_WA into a permanent copy and set bits 14 and 17.
   * We need to do this to avoid RMW of this register. We cannot
   * read the reg when chip is asleep.
   */
- ah->WARegVal = REG_READ(ah, AR_WA);
- ah->WARegVal |= (AR_WA_D3_L1_DISABLE |
-    AR_WA_ASPM_TIMER_BASED_DISABLE);
+ if (AR_SREV_9300_20_OR_LATER(ah)) {
+  ah->WARegVal = REG_READ(ah, AR_WA);
+  ah->WARegVal |= (AR_WA_D3_L1_DISABLE |
+     AR_WA_ASPM_TIMER_BASED_DISABLE);
+ }
 
  if (!ath9k_hw_set_reset_reg(ah, ATH9K_RESET_POWER_ON)) {
   ath_err(common, "Couldn't reset chip\n");
   return -EIO;
  }
 
- if (AR_SREV_9462(ah))
-  ah->WARegVal &= ~AR_WA_D3_L1_DISABLE;
-
  if (AR_SREV_9565(ah)) {
   ah->WARegVal |= AR_WA_BIT22;
   REG_WRITE(ah, AR_WA, ah->WARegVal);
@@ -606,50 +571,6 @@ static int __ath9k_hw_init(struct ath_hw *ah)
   return -EIO;
  }
 
- if (NR_CPUS > 1 && ah->config.serialize_regmode == SER_REG_MODE_AUTO) {
-  if (ah->hw_version.macVersion == AR_SREV_VERSION_5416_PCI ||
-      ((AR_SREV_9160(ah) || AR_SREV_9280(ah) || AR_SREV_9287(ah)) &&
-       !ah->is_pciexpress)) {
-   ah->config.serialize_regmode =
-    SER_REG_MODE_ON;
-  } else {
-   ah->config.serialize_regmode =
-    SER_REG_MODE_OFF;
-  }
- }
-
- ath_dbg(common, RESET, "serialize_regmode is %d\n",
-  ah->config.serialize_regmode);
-
- if (AR_SREV_9285(ah) || AR_SREV_9271(ah))
-  ah->config.max_txtrig_level = MAX_TX_FIFO_THRESHOLD >> 1;
- else
-  ah->config.max_txtrig_level = MAX_TX_FIFO_THRESHOLD;
-
- switch (ah->hw_version.macVersion) {
- case AR_SREV_VERSION_5416_PCI:
- case AR_SREV_VERSION_5416_PCIE:
- case AR_SREV_VERSION_9160:
- case AR_SREV_VERSION_9100:
- case AR_SREV_VERSION_9280:
- case AR_SREV_VERSION_9285:
- case AR_SREV_VERSION_9287:
- case AR_SREV_VERSION_9271:
- case AR_SREV_VERSION_9300:
- case AR_SREV_VERSION_9330:
- case AR_SREV_VERSION_9485:
- case AR_SREV_VERSION_9340:
- case AR_SREV_VERSION_9462:
- case AR_SREV_VERSION_9550:
- case AR_SREV_VERSION_9565:
-  break;
- default:
-  ath_err(common,
-   "Mac Chip Rev 0x%02x.%x is not supported by this driver\n",
-   ah->hw_version.macVersion, ah->hw_version.macRev);
-  return -EOPNOTSUPP;
- }
-
  if (AR_SREV_9271(ah) || AR_SREV_9100(ah) || AR_SREV_9340(ah) ||
      AR_SREV_9330(ah) || AR_SREV_9550(ah))
   ah->is_pciexpress = false;
@@ -657,12 +578,6 @@ static int __ath9k_hw_init(struct ath_hw *ah)
  ah->hw_version.phyRev = REG_READ(ah, AR_PHY_CHIP_ID);
  ath9k_hw_init_cal_settings(ah);
 
- ah->ani_function = ATH9K_ANI_ALL;
- if (AR_SREV_9280_20_OR_LATER(ah) && !AR_SREV_9300_20_OR_LATER(ah))
-  ah->ani_function &= ~ATH9K_ANI_NOISE_IMMUNITY_LEVEL;
- if (!AR_SREV_9300_20_OR_LATER(ah))
-  ah->ani_function &= ~ATH9K_ANI_MRC_CCK;
-
  if (!ah->is_pciexpress)
   ath9k_hw_disablepcie(ah);
 
@@ -681,15 +596,7 @@ static int __ath9k_hw_init(struct ath_hw *ah)
   return r;
  }
 
- if (AR_SREV_9285(ah) || AR_SREV_9271(ah))
-  ah->tx_trig_level = (AR_FTRIG_256B >> AR_FTRIG_S);
- else
-  ah->tx_trig_level = (AR_FTRIG_512B >> AR_FTRIG_S);
-
- if (AR_SREV_9330(ah))
-  ah->bb_watchdog_timeout_ms = 85;
- else
-  ah->bb_watchdog_timeout_ms = 25;
+ ath9k_hw_init_hang_checks(ah);
 
  common->state = ATH_HW_INITIALIZED;
 
@@ -722,6 +629,7 @@ int ath9k_hw_init(struct ath_hw *ah)
  case AR9300_DEVID_AR9462:
  case AR9485_DEVID_AR1111:
  case AR9300_DEVID_AR9565:
+ case AR9300_DEVID_AR953X:
   break;
  default:
   if (common->bus_ops->ath_bus_type == ATH_USB)
@@ -857,7 +765,7 @@ static void ath9k_hw_init_pll(struct ath_hw *ah,
   /* program BB PLL phase_shift */
   REG_RMW_FIELD(ah, AR_CH0_BB_DPLL3,
          AR_CH0_BB_DPLL3_PHASE_SHIFT, 0x1);
- } else if (AR_SREV_9340(ah) || AR_SREV_9550(ah)) {
+ } else if (AR_SREV_9340(ah) || AR_SREV_9550(ah) || AR_SREV_9531(ah)) {
   u32 regval, pll2_divint, pll2_divfrac, refdiv;
 
   REG_WRITE(ah, AR_RTC_PLL_CONTROL, 0x1142c);
@@ -867,9 +775,15 @@ static void ath9k_hw_init_pll(struct ath_hw *ah,
   udelay(100);
 
   if (ah->is_clk_25mhz) {
-   pll2_divint = 0x54;
-   pll2_divfrac = 0x1eb85;
-   refdiv = 3;
+   if (AR_SREV_9531(ah)) {
+    pll2_divint = 0x1c;
+    pll2_divfrac = 0xa3d2;
+    refdiv = 1;
+   } else {
+    pll2_divint = 0x54;
+    pll2_divfrac = 0x1eb85;
+    refdiv = 3;
+   }
   } else {
    if (AR_SREV_9340(ah)) {
     pll2_divint = 88;
@@ -883,7 +797,10 @@ static void ath9k_hw_init_pll(struct ath_hw *ah,
   }
 
   regval = REG_READ(ah, AR_PHY_PLL_MODE);
-  regval |= (0x1 << 16);
+  if (AR_SREV_9531(ah))
+   regval |= (0x1 << 22);
+  else
+   regval |= (0x1 << 16);
   REG_WRITE(ah, AR_PHY_PLL_MODE, regval);
   udelay(100);
 
@@ -893,14 +810,33 @@ static void ath9k_hw_init_pll(struct ath_hw *ah,
 
   regval = REG_READ(ah, AR_PHY_PLL_MODE);
   if (AR_SREV_9340(ah))
-   regval = (regval & 0x80071fff) | (0x1 << 30) |
-     (0x1 << 13) | (0x4 << 26) | (0x18 << 19);
+   regval = (regval & 0x80071fff) |
+    (0x1 << 30) |
+    (0x1 << 13) |
+    (0x4 << 26) |
+    (0x18 << 19);
+  else if (AR_SREV_9531(ah))
+   regval = (regval & 0x01c00fff) |
+    (0x1 << 31) |
+    (0x2 << 29) |
+    (0xa << 25) |
+    (0x1 << 19) |
+    (0x6 << 12);
   else
-   regval = (regval & 0x80071fff) | (0x3 << 30) |
-     (0x1 << 13) | (0x4 << 26) | (0x60 << 19);
+   regval = (regval & 0x80071fff) |
+    (0x3 << 30) |
+    (0x1 << 13) |
+    (0x4 << 26) |
+    (0x60 << 19);
   REG_WRITE(ah, AR_PHY_PLL_MODE, regval);
-  REG_WRITE(ah, AR_PHY_PLL_MODE,
-     REG_READ(ah, AR_PHY_PLL_MODE) & 0xfffeffff);
+
+  if (AR_SREV_9531(ah))
+   REG_WRITE(ah, AR_PHY_PLL_MODE,
+      REG_READ(ah, AR_PHY_PLL_MODE) & 0xffbfffff);
+  else
+   REG_WRITE(ah, AR_PHY_PLL_MODE,
+      REG_READ(ah, AR_PHY_PLL_MODE) & 0xfffeffff);
+
   udelay(1000);
  }
 
@@ -947,7 +883,7 @@ static void ath9k_hw_init_interrupt_masks(struct ath_hw *ah,
   AR_IMR_RXORN |
   AR_IMR_BCNMISC;
 
- if (AR_SREV_9340(ah) || AR_SREV_9550(ah))
+ if (AR_SREV_9340(ah) || AR_SREV_9550(ah) || AR_SREV_9531(ah))
   sync_default &= ~AR_INTR_SYNC_HOST1_FATAL;
 
  if (AR_SREV_9300_20_OR_LATER(ah)) {
@@ -1036,7 +972,6 @@ static bool ath9k_hw_set_global_txtimeout(struct ath_hw *ah, u32 tu)
 void ath9k_hw_init_global_settings(struct ath_hw *ah)
 {
  struct ath_common *common = ath9k_hw_common(ah);
- struct ieee80211_conf *conf = &common->hw->conf;
  const struct ath9k_channel *chan = ah->curchan;
  int acktimeout, ctstimeout, ack_offset = 0;
  int slottime;
@@ -1071,7 +1006,7 @@ void ath9k_hw_init_global_settings(struct ath_hw *ah)
   if (IS_CHAN_A_FAST_CLOCK(ah, chan))
       tx_lat += 11;
 
-  sifstime *= 2;
+  sifstime = 32;
   ack_offset = 16;
   slottime = 13;
  } else if (IS_CHAN_QUARTER_RATE(chan)) {
@@ -1081,7 +1016,7 @@ void ath9k_hw_init_global_settings(struct ath_hw *ah)
   if (IS_CHAN_A_FAST_CLOCK(ah, chan))
       tx_lat += 22;
 
-  sifstime *= 4;
+  sifstime = 64;
   ack_offset = 32;
   slottime = 21;
  } else {
@@ -1111,14 +1046,12 @@ void ath9k_hw_init_global_settings(struct ath_hw *ah)
   * BA frames in some implementations, but it has been found to fix ACK
   * timeout issues in other cases as well.
   */
- if (conf->chandef.chan &&
-     conf->chandef.chan->band == IEEE80211_BAND_2GHZ &&
+ if (IS_CHAN_2GHZ(chan) &&
      !IS_CHAN_HALF_RATE(chan) && !IS_CHAN_QUARTER_RATE(chan)) {
   acktimeout += 64 - sifstime - ah->slottime;
   ctstimeout += 48 - sifstime - ah->slottime;
  }
 
-
  ath9k_hw_set_sifs_time(ah, sifstime);
  ath9k_hw_setslottime(ah, slottime);
  ath9k_hw_set_ack_timeout(ah, acktimeout);
@@ -1155,9 +1088,7 @@ u32 ath9k_regd_get_ctl(struct ath_regulatory *reg, struct ath9k_channel *chan)
 {
  u32 ctl = ath_regd_get_band_ctl(reg, chan->chan->band);
 
- if (IS_CHAN_B(chan))
-  ctl |= CTL_11B;
- else if (IS_CHAN_G(chan))
+ if (IS_CHAN_2GHZ(chan))
   ctl |= CTL_11G;
  else
   ctl |= CTL_11A;
@@ -1250,10 +1181,10 @@ static void ath9k_hw_set_operating_mode(struct ath_hw *ah, int opmode)
 
  switch (opmode) {
  case NL80211_IFTYPE_ADHOC:
- case NL80211_IFTYPE_MESH_POINT:
   set |= AR_STA_ID1_ADHOC;
   REG_SET_BIT(ah, AR_CFG, AR_CFG_AP_ADHOC_INDICATION);
   break;
+ case NL80211_IFTYPE_MESH_POINT:
  case NL80211_IFTYPE_AP:
   set |= AR_STA_ID1_STA_AP;
   /* fall through */
@@ -1285,6 +1216,42 @@ void ath9k_hw_get_delta_slope_vals(struct ath_hw *ah, u32 coef_scaled,
  *coef_exponent = coef_exp - 16;
 }
 
+/* AR9330 WAR:
+ * call external reset function to reset WMAC if:
+ * - doing a cold reset
+ * - we have pending frames in the TX queues.
+ */
+static bool ath9k_hw_ar9330_reset_war(struct ath_hw *ah, int type)
+{
+ int i, npend = 0;
+
+ for (i = 0; i < AR_NUM_QCU; i++) {
+  npend = ath9k_hw_numtxpending(ah, i);
+  if (npend)
+   break;
+ }
+
+ if (ah->external_reset &&
+     (npend || type == ATH9K_RESET_COLD)) {
+  int reset_err = 0;
+
+  ath_dbg(ath9k_hw_common(ah), RESET,
+   "reset MAC via external reset\n");
+
+  reset_err = ah->external_reset();
+  if (reset_err) {
+   ath_err(ath9k_hw_common(ah),
+    "External reset failed, err=%d\n",
+    reset_err);
+   return false;
+  }
+
+  REG_WRITE(ah, AR_RTC_RESET, 1);
+ }
+
+ return true;
+}
+
 static bool ath9k_hw_set_reset(struct ath_hw *ah, int type)
 {
  u32 rst_flags;
@@ -1335,38 +1302,8 @@ static bool ath9k_hw_set_reset(struct ath_hw *ah, int type)
  }
 
  if (AR_SREV_9330(ah)) {
-  int npend = 0;
-  int i;
-
-  /* AR9330 WAR:
-   * call external reset function to reset WMAC if:
-   * - doing a cold reset
-   * - we have pending frames in the TX queues
-   */
-
-  for (i = 0; i < AR_NUM_QCU; i++) {
-   npend = ath9k_hw_numtxpending(ah, i);
-   if (npend)
-    break;
-  }
-
-  if (ah->external_reset &&
-      (npend || type == ATH9K_RESET_COLD)) {
-   int reset_err = 0;
-
-   ath_dbg(ath9k_hw_common(ah), RESET,
-    "reset MAC via external reset\n");
-
-   reset_err = ah->external_reset();
-   if (reset_err) {
-    ath_err(ath9k_hw_common(ah),
-     "External reset failed, err=%d\n",
-     reset_err);
-    return false;
-   }
-
-   REG_WRITE(ah, AR_RTC_RESET, 1);
-  }
+  if (!ath9k_hw_ar9330_reset_war(ah, type))
+   return false;
  }
 
  if (ath9k_hw_mci_is_enabled(ah))
@@ -1376,7 +1313,12 @@ static bool ath9k_hw_set_reset(struct ath_hw *ah, int type)
 
  REGWRITE_BUFFER_FLUSH(ah);
 
- udelay(50);
+ if (AR_SREV_9300_20_OR_LATER(ah))
+  udelay(50);
+ else if (AR_SREV_9100(ah))
+  mdelay(10);
+ else
+  udelay(100);
 
  REG_WRITE(ah, AR_RTC_RC, 0);
  if (!ath9k_hw_wait(ah, AR_RTC_RC, AR_RTC_RC_M, 0, AH_WAIT_TIMEOUT)) {
@@ -1412,8 +1354,7 @@ static bool ath9k_hw_set_reset_power_on(struct ath_hw *ah)
 
  REGWRITE_BUFFER_FLUSH(ah);
 
- if (!AR_SREV_9300_20_OR_LATER(ah))
-  udelay(2);
+ udelay(2);
 
  if (!AR_SREV_9100(ah) && !AR_SREV_9300_20_OR_LATER(ah))
   REG_WRITE(ah, AR_RC, 0);
@@ -1489,7 +1430,6 @@ static bool ath9k_hw_chip_reset(struct ath_hw *ah,
  if (AR_SREV_9330(ah))
   ar9003_hw_internal_regulator_apply(ah);
  ath9k_hw_init_pll(ah, chan);
- ath9k_hw_set_rfmode(ah, chan);
 
  return true;
 }
@@ -1498,16 +1438,17 @@ static bool ath9k_hw_channel_change(struct ath_hw *ah,
         struct ath9k_channel *chan)
 {
  struct ath_common *common = ath9k_hw_common(ah);
+ struct ath9k_hw_capabilities *pCap = &ah->caps;
+ bool band_switch = false, mode_diff = false;
+ u8 ini_reloaded = 0;
  u32 qnum;
  int r;
- bool edma = !!(ah->caps.hw_caps & ATH9K_HW_CAP_EDMA);
- bool band_switch, mode_diff;
- u8 ini_reloaded;
 
- band_switch = (chan->channelFlags & (CHANNEL_2GHZ | CHANNEL_5GHZ)) !=
-        (ah->curchan->channelFlags & (CHANNEL_2GHZ |
-          CHANNEL_5GHZ));
- mode_diff = (chan->chanmode != ah->curchan->chanmode);
+ if (pCap->hw_caps & ATH9K_HW_CAP_FCC_BAND_SWITCH) {
+  u32 flags_diff = chan->channelFlags ^ ah->curchan->channelFlags;
+  band_switch = !!(flags_diff & CHANNEL_5GHZ);
+  mode_diff = !!(flags_diff & ~CHANNEL_HT);
+ }
 
  for (qnum = 0; qnum < AR_NUM_QCU; qnum++) {
   if (ath9k_hw_numtxpending(ah, qnum)) {
@@ -1522,11 +1463,12 @@ static bool ath9k_hw_channel_change(struct ath_hw *ah,
   return false;
  }
 
- if (edma && (band_switch || mode_diff)) {
+ if (band_switch || mode_diff) {
   ath9k_hw_mark_phy_inactive(ah);
   udelay(5);
 
-  ath9k_hw_init_pll(ah, NULL);
+  if (band_switch)
+   ath9k_hw_init_pll(ah, chan);
 
   if (ath9k_hw_fast_chan_change(ah, chan, &ini_reloaded)) {
    ath_err(common, "Failed to do fast channel change\n");
@@ -1543,22 +1485,19 @@ static bool ath9k_hw_channel_change(struct ath_hw *ah,
  }
  ath9k_hw_set_clockrate(ah);
  ath9k_hw_apply_txpower(ah, chan, false);
- ath9k_hw_rfbus_done(ah);
-
- if (IS_CHAN_OFDM(chan) || IS_CHAN_HT(chan))
-  ath9k_hw_set_delta_slope(ah, chan);
 
+ ath9k_hw_set_delta_slope(ah, chan);
  ath9k_hw_spur_mitigate_freq(ah, chan);
 
- if (edma && (band_switch || mode_diff)) {
-  ah->ah_flags |= AH_FASTCC;
-  if (band_switch || ini_reloaded)
-   ah->eep_ops->set_board_values(ah, chan);
+ if (band_switch || ini_reloaded)
+  ah->eep_ops->set_board_values(ah, chan);
 
-  ath9k_hw_init_bb(ah, chan);
+ ath9k_hw_init_bb(ah, chan);
+ ath9k_hw_rfbus_done(ah);
 
-  if (band_switch || ini_reloaded)
-   ath9k_hw_init_cal(ah, chan);
+ if (band_switch || ini_reloaded) {
+  ah->ah_flags |= AH_FASTCC;
+  ath9k_hw_init_cal(ah, chan);
   ah->ah_flags &= ~AH_FASTCC;
  }
 
@@ -1579,80 +1518,23 @@ static void ath9k_hw_apply_gpio_override(struct ath_hw *ah)
  }
 }
 
-static bool ath9k_hw_check_dcs(u32 dma_dbg, u32 num_dcu_states,
-          int *hang_state, int *hang_pos)
-{
- static u32 dcu_chain_state[] = {5, 6, 9}; /* DCU chain stuck states */
- u32 chain_state, dcs_pos, i;
-
- for (dcs_pos = 0; dcs_pos < num_dcu_states; dcs_pos++) {
-  chain_state = (dma_dbg >> (5 * dcs_pos)) & 0x1f;
-  for (i = 0; i < 3; i++) {
-   if (chain_state == dcu_chain_state[i]) {
-    *hang_state = chain_state;
-    *hang_pos = dcs_pos;
-    return true;
-   }
-  }
- }
- return false;
-}
-
-#define DCU_COMPLETE_STATE        1
-#define DCU_COMPLETE_STATE_MASK 0x3
-#define NUM_STATUS_READS         50
-static bool ath9k_hw_detect_mac_hang(struct ath_hw *ah)
+void ath9k_hw_check_nav(struct ath_hw *ah)
 {
- u32 chain_state, comp_state, dcs_reg = AR_DMADBG_4;
- u32 i, hang_pos, hang_state, num_state = 6;
-
- comp_state = REG_READ(ah, AR_DMADBG_6);
-
- if ((comp_state & DCU_COMPLETE_STATE_MASK) != DCU_COMPLETE_STATE) {
-  ath_dbg(ath9k_hw_common(ah), RESET,
-   "MAC Hang signature not found at DCU complete\n");
-  return false;
- }
-
- chain_state = REG_READ(ah, dcs_reg);
- if (ath9k_hw_check_dcs(chain_state, num_state, &hang_state, &hang_pos))
-  goto hang_check_iter;
-
- dcs_reg = AR_DMADBG_5;
- num_state = 4;
- chain_state = REG_READ(ah, dcs_reg);
- if (ath9k_hw_check_dcs(chain_state, num_state, &hang_state, &hang_pos))
-  goto hang_check_iter;
-
- ath_dbg(ath9k_hw_common(ah), RESET,
-  "MAC Hang signature 1 not found\n");
- return false;
-
-hang_check_iter:
- ath_dbg(ath9k_hw_common(ah), RESET,
-  "DCU registers: chain %08x complete %08x Hang: state %d pos %d\n",
-  chain_state, comp_state, hang_state, hang_pos);
-
- for (i = 0; i < NUM_STATUS_READS; i++) {
-  chain_state = REG_READ(ah, dcs_reg);
-  chain_state = (chain_state >> (5 * hang_pos)) & 0x1f;
-  comp_state = REG_READ(ah, AR_DMADBG_6);
+ struct ath_common *common = ath9k_hw_common(ah);
+ u32 val;
 
-  if (((comp_state & DCU_COMPLETE_STATE_MASK) !=
-     DCU_COMPLETE_STATE) ||
-      (chain_state != hang_state))
-   return false;
+ val = REG_READ(ah, AR_NAV);
+ if (val != 0xdeadbeef && val > 0x7fff) {
+  ath_dbg(common, BSTUCK, "Abnormal NAV: 0x%x\n", val);
+  REG_WRITE(ah, AR_NAV, 0);
  }
-
- ath_dbg(ath9k_hw_common(ah), RESET, "MAC Hang signature 1 found\n");
-
- return true;
 }
+EXPORT_SYMBOL(ath9k_hw_check_nav);
 
 bool ath9k_hw_check_alive(struct ath_hw *ah)
 {
  int count = 50;
- u32 reg;
+ u32 reg, last_val;
 
  if (AR_SREV_9300(ah))
   return !ath9k_hw_detect_mac_hang(ah);
@@ -1660,9 +1542,14 @@ bool ath9k_hw_check_alive(struct ath_hw *ah)
  if (AR_SREV_9285_12_OR_LATER(ah))
   return true;
 
+ last_val = REG_READ(ah, AR_OBS_BUS_1);
  do {
   reg = REG_READ(ah, AR_OBS_BUS_1);
+  if (reg != last_val)
+   return true;
 
+  udelay(1);
+  last_val = reg;
   if ((reg & 0x7E7FFFEF) == 0x00702400)
    continue;
 
@@ -1710,7 +1597,6 @@ static void ath9k_hw_reset_opmode(struct ath_hw *ah,
 
  REG_RMW(ah, AR_STA_ID1, macStaId1
     | AR_STA_ID1_RTS_USE_DEF
-    | (ah->config.ack_6mb ? AR_STA_ID1_ACKCTS_6MB : 0)
     | ah->sta_id1_defaults,
     ~AR_STA_ID1_SADH_MASK);
  ath_hw_setbssidmask(common);
@@ -1769,7 +1655,7 @@ static void ath9k_hw_init_desc(struct ath_hw *ah)
   }
 #ifdef __BIG_ENDIAN
   else if (AR_SREV_9330(ah) || AR_SREV_9340(ah) ||
-    AR_SREV_9550(ah))
+    AR_SREV_9550(ah) || AR_SREV_9531(ah))
    REG_RMW(ah, AR_CFG, AR_CFG_SWRB | AR_CFG_SWTB, 0);
   else
    REG_WRITE(ah, AR_CFG, AR_CFG_SWTD | AR_CFG_SWRD);
@@ -1780,16 +1666,11 @@ static void ath9k_hw_init_desc(struct ath_hw *ah)
 /*
  * Fast channel change:
  * (Change synthesizer based on channel freq without resetting chip)
- *
- * Don't do FCC when
- *   - Flag is not set
- *   - Chip is just coming out of full sleep
- *   - Channel to be set is same as current channel
- *   - Channel flags are different, (eg.,moving from 2GHz to 5GHz channel)
  */
 static int ath9k_hw_do_fastcc(struct ath_hw *ah, struct ath9k_channel *chan)
 {
  struct ath_common *common = ath9k_hw_common(ah);
+ struct ath9k_hw_capabilities *pCap = &ah->caps;
  int ret;
 
  if (AR_SREV_9280(ah) && common->bus_ops->ath_bus_type == ATH_PCI)
@@ -1808,8 +1689,11 @@ static int ath9k_hw_do_fastcc(struct ath_hw *ah, struct ath9k_channel *chan)
      (CHANNEL_HALF | CHANNEL_QUARTER))
   goto fail;
 
- if ((chan->channelFlags & CHANNEL_ALL) !=
-     (ah->curchan->channelFlags & CHANNEL_ALL))
+ /*
+  * If cross-band fcc is not supoprted, bail out if channelFlags differ.
+  */
+ if (!(pCap->hw_caps & ATH9K_HW_CAP_FCC_BAND_SWITCH) &&
+     ((chan->channelFlags ^ ah->curchan->channelFlags) & ~CHANNEL_HT))
   goto fail;
 
  if (!ath9k_hw_check_alive(ah))
@@ -1820,9 +1704,9 @@ static int ath9k_hw_do_fastcc(struct ath_hw *ah, struct ath9k_channel *chan)
   * re-using are present.
   */
  if (AR_SREV_9462(ah) && (ah->caldata &&
-     (!ah->caldata->done_txiqcal_once ||
-      !ah->caldata->done_txclcal_once ||
-      !ah->caldata->rtt_done)))
+     (!test_bit(TXIQCAL_DONE, &ah->caldata->cal_flags) ||
+      !test_bit(TXCLCAL_DONE, &ah->caldata->cal_flags) ||
+      !test_bit(RTT_DONE, &ah->caldata->cal_flags))))
   goto fail;
 
  ath_dbg(common, RESET, "FastChannelChange for %d -> %d\n",
@@ -1850,10 +1734,12 @@ int ath9k_hw_reset(struct ath_hw *ah, struct ath9k_channel *chan,
      struct ath9k_hw_cal_data *caldata, bool fastcc)
 {
  struct ath_common *common = ath9k_hw_common(ah);
+ struct timespec ts;
  u32 saveLedState;
  u32 saveDefAntenna;
  u32 macStaId1;
  u64 tsf = 0;
+ s64 usec = 0;
  int r;
  bool start_mci_reset = false;
  bool save_fullsleep = ah->chip_fullsleep;
@@ -1872,15 +1758,14 @@ int ath9k_hw_reset(struct ath_hw *ah, struct ath9k_channel *chan,
 
  ah->caldata = caldata;
  if (caldata && (chan->channel != caldata->channel ||
-   chan->channelFlags != caldata->channelFlags ||
-   chan->chanmode != caldata->chanmode)) {
+   chan->channelFlags != caldata->channelFlags)) {
   /* Operating channel changed, reset channel calibration data */
   memset(caldata, 0, sizeof(*caldata));
   ath9k_init_nfcal_hist_buffer(ah, chan);
  } else if (caldata) {
-  caldata->paprd_packet_sent = false;
+  clear_bit(PAPRD_PACKET_SENT, &caldata->cal_flags);
  }
- ah->noise = ath9k_hw_getchan_noise(ah, chan);
+ ah->noise = ath9k_hw_getchan_noise(ah, chan, chan->noisefloor);
 
  if (fastcc) {
   r = ath9k_hw_do_fastcc(ah, chan);
@@ -1897,10 +1782,10 @@ int ath9k_hw_reset(struct ath_hw *ah, struct ath9k_channel *chan,
 
  macStaId1 = REG_READ(ah, AR_STA_ID1) & AR_STA_ID1_BASE_RATE_11B;
 
- /* For chips on which RTC reset is done, save TSF before it gets cleared */
- if (AR_SREV_9100(ah) ||
-     (AR_SREV_9280(ah) && ah->eep_ops->get_eeprom(ah, EEP_OL_PWRCTRL)))
-  tsf = ath9k_hw_gettsf64(ah);
+ /* Save TSF before chip reset, a cold reset clears it */
+ tsf = ath9k_hw_gettsf64(ah);
+ getrawmonotonic(&ts);
+ usec = ts.tv_sec * 1000000ULL + ts.tv_nsec / 1000;
 
  saveLedState = REG_READ(ah, AR_CFG_LED) &
   (AR_CFG_LED_ASSOC_CTL | AR_CFG_LED_MODE_SEL |
@@ -1933,8 +1818,9 @@ int ath9k_hw_reset(struct ath_hw *ah, struct ath9k_channel *chan,
  }
 
  /* Restore TSF */
- if (tsf)
-  ath9k_hw_settsf64(ah, tsf);
+ getrawmonotonic(&ts);
+ usec = ts.tv_sec * 1000000ULL + ts.tv_nsec / 1000 - usec;
+ ath9k_hw_settsf64(ah, tsf + usec);
 
  if (AR_SREV_9280_20_OR_LATER(ah))
   REG_SET_BIT(ah, AR_GPIO_INPUT_EN_VAL, AR_GPIO_JTAG_DISABLE);
@@ -1946,6 +1832,8 @@ int ath9k_hw_reset(struct ath_hw *ah, struct ath9k_channel *chan,
  if (r)
   return r;
 
+ ath9k_hw_set_rfmode(ah, chan);
+
  if (ath9k_hw_mci_is_enabled(ah))
   ar9003_mci_reset(ah, false, IS_CHAN_2GHZ(chan), save_fullsleep);
 
@@ -1962,9 +1850,7 @@ int ath9k_hw_reset(struct ath_hw *ah, struct ath9k_channel *chan,
 
  ath9k_hw_init_mfp(ah);
 
- if (IS_CHAN_OFDM(chan) || IS_CHAN_HT(chan))
-  ath9k_hw_set_delta_slope(ah, chan);
-
+ ath9k_hw_set_delta_slope(ah, chan);
  ath9k_hw_spur_mitigate_freq(ah, chan);
  ah->eep_ops->set_board_values(ah, chan);
 
@@ -2003,8 +1889,8 @@ int ath9k_hw_reset(struct ath_hw *ah, struct ath9k_channel *chan,
   REG_WRITE(ah, AR_OBS, 8);
 
  if (ah->config.rx_intr_mitigation) {
-  REG_RMW_FIELD(ah, AR_RIMT, AR_RIMT_LAST, 500);
-  REG_RMW_FIELD(ah, AR_RIMT, AR_RIMT_FIRST, 2000);
+  REG_RMW_FIELD(ah, AR_RIMT, AR_RIMT_LAST, ah->config.rimt_last);
+  REG_RMW_FIELD(ah, AR_RIMT, AR_RIMT_FIRST, ah->config.rimt_first);
  }
 
  if (ah->config.tx_intr_mitigation) {
@@ -2015,8 +1901,8 @@ int ath9k_hw_reset(struct ath_hw *ah, struct ath9k_channel *chan,
  ath9k_hw_init_bb(ah, chan);
 
  if (caldata) {
-  caldata->done_txiqcal_once = false;
-  caldata->done_txclcal_once = false;
+  clear_bit(TXIQCAL_DONE, &caldata->cal_flags);
+  clear_bit(TXCLCAL_DONE, &caldata->cal_flags);
  }
  if (!ath9k_hw_init_cal(ah, chan))
   return -EIO;
@@ -2042,14 +1928,15 @@ int ath9k_hw_reset(struct ath_hw *ah, struct ath9k_channel *chan,
  ath9k_hw_loadnf(ah, chan);
  ath9k_hw_start_nfcal(ah, true);
 
- if (AR_SREV_9300_20_OR_LATER(ah)) {
+ if (AR_SREV_9300_20_OR_LATER(ah))
   ar9003_hw_bb_watchdog_config(ah);
+
+ if (ah->config.hw_hang_checks & HW_PHYRESTART_CLC_WAR)
   ar9003_hw_disable_phy_restart(ah);
- }
 
  ath9k_hw_apply_gpio_override(ah);
 
- if (AR_SREV_9565(ah) && ah->shared_chain_lnadiv)
+ if (AR_SREV_9565(ah) && common->bt_ant_diversity)
   REG_SET_BIT(ah, AR_BTCOEX_WL_LNADIV, AR_BTCOEX_WL_LNADIV_FORCE_ON);
 
  return 0;
@@ -2169,7 +2056,10 @@ static bool ath9k_hw_set_power_awake(struct ath_hw *ah)
 
  REG_SET_BIT(ah, AR_RTC_FORCE_WAKE,
       AR_RTC_FORCE_WAKE_EN);
- udelay(50);
+ if (AR_SREV_9100(ah))
+  mdelay(10);
+ else
+  udelay(50);
 
  for (i = POWER_UP_TIME / 50; i > 0; i--) {
   val = REG_READ(ah, AR_RTC_STATUS) & AR_RTC_STATUS_M;
@@ -2256,12 +2146,9 @@ void ath9k_hw_beaconinit(struct ath_hw *ah, u32 next_beacon, u32 beacon_period)
 
  switch (ah->opmode) {
  case NL80211_IFTYPE_ADHOC:
- case NL80211_IFTYPE_MESH_POINT:
   REG_SET_BIT(ah, AR_TXCFG,
        AR_TXCFG_ADHOC_BEACON_ATIM_TX_POLICY);
-  REG_WRITE(ah, AR_NEXT_NDP_TIMER, next_beacon +
-     TU_TO_USEC(ah->atim_window ? ah->atim_window : 1));
-  flags |= AR_NDP_TIMER_EN;
+ case NL80211_IFTYPE_MESH_POINT:
  case NL80211_IFTYPE_AP:
   REG_WRITE(ah, AR_NEXT_TBTT_TIMER, next_beacon);
   REG_WRITE(ah, AR_NEXT_DMA_BEACON_ALERT, next_beacon -
@@ -2281,7 +2168,6 @@ void ath9k_hw_beaconinit(struct ath_hw *ah, u32 next_beacon, u32 beacon_period)
  REG_WRITE(ah, AR_BEACON_PERIOD, beacon_period);
  REG_WRITE(ah, AR_DMA_BEACON_PERIOD, beacon_period);
  REG_WRITE(ah, AR_SWBA_PERIOD, beacon_period);
- REG_WRITE(ah, AR_NDP_PERIOD, beacon_period);
 
  REGWRITE_BUFFER_FLUSH(ah);
 
@@ -2298,12 +2184,9 @@ void ath9k_hw_set_sta_beacon_timers(struct ath_hw *ah,
 
  ENABLE_REGWRITE_BUFFER(ah);
 
- REG_WRITE(ah, AR_NEXT_TBTT_TIMER, TU_TO_USEC(bs->bs_nexttbtt));
-
- REG_WRITE(ah, AR_BEACON_PERIOD,
-    TU_TO_USEC(bs->bs_intval));
- REG_WRITE(ah, AR_DMA_BEACON_PERIOD,
-    TU_TO_USEC(bs->bs_intval));
+ REG_WRITE(ah, AR_NEXT_TBTT_TIMER, bs->bs_nexttbtt);
+ REG_WRITE(ah, AR_BEACON_PERIOD, bs->bs_intval);
+ REG_WRITE(ah, AR_DMA_BEACON_PERIOD, bs->bs_intval);
 
  REGWRITE_BUFFER_FLUSH(ah);
 
@@ -2331,9 +2214,8 @@ void ath9k_hw_set_sta_beacon_timers(struct ath_hw *ah,
 
  ENABLE_REGWRITE_BUFFER(ah);
 
- REG_WRITE(ah, AR_NEXT_DTIM,
-    TU_TO_USEC(bs->bs_nextdtim - SLEEP_SLOP));
- REG_WRITE(ah, AR_NEXT_TIM, TU_TO_USEC(nextTbtt - SLEEP_SLOP));
+ REG_WRITE(ah, AR_NEXT_DTIM, bs->bs_nextdtim - SLEEP_SLOP);
+ REG_WRITE(ah, AR_NEXT_TIM, nextTbtt - SLEEP_SLOP);
 
  REG_WRITE(ah, AR_SLEEP1,
     SM((CAB_TIMEOUT_VAL << 3), AR_SLEEP1_CAB_TIMEOUT)
@@ -2347,8 +2229,8 @@ void ath9k_hw_set_sta_beacon_timers(struct ath_hw *ah,
  REG_WRITE(ah, AR_SLEEP2,
     SM(beacontimeout, AR_SLEEP2_BEACON_TIMEOUT));
 
- REG_WRITE(ah, AR_TIM_PERIOD, TU_TO_USEC(beaconintval));
- REG_WRITE(ah, AR_DTIM_PERIOD, TU_TO_USEC(dtimperiod));
+ REG_WRITE(ah, AR_TIM_PERIOD, beaconintval);
+ REG_WRITE(ah, AR_DTIM_PERIOD, dtimperiod);
 
  REGWRITE_BUFFER_FLUSH(ah);
 
@@ -2506,7 +2388,7 @@ int ath9k_hw_fill_cap_info(struct ath_hw *ah)
  else
   pCap->rts_aggr_limit = (8 * 1024);
 
-#if defined(CONFIG_RFKILL) || defined(CONFIG_RFKILL_MODULE)
+#ifdef CONFIG_ATH9K_RFKILL
  ah->rfsilent = ah->eep_ops->get_eeprom(ah, EEP_RF_SILENT);
  if (ah->rfsilent & EEP_RFSILENT_ENABLED) {
   ah->rfkill_gpio =
@@ -2552,34 +2434,28 @@ int ath9k_hw_fill_cap_info(struct ath_hw *ah)
  if (AR_SREV_9287_11_OR_LATER(ah) || AR_SREV_9271(ah))
   pCap->hw_caps |= ATH9K_HW_CAP_SGI_20;
 
- if (AR_SREV_9285(ah))
+ if (AR_SREV_9285(ah)) {
   if (ah->eep_ops->get_eeprom(ah, EEP_MODAL_VER) >= 3) {
    ant_div_ctl1 =
     ah->eep_ops->get_eeprom(ah, EEP_ANT_DIV_CTL1);
-   if ((ant_div_ctl1 & 0x1) && ((ant_div_ctl1 >> 3) & 0x1))
+   if ((ant_div_ctl1 & 0x1) && ((ant_div_ctl1 >> 3) & 0x1)) {
     pCap->hw_caps |= ATH9K_HW_CAP_ANT_DIV_COMB;
+    ath_info(common, "Enable LNA combining\n");
+   }
   }
+ }
+
  if (AR_SREV_9300_20_OR_LATER(ah)) {
   if (ah->eep_ops->get_eeprom(ah, EEP_CHAIN_MASK_REDUCE))
    pCap->hw_caps |= ATH9K_HW_CAP_APM;
  }
 
-
  if (AR_SREV_9330(ah) || AR_SREV_9485(ah) || AR_SREV_9565(ah)) {
   ant_div_ctl1 = ah->eep_ops->get_eeprom(ah, EEP_ANT_DIV_CTL1);
-  /*
-   * enable the diversity-combining algorithm only when
-   * both enable_lna_div and enable_fast_div are set
-   *  Table for Diversity
-   * ant_div_alt_lnaconf  bit 0-1
-   * ant_div_main_lnaconf  bit 2-3
-   * ant_div_alt_gaintb  bit 4
-   * ant_div_main_gaintb  bit 5
-   * enable_ant_div_lnadiv bit 6
-   * enable_ant_fast_div  bit 7
-   */
-  if ((ant_div_ctl1 >> 0x6) == 0x3)
+  if ((ant_div_ctl1 >> 0x6) == 0x3) {
    pCap->hw_caps |= ATH9K_HW_CAP_ANT_DIV_COMB;
+   ath_info(common, "Enable LNA combining\n");
+  }
  }
 
  if (ath9k_hw_dfs_tested(ah))
@@ -2601,17 +2477,12 @@ int ath9k_hw_fill_cap_info(struct ath_hw *ah)
   if (!(ah->ent_mode & AR_ENT_OTP_49GHZ_DISABLE))
    pCap->hw_caps |= ATH9K_HW_CAP_MCI;
 
-  if (AR_SREV_9462_20(ah))
+  if (AR_SREV_9462_20_OR_LATER(ah))
    pCap->hw_caps |= ATH9K_HW_CAP_RTT;
  }
 
- if (AR_SREV_9280_20_OR_LATER(ah)) {
-  pCap->hw_caps |= ATH9K_HW_WOW_DEVICE_CAPABLE |
-     ATH9K_HW_WOW_PATTERN_MATCH_EXACT;
-
-  if (AR_SREV_9280(ah))
-   pCap->hw_caps |= ATH9K_HW_WOW_PATTERN_MATCH_DWORD;
- }
+ if (AR_SREV_9462(ah))
+  pCap->hw_caps |= ATH9K_HW_WOW_DEVICE_CAPABLE;
 
  if (AR_SREV_9300_20_OR_LATER(ah) &&
      ah->eep_ops->get_eeprom(ah, EEP_PAPRD))
@@ -2945,12 +2816,11 @@ void ath9k_hw_set_tsfadjust(struct ath_hw *ah, bool set)
 }
 EXPORT_SYMBOL(ath9k_hw_set_tsfadjust);
 
-void ath9k_hw_set11nmac2040(struct ath_hw *ah)
+void ath9k_hw_set11nmac2040(struct ath_hw *ah, struct ath9k_channel *chan)
 {
- struct ieee80211_conf *conf = &ath9k_hw_common(ah)->hw->conf;
  u32 macmode;
 
- if (conf_is_ht40(conf) && !ah->config.cwm_ignore_extcca)
+ if (IS_CHAN_HT40(chan) && !ah->config.cwm_ignore_extcca)
   macmode = AR_2040_JOINED_RX_CLEAR;
  else
   macmode = 0;
@@ -2989,20 +2859,6 @@ static const struct ath_gen_timer_configuration gen_tmr_configuration[] =
 
 /* HW generic timer primitives */
 
-/* compute and clear index of rightmost 1 */
-static u32 rightmost_index(struct ath_gen_timer_table *timer_table, u32 *mask)
-{
- u32 b;
-
- b = *mask;
- b &= (0-b);
- *mask &= ~b;
- b *= debruijn32;
- b >>= 27;
-
- return timer_table->gen_timer_index[b];
-}
-
 u32 ath9k_hw_gettsf32(struct ath_hw *ah)
 {
  return REG_READ(ah, AR_TSF_L32);
@@ -3018,6 +2874,10 @@ struct ath_gen_timer *ath_gen_timer_alloc(struct ath_hw *ah,
  struct ath_gen_timer_table *timer_table = &ah->hw_gen_timers;
  struct ath_gen_timer *timer;
 
+ if ((timer_index < AR_FIRST_NDP_TIMER) ||
+  (timer_index >= ATH_MAX_GEN_TIMER))
+  return NULL;
+
  timer = kzalloc(sizeof(struct ath_gen_timer), GFP_KERNEL);
  if (timer == NULL)
   return NULL;
@@ -3035,23 +2895,13 @@ EXPORT_SYMBOL(ath_gen_timer_alloc);
 
 void ath9k_hw_gen_timer_start(struct ath_hw *ah,
          struct ath_gen_timer *timer,
-         u32 trig_timeout,
+         u32 timer_next,
          u32 timer_period)
 {
  struct ath_gen_timer_table *timer_table = &ah->hw_gen_timers;
- u32 tsf, timer_next;
+ u32 mask = 0;
 
- BUG_ON(!timer_period);
-
- set_bit(timer->index, &timer_table->timer_mask.timer_bits);
-
- tsf = ath9k_hw_gettsf32(ah);
-
- timer_next = tsf + trig_timeout;
-
- ath_dbg(ath9k_hw_common(ah), HWTIMER,
-  "current tsf %x period %x timer_next %x\n",
-  tsf, timer_period, timer_next);
+ timer_table->timer_mask |= BIT(timer->index);
 
  /*
   * Program generic timer registers
@@ -3077,10 +2927,19 @@ void ath9k_hw_gen_timer_start(struct ath_hw *ah,
            (1 << timer->index));
  }
 
- /* Enable both trigger and thresh interrupt masks */
- REG_SET_BIT(ah, AR_IMR_S5,
-  (SM(AR_GENTMR_BIT(timer->index), AR_IMR_S5_GENTIMER_THRESH) |
-  SM(AR_GENTMR_BIT(timer->index), AR_IMR_S5_GENTIMER_TRIG)));
+ if (timer->trigger)
+  mask |= SM(AR_GENTMR_BIT(timer->index),
+      AR_IMR_S5_GENTIMER_TRIG);
+ if (timer->overflow)
+  mask |= SM(AR_GENTMR_BIT(timer->index),
+      AR_IMR_S5_GENTIMER_THRESH);
+
+ REG_SET_BIT(ah, AR_IMR_S5, mask);
+
+ if ((ah->imask & ATH9K_INT_GENTIMER) == 0) {
+  ah->imask |= ATH9K_INT_GENTIMER;
+  ath9k_hw_set_interrupts(ah);
+ }
 }
 EXPORT_SYMBOL(ath9k_hw_gen_timer_start);
 
@@ -3088,11 +2947,6 @@ void ath9k_hw_gen_timer_stop(struct ath_hw *ah, struct ath_gen_timer *timer)
 {
  struct ath_gen_timer_table *timer_table = &ah->hw_gen_timers;
 
- if ((timer->index < AR_FIRST_NDP_TIMER) ||
-  (timer->index >= ATH_MAX_GEN_TIMER)) {
-  return;
- }
-
  /* Clear generic timer enable bits. */
  REG_CLR_BIT(ah, gen_tmr_configuration[timer->index].mode_addr,
    gen_tmr_configuration[timer->index].mode_mask);
@@ -3112,7 +2966,12 @@ void ath9k_hw_gen_timer_stop(struct ath_hw *ah, struct ath_gen_timer *timer)
   (SM(AR_GENTMR_BIT(timer->index), AR_IMR_S5_GENTIMER_THRESH) |
   SM(AR_GENTMR_BIT(timer->index), AR_IMR_S5_GENTIMER_TRIG)));
 
- clear_bit(timer->index, &timer_table->timer_mask.timer_bits);
+ timer_table->timer_mask &= ~BIT(timer->index);
+
+ if (timer_table->timer_mask == 0) {
+  ah->imask &= ~ATH9K_INT_GENTIMER;
+  ath9k_hw_set_interrupts(ah);
+ }
 }
 EXPORT_SYMBOL(ath9k_hw_gen_timer_stop);
 
@@ -3133,32 +2992,32 @@ void ath_gen_timer_isr(struct ath_hw *ah)
 {
  struct ath_gen_timer_table *timer_table = &ah->hw_gen_timers;
  struct ath_gen_timer *timer;
- struct ath_common *common = ath9k_hw_common(ah);
- u32 trigger_mask, thresh_mask, index;
+ unsigned long trigger_mask, thresh_mask;
+ unsigned int index;
 
  /* get hardware generic timer interrupt status */
  trigger_mask = ah->intr_gen_timer_trigger;
  thresh_mask = ah->intr_gen_timer_thresh;
- trigger_mask &= timer_table->timer_mask.val;
- thresh_mask &= timer_table->timer_mask.val;
+ trigger_mask &= timer_table->timer_mask;
+ thresh_mask &= timer_table->timer_mask;
 
- trigger_mask &= ~thresh_mask;
-
- while (thresh_mask) {
-  index = rightmost_index(timer_table, &thresh_mask);
+ for_each_set_bit(index, &thresh_mask, ARRAY_SIZE(timer_table->timers)) {
   timer = timer_table->timers[index];
-  BUG_ON(!timer);
-  ath_dbg(common, HWTIMER, "TSF overflow for Gen timer %d\n",
-   index);
+  if (!timer)
+      continue;
+  if (!timer->overflow)
+      continue;
+
+  trigger_mask &= ~BIT(index);
   timer->overflow(timer->arg);
  }
 
- while (trigger_mask) {
-  index = rightmost_index(timer_table, &trigger_mask);
+ for_each_set_bit(index, &trigger_mask, ARRAY_SIZE(timer_table->timers)) {
   timer = timer_table->timers[index];
-  BUG_ON(!timer);
-  ath_dbg(common, HWTIMER,
-   "Gen timer[%d] trigger\n", index);
+  if (!timer)
+      continue;
+  if (!timer->trigger)
+      continue;
   timer->trigger(timer->arg);
  }
 }
@@ -3189,6 +3048,7 @@ static struct {
  { AR_SREV_VERSION_9462,         "9462" },
  { AR_SREV_VERSION_9550,         "9550" },
  { AR_SREV_VERSION_9565,         "9565" },
+ { AR_SREV_VERSION_9531,         "9531" },
 };
 
 /* For devices with external radios */
@@ -3242,19 +3102,19 @@ void ath9k_hw_name(struct ath_hw *ah, char *hw_name, size_t len)
 
  /* chipsets >= AR9280 are single-chip */
  if (AR_SREV_9280_20_OR_LATER(ah)) {
-  used = snprintf(hw_name, len,
-          "Atheros AR%s Rev:%x",
-          ath9k_hw_mac_bb_name(ah->hw_version.macVersion),
-          ah->hw_version.macRev);
+  used = scnprintf(hw_name, len,
+     "Atheros AR%s Rev:%x",
+     ath9k_hw_mac_bb_name(ah->hw_version.macVersion),
+     ah->hw_version.macRev);
  }
  else {
-  used = snprintf(hw_name, len,
-          "Atheros AR%s MAC/BB Rev:%x AR%s RF Rev:%x",
-          ath9k_hw_mac_bb_name(ah->hw_version.macVersion),
-          ah->hw_version.macRev,
-          ath9k_hw_rf_name((ah->hw_version.analog5GhzRev &
-      AR_RADIO_SREV_MAJOR)),
-          ah->hw_version.phyRev);
+  used = scnprintf(hw_name, len,
+     "Atheros AR%s MAC/BB Rev:%x AR%s RF Rev:%x",
+     ath9k_hw_mac_bb_name(ah->hw_version.macVersion),
+     ah->hw_version.macRev,
+     ath9k_hw_rf_name((ah->hw_version.analog5GhzRev
+        & AR_RADIO_SREV_MAJOR)),
+     ah->hw_version.phyRev);
  }
 
  hw_name[used] = '\0';
diff --git a/drivers/net/wireless/ath/ath9k/hw.h b/drivers/net/wireless/ath/ath9k/hw.h
index a0f0027..0acd4b5 100644
--- a/drivers/net/wireless/ath/ath9k/hw.h
+++ b/drivers/net/wireless/ath/ath9k/hw.h
@@ -52,6 +52,7 @@
 #define AR9300_DEVID_QCA955X 0x0038
 #define AR9485_DEVID_AR1111 0x0037
 #define AR9300_DEVID_AR9565     0x0036
+#define AR9300_DEVID_AR953X     0x003d
 
 #define AR5416_AR9100_DEVID 0x000b
 
@@ -98,8 +99,8 @@
 
 #define PR_EEP(_s, _val)      \
  do {        \
-  len += snprintf(buf + len, size - len, "%20s : %10d\n", \
-    _s, (_val));    \
+  len += scnprintf(buf + len, size - len, "%20s : %10d\n",\
+     _s, (_val));    \
  } while (0)
 
 #define SM(_v, _f)  (((_v) << _f##_S) & _f)
@@ -168,7 +169,7 @@
 #define CAB_TIMEOUT_VAL             10
 #define BEACON_TIMEOUT_VAL          10
 #define MIN_BEACON_TIMEOUT_VAL      1
-#define SLEEP_SLOP                  3
+#define SLEEP_SLOP                  TU_TO_USEC(3)
 
 #define INIT_CONFIG_STATUS          0x00000000
 #define INIT_RSSI_THR               0x00000700
@@ -246,9 +247,9 @@ enum ath9k_hw_caps {
  ATH9K_HW_CAP_MCI   = BIT(15),
  ATH9K_HW_CAP_DFS   = BIT(16),
  ATH9K_HW_WOW_DEVICE_CAPABLE  = BIT(17),
- ATH9K_HW_WOW_PATTERN_MATCH_EXACT = BIT(18),
- ATH9K_HW_WOW_PATTERN_MATCH_DWORD = BIT(19),
- ATH9K_HW_CAP_PAPRD   = BIT(20),
+ ATH9K_HW_CAP_PAPRD   = BIT(18),
+ ATH9K_HW_CAP_FCC_BAND_SWITCH  = BIT(19),
+ ATH9K_HW_CAP_BT_ANT_DIV   = BIT(20),
 };
 
 /*
@@ -277,43 +278,49 @@ struct ath9k_hw_capabilities {
  u8 txs_len;
 };
 
+#define AR_NO_SPUR       0x8000
+#define AR_BASE_FREQ_2GHZ    2300
+#define AR_BASE_FREQ_5GHZ    4900
+#define AR_SPUR_FEEQ_BOUND_HT40 19
+#define AR_SPUR_FEEQ_BOUND_HT20 10
+
+enum ath9k_hw_hang_checks {
+ HW_BB_WATCHDOG            = BIT(0),
+ HW_PHYRESTART_CLC_WAR     = BIT(1),
+ HW_BB_RIFS_HANG           = BIT(2),
+ HW_BB_DFS_HANG            = BIT(3),
+ HW_BB_RX_CLEAR_STUCK_HANG = BIT(4),
+ HW_MAC_HANG               = BIT(5),
+};
+
 struct ath9k_ops_config {
  int dma_beacon_response_time;
  int sw_beacon_response_time;
- int additional_swba_backoff;
- int ack_6mb;
  u32 cwm_ignore_extcca;
- bool pcieSerDesWrite;
- u8 pcie_clock_req;
  u32 pcie_waen;
  u8 analog_shiftreg;
  u32 ofdm_trig_low;
  u32 ofdm_trig_high;
  u32 cck_trig_high;
  u32 cck_trig_low;
- u32 enable_ani;
  u32 enable_paprd;
  int serialize_regmode;
  bool rx_intr_mitigation;
  bool tx_intr_mitigation;
-#define SPUR_DISABLE         0
-#define SPUR_ENABLE_IOCTL    1
-#define SPUR_ENABLE_EEPROM   2
-#define AR_SPUR_5413_1       1640
-#define AR_SPUR_5413_2       1200
-#define AR_NO_SPUR       0x8000
-#define AR_BASE_FREQ_2GHZ    2300
-#define AR_BASE_FREQ_5GHZ    4900
-#define AR_SPUR_FEEQ_BOUND_HT40 19
-#define AR_SPUR_FEEQ_BOUND_HT20 10
- int spurmode;
- u16 spurchans[AR_EEPROM_MODAL_SPURS][2];
  u8 max_txtrig_level;
  u16 ani_poll_interval; /* ANI poll interval in ms */
+ u16 hw_hang_checks;
+ u16 rimt_first;
+ u16 rimt_last;
 
  /* Platform specific config */
+ u32 aspm_l1_fix;
  u32 xlna_gpio;
+ u32 ant_ctrl_comm2g_switch_enable;
  bool xatten_margin_cfg;
+ bool alt_mingainidx;
+ bool no_pll_pwrsave;
+ bool tx_gain_buffalo;
 };
 
 enum ath9k_int {
@@ -367,55 +374,30 @@ enum ath9k_int {
  ATH9K_INT_NOCARD = 0xffffffff
 };
 
-#define CHANNEL_CCK       0x00020
-#define CHANNEL_OFDM      0x00040
-#define CHANNEL_2GHZ      0x00080
-#define CHANNEL_5GHZ      0x00100
-#define CHANNEL_PASSIVE   0x00200
-#define CHANNEL_DYN       0x00400
-#define CHANNEL_HALF      0x04000
-#define CHANNEL_QUARTER   0x08000
-#define CHANNEL_HT20      0x10000
-#define CHANNEL_HT40PLUS  0x20000
-#define CHANNEL_HT40MINUS 0x40000
-
-#define CHANNEL_A           (CHANNEL_5GHZ|CHANNEL_OFDM)
-#define CHANNEL_B           (CHANNEL_2GHZ|CHANNEL_CCK)
-#define CHANNEL_G           (CHANNEL_2GHZ|CHANNEL_OFDM)
-#define CHANNEL_G_HT20      (CHANNEL_2GHZ|CHANNEL_HT20)
-#define CHANNEL_A_HT20      (CHANNEL_5GHZ|CHANNEL_HT20)
-#define CHANNEL_G_HT40PLUS  (CHANNEL_2GHZ|CHANNEL_HT40PLUS)
-#define CHANNEL_G_HT40MINUS (CHANNEL_2GHZ|CHANNEL_HT40MINUS)
-#define CHANNEL_A_HT40PLUS  (CHANNEL_5GHZ|CHANNEL_HT40PLUS)
-#define CHANNEL_A_HT40MINUS (CHANNEL_5GHZ|CHANNEL_HT40MINUS)
-#define CHANNEL_ALL    \
- (CHANNEL_OFDM|    \
-  CHANNEL_CCK|    \
-  CHANNEL_2GHZ |    \
-  CHANNEL_5GHZ |    \
-  CHANNEL_HT20 |    \
-  CHANNEL_HT40PLUS |   \
-  CHANNEL_HT40MINUS)
-
 #define MAX_RTT_TABLE_ENTRY     6
 #define MAX_IQCAL_MEASUREMENT 8
 #define MAX_CL_TAB_ENTRY 16
 #define CL_TAB_ENTRY(reg_base) (reg_base + (4 * j))
 
+enum ath9k_cal_flags {
+ RTT_DONE,
+ PAPRD_PACKET_SENT,
+ PAPRD_DONE,
+ NFCAL_PENDING,
+ NFCAL_INTF,
+ TXIQCAL_DONE,
+ TXCLCAL_DONE,
+ SW_PKDET_DONE,
+};
+
 struct ath9k_hw_cal_data {
  u16 channel;
- u32 channelFlags;
- u32 chanmode;
+ u16 channelFlags;
+ unsigned long cal_flags;
  int32_t CalValid;
  int8_t iCoff;
  int8_t qCoff;
- bool rtt_done;
- bool paprd_packet_sent;
- bool paprd_done;
- bool nfcal_pending;
- bool nfcal_interference;
- bool done_txiqcal_once;
- bool done_txclcal_once;
+ u8 caldac[2];
  u16 small_signal_gain[AR9300_MAX_CHAINS];
  u32 pa_table[AR9300_MAX_CHAINS][PAPRD_TABLE_SZ];
  u32 num_measures[AR9300_MAX_CHAINS];
@@ -427,35 +409,35 @@ struct ath9k_hw_cal_data {
 
 struct ath9k_channel {
  struct ieee80211_channel *chan;
- struct ar5416AniState ani;
  u16 channel;
- u32 channelFlags;
- u32 chanmode;
+ u16 channelFlags;
  s16 noisefloor;
 };
 
-#define IS_CHAN_G(_c) ((((_c)->channelFlags & (CHANNEL_G)) == CHANNEL_G) || \
-       (((_c)->channelFlags & CHANNEL_G_HT20) == CHANNEL_G_HT20) || \
-       (((_c)->channelFlags & CHANNEL_G_HT40PLUS) == CHANNEL_G_HT40PLUS) || \
-       (((_c)->channelFlags & CHANNEL_G_HT40MINUS) == CHANNEL_G_HT40MINUS))
-#define IS_CHAN_OFDM(_c) (((_c)->channelFlags & CHANNEL_OFDM) != 0)
-#define IS_CHAN_5GHZ(_c) (((_c)->channelFlags & CHANNEL_5GHZ) != 0)
-#define IS_CHAN_2GHZ(_c) (((_c)->channelFlags & CHANNEL_2GHZ) != 0)
-#define IS_CHAN_HALF_RATE(_c) (((_c)->channelFlags & CHANNEL_HALF) != 0)
-#define IS_CHAN_QUARTER_RATE(_c) (((_c)->channelFlags & CHANNEL_QUARTER) != 0)
+#define CHANNEL_5GHZ  BIT(0)
+#define CHANNEL_HALF  BIT(1)
+#define CHANNEL_QUARTER  BIT(2)
+#define CHANNEL_HT  BIT(3)
+#define CHANNEL_HT40PLUS BIT(4)
+#define CHANNEL_HT40MINUS BIT(5)
+
+#define IS_CHAN_5GHZ(_c) (!!((_c)->channelFlags & CHANNEL_5GHZ))
+#define IS_CHAN_2GHZ(_c) (!IS_CHAN_5GHZ(_c))
+
+#define IS_CHAN_HALF_RATE(_c) (!!((_c)->channelFlags & CHANNEL_HALF))
+#define IS_CHAN_QUARTER_RATE(_c) (!!((_c)->channelFlags & CHANNEL_QUARTER))
 #define IS_CHAN_A_FAST_CLOCK(_ah, _c)   \
- ((((_c)->channelFlags & CHANNEL_5GHZ) != 0) && \
-  ((_ah)->caps.hw_caps & ATH9K_HW_CAP_FASTCLOCK))
-
-/* These macros check chanmode and not channelFlags */
-#define IS_CHAN_B(_c) ((_c)->chanmode == CHANNEL_B)
-#define IS_CHAN_HT20(_c) (((_c)->chanmode == CHANNEL_A_HT20) || \
-     ((_c)->chanmode == CHANNEL_G_HT20))
-#define IS_CHAN_HT40(_c) (((_c)->chanmode == CHANNEL_A_HT40PLUS) || \
-     ((_c)->chanmode == CHANNEL_A_HT40MINUS) || \
-     ((_c)->chanmode == CHANNEL_G_HT40PLUS) || \
-     ((_c)->chanmode == CHANNEL_G_HT40MINUS))
-#define IS_CHAN_HT(_c) (IS_CHAN_HT20((_c)) || IS_CHAN_HT40((_c)))
+ (IS_CHAN_5GHZ(_c) && ((_ah)->caps.hw_caps & ATH9K_HW_CAP_FASTCLOCK))
+
+#define IS_CHAN_HT(_c) ((_c)->channelFlags & CHANNEL_HT)
+
+#define IS_CHAN_HT20(_c) (IS_CHAN_HT(_c) && !IS_CHAN_HT40(_c))
+
+#define IS_CHAN_HT40(_c) \
+ (!!((_c)->channelFlags & (CHANNEL_HT40PLUS | CHANNEL_HT40MINUS)))
+
+#define IS_CHAN_HT40PLUS(_c) ((_c)->channelFlags & CHANNEL_HT40PLUS)
+#define IS_CHAN_HT40MINUS(_c) ((_c)->channelFlags & CHANNEL_HT40MINUS)
 
 enum ath9k_power_mode {
  ATH9K_PM_AWAKE = 0,
@@ -482,10 +464,6 @@ struct ath9k_beacon_state {
  u32 bs_intval;
 #define ATH9K_TSFOOR_THRESHOLD    0x00004240 /* 16k us */
  u32 bs_dtimperiod;
- u16 bs_cfpperiod;
- u16 bs_cfpmaxduration;
- u32 bs_cfpnext;
- u16 bs_timoffset;
  u16 bs_bmissthreshold;
  u32 bs_sleepduration;
  u32 bs_tsfoor_threshold;
@@ -521,12 +499,6 @@ struct ath9k_hw_version {
 
 #define AR_GENTMR_BIT(_index) (1 << (_index))
 
-/*
- * Using de Bruijin sequence to look up 1's index in a 32 bit number
- * debruijn32 = 0000 0111 0111 1100 1011 0101 0011 0001
- */
-#define debruijn32 0x077CB531U
-
 struct ath_gen_timer_configuration {
  u32 next_addr;
  u32 period_addr;
@@ -542,12 +514,8 @@ struct ath_gen_timer {
 };
 
 struct ath_gen_timer_table {
- u32 gen_timer_index[32];
  struct ath_gen_timer *timers[ATH_MAX_GEN_TIMER];
- union {
-  unsigned long timer_bits;
-  u16 val;
- } timer_mask;
+ u16 timer_mask;
 };
 
 struct ath_hw_antcomb_conf {
@@ -557,6 +525,7 @@ struct ath_hw_antcomb_conf {
  u8 main_gaintb;
  u8 alt_gaintb;
  int lna1_lna2_delta;
+ int lna1_lna2_switch_delta;
  u8 div_group;
 };
 
@@ -617,6 +586,10 @@ struct ath_hw_radar_conf {
  * register settings through the register initialization.
  */
 struct ath_hw_private_ops {
+ void (*init_hang_checks)(struct ath_hw *ah);
+ bool (*detect_mac_hang)(struct ath_hw *ah);
+ bool (*detect_bb_hang)(struct ath_hw *ah);
+
  /* Calibration ops */
  void (*init_cal_settings)(struct ath_hw *ah);
  bool (*init_cal)(struct ath_hw *ah, struct ath9k_channel *chan);
@@ -711,7 +684,8 @@ struct ath_hw_ops {
      struct ath9k_channel *chan,
      u8 rxchainmask,
      bool longcal);
- bool (*get_isr)(struct ath_hw *ah, enum ath9k_int *masked);
+ bool (*get_isr)(struct ath_hw *ah, enum ath9k_int *masked,
+   u32 *sync_cause_p);
  void (*set_txdesc)(struct ath_hw *ah, void *ds,
       struct ath_tx_info *i);
  int (*proc_txdesc)(struct ath_hw *ah, void *ds,
@@ -720,11 +694,18 @@ struct ath_hw_ops {
    struct ath_hw_antcomb_conf *antconf);
  void (*antdiv_comb_conf_set)(struct ath_hw *ah,
    struct ath_hw_antcomb_conf *antconf);
- void (*antctrl_shared_chain_lnadiv)(struct ath_hw *hw, bool enable);
  void (*spectral_scan_config)(struct ath_hw *ah,
          struct ath_spec_scan *param);
  void (*spectral_scan_trigger)(struct ath_hw *ah);
  void (*spectral_scan_wait)(struct ath_hw *ah);
+
+ void (*tx99_start)(struct ath_hw *ah, u32 qnum);
+ void (*tx99_stop)(struct ath_hw *ah);
+ void (*tx99_set_txpower)(struct ath_hw *ah, u8 power);
+
+#ifdef CONFIG_ATH9K_BTCOEX_SUPPORT
+ void (*set_bt_ant_diversity)(struct ath_hw *hw, bool enable);
+#endif
 };
 
 struct ath_nf_limits {
@@ -769,7 +750,6 @@ struct ath_hw {
  bool aspm_enabled;
  bool is_monitoring;
  bool need_an_top2_fixup;
- bool shared_chain_lnadiv;
  u16 tx_trig_level;
 
  u32 nf_regs[6];
@@ -801,7 +781,6 @@ struct ath_hw {
  u32 txurn_interrupt_mask;
  atomic_t intr_ref_cnt;
  bool chip_fullsleep;
- u32 atim_window;
  u32 modes_index;
 
  /* Calibration */
@@ -858,10 +837,10 @@ struct ath_hw {
  u32 globaltxtimeout;
 
  /* ANI */
- u32 proc_phyerr;
  u32 aniperiod;
  enum ath9k_ani_cmd ani_function;
  u32 ani_skip_count;
+ struct ar5416AniState ani;
 
 #ifdef CONFIG_ATH9K_BTCOEX_SUPPORT
  struct ath_btcoex_hw btcoex_hw;
@@ -880,15 +859,13 @@ struct ath_hw {
  u32 gpio_mask;
  u32 gpio_val;
 
+ struct ar5416IniArray ini_dfs;
  struct ar5416IniArray iniModes;
  struct ar5416IniArray iniCommon;
  struct ar5416IniArray iniBB_RfGain;
  struct ar5416IniArray iniBank6;
  struct ar5416IniArray iniAddac;
  struct ar5416IniArray iniPcieSerdes;
-#ifdef CONFIG_PM_SLEEP
- struct ar5416IniArray iniPcieSerdesWow;
-#endif
  struct ar5416IniArray iniPcieSerdesLowPower;
  struct ar5416IniArray iniModesFastClock;
  struct ar5416IniArray iniAdditional;
@@ -899,6 +876,9 @@ struct ath_hw {
  struct ar5416IniArray iniCckfirJapan2484;
  struct ar5416IniArray iniModes_9271_ANI_reg;
  struct ar5416IniArray ini_radio_post_sys2ant;
+ struct ar5416IniArray ini_modes_rxgain_5g_xlna;
+ struct ar5416IniArray ini_modes_rxgain_bb_core;
+ struct ar5416IniArray ini_modes_rxgain_bb_postamble;
 
  struct ar5416IniArray iniMac[ATH_INI_NUM_SPLIT];
  struct ar5416IniArray iniBB[ATH_INI_NUM_SPLIT];
@@ -936,7 +916,7 @@ struct ath_hw {
  /* Enterprise mode cap */
  u32 ent_mode;
 
-#ifdef CONFIG_PM_SLEEP
+#ifdef CONFIG_ATH9K_WOW
  u32 wow_event_mask;
 #endif
  bool is_clk_25mhz;
@@ -1023,21 +1003,15 @@ void ath9k_hw_reset_tsf(struct ath_hw *ah);
 void ath9k_hw_set_tsfadjust(struct ath_hw *ah, bool set);
 void ath9k_hw_init_global_settings(struct ath_hw *ah);
 u32 ar9003_get_pll_sqsum_dvc(struct ath_hw *ah);
-void ath9k_hw_set11nmac2040(struct ath_hw *ah);
+void ath9k_hw_set11nmac2040(struct ath_hw *ah, struct ath9k_channel *chan);
 void ath9k_hw_beaconinit(struct ath_hw *ah, u32 next_beacon, u32 beacon_period);
 void ath9k_hw_set_sta_beacon_timers(struct ath_hw *ah,
         const struct ath9k_beacon_state *bs);
+void ath9k_hw_check_nav(struct ath_hw *ah);
 bool ath9k_hw_check_alive(struct ath_hw *ah);
 
 bool ath9k_hw_setpower(struct ath_hw *ah, enum ath9k_power_mode mode);
 
-#ifdef CONFIG_ATH9K_DEBUGFS
-void ath9k_debug_sync_cause(struct ath_common *common, u32 sync_cause);
-#else
-static inline void ath9k_debug_sync_cause(struct ath_common *common,
-       u32 sync_cause) {}
-#endif
-
 /* Generic hw timer primitives */
 struct ath_gen_timer *ath_gen_timer_alloc(struct ath_hw *ah,
        void (*trigger)(void *),
@@ -1072,6 +1046,7 @@ void ar9002_hw_enable_async_fifo(struct ath_hw *ah);
  * Code specific to AR9003, we stuff these here to avoid callbacks
  * for older families
  */
+bool ar9003_hw_bb_watchdog_check(struct ath_hw *ah);
 void ar9003_hw_bb_watchdog_config(struct ath_hw *ah);
 void ar9003_hw_bb_watchdog_read(struct ath_hw *ah);
 void ar9003_hw_bb_watchdog_dbg_info(struct ath_hw *ah);
@@ -1141,7 +1116,7 @@ ath9k_hw_get_btcoex_scheme(struct ath_hw *ah)
 #endif /* CONFIG_ATH9K_BTCOEX_SUPPORT */
 
 
-#ifdef CONFIG_PM_SLEEP
+#ifdef CONFIG_ATH9K_WOW
 const char *ath9k_hw_wow_event_to_string(u32 wow_event);
 void ath9k_hw_wow_apply_pattern(struct ath_hw *ah, u8 *user_pattern,
     u8 *user_mask, int pattern_count,
@@ -1169,8 +1144,6 @@ static inline void ath9k_hw_wow_enable(struct ath_hw *ah, u32 pattern_enable)
 }
 #endif
 
-
-
 #define ATH9K_CLOCK_RATE_CCK  22
 #define ATH9K_CLOCK_RATE_5GHZ_OFDM 40
 #define ATH9K_CLOCK_RATE_2GHZ_OFDM 44
diff --git a/drivers/net/wireless/ath/ath9k/init.c b/drivers/net/wireless/ath/ath9k/init.c
index 483c08c..0246b99 100644
--- a/drivers/net/wireless/ath/ath9k/init.c
+++ b/drivers/net/wireless/ath/ath9k/init.c
@@ -21,6 +21,7 @@
 #include <linux/ath9k_platform.h>
 #include <linux/module.h>
 #include <linux/relay.h>
+#include <net/ieee80211_radiotap.h>
 
 #include "ath9k.h"
 
@@ -52,108 +53,19 @@ static int ath9k_btcoex_enable;
 module_param_named(btcoex_enable, ath9k_btcoex_enable, int, 0444);
 MODULE_PARM_DESC(btcoex_enable, "Enable wifi-BT coexistence");
 
-static int ath9k_enable_diversity;
-module_param_named(enable_diversity, ath9k_enable_diversity, int, 0444);
-MODULE_PARM_DESC(enable_diversity, "Enable Antenna diversity for AR9565");
+static int ath9k_bt_ant_diversity;
+module_param_named(bt_ant_diversity, ath9k_bt_ant_diversity, int, 0444);
+MODULE_PARM_DESC(bt_ant_diversity, "Enable WLAN/BT RX antenna diversity");
 
-bool is_ath9k_unloaded;
-/* We use the hw_value as an index into our private channel structure */
-
-#define CHAN2G(_freq, _idx)  { \
- .band = IEEE80211_BAND_2GHZ, \
- .center_freq = (_freq), \
- .hw_value = (_idx), \
- .max_power = 20, \
-}
-
-#define CHAN5G(_freq, _idx) { \
- .band = IEEE80211_BAND_5GHZ, \
- .center_freq = (_freq), \
- .hw_value = (_idx), \
- .max_power = 20, \
-}
-
-/* Some 2 GHz radios are actually tunable on 2312-2732
- * on 5 MHz steps, we support the channels which we know
- * we have calibration data for all cards though to make
- * this static */
-static const struct ieee80211_channel ath9k_2ghz_chantable[] = {
- CHAN2G(2412, 0), /* Channel 1 */
- CHAN2G(2417, 1), /* Channel 2 */
- CHAN2G(2422, 2), /* Channel 3 */
- CHAN2G(2427, 3), /* Channel 4 */
- CHAN2G(2432, 4), /* Channel 5 */
- CHAN2G(2437, 5), /* Channel 6 */
- CHAN2G(2442, 6), /* Channel 7 */
- CHAN2G(2447, 7), /* Channel 8 */
- CHAN2G(2452, 8), /* Channel 9 */
- CHAN2G(2457, 9), /* Channel 10 */
- CHAN2G(2462, 10), /* Channel 11 */
- CHAN2G(2467, 11), /* Channel 12 */
- CHAN2G(2472, 12), /* Channel 13 */
- CHAN2G(2484, 13), /* Channel 14 */
-};
-
-/* Some 5 GHz radios are actually tunable on XXXX-YYYY
- * on 5 MHz steps, we support the channels which we know
- * we have calibration data for all cards though to make
- * this static */
-static const struct ieee80211_channel ath9k_5ghz_chantable[] = {
- /* _We_ call this UNII 1 */
- CHAN5G(5180, 14), /* Channel 36 */
- CHAN5G(5200, 15), /* Channel 40 */
- CHAN5G(5220, 16), /* Channel 44 */
- CHAN5G(5240, 17), /* Channel 48 */
- /* _We_ call this UNII 2 */
- CHAN5G(5260, 18), /* Channel 52 */
- CHAN5G(5280, 19), /* Channel 56 */
- CHAN5G(5300, 20), /* Channel 60 */
- CHAN5G(5320, 21), /* Channel 64 */
- /* _We_ call this "Middle band" */
- CHAN5G(5500, 22), /* Channel 100 */
- CHAN5G(5520, 23), /* Channel 104 */
- CHAN5G(5540, 24), /* Channel 108 */
- CHAN5G(5560, 25), /* Channel 112 */
- CHAN5G(5580, 26), /* Channel 116 */
- CHAN5G(5600, 27), /* Channel 120 */
- CHAN5G(5620, 28), /* Channel 124 */
- CHAN5G(5640, 29), /* Channel 128 */
- CHAN5G(5660, 30), /* Channel 132 */
- CHAN5G(5680, 31), /* Channel 136 */
- CHAN5G(5700, 32), /* Channel 140 */
- /* _We_ call this UNII 3 */
- CHAN5G(5745, 33), /* Channel 149 */
- CHAN5G(5765, 34), /* Channel 153 */
- CHAN5G(5785, 35), /* Channel 157 */
- CHAN5G(5805, 36), /* Channel 161 */
- CHAN5G(5825, 37), /* Channel 165 */
-};
-
-/* Atheros hardware rate code addition for short premble */
-#define SHPCHECK(__hw_rate, __flags) \
- ((__flags & IEEE80211_RATE_SHORT_PREAMBLE) ? (__hw_rate | 0x04 ) : 0)
+static int ath9k_ps_enable;
+module_param_named(ps_enable, ath9k_ps_enable, int, 0444);
+MODULE_PARM_DESC(ps_enable, "Enable WLAN PowerSave");
 
-#define RATE(_bitrate, _hw_rate, _flags) {              \
- .bitrate        = (_bitrate),                   \
- .flags          = (_flags),                     \
- .hw_value       = (_hw_rate),                   \
- .hw_value_short = (SHPCHECK(_hw_rate, _flags))  \
-}
+static int ath9k_use_chanctx;
+module_param_named(use_chanctx, ath9k_use_chanctx, int, 0444);
+MODULE_PARM_DESC(use_chanctx, "Enable channel context for concurrency");
 
-static struct ieee80211_rate ath9k_legacy_rates[] = {
- RATE(10, 0x1b, 0),
- RATE(20, 0x1a, IEEE80211_RATE_SHORT_PREAMBLE),
- RATE(55, 0x19, IEEE80211_RATE_SHORT_PREAMBLE),
- RATE(110, 0x18, IEEE80211_RATE_SHORT_PREAMBLE),
- RATE(60, 0x0b, 0),
- RATE(90, 0x0f, 0),
- RATE(120, 0x0a, 0),
- RATE(180, 0x0e, 0),
- RATE(240, 0x09, 0),
- RATE(360, 0x0d, 0),
- RATE(480, 0x08, 0),
- RATE(540, 0x0c, 0),
-};
+bool is_ath9k_unloaded;
 
 #ifdef CONFIG_MAC80211_LEDS
 static const struct ieee80211_tpt_blink ath9k_tpt_blink[] = {
@@ -245,64 +157,6 @@ static unsigned int ath9k_reg_rmw(void *hw_priv, u32 reg_offset, u32 set, u32 cl
 /*     Initialization     */
 /**************************/
 
-static void setup_ht_cap(struct ath_softc *sc,
-    struct ieee80211_sta_ht_cap *ht_info)
-{
- struct ath_hw *ah = sc->sc_ah;
- struct ath_common *common = ath9k_hw_common(ah);
- u8 tx_streams, rx_streams;
- int i, max_streams;
-
- ht_info->ht_supported = true;
- ht_info->cap = IEEE80211_HT_CAP_SUP_WIDTH_20_40 |
-         IEEE80211_HT_CAP_SM_PS |
-         IEEE80211_HT_CAP_SGI_40 |
-         IEEE80211_HT_CAP_DSSSCCK40;
-
- if (sc->sc_ah->caps.hw_caps & ATH9K_HW_CAP_LDPC)
-  ht_info->cap |= IEEE80211_HT_CAP_LDPC_CODING;
-
- if (sc->sc_ah->caps.hw_caps & ATH9K_HW_CAP_SGI_20)
-  ht_info->cap |= IEEE80211_HT_CAP_SGI_20;
-
- ht_info->ampdu_factor = IEEE80211_HT_MAX_AMPDU_64K;
- ht_info->ampdu_density = IEEE80211_HT_MPDU_DENSITY_8;
-
- if (AR_SREV_9330(ah) || AR_SREV_9485(ah) || AR_SREV_9565(ah))
-  max_streams = 1;
- else if (AR_SREV_9462(ah))
-  max_streams = 2;
- else if (AR_SREV_9300_20_OR_LATER(ah))
-  max_streams = 3;
- else
-  max_streams = 2;
-
- if (AR_SREV_9280_20_OR_LATER(ah)) {
-  if (max_streams >= 2)
-   ht_info->cap |= IEEE80211_HT_CAP_TX_STBC;
-  ht_info->cap |= (1 << IEEE80211_HT_CAP_RX_STBC_SHIFT);
- }
-
- /* set up supported mcs set */
- memset(&ht_info->mcs, 0, sizeof(ht_info->mcs));
- tx_streams = ath9k_cmn_count_streams(ah->txchainmask, max_streams);
- rx_streams = ath9k_cmn_count_streams(ah->rxchainmask, max_streams);
-
- ath_dbg(common, CONFIG, "TX streams %d, RX streams: %d\n",
-  tx_streams, rx_streams);
-
- if (tx_streams != rx_streams) {
-  ht_info->mcs.tx_params |= IEEE80211_HT_MCS_TX_RX_DIFF;
-  ht_info->mcs.tx_params |= ((tx_streams - 1) <<
-    IEEE80211_HT_MCS_TX_MAX_STREAMS_SHIFT);
- }
-
- for (i = 0; i < rx_streams; i++)
-  ht_info->mcs.rx_mask[i] = 0xff;
-
- ht_info->mcs.tx_params |= IEEE80211_HT_MCS_TX_DEFINED;
-}
-
 static void ath9k_reg_notifier(struct wiphy *wiphy,
           struct regulatory_request *request)
 {
@@ -338,7 +192,6 @@ int ath_descdma_setup(struct ath_softc *sc, struct ath_descdma *dd,
 {
  struct ath_common *common = ath9k_hw_common(sc->sc_ah);
  u8 *ds;
- struct ath_buf *bf;
  int i, bsize, desc_len;
 
  ath_dbg(common, CONFIG, "%s DMA: %u buffers %u desc/buf\n",
@@ -390,33 +243,68 @@ int ath_descdma_setup(struct ath_softc *sc, struct ath_descdma *dd,
   ito64(dd->dd_desc_paddr), /*XXX*/(u32) dd->dd_desc_len);
 
  /* allocate buffers */
- bsize = sizeof(struct ath_buf) * nbuf;
- bf = devm_kzalloc(sc->dev, bsize, GFP_KERNEL);
- if (!bf)
-  return -ENOMEM;
+ if (is_tx) {
+  struct ath_buf *bf;
 
- for (i = 0; i < nbuf; i++, bf++, ds += (desc_len * ndesc)) {
-  bf->bf_desc = ds;
-  bf->bf_daddr = DS2PHYS(dd, ds);
-
-  if (!(sc->sc_ah->caps.hw_caps &
-        ATH9K_HW_CAP_4KB_SPLITTRANS)) {
-   /*
-    * Skip descriptor addresses which can cause 4KB
-    * boundary crossing (addr + length) with a 32 dword
-    * descriptor fetch.
-    */
-   while (ATH_DESC_4KB_BOUND_CHECK(bf->bf_daddr)) {
-    BUG_ON((caddr_t) bf->bf_desc >=
-           ((caddr_t) dd->dd_desc +
-     dd->dd_desc_len));
-
-    ds += (desc_len * ndesc);
-    bf->bf_desc = ds;
-    bf->bf_daddr = DS2PHYS(dd, ds);
+  bsize = sizeof(struct ath_buf) * nbuf;
+  bf = devm_kzalloc(sc->dev, bsize, GFP_KERNEL);
+  if (!bf)
+   return -ENOMEM;
+
+  for (i = 0; i < nbuf; i++, bf++, ds += (desc_len * ndesc)) {
+   bf->bf_desc = ds;
+   bf->bf_daddr = DS2PHYS(dd, ds);
+
+   if (!(sc->sc_ah->caps.hw_caps &
+      ATH9K_HW_CAP_4KB_SPLITTRANS)) {
+    /*
+     * Skip descriptor addresses which can cause 4KB
+     * boundary crossing (addr + length) with a 32 dword
+     * descriptor fetch.
+     */
+    while (ATH_DESC_4KB_BOUND_CHECK(bf->bf_daddr)) {
+     BUG_ON((caddr_t) bf->bf_desc >=
+         ((caddr_t) dd->dd_desc +
+      dd->dd_desc_len));
+
+     ds += (desc_len * ndesc);
+     bf->bf_desc = ds;
+     bf->bf_daddr = DS2PHYS(dd, ds);
+    }
    }
+   list_add_tail(&bf->list, head);
+  }
+ } else {
+  struct ath_rxbuf *bf;
+
+  bsize = sizeof(struct ath_rxbuf) * nbuf;
+  bf = devm_kzalloc(sc->dev, bsize, GFP_KERNEL);
+  if (!bf)
+   return -ENOMEM;
+
+  for (i = 0; i < nbuf; i++, bf++, ds += (desc_len * ndesc)) {
+   bf->bf_desc = ds;
+   bf->bf_daddr = DS2PHYS(dd, ds);
+
+   if (!(sc->sc_ah->caps.hw_caps &
+      ATH9K_HW_CAP_4KB_SPLITTRANS)) {
+    /*
+     * Skip descriptor addresses which can cause 4KB
+     * boundary crossing (addr + length) with a 32 dword
+     * descriptor fetch.
+     */
+    while (ATH_DESC_4KB_BOUND_CHECK(bf->bf_daddr)) {
+     BUG_ON((caddr_t) bf->bf_desc >=
+         ((caddr_t) dd->dd_desc +
+      dd->dd_desc_len));
+
+     ds += (desc_len * ndesc);
+     bf->bf_desc = ds;
+     bf->bf_daddr = DS2PHYS(dd, ds);
+    }
+   }
+   list_add_tail(&bf->list, head);
   }
-  list_add_tail(&bf->list, head);
  }
  return 0;
 }
@@ -427,10 +315,10 @@ static int ath9k_init_queues(struct ath_softc *sc)
 
  sc->beacon.beaconq = ath9k_hw_beaconq_setup(sc->sc_ah);
  sc->beacon.cabq = ath_txq_setup(sc, ATH9K_TX_QUEUE_CAB, 0);
-
- sc->config.cabqReadytime = ATH_CABQ_READY_TIME;
  ath_cabq_update(sc);
 
+ sc->tx.uapsdq = ath_txq_setup(sc, ATH9K_TX_QUEUE_UAPSD, 0);
+
  for (i = 0; i < IEEE80211_NUM_ACS; i++) {
   sc->tx.txq_map[i] = ath_txq_setup(sc, ATH9K_TX_QUEUE_DATA, i);
   sc->tx.txq_map[i]->mac80211_qnum = i;
@@ -439,51 +327,6 @@ static int ath9k_init_queues(struct ath_softc *sc)
  return 0;
 }
 
-static int ath9k_init_channels_rates(struct ath_softc *sc)
-{
- void *channels;
-
- BUILD_BUG_ON(ARRAY_SIZE(ath9k_2ghz_chantable) +
-       ARRAY_SIZE(ath9k_5ghz_chantable) !=
-       ATH9K_NUM_CHANNELS);
-
- if (sc->sc_ah->caps.hw_caps & ATH9K_HW_CAP_2GHZ) {
-  channels = devm_kzalloc(sc->dev,
-   sizeof(ath9k_2ghz_chantable), GFP_KERNEL);
-  if (!channels)
-      return -ENOMEM;
-
-  memcpy(channels, ath9k_2ghz_chantable,
-         sizeof(ath9k_2ghz_chantable));
-  sc->sbands[IEEE80211_BAND_2GHZ].channels = channels;
-  sc->sbands[IEEE80211_BAND_2GHZ].band = IEEE80211_BAND_2GHZ;
-  sc->sbands[IEEE80211_BAND_2GHZ].n_channels =
-   ARRAY_SIZE(ath9k_2ghz_chantable);
-  sc->sbands[IEEE80211_BAND_2GHZ].bitrates = ath9k_legacy_rates;
-  sc->sbands[IEEE80211_BAND_2GHZ].n_bitrates =
-   ARRAY_SIZE(ath9k_legacy_rates);
- }
-
- if (sc->sc_ah->caps.hw_caps & ATH9K_HW_CAP_5GHZ) {
-  channels = devm_kzalloc(sc->dev,
-   sizeof(ath9k_5ghz_chantable), GFP_KERNEL);
-  if (!channels)
-   return -ENOMEM;
-
-  memcpy(channels, ath9k_5ghz_chantable,
-         sizeof(ath9k_5ghz_chantable));
-  sc->sbands[IEEE80211_BAND_5GHZ].channels = channels;
-  sc->sbands[IEEE80211_BAND_5GHZ].band = IEEE80211_BAND_5GHZ;
-  sc->sbands[IEEE80211_BAND_5GHZ].n_channels =
-   ARRAY_SIZE(ath9k_5ghz_chantable);
-  sc->sbands[IEEE80211_BAND_5GHZ].bitrates =
-   ath9k_legacy_rates + 4;
-  sc->sbands[IEEE80211_BAND_5GHZ].n_bitrates =
-   ARRAY_SIZE(ath9k_legacy_rates) - 4;
- }
- return 0;
-}
-
 static void ath9k_init_misc(struct ath_softc *sc)
 {
  struct ath_common *common = ath9k_hw_common(sc->sc_ah);
@@ -491,7 +334,7 @@ static void ath9k_init_misc(struct ath_softc *sc)
 
  setup_timer(&common->ani.timer, ath_ani_calibrate, (unsigned long)sc);
 
- sc->last_rssi = ATH_RSSI_DUMMY_MARKER;
+ common->last_rssi = ATH_RSSI_DUMMY_MARKER;
  sc->config.txpowlimit = ATH_TXPOWER_MAX;
  memcpy(common->bssidmask, ath_bcast_mac, ETH_ALEN);
  sc->beacon.slottime = ATH9K_SLOT_TIME_9;
@@ -510,19 +353,68 @@ static void ath9k_init_misc(struct ath_softc *sc)
  sc->spec_config.fft_period = 0xF;
 }
 
-static void ath9k_init_platform(struct ath_softc *sc)
+static void ath9k_init_pcoem_platform(struct ath_softc *sc)
 {
  struct ath_hw *ah = sc->sc_ah;
+ struct ath9k_hw_capabilities *pCap = &ah->caps;
  struct ath_common *common = ath9k_hw_common(ah);
 
  if (common->bus_ops->ath_bus_type != ATH_PCI)
   return;
 
- if (sc->driver_data & ATH9K_PCI_CUS198) {
+ if (sc->driver_data & (ATH9K_PCI_CUS198 |
+          ATH9K_PCI_CUS230)) {
   ah->config.xlna_gpio = 9;
   ah->config.xatten_margin_cfg = true;
+  ah->config.alt_mingainidx = true;
+  ah->config.ant_ctrl_comm2g_switch_enable = 0x000BBB88;
+  sc->ant_comb.low_rssi_thresh = 20;
+  sc->ant_comb.fast_div_bias = 3;
+
+  ath_info(common, "Set parameters for %s\n",
+    (sc->driver_data & ATH9K_PCI_CUS198) ?
+    "CUS198" : "CUS230");
+ }
 
-  ath_info(common, "Set parameters for CUS198\n");
+ if (sc->driver_data & ATH9K_PCI_CUS217)
+  ath_info(common, "CUS217 card detected\n");
+
+ if (sc->driver_data & ATH9K_PCI_CUS252)
+  ath_info(common, "CUS252 card detected\n");
+
+ if (sc->driver_data & ATH9K_PCI_AR9565_1ANT)
+  ath_info(common, "WB335 1-ANT card detected\n");
+
+ if (sc->driver_data & ATH9K_PCI_AR9565_2ANT)
+  ath_info(common, "WB335 2-ANT card detected\n");
+
+ if (sc->driver_data & ATH9K_PCI_KILLER)
+  ath_info(common, "Killer Wireless card detected\n");
+
+ /*
+  * Some WB335 cards do not support antenna diversity. Since
+  * we use a hardcoded value for AR9565 instead of using the
+  * EEPROM/OTP data, remove the combining feature from
+  * the HW capabilities bitmap.
+  */
+ if (sc->driver_data & (ATH9K_PCI_AR9565_1ANT | ATH9K_PCI_AR9565_2ANT)) {
+  if (!(sc->driver_data & ATH9K_PCI_BT_ANT_DIV))
+   pCap->hw_caps &= ~ATH9K_HW_CAP_ANT_DIV_COMB;
+ }
+
+ if (sc->driver_data & ATH9K_PCI_BT_ANT_DIV) {
+  pCap->hw_caps |= ATH9K_HW_CAP_BT_ANT_DIV;
+  ath_info(common, "Set BT/WLAN RX diversity capability\n");
+ }
+
+ if (sc->driver_data & ATH9K_PCI_D3_L1_WAR) {
+  ah->config.pcie_waen = 0x0040473b;
+  ath_info(common, "Enable WAR for ASPM D3/L1\n");
+ }
+
+ if (sc->driver_data & ATH9K_PCI_NO_PLL_PWRSAVE) {
+  ah->config.no_pll_pwrsave = true;
+  ath_info(common, "Disable PLL PowerSave\n");
  }
 }
 
@@ -571,11 +463,33 @@ static void ath9k_eeprom_release(struct ath_softc *sc)
  release_firmware(sc->sc_ah->eeprom_blob);
 }
 
+static int ath9k_init_soc_platform(struct ath_softc *sc)
+{
+ struct ath9k_platform_data *pdata = sc->dev->platform_data;
+ struct ath_hw *ah = sc->sc_ah;
+ int ret = 0;
+
+ if (!pdata)
+  return 0;
+
+ if (pdata->eeprom_name) {
+  ret = ath9k_eeprom_request(sc, pdata->eeprom_name);
+  if (ret)
+   return ret;
+ }
+
+ if (pdata->tx_gain_buffalo)
+  ah->config.tx_gain_buffalo = true;
+
+ return ret;
+}
+
 static int ath9k_init_softc(u16 devid, struct ath_softc *sc,
        const struct ath_bus_ops *bus_ops)
 {
  struct ath9k_platform_data *pdata = sc->dev->platform_data;
  struct ath_hw *ah = NULL;
+ struct ath9k_hw_capabilities *pCap;
  struct ath_common *common;
  int ret = 0, i;
  int csz = 0;
@@ -590,12 +504,15 @@ static int ath9k_init_softc(u16 devid, struct ath_softc *sc,
  ah->reg_ops.read = ath9k_ioread32;
  ah->reg_ops.write = ath9k_iowrite32;
  ah->reg_ops.rmw = ath9k_reg_rmw;
- atomic_set(&ah->intr_ref_cnt, -1);
  sc->sc_ah = ah;
+ pCap = &ah->caps;
 
- sc->dfs_detector = dfs_pattern_detector_init(ah, NL80211_DFS_UNSET);
+ common = ath9k_hw_common(ah);
+ sc->dfs_detector = dfs_pattern_detector_init(common, NL80211_DFS_UNSET);
+ sc->tx99_power = MAX_RATE_POWER + 1;
+ init_waitqueue_head(&sc->tx_wait);
 
- if (!pdata) {
+ if (!pdata || pdata->use_eeprom) {
   ah->ah_flags |= AH_USE_EEPROM;
   sc->sc_ah->led_pin = -1;
  } else {
@@ -607,7 +524,6 @@ static int ath9k_init_softc(u16 devid, struct ath_softc *sc,
   ah->external_reset = pdata->external_reset;
  }
 
- common = ath9k_hw_common(ah);
  common->ops = &ah->reg_ops;
  common->bus_ops = bus_ops;
  common->ah = ah;
@@ -620,32 +536,35 @@ static int ath9k_init_softc(u16 devid, struct ath_softc *sc,
  /*
   * Platform quirks.
   */
- ath9k_init_platform(sc);
+ ath9k_init_pcoem_platform(sc);
+
+ ret = ath9k_init_soc_platform(sc);
+ if (ret)
+  return ret;
 
  /*
-  * Enable Antenna diversity only when BTCOEX is disabled
-  * and the user manually requests the feature.
+  * Enable WLAN/BT RX Antenna diversity only when:
+  *
+  * - BTCOEX is disabled.
+  * - the user manually requests the feature.
+  * - the HW cap is set using the platform data.
   */
- if (!common->btcoex_enabled && ath9k_enable_diversity)
-  common->antenna_diversity = 1;
+ if (!common->btcoex_enabled && ath9k_bt_ant_diversity &&
+     (pCap->hw_caps & ATH9K_HW_CAP_BT_ANT_DIV))
+  common->bt_ant_diversity = 1;
 
  spin_lock_init(&common->cc_lock);
-
  spin_lock_init(&sc->sc_serial_rw);
  spin_lock_init(&sc->sc_pm_lock);
  mutex_init(&sc->mutex);
-#ifdef CONFIG_ATH9K_MAC_DEBUG
- spin_lock_init(&sc->debug.samp_lock);
-#endif
  tasklet_init(&sc->intr_tq, ath9k_tasklet, (unsigned long)sc);
  tasklet_init(&sc->bcon_tasklet, ath9k_beacon_tasklet,
        (unsigned long)sc);
 
+ setup_timer(&sc->sleep_timer, ath_ps_full_sleep, (unsigned long)sc);
  INIT_WORK(&sc->hw_reset_work, ath_reset_work);
- INIT_WORK(&sc->hw_check_work, ath_hw_check);
  INIT_WORK(&sc->paprd_work, ath_paprd_calibrate);
  INIT_DELAYED_WORK(&sc->hw_pll_work, ath_hw_pll_work);
- setup_timer(&sc->rx_poll_timer, ath_rx_poll, (unsigned long)sc);
 
  /*
   * Cache line size is used to size and align various
@@ -654,12 +573,6 @@ static int ath9k_init_softc(u16 devid, struct ath_softc *sc,
  ath_read_cachesize(common, &csz);
  common->cachelsz = csz << 2; /* convert to bytes */
 
- if (pdata && pdata->eeprom_name) {
-  ret = ath9k_eeprom_request(sc, pdata->eeprom_name);
-  if (ret)
-   return ret;
- }
-
  /* Initializes the hardware for all supported chipsets */
  ret = ath9k_hw_init(ah);
  if (ret)
@@ -676,10 +589,13 @@ static int ath9k_init_softc(u16 devid, struct ath_softc *sc,
  if (ret)
   goto err_btcoex;
 
- ret = ath9k_init_channels_rates(sc);
+ ret = ath9k_cmn_init_channels_rates(common);
  if (ret)
   goto err_btcoex;
 
+ sc->p2p_ps_timer = ath_gen_timer_alloc(sc->sc_ah, ath9k_p2p_ps_timer,
+  NULL, sc, AR_FIRST_NDP_TIMER);
+
  ath9k_cmn_init_crypto(sc->sc_ah);
  ath9k_init_misc(sc);
  ath_fill_led_pin(sc);
@@ -697,6 +613,7 @@ err_queues:
  ath9k_hw_deinit(ah);
 err_hw:
  ath9k_eeprom_release(sc);
+ dev_kfree_skb_any(sc->tx99_skb);
  return ret;
 }
 
@@ -705,13 +622,16 @@ static void ath9k_init_band_txpower(struct ath_softc *sc, int band)
  struct ieee80211_supported_band *sband;
  struct ieee80211_channel *chan;
  struct ath_hw *ah = sc->sc_ah;
+ struct ath_common *common = ath9k_hw_common(ah);
+ struct cfg80211_chan_def chandef;
  int i;
 
- sband = &sc->sbands[band];
+ sband = &common->sbands[band];
  for (i = 0; i < sband->n_channels; i++) {
   chan = &sband->channels[i];
   ah->curchan = &ah->channels[chan->hw_value];
-  ath9k_cmn_update_ichannel(ah->curchan, chan, NL80211_CHAN_HT20);
+  cfg80211_chandef_create(&chandef, chan, NL80211_CHAN_HT20);
+  ath9k_cmn_get_channel(sc->hw, ah, &chandef);
   ath9k_hw_set_txpowerlimit(ah, MAX_RATE_POWER, true);
  }
 }
@@ -729,32 +649,27 @@ static void ath9k_init_txpower_limits(struct ath_softc *sc)
  ah->curchan = curchan;
 }
 
-void ath9k_reload_chainmask_settings(struct ath_softc *sc)
-{
- if (!(sc->sc_ah->caps.hw_caps & ATH9K_HW_CAP_HT))
-  return;
-
- if (sc->sc_ah->caps.hw_caps & ATH9K_HW_CAP_2GHZ)
-  setup_ht_cap(sc, &sc->sbands[IEEE80211_BAND_2GHZ].ht_cap);
- if (sc->sc_ah->caps.hw_caps & ATH9K_HW_CAP_5GHZ)
-  setup_ht_cap(sc, &sc->sbands[IEEE80211_BAND_5GHZ].ht_cap);
-}
-
 static const struct ieee80211_iface_limit if_limits[] = {
- { .max = 2048, .types = BIT(NL80211_IFTYPE_STATION) |
-     BIT(NL80211_IFTYPE_P2P_CLIENT) |
-     BIT(NL80211_IFTYPE_WDS) },
+ { .max = 2048, .types = BIT(NL80211_IFTYPE_STATION) },
  { .max = 8, .types =
 #ifdef CONFIG_MAC80211_MESH
      BIT(NL80211_IFTYPE_MESH_POINT) |
 #endif
-     BIT(NL80211_IFTYPE_AP) |
+     BIT(NL80211_IFTYPE_AP) },
+ { .max = 1, .types = BIT(NL80211_IFTYPE_P2P_CLIENT) |
      BIT(NL80211_IFTYPE_P2P_GO) },
 };
 
+static const struct ieee80211_iface_limit wds_limits[] = {
+ { .max = 2048, .types = BIT(NL80211_IFTYPE_WDS) },
+};
 
 static const struct ieee80211_iface_limit if_dfs_limits[] = {
- { .max = 1, .types = BIT(NL80211_IFTYPE_AP) },
+ { .max = 1, .types = BIT(NL80211_IFTYPE_AP) |
+#ifdef CONFIG_MAC80211_MESH
+     BIT(NL80211_IFTYPE_MESH_POINT) |
+#endif
+     BIT(NL80211_IFTYPE_ADHOC) },
 };
 
 static const struct ieee80211_iface_combination if_comb[] = {
@@ -766,17 +681,26 @@ static const struct ieee80211_iface_combination if_comb[] = {
   .beacon_int_infra_match = true,
  },
  {
+  .limits = wds_limits,
+  .n_limits = ARRAY_SIZE(wds_limits),
+  .max_interfaces = 2048,
+  .num_different_channels = 1,
+  .beacon_int_infra_match = true,
+ },
+#ifdef CONFIG_ATH9K_DFS_CERTIFIED
+ {
   .limits = if_dfs_limits,
   .n_limits = ARRAY_SIZE(if_dfs_limits),
   .max_interfaces = 1,
   .num_different_channels = 1,
   .beacon_int_infra_match = true,
-  .radar_detect_widths = BIT(NL80211_CHAN_NO_HT) |
-     BIT(NL80211_CHAN_HT20),
+  .radar_detect_widths = BIT(NL80211_CHAN_WIDTH_20_NOHT) |
+     BIT(NL80211_CHAN_WIDTH_20),
  }
+#endif
 };
 
-void ath9k_set_hw_capab(struct ath_softc *sc, struct ieee80211_hw *hw)
+static void ath9k_set_hw_capab(struct ath_softc *sc, struct ieee80211_hw *hw)
 {
  struct ath_hw *ah = sc->sc_ah;
  struct ath_common *common = ath9k_hw_common(ah);
@@ -784,58 +708,56 @@ void ath9k_set_hw_capab(struct ath_softc *sc, struct ieee80211_hw *hw)
  hw->flags = IEEE80211_HW_RX_INCLUDES_FCS |
   IEEE80211_HW_HOST_BROADCAST_PS_BUFFERING |
   IEEE80211_HW_SIGNAL_DBM |
-  IEEE80211_HW_SUPPORTS_PS |
   IEEE80211_HW_PS_NULLFUNC_STACK |
   IEEE80211_HW_SPECTRUM_MGMT |
   IEEE80211_HW_REPORTS_TX_ACK_STATUS |
   IEEE80211_HW_SUPPORTS_RC_TABLE |
   IEEE80211_HW_SUPPORTS_HT_CCK_RATES;
 
- if (sc->sc_ah->caps.hw_caps & ATH9K_HW_CAP_HT)
-   hw->flags |= IEEE80211_HW_AMPDU_AGGREGATION;
+ if (ath9k_ps_enable)
+  hw->flags |= IEEE80211_HW_SUPPORTS_PS;
+
+ if (sc->sc_ah->caps.hw_caps & ATH9K_HW_CAP_HT) {
+  hw->flags |= IEEE80211_HW_AMPDU_AGGREGATION;
+
+  if (AR_SREV_9280_20_OR_LATER(ah))
+   hw->radiotap_mcs_details |=
+    IEEE80211_RADIOTAP_MCS_HAVE_STBC;
+ }
 
  if (AR_SREV_9160_10_OR_LATER(sc->sc_ah) || ath9k_modparam_nohwcrypt)
   hw->flags |= IEEE80211_HW_MFP_CAPABLE;
 
- hw->wiphy->interface_modes =
-  BIT(NL80211_IFTYPE_P2P_GO) |
-  BIT(NL80211_IFTYPE_P2P_CLIENT) |
-  BIT(NL80211_IFTYPE_AP) |
-  BIT(NL80211_IFTYPE_WDS) |
-  BIT(NL80211_IFTYPE_STATION) |
-  BIT(NL80211_IFTYPE_ADHOC) |
-  BIT(NL80211_IFTYPE_MESH_POINT);
-
- hw->wiphy->iface_combinations = if_comb;
- hw->wiphy->n_iface_combinations = ARRAY_SIZE(if_comb);
+ hw->wiphy->features |= (NL80211_FEATURE_ACTIVE_MONITOR |
+    NL80211_FEATURE_AP_MODE_CHAN_WIDTH_CHANGE);
+
+ if (!config_enabled(CONFIG_ATH9K_TX99)) {
+  hw->wiphy->interface_modes =
+   BIT(NL80211_IFTYPE_P2P_GO) |
+   BIT(NL80211_IFTYPE_P2P_CLIENT) |
+   BIT(NL80211_IFTYPE_AP) |
+   BIT(NL80211_IFTYPE_STATION) |
+   BIT(NL80211_IFTYPE_ADHOC) |
+   BIT(NL80211_IFTYPE_MESH_POINT);
+  hw->wiphy->iface_combinations = if_comb;
+  if (!ath9k_use_chanctx) {
+   hw->wiphy->n_iface_combinations = ARRAY_SIZE(if_comb);
+   hw->wiphy->interface_modes |= BIT(NL80211_IFTYPE_WDS);
+  } else
+   hw->wiphy->n_iface_combinations = 1;
+ }
 
  hw->wiphy->flags &= ~WIPHY_FLAG_PS_ON_BY_DEFAULT;
 
  hw->wiphy->flags |= WIPHY_FLAG_IBSS_RSN;
  hw->wiphy->flags |= WIPHY_FLAG_SUPPORTS_TDLS;
  hw->wiphy->flags |= WIPHY_FLAG_HAS_REMAIN_ON_CHANNEL;
-
-#ifdef CONFIG_PM_SLEEP
-
- if ((ah->caps.hw_caps & ATH9K_HW_WOW_DEVICE_CAPABLE) &&
-     device_can_wakeup(sc->dev)) {
-
-  hw->wiphy->wowlan.flags = WIPHY_WOWLAN_MAGIC_PKT |
-       WIPHY_WOWLAN_DISCONNECT;
-  hw->wiphy->wowlan.n_patterns = MAX_NUM_USER_PATTERN;
-  hw->wiphy->wowlan.pattern_min_len = 1;
-  hw->wiphy->wowlan.pattern_max_len = MAX_PATTERN_SIZE;
-
- }
-
- atomic_set(&sc->wow_sleep_proc_intr, -1);
- atomic_set(&sc->wow_got_bmiss_intr, -1);
-
-#endif
+ hw->wiphy->flags |= WIPHY_FLAG_SUPPORTS_5_10_MHZ;
+ hw->wiphy->flags |= WIPHY_FLAG_HAS_CHANNEL_SWITCH;
+ hw->wiphy->flags |= WIPHY_FLAG_AP_UAPSD;
 
  hw->queues = 4;
  hw->max_rates = 4;
- hw->channel_change_time = 5000;
  hw->max_listen_interval = 1;
  hw->max_rate_tries = 10;
  hw->sta_data_size = sizeof(struct ath_node);
@@ -853,12 +775,13 @@ void ath9k_set_hw_capab(struct ath_softc *sc, struct ieee80211_hw *hw)
 
  if (sc->sc_ah->caps.hw_caps & ATH9K_HW_CAP_2GHZ)
   hw->wiphy->bands[IEEE80211_BAND_2GHZ] =
-   &sc->sbands[IEEE80211_BAND_2GHZ];
+   &common->sbands[IEEE80211_BAND_2GHZ];
  if (sc->sc_ah->caps.hw_caps & ATH9K_HW_CAP_5GHZ)
   hw->wiphy->bands[IEEE80211_BAND_5GHZ] =
-   &sc->sbands[IEEE80211_BAND_5GHZ];
+   &common->sbands[IEEE80211_BAND_5GHZ];
 
- ath9k_reload_chainmask_settings(sc);
+ ath9k_init_wow(hw);
+ ath9k_cmn_reload_chainmask(ah);
 
  SET_IEEE80211_PERM_ADDR(hw, common->macaddr);
 }
@@ -881,6 +804,9 @@ int ath9k_init_device(u16 devid, struct ath_softc *sc,
  common = ath9k_hw_common(ah);
  ath9k_set_hw_capab(sc, hw);
 
+ /* Will be cleared in ath9k_start() */
+ set_bit(ATH_OP_INVALID, &common->op_flags);
+
  /* Initialize regulatory */
  error = ath_regd_init(&common->regulatory, sc->hw->wiphy,
          ath9k_reg_notifier);
@@ -950,12 +876,16 @@ static void ath9k_deinit_softc(struct ath_softc *sc)
 {
  int i = 0;
 
+ if (sc->p2p_ps_timer)
+  ath_gen_timer_free(sc->sc_ah, sc->p2p_ps_timer);
+
  ath9k_deinit_btcoex(sc);
 
  for (i = 0; i < ATH9K_NUM_TX_QUEUES; i++)
   if (ATH_TXQ_SETUP(sc, i))
    ath_tx_cleanupq(sc, &sc->tx.txq[i]);
 
+ del_timer_sync(&sc->sleep_timer);
  ath9k_hw_deinit(sc->sc_ah);
  if (sc->dfs_detector != NULL)
   sc->dfs_detector->exit(sc->dfs_detector);
@@ -988,19 +918,11 @@ static int __init ath9k_init(void)
 {
  int error;
 
- /* Register rate control algorithm */
- error = ath_rate_control_register();
- if (error != 0) {
-  pr_err("Unable to register rate control algorithm: %d\n",
-         error);
-  goto err_out;
- }
-
  error = ath_pci_init();
  if (error < 0) {
   pr_err("No PCI devices found, driver not installed\n");
   error = -ENODEV;
-  goto err_rate_unregister;
+  goto err_out;
  }
 
  error = ath_ahb_init();
@@ -1013,9 +935,6 @@ static int __init ath9k_init(void)
 
  err_pci_exit:
  ath_pci_exit();
-
- err_rate_unregister:
- ath_rate_control_unregister();
  err_out:
  return error;
 }
@@ -1026,7 +945,6 @@ static void __exit ath9k_exit(void)
  is_ath9k_unloaded = true;
  ath_ahb_exit();
  ath_pci_exit();
- ath_rate_control_unregister();
  pr_info("%s: Driver unloaded\n", dev_info);
 }
 module_exit(ath9k_exit);
diff --git a/drivers/net/wireless/ath/ath9k/link.c b/drivers/net/wireless/ath/ath9k/link.c
index 849259b..72a715f 100644
--- a/drivers/net/wireless/ath/ath9k/link.c
+++ b/drivers/net/wireless/ath/ath9k/link.c
@@ -28,6 +28,13 @@ void ath_tx_complete_poll_work(struct work_struct *work)
  int i;
  bool needreset = false;
 
+
+ if (sc->tx99_state) {
+  ath_dbg(ath9k_hw_common(sc->sc_ah), RESET,
+   "skip tx hung detection on tx99\n");
+  return;
+ }
+
  for (i = 0; i < IEEE80211_NUM_ACS; i++) {
   txq = sc->tx.txq_map[i];
 
@@ -41,7 +48,7 @@ void ath_tx_complete_poll_work(struct work_struct *work)
     txq->axq_tx_inprogress = true;
    }
   }
-  ath_txq_unlock_complete(sc, txq);
+  ath_txq_unlock(sc, txq);
  }
 
  if (needreset) {
@@ -58,50 +65,26 @@ void ath_tx_complete_poll_work(struct work_struct *work)
 /*
  * Checks if the BB/MAC is hung.
  */
-void ath_hw_check(struct work_struct *work)
+bool ath_hw_check(struct ath_softc *sc)
 {
- struct ath_softc *sc = container_of(work, struct ath_softc, hw_check_work);
  struct ath_common *common = ath9k_hw_common(sc->sc_ah);
- unsigned long flags;
- int busy;
- u8 is_alive, nbeacon = 1;
  enum ath_reset_type type;
+ bool is_alive;
 
  ath9k_ps_wakeup(sc);
+
  is_alive = ath9k_hw_check_alive(sc->sc_ah);
 
- if (is_alive && !AR_SREV_9300(sc->sc_ah))
-  goto out;
- else if (!is_alive && AR_SREV_9300(sc->sc_ah)) {
+ if (!is_alive) {
   ath_dbg(common, RESET,
-   "DCU stuck is detected. Schedule chip reset\n");
+   "HW hang detected, schedule chip reset\n");
   type = RESET_TYPE_MAC_HANG;
-  goto sched_reset;
- }
-
- spin_lock_irqsave(&common->cc_lock, flags);
- busy = ath_update_survey_stats(sc);
- spin_unlock_irqrestore(&common->cc_lock, flags);
-
- ath_dbg(common, RESET, "Possible baseband hang, busy=%d (try %d)\n",
-  busy, sc->hw_busy_count + 1);
- if (busy >= 99) {
-  if (++sc->hw_busy_count >= 3) {
-   type = RESET_TYPE_BB_HANG;
-   goto sched_reset;
-  }
- } else if (busy >= 0) {
-  sc->hw_busy_count = 0;
-  nbeacon = 3;
+  ath9k_queue_reset(sc, type);
  }
 
- ath_start_rx_poll(sc, nbeacon);
- goto out;
-
-sched_reset:
- ath9k_queue_reset(sc, type);
-out:
  ath9k_ps_restore(sc);
+
+ return is_alive;
 }
 
 /*
@@ -132,13 +115,17 @@ void ath_hw_pll_work(struct work_struct *work)
  u32 pll_sqsum;
  struct ath_softc *sc = container_of(work, struct ath_softc,
          hw_pll_work.work);
+ struct ath_common *common = ath9k_hw_common(sc->sc_ah);
  /*
   * ensure that the PLL WAR is executed only
   * after the STA is associated (or) if the
   * beaconing had started in interfaces that
   * uses beacons.
   */
- if (!test_bit(SC_OP_BEACONS, &sc->sc_flags))
+ if (!test_bit(ATH_OP_BEACONS, &common->op_flags))
+  return;
+
+ if (sc->tx99_state)
   return;
 
  ath9k_ps_wakeup(sc);
@@ -152,29 +139,6 @@ void ath_hw_pll_work(struct work_struct *work)
 }
 
 /*
- * RX Polling - monitors baseband hangs.
- */
-void ath_start_rx_poll(struct ath_softc *sc, u8 nbeacon)
-{
- if (!AR_SREV_9300(sc->sc_ah))
-  return;
-
- if (!test_bit(SC_OP_PRIM_STA_VIF, &sc->sc_flags))
-  return;
-
- mod_timer(&sc->rx_poll_timer, jiffies + msecs_to_jiffies
-    (nbeacon * sc->cur_beacon_conf.beacon_interval));
-}
-
-void ath_rx_poll(unsigned long data)
-{
- struct ath_softc *sc = (struct ath_softc *)data;
-
- if (!test_bit(SC_OP_INVALID, &sc->sc_flags))
-  ieee80211_queue_work(sc->hw, &sc->hw_check_work);
-}
-
-/*
  * PA Pre-distortion.
  */
 static void ath_paprd_activate(struct ath_softc *sc)
@@ -184,7 +148,7 @@ static void ath_paprd_activate(struct ath_softc *sc)
  struct ath9k_hw_cal_data *caldata = ah->caldata;
  int chain;
 
- if (!caldata || !caldata->paprd_done) {
+ if (!caldata || !test_bit(PAPRD_DONE, &caldata->cal_flags)) {
   ath_dbg(common, CALIBRATE, "Failed to activate PAPRD\n");
   return;
  }
@@ -256,7 +220,9 @@ void ath_paprd_calibrate(struct work_struct *work)
  int len = 1800;
  int ret;
 
- if (!caldata || !caldata->paprd_packet_sent || caldata->paprd_done) {
+ if (!caldata ||
+     !test_bit(PAPRD_PACKET_SENT, &caldata->cal_flags) ||
+     test_bit(PAPRD_DONE, &caldata->cal_flags)) {
   ath_dbg(common, CALIBRATE, "Skipping PAPRD calibration\n");
   return;
  }
@@ -316,7 +282,7 @@ void ath_paprd_calibrate(struct work_struct *work)
  kfree_skb(skb);
 
  if (chain_ok) {
-  caldata->paprd_done = true;
+  set_bit(PAPRD_DONE, &caldata->cal_flags);
   ath_paprd_activate(sc);
  }
 
@@ -343,7 +309,7 @@ void ath_ani_calibrate(unsigned long data)
  u32 cal_interval, short_cal_interval, long_cal_interval;
  unsigned long flags;
 
- if (ah->caldata && ah->caldata->nfcal_interference)
+ if (ah->caldata && test_bit(NFCAL_INTF, &ah->caldata->cal_flags))
   long_cal_interval = ATH_LONG_CALINTERVAL_INT;
  else
   long_cal_interval = ATH_LONG_CALINTERVAL;
@@ -390,19 +356,17 @@ void ath_ani_calibrate(unsigned long data)
  }
 
  /* Verify whether we must check ANI */
- if (sc->sc_ah->config.enable_ani
-     && (timestamp - common->ani.checkani_timer) >=
-     ah->config.ani_poll_interval) {
+ if ((timestamp - common->ani.checkani_timer) >= ah->config.ani_poll_interval) {
   aniflag = true;
   common->ani.checkani_timer = timestamp;
  }
 
  /* Call ANI routine if necessary */
  if (aniflag) {
-  spin_lock_irqsave(&common->cc_lock, flags);
+  spin_lock(&common->cc_lock);
   ath9k_hw_ani_monitor(ah, ah->curchan);
   ath_update_survey_stats(sc);
-  spin_unlock_irqrestore(&common->cc_lock, flags);
+  spin_unlock(&common->cc_lock);
  }
 
  /* Perform calibration if necessary */
@@ -418,7 +382,6 @@ void ath_ani_calibrate(unsigned long data)
   longcal ? "long" : "", shortcal ? "short" : "",
   aniflag ? "ani" : "", common->ani.caldone ? "true" : "false");
 
- ath9k_debug_samp_bb_mac(sc);
  ath9k_ps_restore(sc);
 
 set_timer:
@@ -428,16 +391,14 @@ set_timer:
  * short calibration and long calibration.
  */
  cal_interval = ATH_LONG_CALINTERVAL;
- if (sc->sc_ah->config.enable_ani)
-  cal_interval = min(cal_interval,
-       (u32)ah->config.ani_poll_interval);
+ cal_interval = min(cal_interval, (u32)ah->config.ani_poll_interval);
  if (!common->ani.caldone)
   cal_interval = min(cal_interval, (u32)short_cal_interval);
 
  mod_timer(&common->ani.timer, jiffies + msecs_to_jiffies(cal_interval));
 
  if (ar9003_is_paprd_enabled(ah) && ah->caldata) {
-  if (!ah->caldata->paprd_done) {
+  if (!test_bit(PAPRD_DONE, &ah->caldata->cal_flags)) {
    ieee80211_queue_work(sc->hw, &sc->paprd_work);
   } else if (!ah->paprd_table_write_done) {
    ath9k_ps_wakeup(sc);
@@ -454,7 +415,7 @@ void ath_start_ani(struct ath_softc *sc)
  unsigned long timestamp = jiffies_to_msecs(jiffies);
 
  if (common->disable_ani ||
-     !test_bit(SC_OP_ANI_RUN, &sc->sc_flags) ||
+     !test_bit(ATH_OP_ANI_RUN, &common->op_flags) ||
      (sc->hw->conf.flags & IEEE80211_CONF_OFFCHANNEL))
   return;
 
@@ -478,6 +439,7 @@ void ath_stop_ani(struct ath_softc *sc)
 void ath_check_ani(struct ath_softc *sc)
 {
  struct ath_hw *ah = sc->sc_ah;
+ struct ath_common *common = ath9k_hw_common(sc->sc_ah);
  struct ath_beacon_config *cur_conf = &sc->cur_beacon_conf;
 
  /*
@@ -493,23 +455,23 @@ void ath_check_ani(struct ath_softc *sc)
     * Disable ANI only when there are no
     * associated stations.
     */
-   if (!test_bit(SC_OP_PRIM_STA_VIF, &sc->sc_flags))
+   if (!test_bit(ATH_OP_PRIM_STA_VIF, &common->op_flags))
     goto stop_ani;
   }
  } else if (ah->opmode == NL80211_IFTYPE_STATION) {
-  if (!test_bit(SC_OP_PRIM_STA_VIF, &sc->sc_flags))
+  if (!test_bit(ATH_OP_PRIM_STA_VIF, &common->op_flags))
    goto stop_ani;
  }
 
- if (!test_bit(SC_OP_ANI_RUN, &sc->sc_flags)) {
-  set_bit(SC_OP_ANI_RUN, &sc->sc_flags);
+ if (!test_bit(ATH_OP_ANI_RUN, &common->op_flags)) {
+  set_bit(ATH_OP_ANI_RUN, &common->op_flags);
   ath_start_ani(sc);
  }
 
  return;
 
 stop_ani:
- clear_bit(SC_OP_ANI_RUN, &sc->sc_flags);
+ clear_bit(ATH_OP_ANI_RUN, &common->op_flags);
  ath_stop_ani(sc);
 }
 
@@ -521,7 +483,8 @@ void ath_update_survey_nf(struct ath_softc *sc, int channel)
 
  if (chan->noisefloor) {
   survey->filled |= SURVEY_INFO_NOISE_DBM;
-  survey->noise = ath9k_hw_getchan_noise(ah, chan);
+  survey->noise = ath9k_hw_getchan_noise(ah, chan,
+             chan->noisefloor);
  }
 }
 
diff --git a/drivers/net/wireless/ath/ath9k/mac.c b/drivers/net/wireless/ath/ath9k/mac.c
index 566109a..275205a 100644
--- a/drivers/net/wireless/ath/ath9k/mac.c
+++ b/drivers/net/wireless/ath/ath9k/mac.c
@@ -374,7 +374,6 @@ EXPORT_SYMBOL(ath9k_hw_releasetxqueue);
 bool ath9k_hw_resettxqueue(struct ath_hw *ah, u32 q)
 {
  struct ath_common *common = ath9k_hw_common(ah);
- struct ath9k_channel *chan = ah->curchan;
  struct ath9k_tx_queue_info *qi;
  u32 cwMin, chanCwMin, value;
 
@@ -387,10 +386,7 @@ bool ath9k_hw_resettxqueue(struct ath_hw *ah, u32 q)
  ath_dbg(common, QUEUE, "Reset TX queue: %u\n", q);
 
  if (qi->tqi_cwmin == ATH9K_TXQ_USEDEFAULT) {
-  if (chan && IS_CHAN_B(chan))
-   chanCwMin = INIT_CWMIN_11B;
-  else
-   chanCwMin = INIT_CWMIN;
+  chanCwMin = INIT_CWMIN;
 
   for (cwMin = 1; cwMin < chanCwMin; cwMin = (cwMin << 1) | 1);
  } else
@@ -485,8 +481,7 @@ bool ath9k_hw_resettxqueue(struct ath_hw *ah, u32 q)
        | AR_Q_MISC_CBR_INCR_DIS0);
   value = (qi->tqi_readyTime -
     (ah->config.sw_beacon_response_time -
-     ah->config.dma_beacon_response_time) -
-    ah->config.additional_swba_backoff) * 1024;
+     ah->config.dma_beacon_response_time)) * 1024;
   REG_WRITE(ah, AR_QRDYTIMECFG(q),
      value | AR_Q_RDYTIMECFG_EN);
   REG_SET_BIT(ah, AR_DMISC(q),
@@ -547,31 +542,32 @@ int ath9k_hw_rxprocdesc(struct ath_hw *ah, struct ath_desc *ds,
 
  rs->rs_status = 0;
  rs->rs_flags = 0;
+ rs->flag = 0;
 
  rs->rs_datalen = ads.ds_rxstatus1 & AR_DataLen;
  rs->rs_tstamp = ads.AR_RcvTimestamp;
 
  if (ads.ds_rxstatus8 & AR_PostDelimCRCErr) {
   rs->rs_rssi = ATH9K_RSSI_BAD;
-  rs->rs_rssi_ctl0 = ATH9K_RSSI_BAD;
-  rs->rs_rssi_ctl1 = ATH9K_RSSI_BAD;
-  rs->rs_rssi_ctl2 = ATH9K_RSSI_BAD;
-  rs->rs_rssi_ext0 = ATH9K_RSSI_BAD;
-  rs->rs_rssi_ext1 = ATH9K_RSSI_BAD;
-  rs->rs_rssi_ext2 = ATH9K_RSSI_BAD;
+  rs->rs_rssi_ctl[0] = ATH9K_RSSI_BAD;
+  rs->rs_rssi_ctl[1] = ATH9K_RSSI_BAD;
+  rs->rs_rssi_ctl[2] = ATH9K_RSSI_BAD;
+  rs->rs_rssi_ext[0] = ATH9K_RSSI_BAD;
+  rs->rs_rssi_ext[1] = ATH9K_RSSI_BAD;
+  rs->rs_rssi_ext[2] = ATH9K_RSSI_BAD;
  } else {
   rs->rs_rssi = MS(ads.ds_rxstatus4, AR_RxRSSICombined);
-  rs->rs_rssi_ctl0 = MS(ads.ds_rxstatus0,
+  rs->rs_rssi_ctl[0] = MS(ads.ds_rxstatus0,
       AR_RxRSSIAnt00);
-  rs->rs_rssi_ctl1 = MS(ads.ds_rxstatus0,
+  rs->rs_rssi_ctl[1] = MS(ads.ds_rxstatus0,
       AR_RxRSSIAnt01);
-  rs->rs_rssi_ctl2 = MS(ads.ds_rxstatus0,
+  rs->rs_rssi_ctl[2] = MS(ads.ds_rxstatus0,
       AR_RxRSSIAnt02);
-  rs->rs_rssi_ext0 = MS(ads.ds_rxstatus4,
+  rs->rs_rssi_ext[0] = MS(ads.ds_rxstatus4,
       AR_RxRSSIAnt10);
-  rs->rs_rssi_ext1 = MS(ads.ds_rxstatus4,
+  rs->rs_rssi_ext[1] = MS(ads.ds_rxstatus4,
       AR_RxRSSIAnt11);
-  rs->rs_rssi_ext2 = MS(ads.ds_rxstatus4,
+  rs->rs_rssi_ext[2] = MS(ads.ds_rxstatus4,
       AR_RxRSSIAnt12);
  }
  if (ads.ds_rxstatus8 & AR_RxKeyIdxValid)
@@ -582,14 +578,21 @@ int ath9k_hw_rxprocdesc(struct ath_hw *ah, struct ath_desc *ds,
  rs->rs_rate = MS(ads.ds_rxstatus0, AR_RxRate);
  rs->rs_more = (ads.ds_rxstatus1 & AR_RxMore) ? 1 : 0;
 
+ rs->rs_firstaggr = (ads.ds_rxstatus8 & AR_RxFirstAggr) ? 1 : 0;
  rs->rs_isaggr = (ads.ds_rxstatus8 & AR_RxAggr) ? 1 : 0;
- rs->rs_moreaggr =
-  (ads.ds_rxstatus8 & AR_RxMoreAggr) ? 1 : 0;
+ rs->rs_moreaggr = (ads.ds_rxstatus8 & AR_RxMoreAggr) ? 1 : 0;
  rs->rs_antenna = MS(ads.ds_rxstatus3, AR_RxAntenna);
- rs->rs_flags =
-  (ads.ds_rxstatus3 & AR_GI) ? ATH9K_RX_GI : 0;
- rs->rs_flags |=
-  (ads.ds_rxstatus3 & AR_2040) ? ATH9K_RX_2040 : 0;
+
+ /* directly mapped flags for ieee80211_rx_status */
+ rs->flag |=
+  (ads.ds_rxstatus3 & AR_GI) ? RX_FLAG_SHORT_GI : 0;
+ rs->flag |=
+  (ads.ds_rxstatus3 & AR_2040) ? RX_FLAG_40MHZ : 0;
+ if (AR_SREV_9280_20_OR_LATER(ah))
+  rs->flag |=
+   (ads.ds_rxstatus3 & AR_STBC) ?
+    /* we can only Nss=1 STBC */
+    (1 << RX_FLAG_STBC_SHIFT) : 0;
 
  if (ads.ds_rxstatus8 & AR_PreDelimCRCErr)
   rs->rs_flags |= ATH9K_RX_DELIM_CRC_PRE;
@@ -824,7 +827,7 @@ void ath9k_hw_enable_interrupts(struct ath_hw *ah)
   return;
  }
 
- if (AR_SREV_9340(ah) || AR_SREV_9550(ah))
+ if (AR_SREV_9340(ah) || AR_SREV_9550(ah) || AR_SREV_9531(ah))
   sync_default &= ~AR_INTR_SYNC_HOST1_FATAL;
 
  async_mask = AR_INTR_MAC_IRQ;
@@ -919,11 +922,29 @@ void ath9k_hw_set_interrupts(struct ath_hw *ah)
    mask2 |= AR_IMR_S2_CST;
  }
 
+ if (ah->config.hw_hang_checks & HW_BB_WATCHDOG) {
+  if (ints & ATH9K_INT_BB_WATCHDOG) {
+   mask |= AR_IMR_BCNMISC;
+   mask2 |= AR_IMR_S2_BB_WATCHDOG;
+  }
+ }
+
  ath_dbg(common, INTERRUPT, "new IMR 0x%x\n", mask);
  REG_WRITE(ah, AR_IMR, mask);
- ah->imrs2_reg &= ~(AR_IMR_S2_TIM | AR_IMR_S2_DTIM | AR_IMR_S2_DTIMSYNC |
-      AR_IMR_S2_CABEND | AR_IMR_S2_CABTO |
-      AR_IMR_S2_TSFOOR | AR_IMR_S2_GTT | AR_IMR_S2_CST);
+ ah->imrs2_reg &= ~(AR_IMR_S2_TIM |
+      AR_IMR_S2_DTIM |
+      AR_IMR_S2_DTIMSYNC |
+      AR_IMR_S2_CABEND |
+      AR_IMR_S2_CABTO |
+      AR_IMR_S2_TSFOOR |
+      AR_IMR_S2_GTT |
+      AR_IMR_S2_CST);
+
+ if (ah->config.hw_hang_checks & HW_BB_WATCHDOG) {
+  if (ints & ATH9K_INT_BB_WATCHDOG)
+   ah->imrs2_reg &= ~AR_IMR_S2_BB_WATCHDOG;
+ }
+
  ah->imrs2_reg |= mask2;
  REG_WRITE(ah, AR_IMR_S2, ah->imrs2_reg);
 
@@ -937,3 +958,25 @@ void ath9k_hw_set_interrupts(struct ath_hw *ah)
  return;
 }
 EXPORT_SYMBOL(ath9k_hw_set_interrupts);
+
+#define ATH9K_HW_MAX_DCU       10
+#define ATH9K_HW_SLICE_PER_DCU 16
+#define ATH9K_HW_BIT_IN_SLICE  16
+void ath9k_hw_set_tx_filter(struct ath_hw *ah, u8 destidx, bool set)
+{
+ int dcu_idx;
+ u32 filter;
+
+ for (dcu_idx = 0; dcu_idx < 10; dcu_idx++) {
+  filter = SM(set, AR_D_TXBLK_WRITE_COMMAND);
+  filter |= SM(dcu_idx, AR_D_TXBLK_WRITE_DCU);
+  filter |= SM((destidx / ATH9K_HW_SLICE_PER_DCU),
+        AR_D_TXBLK_WRITE_SLICE);
+  filter |= BIT(destidx % ATH9K_HW_BIT_IN_SLICE);
+  ath_dbg(ath9k_hw_common(ah), PS,
+   "DCU%d staid %d set %d txfilter %08x\n",
+   dcu_idx, destidx, set, filter);
+  REG_WRITE(ah, AR_D_TXBLK_BASE, filter);
+ }
+}
+EXPORT_SYMBOL(ath9k_hw_set_tx_filter);
diff --git a/drivers/net/wireless/ath/ath9k/mac.h b/drivers/net/wireless/ath/ath9k/mac.h
index 5865f92..da76867 100644
--- a/drivers/net/wireless/ath/ath9k/mac.h
+++ b/drivers/net/wireless/ath/ath9k/mac.h
@@ -133,13 +133,10 @@ struct ath_rx_status {
  u8 rs_rate;
  u8 rs_antenna;
  u8 rs_more;
- int8_t rs_rssi_ctl0;
- int8_t rs_rssi_ctl1;
- int8_t rs_rssi_ctl2;
- int8_t rs_rssi_ext0;
- int8_t rs_rssi_ext1;
- int8_t rs_rssi_ext2;
+ int8_t rs_rssi_ctl[3];
+ int8_t rs_rssi_ext[3];
  u8 rs_isaggr;
+ u8 rs_firstaggr;
  u8 rs_moreaggr;
  u8 rs_num_delims;
  u8 rs_flags;
@@ -149,6 +146,7 @@ struct ath_rx_status {
  u32 evm2;
  u32 evm3;
  u32 evm4;
+ u32 flag; /* see enum mac80211_rx_flags */
 };
 
 struct ath_htc_rx_status {
@@ -157,12 +155,8 @@ struct ath_htc_rx_status {
  u8 rs_status;
  u8 rs_phyerr;
  int8_t rs_rssi;
- int8_t rs_rssi_ctl0;
- int8_t rs_rssi_ctl1;
- int8_t rs_rssi_ctl2;
- int8_t rs_rssi_ext0;
- int8_t rs_rssi_ext1;
- int8_t rs_rssi_ext2;
+ int8_t rs_rssi_ctl[3];
+ int8_t rs_rssi_ext[3];
  u8 rs_keyix;
  u8 rs_rate;
  u8 rs_antenna;
@@ -172,6 +166,7 @@ struct ath_htc_rx_status {
  u8 rs_num_delims;
  u8 rs_flags;
  u8 rs_dummy;
+ /* FIXME: evm* never used? */
  __be32 evm0;
  __be32 evm1;
  __be32 evm2;
@@ -533,7 +528,8 @@ struct ar5416_desc {
 #define AR_2040             0x00000002
 #define AR_Parallel40       0x00000004
 #define AR_Parallel40_S     2
-#define AR_RxStatusRsvd30   0x000000f8
+#define AR_STBC             0x00000008 /* on ar9280 and later */
+#define AR_RxStatusRsvd30   0x000000f0
 #define AR_RxAntenna     0xffffff00
 #define AR_RxAntenna_S     8
 
@@ -567,6 +563,7 @@ struct ar5416_desc {
 #define AR_RxAggr           0x00020000
 #define AR_PostDelimCRCErr  0x00040000
 #define AR_RxStatusRsvd71   0x3ff80000
+#define AR_RxFirstAggr      0x20000000
 #define AR_DecryptBusyErr   0x40000000
 #define AR_KeyMiss          0x80000000
 
@@ -599,8 +596,6 @@ enum ath9k_tx_queue_flags {
 #define ATH9K_TXQ_USE_LOCKOUT_BKOFF_DIS 0x00000001
 
 #define ATH9K_DECOMP_MASK_SIZE     128
-#define ATH9K_READY_TIME_LO_BOUND  50
-#define ATH9K_READY_TIME_HI_BOUND  96
 
 enum ath9k_pkt_type {
  ATH9K_PKT_TYPE_NORMAL = 0,
@@ -734,6 +729,7 @@ void ath9k_hw_startpcureceive(struct ath_hw *ah, bool is_scanning);
 void ath9k_hw_abortpcurecv(struct ath_hw *ah);
 bool ath9k_hw_stopdmarecv(struct ath_hw *ah, bool *reset);
 int ath9k_hw_beaconq_setup(struct ath_hw *ah);
+void ath9k_hw_set_tx_filter(struct ath_hw *ah, u8 destidx, bool set);
 
 /* Interrupt Handling */
 bool ath9k_hw_intrpend(struct ath_hw *ah);
diff --git a/drivers/net/wireless/ath/ath9k/main.c b/drivers/net/wireless/ath/ath9k/main.c
index 82a1b5b..62ac95d 100644
--- a/drivers/net/wireless/ath/ath9k/main.c
+++ b/drivers/net/wireless/ath/ath9k/main.c
@@ -82,6 +82,22 @@ static bool ath9k_setpower(struct ath_softc *sc, enum ath9k_power_mode mode)
  return ret;
 }
 
+void ath_ps_full_sleep(unsigned long data)
+{
+ struct ath_softc *sc = (struct ath_softc *) data;
+ struct ath_common *common = ath9k_hw_common(sc->sc_ah);
+ bool reset;
+
+ spin_lock(&common->cc_lock);
+ ath_hw_cycle_counters_update(common);
+ spin_unlock(&common->cc_lock);
+
+ ath9k_hw_setrxabort(sc->sc_ah, 1);
+ ath9k_hw_stopdmarecv(sc->sc_ah, &reset);
+
+ ath9k_hw_setpower(sc->sc_ah, ATH9K_PM_FULL_SLEEP);
+}
+
 void ath9k_ps_wakeup(struct ath_softc *sc)
 {
  struct ath_common *common = ath9k_hw_common(sc->sc_ah);
@@ -92,6 +108,7 @@ void ath9k_ps_wakeup(struct ath_softc *sc)
  if (++sc->ps_usecount != 1)
   goto unlock;
 
+ del_timer_sync(&sc->sleep_timer);
  power_mode = sc->sc_ah->power_mode;
  ath9k_hw_setpower(sc->sc_ah, ATH9K_PM_AWAKE);
 
@@ -117,17 +134,17 @@ void ath9k_ps_restore(struct ath_softc *sc)
  struct ath_common *common = ath9k_hw_common(sc->sc_ah);
  enum ath9k_power_mode mode;
  unsigned long flags;
- bool reset;
 
  spin_lock_irqsave(&sc->sc_pm_lock, flags);
  if (--sc->ps_usecount != 0)
   goto unlock;
 
  if (sc->ps_idle) {
-  ath9k_hw_setrxabort(sc->sc_ah, 1);
-  ath9k_hw_stopdmarecv(sc->sc_ah, &reset);
-  mode = ATH9K_PM_FULL_SLEEP;
- } else if (sc->ps_enabled &&
+  mod_timer(&sc->sleep_timer, jiffies + HZ / 10);
+  goto unlock;
+ }
+
+ if (sc->ps_enabled &&
      !(sc->ps_flags & (PS_WAIT_FOR_BEACON |
          PS_WAIT_FOR_CAB |
          PS_WAIT_FOR_PSPOLL_DATA |
@@ -153,7 +170,6 @@ void ath9k_ps_restore(struct ath_softc *sc)
 static void __ath_cancel_work(struct ath_softc *sc)
 {
  cancel_work_sync(&sc->paprd_work);
- cancel_work_sync(&sc->hw_check_work);
  cancel_delayed_work_sync(&sc->tx_complete_work);
  cancel_delayed_work_sync(&sc->hw_pll_work);
 
@@ -163,13 +179,13 @@ static void __ath_cancel_work(struct ath_softc *sc)
 #endif
 }
 
-static void ath_cancel_work(struct ath_softc *sc)
+void ath_cancel_work(struct ath_softc *sc)
 {
  __ath_cancel_work(sc);
  cancel_work_sync(&sc->hw_reset_work);
 }
 
-static void ath_restart_work(struct ath_softc *sc)
+void ath_restart_work(struct ath_softc *sc)
 {
  ieee80211_queue_delayed_work(sc->hw, &sc->tx_complete_work, 0);
 
@@ -177,7 +193,6 @@ static void ath_restart_work(struct ath_softc *sc)
   ieee80211_queue_delayed_work(sc->hw, &sc->hw_pll_work,
          msecs_to_jiffies(ATH_PLL_WORK_INTERVAL));
 
- ath_start_rx_poll(sc, 3);
  ath_start_ani(sc);
 }
 
@@ -187,12 +202,7 @@ static bool ath_prepare_reset(struct ath_softc *sc)
  bool ret = true;
 
  ieee80211_stop_queues(sc->hw);
-
- sc->hw_busy_count = 0;
  ath_stop_ani(sc);
- del_timer_sync(&sc->rx_poll_timer);
-
- ath9k_debug_samp_bb_mac(sc);
  ath9k_hw_disable_interrupts(ah);
 
  if (!ath_drain_all_txq(sc))
@@ -219,16 +229,16 @@ static bool ath_complete_reset(struct ath_softc *sc, bool start)
  ath9k_cmn_update_txpow(ah, sc->curtxpow,
           sc->config.txpowlimit, &sc->curtxpow);
 
- clear_bit(SC_OP_HW_RESET, &sc->sc_flags);
+ clear_bit(ATH_OP_HW_RESET, &common->op_flags);
  ath9k_hw_set_interrupts(ah);
  ath9k_hw_enable_interrupts(ah);
 
  if (!(sc->hw->conf.flags & IEEE80211_CONF_OFFCHANNEL) && start) {
-  if (!test_bit(SC_OP_BEACONS, &sc->sc_flags))
+  if (!test_bit(ATH_OP_BEACONS, &common->op_flags))
    goto work;
 
   if (ah->opmode == NL80211_IFTYPE_STATION &&
-      test_bit(SC_OP_PRIM_STA_VIF, &sc->sc_flags)) {
+      test_bit(ATH_OP_PRIM_STA_VIF, &common->op_flags)) {
    spin_lock_irqsave(&sc->sc_pm_lock, flags);
    sc->ps_flags |= PS_BEACON_SYNC | PS_WAIT_FOR_BEACON;
    spin_unlock_irqrestore(&sc->sc_pm_lock, flags);
@@ -248,11 +258,11 @@ static bool ath_complete_reset(struct ath_softc *sc, bool start)
   }
  }
 
- if ((ah->caps.hw_caps & ATH9K_HW_CAP_ANT_DIV_COMB) && sc->ant_rx != 3)
-  ath_ant_comb_update(sc);
-
+ sc->gtt_cnt = 0;
  ieee80211_wake_queues(sc->hw);
 
+ ath9k_p2p_ps_timer(sc);
+
  return true;
 }
 
@@ -316,17 +326,90 @@ out:
  * by reseting the chip.  To accomplish this we must first cleanup any pending
  * DMA, then restart stuff.
 */
-static int ath_set_channel(struct ath_softc *sc, struct ieee80211_hw *hw,
-      struct ath9k_channel *hchan)
+static int ath_set_channel(struct ath_softc *sc, struct cfg80211_chan_def *chandef)
 {
+ struct ath_hw *ah = sc->sc_ah;
+ struct ath_common *common = ath9k_hw_common(ah);
+ struct ieee80211_hw *hw = sc->hw;
+ struct ath9k_channel *hchan;
+ struct ieee80211_channel *chan = chandef->chan;
+ bool offchannel;
+ int pos = chan->hw_value;
+ int old_pos = -1;
  int r;
 
- if (test_bit(SC_OP_INVALID, &sc->sc_flags))
+ if (test_bit(ATH_OP_INVALID, &common->op_flags))
   return -EIO;
 
+ offchannel = !!(hw->conf.flags & IEEE80211_CONF_OFFCHANNEL);
+
+ if (ah->curchan)
+  old_pos = ah->curchan - &ah->channels[0];
+
+ ath_dbg(common, CONFIG, "Set channel: %d MHz width: %d\n",
+  chan->center_freq, chandef->width);
+
+ /* update survey stats for the old channel before switching */
+ spin_lock_bh(&common->cc_lock);
+ ath_update_survey_stats(sc);
+ spin_unlock_bh(&common->cc_lock);
+
+ ath9k_cmn_get_channel(hw, ah, chandef);
+
+ /*
+  * If the operating channel changes, change the survey in-use flags
+  * along with it.
+  * Reset the survey data for the new channel, unless we're switching
+  * back to the operating channel from an off-channel operation.
+  */
+ if (!offchannel && sc->cur_survey != &sc->survey[pos]) {
+  if (sc->cur_survey)
+   sc->cur_survey->filled &= ~SURVEY_INFO_IN_USE;
+
+  sc->cur_survey = &sc->survey[pos];
+
+  memset(sc->cur_survey, 0, sizeof(struct survey_info));
+  sc->cur_survey->filled |= SURVEY_INFO_IN_USE;
+ } else if (!(sc->survey[pos].filled & SURVEY_INFO_IN_USE)) {
+  memset(&sc->survey[pos], 0, sizeof(struct survey_info));
+ }
+
+ hchan = &sc->sc_ah->channels[pos];
  r = ath_reset_internal(sc, hchan);
+ if (r)
+  return r;
 
- return r;
+ /*
+  * The most recent snapshot of channel->noisefloor for the old
+  * channel is only available after the hardware reset. Copy it to
+  * the survey stats now.
+  */
+ if (old_pos >= 0)
+  ath_update_survey_nf(sc, old_pos);
+
+ /*
+  * Enable radar pulse detection if on a DFS channel. Spectral
+  * scanning and radar detection can not be used concurrently.
+  */
+ if (hw->conf.radar_enabled) {
+  u32 rxfilter;
+
+  /* set HW specific DFS configuration */
+  ath9k_hw_set_radar_params(ah);
+  rxfilter = ath9k_hw_getrxfilter(ah);
+  rxfilter |= ATH9K_RX_FILTER_PHYRADAR |
+    ATH9K_RX_FILTER_PHYERR;
+  ath9k_hw_setrxfilter(ah, rxfilter);
+  ath_dbg(common, DFS, "DFS enabled at freq %d\n",
+   chan->center_freq);
+ } else {
+  /* perform spectral scan if requested. */
+  if (test_bit(ATH_OP_SCANNING, &common->op_flags) &&
+   sc->spectral_mode == SPECTRAL_CHANSCAN)
+   ath9k_spectral_scan_trigger(hw);
+ }
+
+ return 0;
 }
 
 static void ath_node_attach(struct ath_softc *sc, struct ieee80211_sta *sta,
@@ -338,14 +421,9 @@ static void ath_node_attach(struct ath_softc *sc, struct ieee80211_sta *sta,
  an->sc = sc;
  an->sta = sta;
  an->vif = vif;
+ memset(&an->key_idx, 0, sizeof(an->key_idx));
 
  ath_tx_node_init(sc, an);
-
- if (sta->ht_cap.ht_supported) {
-  an->maxampdu = 1 << (IEEE80211_HT_MAX_AMPDU_FACTOR +
-         sta->ht_cap.ampdu_factor);
-  an->mpdudensity = ath9k_parse_mpdudensity(sta->ht_cap.ampdu_density);
- }
 }
 
 static void ath_node_detach(struct ath_softc *sc, struct ieee80211_sta *sta)
@@ -367,16 +445,52 @@ void ath9k_tasklet(unsigned long data)
  ath9k_ps_wakeup(sc);
  spin_lock(&sc->sc_pcu_lock);
 
- if ((status & ATH9K_INT_FATAL) ||
+ if (status & ATH9K_INT_FATAL) {
+  type = RESET_TYPE_FATAL_INT;
+  ath9k_queue_reset(sc, type);
+
+  /*
+   * Increment the ref. counter here so that
+   * interrupts are enabled in the reset routine.
+   */
+  atomic_inc(&ah->intr_ref_cnt);
+  ath_dbg(common, RESET, "FATAL: Skipping interrupts\n");
+  goto out;
+ }
+
+ if ((ah->config.hw_hang_checks & HW_BB_WATCHDOG) &&
      (status & ATH9K_INT_BB_WATCHDOG)) {
+  spin_lock(&common->cc_lock);
+  ath_hw_cycle_counters_update(common);
+  ar9003_hw_bb_watchdog_dbg_info(ah);
+  spin_unlock(&common->cc_lock);
 
-  if (status & ATH9K_INT_FATAL)
-   type = RESET_TYPE_FATAL_INT;
-  else
+  if (ar9003_hw_bb_watchdog_check(ah)) {
    type = RESET_TYPE_BB_WATCHDOG;
+   ath9k_queue_reset(sc, type);
 
-  ath9k_queue_reset(sc, type);
-  goto out;
+   /*
+    * Increment the ref. counter here so that
+    * interrupts are enabled in the reset routine.
+    */
+   atomic_inc(&ah->intr_ref_cnt);
+   ath_dbg(common, RESET,
+    "BB_WATCHDOG: Skipping interrupts\n");
+   goto out;
+  }
+ }
+
+ if (status & ATH9K_INT_GTT) {
+  sc->gtt_cnt++;
+
+  if ((sc->gtt_cnt >= MAX_GTT_CNT) && !ath9k_hw_check_alive(ah)) {
+   type = RESET_TYPE_TX_GTT;
+   ath9k_queue_reset(sc, type);
+   atomic_inc(&ah->intr_ref_cnt);
+   ath_dbg(common, RESET,
+    "GTT: Skipping interrupts\n");
+   goto out;
+  }
  }
 
  spin_lock_irqsave(&sc->sc_pm_lock, flags);
@@ -406,18 +520,31 @@ void ath9k_tasklet(unsigned long data)
  }
 
  if (status & ATH9K_INT_TX) {
-  if (ah->caps.hw_caps & ATH9K_HW_CAP_EDMA)
+  if (ah->caps.hw_caps & ATH9K_HW_CAP_EDMA) {
+   /*
+    * For EDMA chips, TX completion is enabled for the
+    * beacon queue, so if a beacon has been transmitted
+    * successfully after a GTT interrupt, the GTT counter
+    * gets reset to zero here.
+    */
+   sc->gtt_cnt = 0;
+
    ath_tx_edma_tasklet(sc);
-  else
+  } else {
    ath_tx_tasklet(sc);
+  }
+
+  wake_up(&sc->tx_wait);
  }
 
+ if (status & ATH9K_INT_GENTIMER)
+  ath_gen_timer_isr(sc->sc_ah);
+
  ath9k_btcoex_handle_interrupt(sc, status);
 
-out:
  /* re-enable hardware interrupt */
  ath9k_hw_enable_interrupts(ah);
-
+out:
  spin_unlock(&sc->sc_pcu_lock);
  ath9k_ps_restore(sc);
 }
@@ -435,6 +562,7 @@ irqreturn_t ath_isr(int irq, void *dev)
   ATH9K_INT_TX |   \
   ATH9K_INT_BMISS |  \
   ATH9K_INT_CST |   \
+  ATH9K_INT_GTT |   \
   ATH9K_INT_TSFOOR |  \
   ATH9K_INT_GENTIMER |  \
   ATH9K_INT_MCI)
@@ -443,6 +571,7 @@ irqreturn_t ath_isr(int irq, void *dev)
  struct ath_hw *ah = sc->sc_ah;
  struct ath_common *common = ath9k_hw_common(ah);
  enum ath9k_int status;
+ u32 sync_cause = 0;
  bool sched = false;
 
  /*
@@ -450,7 +579,7 @@ irqreturn_t ath_isr(int irq, void *dev)
   * touch anything. Note this can happen early
   * on if the IRQ is shared.
   */
- if (test_bit(SC_OP_INVALID, &sc->sc_flags))
+ if (test_bit(ATH_OP_INVALID, &common->op_flags))
   return IRQ_NONE;
 
  /* shared irq, not for us */
@@ -458,7 +587,7 @@ irqreturn_t ath_isr(int irq, void *dev)
  if (!ath9k_hw_intrpend(ah))
   return IRQ_NONE;
 
- if (test_bit(SC_OP_HW_RESET, &sc->sc_flags)) {
+ if (test_bit(ATH_OP_HW_RESET, &common->op_flags)) {
   ath9k_hw_kill_interrupts(ah);
   return IRQ_HANDLED;
  }
@@ -469,7 +598,8 @@ irqreturn_t ath_isr(int irq, void *dev)
   * bits we haven't explicitly enabled so we mask the
   * value to insure we only process bits we requested.
   */
- ath9k_hw_getisr(ah, &status); /* NB: clears ISR too */
+ ath9k_hw_getisr(ah, &status, &sync_cause); /* NB: clears ISR too */
+ ath9k_debug_sync_cause(sc, sync_cause);
  status &= ah->imask; /* discard unasked-for bits */
 
  /*
@@ -493,25 +623,19 @@ irqreturn_t ath_isr(int irq, void *dev)
      !(ah->caps.hw_caps & ATH9K_HW_CAP_EDMA)))
   goto chip_reset;
 
- if ((ah->caps.hw_caps & ATH9K_HW_CAP_EDMA) &&
-     (status & ATH9K_INT_BB_WATCHDOG)) {
-
-  spin_lock(&common->cc_lock);
-  ath_hw_cycle_counters_update(common);
-  ar9003_hw_bb_watchdog_dbg_info(ah);
-  spin_unlock(&common->cc_lock);
-
+ if ((ah->config.hw_hang_checks & HW_BB_WATCHDOG) &&
+     (status & ATH9K_INT_BB_WATCHDOG))
   goto chip_reset;
- }
-#ifdef CONFIG_PM_SLEEP
+
+#ifdef CONFIG_ATH9K_WOW
  if (status & ATH9K_INT_BMISS) {
   if (atomic_read(&sc->wow_sleep_proc_intr) == 0) {
-   ath_dbg(common, ANY, "during WoW we got a BMISS\n");
    atomic_inc(&sc->wow_got_bmiss_intr);
    atomic_dec(&sc->wow_sleep_proc_intr);
   }
  }
 #endif
+
  if (status & ATH9K_INT_SWBA)
   tasklet_schedule(&sc->bcon_tasklet);
 
@@ -551,7 +675,7 @@ chip_reset:
 #undef SCHED_INTR
 }
 
-static int ath_reset(struct ath_softc *sc)
+int ath_reset(struct ath_softc *sc)
 {
  int r;
 
@@ -564,10 +688,11 @@ static int ath_reset(struct ath_softc *sc)
 
 void ath9k_queue_reset(struct ath_softc *sc, enum ath_reset_type type)
 {
+ struct ath_common *common = ath9k_hw_common(sc->sc_ah);
 #ifdef CONFIG_ATH9K_DEBUGFS
  RESET_STAT_INC(sc, type);
 #endif
- set_bit(SC_OP_HW_RESET, &sc->sc_flags);
+ set_bit(ATH_OP_HW_RESET, &common->op_flags);
  ieee80211_queue_work(sc->hw, &sc->hw_reset_work);
 }
 
@@ -598,7 +723,7 @@ static int ath9k_start(struct ieee80211_hw *hw)
  ath9k_ps_wakeup(sc);
  mutex_lock(&sc->mutex);
 
- init_channel = ath9k_cmn_get_curchannel(hw, ah);
+ init_channel = ath9k_cmn_get_channel(hw, ah, &hw->conf.chandef);
 
  /* Reset SERDES registers */
  ath9k_hw_configpcipowersave(ah, false);
@@ -629,19 +754,26 @@ static int ath9k_start(struct ieee80211_hw *hw)
 
  if (ah->caps.hw_caps & ATH9K_HW_CAP_EDMA)
   ah->imask |= ATH9K_INT_RXHP |
-        ATH9K_INT_RXLP |
-        ATH9K_INT_BB_WATCHDOG;
+        ATH9K_INT_RXLP;
  else
   ah->imask |= ATH9K_INT_RX;
 
- ah->imask |= ATH9K_INT_GTT;
+ if (ah->config.hw_hang_checks & HW_BB_WATCHDOG)
+  ah->imask |= ATH9K_INT_BB_WATCHDOG;
+
+ /*
+  * Enable GTT interrupts only for AR9003/AR9004 chips
+  * for now.
+  */
+ if (AR_SREV_9300_20_OR_LATER(ah))
+  ah->imask |= ATH9K_INT_GTT;
 
  if (ah->caps.hw_caps & ATH9K_HW_CAP_HT)
   ah->imask |= ATH9K_INT_CST;
 
  ath_mci_enable(sc);
 
- clear_bit(SC_OP_INVALID, &sc->sc_flags);
+ clear_bit(ATH_OP_INVALID, &common->op_flags);
  sc->sc_ah->is_monitoring = false;
 
  if (!ath_complete_reset(sc, false))
@@ -659,6 +791,8 @@ static int ath9k_start(struct ieee80211_hw *hw)
   */
  ath9k_cmn_init_crypto(sc->sc_ah);
 
+ ath9k_hw_reset_tsf(ah);
+
  spin_unlock_bh(&sc->sc_pcu_lock);
 
  mutex_unlock(&sc->mutex);
@@ -755,9 +889,8 @@ static void ath9k_stop(struct ieee80211_hw *hw)
  mutex_lock(&sc->mutex);
 
  ath_cancel_work(sc);
- del_timer_sync(&sc->rx_poll_timer);
 
- if (test_bit(SC_OP_INVALID, &sc->sc_flags)) {
+ if (test_bit(ATH_OP_INVALID, &common->op_flags)) {
   ath_dbg(common, ANY, "Device not present\n");
   mutex_unlock(&sc->mutex);
   return;
@@ -801,7 +934,7 @@ static void ath9k_stop(struct ieee80211_hw *hw)
  }
 
  if (!ah->curchan)
-  ah->curchan = ath9k_cmn_get_curchannel(hw, ah);
+  ah->curchan = ath9k_cmn_get_channel(hw, ah, &hw->conf.chandef);
 
  ath9k_hw_reset(ah, ah->curchan, ah->caldata, false);
  ath9k_hw_phy_disable(ah);
@@ -812,7 +945,7 @@ static void ath9k_stop(struct ieee80211_hw *hw)
 
  ath9k_ps_restore(sc);
 
- set_bit(SC_OP_INVALID, &sc->sc_flags);
+ set_bit(ATH_OP_INVALID, &common->op_flags);
  sc->ps_idle = prev_idle;
 
  mutex_unlock(&sc->mutex);
@@ -820,7 +953,7 @@ static void ath9k_stop(struct ieee80211_hw *hw)
  ath_dbg(common, CONFIG, "Driver halt\n");
 }
 
-bool ath9k_uses_beacons(int type)
+static bool ath9k_uses_beacons(int type)
 {
  switch (type) {
  case NL80211_IFTYPE_AP:
@@ -953,7 +1086,7 @@ static void ath9k_calculate_summary_state(struct ieee80211_hw *hw,
   */
  if (ah->opmode == NL80211_IFTYPE_STATION &&
      old_opmode == NL80211_IFTYPE_AP &&
-     test_bit(SC_OP_PRIM_STA_VIF, &sc->sc_flags)) {
+     test_bit(ATH_OP_PRIM_STA_VIF, &common->op_flags)) {
   ieee80211_iterate_active_interfaces_atomic(
    sc->hw, IEEE80211_IFACE_ITER_RESUME_ALL,
    ath9k_sta_vif_iter, sc);
@@ -966,9 +1099,19 @@ static int ath9k_add_interface(struct ieee80211_hw *hw,
  struct ath_softc *sc = hw->priv;
  struct ath_hw *ah = sc->sc_ah;
  struct ath_common *common = ath9k_hw_common(ah);
+ struct ath_vif *avp = (void *)vif->drv_priv;
+ struct ath_node *an = &avp->mcast_node;
 
  mutex_lock(&sc->mutex);
 
+ if (config_enabled(CONFIG_ATH9K_TX99)) {
+  if (sc->nvifs >= 1) {
+   mutex_unlock(&sc->mutex);
+   return -EOPNOTSUPP;
+  }
+  sc->tx99_vif = vif;
+ }
+
  ath_dbg(common, CONFIG, "Attach a VIF of type: %d\n", vif->type);
  sc->nvifs++;
 
@@ -979,6 +1122,14 @@ static int ath9k_add_interface(struct ieee80211_hw *hw,
  if (ath9k_uses_beacons(vif->type))
   ath9k_beacon_assign_slot(sc, vif);
 
+ avp->vif = vif;
+
+ an->sc = sc;
+ an->sta = NULL;
+ an->vif = vif;
+ an->no_ps_filter = true;
+ ath_tx_node_init(sc, an);
+
  mutex_unlock(&sc->mutex);
  return 0;
 }
@@ -991,9 +1142,15 @@ static int ath9k_change_interface(struct ieee80211_hw *hw,
  struct ath_softc *sc = hw->priv;
  struct ath_common *common = ath9k_hw_common(sc->sc_ah);
 
- ath_dbg(common, CONFIG, "Change Interface\n");
  mutex_lock(&sc->mutex);
 
+ if (config_enabled(CONFIG_ATH9K_TX99)) {
+  mutex_unlock(&sc->mutex);
+  return -EOPNOTSUPP;
+ }
+
+ ath_dbg(common, CONFIG, "Change Interface\n");
+
  if (ath9k_uses_beacons(vif->type))
   ath9k_beacon_remove_slot(sc, vif);
 
@@ -1011,17 +1168,49 @@ static int ath9k_change_interface(struct ieee80211_hw *hw,
  return 0;
 }
 
+static void
+ath9k_update_p2p_ps_timer(struct ath_softc *sc, struct ath_vif *avp)
+{
+ struct ath_hw *ah = sc->sc_ah;
+ s32 tsf, target_tsf;
+
+ if (!avp || !avp->noa.has_next_tsf)
+  return;
+
+ ath9k_hw_gen_timer_stop(ah, sc->p2p_ps_timer);
+
+ tsf = ath9k_hw_gettsf32(sc->sc_ah);
+
+ target_tsf = avp->noa.next_tsf;
+ if (!avp->noa.absent)
+  target_tsf -= ATH_P2P_PS_STOP_TIME;
+
+ if (target_tsf - tsf < ATH_P2P_PS_STOP_TIME)
+  target_tsf = tsf + ATH_P2P_PS_STOP_TIME;
+
+ ath9k_hw_gen_timer_start(ah, sc->p2p_ps_timer, (u32) target_tsf, 1000000);
+}
+
 static void ath9k_remove_interface(struct ieee80211_hw *hw,
        struct ieee80211_vif *vif)
 {
  struct ath_softc *sc = hw->priv;
  struct ath_common *common = ath9k_hw_common(sc->sc_ah);
+ struct ath_vif *avp = (void *)vif->drv_priv;
 
  ath_dbg(common, CONFIG, "Detach Interface\n");
 
  mutex_lock(&sc->mutex);
 
+ spin_lock_bh(&sc->sc_pcu_lock);
+ if (avp == sc->p2p_ps_vif) {
+  sc->p2p_ps_vif = NULL;
+  ath9k_update_p2p_ps_timer(sc, NULL);
+ }
+ spin_unlock_bh(&sc->sc_pcu_lock);
+
  sc->nvifs--;
+ sc->tx99_vif = NULL;
 
  if (ath9k_uses_beacons(vif->type))
   ath9k_beacon_remove_slot(sc, vif);
@@ -1030,6 +1219,8 @@ static void ath9k_remove_interface(struct ieee80211_hw *hw,
  ath9k_calculate_summary_state(hw, NULL);
  ath9k_ps_restore(sc);
 
+ ath_tx_node_cleanup(sc, &avp->mcast_node);
+
  mutex_unlock(&sc->mutex);
 }
 
@@ -1038,6 +1229,9 @@ static void ath9k_enable_ps(struct ath_softc *sc)
  struct ath_hw *ah = sc->sc_ah;
  struct ath_common *common = ath9k_hw_common(ah);
 
+ if (config_enabled(CONFIG_ATH9K_TX99))
+  return;
+
  sc->ps_enabled = true;
  if (!(ah->caps.hw_caps & ATH9K_HW_CAP_AUTOSLEEP)) {
   if ((ah->imask & ATH9K_INT_TIM_TIMER) == 0) {
@@ -1054,6 +1248,9 @@ static void ath9k_disable_ps(struct ath_softc *sc)
  struct ath_hw *ah = sc->sc_ah;
  struct ath_common *common = ath9k_hw_common(ah);
 
+ if (config_enabled(CONFIG_ATH9K_TX99))
+  return;
+
  sc->ps_enabled = false;
  ath9k_hw_setpower(ah, ATH9K_PM_AWAKE);
  if (!(ah->caps.hw_caps & ATH9K_HW_CAP_AUTOSLEEP)) {
@@ -1077,6 +1274,9 @@ void ath9k_spectral_scan_trigger(struct ieee80211_hw *hw)
  struct ath_common *common = ath9k_hw_common(ah);
  u32 rxfilter;
 
+ if (config_enabled(CONFIG_ATH9K_TX99))
+  return;
+
  if (!ath9k_hw_ops(ah)->spectral_scan_trigger) {
   ath_err(common, "spectrum analyzer not implemented on this hardware\n");
   return;
@@ -1192,83 +1392,12 @@ static int ath9k_config(struct ieee80211_hw *hw, u32 changed)
  }
 
  if ((changed & IEEE80211_CONF_CHANGE_CHANNEL) || reset_channel) {
-  struct ieee80211_channel *curchan = hw->conf.chandef.chan;
-  enum nl80211_channel_type channel_type =
-   cfg80211_get_chandef_type(&conf->chandef);
-  int pos = curchan->hw_value;
-  int old_pos = -1;
-  unsigned long flags;
-
-  if (ah->curchan)
-   old_pos = ah->curchan - &ah->channels[0];
-
-  ath_dbg(common, CONFIG, "Set channel: %d MHz type: %d\n",
-   curchan->center_freq, channel_type);
-
-  /* update survey stats for the old channel before switching */
-  spin_lock_irqsave(&common->cc_lock, flags);
-  ath_update_survey_stats(sc);
-  spin_unlock_irqrestore(&common->cc_lock, flags);
-
-  ath9k_cmn_update_ichannel(&sc->sc_ah->channels[pos],
-       curchan, channel_type);
-
-  /*
-   * If the operating channel changes, change the survey in-use flags
-   * along with it.
-   * Reset the survey data for the new channel, unless we're switching
-   * back to the operating channel from an off-channel operation.
-   */
-  if (!(hw->conf.flags & IEEE80211_CONF_OFFCHANNEL) &&
-      sc->cur_survey != &sc->survey[pos]) {
-
-   if (sc->cur_survey)
-    sc->cur_survey->filled &= ~SURVEY_INFO_IN_USE;
-
-   sc->cur_survey = &sc->survey[pos];
-
-   memset(sc->cur_survey, 0, sizeof(struct survey_info));
-   sc->cur_survey->filled |= SURVEY_INFO_IN_USE;
-  } else if (!(sc->survey[pos].filled & SURVEY_INFO_IN_USE)) {
-   memset(&sc->survey[pos], 0, sizeof(struct survey_info));
-  }
-
-  if (ath_set_channel(sc, hw, &sc->sc_ah->channels[pos]) < 0) {
+  if (ath_set_channel(sc, &hw->conf.chandef) < 0) {
    ath_err(common, "Unable to set channel\n");
    mutex_unlock(&sc->mutex);
    ath9k_ps_restore(sc);
    return -EINVAL;
   }
-
-  /*
-   * The most recent snapshot of channel->noisefloor for the old
-   * channel is only available after the hardware reset. Copy it to
-   * the survey stats now.
-   */
-  if (old_pos >= 0)
-   ath_update_survey_nf(sc, old_pos);
-
-  /*
-   * Enable radar pulse detection if on a DFS channel. Spectral
-   * scanning and radar detection can not be used concurrently.
-   */
-  if (hw->conf.radar_enabled) {
-   u32 rxfilter;
-
-   /* set HW specific DFS configuration */
-   ath9k_hw_set_radar_params(ah);
-   rxfilter = ath9k_hw_getrxfilter(ah);
-   rxfilter |= ATH9K_RX_FILTER_PHYRADAR |
-        ATH9K_RX_FILTER_PHYERR;
-   ath9k_hw_setrxfilter(ah, rxfilter);
-   ath_dbg(common, DFS, "DFS enabled at freq %d\n",
-    curchan->center_freq);
-  } else {
-   /* perform spectral scan if requested. */
-   if (sc->scanning &&
-       sc->spectral_mode == SPECTRAL_CHANSCAN)
-    ath9k_spectral_scan_trigger(hw);
-  }
  }
 
  if (changed & IEEE80211_CONF_CHANGE_POWER) {
@@ -1333,8 +1462,10 @@ static int ath9k_sta_add(struct ieee80211_hw *hw,
   return 0;
 
  key = ath_key_config(common, vif, sta, &ps_key);
- if (key > 0)
+ if (key > 0) {
   an->ps_key = key;
+  an->key_idx[0] = key;
+ }
 
  return 0;
 }
@@ -1352,6 +1483,7 @@ static void ath9k_del_ps_key(struct ath_softc *sc,
 
  ath_key_delete(common, &ps_key);
  an->ps_key = 0;
+ an->key_idx[0] = 0;
 }
 
 static int ath9k_sta_remove(struct ieee80211_hw *hw,
@@ -1366,6 +1498,19 @@ static int ath9k_sta_remove(struct ieee80211_hw *hw,
  return 0;
 }
 
+static void ath9k_sta_set_tx_filter(struct ath_hw *ah,
+        struct ath_node *an,
+        bool set)
+{
+ int i;
+
+ for (i = 0; i < ARRAY_SIZE(an->key_idx); i++) {
+  if (!an->key_idx[i])
+   continue;
+  ath9k_hw_set_tx_filter(ah, an->key_idx[i], set);
+ }
+}
+
 static void ath9k_sta_notify(struct ieee80211_hw *hw,
     struct ieee80211_vif *vif,
     enum sta_notify_cmd cmd,
@@ -1374,15 +1519,14 @@ static void ath9k_sta_notify(struct ieee80211_hw *hw,
  struct ath_softc *sc = hw->priv;
  struct ath_node *an = (struct ath_node *) sta->drv_priv;
 
- if (!sta->ht_cap.ht_supported)
-  return;
-
  switch (cmd) {
  case STA_NOTIFY_SLEEP:
   an->sleeping = true;
   ath_tx_aggr_sleep(sta, sc, an);
+  ath9k_sta_set_tx_filter(sc->sc_ah, an, true);
   break;
  case STA_NOTIFY_AWAKE:
+  ath9k_sta_set_tx_filter(sc->sc_ah, an, false);
   an->sleeping = false;
   ath_tx_aggr_wakeup(sc, an);
   break;
@@ -1438,7 +1582,8 @@ static int ath9k_set_key(struct ieee80211_hw *hw,
 {
  struct ath_softc *sc = hw->priv;
  struct ath_common *common = ath9k_hw_common(sc->sc_ah);
- int ret = 0;
+ struct ath_node *an = NULL;
+ int ret = 0, i;
 
  if (ath9k_modparam_nohwcrypt)
   return -ENOSPC;
@@ -1460,13 +1605,16 @@ static int ath9k_set_key(struct ieee80211_hw *hw,
 
  mutex_lock(&sc->mutex);
  ath9k_ps_wakeup(sc);
- ath_dbg(common, CONFIG, "Set HW Key\n");
+ ath_dbg(common, CONFIG, "Set HW Key %d\n", cmd);
+ if (sta)
+  an = (struct ath_node *)sta->drv_priv;
 
  switch (cmd) {
  case SET_KEY:
   if (sta)
    ath9k_del_ps_key(sc, vif, sta);
 
+  key->hw_key_idx = 0;
   ret = ath_key_config(common, vif, sta, key);
   if (ret >= 0) {
    key->hw_key_idx = ret;
@@ -1479,9 +1627,27 @@ static int ath9k_set_key(struct ieee80211_hw *hw,
     key->flags |= IEEE80211_KEY_FLAG_SW_MGMT_TX;
    ret = 0;
   }
+  if (an && key->hw_key_idx) {
+   for (i = 0; i < ARRAY_SIZE(an->key_idx); i++) {
+    if (an->key_idx[i])
+     continue;
+    an->key_idx[i] = key->hw_key_idx;
+    break;
+   }
+   WARN_ON(i == ARRAY_SIZE(an->key_idx));
+  }
   break;
  case DISABLE_KEY:
   ath_key_delete(common, key);
+  if (an) {
+   for (i = 0; i < ARRAY_SIZE(an->key_idx); i++) {
+    if (an->key_idx[i] != key->hw_key_idx)
+     continue;
+    an->key_idx[i] = 0;
+    break;
+   }
+  }
+  key->hw_key_idx = 0;
   break;
  default:
   ret = -EINVAL;
@@ -1501,7 +1667,7 @@ static void ath9k_set_assoc_state(struct ath_softc *sc,
  struct ieee80211_bss_conf *bss_conf = &vif->bss_conf;
  unsigned long flags;
 
- set_bit(SC_OP_PRIM_STA_VIF, &sc->sc_flags);
+ set_bit(ATH_OP_PRIM_STA_VIF, &common->op_flags);
  avp->primary_sta_vif = true;
 
  /*
@@ -1517,7 +1683,7 @@ static void ath9k_set_assoc_state(struct ath_softc *sc,
  common->curaid = bss_conf->aid;
  ath9k_hw_write_associd(sc->sc_ah);
 
- sc->last_rssi = ATH_RSSI_DUMMY_MARKER;
+ common->last_rssi = ATH_RSSI_DUMMY_MARKER;
  sc->sc_ah->stats.avgbrssi = ATH_RSSI_DUMMY_MARKER;
 
  spin_lock_irqsave(&sc->sc_pm_lock, flags);
@@ -1536,14 +1702,75 @@ static void ath9k_bss_assoc_iter(void *data, u8 *mac, struct ieee80211_vif *vif)
 {
  struct ath_softc *sc = data;
  struct ieee80211_bss_conf *bss_conf = &vif->bss_conf;
+ struct ath_common *common = ath9k_hw_common(sc->sc_ah);
 
- if (test_bit(SC_OP_PRIM_STA_VIF, &sc->sc_flags))
+ if (test_bit(ATH_OP_PRIM_STA_VIF, &common->op_flags))
   return;
 
  if (bss_conf->assoc)
   ath9k_set_assoc_state(sc, vif);
 }
 
+void ath9k_p2p_ps_timer(void *priv)
+{
+ struct ath_softc *sc = priv;
+ struct ath_vif *avp = sc->p2p_ps_vif;
+ struct ieee80211_vif *vif;
+ struct ieee80211_sta *sta;
+ struct ath_node *an;
+ u32 tsf;
+
+ if (!avp)
+  return;
+
+ tsf = ath9k_hw_gettsf32(sc->sc_ah);
+ if (!avp->noa.absent)
+  tsf += ATH_P2P_PS_STOP_TIME;
+
+ if (!avp->noa.has_next_tsf ||
+     avp->noa.next_tsf - tsf > BIT(31))
+  ieee80211_update_p2p_noa(&avp->noa, tsf);
+
+ ath9k_update_p2p_ps_timer(sc, avp);
+
+ rcu_read_lock();
+
+ vif = avp->vif;
+ sta = ieee80211_find_sta(vif, vif->bss_conf.bssid);
+ if (!sta)
+  goto out;
+
+ an = (void *) sta->drv_priv;
+ if (an->sleeping == !!avp->noa.absent)
+  goto out;
+
+ an->sleeping = avp->noa.absent;
+ if (an->sleeping)
+  ath_tx_aggr_sleep(sta, sc, an);
+ else
+  ath_tx_aggr_wakeup(sc, an);
+
+out:
+ rcu_read_unlock();
+}
+
+void ath9k_update_p2p_ps(struct ath_softc *sc, struct ieee80211_vif *vif)
+{
+ struct ath_vif *avp = (void *)vif->drv_priv;
+ u32 tsf;
+
+ if (!sc->p2p_ps_timer)
+  return;
+
+ if (vif->type != NL80211_IFTYPE_STATION || !vif->p2p)
+  return;
+
+ sc->p2p_ps_vif = avp;
+ tsf = ath9k_hw_gettsf32(sc->sc_ah);
+ ieee80211_parse_p2p_noa(&vif->bss_conf.p2p_noa_attr, &avp->noa, tsf);
+ ath9k_update_p2p_ps_timer(sc, avp);
+}
+
 static void ath9k_bss_info_changed(struct ieee80211_hw *hw,
        struct ieee80211_vif *vif,
        struct ieee80211_bss_conf *bss_conf,
@@ -1558,6 +1785,7 @@ static void ath9k_bss_info_changed(struct ieee80211_hw *hw,
  struct ath_hw *ah = sc->sc_ah;
  struct ath_common *common = ath9k_hw_common(ah);
  struct ath_vif *avp = (void *)vif->drv_priv;
+ unsigned long flags;
  int slottime;
 
  ath9k_ps_wakeup(sc);
@@ -1568,18 +1796,18 @@ static void ath9k_bss_info_changed(struct ieee80211_hw *hw,
    bss_conf->bssid, bss_conf->assoc);
 
   if (avp->primary_sta_vif && !bss_conf->assoc) {
-   clear_bit(SC_OP_PRIM_STA_VIF, &sc->sc_flags);
+   clear_bit(ATH_OP_PRIM_STA_VIF, &common->op_flags);
    avp->primary_sta_vif = false;
 
    if (ah->opmode == NL80211_IFTYPE_STATION)
-    clear_bit(SC_OP_BEACONS, &sc->sc_flags);
+    clear_bit(ATH_OP_BEACONS, &common->op_flags);
   }
 
   ieee80211_iterate_active_interfaces_atomic(
    sc->hw, IEEE80211_IFACE_ITER_RESUME_ALL,
    ath9k_bss_assoc_iter, sc);
 
-  if (!test_bit(SC_OP_PRIM_STA_VIF, &sc->sc_flags) &&
+  if (!test_bit(ATH_OP_PRIM_STA_VIF, &common->op_flags) &&
       ah->opmode == NL80211_IFTYPE_STATION) {
    memset(common->curbssid, 0, ETH_ALEN);
    common->curaid = 0;
@@ -1596,13 +1824,8 @@ static void ath9k_bss_info_changed(struct ieee80211_hw *hw,
  }
 
  if ((changed & BSS_CHANGED_BEACON_ENABLED) ||
-     (changed & BSS_CHANGED_BEACON_INT)) {
-  if (ah->opmode == NL80211_IFTYPE_AP &&
-      bss_conf->enable_beacon)
-   ath9k_set_tsfadjust(sc, vif);
-  if (ath9k_allow_beacon_config(sc, vif))
-   ath9k_beacon_config(sc, vif, changed);
- }
+     (changed & BSS_CHANGED_BEACON_INT))
+  ath9k_beacon_config(sc, vif, changed);
 
  if (changed & BSS_CHANGED_ERP_SLOT) {
   if (bss_conf->use_short_slot)
@@ -1623,6 +1846,15 @@ static void ath9k_bss_info_changed(struct ieee80211_hw *hw,
   }
  }
 
+ if (changed & BSS_CHANGED_P2P_PS) {
+  spin_lock_bh(&sc->sc_pcu_lock);
+  spin_lock_irqsave(&sc->sc_pm_lock, flags);
+  if (!(sc->ps_flags & PS_BEACON_SYNC))
+   ath9k_update_p2p_ps(sc, vif);
+  spin_unlock_irqrestore(&sc->sc_pm_lock, flags);
+  spin_unlock_bh(&sc->sc_pcu_lock);
+ }
+
  if (changed & CHECK_ANI)
   ath_check_ani(sc);
 
@@ -1682,7 +1914,7 @@ static int ath9k_ampdu_action(struct ieee80211_hw *hw,
  bool flush = false;
  int ret = 0;
 
- local_bh_disable();
+ mutex_lock(&sc->mutex);
 
  switch (action) {
  case IEEE80211_AMPDU_RX_START:
@@ -1715,7 +1947,7 @@ static int ath9k_ampdu_action(struct ieee80211_hw *hw,
   ath_err(ath9k_hw_common(sc->sc_ah), "Unknown AMPDU action\n");
  }
 
- local_bh_enable();
+ mutex_unlock(&sc->mutex);
 
  return ret;
 }
@@ -1727,10 +1959,12 @@ static int ath9k_get_survey(struct ieee80211_hw *hw, int idx,
  struct ath_common *common = ath9k_hw_common(sc->sc_ah);
  struct ieee80211_supported_band *sband;
  struct ieee80211_channel *chan;
- unsigned long flags;
  int pos;
 
- spin_lock_irqsave(&common->cc_lock, flags);
+ if (config_enabled(CONFIG_ATH9K_TX99))
+  return -EOPNOTSUPP;
+
+ spin_lock_bh(&common->cc_lock);
  if (idx == 0)
   ath_update_survey_stats(sc);
 
@@ -1744,7 +1978,7 @@ static int ath9k_get_survey(struct ieee80211_hw *hw, int idx,
   sband = hw->wiphy->bands[IEEE80211_BAND_5GHZ];
 
  if (!sband || idx >= sband->n_channels) {
-  spin_unlock_irqrestore(&common->cc_lock, flags);
+  spin_unlock_bh(&common->cc_lock);
   return -ENOENT;
  }
 
@@ -1752,7 +1986,7 @@ static int ath9k_get_survey(struct ieee80211_hw *hw, int idx,
  pos = chan->hw_value;
  memcpy(survey, &sc->survey[pos], sizeof(*survey));
  survey->channel = chan;
- spin_unlock_irqrestore(&common->cc_lock, flags);
+ spin_unlock_bh(&common->cc_lock);
 
  return 0;
 }
@@ -1762,6 +1996,9 @@ static void ath9k_set_coverage_class(struct ieee80211_hw *hw, u8 coverage_class)
  struct ath_softc *sc = hw->priv;
  struct ath_hw *ah = sc->sc_ah;
 
+ if (config_enabled(CONFIG_ATH9K_TX99))
+  return;
+
  mutex_lock(&sc->mutex);
  ah->coverage_class = coverage_class;
 
@@ -1772,13 +2009,32 @@ static void ath9k_set_coverage_class(struct ieee80211_hw *hw, u8 coverage_class)
  mutex_unlock(&sc->mutex);
 }
 
-static void ath9k_flush(struct ieee80211_hw *hw, u32 queues, bool drop)
+static bool ath9k_has_tx_pending(struct ath_softc *sc)
+{
+ int i, npend = 0;
+
+ for (i = 0; i < ATH9K_NUM_TX_QUEUES; i++) {
+  if (!ATH_TXQ_SETUP(sc, i))
+   continue;
+
+  if (!sc->tx.txq[i].axq_depth)
+   continue;
+
+  npend = ath9k_has_pending_frames(sc, &sc->tx.txq[i]);
+  if (npend)
+   break;
+ }
+
+ return !!npend;
+}
+
+static void ath9k_flush(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
+   u32 queues, bool drop)
 {
  struct ath_softc *sc = hw->priv;
  struct ath_hw *ah = sc->sc_ah;
  struct ath_common *common = ath9k_hw_common(ah);
- int timeout = 200; /* ms */
- int i, j;
+ int timeout = HZ / 5; /* 200 ms */
  bool drain_txq;
 
  mutex_lock(&sc->mutex);
@@ -1790,31 +2046,15 @@ static void ath9k_flush(struct ieee80211_hw *hw, u32 queues, bool drop)
   return;
  }
 
- if (test_bit(SC_OP_INVALID, &sc->sc_flags)) {
+ if (test_bit(ATH_OP_INVALID, &common->op_flags)) {
   ath_dbg(common, ANY, "Device not present\n");
   mutex_unlock(&sc->mutex);
   return;
  }
 
- for (j = 0; j < timeout; j++) {
-  bool npend = false;
-
-  if (j)
-   usleep_range(1000, 2000);
-
-  for (i = 0; i < ATH9K_NUM_TX_QUEUES; i++) {
-   if (!ATH_TXQ_SETUP(sc, i))
-    continue;
-
-   npend = ath9k_has_pending_frames(sc, &sc->tx.txq[i]);
-
-   if (npend)
-    break;
-  }
-
-  if (!npend)
-      break;
- }
+ if (wait_event_timeout(sc->tx_wait, !ath9k_has_tx_pending(sc),
+          timeout) > 0)
+  drop = false;
 
  if (drop) {
   ath9k_ps_wakeup(sc);
@@ -1962,7 +2202,7 @@ static int ath9k_set_antenna(struct ieee80211_hw *hw, u32 tx_ant, u32 rx_ant)
   ah->rxchainmask = fill_chainmask(ah->caps.rx_chainmask, rx_ant);
 
  ah->txchainmask = fill_chainmask(ah->caps.tx_chainmask, tx_ant);
- ath9k_reload_chainmask_settings(sc);
+ ath9k_cmn_reload_chainmask(ah);
 
  return 0;
 }
@@ -1976,373 +2216,18 @@ static int ath9k_get_antenna(struct ieee80211_hw *hw, u32 *tx_ant, u32 *rx_ant)
  return 0;
 }
 
-#ifdef CONFIG_PM_SLEEP
-
-static void ath9k_wow_map_triggers(struct ath_softc *sc,
-       struct cfg80211_wowlan *wowlan,
-       u32 *wow_triggers)
-{
- if (wowlan->disconnect)
-  *wow_triggers |= AH_WOW_LINK_CHANGE |
-     AH_WOW_BEACON_MISS;
- if (wowlan->magic_pkt)
-  *wow_triggers |= AH_WOW_MAGIC_PATTERN_EN;
-
- if (wowlan->n_patterns)
-  *wow_triggers |= AH_WOW_USER_PATTERN_EN;
-
- sc->wow_enabled = *wow_triggers;
-
-}
-
-static void ath9k_wow_add_disassoc_deauth_pattern(struct ath_softc *sc)
-{
- struct ath_hw *ah = sc->sc_ah;
- struct ath_common *common = ath9k_hw_common(ah);
- struct ath9k_hw_capabilities *pcaps = &ah->caps;
- int pattern_count = 0;
- int i, byte_cnt;
- u8 dis_deauth_pattern[MAX_PATTERN_SIZE];
- u8 dis_deauth_mask[MAX_PATTERN_SIZE];
-
- memset(dis_deauth_pattern, 0, MAX_PATTERN_SIZE);
- memset(dis_deauth_mask, 0, MAX_PATTERN_SIZE);
-
- /*
-  * Create Dissassociate / Deauthenticate packet filter
-  *
-  *     2 bytes        2 byte    6 bytes   6 bytes  6 bytes
-  *  +--------------+----------+---------+--------+--------+----
-  *  + Frame Control+ Duration +   DA    +  SA    +  BSSID +
-  *  +--------------+----------+---------+--------+--------+----
-  *
-  * The above is the management frame format for disassociate/
-  * deauthenticate pattern, from this we need to match the first byte
-  * of 'Frame Control' and DA, SA, and BSSID fields
-  * (skipping 2nd byte of FC and Duration feild.
-  *
-  * Disassociate pattern
-  * --------------------
-  * Frame control = 00 00 1010
-  * DA, SA, BSSID = x:x:x:x:x:x
-  * Pattern will be A0000000 | x:x:x:x:x:x | x:x:x:x:x:x
-  *       | x:x:x:x:x:x  -- 22 bytes
-  *
-  * Deauthenticate pattern
-  * ----------------------
-  * Frame control = 00 00 1100
-  * DA, SA, BSSID = x:x:x:x:x:x
-  * Pattern will be C0000000 | x:x:x:x:x:x | x:x:x:x:x:x
-  *       | x:x:x:x:x:x  -- 22 bytes
-  */
-
- /* Create Disassociate Pattern first */
-
- byte_cnt = 0;
-
- /* Fill out the mask with all FF's */
-
- for (i = 0; i < MAX_PATTERN_MASK_SIZE; i++)
-  dis_deauth_mask[i] = 0xff;
-
- /* copy the first byte of frame control field */
- dis_deauth_pattern[byte_cnt] = 0xa0;
- byte_cnt++;
-
- /* skip 2nd byte of frame control and Duration field */
- byte_cnt += 3;
-
- /*
-  * need not match the destination mac address, it can be a broadcast
-  * mac address or an unicast to this station
-  */
- byte_cnt += 6;
-
- /* copy the source mac address */
- memcpy((dis_deauth_pattern + byte_cnt), common->curbssid, ETH_ALEN);
-
- byte_cnt += 6;
-
- /* copy the bssid, its same as the source mac address */
-
- memcpy((dis_deauth_pattern + byte_cnt), common->curbssid, ETH_ALEN);
-
- /* Create Disassociate pattern mask */
-
- if (pcaps->hw_caps & ATH9K_HW_WOW_PATTERN_MATCH_EXACT) {
-
-  if (pcaps->hw_caps & ATH9K_HW_WOW_PATTERN_MATCH_DWORD) {
-   /*
-    * for AR9280, because of hardware limitation, the
-    * first 4 bytes have to be matched for all patterns.
-    * the mask for disassociation and de-auth pattern
-    * matching need to enable the first 4 bytes.
-    * also the duration field needs to be filled.
-    */
-   dis_deauth_mask[0] = 0xf0;
-
-   /*
-    * fill in duration field
-    FIXME: what is the exact value ?
-    */
-   dis_deauth_pattern[2] = 0xff;
-   dis_deauth_pattern[3] = 0xff;
-  } else {
-   dis_deauth_mask[0] = 0xfe;
-  }
-
-  dis_deauth_mask[1] = 0x03;
-  dis_deauth_mask[2] = 0xc0;
- } else {
-  dis_deauth_mask[0] = 0xef;
-  dis_deauth_mask[1] = 0x3f;
-  dis_deauth_mask[2] = 0x00;
-  dis_deauth_mask[3] = 0xfc;
- }
-
- ath_dbg(common, WOW, "Adding disassoc/deauth patterns for WoW\n");
-
- ath9k_hw_wow_apply_pattern(ah, dis_deauth_pattern, dis_deauth_mask,
-       pattern_count, byte_cnt);
-
- pattern_count++;
- /*
-  * for de-authenticate pattern, only the first byte of the frame
-  * control field gets changed from 0xA0 to 0xC0
-  */
- dis_deauth_pattern[0] = 0xC0;
-
- ath9k_hw_wow_apply_pattern(ah, dis_deauth_pattern, dis_deauth_mask,
-       pattern_count, byte_cnt);
-
-}
-
-static void ath9k_wow_add_pattern(struct ath_softc *sc,
-      struct cfg80211_wowlan *wowlan)
-{
- struct ath_hw *ah = sc->sc_ah;
- struct ath9k_wow_pattern *wow_pattern = NULL;
- struct cfg80211_wowlan_trig_pkt_pattern *patterns = wowlan->patterns;
- int mask_len;
- s8 i = 0;
-
- if (!wowlan->n_patterns)
-  return;
-
- /*
-  * Add the new user configured patterns
-  */
- for (i = 0; i < wowlan->n_patterns; i++) {
-
-  wow_pattern = kzalloc(sizeof(*wow_pattern), GFP_KERNEL);
-
-  if (!wow_pattern)
-   return;
-
-  /*
-   * TODO: convert the generic user space pattern to
-   * appropriate chip specific/802.11 pattern.
-   */
-
-  mask_len = DIV_ROUND_UP(wowlan->patterns[i].pattern_len, 8);
-  memset(wow_pattern->pattern_bytes, 0, MAX_PATTERN_SIZE);
-  memset(wow_pattern->mask_bytes, 0, MAX_PATTERN_SIZE);
-  memcpy(wow_pattern->pattern_bytes, patterns[i].pattern,
-         patterns[i].pattern_len);
-  memcpy(wow_pattern->mask_bytes, patterns[i].mask, mask_len);
-  wow_pattern->pattern_len = patterns[i].pattern_len;
-
-  /*
-   * just need to take care of deauth and disssoc pattern,
-   * make sure we don't overwrite them.
-   */
-
-  ath9k_hw_wow_apply_pattern(ah, wow_pattern->pattern_bytes,
-        wow_pattern->mask_bytes,
-        i + 2,
-        wow_pattern->pattern_len);
-  kfree(wow_pattern);
-
- }
-
-}
-
-static int ath9k_suspend(struct ieee80211_hw *hw,
-    struct cfg80211_wowlan *wowlan)
-{
- struct ath_softc *sc = hw->priv;
- struct ath_hw *ah = sc->sc_ah;
- struct ath_common *common = ath9k_hw_common(ah);
- u32 wow_triggers_enabled = 0;
- int ret = 0;
-
- mutex_lock(&sc->mutex);
-
- ath_cancel_work(sc);
- ath_stop_ani(sc);
- del_timer_sync(&sc->rx_poll_timer);
-
- if (test_bit(SC_OP_INVALID, &sc->sc_flags)) {
-  ath_dbg(common, ANY, "Device not present\n");
-  ret = -EINVAL;
-  goto fail_wow;
- }
-
- if (WARN_ON(!wowlan)) {
-  ath_dbg(common, WOW, "None of the WoW triggers enabled\n");
-  ret = -EINVAL;
-  goto fail_wow;
- }
-
- if (!device_can_wakeup(sc->dev)) {
-  ath_dbg(common, WOW, "device_can_wakeup failed, WoW is not enabled\n");
-  ret = 1;
-  goto fail_wow;
- }
-
- /*
-  * none of the sta vifs are associated
-  * and we are not currently handling multivif
-  * cases, for instance we have to seperately
-  * configure 'keep alive frame' for each
-  * STA.
-  */
-
- if (!test_bit(SC_OP_PRIM_STA_VIF, &sc->sc_flags)) {
-  ath_dbg(common, WOW, "None of the STA vifs are associated\n");
-  ret = 1;
-  goto fail_wow;
- }
-
- if (sc->nvifs > 1) {
-  ath_dbg(common, WOW, "WoW for multivif is not yet supported\n");
-  ret = 1;
-  goto fail_wow;
- }
-
- ath9k_wow_map_triggers(sc, wowlan, &wow_triggers_enabled);
-
- ath_dbg(common, WOW, "WoW triggers enabled 0x%x\n",
-  wow_triggers_enabled);
-
- ath9k_ps_wakeup(sc);
-
- ath9k_stop_btcoex(sc);
-
- /*
-  * Enable wake up on recieving disassoc/deauth
-  * frame by default.
-  */
- ath9k_wow_add_disassoc_deauth_pattern(sc);
-
- if (wow_triggers_enabled & AH_WOW_USER_PATTERN_EN)
-  ath9k_wow_add_pattern(sc, wowlan);
-
- spin_lock_bh(&sc->sc_pcu_lock);
- /*
-  * To avoid false wake, we enable beacon miss interrupt only
-  * when we go to sleep. We save the current interrupt mask
-  * so we can restore it after the system wakes up
-  */
- sc->wow_intr_before_sleep = ah->imask;
- ah->imask &= ~ATH9K_INT_GLOBAL;
- ath9k_hw_disable_interrupts(ah);
- ah->imask = ATH9K_INT_BMISS | ATH9K_INT_GLOBAL;
- ath9k_hw_set_interrupts(ah);
- ath9k_hw_enable_interrupts(ah);
-
- spin_unlock_bh(&sc->sc_pcu_lock);
-
- /*
-  * we can now sync irq and kill any running tasklets, since we already
-  * disabled interrupts and not holding a spin lock
-  */
- synchronize_irq(sc->irq);
- tasklet_kill(&sc->intr_tq);
-
- ath9k_hw_wow_enable(ah, wow_triggers_enabled);
-
- ath9k_ps_restore(sc);
- ath_dbg(common, ANY, "WoW enabled in ath9k\n");
- atomic_inc(&sc->wow_sleep_proc_intr);
-
-fail_wow:
- mutex_unlock(&sc->mutex);
- return ret;
-}
-
-static int ath9k_resume(struct ieee80211_hw *hw)
-{
- struct ath_softc *sc = hw->priv;
- struct ath_hw *ah = sc->sc_ah;
- struct ath_common *common = ath9k_hw_common(ah);
- u32 wow_status;
-
- mutex_lock(&sc->mutex);
-
- ath9k_ps_wakeup(sc);
-
- spin_lock_bh(&sc->sc_pcu_lock);
-
- ath9k_hw_disable_interrupts(ah);
- ah->imask = sc->wow_intr_before_sleep;
- ath9k_hw_set_interrupts(ah);
- ath9k_hw_enable_interrupts(ah);
-
- spin_unlock_bh(&sc->sc_pcu_lock);
-
- wow_status = ath9k_hw_wow_wakeup(ah);
-
- if (atomic_read(&sc->wow_got_bmiss_intr) == 0) {
-  /*
-   * some devices may not pick beacon miss
-   * as the reason they woke up so we add
-   * that here for that shortcoming.
-   */
-  wow_status |= AH_WOW_BEACON_MISS;
-  atomic_dec(&sc->wow_got_bmiss_intr);
-  ath_dbg(common, ANY, "Beacon miss interrupt picked up during WoW sleep\n");
- }
-
- atomic_dec(&sc->wow_sleep_proc_intr);
-
- if (wow_status) {
-  ath_dbg(common, ANY, "Waking up due to WoW triggers %s with WoW status = %x\n",
-   ath9k_hw_wow_event_to_string(wow_status), wow_status);
- }
-
- ath_restart_work(sc);
- ath9k_start_btcoex(sc);
-
- ath9k_ps_restore(sc);
- mutex_unlock(&sc->mutex);
-
- return 0;
-}
-
-static void ath9k_set_wakeup(struct ieee80211_hw *hw, bool enabled)
-{
- struct ath_softc *sc = hw->priv;
-
- mutex_lock(&sc->mutex);
- device_init_wakeup(sc->dev, 1);
- device_set_wakeup_enable(sc->dev, enabled);
- mutex_unlock(&sc->mutex);
-}
-
-#endif
 static void ath9k_sw_scan_start(struct ieee80211_hw *hw)
 {
  struct ath_softc *sc = hw->priv;
-
- sc->scanning = 1;
+ struct ath_common *common = ath9k_hw_common(sc->sc_ah);
+ set_bit(ATH_OP_SCANNING, &common->op_flags);
 }
 
 static void ath9k_sw_scan_complete(struct ieee80211_hw *hw)
 {
  struct ath_softc *sc = hw->priv;
-
- sc->scanning = 0;
+ struct ath_common *common = ath9k_hw_common(sc->sc_ah);
+ clear_bit(ATH_OP_SCANNING, &common->op_flags);
 }
 
 struct ieee80211_ops ath9k_ops = {
@@ -2370,11 +2255,12 @@ struct ieee80211_ops ath9k_ops = {
  .flush      = ath9k_flush,
  .tx_frames_pending  = ath9k_tx_frames_pending,
  .tx_last_beacon     = ath9k_tx_last_beacon,
+ .release_buffered_frames = ath9k_release_buffered_frames,
  .get_stats     = ath9k_get_stats,
  .set_antenna     = ath9k_set_antenna,
  .get_antenna     = ath9k_get_antenna,
 
-#ifdef CONFIG_PM_SLEEP
+#ifdef CONFIG_ATH9K_WOW
  .suspend     = ath9k_suspend,
  .resume      = ath9k_resume,
  .set_wakeup     = ath9k_set_wakeup,
@@ -2386,9 +2272,8 @@ struct ieee80211_ops ath9k_ops = {
  .get_et_strings     = ath9k_get_et_strings,
 #endif
 
-#if defined(CONFIG_MAC80211_DEBUGFS) && defined(CONFIG_ATH9K_DEBUGFS)
+#if defined(CONFIG_MAC80211_DEBUGFS) && defined(CONFIG_ATH9K_STATION_STATISTICS)
  .sta_add_debugfs    = ath9k_sta_add_debugfs,
- .sta_remove_debugfs = ath9k_sta_remove_debugfs,
 #endif
  .sw_scan_start     = ath9k_sw_scan_start,
  .sw_scan_complete   = ath9k_sw_scan_complete,
diff --git a/drivers/net/wireless/ath/ath9k/mci.c b/drivers/net/wireless/ath/ath9k/mci.c
index 815bee2..a0dbcc4 100644
--- a/drivers/net/wireless/ath/ath9k/mci.c
+++ b/drivers/net/wireless/ath/ath9k/mci.c
@@ -200,7 +200,7 @@ skip_tuning:
  if (btcoex->duty_cycle > ATH_MCI_MAX_DUTY_CYCLE)
   btcoex->duty_cycle = ATH_MCI_MAX_DUTY_CYCLE;
 
- btcoex->btcoex_no_stomp =  btcoex->btcoex_period * 1000 *
+ btcoex->btcoex_no_stomp =  btcoex->btcoex_period *
   (100 - btcoex->duty_cycle) / 100;
 
  ath9k_hw_btcoex_enable(sc->sc_ah);
@@ -555,7 +555,7 @@ void ath_mci_intr(struct ath_softc *sc)
   mci_int_rxmsg &= ~AR_MCI_INTERRUPT_RX_MSG_GPM;
 
   while (more_data == MCI_GPM_MORE) {
-   if (test_bit(SC_OP_HW_RESET, &sc->sc_flags))
+   if (test_bit(ATH_OP_HW_RESET, &common->op_flags))
     return;
 
    pgpm = mci->gpm_buf.bf_addr;
@@ -661,9 +661,9 @@ void ath9k_mci_update_wlan_channels(struct ath_softc *sc, bool allow_all)
  chan_start = wlan_chan - 10;
  chan_end = wlan_chan + 10;
 
- if (chan->chanmode == CHANNEL_G_HT40PLUS)
+ if (IS_CHAN_HT40PLUS(chan))
   chan_end += 20;
- else if (chan->chanmode == CHANNEL_G_HT40MINUS)
+ else if (IS_CHAN_HT40MINUS(chan))
   chan_start -= 20;
 
  /* adjust side band */
@@ -707,11 +707,11 @@ void ath9k_mci_set_txpower(struct ath_softc *sc, bool setchannel,
 
  if (setchannel) {
   struct ath9k_hw_cal_data *caldata = &sc->caldata;
-  if ((caldata->chanmode == CHANNEL_G_HT40PLUS) &&
+  if (IS_CHAN_HT40PLUS(ah->curchan) &&
       (ah->curchan->channel > caldata->channel) &&
       (ah->curchan->channel <= caldata->channel + 20))
    return;
-  if ((caldata->chanmode == CHANNEL_G_HT40MINUS) &&
+  if (IS_CHAN_HT40MINUS(ah->curchan) &&
       (ah->curchan->channel < caldata->channel) &&
       (ah->curchan->channel >= caldata->channel - 20))
    return;
diff --git a/drivers/net/wireless/ath/ath9k/pci.c b/drivers/net/wireless/ath/ath9k/pci.c
index 4ac00b4..4dec09e 100644
--- a/drivers/net/wireless/ath/ath9k/pci.c
+++ b/drivers/net/wireless/ath/ath9k/pci.c
@@ -29,10 +29,77 @@ static DEFINE_PCI_DEVICE_TABLE(ath_pci_id_table) = {
  { PCI_VDEVICE(ATHEROS, 0x0027) }, /* PCI   */
  { PCI_VDEVICE(ATHEROS, 0x0029) }, /* PCI   */
  { PCI_VDEVICE(ATHEROS, 0x002A) }, /* PCI-E */
+
+ { PCI_DEVICE_SUB(PCI_VENDOR_ID_ATHEROS,
+    0x002A,
+    PCI_VENDOR_ID_AZWAVE,
+    0x1C71),
+   .driver_data = ATH9K_PCI_D3_L1_WAR },
+ { PCI_DEVICE_SUB(PCI_VENDOR_ID_ATHEROS,
+    0x002A,
+    PCI_VENDOR_ID_FOXCONN,
+    0xE01F),
+   .driver_data = ATH9K_PCI_D3_L1_WAR },
+ { PCI_DEVICE_SUB(PCI_VENDOR_ID_ATHEROS,
+    0x002A,
+    0x11AD, /* LITEON */
+    0x6632),
+   .driver_data = ATH9K_PCI_D3_L1_WAR },
+ { PCI_DEVICE_SUB(PCI_VENDOR_ID_ATHEROS,
+    0x002A,
+    0x11AD, /* LITEON */
+    0x6642),
+   .driver_data = ATH9K_PCI_D3_L1_WAR },
+ { PCI_DEVICE_SUB(PCI_VENDOR_ID_ATHEROS,
+    0x002A,
+    PCI_VENDOR_ID_QMI,
+    0x0306),
+   .driver_data = ATH9K_PCI_D3_L1_WAR },
+ { PCI_DEVICE_SUB(PCI_VENDOR_ID_ATHEROS,
+    0x002A,
+    0x185F, /* WNC */
+    0x309D),
+   .driver_data = ATH9K_PCI_D3_L1_WAR },
+ { PCI_DEVICE_SUB(PCI_VENDOR_ID_ATHEROS,
+    0x002A,
+    0x10CF, /* Fujitsu */
+    0x147C),
+   .driver_data = ATH9K_PCI_D3_L1_WAR },
+ { PCI_DEVICE_SUB(PCI_VENDOR_ID_ATHEROS,
+    0x002A,
+    0x10CF, /* Fujitsu */
+    0x147D),
+   .driver_data = ATH9K_PCI_D3_L1_WAR },
+ { PCI_DEVICE_SUB(PCI_VENDOR_ID_ATHEROS,
+    0x002A,
+    0x10CF, /* Fujitsu */
+    0x1536),
+   .driver_data = ATH9K_PCI_D3_L1_WAR },
+
+ /* AR9285 card for Asus */
+ { PCI_DEVICE_SUB(PCI_VENDOR_ID_ATHEROS,
+    0x002B,
+    PCI_VENDOR_ID_AZWAVE,
+    0x2C37),
+   .driver_data = ATH9K_PCI_BT_ANT_DIV },
+
  { PCI_VDEVICE(ATHEROS, 0x002B) }, /* PCI-E */
  { PCI_VDEVICE(ATHEROS, 0x002C) }, /* PCI-E 802.11n bonded out */
  { PCI_VDEVICE(ATHEROS, 0x002D) }, /* PCI   */
  { PCI_VDEVICE(ATHEROS, 0x002E) }, /* PCI-E */
+
+ /* Killer Wireless (3x3) */
+ { PCI_DEVICE_SUB(PCI_VENDOR_ID_ATHEROS,
+    0x0030,
+    0x1A56,
+    0x2000),
+   .driver_data = ATH9K_PCI_KILLER },
+ { PCI_DEVICE_SUB(PCI_VENDOR_ID_ATHEROS,
+    0x0030,
+    0x1A56,
+    0x2001),
+   .driver_data = ATH9K_PCI_KILLER },
+
  { PCI_VDEVICE(ATHEROS, 0x0030) }, /* PCI-E  AR9300 */
 
  /* PCI-E CUS198 */
@@ -40,33 +107,557 @@ static DEFINE_PCI_DEVICE_TABLE(ath_pci_id_table) = {
     0x0032,
     PCI_VENDOR_ID_AZWAVE,
     0x2086),
-   .driver_data = ATH9K_PCI_CUS198 },
+   .driver_data = ATH9K_PCI_CUS198 | ATH9K_PCI_BT_ANT_DIV },
  { PCI_DEVICE_SUB(PCI_VENDOR_ID_ATHEROS,
     0x0032,
     PCI_VENDOR_ID_AZWAVE,
     0x1237),
-   .driver_data = ATH9K_PCI_CUS198 },
+   .driver_data = ATH9K_PCI_CUS198 | ATH9K_PCI_BT_ANT_DIV },
  { PCI_DEVICE_SUB(PCI_VENDOR_ID_ATHEROS,
     0x0032,
     PCI_VENDOR_ID_AZWAVE,
     0x2126),
-   .driver_data = ATH9K_PCI_CUS198 },
+   .driver_data = ATH9K_PCI_CUS198 | ATH9K_PCI_BT_ANT_DIV },
+ { PCI_DEVICE_SUB(PCI_VENDOR_ID_ATHEROS,
+    0x0032,
+    PCI_VENDOR_ID_AZWAVE,
+    0x126A),
+   .driver_data = ATH9K_PCI_CUS198 | ATH9K_PCI_BT_ANT_DIV },
+
+ /* PCI-E CUS230 */
  { PCI_DEVICE_SUB(PCI_VENDOR_ID_ATHEROS,
     0x0032,
     PCI_VENDOR_ID_AZWAVE,
     0x2152),
-   .driver_data = ATH9K_PCI_CUS198 },
+   .driver_data = ATH9K_PCI_CUS230 | ATH9K_PCI_BT_ANT_DIV },
  { PCI_DEVICE_SUB(PCI_VENDOR_ID_ATHEROS,
     0x0032,
     PCI_VENDOR_ID_FOXCONN,
     0xE075),
-   .driver_data = ATH9K_PCI_CUS198 },
+   .driver_data = ATH9K_PCI_CUS230 | ATH9K_PCI_BT_ANT_DIV },
+
+ /* WB225 */
+ { PCI_DEVICE_SUB(PCI_VENDOR_ID_ATHEROS,
+    0x0032,
+    PCI_VENDOR_ID_ATHEROS,
+    0x3119),
+   .driver_data = ATH9K_PCI_BT_ANT_DIV },
+ { PCI_DEVICE_SUB(PCI_VENDOR_ID_ATHEROS,
+    0x0032,
+    PCI_VENDOR_ID_ATHEROS,
+    0x3122),
+   .driver_data = ATH9K_PCI_BT_ANT_DIV },
+ { PCI_DEVICE_SUB(PCI_VENDOR_ID_ATHEROS,
+    0x0032,
+    0x185F, /* WNC */
+    0x3119),
+   .driver_data = ATH9K_PCI_BT_ANT_DIV },
+ { PCI_DEVICE_SUB(PCI_VENDOR_ID_ATHEROS,
+    0x0032,
+    0x185F, /* WNC */
+    0x3027),
+   .driver_data = ATH9K_PCI_BT_ANT_DIV },
+ { PCI_DEVICE_SUB(PCI_VENDOR_ID_ATHEROS,
+    0x0032,
+    PCI_VENDOR_ID_SAMSUNG,
+    0x4105),
+   .driver_data = ATH9K_PCI_BT_ANT_DIV },
+ { PCI_DEVICE_SUB(PCI_VENDOR_ID_ATHEROS,
+    0x0032,
+    PCI_VENDOR_ID_SAMSUNG,
+    0x4106),
+   .driver_data = ATH9K_PCI_BT_ANT_DIV },
+ { PCI_DEVICE_SUB(PCI_VENDOR_ID_ATHEROS,
+    0x0032,
+    PCI_VENDOR_ID_SAMSUNG,
+    0x410D),
+   .driver_data = ATH9K_PCI_BT_ANT_DIV },
+ { PCI_DEVICE_SUB(PCI_VENDOR_ID_ATHEROS,
+    0x0032,
+    PCI_VENDOR_ID_SAMSUNG,
+    0x410E),
+   .driver_data = ATH9K_PCI_BT_ANT_DIV },
+ { PCI_DEVICE_SUB(PCI_VENDOR_ID_ATHEROS,
+    0x0032,
+    PCI_VENDOR_ID_SAMSUNG,
+    0x410F),
+   .driver_data = ATH9K_PCI_BT_ANT_DIV },
+ { PCI_DEVICE_SUB(PCI_VENDOR_ID_ATHEROS,
+    0x0032,
+    PCI_VENDOR_ID_SAMSUNG,
+    0xC706),
+   .driver_data = ATH9K_PCI_BT_ANT_DIV },
+ { PCI_DEVICE_SUB(PCI_VENDOR_ID_ATHEROS,
+    0x0032,
+    PCI_VENDOR_ID_SAMSUNG,
+    0xC680),
+   .driver_data = ATH9K_PCI_BT_ANT_DIV },
+ { PCI_DEVICE_SUB(PCI_VENDOR_ID_ATHEROS,
+    0x0032,
+    PCI_VENDOR_ID_SAMSUNG,
+    0xC708),
+   .driver_data = ATH9K_PCI_BT_ANT_DIV },
+ { PCI_DEVICE_SUB(PCI_VENDOR_ID_ATHEROS,
+    0x0032,
+    PCI_VENDOR_ID_LENOVO,
+    0x3218),
+   .driver_data = ATH9K_PCI_BT_ANT_DIV },
+ { PCI_DEVICE_SUB(PCI_VENDOR_ID_ATHEROS,
+    0x0032,
+    PCI_VENDOR_ID_LENOVO,
+    0x3219),
+   .driver_data = ATH9K_PCI_BT_ANT_DIV },
+
+ /* AR9485 cards with PLL power-save disabled by default. */
+ { PCI_DEVICE_SUB(PCI_VENDOR_ID_ATHEROS,
+    0x0032,
+    PCI_VENDOR_ID_AZWAVE,
+    0x2C97),
+   .driver_data = ATH9K_PCI_NO_PLL_PWRSAVE },
+ { PCI_DEVICE_SUB(PCI_VENDOR_ID_ATHEROS,
+    0x0032,
+    PCI_VENDOR_ID_AZWAVE,
+    0x2100),
+   .driver_data = ATH9K_PCI_NO_PLL_PWRSAVE },
+ { PCI_DEVICE_SUB(PCI_VENDOR_ID_ATHEROS,
+    0x0032,
+    0x1C56, /* ASKEY */
+    0x4001),
+   .driver_data = ATH9K_PCI_NO_PLL_PWRSAVE },
+ { PCI_DEVICE_SUB(PCI_VENDOR_ID_ATHEROS,
+    0x0032,
+    0x11AD, /* LITEON */
+    0x6627),
+   .driver_data = ATH9K_PCI_NO_PLL_PWRSAVE },
+ { PCI_DEVICE_SUB(PCI_VENDOR_ID_ATHEROS,
+    0x0032,
+    0x11AD, /* LITEON */
+    0x6628),
+   .driver_data = ATH9K_PCI_NO_PLL_PWRSAVE },
+ { PCI_DEVICE_SUB(PCI_VENDOR_ID_ATHEROS,
+    0x0032,
+    PCI_VENDOR_ID_FOXCONN,
+    0xE04E),
+   .driver_data = ATH9K_PCI_NO_PLL_PWRSAVE },
+ { PCI_DEVICE_SUB(PCI_VENDOR_ID_ATHEROS,
+    0x0032,
+    PCI_VENDOR_ID_FOXCONN,
+    0xE04F),
+   .driver_data = ATH9K_PCI_NO_PLL_PWRSAVE },
+ { PCI_DEVICE_SUB(PCI_VENDOR_ID_ATHEROS,
+    0x0032,
+    0x144F, /* ASKEY */
+    0x7197),
+   .driver_data = ATH9K_PCI_NO_PLL_PWRSAVE },
+ { PCI_DEVICE_SUB(PCI_VENDOR_ID_ATHEROS,
+    0x0032,
+    0x1B9A, /* XAVI */
+    0x2000),
+   .driver_data = ATH9K_PCI_NO_PLL_PWRSAVE },
+ { PCI_DEVICE_SUB(PCI_VENDOR_ID_ATHEROS,
+    0x0032,
+    0x1B9A, /* XAVI */
+    0x2001),
+   .driver_data = ATH9K_PCI_NO_PLL_PWRSAVE },
+ { PCI_DEVICE_SUB(PCI_VENDOR_ID_ATHEROS,
+    0x0032,
+    PCI_VENDOR_ID_AZWAVE,
+    0x1186),
+   .driver_data = ATH9K_PCI_NO_PLL_PWRSAVE },
+ { PCI_DEVICE_SUB(PCI_VENDOR_ID_ATHEROS,
+    0x0032,
+    PCI_VENDOR_ID_AZWAVE,
+    0x1F86),
+   .driver_data = ATH9K_PCI_NO_PLL_PWRSAVE },
+ { PCI_DEVICE_SUB(PCI_VENDOR_ID_ATHEROS,
+    0x0032,
+    PCI_VENDOR_ID_AZWAVE,
+    0x1195),
+   .driver_data = ATH9K_PCI_NO_PLL_PWRSAVE },
+ { PCI_DEVICE_SUB(PCI_VENDOR_ID_ATHEROS,
+    0x0032,
+    PCI_VENDOR_ID_AZWAVE,
+    0x1F95),
+   .driver_data = ATH9K_PCI_NO_PLL_PWRSAVE },
+ { PCI_DEVICE_SUB(PCI_VENDOR_ID_ATHEROS,
+    0x0032,
+    0x1B9A, /* XAVI */
+    0x1C00),
+   .driver_data = ATH9K_PCI_NO_PLL_PWRSAVE },
+ { PCI_DEVICE_SUB(PCI_VENDOR_ID_ATHEROS,
+    0x0032,
+    0x1B9A, /* XAVI */
+    0x1C01),
+   .driver_data = ATH9K_PCI_NO_PLL_PWRSAVE },
+ { PCI_DEVICE_SUB(PCI_VENDOR_ID_ATHEROS,
+    0x0032,
+    PCI_VENDOR_ID_ASUSTEK,
+    0x850D),
+   .driver_data = ATH9K_PCI_NO_PLL_PWRSAVE },
 
  { PCI_VDEVICE(ATHEROS, 0x0032) }, /* PCI-E  AR9485 */
  { PCI_VDEVICE(ATHEROS, 0x0033) }, /* PCI-E  AR9580 */
+
+ /* PCI-E CUS217 */
+ { PCI_DEVICE_SUB(PCI_VENDOR_ID_ATHEROS,
+    0x0034,
+    PCI_VENDOR_ID_AZWAVE,
+    0x2116),
+   .driver_data = ATH9K_PCI_CUS217 },
+ { PCI_DEVICE_SUB(PCI_VENDOR_ID_ATHEROS,
+    0x0034,
+    0x11AD, /* LITEON */
+    0x6661),
+   .driver_data = ATH9K_PCI_CUS217 },
+
+ /* AR9462 with WoW support */
+ { PCI_DEVICE_SUB(PCI_VENDOR_ID_ATHEROS,
+    0x0034,
+    PCI_VENDOR_ID_ATHEROS,
+    0x3117),
+   .driver_data = ATH9K_PCI_WOW },
+ { PCI_DEVICE_SUB(PCI_VENDOR_ID_ATHEROS,
+    0x0034,
+    PCI_VENDOR_ID_LENOVO,
+    0x3214),
+   .driver_data = ATH9K_PCI_WOW },
+ { PCI_DEVICE_SUB(PCI_VENDOR_ID_ATHEROS,
+    0x0034,
+    PCI_VENDOR_ID_ATTANSIC,
+    0x0091),
+   .driver_data = ATH9K_PCI_WOW },
+ { PCI_DEVICE_SUB(PCI_VENDOR_ID_ATHEROS,
+    0x0034,
+    PCI_VENDOR_ID_AZWAVE,
+    0x2110),
+   .driver_data = ATH9K_PCI_WOW },
+ { PCI_DEVICE_SUB(PCI_VENDOR_ID_ATHEROS,
+    0x0034,
+    PCI_VENDOR_ID_ASUSTEK,
+    0x850E),
+   .driver_data = ATH9K_PCI_WOW },
+ { PCI_DEVICE_SUB(PCI_VENDOR_ID_ATHEROS,
+    0x0034,
+    0x11AD, /* LITEON */
+    0x6631),
+   .driver_data = ATH9K_PCI_WOW },
+ { PCI_DEVICE_SUB(PCI_VENDOR_ID_ATHEROS,
+    0x0034,
+    0x11AD, /* LITEON */
+    0x6641),
+   .driver_data = ATH9K_PCI_WOW },
+ { PCI_DEVICE_SUB(PCI_VENDOR_ID_ATHEROS,
+    0x0034,
+    PCI_VENDOR_ID_HP,
+    0x1864),
+   .driver_data = ATH9K_PCI_WOW },
+ { PCI_DEVICE_SUB(PCI_VENDOR_ID_ATHEROS,
+    0x0034,
+    0x14CD, /* USI */
+    0x0063),
+   .driver_data = ATH9K_PCI_WOW },
+ { PCI_DEVICE_SUB(PCI_VENDOR_ID_ATHEROS,
+    0x0034,
+    0x14CD, /* USI */
+    0x0064),
+   .driver_data = ATH9K_PCI_WOW },
+ { PCI_DEVICE_SUB(PCI_VENDOR_ID_ATHEROS,
+    0x0034,
+    0x10CF, /* Fujitsu */
+    0x1783),
+   .driver_data = ATH9K_PCI_WOW },
+
+ /* Killer Wireless (2x2) */
+ { PCI_DEVICE_SUB(PCI_VENDOR_ID_ATHEROS,
+    0x0030,
+    0x1A56,
+    0x2003),
+   .driver_data = ATH9K_PCI_KILLER },
+
  { PCI_VDEVICE(ATHEROS, 0x0034) }, /* PCI-E  AR9462 */
  { PCI_VDEVICE(ATHEROS, 0x0037) }, /* PCI-E  AR1111/AR9485 */
- { PCI_VDEVICE(ATHEROS, 0x0036) }, /* PCI-E  AR9565 */
+
+ /* CUS252 */
+ { PCI_DEVICE_SUB(PCI_VENDOR_ID_ATHEROS,
+    0x0036,
+    PCI_VENDOR_ID_ATHEROS,
+    0x3028),
+   .driver_data = ATH9K_PCI_CUS252 |
+    ATH9K_PCI_AR9565_2ANT |
+    ATH9K_PCI_BT_ANT_DIV },
+ { PCI_DEVICE_SUB(PCI_VENDOR_ID_ATHEROS,
+    0x0036,
+    PCI_VENDOR_ID_AZWAVE,
+    0x2176),
+   .driver_data = ATH9K_PCI_CUS252 |
+    ATH9K_PCI_AR9565_2ANT |
+    ATH9K_PCI_BT_ANT_DIV },
+
+ /* WB335 1-ANT */
+ { PCI_DEVICE_SUB(PCI_VENDOR_ID_ATHEROS,
+    0x0036,
+    PCI_VENDOR_ID_FOXCONN,
+    0xE068),
+   .driver_data = ATH9K_PCI_AR9565_1ANT },
+ { PCI_DEVICE_SUB(PCI_VENDOR_ID_ATHEROS,
+    0x0036,
+    0x185F, /* WNC */
+    0xA119),
+   .driver_data = ATH9K_PCI_AR9565_1ANT },
+ { PCI_DEVICE_SUB(PCI_VENDOR_ID_ATHEROS,
+    0x0036,
+    0x11AD, /* LITEON */
+    0x0632),
+   .driver_data = ATH9K_PCI_AR9565_1ANT },
+ { PCI_DEVICE_SUB(PCI_VENDOR_ID_ATHEROS,
+    0x0036,
+    0x11AD, /* LITEON */
+    0x06B2),
+   .driver_data = ATH9K_PCI_AR9565_1ANT },
+ { PCI_DEVICE_SUB(PCI_VENDOR_ID_ATHEROS,
+    0x0036,
+    0x11AD, /* LITEON */
+    0x0842),
+   .driver_data = ATH9K_PCI_AR9565_1ANT },
+ { PCI_DEVICE_SUB(PCI_VENDOR_ID_ATHEROS,
+    0x0036,
+    0x11AD, /* LITEON */
+    0x6671),
+   .driver_data = ATH9K_PCI_AR9565_1ANT },
+ { PCI_DEVICE_SUB(PCI_VENDOR_ID_ATHEROS,
+    0x0036,
+    0x1B9A, /* XAVI */
+    0x2811),
+   .driver_data = ATH9K_PCI_AR9565_1ANT },
+ { PCI_DEVICE_SUB(PCI_VENDOR_ID_ATHEROS,
+    0x0036,
+    0x1B9A, /* XAVI */
+    0x2812),
+   .driver_data = ATH9K_PCI_AR9565_1ANT },
+ { PCI_DEVICE_SUB(PCI_VENDOR_ID_ATHEROS,
+    0x0036,
+    0x1B9A, /* XAVI */
+    0x28A1),
+   .driver_data = ATH9K_PCI_AR9565_1ANT },
+ { PCI_DEVICE_SUB(PCI_VENDOR_ID_ATHEROS,
+    0x0036,
+    PCI_VENDOR_ID_AZWAVE,
+    0x218A),
+   .driver_data = ATH9K_PCI_AR9565_1ANT },
+
+ /* WB335 1-ANT / Antenna Diversity */
+ { PCI_DEVICE_SUB(PCI_VENDOR_ID_ATHEROS,
+    0x0036,
+    PCI_VENDOR_ID_ATHEROS,
+    0x3025),
+   .driver_data = ATH9K_PCI_AR9565_1ANT | ATH9K_PCI_BT_ANT_DIV },
+ { PCI_DEVICE_SUB(PCI_VENDOR_ID_ATHEROS,
+    0x0036,
+    PCI_VENDOR_ID_ATHEROS,
+    0x3026),
+   .driver_data = ATH9K_PCI_AR9565_1ANT | ATH9K_PCI_BT_ANT_DIV },
+ { PCI_DEVICE_SUB(PCI_VENDOR_ID_ATHEROS,
+    0x0036,
+    PCI_VENDOR_ID_ATHEROS,
+    0x302B),
+   .driver_data = ATH9K_PCI_AR9565_1ANT | ATH9K_PCI_BT_ANT_DIV },
+ { PCI_DEVICE_SUB(PCI_VENDOR_ID_ATHEROS,
+    0x0036,
+    PCI_VENDOR_ID_FOXCONN,
+    0xE069),
+   .driver_data = ATH9K_PCI_AR9565_1ANT | ATH9K_PCI_BT_ANT_DIV },
+ { PCI_DEVICE_SUB(PCI_VENDOR_ID_ATHEROS,
+    0x0036,
+    0x185F, /* WNC */
+    0x3028),
+   .driver_data = ATH9K_PCI_AR9565_1ANT | ATH9K_PCI_BT_ANT_DIV },
+ { PCI_DEVICE_SUB(PCI_VENDOR_ID_ATHEROS,
+    0x0036,
+    0x11AD, /* LITEON */
+    0x0622),
+   .driver_data = ATH9K_PCI_AR9565_1ANT | ATH9K_PCI_BT_ANT_DIV },
+ { PCI_DEVICE_SUB(PCI_VENDOR_ID_ATHEROS,
+    0x0036,
+    0x11AD, /* LITEON */
+    0x0672),
+   .driver_data = ATH9K_PCI_AR9565_1ANT | ATH9K_PCI_BT_ANT_DIV },
+ { PCI_DEVICE_SUB(PCI_VENDOR_ID_ATHEROS,
+    0x0036,
+    0x11AD, /* LITEON */
+    0x0662),
+   .driver_data = ATH9K_PCI_AR9565_1ANT | ATH9K_PCI_BT_ANT_DIV },
+ { PCI_DEVICE_SUB(PCI_VENDOR_ID_ATHEROS,
+    0x0036,
+    0x11AD, /* LITEON */
+    0x06A2),
+   .driver_data = ATH9K_PCI_AR9565_1ANT | ATH9K_PCI_BT_ANT_DIV },
+ { PCI_DEVICE_SUB(PCI_VENDOR_ID_ATHEROS,
+    0x0036,
+    0x11AD, /* LITEON */
+    0x0682),
+   .driver_data = ATH9K_PCI_AR9565_1ANT | ATH9K_PCI_BT_ANT_DIV },
+ { PCI_DEVICE_SUB(PCI_VENDOR_ID_ATHEROS,
+    0x0036,
+    PCI_VENDOR_ID_AZWAVE,
+    0x213A),
+   .driver_data = ATH9K_PCI_AR9565_1ANT | ATH9K_PCI_BT_ANT_DIV },
+ { PCI_DEVICE_SUB(PCI_VENDOR_ID_ATHEROS,
+    0x0036,
+    PCI_VENDOR_ID_HP,
+    0x18E3),
+   .driver_data = ATH9K_PCI_AR9565_1ANT | ATH9K_PCI_BT_ANT_DIV },
+ { PCI_DEVICE_SUB(PCI_VENDOR_ID_ATHEROS,
+    0x0036,
+    PCI_VENDOR_ID_HP,
+    0x217F),
+   .driver_data = ATH9K_PCI_AR9565_1ANT | ATH9K_PCI_BT_ANT_DIV },
+ { PCI_DEVICE_SUB(PCI_VENDOR_ID_ATHEROS,
+    0x0036,
+    PCI_VENDOR_ID_HP,
+    0x2005),
+   .driver_data = ATH9K_PCI_AR9565_1ANT | ATH9K_PCI_BT_ANT_DIV },
+ { PCI_DEVICE_SUB(PCI_VENDOR_ID_ATHEROS,
+    0x0036,
+    PCI_VENDOR_ID_DELL,
+    0x020C),
+   .driver_data = ATH9K_PCI_AR9565_1ANT | ATH9K_PCI_BT_ANT_DIV },
+
+ /* WB335 2-ANT / Antenna-Diversity */
+ { PCI_DEVICE_SUB(PCI_VENDOR_ID_ATHEROS,
+    0x0036,
+    PCI_VENDOR_ID_SAMSUNG,
+    0x411A),
+   .driver_data = ATH9K_PCI_AR9565_2ANT | ATH9K_PCI_BT_ANT_DIV },
+ { PCI_DEVICE_SUB(PCI_VENDOR_ID_ATHEROS,
+    0x0036,
+    PCI_VENDOR_ID_SAMSUNG,
+    0x411B),
+   .driver_data = ATH9K_PCI_AR9565_2ANT | ATH9K_PCI_BT_ANT_DIV },
+ { PCI_DEVICE_SUB(PCI_VENDOR_ID_ATHEROS,
+    0x0036,
+    PCI_VENDOR_ID_SAMSUNG,
+    0x411C),
+   .driver_data = ATH9K_PCI_AR9565_2ANT | ATH9K_PCI_BT_ANT_DIV },
+ { PCI_DEVICE_SUB(PCI_VENDOR_ID_ATHEROS,
+    0x0036,
+    PCI_VENDOR_ID_SAMSUNG,
+    0x411D),
+   .driver_data = ATH9K_PCI_AR9565_2ANT | ATH9K_PCI_BT_ANT_DIV },
+ { PCI_DEVICE_SUB(PCI_VENDOR_ID_ATHEROS,
+    0x0036,
+    PCI_VENDOR_ID_SAMSUNG,
+    0x411E),
+   .driver_data = ATH9K_PCI_AR9565_2ANT | ATH9K_PCI_BT_ANT_DIV },
+ { PCI_DEVICE_SUB(PCI_VENDOR_ID_ATHEROS,
+    0x0036,
+    PCI_VENDOR_ID_ATHEROS,
+    0x3027),
+   .driver_data = ATH9K_PCI_AR9565_2ANT | ATH9K_PCI_BT_ANT_DIV },
+ { PCI_DEVICE_SUB(PCI_VENDOR_ID_ATHEROS,
+    0x0036,
+    PCI_VENDOR_ID_ATHEROS,
+    0x302C),
+   .driver_data = ATH9K_PCI_AR9565_2ANT | ATH9K_PCI_BT_ANT_DIV },
+ { PCI_DEVICE_SUB(PCI_VENDOR_ID_ATHEROS,
+    0x0036,
+    0x11AD, /* LITEON */
+    0x0642),
+   .driver_data = ATH9K_PCI_AR9565_2ANT | ATH9K_PCI_BT_ANT_DIV },
+ { PCI_DEVICE_SUB(PCI_VENDOR_ID_ATHEROS,
+    0x0036,
+    0x11AD, /* LITEON */
+    0x0652),
+   .driver_data = ATH9K_PCI_AR9565_2ANT | ATH9K_PCI_BT_ANT_DIV },
+ { PCI_DEVICE_SUB(PCI_VENDOR_ID_ATHEROS,
+    0x0036,
+    0x11AD, /* LITEON */
+    0x0612),
+   .driver_data = ATH9K_PCI_AR9565_2ANT | ATH9K_PCI_BT_ANT_DIV },
+ { PCI_DEVICE_SUB(PCI_VENDOR_ID_ATHEROS,
+    0x0036,
+    0x11AD, /* LITEON */
+    0x0832),
+   .driver_data = ATH9K_PCI_AR9565_2ANT | ATH9K_PCI_BT_ANT_DIV },
+ { PCI_DEVICE_SUB(PCI_VENDOR_ID_ATHEROS,
+    0x0036,
+    0x11AD, /* LITEON */
+    0x0692),
+   .driver_data = ATH9K_PCI_AR9565_2ANT | ATH9K_PCI_BT_ANT_DIV },
+ { PCI_DEVICE_SUB(PCI_VENDOR_ID_ATHEROS,
+    0x0036,
+    PCI_VENDOR_ID_AZWAVE,
+    0x2130),
+   .driver_data = ATH9K_PCI_AR9565_2ANT | ATH9K_PCI_BT_ANT_DIV },
+ { PCI_DEVICE_SUB(PCI_VENDOR_ID_ATHEROS,
+    0x0036,
+    PCI_VENDOR_ID_AZWAVE,
+    0x213B),
+   .driver_data = ATH9K_PCI_AR9565_2ANT | ATH9K_PCI_BT_ANT_DIV },
+ { PCI_DEVICE_SUB(PCI_VENDOR_ID_ATHEROS,
+    0x0036,
+    PCI_VENDOR_ID_AZWAVE,
+    0x2182),
+   .driver_data = ATH9K_PCI_AR9565_2ANT | ATH9K_PCI_BT_ANT_DIV },
+ { PCI_DEVICE_SUB(PCI_VENDOR_ID_ATHEROS,
+    0x0036,
+    0x144F, /* ASKEY */
+    0x7202),
+   .driver_data = ATH9K_PCI_AR9565_2ANT | ATH9K_PCI_BT_ANT_DIV },
+ { PCI_DEVICE_SUB(PCI_VENDOR_ID_ATHEROS,
+    0x0036,
+    0x1B9A, /* XAVI */
+    0x2810),
+   .driver_data = ATH9K_PCI_AR9565_2ANT | ATH9K_PCI_BT_ANT_DIV },
+ { PCI_DEVICE_SUB(PCI_VENDOR_ID_ATHEROS,
+    0x0036,
+    0x1B9A, /* XAVI */
+    0x28A2),
+   .driver_data = ATH9K_PCI_AR9565_2ANT | ATH9K_PCI_BT_ANT_DIV },
+ { PCI_DEVICE_SUB(PCI_VENDOR_ID_ATHEROS,
+    0x0036,
+    0x185F, /* WNC */
+    0x3027),
+   .driver_data = ATH9K_PCI_AR9565_2ANT | ATH9K_PCI_BT_ANT_DIV },
+ { PCI_DEVICE_SUB(PCI_VENDOR_ID_ATHEROS,
+    0x0036,
+    0x185F, /* WNC */
+    0xA120),
+   .driver_data = ATH9K_PCI_AR9565_2ANT | ATH9K_PCI_BT_ANT_DIV },
+ { PCI_DEVICE_SUB(PCI_VENDOR_ID_ATHEROS,
+    0x0036,
+    PCI_VENDOR_ID_FOXCONN,
+    0xE07F),
+   .driver_data = ATH9K_PCI_AR9565_2ANT | ATH9K_PCI_BT_ANT_DIV },
+ { PCI_DEVICE_SUB(PCI_VENDOR_ID_ATHEROS,
+    0x0036,
+    PCI_VENDOR_ID_FOXCONN,
+    0xE081),
+   .driver_data = ATH9K_PCI_AR9565_2ANT | ATH9K_PCI_BT_ANT_DIV },
+ { PCI_DEVICE_SUB(PCI_VENDOR_ID_ATHEROS,
+    0x0036,
+    PCI_VENDOR_ID_LENOVO,
+    0x3026),
+   .driver_data = ATH9K_PCI_AR9565_2ANT | ATH9K_PCI_BT_ANT_DIV },
+ { PCI_DEVICE_SUB(PCI_VENDOR_ID_ATHEROS,
+    0x0036,
+    PCI_VENDOR_ID_LENOVO,
+    0x4026),
+   .driver_data = ATH9K_PCI_AR9565_2ANT | ATH9K_PCI_BT_ANT_DIV },
+ { PCI_DEVICE_SUB(PCI_VENDOR_ID_ATHEROS,
+    0x0036,
+    PCI_VENDOR_ID_ASUSTEK,
+    0x85F2),
+   .driver_data = ATH9K_PCI_AR9565_2ANT | ATH9K_PCI_BT_ANT_DIV },
+ { PCI_DEVICE_SUB(PCI_VENDOR_ID_ATHEROS,
+    0x0036,
+    PCI_VENDOR_ID_DELL,
+    0x020E),
+   .driver_data = ATH9K_PCI_AR9565_2ANT | ATH9K_PCI_BT_ANT_DIV },
+
+ /* PCI-E AR9565 (WB335) */
+ { PCI_VDEVICE(ATHEROS, 0x0036),
+   .driver_data = ATH9K_PCI_BT_ANT_DIV },
+
  { 0 }
 };
 
@@ -95,7 +686,7 @@ static bool ath_pci_eeprom_read(struct ath_common *common, u32 off, u16 *data)
  struct ath_softc *sc = (struct ath_softc *) common->priv;
  struct ath9k_platform_data *pdata = sc->dev->platform_data;
 
- if (pdata) {
+ if (pdata && !pdata->use_eeprom) {
   if (off >= (ARRAY_SIZE(pdata->eeprom_data))) {
    ath_err(common,
     "%s: eeprom read failed, offset %08x is out of range\n",
@@ -157,6 +748,22 @@ static void ath_pci_aspm_init(struct ath_common *common)
   return;
  }
 
+ /*
+  * 0x70c - Ack Frequency Register.
+  *
+  * Bits 27:29 - DEFAULT_L1_ENTRANCE_LATENCY.
+  *
+  * 000 : 1 us
+  * 001 : 2 us
+  * 010 : 4 us
+  * 011 : 8 us
+  * 100 : 16 us
+  * 101 : 32 us
+  * 110/111 : 64 us
+  */
+ if (AR_SREV_9462(ah))
+  pci_read_config_dword(pdev, 0x70c, &ah->config.aspm_l1_fix);
+
  pcie_capability_read_word(parent, PCI_EXP_LNKCTL, &aspm);
  if (aspm & (PCI_EXP_LNKCTL_ASPM_L0S | PCI_EXP_LNKCTL_ASPM_L1)) {
   ah->aspm_enabled = true;
@@ -251,9 +858,6 @@ static int ath_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)
  sc->mem = pcim_iomap_table(pdev)[0];
  sc->driver_data = id->driver_data;
 
- /* Will be cleared in ath9k_start() */
- set_bit(SC_OP_INVALID, &sc->sc_flags);
-
  ret = request_irq(pdev->irq, ath_isr, IRQF_SHARED, "ath9k", sc);
  if (ret) {
   dev_err(&pdev->dev, "request_irq failed\n");
@@ -310,6 +914,7 @@ static int ath_pci_suspend(struct device *device)
   */
  ath9k_stop_btcoex(sc);
  ath9k_hw_disable(sc->sc_ah);
+ del_timer_sync(&sc->sleep_timer);
  ath9k_hw_setpower(sc->sc_ah, ATH9K_PM_FULL_SLEEP);
 
  return 0;
diff --git a/drivers/net/wireless/ath/ath9k/phy.h b/drivers/net/wireless/ath/ath9k/phy.h
index 8b38030..4a1b992 100644
--- a/drivers/net/wireless/ath/ath9k/phy.h
+++ b/drivers/net/wireless/ath/ath9k/phy.h
@@ -48,4 +48,11 @@
 #define AR_PHY_PLL_CONTROL 0x16180
 #define AR_PHY_PLL_MODE 0x16184
 
+enum ath9k_ant_div_comb_lna_conf {
+ ATH_ANT_DIV_COMB_LNA1_MINUS_LNA2,
+ ATH_ANT_DIV_COMB_LNA2,
+ ATH_ANT_DIV_COMB_LNA1,
+ ATH_ANT_DIV_COMB_LNA1_PLUS_LNA2,
+};
+
 #endif
diff --git a/drivers/net/wireless/ath/ath9k/recv.c b/drivers/net/wireless/ath/ath9k/recv.c
index f53dbd1..9105a92 100644
--- a/drivers/net/wireless/ath/ath9k/recv.c
+++ b/drivers/net/wireless/ath/ath9k/recv.c
@@ -15,11 +15,10 @@
  */
 
 #include <linux/dma-mapping.h>
-#include <linux/relay.h>
 #include "ath9k.h"
 #include "ar9003_mac.h"
 
-#define SKB_CB_ATHBUF(__skb) (*((struct ath_buf **)__skb->cb))
+#define SKB_CB_ATHBUF(__skb) (*((struct ath_rxbuf **)__skb->cb))
 
 static inline bool ath9k_check_auto_sleep(struct ath_softc *sc)
 {
@@ -35,7 +34,8 @@ static inline bool ath9k_check_auto_sleep(struct ath_softc *sc)
  * buffer (or rx fifo). This can incorrectly acknowledge packets
  * to a sender if last desc is self-linked.
  */
-static void ath_rx_buf_link(struct ath_softc *sc, struct ath_buf *bf)
+static void ath_rx_buf_link(struct ath_softc *sc, struct ath_rxbuf *bf,
+       bool flush)
 {
  struct ath_hw *ah = sc->sc_ah;
  struct ath_common *common = ath9k_hw_common(ah);
@@ -60,18 +60,19 @@ static void ath_rx_buf_link(struct ath_softc *sc, struct ath_buf *bf)
         common->rx_bufsize,
         0);
 
- if (sc->rx.rxlink == NULL)
-  ath9k_hw_putrxbuf(ah, bf->bf_daddr);
- else
+ if (sc->rx.rxlink)
   *sc->rx.rxlink = bf->bf_daddr;
+ else if (!flush)
+  ath9k_hw_putrxbuf(ah, bf->bf_daddr);
 
  sc->rx.rxlink = &ds->ds_link;
 }
 
-static void ath_rx_buf_relink(struct ath_softc *sc, struct ath_buf *bf)
+static void ath_rx_buf_relink(struct ath_softc *sc, struct ath_rxbuf *bf,
+         bool flush)
 {
  if (sc->rx.buf_hold)
-  ath_rx_buf_link(sc, sc->rx.buf_hold);
+  ath_rx_buf_link(sc, sc->rx.buf_hold, flush);
 
  sc->rx.buf_hold = bf;
 }
@@ -112,13 +113,13 @@ static bool ath_rx_edma_buf_link(struct ath_softc *sc,
  struct ath_hw *ah = sc->sc_ah;
  struct ath_rx_edma *rx_edma;
  struct sk_buff *skb;
- struct ath_buf *bf;
+ struct ath_rxbuf *bf;
 
  rx_edma = &sc->rx.rx_edma[qtype];
  if (skb_queue_len(&rx_edma->rx_fifo) >= rx_edma->rx_fifo_hwsize)
   return false;
 
- bf = list_first_entry(&sc->rx.rxbuf, struct ath_buf, list);
+ bf = list_first_entry(&sc->rx.rxbuf, struct ath_rxbuf, list);
  list_del_init(&bf->list);
 
  skb = bf->bf_mpdu;
@@ -138,7 +139,7 @@ static void ath_rx_addbuffer_edma(struct ath_softc *sc,
       enum ath9k_rx_qtype qtype)
 {
  struct ath_common *common = ath9k_hw_common(sc->sc_ah);
- struct ath_buf *bf, *tbf;
+ struct ath_rxbuf *bf, *tbf;
 
  if (list_empty(&sc->rx.rxbuf)) {
   ath_dbg(common, QUEUE, "No free rx buf available\n");
@@ -154,7 +155,7 @@ static void ath_rx_addbuffer_edma(struct ath_softc *sc,
 static void ath_rx_remove_buffer(struct ath_softc *sc,
      enum ath9k_rx_qtype qtype)
 {
- struct ath_buf *bf;
+ struct ath_rxbuf *bf;
  struct ath_rx_edma *rx_edma;
  struct sk_buff *skb;
 
@@ -171,7 +172,7 @@ static void ath_rx_edma_cleanup(struct ath_softc *sc)
 {
  struct ath_hw *ah = sc->sc_ah;
  struct ath_common *common = ath9k_hw_common(ah);
- struct ath_buf *bf;
+ struct ath_rxbuf *bf;
 
  ath_rx_remove_buffer(sc, ATH9K_RX_QUEUE_LP);
  ath_rx_remove_buffer(sc, ATH9K_RX_QUEUE_HP);
@@ -190,7 +191,7 @@ static void ath_rx_edma_cleanup(struct ath_softc *sc)
 
 static void ath_rx_edma_init_queue(struct ath_rx_edma *rx_edma, int size)
 {
- skb_queue_head_init(&rx_edma->rx_fifo);
+ __skb_queue_head_init(&rx_edma->rx_fifo);
  rx_edma->rx_fifo_hwsize = size;
 }
 
@@ -199,7 +200,7 @@ static int ath_rx_edma_init(struct ath_softc *sc, int nbufs)
  struct ath_common *common = ath9k_hw_common(sc->sc_ah);
  struct ath_hw *ah = sc->sc_ah;
  struct sk_buff *skb;
- struct ath_buf *bf;
+ struct ath_rxbuf *bf;
  int error = 0, i;
  u32 size;
 
@@ -211,7 +212,7 @@ static int ath_rx_edma_init(struct ath_softc *sc, int nbufs)
  ath_rx_edma_init_queue(&sc->rx.rx_edma[ATH9K_RX_QUEUE_HP],
           ah->caps.rx_hp_qdepth);
 
- size = sizeof(struct ath_buf) * nbufs;
+ size = sizeof(struct ath_rxbuf) * nbufs;
  bf = devm_kzalloc(sc->dev, size, GFP_KERNEL);
  if (!bf)
   return -ENOMEM;
@@ -271,7 +272,7 @@ int ath_rx_init(struct ath_softc *sc, int nbufs)
 {
  struct ath_common *common = ath9k_hw_common(sc->sc_ah);
  struct sk_buff *skb;
- struct ath_buf *bf;
+ struct ath_rxbuf *bf;
  int error = 0;
 
  spin_lock_init(&sc->sc_pcu_lock);
@@ -332,7 +333,7 @@ void ath_rx_cleanup(struct ath_softc *sc)
  struct ath_hw *ah = sc->sc_ah;
  struct ath_common *common = ath9k_hw_common(ah);
  struct sk_buff *skb;
- struct ath_buf *bf;
+ struct ath_rxbuf *bf;
 
  if (sc->sc_ah->caps.hw_caps & ATH9K_HW_CAP_EDMA) {
   ath_rx_edma_cleanup(sc);
@@ -375,6 +376,9 @@ u32 ath_calcrxfilter(struct ath_softc *sc)
 {
  u32 rfilt;
 
+ if (config_enabled(CONFIG_ATH9K_TX99))
+  return 0;
+
  rfilt = ATH9K_RX_FILTER_UCAST | ATH9K_RX_FILTER_BCAST
   | ATH9K_RX_FILTER_MCAST;
 
@@ -417,7 +421,7 @@ u32 ath_calcrxfilter(struct ath_softc *sc)
   rfilt |= ATH9K_RX_FILTER_MCAST_BCAST_ALL;
  }
 
- if (AR_SREV_9550(sc->sc_ah))
+ if (AR_SREV_9550(sc->sc_ah) || AR_SREV_9531(sc->sc_ah))
   rfilt |= ATH9K_RX_FILTER_4ADDRESS;
 
  return rfilt;
@@ -427,7 +431,7 @@ u32 ath_calcrxfilter(struct ath_softc *sc)
 int ath_startrecv(struct ath_softc *sc)
 {
  struct ath_hw *ah = sc->sc_ah;
- struct ath_buf *bf, *tbf;
+ struct ath_rxbuf *bf, *tbf;
 
  if (ah->caps.hw_caps & ATH9K_HW_CAP_EDMA) {
   ath_edma_start_recv(sc);
@@ -440,14 +444,14 @@ int ath_startrecv(struct ath_softc *sc)
  sc->rx.buf_hold = NULL;
  sc->rx.rxlink = NULL;
  list_for_each_entry_safe(bf, tbf, &sc->rx.rxbuf, list) {
-  ath_rx_buf_link(sc, bf);
+  ath_rx_buf_link(sc, bf, false);
  }
 
  /* We could have deleted elements so the list may be empty now */
  if (list_empty(&sc->rx.rxbuf))
   goto start_recv;
 
- bf = list_first_entry(&sc->rx.rxbuf, struct ath_buf, list);
+ bf = list_first_entry(&sc->rx.rxbuf, struct ath_rxbuf, list);
  ath9k_hw_putrxbuf(ah, bf->bf_daddr);
  ath9k_hw_rxena(ah);
 
@@ -536,7 +540,10 @@ static void ath_rx_ps_beacon(struct ath_softc *sc, struct sk_buff *skb)
   sc->ps_flags &= ~PS_BEACON_SYNC;
   ath_dbg(common, PS,
    "Reconfigure beacon timers based on synchronized timestamp\n");
-  ath9k_set_beacon(sc);
+  if (!(WARN_ON_ONCE(sc->cur_beacon_conf.beacon_interval == 0)))
+   ath9k_set_beacon(sc);
+  if (sc->p2p_ps_vif)
+   ath9k_update_p2p_ps(sc, sc->p2p_ps_vif->vif);
  }
 
  if (ath_beacon_dtim_pending_cab(skb)) {
@@ -603,13 +610,13 @@ static void ath_rx_ps(struct ath_softc *sc, struct sk_buff *skb, bool mybeacon)
 static bool ath_edma_get_buffers(struct ath_softc *sc,
      enum ath9k_rx_qtype qtype,
      struct ath_rx_status *rs,
-     struct ath_buf **dest)
+     struct ath_rxbuf **dest)
 {
  struct ath_rx_edma *rx_edma = &sc->rx.rx_edma[qtype];
  struct ath_hw *ah = sc->sc_ah;
  struct ath_common *common = ath9k_hw_common(ah);
  struct sk_buff *skb;
- struct ath_buf *bf;
+ struct ath_rxbuf *bf;
  int ret;
 
  skb = skb_peek(&rx_edma->rx_fifo);
@@ -653,11 +660,11 @@ static bool ath_edma_get_buffers(struct ath_softc *sc,
  return true;
 }
 
-static struct ath_buf *ath_edma_get_next_rx_buf(struct ath_softc *sc,
+static struct ath_rxbuf *ath_edma_get_next_rx_buf(struct ath_softc *sc,
       struct ath_rx_status *rs,
       enum ath9k_rx_qtype qtype)
 {
- struct ath_buf *bf = NULL;
+ struct ath_rxbuf *bf = NULL;
 
  while (ath_edma_get_buffers(sc, qtype, rs, &bf)) {
   if (!bf)
@@ -668,13 +675,13 @@ static struct ath_buf *ath_edma_get_next_rx_buf(struct ath_softc *sc,
  return NULL;
 }
 
-static struct ath_buf *ath_get_next_rx_buf(struct ath_softc *sc,
+static struct ath_rxbuf *ath_get_next_rx_buf(struct ath_softc *sc,
         struct ath_rx_status *rs)
 {
  struct ath_hw *ah = sc->sc_ah;
  struct ath_common *common = ath9k_hw_common(ah);
  struct ath_desc *ds;
- struct ath_buf *bf;
+ struct ath_rxbuf *bf;
  int ret;
 
  if (list_empty(&sc->rx.rxbuf)) {
@@ -682,7 +689,7 @@ static struct ath_buf *ath_get_next_rx_buf(struct ath_softc *sc,
   return NULL;
  }
 
- bf = list_first_entry(&sc->rx.rxbuf, struct ath_buf, list);
+ bf = list_first_entry(&sc->rx.rxbuf, struct ath_rxbuf, list);
  if (bf == sc->rx.buf_hold)
   return NULL;
 
@@ -702,7 +709,7 @@ static struct ath_buf *ath_get_next_rx_buf(struct ath_softc *sc,
  ret = ath9k_hw_rxprocdesc(ah, ds, rs);
  if (ret == -EINPROGRESS) {
   struct ath_rx_status trs;
-  struct ath_buf *tbf;
+  struct ath_rxbuf *tbf;
   struct ath_desc *tds;
 
   memset(&trs, 0, sizeof(trs));
@@ -711,7 +718,7 @@ static struct ath_buf *ath_get_next_rx_buf(struct ath_softc *sc,
    return NULL;
   }
 
-  tbf = list_entry(bf->list.next, struct ath_buf, list);
+  tbf = list_entry(bf->list.next, struct ath_rxbuf, list);
 
   /*
    * On some hardware the descriptor status words could
@@ -730,11 +737,18 @@ static struct ath_buf *ath_get_next_rx_buf(struct ath_softc *sc,
    return NULL;
 
   /*
-   * mark descriptor as zero-length and set the 'more'
-   * flag to ensure that both buffers get discarded
+   * Re-check previous descriptor, in case it has been filled
+   * in the mean time.
    */
-  rs->rs_datalen = 0;
-  rs->rs_more = true;
+  ret = ath9k_hw_rxprocdesc(ah, ds, rs);
+  if (ret == -EINPROGRESS) {
+   /*
+    * mark descriptor as zero-length and set the 'more'
+    * flag to ensure that both buffers get discarded
+    */
+   rs->rs_datalen = 0;
+   rs->rs_more = true;
+  }
  }
 
  list_del(&bf->list);
@@ -753,396 +767,183 @@ static struct ath_buf *ath_get_next_rx_buf(struct ath_softc *sc,
  return bf;
 }
 
-/* Assumes you've already done the endian to CPU conversion */
-static bool ath9k_rx_accept(struct ath_common *common,
-       struct ieee80211_hdr *hdr,
-       struct ieee80211_rx_status *rxs,
-       struct ath_rx_status *rx_stats,
-       bool *decrypt_error)
+static void ath9k_process_tsf(struct ath_rx_status *rs,
+         struct ieee80211_rx_status *rxs,
+         u64 tsf)
 {
- struct ath_softc *sc = (struct ath_softc *) common->priv;
- bool is_mc, is_valid_tkip, strip_mic, mic_error;
- struct ath_hw *ah = common->ah;
- __le16 fc;
- u8 rx_status_len = ah->caps.rx_status_len;
-
- fc = hdr->frame_control;
-
- is_mc = !!is_multicast_ether_addr(hdr->addr1);
- is_valid_tkip = rx_stats->rs_keyix != ATH9K_RXKEYIX_INVALID &&
-  test_bit(rx_stats->rs_keyix, common->tkip_keymap);
- strip_mic = is_valid_tkip && ieee80211_is_data(fc) &&
-  ieee80211_has_protected(fc) &&
-  !(rx_stats->rs_status &
-  (ATH9K_RXERR_DECRYPT | ATH9K_RXERR_CRC | ATH9K_RXERR_MIC |
-   ATH9K_RXERR_KEYMISS));
+ u32 tsf_lower = tsf & 0xffffffff;
 
- /*
-  * Key miss events are only relevant for pairwise keys where the
-  * descriptor does contain a valid key index. This has been observed
-  * mostly with CCMP encryption.
-  */
- if (rx_stats->rs_keyix == ATH9K_RXKEYIX_INVALID ||
-     !test_bit(rx_stats->rs_keyix, common->ccmp_keymap))
-  rx_stats->rs_status &= ~ATH9K_RXERR_KEYMISS;
+ rxs->mactime = (tsf & ~0xffffffffULL) | rs->rs_tstamp;
+ if (rs->rs_tstamp > tsf_lower &&
+     unlikely(rs->rs_tstamp - tsf_lower > 0x10000000))
+  rxs->mactime -= 0x100000000ULL;
 
- if (!rx_stats->rs_datalen) {
-  RX_STAT_INC(rx_len_err);
-  return false;
- }
-
-        /*
-         * rs_status follows rs_datalen so if rs_datalen is too large
-         * we can take a hint that hardware corrupted it, so ignore
-         * those frames.
-         */
- if (rx_stats->rs_datalen > (common->rx_bufsize - rx_status_len)) {
-  RX_STAT_INC(rx_len_err);
-  return false;
- }
-
- /* Only use error bits from the last fragment */
- if (rx_stats->rs_more)
-  return true;
+ if (rs->rs_tstamp < tsf_lower &&
+     unlikely(tsf_lower - rs->rs_tstamp > 0x10000000))
+  rxs->mactime += 0x100000000ULL;
+}
 
- mic_error = is_valid_tkip && !ieee80211_is_ctl(fc) &&
-  !ieee80211_has_morefrags(fc) &&
-  !(le16_to_cpu(hdr->seq_ctrl) & IEEE80211_SCTL_FRAG) &&
-  (rx_stats->rs_status & ATH9K_RXERR_MIC);
+/*
+ * For Decrypt or Demic errors, we only mark packet status here and always push
+ * up the frame up to let mac80211 handle the actual error case, be it no
+ * decryption key or real decryption error. This let us keep statistics there.
+ */
+static int ath9k_rx_skb_preprocess(struct ath_softc *sc,
+       struct sk_buff *skb,
+       struct ath_rx_status *rx_stats,
+       struct ieee80211_rx_status *rx_status,
+       bool *decrypt_error, u64 tsf)
+{
+ struct ieee80211_hw *hw = sc->hw;
+ struct ath_hw *ah = sc->sc_ah;
+ struct ath_common *common = ath9k_hw_common(ah);
+ struct ieee80211_hdr *hdr;
+ bool discard_current = sc->rx.discard_next;
 
  /*
-  * The rx_stats->rs_status will not be set until the end of the
-  * chained descriptors so it can be ignored if rs_more is set. The
-  * rs_more will be false at the last element of the chained
-  * descriptors.
+  * Discard corrupt descriptors which are marked in
+  * ath_get_next_rx_buf().
   */
- if (rx_stats->rs_status != 0) {
-  u8 status_mask;
-
-  if (rx_stats->rs_status & ATH9K_RXERR_CRC) {
-   rxs->flag |= RX_FLAG_FAILED_FCS_CRC;
-   mic_error = false;
-  }
-  if (rx_stats->rs_status & ATH9K_RXERR_PHY)
-   return false;
-
-  if ((rx_stats->rs_status & ATH9K_RXERR_DECRYPT) ||
-      (!is_mc && (rx_stats->rs_status & ATH9K_RXERR_KEYMISS))) {
-   *decrypt_error = true;
-   mic_error = false;
-  }
-
-  /*
-   * Reject error frames with the exception of
-   * decryption and MIC failures. For monitor mode,
-   * we also ignore the CRC error.
-   */
-  status_mask = ATH9K_RXERR_DECRYPT | ATH9K_RXERR_MIC |
-         ATH9K_RXERR_KEYMISS;
+ if (discard_current)
+  goto corrupt;
 
-  if (ah->is_monitoring && (sc->rx.rxfilter & FIF_FCSFAIL))
-   status_mask |= ATH9K_RXERR_CRC;
+ sc->rx.discard_next = false;
 
-  if (rx_stats->rs_status & ~status_mask)
-   return false;
+ /*
+  * Discard zero-length packets.
+  */
+ if (!rx_stats->rs_datalen) {
+  RX_STAT_INC(rx_len_err);
+  goto corrupt;
  }
 
  /*
-  * For unicast frames the MIC error bit can have false positives,
-  * so all MIC error reports need to be validated in software.
-  * False negatives are not common, so skip software verification
-  * if the hardware considers the MIC valid.
+  * rs_status follows rs_datalen so if rs_datalen is too large
+  * we can take a hint that hardware corrupted it, so ignore
+  * those frames.
   */
- if (strip_mic)
-  rxs->flag |= RX_FLAG_MMIC_STRIPPED;
- else if (is_mc && mic_error)
-  rxs->flag |= RX_FLAG_MMIC_ERROR;
-
- return true;
-}
-
-static int ath9k_process_rate(struct ath_common *common,
-         struct ieee80211_hw *hw,
-         struct ath_rx_status *rx_stats,
-         struct ieee80211_rx_status *rxs)
-{
- struct ieee80211_supported_band *sband;
- enum ieee80211_band band;
- unsigned int i = 0;
- struct ath_softc __maybe_unused *sc = common->priv;
-
- band = hw->conf.chandef.chan->band;
- sband = hw->wiphy->bands[band];
-
- if (rx_stats->rs_rate & 0x80) {
-  /* HT rate */
-  rxs->flag |= RX_FLAG_HT;
-  if (rx_stats->rs_flags & ATH9K_RX_2040)
-   rxs->flag |= RX_FLAG_40MHZ;
-  if (rx_stats->rs_flags & ATH9K_RX_GI)
-   rxs->flag |= RX_FLAG_SHORT_GI;
-  rxs->rate_idx = rx_stats->rs_rate & 0x7f;
-  return 0;
+ if (rx_stats->rs_datalen > (common->rx_bufsize - ah->caps.rx_status_len)) {
+  RX_STAT_INC(rx_len_err);
+  goto corrupt;
  }
 
- for (i = 0; i < sband->n_bitrates; i++) {
-  if (sband->bitrates[i].hw_value == rx_stats->rs_rate) {
-   rxs->rate_idx = i;
-   return 0;
-  }
-  if (sband->bitrates[i].hw_value_short == rx_stats->rs_rate) {
-   rxs->flag |= RX_FLAG_SHORTPRE;
-   rxs->rate_idx = i;
-   return 0;
-  }
- }
+ /* Only use status info from the last fragment */
+ if (rx_stats->rs_more)
+  return 0;
 
  /*
-  * No valid hardware bitrate found -- we should not get here
-  * because hardware has already validated this frame as OK.
+  * Return immediately if the RX descriptor has been marked
+  * as corrupt based on the various error bits.
+  *
+  * This is different from the other corrupt descriptor
+  * condition handled above.
   */
- ath_dbg(common, ANY,
-  "unsupported hw bitrate detected 0x%02x using 1 Mbit\n",
-  rx_stats->rs_rate);
- RX_STAT_INC(rx_rate_err);
- return -EINVAL;
-}
-
-static void ath9k_process_rssi(struct ath_common *common,
-          struct ieee80211_hw *hw,
-          struct ieee80211_hdr *hdr,
-          struct ath_rx_status *rx_stats)
-{
- struct ath_softc *sc = hw->priv;
- struct ath_hw *ah = common->ah;
- int last_rssi;
- int rssi = rx_stats->rs_rssi;
-
- if (!rx_stats->is_mybeacon ||
-     ((ah->opmode != NL80211_IFTYPE_STATION) &&
-      (ah->opmode != NL80211_IFTYPE_ADHOC)))
-  return;
-
- if (rx_stats->rs_rssi != ATH9K_RSSI_BAD && !rx_stats->rs_moreaggr)
-  ATH_RSSI_LPF(sc->last_rssi, rx_stats->rs_rssi);
+ if (rx_stats->rs_status & ATH9K_RXERR_CORRUPT_DESC)
+  goto corrupt;
 
- last_rssi = sc->last_rssi;
- if (likely(last_rssi != ATH_RSSI_DUMMY_MARKER))
-  rssi = ATH_EP_RND(last_rssi, ATH_RSSI_EP_MULTIPLIER);
- if (rssi < 0)
-  rssi = 0;
+ hdr = (struct ieee80211_hdr *) (skb->data + ah->caps.rx_status_len);
 
- /* Update Beacon RSSI, this is used by ANI. */
- ah->stats.avgbrssi = rssi;
-}
+ ath9k_process_tsf(rx_stats, rx_status, tsf);
+ ath_debug_stat_rx(sc, rx_stats);
 
-/*
- * For Decrypt or Demic errors, we only mark packet status here and always push
- * up the frame up to let mac80211 handle the actual error case, be it no
- * decryption key or real decryption error. This let us keep statistics there.
- */
-static int ath9k_rx_skb_preprocess(struct ath_softc *sc,
-       struct ieee80211_hdr *hdr,
-       struct ath_rx_status *rx_stats,
-       struct ieee80211_rx_status *rx_status,
-       bool *decrypt_error)
-{
- struct ieee80211_hw *hw = sc->hw;
- struct ath_hw *ah = sc->sc_ah;
- struct ath_common *common = ath9k_hw_common(ah);
- bool discard_current = sc->rx.discard_next;
+ /*
+  * Process PHY errors and return so that the packet
+  * can be dropped.
+  */
+ if (rx_stats->rs_status & ATH9K_RXERR_PHY) {
+  ath9k_dfs_process_phyerr(sc, hdr, rx_stats, rx_status->mactime);
+  if (ath_process_fft(sc, hdr, rx_stats, rx_status->mactime))
+   RX_STAT_INC(rx_spectral);
 
- sc->rx.discard_next = rx_stats->rs_more;
- if (discard_current)
   return -EINVAL;
+ }
 
  /*
   * everything but the rate is checked here, the rate check is done
   * separately to avoid doing two lookups for a rate for each frame.
   */
- if (!ath9k_rx_accept(common, hdr, rx_status, rx_stats, decrypt_error))
+ if (!ath9k_cmn_rx_accept(common, hdr, rx_status, rx_stats, decrypt_error, sc->rx.rxfilter))
   return -EINVAL;
 
- /* Only use status info from the last fragment */
- if (rx_stats->rs_more)
-  return 0;
+ if (ath_is_mybeacon(common, hdr)) {
+  RX_STAT_INC(rx_beacons);
+  rx_stats->is_mybeacon = true;
+ }
 
- ath9k_process_rssi(common, hw, hdr, rx_stats);
+ /*
+  * This shouldn't happen, but have a safety check anyway.
+  */
+ if (WARN_ON(!ah->curchan))
+  return -EINVAL;
 
- if (ath9k_process_rate(common, hw, rx_stats, rx_status))
+ if (ath9k_cmn_process_rate(common, hw, rx_stats, rx_status)) {
+  /*
+   * No valid hardware bitrate found -- we should not get here
+   * because hardware has already validated this frame as OK.
+   */
+  ath_dbg(common, ANY, "unsupported hw bitrate detected 0x%02x using 1 Mbit\n",
+   rx_stats->rs_rate);
+  RX_STAT_INC(rx_rate_err);
   return -EINVAL;
+ }
 
- rx_status->band = hw->conf.chandef.chan->band;
- rx_status->freq = hw->conf.chandef.chan->center_freq;
- rx_status->signal = ah->noise + rx_stats->rs_rssi;
+ ath9k_cmn_process_rssi(common, hw, rx_stats, rx_status);
+
+ rx_status->band = ah->curchan->chan->band;
+ rx_status->freq = ah->curchan->chan->center_freq;
  rx_status->antenna = rx_stats->rs_antenna;
  rx_status->flag |= RX_FLAG_MACTIME_END;
- if (rx_stats->rs_moreaggr)
-  rx_status->flag |= RX_FLAG_NO_SIGNAL_VAL;
-
- sc->rx.discard_next = false;
- return 0;
-}
 
-static void ath9k_rx_skb_postprocess(struct ath_common *common,
-         struct sk_buff *skb,
-         struct ath_rx_status *rx_stats,
-         struct ieee80211_rx_status *rxs,
-         bool decrypt_error)
-{
- struct ath_hw *ah = common->ah;
- struct ieee80211_hdr *hdr;
- int hdrlen, padpos, padsize;
- u8 keyix;
- __le16 fc;
-
- /* see if any padding is done by the hw and remove it */
- hdr = (struct ieee80211_hdr *) skb->data;
- hdrlen = ieee80211_get_hdrlen_from_skb(skb);
- fc = hdr->frame_control;
- padpos = ieee80211_hdrlen(fc);
-
- /* The MAC header is padded to have 32-bit boundary if the
-  * packet payload is non-zero. The general calculation for
-  * padsize would take into account odd header lengths:
-  * padsize = (4 - padpos % 4) % 4; However, since only
-  * even-length headers are used, padding can only be 0 or 2
-  * bytes and we can optimize this a bit. In addition, we must
-  * not try to remove padding from short control frames that do
-  * not have payload. */
- padsize = padpos & 3;
- if (padsize && skb->len>=padpos+padsize+FCS_LEN) {
-  memmove(skb->data + padsize, skb->data, padpos);
-  skb_pull(skb, padsize);
- }
-
- keyix = rx_stats->rs_keyix;
-
- if (!(keyix == ATH9K_RXKEYIX_INVALID) && !decrypt_error &&
-     ieee80211_has_protected(fc)) {
-  rxs->flag |= RX_FLAG_DECRYPTED;
- } else if (ieee80211_has_protected(fc)
-     && !decrypt_error && skb->len >= hdrlen + 4) {
-  keyix = skb->data[hdrlen + 3] >> 6;
+#ifdef CONFIG_ATH9K_BTCOEX_SUPPORT
+ if (ieee80211_is_data_present(hdr->frame_control) &&
+     !ieee80211_is_qos_nullfunc(hdr->frame_control))
+  sc->rx.num_pkts++;
+#endif
 
-  if (test_bit(keyix, common->keymap))
-   rxs->flag |= RX_FLAG_DECRYPTED;
- }
- if (ah->sw_mgmt_crypto &&
-     (rxs->flag & RX_FLAG_DECRYPTED) &&
-     ieee80211_is_mgmt(fc))
-  /* Use software decrypt for management frames. */
-  rxs->flag &= ~RX_FLAG_DECRYPTED;
-}
+ return 0;
 
-#ifdef CONFIG_ATH9K_DEBUGFS
-static s8 fix_rssi_inv_only(u8 rssi_val)
-{
- if (rssi_val == 128)
-  rssi_val = 0;
- return (s8) rssi_val;
+corrupt:
+ sc->rx.discard_next = rx_stats->rs_more;
+ return -EINVAL;
 }
-#endif
 
-/* returns 1 if this was a spectral frame, even if not handled. */
-static int ath_process_fft(struct ath_softc *sc, struct ieee80211_hdr *hdr,
-      struct ath_rx_status *rs, u64 tsf)
+/*
+ * Run the LNA combining algorithm only in these cases:
+ *
+ * Standalone WLAN cards with both LNA/Antenna diversity
+ * enabled in the EEPROM.
+ *
+ * WLAN+BT cards which are in the supported card list
+ * in ath_pci_id_table and the user has loaded the
+ * driver with "bt_ant_diversity" set to true.
+ */
+static void ath9k_antenna_check(struct ath_softc *sc,
+    struct ath_rx_status *rs)
 {
-#ifdef CONFIG_ATH9K_DEBUGFS
  struct ath_hw *ah = sc->sc_ah;
- u8 bins[SPECTRAL_HT20_NUM_BINS];
- u8 *vdata = (u8 *)hdr;
- struct fft_sample_ht20 fft_sample;
- struct ath_radar_info *radar_info;
- struct ath_ht20_mag_info *mag_info;
- int len = rs->rs_datalen;
- int dc_pos;
- u16 length, max_magnitude;
-
- /* AR9280 and before report via ATH9K_PHYERR_RADAR, AR93xx and newer
-  * via ATH9K_PHYERR_SPECTRAL. Haven't seen ATH9K_PHYERR_FALSE_RADAR_EXT
-  * yet, but this is supposed to be possible as well.
-  */
- if (rs->rs_phyerr != ATH9K_PHYERR_RADAR &&
-     rs->rs_phyerr != ATH9K_PHYERR_FALSE_RADAR_EXT &&
-     rs->rs_phyerr != ATH9K_PHYERR_SPECTRAL)
-  return 0;
+ struct ath9k_hw_capabilities *pCap = &ah->caps;
+ struct ath_common *common = ath9k_hw_common(ah);
 
- /* check if spectral scan bit is set. This does not have to be checked
-  * if received through a SPECTRAL phy error, but shouldn't hurt.
-  */
- radar_info = ((struct ath_radar_info *)&vdata[len]) - 1;
- if (!(radar_info->pulse_bw_info & SPECTRAL_SCAN_BITMASK))
-  return 0;
+ if (!(ah->caps.hw_caps & ATH9K_HW_CAP_ANT_DIV_COMB))
+  return;
 
- /* Variation in the data length is possible and will be fixed later.
-  * Note that we only support HT20 for now.
-  *
-  * TODO: add HT20_40 support as well.
+ /*
+  * Change the default rx antenna if rx diversity
+  * chooses the other antenna 3 times in a row.
   */
- if ((len > SPECTRAL_HT20_TOTAL_DATA_LEN + 2) ||
-     (len < SPECTRAL_HT20_TOTAL_DATA_LEN - 1))
-  return 1;
-
- fft_sample.tlv.type = ATH_FFT_SAMPLE_HT20;
- length = sizeof(fft_sample) - sizeof(fft_sample.tlv);
- fft_sample.tlv.length = __cpu_to_be16(length);
-
- fft_sample.freq = __cpu_to_be16(ah->curchan->chan->center_freq);
- fft_sample.rssi = fix_rssi_inv_only(rs->rs_rssi_ctl0);
- fft_sample.noise = ah->noise;
-
- switch (len - SPECTRAL_HT20_TOTAL_DATA_LEN) {
- case 0:
-  /* length correct, nothing to do. */
-  memcpy(bins, vdata, SPECTRAL_HT20_NUM_BINS);
-  break;
- case -1:
-  /* first byte missing, duplicate it. */
-  memcpy(&bins[1], vdata, SPECTRAL_HT20_NUM_BINS - 1);
-  bins[0] = vdata[0];
-  break;
- case 2:
-  /* MAC added 2 extra bytes at bin 30 and 32, remove them. */
-  memcpy(bins, vdata, 30);
-  bins[30] = vdata[31];
-  memcpy(&bins[31], &vdata[33], SPECTRAL_HT20_NUM_BINS - 31);
-  break;
- case 1:
-  /* MAC added 2 extra bytes AND first byte is missing. */
-  bins[0] = vdata[0];
-  memcpy(&bins[0], vdata, 30);
-  bins[31] = vdata[31];
-  memcpy(&bins[32], &vdata[33], SPECTRAL_HT20_NUM_BINS - 32);
-  break;
- default:
-  return 1;
+ if (sc->rx.defant != rs->rs_antenna) {
+  if (++sc->rx.rxotherant >= 3)
+   ath_setdefantenna(sc, rs->rs_antenna);
+ } else {
+  sc->rx.rxotherant = 0;
  }
 
- /* DC value (value in the middle) is the blind spot of the spectral
-  * sample and invalid, interpolate it.
-  */
- dc_pos = SPECTRAL_HT20_NUM_BINS / 2;
- bins[dc_pos] = (bins[dc_pos + 1] + bins[dc_pos - 1]) / 2;
-
- /* mag data is at the end of the frame, in front of radar_info */
- mag_info = ((struct ath_ht20_mag_info *)radar_info) - 1;
-
- /* copy raw bins without scaling them */
- memcpy(fft_sample.data, bins, SPECTRAL_HT20_NUM_BINS);
- fft_sample.max_exp = mag_info->max_exp & 0xf;
-
- max_magnitude = spectral_max_magnitude(mag_info->all_bins);
- fft_sample.max_magnitude = __cpu_to_be16(max_magnitude);
- fft_sample.max_index = spectral_max_index(mag_info->all_bins);
- fft_sample.bitmap_weight = spectral_bitmap_weight(mag_info->all_bins);
- fft_sample.tsf = __cpu_to_be64(tsf);
-
- ath_debug_send_fft_sample(sc, &fft_sample.tlv);
- return 1;
-#else
- return 0;
-#endif
+ if (pCap->hw_caps & ATH9K_HW_CAP_BT_ANT_DIV) {
+  if (common->bt_ant_diversity)
+   ath_ant_comb_scan(sc, rs);
+ } else {
+  ath_ant_comb_scan(sc, rs);
+ }
 }
 
 static void ath9k_apply_ampdu_details(struct ath_softc *sc,
@@ -1165,23 +966,21 @@ static void ath9k_apply_ampdu_details(struct ath_softc *sc,
 
 int ath_rx_tasklet(struct ath_softc *sc, int flush, bool hp)
 {
- struct ath_buf *bf;
+ struct ath_rxbuf *bf;
  struct sk_buff *skb = NULL, *requeue_skb, *hdr_skb;
  struct ieee80211_rx_status *rxs;
  struct ath_hw *ah = sc->sc_ah;
  struct ath_common *common = ath9k_hw_common(ah);
  struct ieee80211_hw *hw = sc->hw;
- struct ieee80211_hdr *hdr;
  int retval;
  struct ath_rx_status rs;
  enum ath9k_rx_qtype qtype;
  bool edma = !!(ah->caps.hw_caps & ATH9K_HW_CAP_EDMA);
  int dma_type;
- u8 rx_status_len = ah->caps.rx_status_len;
  u64 tsf = 0;
- u32 tsf_lower = 0;
  unsigned long flags;
  dma_addr_t new_buf_addr;
+ unsigned int budget = 512;
 
  if (edma)
   dma_type = DMA_BIDIRECTIONAL;
@@ -1191,7 +990,6 @@ int ath_rx_tasklet(struct ath_softc *sc, int flush, bool hp)
  qtype = hp ? ATH9K_RX_QUEUE_HP : ATH9K_RX_QUEUE_LP;
 
  tsf = ath9k_hw_gettsf64(ah);
- tsf_lower = tsf & 0xffffffff;
 
  do {
   bool decrypt_error = false;
@@ -1218,55 +1016,14 @@ int ath_rx_tasklet(struct ath_softc *sc, int flush, bool hp)
   else
    hdr_skb = skb;
 
-  hdr = (struct ieee80211_hdr *) (hdr_skb->data + rx_status_len);
   rxs = IEEE80211_SKB_RXCB(hdr_skb);
-  if (ieee80211_is_beacon(hdr->frame_control)) {
-   RX_STAT_INC(rx_beacons);
-   if (!is_zero_ether_addr(common->curbssid) &&
-       ether_addr_equal(hdr->addr3, common->curbssid))
-    rs.is_mybeacon = true;
-   else
-    rs.is_mybeacon = false;
-  }
-  else
-   rs.is_mybeacon = false;
-
-  if (ieee80211_is_data_present(hdr->frame_control) &&
-      !ieee80211_is_qos_nullfunc(hdr->frame_control))
-   sc->rx.num_pkts++;
-
-  ath_debug_stat_rx(sc, &rs);
-
   memset(rxs, 0, sizeof(struct ieee80211_rx_status));
 
-  rxs->mactime = (tsf & ~0xffffffffULL) | rs.rs_tstamp;
-  if (rs.rs_tstamp > tsf_lower &&
-      unlikely(rs.rs_tstamp - tsf_lower > 0x10000000))
-   rxs->mactime -= 0x100000000ULL;
-
-  if (rs.rs_tstamp < tsf_lower &&
-      unlikely(tsf_lower - rs.rs_tstamp > 0x10000000))
-   rxs->mactime += 0x100000000ULL;
-
-  if (rs.rs_phyerr == ATH9K_PHYERR_RADAR)
-   ath9k_dfs_process_phyerr(sc, hdr, &rs, rxs->mactime);
-
-  if (rs.rs_status & ATH9K_RXERR_PHY) {
-   if (ath_process_fft(sc, hdr, &rs, rxs->mactime)) {
-    RX_STAT_INC(rx_spectral);
-    goto requeue_drop_frag;
-   }
-  }
-
-  retval = ath9k_rx_skb_preprocess(sc, hdr, &rs, rxs,
-       &decrypt_error);
+  retval = ath9k_rx_skb_preprocess(sc, hdr_skb, &rs, rxs,
+       &decrypt_error, tsf);
   if (retval)
    goto requeue_drop_frag;
 
-  if (rs.is_mybeacon) {
-   sc->hw_busy_count = 0;
-   ath_start_rx_poll(sc, 3);
-  }
   /* Ensure we always have an skb to requeue once we are done
    * processing the current buffer's skb */
   requeue_skb = ath_rxbuf_alloc(common, common->rx_bufsize, GFP_ATOMIC);
@@ -1300,8 +1057,8 @@ int ath_rx_tasklet(struct ath_softc *sc, int flush, bool hp)
    skb_pull(skb, ah->caps.rx_status_len);
 
   if (!rs.rs_more)
-   ath9k_rx_skb_postprocess(common, hdr_skb, &rs,
-       rxs, decrypt_error);
+   ath9k_cmn_rx_skb_postprocess(common, hdr_skb, &rs,
+           rxs, decrypt_error);
 
   if (rs.rs_more) {
    RX_STAT_INC(rx_frags);
@@ -1320,8 +1077,6 @@ int ath_rx_tasklet(struct ath_softc *sc, int flush, bool hp)
    sc->rx.frag = skb;
    goto requeue;
   }
-  if (rs.rs_status & ATH9K_RXERR_CORRUPT_DESC)
-   goto requeue_drop_frag;
 
   if (sc->rx.frag) {
    int space = skb->len - skb_tailroom(hdr_skb);
@@ -1340,22 +1095,6 @@ int ath_rx_tasklet(struct ath_softc *sc, int flush, bool hp)
    skb = hdr_skb;
   }
 
-
-  if (ah->caps.hw_caps & ATH9K_HW_CAP_ANT_DIV_COMB) {
-
-   /*
-    * change the default rx antenna if rx diversity
-    * chooses the other antenna 3 times in a row.
-    */
-   if (sc->rx.defant != rs.rs_antenna) {
-    if (++sc->rx.rxotherant >= 3)
-     ath_setdefantenna(sc, rs.rs_antenna);
-   } else {
-    sc->rx.rxotherant = 0;
-   }
-
-  }
-
   if (rxs->flag & RX_FLAG_MMIC_STRIPPED)
    skb_trim(skb, skb->len - 8);
 
@@ -1367,10 +1106,9 @@ int ath_rx_tasklet(struct ath_softc *sc, int flush, bool hp)
    ath_rx_ps(sc, skb, rs.is_mybeacon);
   spin_unlock_irqrestore(&sc->sc_pm_lock, flags);
 
-  if ((ah->caps.hw_caps & ATH9K_HW_CAP_ANT_DIV_COMB) && sc->ant_rx == 3)
-   ath_ant_comb_scan(sc, &rs);
-
+  ath9k_antenna_check(sc, &rs);
   ath9k_apply_ampdu_details(sc, &rs, rxs);
+  ath_debug_rate_stats(sc, &rs, skb);
 
   ieee80211_rx(hw, skb);
 
@@ -1381,15 +1119,17 @@ requeue_drop_frag:
   }
 requeue:
   list_add_tail(&bf->list, &sc->rx.rxbuf);
-  if (flush)
-   continue;
 
-  if (edma) {
+  if (!edma) {
+   ath_rx_buf_relink(sc, bf, flush);
+   if (!flush)
+    ath9k_hw_rxena(ah);
+  } else if (!flush) {
    ath_rx_edma_buf_link(sc, qtype);
-  } else {
-   ath_rx_buf_relink(sc, bf);
-   ath9k_hw_rxena(ah);
   }
+
+  if (!budget--)
+   break;
  } while (1);
 
  if (!(ah->imask & ATH9K_INT_RXEOL)) {
diff --git a/drivers/net/wireless/ath/ath9k/reg.h b/drivers/net/wireless/ath/ath9k/reg.h
index f7c90cc..f1bbce3 100644
--- a/drivers/net/wireless/ath/ath9k/reg.h
+++ b/drivers/net/wireless/ath/ath9k/reg.h
@@ -304,6 +304,7 @@
 #define AR_IMR_S2              0x00ac
 #define AR_IMR_S2_QCU_TXURN    0x000003FF
 #define AR_IMR_S2_QCU_TXURN_S  0
+#define AR_IMR_S2_BB_WATCHDOG  0x00010000
 #define AR_IMR_S2_CST          0x00400000
 #define AR_IMR_S2_GTT          0x00800000
 #define AR_IMR_S2_TIM          0x01000000
@@ -504,9 +505,6 @@
 #define AR_D_QCUMASK         0x000003FF
 #define AR_D_QCUMASK_RESV0   0xFFFFFC00
 
-#define AR_D_TXBLK_CMD  0x1038
-#define AR_D_TXBLK_DATA(i) (AR_D_TXBLK_CMD+(i))
-
 #define AR_D0_LCL_IFS     0x1040
 #define AR_D1_LCL_IFS     0x1044
 #define AR_D2_LCL_IFS     0x1048
@@ -806,9 +804,15 @@
 #define AR_SREV_REVISION_9580_10 4 /* AR9580 1.0 */
 #define AR_SREV_VERSION_9462  0x280
 #define AR_SREV_REVISION_9462_20 2
+#define AR_SREV_REVISION_9462_21 3
 #define AR_SREV_VERSION_9565            0x2C0
 #define AR_SREV_REVISION_9565_10        0
+#define AR_SREV_REVISION_9565_101       1
+#define AR_SREV_REVISION_9565_11        2
 #define AR_SREV_VERSION_9550  0x400
+#define AR_SREV_VERSION_9531            0x500
+#define AR_SREV_REVISION_9531_10        0
+#define AR_SREV_REVISION_9531_11        1
 
 #define AR_SREV_5416(_ah) \
  (((_ah)->hw_version.macVersion == AR_SREV_VERSION_5416_PCI) || \
@@ -880,9 +884,6 @@
 
 #define AR_SREV_9330(_ah) \
  (((_ah)->hw_version.macVersion == AR_SREV_VERSION_9330))
-#define AR_SREV_9330_10(_ah) \
- (AR_SREV_9330((_ah)) && \
-  ((_ah)->hw_version.macRev == AR_SREV_REVISION_9330_10))
 #define AR_SREV_9330_11(_ah) \
  (AR_SREV_9330((_ah)) && \
   ((_ah)->hw_version.macRev == AR_SREV_REVISION_9330_11))
@@ -892,9 +893,9 @@
 
 #define AR_SREV_9485(_ah) \
  (((_ah)->hw_version.macVersion == AR_SREV_VERSION_9485))
-#define AR_SREV_9485_11(_ah) \
- (AR_SREV_9485(_ah) && \
-  ((_ah)->hw_version.macRev == AR_SREV_REVISION_9485_11))
+#define AR_SREV_9485_11_OR_LATER(_ah) \
+ (((_ah)->hw_version.macVersion == AR_SREV_VERSION_9485) && \
+  ((_ah)->hw_version.macRev >= AR_SREV_REVISION_9485_11))
 #define AR_SREV_9485_OR_LATER(_ah) \
  (((_ah)->hw_version.macVersion >= AR_SREV_VERSION_9485))
 
@@ -911,17 +912,33 @@
 
 #define AR_SREV_9462(_ah) \
  (((_ah)->hw_version.macVersion == AR_SREV_VERSION_9462))
-
 #define AR_SREV_9462_20(_ah) \
  (((_ah)->hw_version.macVersion == AR_SREV_VERSION_9462) && \
- ((_ah)->hw_version.macRev == AR_SREV_REVISION_9462_20))
+  ((_ah)->hw_version.macRev == AR_SREV_REVISION_9462_20))
+#define AR_SREV_9462_21(_ah) \
+ (((_ah)->hw_version.macVersion == AR_SREV_VERSION_9462) && \
+  ((_ah)->hw_version.macRev == AR_SREV_REVISION_9462_21))
+#define AR_SREV_9462_20_OR_LATER(_ah) \
+ (((_ah)->hw_version.macVersion == AR_SREV_VERSION_9462) && \
+  ((_ah)->hw_version.macRev >= AR_SREV_REVISION_9462_20))
+#define AR_SREV_9462_21_OR_LATER(_ah) \
+ (((_ah)->hw_version.macVersion == AR_SREV_VERSION_9462) && \
+  ((_ah)->hw_version.macRev >= AR_SREV_REVISION_9462_21))
 
 #define AR_SREV_9565(_ah) \
  (((_ah)->hw_version.macVersion == AR_SREV_VERSION_9565))
-
 #define AR_SREV_9565_10(_ah) \
  (((_ah)->hw_version.macVersion == AR_SREV_VERSION_9565) && \
   ((_ah)->hw_version.macRev == AR_SREV_REVISION_9565_10))
+#define AR_SREV_9565_101(_ah) \
+ (((_ah)->hw_version.macVersion == AR_SREV_VERSION_9565) && \
+  ((_ah)->hw_version.macRev == AR_SREV_REVISION_9565_101))
+#define AR_SREV_9565_11(_ah) \
+ (((_ah)->hw_version.macVersion == AR_SREV_VERSION_9565) && \
+  ((_ah)->hw_version.macRev == AR_SREV_REVISION_9565_11))
+#define AR_SREV_9565_11_OR_LATER(_ah) \
+ (((_ah)->hw_version.macVersion == AR_SREV_VERSION_9565) && \
+  ((_ah)->hw_version.macRev >= AR_SREV_REVISION_9565_11))
 
 #define AR_SREV_9550(_ah) \
  (((_ah)->hw_version.macVersion == AR_SREV_VERSION_9550))
@@ -929,11 +946,19 @@
 #define AR_SREV_9580(_ah) \
  (((_ah)->hw_version.macVersion == AR_SREV_VERSION_9580) && \
  ((_ah)->hw_version.macRev >= AR_SREV_REVISION_9580_10))
-
 #define AR_SREV_9580_10(_ah) \
  (((_ah)->hw_version.macVersion == AR_SREV_VERSION_9580) && \
  ((_ah)->hw_version.macRev == AR_SREV_REVISION_9580_10))
 
+#define AR_SREV_9531(_ah) \
+ (((_ah)->hw_version.macVersion == AR_SREV_VERSION_9531))
+#define AR_SREV_9531_10(_ah) \
+ (((_ah)->hw_version.macVersion == AR_SREV_VERSION_9531) && \
+  ((_ah)->hw_version.macRev == AR_SREV_REVISION_9531_10))
+#define AR_SREV_9531_11(_ah) \
+ (((_ah)->hw_version.macVersion == AR_SREV_VERSION_9531) && \
+  ((_ah)->hw_version.macRev == AR_SREV_REVISION_9531_11))
+
 /* NOTE: When adding chips newer than Peacock, add chip check here */
 #define AR_SREV_9580_10_OR_LATER(_ah) \
  (AR_SREV_9580(_ah))
diff --git a/drivers/net/wireless/ath/ath9k/spectral.c b/drivers/net/wireless/ath/ath9k/spectral.c
new file mode 100644
index 0000000..99f4de9
--- /dev/null
+++ b/drivers/net/wireless/ath/ath9k/spectral.c
@@ -0,0 +1,543 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <linux/relay.h>
+#include "ath9k.h"
+
+static s8 fix_rssi_inv_only(u8 rssi_val)
+{
+ if (rssi_val == 128)
+  rssi_val = 0;
+ return (s8) rssi_val;
+}
+
+static void ath_debug_send_fft_sample(struct ath_softc *sc,
+          struct fft_sample_tlv *fft_sample_tlv)
+{
+ int length;
+ if (!sc->rfs_chan_spec_scan)
+  return;
+
+ length = __be16_to_cpu(fft_sample_tlv->length) +
+   sizeof(*fft_sample_tlv);
+ relay_write(sc->rfs_chan_spec_scan, fft_sample_tlv, length);
+}
+
+/* returns 1 if this was a spectral frame, even if not handled. */
+int ath_process_fft(struct ath_softc *sc, struct ieee80211_hdr *hdr,
+      struct ath_rx_status *rs, u64 tsf)
+{
+ struct ath_hw *ah = sc->sc_ah;
+ u8 num_bins, *bins, *vdata = (u8 *)hdr;
+ struct fft_sample_ht20 fft_sample_20;
+ struct fft_sample_ht20_40 fft_sample_40;
+ struct fft_sample_tlv *tlv;
+ struct ath_radar_info *radar_info;
+ int len = rs->rs_datalen;
+ int dc_pos;
+ u16 fft_len, length, freq = ah->curchan->chan->center_freq;
+ enum nl80211_channel_type chan_type;
+
+ /* AR9280 and before report via ATH9K_PHYERR_RADAR, AR93xx and newer
+  * via ATH9K_PHYERR_SPECTRAL. Haven't seen ATH9K_PHYERR_FALSE_RADAR_EXT
+  * yet, but this is supposed to be possible as well.
+  */
+ if (rs->rs_phyerr != ATH9K_PHYERR_RADAR &&
+     rs->rs_phyerr != ATH9K_PHYERR_FALSE_RADAR_EXT &&
+     rs->rs_phyerr != ATH9K_PHYERR_SPECTRAL)
+  return 0;
+
+ /* check if spectral scan bit is set. This does not have to be checked
+  * if received through a SPECTRAL phy error, but shouldn't hurt.
+  */
+ radar_info = ((struct ath_radar_info *)&vdata[len]) - 1;
+ if (!(radar_info->pulse_bw_info & SPECTRAL_SCAN_BITMASK))
+  return 0;
+
+ chan_type = cfg80211_get_chandef_type(&sc->hw->conf.chandef);
+ if ((chan_type == NL80211_CHAN_HT40MINUS) ||
+     (chan_type == NL80211_CHAN_HT40PLUS)) {
+  fft_len = SPECTRAL_HT20_40_TOTAL_DATA_LEN;
+  num_bins = SPECTRAL_HT20_40_NUM_BINS;
+  bins = (u8 *)fft_sample_40.data;
+ } else {
+  fft_len = SPECTRAL_HT20_TOTAL_DATA_LEN;
+  num_bins = SPECTRAL_HT20_NUM_BINS;
+  bins = (u8 *)fft_sample_20.data;
+ }
+
+ /* Variation in the data length is possible and will be fixed later */
+ if ((len > fft_len + 2) || (len < fft_len - 1))
+  return 1;
+
+ switch (len - fft_len) {
+ case 0:
+  /* length correct, nothing to do. */
+  memcpy(bins, vdata, num_bins);
+  break;
+ case -1:
+  /* first byte missing, duplicate it. */
+  memcpy(&bins[1], vdata, num_bins - 1);
+  bins[0] = vdata[0];
+  break;
+ case 2:
+  /* MAC added 2 extra bytes at bin 30 and 32, remove them. */
+  memcpy(bins, vdata, 30);
+  bins[30] = vdata[31];
+  memcpy(&bins[31], &vdata[33], num_bins - 31);
+  break;
+ case 1:
+  /* MAC added 2 extra bytes AND first byte is missing. */
+  bins[0] = vdata[0];
+  memcpy(&bins[1], vdata, 30);
+  bins[31] = vdata[31];
+  memcpy(&bins[32], &vdata[33], num_bins - 32);
+  break;
+ default:
+  return 1;
+ }
+
+ /* DC value (value in the middle) is the blind spot of the spectral
+  * sample and invalid, interpolate it.
+  */
+ dc_pos = num_bins / 2;
+ bins[dc_pos] = (bins[dc_pos + 1] + bins[dc_pos - 1]) / 2;
+
+ if ((chan_type == NL80211_CHAN_HT40MINUS) ||
+     (chan_type == NL80211_CHAN_HT40PLUS)) {
+  s8 lower_rssi, upper_rssi;
+  s16 ext_nf;
+  u8 lower_max_index, upper_max_index;
+  u8 lower_bitmap_w, upper_bitmap_w;
+  u16 lower_mag, upper_mag;
+  struct ath9k_hw_cal_data *caldata = ah->caldata;
+  struct ath_ht20_40_mag_info *mag_info;
+
+  if (caldata)
+   ext_nf = ath9k_hw_getchan_noise(ah, ah->curchan,
+     caldata->nfCalHist[3].privNF);
+  else
+   ext_nf = ATH_DEFAULT_NOISE_FLOOR;
+
+  length = sizeof(fft_sample_40) - sizeof(struct fft_sample_tlv);
+  fft_sample_40.tlv.type = ATH_FFT_SAMPLE_HT20_40;
+  fft_sample_40.tlv.length = __cpu_to_be16(length);
+  fft_sample_40.freq = __cpu_to_be16(freq);
+  fft_sample_40.channel_type = chan_type;
+
+  if (chan_type == NL80211_CHAN_HT40PLUS) {
+   lower_rssi = fix_rssi_inv_only(rs->rs_rssi_ctl[0]);
+   upper_rssi = fix_rssi_inv_only(rs->rs_rssi_ext[0]);
+
+   fft_sample_40.lower_noise = ah->noise;
+   fft_sample_40.upper_noise = ext_nf;
+  } else {
+   lower_rssi = fix_rssi_inv_only(rs->rs_rssi_ext[0]);
+   upper_rssi = fix_rssi_inv_only(rs->rs_rssi_ctl[0]);
+
+   fft_sample_40.lower_noise = ext_nf;
+   fft_sample_40.upper_noise = ah->noise;
+  }
+  fft_sample_40.lower_rssi = lower_rssi;
+  fft_sample_40.upper_rssi = upper_rssi;
+
+  mag_info = ((struct ath_ht20_40_mag_info *)radar_info) - 1;
+  lower_mag = spectral_max_magnitude(mag_info->lower_bins);
+  upper_mag = spectral_max_magnitude(mag_info->upper_bins);
+  fft_sample_40.lower_max_magnitude = __cpu_to_be16(lower_mag);
+  fft_sample_40.upper_max_magnitude = __cpu_to_be16(upper_mag);
+  lower_max_index = spectral_max_index(mag_info->lower_bins);
+  upper_max_index = spectral_max_index(mag_info->upper_bins);
+  fft_sample_40.lower_max_index = lower_max_index;
+  fft_sample_40.upper_max_index = upper_max_index;
+  lower_bitmap_w = spectral_bitmap_weight(mag_info->lower_bins);
+  upper_bitmap_w = spectral_bitmap_weight(mag_info->upper_bins);
+  fft_sample_40.lower_bitmap_weight = lower_bitmap_w;
+  fft_sample_40.upper_bitmap_weight = upper_bitmap_w;
+  fft_sample_40.max_exp = mag_info->max_exp & 0xf;
+
+  fft_sample_40.tsf = __cpu_to_be64(tsf);
+
+  tlv = (struct fft_sample_tlv *)&fft_sample_40;
+ } else {
+  u8 max_index, bitmap_w;
+  u16 magnitude;
+  struct ath_ht20_mag_info *mag_info;
+
+  length = sizeof(fft_sample_20) - sizeof(struct fft_sample_tlv);
+  fft_sample_20.tlv.type = ATH_FFT_SAMPLE_HT20;
+  fft_sample_20.tlv.length = __cpu_to_be16(length);
+  fft_sample_20.freq = __cpu_to_be16(freq);
+
+  fft_sample_20.rssi = fix_rssi_inv_only(rs->rs_rssi_ctl[0]);
+  fft_sample_20.noise = ah->noise;
+
+  mag_info = ((struct ath_ht20_mag_info *)radar_info) - 1;
+  magnitude = spectral_max_magnitude(mag_info->all_bins);
+  fft_sample_20.max_magnitude = __cpu_to_be16(magnitude);
+  max_index = spectral_max_index(mag_info->all_bins);
+  fft_sample_20.max_index = max_index;
+  bitmap_w = spectral_bitmap_weight(mag_info->all_bins);
+  fft_sample_20.bitmap_weight = bitmap_w;
+  fft_sample_20.max_exp = mag_info->max_exp & 0xf;
+
+  fft_sample_20.tsf = __cpu_to_be64(tsf);
+
+  tlv = (struct fft_sample_tlv *)&fft_sample_20;
+ }
+
+ ath_debug_send_fft_sample(sc, tlv);
+
+ return 1;
+}
+
+/*********************/
+/* spectral_scan_ctl */
+/*********************/
+
+static ssize_t read_file_spec_scan_ctl(struct file *file, char __user *user_buf,
+           size_t count, loff_t *ppos)
+{
+ struct ath_softc *sc = file->private_data;
+ char *mode = "";
+ unsigned int len;
+
+ switch (sc->spectral_mode) {
+ case SPECTRAL_DISABLED:
+  mode = "disable";
+  break;
+ case SPECTRAL_BACKGROUND:
+  mode = "background";
+  break;
+ case SPECTRAL_CHANSCAN:
+  mode = "chanscan";
+  break;
+ case SPECTRAL_MANUAL:
+  mode = "manual";
+  break;
+ }
+ len = strlen(mode);
+ return simple_read_from_buffer(user_buf, count, ppos, mode, len);
+}
+
+static ssize_t write_file_spec_scan_ctl(struct file *file,
+     const char __user *user_buf,
+     size_t count, loff_t *ppos)
+{
+ struct ath_softc *sc = file->private_data;
+ struct ath_common *common = ath9k_hw_common(sc->sc_ah);
+ char buf[32];
+ ssize_t len;
+
+ if (config_enabled(CONFIG_ATH9K_TX99))
+  return -EOPNOTSUPP;
+
+ len = min(count, sizeof(buf) - 1);
+ if (copy_from_user(buf, user_buf, len))
+  return -EFAULT;
+
+ buf[len] = '\0';
+
+ if (strncmp("trigger", buf, 7) == 0) {
+  ath9k_spectral_scan_trigger(sc->hw);
+ } else if (strncmp("background", buf, 9) == 0) {
+  ath9k_spectral_scan_config(sc->hw, SPECTRAL_BACKGROUND);
+  ath_dbg(common, CONFIG, "spectral scan: background mode enabled\n");
+ } else if (strncmp("chanscan", buf, 8) == 0) {
+  ath9k_spectral_scan_config(sc->hw, SPECTRAL_CHANSCAN);
+  ath_dbg(common, CONFIG, "spectral scan: channel scan mode enabled\n");
+ } else if (strncmp("manual", buf, 6) == 0) {
+  ath9k_spectral_scan_config(sc->hw, SPECTRAL_MANUAL);
+  ath_dbg(common, CONFIG, "spectral scan: manual mode enabled\n");
+ } else if (strncmp("disable", buf, 7) == 0) {
+  ath9k_spectral_scan_config(sc->hw, SPECTRAL_DISABLED);
+  ath_dbg(common, CONFIG, "spectral scan: disabled\n");
+ } else {
+  return -EINVAL;
+ }
+
+ return count;
+}
+
+static const struct file_operations fops_spec_scan_ctl = {
+ .read = read_file_spec_scan_ctl,
+ .write = write_file_spec_scan_ctl,
+ .open = simple_open,
+ .owner = THIS_MODULE,
+ .llseek = default_llseek,
+};
+
+/*************************/
+/* spectral_short_repeat */
+/*************************/
+
+static ssize_t read_file_spectral_short_repeat(struct file *file,
+            char __user *user_buf,
+            size_t count, loff_t *ppos)
+{
+ struct ath_softc *sc = file->private_data;
+ char buf[32];
+ unsigned int len;
+
+ len = sprintf(buf, "%d\n", sc->spec_config.short_repeat);
+ return simple_read_from_buffer(user_buf, count, ppos, buf, len);
+}
+
+static ssize_t write_file_spectral_short_repeat(struct file *file,
+      const char __user *user_buf,
+      size_t count, loff_t *ppos)
+{
+ struct ath_softc *sc = file->private_data;
+ unsigned long val;
+ char buf[32];
+ ssize_t len;
+
+ len = min(count, sizeof(buf) - 1);
+ if (copy_from_user(buf, user_buf, len))
+  return -EFAULT;
+
+ buf[len] = '\0';
+ if (kstrtoul(buf, 0, &val))
+  return -EINVAL;
+
+ if (val < 0 || val > 1)
+  return -EINVAL;
+
+ sc->spec_config.short_repeat = val;
+ return count;
+}
+
+static const struct file_operations fops_spectral_short_repeat = {
+ .read = read_file_spectral_short_repeat,
+ .write = write_file_spectral_short_repeat,
+ .open = simple_open,
+ .owner = THIS_MODULE,
+ .llseek = default_llseek,
+};
+
+/******************/
+/* spectral_count */
+/******************/
+
+static ssize_t read_file_spectral_count(struct file *file,
+     char __user *user_buf,
+     size_t count, loff_t *ppos)
+{
+ struct ath_softc *sc = file->private_data;
+ char buf[32];
+ unsigned int len;
+
+ len = sprintf(buf, "%d\n", sc->spec_config.count);
+ return simple_read_from_buffer(user_buf, count, ppos, buf, len);
+}
+
+static ssize_t write_file_spectral_count(struct file *file,
+      const char __user *user_buf,
+      size_t count, loff_t *ppos)
+{
+ struct ath_softc *sc = file->private_data;
+ unsigned long val;
+ char buf[32];
+ ssize_t len;
+
+ len = min(count, sizeof(buf) - 1);
+ if (copy_from_user(buf, user_buf, len))
+  return -EFAULT;
+
+ buf[len] = '\0';
+ if (kstrtoul(buf, 0, &val))
+  return -EINVAL;
+
+ if (val < 0 || val > 255)
+  return -EINVAL;
+
+ sc->spec_config.count = val;
+ return count;
+}
+
+static const struct file_operations fops_spectral_count = {
+ .read = read_file_spectral_count,
+ .write = write_file_spectral_count,
+ .open = simple_open,
+ .owner = THIS_MODULE,
+ .llseek = default_llseek,
+};
+
+/*******************/
+/* spectral_period */
+/*******************/
+
+static ssize_t read_file_spectral_period(struct file *file,
+      char __user *user_buf,
+      size_t count, loff_t *ppos)
+{
+ struct ath_softc *sc = file->private_data;
+ char buf[32];
+ unsigned int len;
+
+ len = sprintf(buf, "%d\n", sc->spec_config.period);
+ return simple_read_from_buffer(user_buf, count, ppos, buf, len);
+}
+
+static ssize_t write_file_spectral_period(struct file *file,
+       const char __user *user_buf,
+       size_t count, loff_t *ppos)
+{
+ struct ath_softc *sc = file->private_data;
+ unsigned long val;
+ char buf[32];
+ ssize_t len;
+
+ len = min(count, sizeof(buf) - 1);
+ if (copy_from_user(buf, user_buf, len))
+  return -EFAULT;
+
+ buf[len] = '\0';
+ if (kstrtoul(buf, 0, &val))
+  return -EINVAL;
+
+ if (val < 0 || val > 255)
+  return -EINVAL;
+
+ sc->spec_config.period = val;
+ return count;
+}
+
+static const struct file_operations fops_spectral_period = {
+ .read = read_file_spectral_period,
+ .write = write_file_spectral_period,
+ .open = simple_open,
+ .owner = THIS_MODULE,
+ .llseek = default_llseek,
+};
+
+/***********************/
+/* spectral_fft_period */
+/***********************/
+
+static ssize_t read_file_spectral_fft_period(struct file *file,
+          char __user *user_buf,
+          size_t count, loff_t *ppos)
+{
+ struct ath_softc *sc = file->private_data;
+ char buf[32];
+ unsigned int len;
+
+ len = sprintf(buf, "%d\n", sc->spec_config.fft_period);
+ return simple_read_from_buffer(user_buf, count, ppos, buf, len);
+}
+
+static ssize_t write_file_spectral_fft_period(struct file *file,
+           const char __user *user_buf,
+           size_t count, loff_t *ppos)
+{
+ struct ath_softc *sc = file->private_data;
+ unsigned long val;
+ char buf[32];
+ ssize_t len;
+
+ len = min(count, sizeof(buf) - 1);
+ if (copy_from_user(buf, user_buf, len))
+  return -EFAULT;
+
+ buf[len] = '\0';
+ if (kstrtoul(buf, 0, &val))
+  return -EINVAL;
+
+ if (val < 0 || val > 15)
+  return -EINVAL;
+
+ sc->spec_config.fft_period = val;
+ return count;
+}
+
+static const struct file_operations fops_spectral_fft_period = {
+ .read = read_file_spectral_fft_period,
+ .write = write_file_spectral_fft_period,
+ .open = simple_open,
+ .owner = THIS_MODULE,
+ .llseek = default_llseek,
+};
+
+/*******************/
+/* Relay interface */
+/*******************/
+
+static struct dentry *create_buf_file_handler(const char *filename,
+           struct dentry *parent,
+           umode_t mode,
+           struct rchan_buf *buf,
+           int *is_global)
+{
+ struct dentry *buf_file;
+
+ buf_file = debugfs_create_file(filename, mode, parent, buf,
+           &relay_file_operations);
+ *is_global = 1;
+ return buf_file;
+}
+
+static int remove_buf_file_handler(struct dentry *dentry)
+{
+ debugfs_remove(dentry);
+
+ return 0;
+}
+
+static struct rchan_callbacks rfs_spec_scan_cb = {
+ .create_buf_file = create_buf_file_handler,
+ .remove_buf_file = remove_buf_file_handler,
+};
+
+/*********************/
+/* Debug Init/Deinit */
+/*********************/
+
+void ath9k_spectral_deinit_debug(struct ath_softc *sc)
+{
+ if (config_enabled(CONFIG_ATH9K_DEBUGFS) && sc->rfs_chan_spec_scan) {
+  relay_close(sc->rfs_chan_spec_scan);
+  sc->rfs_chan_spec_scan = NULL;
+ }
+}
+
+void ath9k_spectral_init_debug(struct ath_softc *sc)
+{
+ sc->rfs_chan_spec_scan = relay_open("spectral_scan",
+         sc->debug.debugfs_phy,
+         1024, 256, &rfs_spec_scan_cb,
+         NULL);
+ debugfs_create_file("spectral_scan_ctl",
+       S_IRUSR | S_IWUSR,
+       sc->debug.debugfs_phy, sc,
+       &fops_spec_scan_ctl);
+ debugfs_create_file("spectral_short_repeat",
+       S_IRUSR | S_IWUSR,
+       sc->debug.debugfs_phy, sc,
+       &fops_spectral_short_repeat);
+ debugfs_create_file("spectral_count",
+       S_IRUSR | S_IWUSR,
+       sc->debug.debugfs_phy, sc,
+       &fops_spectral_count);
+ debugfs_create_file("spectral_period",
+       S_IRUSR | S_IWUSR,
+       sc->debug.debugfs_phy, sc,
+       &fops_spectral_period);
+ debugfs_create_file("spectral_fft_period",
+       S_IRUSR | S_IWUSR,
+       sc->debug.debugfs_phy, sc,
+       &fops_spectral_fft_period);
+}
diff --git a/drivers/net/wireless/ath/ath9k/spectral.h b/drivers/net/wireless/ath/ath9k/spectral.h
new file mode 100644
index 0000000..ead6341
--- /dev/null
+++ b/drivers/net/wireless/ath/ath9k/spectral.h
@@ -0,0 +1,212 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef SPECTRAL_H
+#define SPECTRAL_H
+
+/* enum spectral_mode:
+ *
+ * @SPECTRAL_DISABLED: spectral mode is disabled
+ * @SPECTRAL_BACKGROUND: hardware sends samples when it is not busy with
+ * something else.
+ * @SPECTRAL_MANUAL: spectral scan is enabled, triggering for samples
+ * is performed manually.
+ * @SPECTRAL_CHANSCAN: Like manual, but also triggered when changing channels
+ * during a channel scan.
+ */
+enum spectral_mode {
+ SPECTRAL_DISABLED = 0,
+ SPECTRAL_BACKGROUND,
+ SPECTRAL_MANUAL,
+ SPECTRAL_CHANSCAN,
+};
+
+#define SPECTRAL_SCAN_BITMASK  0x10
+/* Radar info packet format, used for DFS and spectral formats. */
+struct ath_radar_info {
+ u8 pulse_length_pri;
+ u8 pulse_length_ext;
+ u8 pulse_bw_info;
+} __packed;
+
+/* The HT20 spectral data has 4 bytes of additional information at it's end.
+ *
+ * [7:0]: all bins {max_magnitude[1:0], bitmap_weight[5:0]}
+ * [7:0]: all bins  max_magnitude[9:2]
+ * [7:0]: all bins {max_index[5:0], max_magnitude[11:10]}
+ * [3:0]: max_exp (shift amount to size max bin to 8-bit unsigned)
+ */
+struct ath_ht20_mag_info {
+ u8 all_bins[3];
+ u8 max_exp;
+} __packed;
+
+#define SPECTRAL_HT20_NUM_BINS  56
+
+/* WARNING: don't actually use this struct! MAC may vary the amount of
+ * data by -1/+2. This struct is for reference only.
+ */
+struct ath_ht20_fft_packet {
+ u8 data[SPECTRAL_HT20_NUM_BINS];
+ struct ath_ht20_mag_info mag_info;
+ struct ath_radar_info radar_info;
+} __packed;
+
+#define SPECTRAL_HT20_TOTAL_DATA_LEN (sizeof(struct ath_ht20_fft_packet))
+
+/* Dynamic 20/40 mode:
+ *
+ * [7:0]: lower bins {max_magnitude[1:0], bitmap_weight[5:0]}
+ * [7:0]: lower bins  max_magnitude[9:2]
+ * [7:0]: lower bins {max_index[5:0], max_magnitude[11:10]}
+ * [7:0]: upper bins {max_magnitude[1:0], bitmap_weight[5:0]}
+ * [7:0]: upper bins  max_magnitude[9:2]
+ * [7:0]: upper bins {max_index[5:0], max_magnitude[11:10]}
+ * [3:0]: max_exp (shift amount to size max bin to 8-bit unsigned)
+ */
+struct ath_ht20_40_mag_info {
+ u8 lower_bins[3];
+ u8 upper_bins[3];
+ u8 max_exp;
+} __packed;
+
+#define SPECTRAL_HT20_40_NUM_BINS  128
+
+/* WARNING: don't actually use this struct! MAC may vary the amount of
+ * data. This struct is for reference only.
+ */
+struct ath_ht20_40_fft_packet {
+ u8 data[SPECTRAL_HT20_40_NUM_BINS];
+ struct ath_ht20_40_mag_info mag_info;
+ struct ath_radar_info radar_info;
+} __packed;
+
+
+#define SPECTRAL_HT20_40_TOTAL_DATA_LEN (sizeof(struct ath_ht20_40_fft_packet))
+
+/* grabs the max magnitude from the all/upper/lower bins */
+static inline u16 spectral_max_magnitude(u8 *bins)
+{
+ return (bins[0] & 0xc0) >> 6 |
+        (bins[1] & 0xff) << 2 |
+        (bins[2] & 0x03) << 10;
+}
+
+/* return the max magnitude from the all/upper/lower bins */
+static inline u8 spectral_max_index(u8 *bins)
+{
+ s8 m = (bins[2] & 0xfc) >> 2;
+
+ /* TODO: this still doesn't always report the right values ... */
+ if (m > 32)
+  m |= 0xe0;
+ else
+  m &= ~0xe0;
+
+ return m + 29;
+}
+
+/* return the bitmap weight from the all/upper/lower bins */
+static inline u8 spectral_bitmap_weight(u8 *bins)
+{
+ return bins[0] & 0x3f;
+}
+
+/* FFT sample format given to userspace via debugfs.
+ *
+ * Please keep the type/length at the front position and change
+ * other fields after adding another sample type
+ *
+ * TODO: this might need rework when switching to nl80211-based
+ * interface.
+ */
+enum ath_fft_sample_type {
+ ATH_FFT_SAMPLE_HT20 = 1,
+ ATH_FFT_SAMPLE_HT20_40,
+};
+
+struct fft_sample_tlv {
+ u8 type; /* see ath_fft_sample */
+ __be16 length;
+ /* type dependent data follows */
+} __packed;
+
+struct fft_sample_ht20 {
+ struct fft_sample_tlv tlv;
+
+ u8 max_exp;
+
+ __be16 freq;
+ s8 rssi;
+ s8 noise;
+
+ __be16 max_magnitude;
+ u8 max_index;
+ u8 bitmap_weight;
+
+ __be64 tsf;
+
+ u8 data[SPECTRAL_HT20_NUM_BINS];
+} __packed;
+
+struct fft_sample_ht20_40 {
+ struct fft_sample_tlv tlv;
+
+ u8 channel_type;
+ __be16 freq;
+
+ s8 lower_rssi;
+ s8 upper_rssi;
+
+ __be64 tsf;
+
+ s8 lower_noise;
+ s8 upper_noise;
+
+ __be16 lower_max_magnitude;
+ __be16 upper_max_magnitude;
+
+ u8 lower_max_index;
+ u8 upper_max_index;
+
+ u8 lower_bitmap_weight;
+ u8 upper_bitmap_weight;
+
+ u8 max_exp;
+
+ u8 data[SPECTRAL_HT20_40_NUM_BINS];
+} __packed;
+
+void ath9k_spectral_init_debug(struct ath_softc *sc);
+void ath9k_spectral_deinit_debug(struct ath_softc *sc);
+
+void ath9k_spectral_scan_trigger(struct ieee80211_hw *hw);
+int ath9k_spectral_scan_config(struct ieee80211_hw *hw,
+          enum spectral_mode spectral_mode);
+
+#ifdef CONFIG_ATH9K_DEBUGFS
+int ath_process_fft(struct ath_softc *sc, struct ieee80211_hdr *hdr,
+      struct ath_rx_status *rs, u64 tsf);
+#else
+static inline int ath_process_fft(struct ath_softc *sc,
+      struct ieee80211_hdr *hdr,
+      struct ath_rx_status *rs, u64 tsf)
+{
+ return 0;
+}
+#endif /* CONFIG_ATH9K_DEBUGFS */
+
+#endif /* SPECTRAL_H */
diff --git a/drivers/net/wireless/ath/ath9k/tx99.c b/drivers/net/wireless/ath/ath9k/tx99.c
new file mode 100644
index 0000000..a65cfb9
--- /dev/null
+++ b/drivers/net/wireless/ath/ath9k/tx99.c
@@ -0,0 +1,272 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include "ath9k.h"
+
+static void ath9k_tx99_stop(struct ath_softc *sc)
+{
+ struct ath_hw *ah = sc->sc_ah;
+ struct ath_common *common = ath9k_hw_common(ah);
+
+ ath_drain_all_txq(sc);
+ ath_startrecv(sc);
+
+ ath9k_hw_set_interrupts(ah);
+ ath9k_hw_enable_interrupts(ah);
+
+ ieee80211_wake_queues(sc->hw);
+
+ kfree_skb(sc->tx99_skb);
+ sc->tx99_skb = NULL;
+ sc->tx99_state = false;
+
+ ath9k_hw_tx99_stop(sc->sc_ah);
+ ath_dbg(common, XMIT, "TX99 stopped\n");
+}
+
+static struct sk_buff *ath9k_build_tx99_skb(struct ath_softc *sc)
+{
+ static u8 PN9Data[] = {0xff, 0x87, 0xb8, 0x59, 0xb7, 0xa1, 0xcc, 0x24,
+          0x57, 0x5e, 0x4b, 0x9c, 0x0e, 0xe9, 0xea, 0x50,
+          0x2a, 0xbe, 0xb4, 0x1b, 0xb6, 0xb0, 0x5d, 0xf1,
+          0xe6, 0x9a, 0xe3, 0x45, 0xfd, 0x2c, 0x53, 0x18,
+          0x0c, 0xca, 0xc9, 0xfb, 0x49, 0x37, 0xe5, 0xa8,
+          0x51, 0x3b, 0x2f, 0x61, 0xaa, 0x72, 0x18, 0x84,
+          0x02, 0x23, 0x23, 0xab, 0x63, 0x89, 0x51, 0xb3,
+          0xe7, 0x8b, 0x72, 0x90, 0x4c, 0xe8, 0xfb, 0xc0};
+ u32 len = 1200;
+ struct ieee80211_tx_rate *rate;
+ struct ieee80211_hw *hw = sc->hw;
+ struct ath_hw *ah = sc->sc_ah;
+ struct ieee80211_hdr *hdr;
+ struct ieee80211_tx_info *tx_info;
+ struct sk_buff *skb;
+
+ skb = alloc_skb(len, GFP_KERNEL);
+ if (!skb)
+  return NULL;
+
+ skb_put(skb, len);
+
+ memset(skb->data, 0, len);
+
+ hdr = (struct ieee80211_hdr *)skb->data;
+ hdr->frame_control = cpu_to_le16(IEEE80211_FTYPE_DATA);
+ hdr->duration_id = 0;
+
+ memcpy(hdr->addr1, hw->wiphy->perm_addr, ETH_ALEN);
+ memcpy(hdr->addr2, hw->wiphy->perm_addr, ETH_ALEN);
+ memcpy(hdr->addr3, hw->wiphy->perm_addr, ETH_ALEN);
+
+ hdr->seq_ctrl |= cpu_to_le16(sc->tx.seq_no);
+
+ tx_info = IEEE80211_SKB_CB(skb);
+ memset(tx_info, 0, sizeof(*tx_info));
+ rate = &tx_info->control.rates[0];
+ tx_info->band = hw->conf.chandef.chan->band;
+ tx_info->flags = IEEE80211_TX_CTL_NO_ACK;
+ tx_info->control.vif = sc->tx99_vif;
+ rate->count = 1;
+ if (ah->curchan && IS_CHAN_HT(ah->curchan)) {
+  rate->flags |= IEEE80211_TX_RC_MCS;
+  if (IS_CHAN_HT40(ah->curchan))
+   rate->flags |= IEEE80211_TX_RC_40_MHZ_WIDTH;
+ }
+
+ memcpy(skb->data + sizeof(*hdr), PN9Data, sizeof(PN9Data));
+
+ return skb;
+}
+
+static void ath9k_tx99_deinit(struct ath_softc *sc)
+{
+ ath_reset(sc);
+
+ ath9k_ps_wakeup(sc);
+ ath9k_tx99_stop(sc);
+ ath9k_ps_restore(sc);
+}
+
+static int ath9k_tx99_init(struct ath_softc *sc)
+{
+ struct ieee80211_hw *hw = sc->hw;
+ struct ath_hw *ah = sc->sc_ah;
+ struct ath_common *common = ath9k_hw_common(ah);
+ struct ath_tx_control txctl;
+ int r;
+
+ if (test_bit(ATH_OP_INVALID, &common->op_flags)) {
+  ath_err(common,
+   "driver is in invalid state unable to use TX99");
+  return -EINVAL;
+ }
+
+ sc->tx99_skb = ath9k_build_tx99_skb(sc);
+ if (!sc->tx99_skb)
+  return -ENOMEM;
+
+ memset(&txctl, 0, sizeof(txctl));
+ txctl.txq = sc->tx.txq_map[IEEE80211_AC_VO];
+
+ ath_reset(sc);
+
+ ath9k_ps_wakeup(sc);
+
+ ath9k_hw_disable_interrupts(ah);
+ atomic_set(&ah->intr_ref_cnt, -1);
+ ath_drain_all_txq(sc);
+ ath_stoprecv(sc);
+
+ sc->tx99_state = true;
+
+ ieee80211_stop_queues(hw);
+
+ if (sc->tx99_power == MAX_RATE_POWER + 1)
+  sc->tx99_power = MAX_RATE_POWER;
+
+ ath9k_hw_tx99_set_txpower(ah, sc->tx99_power);
+ r = ath9k_tx99_send(sc, sc->tx99_skb, &txctl);
+ if (r) {
+  ath_dbg(common, XMIT, "Failed to xmit TX99 skb\n");
+  return r;
+ }
+
+ ath_dbg(common, XMIT, "TX99 xmit started using %d ( %ddBm)\n",
+  sc->tx99_power,
+  sc->tx99_power / 2);
+
+ /* We leave the harware awake as it will be chugging on */
+
+ return 0;
+}
+
+static ssize_t read_file_tx99(struct file *file, char __user *user_buf,
+         size_t count, loff_t *ppos)
+{
+ struct ath_softc *sc = file->private_data;
+ char buf[3];
+ unsigned int len;
+
+ len = sprintf(buf, "%d\n", sc->tx99_state);
+ return simple_read_from_buffer(user_buf, count, ppos, buf, len);
+}
+
+static ssize_t write_file_tx99(struct file *file, const char __user *user_buf,
+          size_t count, loff_t *ppos)
+{
+ struct ath_softc *sc = file->private_data;
+ struct ath_common *common = ath9k_hw_common(sc->sc_ah);
+ char buf[32];
+ bool start;
+ ssize_t len;
+ int r;
+
+ if (sc->nvifs > 1)
+  return -EOPNOTSUPP;
+
+ len = min(count, sizeof(buf) - 1);
+ if (copy_from_user(buf, user_buf, len))
+  return -EFAULT;
+
+ if (strtobool(buf, &start))
+  return -EINVAL;
+
+ if (start == sc->tx99_state) {
+  if (!start)
+   return count;
+  ath_dbg(common, XMIT, "Resetting TX99\n");
+  ath9k_tx99_deinit(sc);
+ }
+
+ if (!start) {
+  ath9k_tx99_deinit(sc);
+  return count;
+ }
+
+ r = ath9k_tx99_init(sc);
+ if (r)
+  return r;
+
+ return count;
+}
+
+static const struct file_operations fops_tx99 = {
+ .read = read_file_tx99,
+ .write = write_file_tx99,
+ .open = simple_open,
+ .owner = THIS_MODULE,
+ .llseek = default_llseek,
+};
+
+static ssize_t read_file_tx99_power(struct file *file,
+        char __user *user_buf,
+        size_t count, loff_t *ppos)
+{
+ struct ath_softc *sc = file->private_data;
+ char buf[32];
+ unsigned int len;
+
+ len = sprintf(buf, "%d (%d dBm)\n",
+        sc->tx99_power,
+        sc->tx99_power / 2);
+
+ return simple_read_from_buffer(user_buf, count, ppos, buf, len);
+}
+
+static ssize_t write_file_tx99_power(struct file *file,
+         const char __user *user_buf,
+         size_t count, loff_t *ppos)
+{
+ struct ath_softc *sc = file->private_data;
+ int r;
+ u8 tx_power;
+
+ r = kstrtou8_from_user(user_buf, count, 0, &tx_power);
+ if (r)
+  return r;
+
+ if (tx_power > MAX_RATE_POWER)
+  return -EINVAL;
+
+ sc->tx99_power = tx_power;
+
+ ath9k_ps_wakeup(sc);
+ ath9k_hw_tx99_set_txpower(sc->sc_ah, sc->tx99_power);
+ ath9k_ps_restore(sc);
+
+ return count;
+}
+
+static const struct file_operations fops_tx99_power = {
+ .read = read_file_tx99_power,
+ .write = write_file_tx99_power,
+ .open = simple_open,
+ .owner = THIS_MODULE,
+ .llseek = default_llseek,
+};
+
+void ath9k_tx99_init_debug(struct ath_softc *sc)
+{
+ if (!AR_SREV_9300_20_OR_LATER(sc->sc_ah))
+  return;
+
+ debugfs_create_file("tx99", S_IRUSR | S_IWUSR,
+       sc->debug.debugfs_phy, sc,
+       &fops_tx99);
+ debugfs_create_file("tx99_power", S_IRUSR | S_IWUSR,
+       sc->debug.debugfs_phy, sc,
+       &fops_tx99_power);
+}
diff --git a/drivers/net/wireless/ath/ath9k/wmi.h b/drivers/net/wireless/ath/ath9k/wmi.h
index fde6da6..0db37f2 100644
--- a/drivers/net/wireless/ath/ath9k/wmi.h
+++ b/drivers/net/wireless/ath/ath9k/wmi.h
@@ -39,7 +39,7 @@ struct wmi_fw_version {
 struct wmi_event_swba {
  __be64 tsf;
  u8 beacon_pending;
-};
+} __packed;
 
 /*
  * 64 - HTC header - WMI header - 1 / txstatus
diff --git a/drivers/net/wireless/ath/ath9k/wow.c b/drivers/net/wireless/ath/ath9k/wow.c
index 9f85630..2879887 100644
--- a/drivers/net/wireless/ath/ath9k/wow.c
+++ b/drivers/net/wireless/ath/ath9k/wow.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012 Qualcomm Atheros, Inc.
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
  *
  * Permission to use, copy, modify, and/or distribute this software for any
  * purpose with or without fee is hereby granted, provided that the above
@@ -14,519 +14,347 @@
  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  */
 
-#include <linux/export.h>
 #include "ath9k.h"
-#include "reg.h"
-#include "hw-ops.h"
 
-const char *ath9k_hw_wow_event_to_string(u32 wow_event)
-{
- if (wow_event & AH_WOW_MAGIC_PATTERN_EN)
-  return "Magic pattern";
- if (wow_event & AH_WOW_USER_PATTERN_EN)
-  return "User pattern";
- if (wow_event & AH_WOW_LINK_CHANGE)
-  return "Link change";
- if (wow_event & AH_WOW_BEACON_MISS)
-  return "Beacon miss";
-
- return  "unknown reason";
-}
-EXPORT_SYMBOL(ath9k_hw_wow_event_to_string);
+static const struct wiphy_wowlan_support ath9k_wowlan_support = {
+ .flags = WIPHY_WOWLAN_MAGIC_PKT | WIPHY_WOWLAN_DISCONNECT,
+ .n_patterns = MAX_NUM_USER_PATTERN,
+ .pattern_min_len = 1,
+ .pattern_max_len = MAX_PATTERN_SIZE,
+};
 
-static void ath9k_hw_config_serdes_wow_sleep(struct ath_hw *ah)
+static void ath9k_wow_map_triggers(struct ath_softc *sc,
+       struct cfg80211_wowlan *wowlan,
+       u32 *wow_triggers)
 {
- int i;
+ if (wowlan->disconnect)
+  *wow_triggers |= AH_WOW_LINK_CHANGE |
+     AH_WOW_BEACON_MISS;
+ if (wowlan->magic_pkt)
+  *wow_triggers |= AH_WOW_MAGIC_PATTERN_EN;
 
- for (i = 0; i < ah->iniPcieSerdesWow.ia_rows; i++)
-  REG_WRITE(ah, INI_RA(&ah->iniPcieSerdesWow, i, 0),
-     INI_RA(&ah->iniPcieSerdesWow, i, 1));
-
- usleep_range(1000, 1500);
-}
-
-static void ath9k_hw_set_powermode_wow_sleep(struct ath_hw *ah)
-{
- struct ath_common *common = ath9k_hw_common(ah);
+ if (wowlan->n_patterns)
+  *wow_triggers |= AH_WOW_USER_PATTERN_EN;
 
- REG_SET_BIT(ah, AR_STA_ID1, AR_STA_ID1_PWR_SAV);
-
- /* set rx disable bit */
- REG_WRITE(ah, AR_CR, AR_CR_RXD);
-
- if (!ath9k_hw_wait(ah, AR_CR, AR_CR_RXE, 0, AH_WAIT_TIMEOUT)) {
-  ath_err(common, "Failed to stop Rx DMA in 10ms AR_CR=0x%08x AR_DIAG_SW=0x%08x\n",
-   REG_READ(ah, AR_CR), REG_READ(ah, AR_DIAG_SW));
-  return;
- } else {
-  if (!AR_SREV_9300_20_OR_LATER(ah))
-   REG_WRITE(ah, AR_RXDP, 0x0);
- }
-
- /* AR9280 WoW has sleep issue, do not set it to sleep */
- if (AR_SREV_9280_20(ah))
-  return;
+ sc->wow_enabled = *wow_triggers;
 
- REG_WRITE(ah, AR_RTC_FORCE_WAKE, AR_RTC_FORCE_WAKE_ON_INT);
 }
 
-static void ath9k_wow_create_keep_alive_pattern(struct ath_hw *ah)
+static void ath9k_wow_add_disassoc_deauth_pattern(struct ath_softc *sc)
 {
+ struct ath_hw *ah = sc->sc_ah;
  struct ath_common *common = ath9k_hw_common(ah);
- u8 sta_mac_addr[ETH_ALEN], ap_mac_addr[ETH_ALEN];
- u32 ctl[13] = {0};
- u32 data_word[KAL_NUM_DATA_WORDS];
- u8 i;
- u32 wow_ka_data_word0;
-
- memcpy(sta_mac_addr, common->macaddr, ETH_ALEN);
- memcpy(ap_mac_addr, common->curbssid, ETH_ALEN);
-
- /* set the transmit buffer */
- ctl[0] = (KAL_FRAME_LEN | (MAX_RATE_POWER << 16));
-
- if (!(AR_SREV_9300_20_OR_LATER(ah)))
-  ctl[0] += (KAL_ANTENNA_MODE << 25);
-
- ctl[1] = 0;
- ctl[3] = 0xb; /* OFDM_6M hardware value for this rate */
- ctl[4] = 0;
- ctl[7] = (ah->txchainmask) << 2;
-
- if (AR_SREV_9300_20_OR_LATER(ah))
-  ctl[2] = 0xf << 16; /* tx_tries 0 */
- else
-  ctl[2] = 0x7 << 16; /* tx_tries 0 */
-
-
- for (i = 0; i < KAL_NUM_DESC_WORDS; i++)
-  REG_WRITE(ah, (AR_WOW_KA_DESC_WORD2 + i * 4), ctl[i]);
-
- /* for AR9300 family 13 descriptor words */
- if (AR_SREV_9300_20_OR_LATER(ah))
-  REG_WRITE(ah, (AR_WOW_KA_DESC_WORD2 + i * 4), ctl[i]);
-
- data_word[0] = (KAL_FRAME_TYPE << 2) | (KAL_FRAME_SUB_TYPE << 4) |
-         (KAL_TO_DS << 8) | (KAL_DURATION_ID << 16);
- data_word[1] = (ap_mac_addr[3] << 24) | (ap_mac_addr[2] << 16) |
-         (ap_mac_addr[1] << 8) | (ap_mac_addr[0]);
- data_word[2] = (sta_mac_addr[1] << 24) | (sta_mac_addr[0] << 16) |
-         (ap_mac_addr[5] << 8) | (ap_mac_addr[4]);
- data_word[3] = (sta_mac_addr[5] << 24) | (sta_mac_addr[4] << 16) |
-         (sta_mac_addr[3] << 8) | (sta_mac_addr[2]);
- data_word[4] = (ap_mac_addr[3] << 24) | (ap_mac_addr[2] << 16) |
-         (ap_mac_addr[1] << 8) | (ap_mac_addr[0]);
- data_word[5] = (ap_mac_addr[5] << 8) | (ap_mac_addr[4]);
-
- if (AR_SREV_9462_20(ah)) {
-  /* AR9462 2.0 has an extra descriptor word (time based
-   * discard) compared to other chips */
-  REG_WRITE(ah, (AR_WOW_KA_DESC_WORD2 + (12 * 4)), 0);
-  wow_ka_data_word0 = AR_WOW_TXBUF(13);
- } else {
-  wow_ka_data_word0 = AR_WOW_TXBUF(12);
- }
-
- for (i = 0; i < KAL_NUM_DATA_WORDS; i++)
-  REG_WRITE(ah, (wow_ka_data_word0 + i*4), data_word[i]);
-
-}
+ int pattern_count = 0;
+ int i, byte_cnt;
+ u8 dis_deauth_pattern[MAX_PATTERN_SIZE];
+ u8 dis_deauth_mask[MAX_PATTERN_SIZE];
 
-void ath9k_hw_wow_apply_pattern(struct ath_hw *ah, u8 *user_pattern,
-    u8 *user_mask, int pattern_count,
-    int pattern_len)
-{
- int i;
- u32 pattern_val, mask_val;
- u32 set, clr;
-
- /* FIXME: should check count by querying the hardware capability */
- if (pattern_count >= MAX_NUM_PATTERN)
-  return;
+ memset(dis_deauth_pattern, 0, MAX_PATTERN_SIZE);
+ memset(dis_deauth_mask, 0, MAX_PATTERN_SIZE);
 
- REG_SET_BIT(ah, AR_WOW_PATTERN, BIT(pattern_count));
-
- /* set the registers for pattern */
- for (i = 0; i < MAX_PATTERN_SIZE; i += 4) {
-  memcpy(&pattern_val, user_pattern, 4);
-  REG_WRITE(ah, (AR_WOW_TB_PATTERN(pattern_count) + i),
-     pattern_val);
-  user_pattern += 4;
- }
-
- /* set the registers for mask */
- for (i = 0; i < MAX_PATTERN_MASK_SIZE; i += 4) {
-  memcpy(&mask_val, user_mask, 4);
-  REG_WRITE(ah, (AR_WOW_TB_MASK(pattern_count) + i), mask_val);
-  user_mask += 4;
- }
-
- /* set the pattern length to be matched
+ /*
+  * Create Dissassociate / Deauthenticate packet filter
   *
-  * AR_WOW_LENGTH1_REG1
-  * bit 31:24 pattern 0 length
-  * bit 23:16 pattern 1 length
-  * bit 15:8 pattern 2 length
-  * bit 7:0 pattern 3 length
+  *     2 bytes        2 byte    6 bytes   6 bytes  6 bytes
+  *  +--------------+----------+---------+--------+--------+----
+  *  + Frame Control+ Duration +   DA    +  SA    +  BSSID +
+  *  +--------------+----------+---------+--------+--------+----
   *
-  * AR_WOW_LENGTH1_REG2
-  * bit 31:24 pattern 4 length
-  * bit 23:16 pattern 5 length
-  * bit 15:8 pattern 6 length
-  * bit 7:0 pattern 7 length
+  * The above is the management frame format for disassociate/
+  * deauthenticate pattern, from this we need to match the first byte
+  * of 'Frame Control' and DA, SA, and BSSID fields
+  * (skipping 2nd byte of FC and Duration feild.
   *
-  * the below logic writes out the new
-  * pattern length for the corresponding
-  * pattern_count, while masking out the
-  * other fields
+  * Disassociate pattern
+  * --------------------
+  * Frame control = 00 00 1010
+  * DA, SA, BSSID = x:x:x:x:x:x
+  * Pattern will be A0000000 | x:x:x:x:x:x | x:x:x:x:x:x
+  *       | x:x:x:x:x:x  -- 22 bytes
+  *
+  * Deauthenticate pattern
+  * ----------------------
+  * Frame control = 00 00 1100
+  * DA, SA, BSSID = x:x:x:x:x:x
+  * Pattern will be C0000000 | x:x:x:x:x:x | x:x:x:x:x:x
+  *       | x:x:x:x:x:x  -- 22 bytes
   */
 
- ah->wow_event_mask |= BIT(pattern_count + AR_WOW_PAT_FOUND_SHIFT);
+ /* Create Disassociate Pattern first */
 
- if (!AR_SREV_9285_12_OR_LATER(ah))
-  return;
+ byte_cnt = 0;
 
- if (pattern_count < 4) {
-  /* Pattern 0-3 uses AR_WOW_LENGTH1 register */
-  set = (pattern_len & AR_WOW_LENGTH_MAX) <<
-         AR_WOW_LEN1_SHIFT(pattern_count);
-  clr = AR_WOW_LENGTH1_MASK(pattern_count);
-  REG_RMW(ah, AR_WOW_LENGTH1, set, clr);
- } else {
-  /* Pattern 4-7 uses AR_WOW_LENGTH2 register */
-  set = (pattern_len & AR_WOW_LENGTH_MAX) <<
-         AR_WOW_LEN2_SHIFT(pattern_count);
-  clr = AR_WOW_LENGTH2_MASK(pattern_count);
-  REG_RMW(ah, AR_WOW_LENGTH2, set, clr);
- }
+ /* Fill out the mask with all FF's */
 
-}
-EXPORT_SYMBOL(ath9k_hw_wow_apply_pattern);
+ for (i = 0; i < MAX_PATTERN_MASK_SIZE; i++)
+  dis_deauth_mask[i] = 0xff;
 
-u32 ath9k_hw_wow_wakeup(struct ath_hw *ah)
-{
- u32 wow_status = 0;
- u32 val = 0, rval;
- /*
-  * read the WoW status register to know
-  * the wakeup reason
-  */
- rval = REG_READ(ah, AR_WOW_PATTERN);
- val = AR_WOW_STATUS(rval);
+ /* copy the first byte of frame control field */
+ dis_deauth_pattern[byte_cnt] = 0xa0;
+ byte_cnt++;
+
+ /* skip 2nd byte of frame control and Duration field */
+ byte_cnt += 3;
 
  /*
-  * mask only the WoW events that we have enabled. Sometimes
-  * we have spurious WoW events from the AR_WOW_PATTERN
-  * register. This mask will clean it up.
+  * need not match the destination mac address, it can be a broadcast
+  * mac address or an unicast to this station
   */
+ byte_cnt += 6;
 
- val &= ah->wow_event_mask;
+ /* copy the source mac address */
+ memcpy((dis_deauth_pattern + byte_cnt), common->curbssid, ETH_ALEN);
 
- if (val) {
+ byte_cnt += 6;
 
-  if (val & AR_WOW_MAGIC_PAT_FOUND)
-   wow_status |= AH_WOW_MAGIC_PATTERN_EN;
+ /* copy the bssid, its same as the source mac address */
 
-  if (AR_WOW_PATTERN_FOUND(val))
-   wow_status |= AH_WOW_USER_PATTERN_EN;
+ memcpy((dis_deauth_pattern + byte_cnt), common->curbssid, ETH_ALEN);
 
-  if (val & AR_WOW_KEEP_ALIVE_FAIL)
-   wow_status |= AH_WOW_LINK_CHANGE;
+ /* Create Disassociate pattern mask */
 
-  if (val & AR_WOW_BEACON_FAIL)
-   wow_status |= AH_WOW_BEACON_MISS;
+ dis_deauth_mask[0] = 0xfe;
+ dis_deauth_mask[1] = 0x03;
+ dis_deauth_mask[2] = 0xc0;
 
- }
+ ath_dbg(common, WOW, "Adding disassoc/deauth patterns for WoW\n");
+
+ ath9k_hw_wow_apply_pattern(ah, dis_deauth_pattern, dis_deauth_mask,
+       pattern_count, byte_cnt);
 
+ pattern_count++;
  /*
-  * set and clear WOW_PME_CLEAR registers for the chip to
-  * generate next wow signal.
-  * disable D3 before accessing other registers ?
+  * for de-authenticate pattern, only the first byte of the frame
+  * control field gets changed from 0xA0 to 0xC0
   */
+ dis_deauth_pattern[0] = 0xC0;
 
- /* do we need to check the bit value 0x01000000 (7-10) ?? */
- REG_RMW(ah, AR_PCIE_PM_CTRL, AR_PMCTRL_WOW_PME_CLR,
-  AR_PMCTRL_PWR_STATE_D1D3);
+ ath9k_hw_wow_apply_pattern(ah, dis_deauth_pattern, dis_deauth_mask,
+       pattern_count, byte_cnt);
 
- /*
-  * clear all events
-  */
- REG_WRITE(ah, AR_WOW_PATTERN,
-    AR_WOW_CLEAR_EVENTS(REG_READ(ah, AR_WOW_PATTERN)));
+}
+
+static void ath9k_wow_add_pattern(struct ath_softc *sc,
+      struct cfg80211_wowlan *wowlan)
+{
+ struct ath_hw *ah = sc->sc_ah;
+ struct ath9k_wow_pattern *wow_pattern = NULL;
+ struct cfg80211_pkt_pattern *patterns = wowlan->patterns;
+ int mask_len;
+ s8 i = 0;
+
+ if (!wowlan->n_patterns)
+  return;
 
  /*
-  * tie reset register for AR9002 family of chipsets
-  * NB: not tieing it back might have some repurcussions.
+  * Add the new user configured patterns
   */
+ for (i = 0; i < wowlan->n_patterns; i++) {
 
- if (!AR_SREV_9300_20_OR_LATER(ah)) {
-  REG_SET_BIT(ah, AR_WA, AR_WA_UNTIE_RESET_EN |
-       AR_WA_POR_SHORT | AR_WA_RESET_EN);
- }
+  wow_pattern = kzalloc(sizeof(*wow_pattern), GFP_KERNEL);
 
+  if (!wow_pattern)
+   return;
 
- /*
-  * restore the beacon threshold to init value
-  */
- REG_WRITE(ah, AR_RSSI_THR, INIT_RSSI_THR);
+  /*
+   * TODO: convert the generic user space pattern to
+   * appropriate chip specific/802.11 pattern.
+   */
 
- /*
-  * Restore the way the PCI-E reset, Power-On-Reset, external
-  * PCIE_POR_SHORT pins are tied to its original value.
-  * Previously just before WoW sleep, we untie the PCI-E
-  * reset to our Chip's Power On Reset so that any PCI-E
-  * reset from the bus will not reset our chip
-  */
+  mask_len = DIV_ROUND_UP(wowlan->patterns[i].pattern_len, 8);
+  memset(wow_pattern->pattern_bytes, 0, MAX_PATTERN_SIZE);
+  memset(wow_pattern->mask_bytes, 0, MAX_PATTERN_SIZE);
+  memcpy(wow_pattern->pattern_bytes, patterns[i].pattern,
+         patterns[i].pattern_len);
+  memcpy(wow_pattern->mask_bytes, patterns[i].mask, mask_len);
+  wow_pattern->pattern_len = patterns[i].pattern_len;
 
- if (AR_SREV_9280_20_OR_LATER(ah) && ah->is_pciexpress)
-  ath9k_hw_configpcipowersave(ah, false);
+  /*
+   * just need to take care of deauth and disssoc pattern,
+   * make sure we don't overwrite them.
+   */
 
- ah->wow_event_mask = 0;
+  ath9k_hw_wow_apply_pattern(ah, wow_pattern->pattern_bytes,
+        wow_pattern->mask_bytes,
+        i + 2,
+        wow_pattern->pattern_len);
+  kfree(wow_pattern);
+
+ }
 
- return wow_status;
 }
-EXPORT_SYMBOL(ath9k_hw_wow_wakeup);
 
-void ath9k_hw_wow_enable(struct ath_hw *ah, u32 pattern_enable)
+int ath9k_suspend(struct ieee80211_hw *hw,
+    struct cfg80211_wowlan *wowlan)
 {
- u32 wow_event_mask;
- u32 set, clr;
+ struct ath_softc *sc = hw->priv;
+ struct ath_hw *ah = sc->sc_ah;
+ struct ath_common *common = ath9k_hw_common(ah);
+ u32 wow_triggers_enabled = 0;
+ int ret = 0;
 
- /*
-  * wow_event_mask is a mask to the AR_WOW_PATTERN register to
-  * indicate which WoW events we have enabled. The WoW events
-  * are from the 'pattern_enable' in this function and
-  * 'pattern_count' of ath9k_hw_wow_apply_pattern()
-  */
+ mutex_lock(&sc->mutex);
 
- wow_event_mask = ah->wow_event_mask;
+ ath_cancel_work(sc);
+ ath_stop_ani(sc);
 
- /*
-  * Untie Power-on-Reset from the PCI-E-Reset. When we are in
-  * WOW sleep, we do want the Reset from the PCI-E to disturb
-  * our hw state
-  */
-
- if (ah->is_pciexpress) {
-
-  /*
-   * we need to untie the internal POR (power-on-reset)
-   * to the external PCI-E reset. We also need to tie
-   * the PCI-E Phy reset to the PCI-E reset.
-   */
+ if (test_bit(ATH_OP_INVALID, &common->op_flags)) {
+  ath_dbg(common, ANY, "Device not present\n");
+  ret = -EINVAL;
+  goto fail_wow;
+ }
 
-  if (AR_SREV_9300_20_OR_LATER(ah)) {
-   set = AR_WA_RESET_EN | AR_WA_POR_SHORT;
-   clr = AR_WA_UNTIE_RESET_EN | AR_WA_D3_L1_DISABLE;
-   REG_RMW(ah, AR_WA, set, clr);
-  } else {
-   if (AR_SREV_9285(ah) || AR_SREV_9287(ah))
-    set = AR9285_WA_DEFAULT;
-   else
-    set = AR9280_WA_DEFAULT;
-
-   /*
-    * In AR9280 and AR9285, bit 14 in WA register
-    * (disable L1) should only be set when device
-    * enters D3 state and be cleared when device
-    * comes back to D0
-    */
-
-   if (ah->config.pcie_waen & AR_WA_D3_L1_DISABLE)
-    set |= AR_WA_D3_L1_DISABLE;
-
-   clr = AR_WA_UNTIE_RESET_EN;
-   set |= AR_WA_RESET_EN | AR_WA_POR_SHORT;
-   REG_RMW(ah, AR_WA, set, clr);
-
-   /*
-    * for WoW sleep, we reprogram the SerDes so that the
-    * PLL and CLK REQ are both enabled. This uses more
-    * power but otherwise WoW sleep is unstable and the
-    * chip may disappear.
-    */
-
-   if (AR_SREV_9285_12_OR_LATER(ah))
-    ath9k_hw_config_serdes_wow_sleep(ah);
-
-  }
+ if (WARN_ON(!wowlan)) {
+  ath_dbg(common, WOW, "None of the WoW triggers enabled\n");
+  ret = -EINVAL;
+  goto fail_wow;
  }
 
- /*
-  * set the power states appropriately and enable PME
-  */
- set = AR_PMCTRL_HOST_PME_EN | AR_PMCTRL_PWR_PM_CTRL_ENA |
-       AR_PMCTRL_AUX_PWR_DET | AR_PMCTRL_WOW_PME_CLR;
+ if (!device_can_wakeup(sc->dev)) {
+  ath_dbg(common, WOW, "device_can_wakeup failed, WoW is not enabled\n");
+  ret = 1;
+  goto fail_wow;
+ }
 
  /*
-  * set and clear WOW_PME_CLEAR registers for the chip
-  * to generate next wow signal.
+  * none of the sta vifs are associated
+  * and we are not currently handling multivif
+  * cases, for instance we have to seperately
+  * configure 'keep alive frame' for each
+  * STA.
   */
- REG_SET_BIT(ah, AR_PCIE_PM_CTRL, set);
- clr = AR_PMCTRL_WOW_PME_CLR;
- REG_CLR_BIT(ah, AR_PCIE_PM_CTRL, clr);
 
- /*
-  * Setup for:
-  * - beacon misses
-  * - magic pattern
-  * - keep alive timeout
-  * - pattern matching
-  */
+ if (!test_bit(ATH_OP_PRIM_STA_VIF, &common->op_flags)) {
+  ath_dbg(common, WOW, "None of the STA vifs are associated\n");
+  ret = 1;
+  goto fail_wow;
+ }
 
- /*
-  * Program default values for pattern backoff, aifs/slot/KAL count,
-  * beacon miss timeout, KAL timeout, etc.
-  */
+ if (sc->nvifs > 1) {
+  ath_dbg(common, WOW, "WoW for multivif is not yet supported\n");
+  ret = 1;
+  goto fail_wow;
+ }
 
- set = AR_WOW_BACK_OFF_SHIFT(AR_WOW_PAT_BACKOFF);
- REG_SET_BIT(ah, AR_WOW_PATTERN, set);
+ ath9k_wow_map_triggers(sc, wowlan, &wow_triggers_enabled);
 
- set = AR_WOW_AIFS_CNT(AR_WOW_CNT_AIFS_CNT) |
-       AR_WOW_SLOT_CNT(AR_WOW_CNT_SLOT_CNT) |
-       AR_WOW_KEEP_ALIVE_CNT(AR_WOW_CNT_KA_CNT);
- REG_SET_BIT(ah, AR_WOW_COUNT, set);
+ ath_dbg(common, WOW, "WoW triggers enabled 0x%x\n",
+  wow_triggers_enabled);
 
- if (pattern_enable & AH_WOW_BEACON_MISS)
-  set = AR_WOW_BEACON_TIMO;
- /* We are not using beacon miss, program a large value */
- else
-  set = AR_WOW_BEACON_TIMO_MAX;
+ ath9k_ps_wakeup(sc);
 
- REG_WRITE(ah, AR_WOW_BCN_TIMO, set);
+ ath9k_stop_btcoex(sc);
 
  /*
-  * Keep alive timo in ms except AR9280
+  * Enable wake up on recieving disassoc/deauth
+  * frame by default.
   */
- if (!pattern_enable || AR_SREV_9280(ah))
-  set = AR_WOW_KEEP_ALIVE_NEVER;
- else
-  set = KAL_TIMEOUT * 32;
+ ath9k_wow_add_disassoc_deauth_pattern(sc);
 
- REG_WRITE(ah, AR_WOW_KEEP_ALIVE_TIMO, set);
+ if (wow_triggers_enabled & AH_WOW_USER_PATTERN_EN)
+  ath9k_wow_add_pattern(sc, wowlan);
 
+ spin_lock_bh(&sc->sc_pcu_lock);
  /*
-  * Keep alive delay in us. based on 'power on clock',
-  * therefore in usec
+  * To avoid false wake, we enable beacon miss interrupt only
+  * when we go to sleep. We save the current interrupt mask
+  * so we can restore it after the system wakes up
   */
- set = KAL_DELAY * 1000;
- REG_WRITE(ah, AR_WOW_KEEP_ALIVE_DELAY, set);
+ sc->wow_intr_before_sleep = ah->imask;
+ ah->imask &= ~ATH9K_INT_GLOBAL;
+ ath9k_hw_disable_interrupts(ah);
+ ah->imask = ATH9K_INT_BMISS | ATH9K_INT_GLOBAL;
+ ath9k_hw_set_interrupts(ah);
+ ath9k_hw_enable_interrupts(ah);
 
- /*
-  * Create keep alive pattern to respond to beacons
-  */
- ath9k_wow_create_keep_alive_pattern(ah);
+ spin_unlock_bh(&sc->sc_pcu_lock);
 
  /*
-  * Configure MAC WoW Registers
+  * we can now sync irq and kill any running tasklets, since we already
+  * disabled interrupts and not holding a spin lock
   */
+ synchronize_irq(sc->irq);
+ tasklet_kill(&sc->intr_tq);
 
- set = 0;
- /* Send keep alive timeouts anyway */
- clr = AR_WOW_KEEP_ALIVE_AUTO_DIS;
+ ath9k_hw_wow_enable(ah, wow_triggers_enabled);
 
- if (pattern_enable & AH_WOW_LINK_CHANGE)
-  wow_event_mask |= AR_WOW_KEEP_ALIVE_FAIL;
- else
-  set = AR_WOW_KEEP_ALIVE_FAIL_DIS;
+ ath9k_ps_restore(sc);
+ ath_dbg(common, ANY, "WoW enabled in ath9k\n");
+ atomic_inc(&sc->wow_sleep_proc_intr);
 
- /*
-  * FIXME: For now disable keep alive frame
-  * failure. This seems to sometimes trigger
-  * unnecessary wake up with AR9485 chipsets.
-  */
- set = AR_WOW_KEEP_ALIVE_FAIL_DIS;
+fail_wow:
+ mutex_unlock(&sc->mutex);
+ return ret;
+}
 
- REG_RMW(ah, AR_WOW_KEEP_ALIVE, set, clr);
+int ath9k_resume(struct ieee80211_hw *hw)
+{
+ struct ath_softc *sc = hw->priv;
+ struct ath_hw *ah = sc->sc_ah;
+ struct ath_common *common = ath9k_hw_common(ah);
+ u32 wow_status;
 
+ mutex_lock(&sc->mutex);
 
- /*
-  * we are relying on a bmiss failure. ensure we have
-  * enough threshold to prevent false positives
-  */
- REG_RMW_FIELD(ah, AR_RSSI_THR, AR_RSSI_THR_BM_THR,
-        AR_WOW_BMISSTHRESHOLD);
+ ath9k_ps_wakeup(sc);
 
- set = 0;
- clr = 0;
+ spin_lock_bh(&sc->sc_pcu_lock);
 
- if (pattern_enable & AH_WOW_BEACON_MISS) {
-  set = AR_WOW_BEACON_FAIL_EN;
-  wow_event_mask |= AR_WOW_BEACON_FAIL;
- } else {
-  clr = AR_WOW_BEACON_FAIL_EN;
- }
+ ath9k_hw_disable_interrupts(ah);
+ ah->imask = sc->wow_intr_before_sleep;
+ ath9k_hw_set_interrupts(ah);
+ ath9k_hw_enable_interrupts(ah);
 
- REG_RMW(ah, AR_WOW_BCN_EN, set, clr);
+ spin_unlock_bh(&sc->sc_pcu_lock);
 
- set = 0;
- clr = 0;
- /*
-  * Enable the magic packet registers
-  */
- if (pattern_enable & AH_WOW_MAGIC_PATTERN_EN) {
-  set = AR_WOW_MAGIC_EN;
-  wow_event_mask |= AR_WOW_MAGIC_PAT_FOUND;
- } else {
-  clr = AR_WOW_MAGIC_EN;
+ wow_status = ath9k_hw_wow_wakeup(ah);
+
+ if (atomic_read(&sc->wow_got_bmiss_intr) == 0) {
+  /*
+   * some devices may not pick beacon miss
+   * as the reason they woke up so we add
+   * that here for that shortcoming.
+   */
+  wow_status |= AH_WOW_BEACON_MISS;
+  atomic_dec(&sc->wow_got_bmiss_intr);
+  ath_dbg(common, ANY, "Beacon miss interrupt picked up during WoW sleep\n");
  }
- set |= AR_WOW_MAC_INTR_EN;
- REG_RMW(ah, AR_WOW_PATTERN, set, clr);
 
- /*
-  * For AR9285 and later version of chipsets
-  * enable WoW pattern match for packets less
-  * than 256 bytes for all patterns
-  */
- if (AR_SREV_9285_12_OR_LATER(ah))
-  REG_WRITE(ah, AR_WOW_PATTERN_MATCH_LT_256B,
-     AR_WOW_PATTERN_SUPPORTED);
+ atomic_dec(&sc->wow_sleep_proc_intr);
 
- /*
-  * Set the power states appropriately and enable PME
-  */
- clr = 0;
- set = AR_PMCTRL_PWR_STATE_D1D3 | AR_PMCTRL_HOST_PME_EN |
-       AR_PMCTRL_PWR_PM_CTRL_ENA;
- /*
-  * This is needed for AR9300 chipsets to wake-up
-  * the host.
-  */
- if (AR_SREV_9300_20_OR_LATER(ah))
-  clr = AR_PCIE_PM_CTRL_ENA;
+ if (wow_status) {
+  ath_dbg(common, ANY, "Waking up due to WoW triggers %s with WoW status = %x\n",
+   ath9k_hw_wow_event_to_string(wow_status), wow_status);
+ }
 
- REG_RMW(ah, AR_PCIE_PM_CTRL, set, clr);
+ ath_restart_work(sc);
+ ath9k_start_btcoex(sc);
 
- if (AR_SREV_9462(ah) || AR_SREV_9565(ah)) {
-  /*
-   * this is needed to prevent the chip waking up
-   * the host within 3-4 seconds with certain
-   * platform/BIOS. The fix is to enable
-   * D1 & D3 to match original definition and
-   * also match the OTP value. Anyway this
-   * is more related to SW WOW.
-   */
-  clr = AR_PMCTRL_PWR_STATE_D1D3;
-  REG_CLR_BIT(ah, AR_PCIE_PM_CTRL, clr);
+ ath9k_ps_restore(sc);
+ mutex_unlock(&sc->mutex);
 
-  set = AR_PMCTRL_PWR_STATE_D1D3_REAL;
-  REG_SET_BIT(ah, AR_PCIE_PM_CTRL, set);
- }
+ return 0;
+}
 
+void ath9k_set_wakeup(struct ieee80211_hw *hw, bool enabled)
+{
+ struct ath_softc *sc = hw->priv;
 
+ mutex_lock(&sc->mutex);
+ device_init_wakeup(sc->dev, 1);
+ device_set_wakeup_enable(sc->dev, enabled);
+ mutex_unlock(&sc->mutex);
+}
 
- REG_CLR_BIT(ah, AR_STA_ID1, AR_STA_ID1_PRESERVE_SEQNUM);
+void ath9k_init_wow(struct ieee80211_hw *hw)
+{
+ struct ath_softc *sc = hw->priv;
 
- if (AR_SREV_9300_20_OR_LATER(ah)) {
-  /* to bring down WOW power low margin */
-  set = BIT(13);
-  REG_SET_BIT(ah, AR_PCIE_PHY_REG3, set);
-  /* HW WoW */
-  clr = BIT(5);
-  REG_CLR_BIT(ah, AR_PCU_MISC_MODE3, clr);
- }
+ if ((sc->sc_ah->caps.hw_caps & ATH9K_HW_WOW_DEVICE_CAPABLE) &&
+     (sc->driver_data & ATH9K_PCI_WOW) &&
+     device_can_wakeup(sc->dev))
+  hw->wiphy->wowlan = &ath9k_wowlan_support;
 
- ath9k_hw_set_powermode_wow_sleep(ah);
- ah->wow_event_mask = wow_event_mask;
+ atomic_set(&sc->wow_sleep_proc_intr, -1);
+ atomic_set(&sc->wow_got_bmiss_intr, -1);
 }
-EXPORT_SYMBOL(ath9k_hw_wow_enable);
diff --git a/drivers/net/wireless/ath/ath9k/xmit.c b/drivers/net/wireless/ath/ath9k/xmit.c
index aa16bfc..7c28cb5 100644
--- a/drivers/net/wireless/ath/ath9k/xmit.c
+++ b/drivers/net/wireless/ath/ath9k/xmit.c
@@ -47,8 +47,6 @@ static u16 bits_per_symbol[][2] = {
  {   260,  540 },     /*  7: 64-QAM 5/6 */
 };
 
-#define IS_HT_RATE(_rate)     ((_rate) & 0x80)
-
 static void ath_tx_send_normal(struct ath_softc *sc, struct ath_txq *txq,
           struct ath_atx_tid *tid, struct sk_buff *skb);
 static void ath_tx_complete(struct ath_softc *sc, struct sk_buff *skb,
@@ -109,9 +107,6 @@ static void ath_tx_queue_tid(struct ath_txq *txq, struct ath_atx_tid *tid)
 {
  struct ath_atx_ac *ac = tid->ac;
 
- if (tid->paused)
-  return;
-
  if (tid->sched)
   return;
 
@@ -135,6 +130,9 @@ static struct ath_frame_info *get_frame_info(struct sk_buff *skb)
 
 static void ath_send_bar(struct ath_atx_tid *tid, u16 seqno)
 {
+ if (!tid->an->sta)
+  return;
+
  ieee80211_send_bar(tid->an->vif, tid->an->sta->addr, tid->tidno,
       seqno << IEEE80211_SEQ_SEQ_SHIFT);
 }
@@ -146,6 +144,86 @@ static void ath_set_rates(struct ieee80211_vif *vif, struct ieee80211_sta *sta,
           ARRAY_SIZE(bf->rates));
 }
 
+static void ath_txq_skb_done(struct ath_softc *sc, struct ath_txq *txq,
+        struct sk_buff *skb)
+{
+ int q;
+
+ q = skb_get_queue_mapping(skb);
+ if (txq == sc->tx.uapsdq)
+  txq = sc->tx.txq_map[q];
+
+ if (txq != sc->tx.txq_map[q])
+  return;
+
+ if (WARN_ON(--txq->pending_frames < 0))
+  txq->pending_frames = 0;
+
+ if (txq->stopped &&
+     txq->pending_frames < sc->tx.txq_max_pending[q]) {
+  ieee80211_wake_queue(sc->hw, q);
+  txq->stopped = false;
+ }
+}
+
+static struct ath_atx_tid *
+ath_get_skb_tid(struct ath_softc *sc, struct ath_node *an, struct sk_buff *skb)
+{
+ u8 tidno = skb->priority & IEEE80211_QOS_CTL_TID_MASK;
+ return ATH_AN_2_TID(an, tidno);
+}
+
+static bool ath_tid_has_buffered(struct ath_atx_tid *tid)
+{
+ return !skb_queue_empty(&tid->buf_q) || !skb_queue_empty(&tid->retry_q);
+}
+
+static struct sk_buff *ath_tid_dequeue(struct ath_atx_tid *tid)
+{
+ struct sk_buff *skb;
+
+ skb = __skb_dequeue(&tid->retry_q);
+ if (!skb)
+  skb = __skb_dequeue(&tid->buf_q);
+
+ return skb;
+}
+
+/*
+ * ath_tx_tid_change_state:
+ * - clears a-mpdu flag of previous session
+ * - force sequence number allocation to fix next BlockAck Window
+ */
+static void
+ath_tx_tid_change_state(struct ath_softc *sc, struct ath_atx_tid *tid)
+{
+ struct ath_txq *txq = tid->ac->txq;
+ struct ieee80211_tx_info *tx_info;
+ struct sk_buff *skb, *tskb;
+ struct ath_buf *bf;
+ struct ath_frame_info *fi;
+
+ skb_queue_walk_safe(&tid->buf_q, skb, tskb) {
+  fi = get_frame_info(skb);
+  bf = fi->bf;
+
+  tx_info = IEEE80211_SKB_CB(skb);
+  tx_info->flags &= ~IEEE80211_TX_CTL_AMPDU;
+
+  if (bf)
+   continue;
+
+  bf = ath_tx_setup_buffer(sc, txq, tid, skb);
+  if (!bf) {
+   __skb_unlink(skb, &tid->buf_q);
+   ath_txq_skb_done(sc, txq, skb);
+   ieee80211_free_txskb(sc->hw, skb);
+   continue;
+  }
+ }
+
+}
+
 static void ath_tx_flush_tid(struct ath_softc *sc, struct ath_atx_tid *tid)
 {
  struct ath_txq *txq = tid->ac->txq;
@@ -160,27 +238,22 @@ static void ath_tx_flush_tid(struct ath_softc *sc, struct ath_atx_tid *tid)
 
  memset(&ts, 0, sizeof(ts));
 
- while ((skb = __skb_dequeue(&tid->buf_q))) {
+ while ((skb = __skb_dequeue(&tid->retry_q))) {
   fi = get_frame_info(skb);
   bf = fi->bf;
-
   if (!bf) {
-   bf = ath_tx_setup_buffer(sc, txq, tid, skb);
-   if (!bf) {
-    ieee80211_free_txskb(sc->hw, skb);
-    continue;
-   }
+   ath_txq_skb_done(sc, txq, skb);
+   ieee80211_free_txskb(sc->hw, skb);
+   continue;
   }
 
-  if (fi->retries) {
-   list_add_tail(&bf->list, &bf_head);
+  if (fi->baw_tracked) {
    ath_tx_update_baw(sc, tid, bf->bf_state.seqno);
-   ath_tx_complete_buf(sc, bf, txq, &bf_head, &ts, 0);
    sendbar = true;
-  } else {
-   ath_set_rates(tid->an->vif, tid->an->sta, bf);
-   ath_tx_send_normal(sc, txq, NULL, skb);
   }
+
+  list_add_tail(&bf->list, &bf_head);
+  ath_tx_complete_buf(sc, bf, txq, &bf_head, &ts, 0);
  }
 
  if (sendbar) {
@@ -209,13 +282,16 @@ static void ath_tx_update_baw(struct ath_softc *sc, struct ath_atx_tid *tid,
 }
 
 static void ath_tx_addto_baw(struct ath_softc *sc, struct ath_atx_tid *tid,
-        u16 seqno)
+        struct ath_buf *bf)
 {
+ struct ath_frame_info *fi = get_frame_info(bf->bf_mpdu);
+ u16 seqno = bf->bf_state.seqno;
  int index, cindex;
 
  index  = ATH_BA_INDEX(tid->seq_start, seqno);
  cindex = (tid->baw_head + index) & (ATH_TID_MAX_BUFS - 1);
  __set_bit(cindex, tid->tx_buf);
+ fi->baw_tracked = 1;
 
  if (index >= ((tid->baw_tail - tid->baw_head) &
   (ATH_TID_MAX_BUFS - 1))) {
@@ -224,12 +300,6 @@ static void ath_tx_addto_baw(struct ath_softc *sc, struct ath_atx_tid *tid,
  }
 }
 
-/*
- * TODO: For frame(s) that are in the retry state, we will reuse the
- * sequence number(s) without setting the retry bit. The
- * alternative is to give up on these and BAR the receiver's window
- * forward.
- */
 static void ath_tid_drain(struct ath_softc *sc, struct ath_txq *txq,
      struct ath_atx_tid *tid)
 
@@ -243,7 +313,7 @@ static void ath_tid_drain(struct ath_softc *sc, struct ath_txq *txq,
  memset(&ts, 0, sizeof(ts));
  INIT_LIST_HEAD(&bf_head);
 
- while ((skb = __skb_dequeue(&tid->buf_q))) {
+ while ((skb = ath_tid_dequeue(tid))) {
   fi = get_frame_info(skb);
   bf = fi->bf;
 
@@ -253,14 +323,8 @@ static void ath_tid_drain(struct ath_softc *sc, struct ath_txq *txq,
   }
 
   list_add_tail(&bf->list, &bf_head);
-
-  ath_tx_update_baw(sc, tid, bf->bf_state.seqno);
   ath_tx_complete_buf(sc, bf, txq, &bf_head, &ts, 0);
  }
-
- tid->seq_next = tid->seq_start;
- tid->baw_tail = tid->baw_head;
- tid->bar_index = -1;
 }
 
 static void ath_tx_set_retry(struct ath_softc *sc, struct ath_txq *txq,
@@ -323,6 +387,7 @@ static struct ath_buf* ath_clone_txbuf(struct ath_softc *sc, struct ath_buf *bf)
  tbf->bf_buf_addr = bf->bf_buf_addr;
  memcpy(tbf->bf_desc, bf->bf_desc, sc->sc_ah->caps.tx_desc_len);
  tbf->bf_state = bf->bf_state;
+ tbf->bf_state.stale = false;
 
  return tbf;
 }
@@ -380,7 +445,6 @@ static void ath_tx_complete_aggr(struct ath_softc *sc, struct ath_txq *txq,
  struct ieee80211_tx_rate rates[4];
  struct ath_frame_info *fi;
  int nframes;
- u8 tidno;
  bool flush = !!(ts->ts_status & ATH9K_TX_FLUSH);
  int i, retries;
  int bar_index = -1;
@@ -406,7 +470,7 @@ static void ath_tx_complete_aggr(struct ath_softc *sc, struct ath_txq *txq,
   while (bf) {
    bf_next = bf->bf_next;
 
-   if (!bf->bf_stale || bf_next != NULL)
+   if (!bf->bf_state.stale || bf_next != NULL)
     list_move_tail(&bf->list, &bf_head);
 
    ath_tx_complete_buf(sc, bf, txq, &bf_head, ts, 0);
@@ -417,8 +481,7 @@ static void ath_tx_complete_aggr(struct ath_softc *sc, struct ath_txq *txq,
  }
 
  an = (struct ath_node *)sta->drv_priv;
- tidno = ieee80211_get_qos_ctl(hdr)[0] & IEEE80211_QOS_CTL_TID_MASK;
- tid = ATH_AN_2_TID(an, tidno);
+ tid = ath_get_skb_tid(sc, an, skb);
  seq_first = tid->seq_start;
  isba = ts->ts_flags & ATH9K_TX_BA;
 
@@ -430,7 +493,7 @@ static void ath_tx_complete_aggr(struct ath_softc *sc, struct ath_txq *txq,
   * Only BlockAcks have a TID and therefore normal Acks cannot be
   * checked
   */
- if (isba && tidno != ts->tid)
+ if (isba && tid->tidno != ts->tid)
   txok = false;
 
  isaggr = bf_isaggr(bf);
@@ -466,7 +529,8 @@ static void ath_tx_complete_aggr(struct ath_softc *sc, struct ath_txq *txq,
   tx_info = IEEE80211_SKB_CB(skb);
   fi = get_frame_info(skb);
 
-  if (!BAW_WITHIN(tid->seq_start, tid->baw_size, seqno)) {
+  if (!BAW_WITHIN(tid->seq_start, tid->baw_size, seqno) ||
+      !tid->active) {
    /*
     * Outside of the current BlockAck window,
     * maybe part of a previous session
@@ -499,7 +563,7 @@ static void ath_tx_complete_aggr(struct ath_softc *sc, struct ath_txq *txq,
    * not a holding desc.
    */
   INIT_LIST_HEAD(&bf_head);
-  if (bf_next != NULL || !bf_last->bf_stale)
+  if (bf_next != NULL || !bf_last->bf_state.stale)
    list_move_tail(&bf->list, &bf_head);
 
   if (!txpending) {
@@ -518,8 +582,12 @@ static void ath_tx_complete_aggr(struct ath_softc *sc, struct ath_txq *txq,
    ath_tx_complete_buf(sc, bf, txq, &bf_head, ts,
     !txfail);
   } else {
+   if (tx_info->flags & IEEE80211_TX_STATUS_EOSP) {
+    tx_info->flags &= ~IEEE80211_TX_STATUS_EOSP;
+    ieee80211_sta_eosp(sta);
+   }
    /* retry the un-acked ones */
-   if (bf->bf_next == NULL && bf_last->bf_stale) {
+   if (bf->bf_next == NULL && bf_last->bf_state.stale) {
     struct ath_buf *tbf;
 
     tbf = ath_clone_txbuf(sc, bf_last);
@@ -556,7 +624,7 @@ static void ath_tx_complete_aggr(struct ath_softc *sc, struct ath_txq *txq,
   if (an->sleeping)
    ieee80211_sta_set_buffered(sta, tid->tidno, true);
 
-  skb_queue_splice(&bf_pending, &tid->buf_q);
+  skb_queue_splice_tail(&bf_pending, &tid->retry_q);
   if (!an->sleeping) {
    ath_tx_queue_tid(txq, tid);
 
@@ -614,7 +682,7 @@ static void ath_tx_process_buffer(struct ath_softc *sc, struct ath_txq *txq,
  } else
   ath_tx_complete_aggr(sc, txq, bf, bf_head, ts, txok);
 
- if ((sc->sc_ah->caps.hw_caps & ATH9K_HW_CAP_HT) && !flush)
+ if (!flush)
   ath_txq_schedule(sc, txq);
 }
 
@@ -701,11 +769,6 @@ static u32 ath_lookup_rate(struct ath_softc *sc, struct ath_buf *bf,
  if (bt_aggr_limit)
   aggr_limit = bt_aggr_limit;
 
- /*
-  * h/w can accept aggregates up to 16 bit lengths (65535).
-  * The IE, however can hold up to 65536, which shows up here
-  * as zero. Ignore 65536 since we  are constrained by hw.
-  */
  if (tid->an->maxampdu)
   aggr_limit = min(aggr_limit, tid->an->maxampdu);
 
@@ -786,44 +849,64 @@ static int ath_compute_num_delims(struct ath_softc *sc, struct ath_atx_tid *tid,
  return ndelim;
 }
 
-static enum ATH_AGGR_STATUS ath_tx_form_aggr(struct ath_softc *sc,
-          struct ath_txq *txq,
-          struct ath_atx_tid *tid,
-          struct list_head *bf_q,
-          int *aggr_len)
+static struct ath_buf *
+ath_tx_get_tid_subframe(struct ath_softc *sc, struct ath_txq *txq,
+   struct ath_atx_tid *tid, struct sk_buff_head **q)
 {
-#define PADBYTES(_len) ((4 - ((_len) % 4)) % 4)
- struct ath_buf *bf, *bf_first = NULL, *bf_prev = NULL;
- int rl = 0, nframes = 0, ndelim, prev_al = 0;
- u16 aggr_limit = 0, al = 0, bpad = 0,
-  al_delta, h_baw = tid->baw_size / 2;
- enum ATH_AGGR_STATUS status = ATH_AGGR_DONE;
  struct ieee80211_tx_info *tx_info;
  struct ath_frame_info *fi;
  struct sk_buff *skb;
+ struct ath_buf *bf;
  u16 seqno;
 
- do {
-  skb = skb_peek(&tid->buf_q);
+ while (1) {
+  *q = &tid->retry_q;
+  if (skb_queue_empty(*q))
+   *q = &tid->buf_q;
+
+  skb = skb_peek(*q);
+  if (!skb)
+   break;
+
   fi = get_frame_info(skb);
   bf = fi->bf;
   if (!fi->bf)
    bf = ath_tx_setup_buffer(sc, txq, tid, skb);
+  else
+   bf->bf_state.stale = false;
 
   if (!bf) {
-   __skb_unlink(skb, &tid->buf_q);
+   __skb_unlink(skb, *q);
+   ath_txq_skb_done(sc, txq, skb);
    ieee80211_free_txskb(sc->hw, skb);
    continue;
   }
 
+  bf->bf_next = NULL;
+  bf->bf_lastbf = bf;
+
+  tx_info = IEEE80211_SKB_CB(skb);
+  tx_info->flags &= ~IEEE80211_TX_CTL_CLEAR_PS_FILT;
+
+  /*
+   * No aggregation session is running, but there may be frames
+   * from a previous session or a failed attempt in the queue.
+   * Send them out as normal data frames
+   */
+  if (!tid->active)
+   tx_info->flags &= ~IEEE80211_TX_CTL_AMPDU;
+
+  if (!(tx_info->flags & IEEE80211_TX_CTL_AMPDU)) {
+   bf->bf_state.bf_type = 0;
+   return bf;
+  }
+
   bf->bf_state.bf_type = BUF_AMPDU | BUF_AGGR;
   seqno = bf->bf_state.seqno;
 
   /* do not step over block-ack window */
-  if (!BAW_WITHIN(tid->seq_start, tid->baw_size, seqno)) {
-   status = ATH_AGGR_BAW_CLOSED;
+  if (!BAW_WITHIN(tid->seq_start, tid->baw_size, seqno))
    break;
-  }
 
   if (tid->bar_index > ATH_BA_INDEX(tid->seq_start, seqno)) {
    struct ath_tx_status ts = {};
@@ -831,39 +914,52 @@ static enum ATH_AGGR_STATUS ath_tx_form_aggr(struct ath_softc *sc,
 
    INIT_LIST_HEAD(&bf_head);
    list_add(&bf->list, &bf_head);
-   __skb_unlink(skb, &tid->buf_q);
+   __skb_unlink(skb, *q);
    ath_tx_update_baw(sc, tid, seqno);
    ath_tx_complete_buf(sc, bf, txq, &bf_head, &ts, 0);
    continue;
   }
 
-  if (!bf_first)
-   bf_first = bf;
+  return bf;
+ }
 
-  if (!rl) {
-   ath_set_rates(tid->an->vif, tid->an->sta, bf);
-   aggr_limit = ath_lookup_rate(sc, bf, tid);
-   rl = 1;
-  }
+ return NULL;
+}
 
-  /* do not exceed aggregation limit */
-  al_delta = ATH_AGGR_DELIM_SZ + fi->framelen;
+static bool
+ath_tx_form_aggr(struct ath_softc *sc, struct ath_txq *txq,
+   struct ath_atx_tid *tid, struct list_head *bf_q,
+   struct ath_buf *bf_first, struct sk_buff_head *tid_q,
+   int *aggr_len)
+{
+#define PADBYTES(_len) ((4 - ((_len) % 4)) % 4)
+ struct ath_buf *bf = bf_first, *bf_prev = NULL;
+ int nframes = 0, ndelim;
+ u16 aggr_limit = 0, al = 0, bpad = 0,
+     al_delta, h_baw = tid->baw_size / 2;
+ struct ieee80211_tx_info *tx_info;
+ struct ath_frame_info *fi;
+ struct sk_buff *skb;
+ bool closed = false;
 
-  if (nframes &&
-      ((aggr_limit < (al + bpad + al_delta + prev_al)) ||
-       ath_lookup_legacy(bf))) {
-   status = ATH_AGGR_LIMITED;
-   break;
-  }
+ bf = bf_first;
+ aggr_limit = ath_lookup_rate(sc, bf, tid);
 
-  tx_info = IEEE80211_SKB_CB(bf->bf_mpdu);
-  if (nframes && (tx_info->flags & IEEE80211_TX_CTL_RATE_CTRL_PROBE))
-   break;
+ do {
+  skb = bf->bf_mpdu;
+  fi = get_frame_info(skb);
 
-  /* do not exceed subframe limit */
-  if (nframes >= min((int)h_baw, ATH_AMPDU_SUBFRAME_DEFAULT)) {
-   status = ATH_AGGR_LIMITED;
-   break;
+  /* do not exceed aggregation limit */
+  al_delta = ATH_AGGR_DELIM_SZ + fi->framelen;
+  if (nframes) {
+   if (aggr_limit < al + bpad + al_delta ||
+       ath_lookup_legacy(bf) || nframes >= h_baw)
+    break;
+
+   tx_info = IEEE80211_SKB_CB(bf->bf_mpdu);
+   if ((tx_info->flags & IEEE80211_TX_CTL_RATE_CTRL_PROBE) ||
+       !(tx_info->flags & IEEE80211_TX_CTL_AMPDU))
+    break;
   }
 
   /* add padding for previous frame to aggregation length */
@@ -881,22 +977,37 @@ static enum ATH_AGGR_STATUS ath_tx_form_aggr(struct ath_softc *sc,
   bf->bf_next = NULL;
 
   /* link buffers of this frame to the aggregate */
-  if (!fi->retries)
-   ath_tx_addto_baw(sc, tid, seqno);
+  if (!fi->baw_tracked)
+   ath_tx_addto_baw(sc, tid, bf);
   bf->bf_state.ndelim = ndelim;
 
-  __skb_unlink(skb, &tid->buf_q);
+  __skb_unlink(skb, tid_q);
   list_add_tail(&bf->list, bf_q);
   if (bf_prev)
    bf_prev->bf_next = bf;
 
   bf_prev = bf;
 
- } while (!skb_queue_empty(&tid->buf_q));
+  bf = ath_tx_get_tid_subframe(sc, txq, tid, &tid_q);
+  if (!bf) {
+   closed = true;
+   break;
+  }
+ } while (ath_tid_has_buffered(tid));
+
+ bf = bf_first;
+ bf->bf_lastbf = bf_prev;
+
+ if (bf == bf_prev) {
+  al = get_frame_info(bf->bf_mpdu)->framelen;
+  bf->bf_state.bf_type = BUF_AMPDU;
+ } else {
+  TX_STAT_INC(txq->axq_qnum, a_aggr);
+ }
 
  *aggr_len = al;
 
- return status;
+ return closed;
 #undef PADBYTES
 }
 
@@ -935,11 +1046,11 @@ static int ath_max_framelen(int usec, int mcs, bool ht40, bool sgi)
  int symbols, bits;
  int bytes = 0;
 
+ usec -= L_STF + L_LTF + L_SIG + HT_SIG + HT_STF + HT_LTF(streams);
  symbols = sgi ? TIME_SYMBOLS_HALFGI(usec) : TIME_SYMBOLS(usec);
  bits = symbols * bits_per_symbol[mcs % 8][ht40] * streams;
  bits -= OFDM_PLCP_BITS;
  bytes = bits / 8;
- bytes -= L_STF + L_LTF + L_SIG + HT_SIG + HT_STF + HT_LTF(streams);
  if (bytes > 65532)
   bytes = 65532;
 
@@ -968,15 +1079,17 @@ void ath_update_max_aggr_framelen(struct ath_softc *sc, int queue, int txop)
 }
 
 static void ath_buf_set_rate(struct ath_softc *sc, struct ath_buf *bf,
-        struct ath_tx_info *info, int len)
+        struct ath_tx_info *info, int len, bool rts)
 {
  struct ath_hw *ah = sc->sc_ah;
+ struct ath_common *common = ath9k_hw_common(ah);
  struct sk_buff *skb;
  struct ieee80211_tx_info *tx_info;
  struct ieee80211_tx_rate *rates;
  const struct ieee80211_rate *rate;
  struct ieee80211_hdr *hdr;
  struct ath_frame_info *fi = get_frame_info(bf->bf_mpdu);
+ u32 rts_thresh = sc->hw->wiphy->rts_threshold;
  int i;
  u8 rix = 0;
 
@@ -999,7 +1112,17 @@ static void ath_buf_set_rate(struct ath_softc *sc, struct ath_buf *bf,
   rix = rates[i].idx;
   info->rates[i].Tries = rates[i].count;
 
-      if (rates[i].flags & IEEE80211_TX_RC_USE_RTS_CTS) {
+  /*
+   * Handle RTS threshold for unaggregated HT frames.
+   */
+  if (bf_isampdu(bf) && !bf_isaggr(bf) &&
+      (rates[i].flags & IEEE80211_TX_RC_MCS) &&
+      unlikely(rts_thresh != (u32) -1)) {
+   if (!rts_thresh || (len > rts_thresh))
+    rts = true;
+  }
+
+  if (rts || rates[i].flags & IEEE80211_TX_RC_USE_RTS_CTS) {
    info->rates[i].RateFlags |= ATH9K_RATESERIES_RTS_CTS;
    info->flags |= ATH9K_TXDESC_RTSENA;
   } else if (rates[i].flags & IEEE80211_TX_RC_USE_CTS_PROTECT) {
@@ -1029,7 +1152,7 @@ static void ath_buf_set_rate(struct ath_softc *sc, struct ath_buf *bf,
   }
 
   /* legacy rates */
-  rate = &sc->sbands[tx_info->band].bitrates[rates[i].idx];
+  rate = &common->sbands[tx_info->band].bitrates[rates[i].idx];
   if ((tx_info->band == IEEE80211_BAND_2GHZ) &&
       !(rate->flags & IEEE80211_RATE_ERP_G))
    phy = WLAN_RC_PHY_CCK;
@@ -1090,10 +1213,10 @@ static void ath_tx_fill_desc(struct ath_softc *sc, struct ath_buf *bf,
         struct ath_txq *txq, int len)
 {
  struct ath_hw *ah = sc->sc_ah;
- struct ieee80211_tx_info *tx_info = IEEE80211_SKB_CB(bf->bf_mpdu);
- struct ath_buf *bf_first = bf;
+ struct ath_buf *bf_first = NULL;
  struct ath_tx_info info;
- bool aggr = !!(bf->bf_state.bf_type & BUF_AGGR);
+ u32 rts_thresh = sc->hw->wiphy->rts_threshold;
+ bool rts = false;
 
  memset(&info, 0, sizeof(info));
  info.is_first = true;
@@ -1101,30 +1224,57 @@ static void ath_tx_fill_desc(struct ath_softc *sc, struct ath_buf *bf,
  info.txpower = MAX_RATE_POWER;
  info.qcu = txq->axq_qnum;
 
- info.flags = ATH9K_TXDESC_INTREQ;
- if (tx_info->flags & IEEE80211_TX_CTL_NO_ACK)
-  info.flags |= ATH9K_TXDESC_NOACK;
- if (tx_info->flags & IEEE80211_TX_CTL_LDPC)
-  info.flags |= ATH9K_TXDESC_LDPC;
-
- ath_buf_set_rate(sc, bf, &info, len);
-
- if (tx_info->flags & IEEE80211_TX_CTL_CLEAR_PS_FILT)
-  info.flags |= ATH9K_TXDESC_CLRDMASK;
-
- if (bf->bf_state.bfs_paprd)
-  info.flags |= (u32) bf->bf_state.bfs_paprd << ATH9K_TXDESC_PAPRD_S;
-
-
  while (bf) {
   struct sk_buff *skb = bf->bf_mpdu;
+  struct ieee80211_tx_info *tx_info = IEEE80211_SKB_CB(skb);
   struct ath_frame_info *fi = get_frame_info(skb);
+  bool aggr = !!(bf->bf_state.bf_type & BUF_AGGR);
 
   info.type = get_hw_packet_type(skb);
   if (bf->bf_next)
    info.link = bf->bf_next->bf_daddr;
   else
-   info.link = 0;
+   info.link = (sc->tx99_state) ? bf->bf_daddr : 0;
+
+  if (!bf_first) {
+   bf_first = bf;
+
+   if (!sc->tx99_state)
+    info.flags = ATH9K_TXDESC_INTREQ;
+   if ((tx_info->flags & IEEE80211_TX_CTL_CLEAR_PS_FILT) ||
+       txq == sc->tx.uapsdq)
+    info.flags |= ATH9K_TXDESC_CLRDMASK;
+
+   if (tx_info->flags & IEEE80211_TX_CTL_NO_ACK)
+    info.flags |= ATH9K_TXDESC_NOACK;
+   if (tx_info->flags & IEEE80211_TX_CTL_LDPC)
+    info.flags |= ATH9K_TXDESC_LDPC;
+
+   if (bf->bf_state.bfs_paprd)
+    info.flags |= (u32) bf->bf_state.bfs_paprd <<
+           ATH9K_TXDESC_PAPRD_S;
+
+   /*
+    * mac80211 doesn't handle RTS threshold for HT because
+    * the decision has to be taken based on AMPDU length
+    * and aggregation is done entirely inside ath9k.
+    * Set the RTS/CTS flag for the first subframe based
+    * on the threshold.
+    */
+   if (aggr && (bf == bf_first) &&
+       unlikely(rts_thresh != (u32) -1)) {
+    /*
+     * "len" is the size of the entire AMPDU.
+     */
+    if (!rts_thresh || (len > rts_thresh))
+     rts = true;
+   }
+
+   if (!aggr)
+    len = fi->framelen;
+
+   ath_buf_set_rate(sc, bf, &info, len, rts);
+  }
 
   info.buf_addr[0] = bf->bf_buf_addr;
   info.buf_len[0] = skb->len;
@@ -1135,7 +1285,7 @@ static void ath_tx_fill_desc(struct ath_softc *sc, struct ath_buf *bf,
   if (aggr) {
    if (bf == bf_first)
     info.aggr = AGGR_BUF_FIRST;
-   else if (!bf->bf_next)
+   else if (bf == bf_first->bf_lastbf)
     info.aggr = AGGR_BUF_LAST;
    else
     info.aggr = AGGR_BUF_MIDDLE;
@@ -1144,89 +1294,133 @@ static void ath_tx_fill_desc(struct ath_softc *sc, struct ath_buf *bf,
    info.aggr_len = len;
   }
 
+  if (bf == bf_first->bf_lastbf)
+   bf_first = NULL;
+
   ath9k_hw_set_txdesc(ah, bf->bf_desc, &info);
   bf = bf->bf_next;
  }
 }
 
-static void ath_tx_sched_aggr(struct ath_softc *sc, struct ath_txq *txq,
-         struct ath_atx_tid *tid)
+static void
+ath_tx_form_burst(struct ath_softc *sc, struct ath_txq *txq,
+    struct ath_atx_tid *tid, struct list_head *bf_q,
+    struct ath_buf *bf_first, struct sk_buff_head *tid_q)
 {
- struct ath_buf *bf;
- enum ATH_AGGR_STATUS status;
- struct ieee80211_tx_info *tx_info;
- struct list_head bf_q;
- int aggr_len;
+ struct ath_buf *bf = bf_first, *bf_prev = NULL;
+ struct sk_buff *skb;
+ int nframes = 0;
 
  do {
-  if (skb_queue_empty(&tid->buf_q))
-   return;
+  struct ieee80211_tx_info *tx_info;
+  skb = bf->bf_mpdu;
 
-  INIT_LIST_HEAD(&bf_q);
+  nframes++;
+  __skb_unlink(skb, tid_q);
+  list_add_tail(&bf->list, bf_q);
+  if (bf_prev)
+   bf_prev->bf_next = bf;
+  bf_prev = bf;
 
-  status = ath_tx_form_aggr(sc, txq, tid, &bf_q, &aggr_len);
+  if (nframes >= 2)
+   break;
 
-  /*
-   * no frames picked up to be aggregated;
-   * block-ack window is not open.
-   */
-  if (list_empty(&bf_q))
+  bf = ath_tx_get_tid_subframe(sc, txq, tid, &tid_q);
+  if (!bf)
    break;
 
-  bf = list_first_entry(&bf_q, struct ath_buf, list);
-  bf->bf_lastbf = list_entry(bf_q.prev, struct ath_buf, list);
   tx_info = IEEE80211_SKB_CB(bf->bf_mpdu);
+  if (tx_info->flags & IEEE80211_TX_CTL_AMPDU)
+   break;
 
-  if (tid->ac->clear_ps_filter) {
-   tid->ac->clear_ps_filter = false;
-   tx_info->flags |= IEEE80211_TX_CTL_CLEAR_PS_FILT;
-  } else {
-   tx_info->flags &= ~IEEE80211_TX_CTL_CLEAR_PS_FILT;
-  }
+  ath_set_rates(tid->an->vif, tid->an->sta, bf);
+ } while (1);
+}
 
-  /* if only one frame, send as non-aggregate */
-  if (bf == bf->bf_lastbf) {
-   aggr_len = get_frame_info(bf->bf_mpdu)->framelen;
-   bf->bf_state.bf_type = BUF_AMPDU;
-  } else {
-   TX_STAT_INC(txq->axq_qnum, a_aggr);
-  }
+static bool ath_tx_sched_aggr(struct ath_softc *sc, struct ath_txq *txq,
+         struct ath_atx_tid *tid, bool *stop)
+{
+ struct ath_buf *bf;
+ struct ieee80211_tx_info *tx_info;
+ struct sk_buff_head *tid_q;
+ struct list_head bf_q;
+ int aggr_len = 0;
+ bool aggr, last = true;
+
+ if (!ath_tid_has_buffered(tid))
+  return false;
+
+ INIT_LIST_HEAD(&bf_q);
 
-  ath_tx_fill_desc(sc, bf, txq, aggr_len);
-  ath_tx_txqaddbuf(sc, txq, &bf_q, false);
- } while (txq->axq_ampdu_depth < ATH_AGGR_MIN_QDEPTH &&
-   status != ATH_AGGR_BAW_CLOSED);
+ bf = ath_tx_get_tid_subframe(sc, txq, tid, &tid_q);
+ if (!bf)
+  return false;
+
+ tx_info = IEEE80211_SKB_CB(bf->bf_mpdu);
+ aggr = !!(tx_info->flags & IEEE80211_TX_CTL_AMPDU);
+ if ((aggr && txq->axq_ampdu_depth >= ATH_AGGR_MIN_QDEPTH) ||
+  (!aggr && txq->axq_depth >= ATH_NON_AGGR_MIN_QDEPTH)) {
+  *stop = true;
+  return false;
+ }
+
+ ath_set_rates(tid->an->vif, tid->an->sta, bf);
+ if (aggr)
+  last = ath_tx_form_aggr(sc, txq, tid, &bf_q, bf,
+     tid_q, &aggr_len);
+ else
+  ath_tx_form_burst(sc, txq, tid, &bf_q, bf, tid_q);
+
+ if (list_empty(&bf_q))
+  return false;
+
+ if (tid->ac->clear_ps_filter || tid->an->no_ps_filter) {
+  tid->ac->clear_ps_filter = false;
+  tx_info->flags |= IEEE80211_TX_CTL_CLEAR_PS_FILT;
+ }
+
+ ath_tx_fill_desc(sc, bf, txq, aggr_len);
+ ath_tx_txqaddbuf(sc, txq, &bf_q, false);
+ return true;
 }
 
 int ath_tx_aggr_start(struct ath_softc *sc, struct ieee80211_sta *sta,
         u16 tid, u16 *ssn)
 {
  struct ath_atx_tid *txtid;
+ struct ath_txq *txq;
  struct ath_node *an;
  u8 density;
 
  an = (struct ath_node *)sta->drv_priv;
  txtid = ATH_AN_2_TID(an, tid);
+ txq = txtid->ac->txq;
+
+ ath_txq_lock(sc, txq);
 
  /* update ampdu factor/density, they may have changed. This may happen
   * in HT IBSS when a beacon with HT-info is received after the station
   * has already been added.
   */
  if (sta->ht_cap.ht_supported) {
-  an->maxampdu = 1 << (IEEE80211_HT_MAX_AMPDU_FACTOR +
-         sta->ht_cap.ampdu_factor);
+  an->maxampdu = (1 << (IEEE80211_HT_MAX_AMPDU_FACTOR +
+          sta->ht_cap.ampdu_factor)) - 1;
   density = ath9k_parse_mpdudensity(sta->ht_cap.ampdu_density);
   an->mpdudensity = density;
  }
 
+ /* force sequence number allocation for pending frames */
+ ath_tx_tid_change_state(sc, txtid);
+
  txtid->active = true;
- txtid->paused = true;
  *ssn = txtid->seq_start = txtid->seq_next;
  txtid->bar_index = -1;
 
  memset(txtid->tx_buf, 0, sizeof(txtid->tx_buf));
  txtid->baw_head = txtid->baw_tail = 0;
 
+ ath_txq_unlock_complete(sc, txq);
+
  return 0;
 }
 
@@ -1238,8 +1432,8 @@ void ath_tx_aggr_stop(struct ath_softc *sc, struct ieee80211_sta *sta, u16 tid)
 
  ath_txq_lock(sc, txq);
  txtid->active = false;
- txtid->paused = true;
  ath_tx_flush_tid(sc, txtid);
+ ath_tx_tid_change_state(sc, txtid);
  ath_txq_unlock_complete(sc, txq);
 }
 
@@ -1261,11 +1455,11 @@ void ath_tx_aggr_sleep(struct ieee80211_sta *sta, struct ath_softc *sc,
   ath_txq_lock(sc, txq);
 
   if (!tid->sched) {
-   ath_txq_unlock(sc,txq);
+   ath_txq_unlock(sc, txq);
    continue;
   }
 
-  buffered = !skb_queue_empty(&tid->buf_q);
+  buffered = ath_tid_has_buffered(tid);
 
   tid->sched = false;
   list_del(&tid->list);
@@ -1297,7 +1491,7 @@ void ath_tx_aggr_wakeup(struct ath_softc *sc, struct ath_node *an)
   ath_txq_lock(sc, txq);
   ac->clear_ps_filter = true;
 
-  if (!skb_queue_empty(&tid->buf_q) && !tid->paused) {
+  if (ath_tid_has_buffered(tid)) {
    ath_tx_queue_tid(txq, tid);
    ath_txq_schedule(sc, txq);
   }
@@ -1320,9 +1514,8 @@ void ath_tx_aggr_resume(struct ath_softc *sc, struct ieee80211_sta *sta,
  ath_txq_lock(sc, txq);
 
  tid->baw_size = IEEE80211_MIN_AMPDU_BUF << sta->ht_cap.ampdu_factor;
- tid->paused = false;
 
- if (!skb_queue_empty(&tid->buf_q)) {
+ if (ath_tid_has_buffered(tid)) {
   ath_tx_queue_tid(txq, tid);
   ath_txq_schedule(sc, txq);
  }
@@ -1330,6 +1523,71 @@ void ath_tx_aggr_resume(struct ath_softc *sc, struct ieee80211_sta *sta,
  ath_txq_unlock_complete(sc, txq);
 }
 
+void ath9k_release_buffered_frames(struct ieee80211_hw *hw,
+       struct ieee80211_sta *sta,
+       u16 tids, int nframes,
+       enum ieee80211_frame_release_type reason,
+       bool more_data)
+{
+ struct ath_softc *sc = hw->priv;
+ struct ath_node *an = (struct ath_node *)sta->drv_priv;
+ struct ath_txq *txq = sc->tx.uapsdq;
+ struct ieee80211_tx_info *info;
+ struct list_head bf_q;
+ struct ath_buf *bf_tail = NULL, *bf;
+ struct sk_buff_head *tid_q;
+ int sent = 0;
+ int i;
+
+ INIT_LIST_HEAD(&bf_q);
+ for (i = 0; tids && nframes; i++, tids >>= 1) {
+  struct ath_atx_tid *tid;
+
+  if (!(tids & 1))
+   continue;
+
+  tid = ATH_AN_2_TID(an, i);
+
+  ath_txq_lock(sc, tid->ac->txq);
+  while (nframes > 0) {
+   bf = ath_tx_get_tid_subframe(sc, sc->tx.uapsdq, tid, &tid_q);
+   if (!bf)
+    break;
+
+   __skb_unlink(bf->bf_mpdu, tid_q);
+   list_add_tail(&bf->list, &bf_q);
+   ath_set_rates(tid->an->vif, tid->an->sta, bf);
+   if (bf_isampdu(bf)) {
+    ath_tx_addto_baw(sc, tid, bf);
+    bf->bf_state.bf_type &= ~BUF_AGGR;
+   }
+   if (bf_tail)
+    bf_tail->bf_next = bf;
+
+   bf_tail = bf;
+   nframes--;
+   sent++;
+   TX_STAT_INC(txq->axq_qnum, a_queued_hw);
+
+   if (an->sta && !ath_tid_has_buffered(tid))
+    ieee80211_sta_set_buffered(an->sta, i, false);
+  }
+  ath_txq_unlock_complete(sc, tid->ac->txq);
+ }
+
+ if (list_empty(&bf_q))
+  return;
+
+ info = IEEE80211_SKB_CB(bf_tail->bf_mpdu);
+ info->flags |= IEEE80211_TX_STATUS_EOSP;
+
+ bf = list_first_entry(&bf_q, struct ath_buf, list);
+ ath_txq_lock(sc, txq);
+ ath_tx_fill_desc(sc, bf, txq, 0);
+ ath_tx_txqaddbuf(sc, txq, &bf_q, false);
+ ath_txq_unlock(sc, txq);
+}
+
 /********************/
 /* Queue Management */
 /********************/
@@ -1441,16 +1699,9 @@ int ath_cabq_update(struct ath_softc *sc)
  int qnum = sc->beacon.cabq->axq_qnum;
 
  ath9k_hw_get_txq_props(sc->sc_ah, qnum, &qi);
- /*
-  * Ensure the readytime % is within the bounds.
-  */
- if (sc->config.cabqReadytime < ATH9K_READY_TIME_LO_BOUND)
-  sc->config.cabqReadytime = ATH9K_READY_TIME_LO_BOUND;
- else if (sc->config.cabqReadytime > ATH9K_READY_TIME_HI_BOUND)
-  sc->config.cabqReadytime = ATH9K_READY_TIME_HI_BOUND;
 
- qi.tqi_readyTime = (cur_conf->beacon_interval *
-       sc->config.cabqReadytime) / 100;
+ qi.tqi_readyTime = (TU_TO_USEC(cur_conf->beacon_interval) *
+       ATH_CABQ_READY_TIME) / 100;
  ath_txq_update(sc, qnum, &qi);
 
  return 0;
@@ -1470,7 +1721,7 @@ static void ath_drain_txq_list(struct ath_softc *sc, struct ath_txq *txq,
  while (!list_empty(list)) {
   bf = list_first_entry(list, struct ath_buf, list);
 
-  if (bf->bf_stale) {
+  if (bf->bf_state.stale) {
    list_del(&bf->list);
 
    ath_tx_return_buffer(sc, bf);
@@ -1519,7 +1770,7 @@ bool ath_drain_all_txq(struct ath_softc *sc)
  int i;
  u32 npend = 0;
 
- if (test_bit(SC_OP_INVALID, &sc->sc_flags))
+ if (test_bit(ATH_OP_INVALID, &common->op_flags))
   return true;
 
  ath9k_hw_abort_tx_dma(ah);
@@ -1529,6 +1780,9 @@ bool ath_drain_all_txq(struct ath_softc *sc)
   if (!ATH_TXQ_SETUP(sc, i))
    continue;
 
+  if (!sc->tx.txq[i].axq_depth)
+   continue;
+
   if (ath9k_hw_numtxpending(ah, sc->tx.txq[i].axq_qnum))
    npend |= BIT(i);
  }
@@ -1564,44 +1818,44 @@ void ath_tx_cleanupq(struct ath_softc *sc, struct ath_txq *txq)
  */
 void ath_txq_schedule(struct ath_softc *sc, struct ath_txq *txq)
 {
- struct ath_atx_ac *ac, *ac_tmp, *last_ac;
+ struct ath_common *common = ath9k_hw_common(sc->sc_ah);
+ struct ath_atx_ac *ac, *last_ac;
  struct ath_atx_tid *tid, *last_tid;
+ bool sent = false;
 
- if (test_bit(SC_OP_HW_RESET, &sc->sc_flags) ||
-     list_empty(&txq->axq_acq) ||
-     txq->axq_ampdu_depth >= ATH_AGGR_MIN_QDEPTH)
+ if (test_bit(ATH_OP_HW_RESET, &common->op_flags) ||
+     list_empty(&txq->axq_acq))
   return;
 
  rcu_read_lock();
 
- ac = list_first_entry(&txq->axq_acq, struct ath_atx_ac, list);
  last_ac = list_entry(txq->axq_acq.prev, struct ath_atx_ac, list);
+ while (!list_empty(&txq->axq_acq)) {
+  bool stop = false;
 
- list_for_each_entry_safe(ac, ac_tmp, &txq->axq_acq, list) {
+  ac = list_first_entry(&txq->axq_acq, struct ath_atx_ac, list);
   last_tid = list_entry(ac->tid_q.prev, struct ath_atx_tid, list);
   list_del(&ac->list);
   ac->sched = false;
 
   while (!list_empty(&ac->tid_q)) {
+
    tid = list_first_entry(&ac->tid_q, struct ath_atx_tid,
             list);
    list_del(&tid->list);
    tid->sched = false;
 
-   if (tid->paused)
-    continue;
-
-   ath_tx_sched_aggr(sc, txq, tid);
+   if (ath_tx_sched_aggr(sc, txq, tid, &stop))
+    sent = true;
 
    /*
     * add tid to round-robin queue if more frames
     * are pending for the tid
     */
-   if (!skb_queue_empty(&tid->buf_q))
+   if (ath_tid_has_buffered(tid))
     ath_tx_queue_tid(txq, tid);
 
-   if (tid == last_tid ||
-       txq->axq_ampdu_depth >= ATH_AGGR_MIN_QDEPTH)
+   if (stop || tid == last_tid)
     break;
   }
 
@@ -1610,9 +1864,17 @@ void ath_txq_schedule(struct ath_softc *sc, struct ath_txq *txq)
    list_add_tail(&ac->list, &txq->axq_acq);
   }
 
-  if (ac == last_ac ||
-      txq->axq_ampdu_depth >= ATH_AGGR_MIN_QDEPTH)
+  if (stop)
    break;
+
+  if (ac == last_ac) {
+   if (!sent)
+    break;
+
+   sent = false;
+   last_ac = list_entry(txq->axq_acq.prev,
+          struct ath_atx_ac, list);
+  }
  }
 
  rcu_read_unlock();
@@ -1675,79 +1937,39 @@ static void ath_tx_txqaddbuf(struct ath_softc *sc, struct ath_txq *txq,
    txq->axq_qnum, ito64(bf->bf_daddr), bf->bf_desc);
  }
 
- if (!edma) {
+ if (!edma || sc->tx99_state) {
   TX_STAT_INC(txq->axq_qnum, txstart);
   ath9k_hw_txstart(ah, txq->axq_qnum);
  }
 
  if (!internal) {
-  txq->axq_depth++;
-  if (bf_is_ampdu_not_probing(bf))
-   txq->axq_ampdu_depth++;
- }
-}
-
-static void ath_tx_send_ampdu(struct ath_softc *sc, struct ath_atx_tid *tid,
-         struct sk_buff *skb, struct ath_tx_control *txctl)
-{
- struct ath_frame_info *fi = get_frame_info(skb);
- struct list_head bf_head;
- struct ath_buf *bf;
-
- /*
-  * Do not queue to h/w when any of the following conditions is true:
-  * - there are pending frames in software queue
-  * - the TID is currently paused for ADDBA/BAR request
-  * - seqno is not within block-ack window
-  * - h/w queue depth exceeds low water mark
-  */
- if (!skb_queue_empty(&tid->buf_q) || tid->paused ||
-     !BAW_WITHIN(tid->seq_start, tid->baw_size, tid->seq_next) ||
-     txctl->txq->axq_ampdu_depth >= ATH_AGGR_MIN_QDEPTH) {
-  /*
-   * Add this frame to software queue for scheduling later
-   * for aggregation.
-   */
-  TX_STAT_INC(txctl->txq->axq_qnum, a_queued_sw);
-  __skb_queue_tail(&tid->buf_q, skb);
-  if (!txctl->an || !txctl->an->sleeping)
-   ath_tx_queue_tid(txctl->txq, tid);
-  return;
- }
+  while (bf) {
+   txq->axq_depth++;
+   if (bf_is_ampdu_not_probing(bf))
+    txq->axq_ampdu_depth++;
 
- bf = ath_tx_setup_buffer(sc, txctl->txq, tid, skb);
- if (!bf) {
-  ieee80211_free_txskb(sc->hw, skb);
-  return;
+   bf_last = bf->bf_lastbf;
+   bf = bf_last->bf_next;
+   bf_last->bf_next = NULL;
+  }
  }
-
- ath_set_rates(tid->an->vif, tid->an->sta, bf);
- bf->bf_state.bf_type = BUF_AMPDU;
- INIT_LIST_HEAD(&bf_head);
- list_add(&bf->list, &bf_head);
-
- /* Add sub-frame to BAW */
- ath_tx_addto_baw(sc, tid, bf->bf_state.seqno);
-
- /* Queue to h/w without aggregation */
- TX_STAT_INC(txctl->txq->axq_qnum, a_queued_hw);
- bf->bf_lastbf = bf;
- ath_tx_fill_desc(sc, bf, txctl->txq, fi->framelen);
- ath_tx_txqaddbuf(sc, txctl->txq, &bf_head, false);
 }
 
 static void ath_tx_send_normal(struct ath_softc *sc, struct ath_txq *txq,
           struct ath_atx_tid *tid, struct sk_buff *skb)
 {
+ struct ieee80211_tx_info *tx_info = IEEE80211_SKB_CB(skb);
  struct ath_frame_info *fi = get_frame_info(skb);
  struct list_head bf_head;
- struct ath_buf *bf;
-
- bf = fi->bf;
+ struct ath_buf *bf = fi->bf;
 
  INIT_LIST_HEAD(&bf_head);
  list_add_tail(&bf->list, &bf_head);
  bf->bf_state.bf_type = 0;
+ if (tid && (tx_info->flags & IEEE80211_TX_CTL_AMPDU)) {
+  bf->bf_state.bf_type = BUF_AMPDU;
+  ath_tx_addto_baw(sc, tid, bf);
+ }
 
  bf->bf_next = NULL;
  bf->bf_lastbf = bf;
@@ -1794,6 +2016,9 @@ static void setup_frame_info(struct ieee80211_hw *hw,
   fi->keyix = ATH9K_TXKEYIX_INVALID;
  fi->keytype = keytype;
  fi->framelen = framelen;
+
+ if (!rate)
+  return;
  fi->rtscts_rate = rate->hw_value;
  if (short_preamble)
   fi->rtscts_rate |= rate->hw_value_short;
@@ -1804,8 +2029,7 @@ u8 ath_txchainmask_reduction(struct ath_softc *sc, u8 chainmask, u32 rate)
  struct ath_hw *ah = sc->sc_ah;
  struct ath9k_channel *curchan = ah->curchan;
 
- if ((ah->caps.hw_caps & ATH9K_HW_CAP_APM) &&
-     (curchan->channelFlags & CHANNEL_5GHZ) &&
+ if ((ah->caps.hw_caps & ATH9K_HW_CAP_APM) && IS_CHAN_5GHZ(curchan) &&
      (chainmask == 0x7) && (rate < 0x90))
   return 0x3;
  else if (AR_SREV_9462(ah) && ath9k_hw_btcoex_is_enabled(ah) &&
@@ -1839,7 +2063,7 @@ static struct ath_buf *ath_tx_setup_buffer(struct ath_softc *sc,
 
  ATH_TXBUF_RESET(bf);
 
- if (tid) {
+ if (tid && ieee80211_is_data_present(hdr->frame_control)) {
   fragno = le16_to_cpu(hdr->seq_ctrl) & IEEE80211_SCTL_FRAG;
   seqno = tid->seq_next;
   hdr->seq_ctrl = cpu_to_le16(tid->seq_next << IEEE80211_SEQ_SEQ_SHIFT);
@@ -1871,26 +2095,25 @@ static struct ath_buf *ath_tx_setup_buffer(struct ath_softc *sc,
  return bf;
 }
 
-/* Upon failure caller should free skb */
-int ath_tx_start(struct ieee80211_hw *hw, struct sk_buff *skb,
-   struct ath_tx_control *txctl)
+static int ath_tx_prepare(struct ieee80211_hw *hw, struct sk_buff *skb,
+     struct ath_tx_control *txctl)
 {
  struct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;
  struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
  struct ieee80211_sta *sta = txctl->sta;
  struct ieee80211_vif *vif = info->control.vif;
+ struct ath_vif *avp;
  struct ath_softc *sc = hw->priv;
- struct ath_txq *txq = txctl->txq;
- struct ath_atx_tid *tid = NULL;
- struct ath_buf *bf;
- int padpos, padsize;
  int frmlen = skb->len + FCS_LEN;
- u8 tidno;
- int q;
+ int padpos, padsize;
 
  /* NOTE:  sta can be NULL according to net/mac80211.h */
  if (sta)
   txctl->an = (struct ath_node *)sta->drv_priv;
+ else if (vif && ieee80211_is_data(hdr->frame_control)) {
+  avp = (void *)vif->drv_priv;
+  txctl->an = &avp->mcast_node;
+ }
 
  if (info->control.hw_key)
   frmlen += info->control.hw_key->icv_len;
@@ -1907,6 +2130,11 @@ int ath_tx_start(struct ieee80211_hw *hw, struct sk_buff *skb,
   hdr->seq_ctrl |= cpu_to_le16(sc->tx.seq_no);
  }
 
+ if ((vif && vif->type != NL80211_IFTYPE_AP &&
+             vif->type != NL80211_IFTYPE_AP_VLAN) ||
+     !ieee80211_is_data(hdr->frame_control))
+  info->flags |= IEEE80211_TX_CTL_CLEAR_PS_FILT;
+
  /* Add the padding after the header if this is not already done */
  padpos = ieee80211_hdrlen(hdr->frame_control);
  padsize = padpos & 3;
@@ -1916,16 +2144,33 @@ int ath_tx_start(struct ieee80211_hw *hw, struct sk_buff *skb,
 
   skb_push(skb, padsize);
   memmove(skb->data, skb->data + padsize, padpos);
-  hdr = (struct ieee80211_hdr *) skb->data;
  }
 
- if ((vif && vif->type != NL80211_IFTYPE_AP &&
-             vif->type != NL80211_IFTYPE_AP_VLAN) ||
-     !ieee80211_is_data(hdr->frame_control))
-  info->flags |= IEEE80211_TX_CTL_CLEAR_PS_FILT;
-
  setup_frame_info(hw, sta, skb, frmlen);
+ return 0;
+}
+
+
+/* Upon failure caller should free skb */
+int ath_tx_start(struct ieee80211_hw *hw, struct sk_buff *skb,
+   struct ath_tx_control *txctl)
+{
+ struct ieee80211_hdr *hdr;
+ struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
+ struct ieee80211_sta *sta = txctl->sta;
+ struct ieee80211_vif *vif = info->control.vif;
+ struct ath_softc *sc = hw->priv;
+ struct ath_txq *txq = txctl->txq;
+ struct ath_atx_tid *tid = NULL;
+ struct ath_buf *bf;
+ int q;
+ int ret;
+
+ ret = ath_tx_prepare(hw, skb, txctl);
+ if (ret)
+     return ret;
 
+ hdr = (struct ieee80211_hdr *) skb->data;
  /*
   * At this point, the vif, hw_key and sta pointers in the tx control
   * info are no longer valid (overwritten by the ath_frame_info data.
@@ -1941,25 +2186,36 @@ int ath_tx_start(struct ieee80211_hw *hw, struct sk_buff *skb,
   txq->stopped = true;
  }
 
- if (txctl->an && ieee80211_is_data_qos(hdr->frame_control)) {
-  tidno = ieee80211_get_qos_ctl(hdr)[0] &
-   IEEE80211_QOS_CTL_TID_MASK;
-  tid = ATH_AN_2_TID(txctl->an, tidno);
+ if (txctl->an && ieee80211_is_data_present(hdr->frame_control))
+  tid = ath_get_skb_tid(sc, txctl->an, skb);
 
+ if (info->flags & IEEE80211_TX_CTL_PS_RESPONSE) {
+  ath_txq_unlock(sc, txq);
+  txq = sc->tx.uapsdq;
+  ath_txq_lock(sc, txq);
+ } else if (txctl->an &&
+     ieee80211_is_data_present(hdr->frame_control)) {
   WARN_ON(tid->ac->txq != txctl->txq);
- }
 
- if ((info->flags & IEEE80211_TX_CTL_AMPDU) && tid) {
+  if (info->flags & IEEE80211_TX_CTL_CLEAR_PS_FILT)
+   tid->ac->clear_ps_filter = true;
+
   /*
-   * Try aggregation if it's a unicast data frame
-   * and the destination is HT capable.
+   * Add this frame to software queue for scheduling later
+   * for aggregation.
    */
-  ath_tx_send_ampdu(sc, tid, skb, txctl);
+  TX_STAT_INC(txq->axq_qnum, a_queued_sw);
+  __skb_queue_tail(&tid->buf_q, skb);
+  if (!txctl->an->sleeping)
+   ath_tx_queue_tid(txq, tid);
+
+  ath_txq_schedule(sc, txq);
   goto out;
  }
 
- bf = ath_tx_setup_buffer(sc, txctl->txq, tid, skb);
+ bf = ath_tx_setup_buffer(sc, txq, tid, skb);
  if (!bf) {
+  ath_txq_skb_done(sc, txq, skb);
   if (txctl->paprd)
    dev_kfree_skb_any(skb);
   else
@@ -1973,7 +2229,7 @@ int ath_tx_start(struct ieee80211_hw *hw, struct sk_buff *skb,
   bf->bf_state.bfs_paprd_timestamp = jiffies;
 
  ath_set_rates(vif, sta, bf);
- ath_tx_send_normal(sc, txctl->txq, tid, skb);
+ ath_tx_send_normal(sc, txq, tid, skb);
 
 out:
  ath_txq_unlock(sc, txq);
@@ -1981,6 +2237,74 @@ out:
  return 0;
 }
 
+void ath_tx_cabq(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
+   struct sk_buff *skb)
+{
+ struct ath_softc *sc = hw->priv;
+ struct ath_tx_control txctl = {
+  .txq = sc->beacon.cabq
+ };
+ struct ath_tx_info info = {};
+ struct ieee80211_hdr *hdr;
+ struct ath_buf *bf_tail = NULL;
+ struct ath_buf *bf;
+ LIST_HEAD(bf_q);
+ int duration = 0;
+ int max_duration;
+
+ max_duration =
+  sc->cur_beacon_conf.beacon_interval * 1000 *
+  sc->cur_beacon_conf.dtim_period / ATH_BCBUF;
+
+ do {
+  struct ath_frame_info *fi = get_frame_info(skb);
+
+  if (ath_tx_prepare(hw, skb, &txctl))
+   break;
+
+  bf = ath_tx_setup_buffer(sc, txctl.txq, NULL, skb);
+  if (!bf)
+   break;
+
+  bf->bf_lastbf = bf;
+  ath_set_rates(vif, NULL, bf);
+  ath_buf_set_rate(sc, bf, &info, fi->framelen, false);
+  duration += info.rates[0].PktDuration;
+  if (bf_tail)
+   bf_tail->bf_next = bf;
+
+  list_add_tail(&bf->list, &bf_q);
+  bf_tail = bf;
+  skb = NULL;
+
+  if (duration > max_duration)
+   break;
+
+  skb = ieee80211_get_buffered_bc(hw, vif);
+ } while(skb);
+
+ if (skb)
+  ieee80211_free_txskb(hw, skb);
+
+ if (list_empty(&bf_q))
+  return;
+
+ bf = list_first_entry(&bf_q, struct ath_buf, list);
+ hdr = (struct ieee80211_hdr *) bf->bf_mpdu->data;
+
+ if (hdr->frame_control & IEEE80211_FCTL_MOREDATA) {
+  hdr->frame_control &= ~IEEE80211_FCTL_MOREDATA;
+  dma_sync_single_for_device(sc->dev, bf->bf_buf_addr,
+   sizeof(*hdr), DMA_TO_DEVICE);
+ }
+
+ ath_txq_lock(sc, txctl.txq);
+ ath_tx_fill_desc(sc, bf, txctl.txq, 0);
+ ath_tx_txqaddbuf(sc, txctl.txq, &bf_q, false);
+ TX_STAT_INC(txctl.txq->axq_qnum, queued);
+ ath_txq_unlock(sc, txctl.txq);
+}
+
 /*****************/
 /* TX Completion */
 /*****************/
@@ -1991,13 +2315,13 @@ static void ath_tx_complete(struct ath_softc *sc, struct sk_buff *skb,
  struct ieee80211_tx_info *tx_info = IEEE80211_SKB_CB(skb);
  struct ath_common *common = ath9k_hw_common(sc->sc_ah);
  struct ieee80211_hdr * hdr = (struct ieee80211_hdr *)skb->data;
- int q, padpos, padsize;
+ int padpos, padsize;
  unsigned long flags;
 
  ath_dbg(common, XMIT, "TX complete: skb: %p\n", skb);
 
  if (sc->sc_ah->caldata)
-  sc->sc_ah->caldata->paprd_packet_sent = true;
+  set_bit(PAPRD_PACKET_SENT, &sc->sc_ah->caldata->cal_flags);
 
  if (!(tx_flags & ATH_TX_ERROR))
   /* Frame was ACKed */
@@ -2026,19 +2350,8 @@ static void ath_tx_complete(struct ath_softc *sc, struct sk_buff *skb,
  }
  spin_unlock_irqrestore(&sc->sc_pm_lock, flags);
 
- q = skb_get_queue_mapping(skb);
- if (txq == sc->tx.txq_map[q]) {
-  if (WARN_ON(--txq->pending_frames < 0))
-   txq->pending_frames = 0;
-
-  if (txq->stopped &&
-      txq->pending_frames < sc->tx.txq_max_pending[q]) {
-   ieee80211_wake_queue(sc->hw, q);
-   txq->stopped = false;
-  }
- }
-
  __skb_queue_tail(&txq->complete_q, skb);
+ ath_txq_skb_done(sc, txq, skb);
 }
 
 static void ath_tx_complete_buf(struct ath_softc *sc, struct ath_buf *bf,
@@ -2058,6 +2371,8 @@ static void ath_tx_complete_buf(struct ath_softc *sc, struct ath_buf *bf,
 
  dma_unmap_single(sc->dev, bf->bf_buf_addr, skb->len, DMA_TO_DEVICE);
  bf->bf_buf_addr = 0;
+ if (sc->tx99_state)
+  goto skip_tx_complete;
 
  if (bf->bf_state.bfs_paprd) {
   if (time_after(jiffies,
@@ -2070,6 +2385,7 @@ static void ath_tx_complete_buf(struct ath_softc *sc, struct ath_buf *bf,
   ath_debug_stat_tx(sc, bf, ts, txq, tx_flags);
   ath_tx_complete(sc, skb, tx_flags, txq);
  }
+skip_tx_complete:
  /* At this point, skb (bf->bf_mpdu) is consumed...make sure we don't
   * accidentally reference it later.
   */
@@ -2154,13 +2470,12 @@ static void ath_tx_processq(struct ath_softc *sc, struct ath_txq *txq)
 
  ath_txq_lock(sc, txq);
  for (;;) {
-  if (test_bit(SC_OP_HW_RESET, &sc->sc_flags))
+  if (test_bit(ATH_OP_HW_RESET, &common->op_flags))
    break;
 
   if (list_empty(&txq->axq_q)) {
    txq->axq_link = NULL;
-   if (sc->sc_ah->caps.hw_caps & ATH9K_HW_CAP_HT)
-    ath_txq_schedule(sc, txq);
+   ath_txq_schedule(sc, txq);
    break;
   }
   bf = list_first_entry(&txq->axq_q, struct ath_buf, list);
@@ -2174,7 +2489,7 @@ static void ath_tx_processq(struct ath_softc *sc, struct ath_txq *txq)
    * it with the STALE flag.
    */
   bf_held = NULL;
-  if (bf->bf_stale) {
+  if (bf->bf_state.stale) {
    bf_held = bf;
    if (list_is_last(&bf_held->list, &txq->axq_q))
     break;
@@ -2198,7 +2513,7 @@ static void ath_tx_processq(struct ath_softc *sc, struct ath_txq *txq)
    * however leave the last descriptor back as the holding
    * descriptor for hw.
    */
-  lastbf->bf_stale = true;
+  lastbf->bf_state.stale = true;
   INIT_LIST_HEAD(&bf_head);
   if (!list_is_singular(&lastbf->list))
    list_cut_position(&bf_head,
@@ -2238,7 +2553,7 @@ void ath_tx_edma_tasklet(struct ath_softc *sc)
  int status;
 
  for (;;) {
-  if (test_bit(SC_OP_HW_RESET, &sc->sc_flags))
+  if (test_bit(ATH_OP_HW_RESET, &common->op_flags))
    break;
 
   status = ath9k_hw_txprocdesc(ah, NULL, (void *)&ts);
@@ -2253,6 +2568,8 @@ void ath_tx_edma_tasklet(struct ath_softc *sc)
   if (ts.qid == sc->beacon.beaconq) {
    sc->beacon.tx_processed = true;
    sc->beacon.tx_last = !(ts.ts_status & ATH9K_TXERR_MASK);
+
+   ath9k_csa_update(sc);
    continue;
   }
 
@@ -2269,7 +2586,7 @@ void ath_tx_edma_tasklet(struct ath_softc *sc)
   }
 
   bf = list_first_entry(fifo_list, struct ath_buf, list);
-  if (bf->bf_stale) {
+  if (bf->bf_state.stale) {
    list_del(&bf->list);
    ath_tx_return_buffer(sc, bf);
    bf = list_first_entry(fifo_list, struct ath_buf, list);
@@ -2291,7 +2608,7 @@ void ath_tx_edma_tasklet(struct ath_softc *sc)
     ath_tx_txqaddbuf(sc, txq, &bf_q, true);
    }
   } else {
-   lastbf->bf_stale = true;
+   lastbf->bf_state.stale = true;
    if (bf != lastbf)
     list_cut_position(&bf_head, fifo_list,
         lastbf->list.prev);
@@ -2379,9 +2696,9 @@ void ath_tx_node_init(struct ath_softc *sc, struct ath_node *an)
   tid->baw_size  = WME_MAX_BA;
   tid->baw_head  = tid->baw_tail = 0;
   tid->sched     = false;
-  tid->paused    = false;
   tid->active    = false;
   __skb_queue_head_init(&tid->buf_q);
+  __skb_queue_head_init(&tid->retry_q);
   acno = TID_TO_WME_AC(tidno);
   tid->ac = &an->ac[acno];
  }
@@ -2426,3 +2743,50 @@ void ath_tx_node_cleanup(struct ath_softc *sc, struct ath_node *an)
   ath_txq_unlock(sc, txq);
  }
 }
+
+#ifdef CONFIG_ATH9K_TX99
+
+int ath9k_tx99_send(struct ath_softc *sc, struct sk_buff *skb,
+      struct ath_tx_control *txctl)
+{
+ struct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;
+ struct ath_frame_info *fi = get_frame_info(skb);
+ struct ath_common *common = ath9k_hw_common(sc->sc_ah);
+ struct ath_buf *bf;
+ int padpos, padsize;
+
+ padpos = ieee80211_hdrlen(hdr->frame_control);
+ padsize = padpos & 3;
+
+ if (padsize && skb->len > padpos) {
+  if (skb_headroom(skb) < padsize) {
+   ath_dbg(common, XMIT,
+    "tx99 padding failed\n");
+  return -EINVAL;
+  }
+
+  skb_push(skb, padsize);
+  memmove(skb->data, skb->data + padsize, padpos);
+ }
+
+ fi->keyix = ATH9K_TXKEYIX_INVALID;
+ fi->framelen = skb->len + FCS_LEN;
+ fi->keytype = ATH9K_KEY_TYPE_CLEAR;
+
+ bf = ath_tx_setup_buffer(sc, txctl->txq, NULL, skb);
+ if (!bf) {
+  ath_dbg(common, XMIT, "tx99 buffer setup failed\n");
+  return -EINVAL;
+ }
+
+ ath_set_rates(sc->tx99_vif, NULL, bf);
+
+ ath9k_hw_set_desc_link(sc->sc_ah, bf->bf_desc, bf->bf_daddr);
+ ath9k_hw_tx99_start(sc->sc_ah, txctl->txq->axq_qnum);
+
+ ath_tx_send_normal(sc, txctl->txq, NULL, skb);
+
+ return 0;
+}
+
+#endif /* CONFIG_ATH9K_TX99 */
diff --git a/drivers/net/wireless/ath/carl9170/carl9170.h b/drivers/net/wireless/ath/carl9170/carl9170.h
index 9dce106..8596aba 100644
--- a/drivers/net/wireless/ath/carl9170/carl9170.h
+++ b/drivers/net/wireless/ath/carl9170/carl9170.h
@@ -133,6 +133,9 @@ struct carl9170_sta_tid {
 
  /* Preaggregation reorder queue */
  struct sk_buff_head queue;
+
+ struct ieee80211_sta *sta;
+ struct ieee80211_vif *vif;
 };
 
 #define CARL9170_QUEUE_TIMEOUT  256
diff --git a/drivers/net/wireless/ath/carl9170/debug.c b/drivers/net/wireless/ath/carl9170/debug.c
index 3d70cd2..1c0af9c 100644
--- a/drivers/net/wireless/ath/carl9170/debug.c
+++ b/drivers/net/wireless/ath/carl9170/debug.c
@@ -37,7 +37,6 @@
  *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  */
 
-#include <linux/init.h>
 #include <linux/slab.h>
 #include <linux/module.h>
 #include <linux/seq_file.h>
diff --git a/drivers/net/wireless/ath/carl9170/main.c b/drivers/net/wireless/ath/carl9170/main.c
index 0686375..f8ded84 100644
--- a/drivers/net/wireless/ath/carl9170/main.c
+++ b/drivers/net/wireless/ath/carl9170/main.c
@@ -37,7 +37,6 @@
  *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  */
 
-#include <linux/init.h>
 #include <linux/slab.h>
 #include <linux/module.h>
 #include <linux/etherdevice.h>
@@ -1448,6 +1447,8 @@ static int carl9170_op_ampdu_action(struct ieee80211_hw *hw,
   tid_info->state = CARL9170_TID_STATE_PROGRESS;
   tid_info->tid = tid;
   tid_info->max = sta_info->ampdu_max_len;
+  tid_info->sta = sta;
+  tid_info->vif = vif;
 
   INIT_LIST_HEAD(&tid_info->list);
   INIT_LIST_HEAD(&tid_info->tmp_list);
@@ -1706,7 +1707,9 @@ found:
  return 0;
 }
 
-static void carl9170_op_flush(struct ieee80211_hw *hw, u32 queues, bool drop)
+static void carl9170_op_flush(struct ieee80211_hw *hw,
+         struct ieee80211_vif *vif,
+         u32 queues, bool drop)
 {
  struct ar9170 *ar = hw->priv;
  unsigned int vid;
@@ -1857,6 +1860,7 @@ void *carl9170_alloc(size_t priv_size)
        IEEE80211_HW_SUPPORTS_PS |
        IEEE80211_HW_PS_NULLFUNC_STACK |
        IEEE80211_HW_NEED_DTIM_BEFORE_ASSOC |
+       IEEE80211_HW_SUPPORTS_RC_TABLE |
        IEEE80211_HW_SIGNAL_DBM |
        IEEE80211_HW_SUPPORTS_HT_CCK_RATES;
 
@@ -1965,18 +1969,6 @@ static int carl9170_parse_eeprom(struct ar9170 *ar)
   return -ENOMEM;
  ar->num_channels = chans;
 
- /*
-  * I measured this, a bandswitch takes roughly
-  * 135 ms and a frequency switch about 80.
-  *
-  * FIXME: measure these values again once EEPROM settings
-  *   are used, that will influence them!
-  */
- if (bands == 2)
-  ar->hw->channel_change_time = 135 * 1000;
- else
-  ar->hw->channel_change_time = 80 * 1000;
-
  regulatory->current_rd = le16_to_cpu(ar->eeprom.reg_domain[0]);
 
  /* second part of wiphy init */
diff --git a/drivers/net/wireless/ath/carl9170/rx.c b/drivers/net/wireless/ath/carl9170/rx.c
index 4684dd9..924135b 100644
--- a/drivers/net/wireless/ath/carl9170/rx.c
+++ b/drivers/net/wireless/ath/carl9170/rx.c
@@ -37,7 +37,6 @@
  *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  */
 
-#include <linux/init.h>
 #include <linux/slab.h>
 #include <linux/module.h>
 #include <linux/etherdevice.h>
@@ -520,6 +519,7 @@ static void carl9170_ps_beacon(struct ar9170 *ar, void *data, unsigned int len)
 {
  struct ieee80211_hdr *hdr = data;
  struct ieee80211_tim_ie *tim_ie;
+ struct ath_common *common = &ar->common;
  u8 *tim;
  u8 tim_len;
  bool cam;
@@ -527,17 +527,13 @@ static void carl9170_ps_beacon(struct ar9170 *ar, void *data, unsigned int len)
  if (likely(!(ar->hw->conf.flags & IEEE80211_CONF_PS)))
   return;
 
- /* check if this really is a beacon */
- if (!ieee80211_is_beacon(hdr->frame_control))
-  return;
-
  /* min. beacon length + FCS_LEN */
  if (len <= 40 + FCS_LEN)
   return;
 
+ /* check if this really is a beacon */
  /* and only beacons from the associated BSSID, please */
- if (!ether_addr_equal(hdr->addr3, ar->common.curbssid) ||
-     !ar->common.curaid)
+ if (!ath_is_mybeacon(common, hdr) || !common->curaid)
   return;
 
  ar->ps.last_beacon = jiffies;
@@ -576,7 +572,7 @@ static void carl9170_ps_beacon(struct ar9170 *ar, void *data, unsigned int len)
 
 static void carl9170_ba_check(struct ar9170 *ar, void *data, unsigned int len)
 {
- struct ieee80211_bar *bar = (void *) data;
+ struct ieee80211_bar *bar = data;
  struct carl9170_bar_list_entry *entry;
  unsigned int queue;
 
@@ -602,8 +598,8 @@ static void carl9170_ba_check(struct ar9170 *ar, void *data, unsigned int len)
 
   if (bar->start_seq_num == entry_bar->start_seq_num &&
       TID_CHECK(bar->control, entry_bar->control) &&
-      compare_ether_addr(bar->ra, entry_bar->ta) == 0 &&
-      compare_ether_addr(bar->ta, entry_bar->ra) == 0) {
+      ether_addr_equal_64bits(bar->ra, entry_bar->ta) &&
+      ether_addr_equal_64bits(bar->ta, entry_bar->ra)) {
    struct ieee80211_tx_info *tx_info;
 
    tx_info = IEEE80211_SKB_CB(entry_skb);
diff --git a/drivers/net/wireless/ath/carl9170/tx.c b/drivers/net/wireless/ath/carl9170/tx.c
index c61cafa..4cadfd4 100644
--- a/drivers/net/wireless/ath/carl9170/tx.c
+++ b/drivers/net/wireless/ath/carl9170/tx.c
@@ -37,7 +37,6 @@
  *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  */
 
-#include <linux/init.h>
 #include <linux/slab.h>
 #include <linux/module.h>
 #include <linux/etherdevice.h>
@@ -625,7 +624,7 @@ static void carl9170_tx_ampdu_timeout(struct ar9170 *ar)
       msecs_to_jiffies(CARL9170_QUEUE_TIMEOUT)))
    goto unlock;
 
-  sta = __carl9170_get_tx_sta(ar, skb);
+  sta = iter->sta;
   if (WARN_ON(!sta))
    goto unlock;
 
@@ -866,6 +865,93 @@ static bool carl9170_tx_cts_check(struct ar9170 *ar,
  return false;
 }
 
+static void carl9170_tx_get_rates(struct ar9170 *ar,
+      struct ieee80211_vif *vif,
+      struct ieee80211_sta *sta,
+      struct sk_buff *skb)
+{
+ struct ieee80211_tx_info *info;
+
+ BUILD_BUG_ON(IEEE80211_TX_MAX_RATES < CARL9170_TX_MAX_RATES);
+ BUILD_BUG_ON(IEEE80211_TX_MAX_RATES > IEEE80211_TX_RATE_TABLE_SIZE);
+
+ info = IEEE80211_SKB_CB(skb);
+
+ ieee80211_get_tx_rates(vif, sta, skb,
+          info->control.rates,
+          IEEE80211_TX_MAX_RATES);
+}
+
+static void carl9170_tx_apply_rateset(struct ar9170 *ar,
+          struct ieee80211_tx_info *sinfo,
+          struct sk_buff *skb)
+{
+ struct ieee80211_tx_rate *txrate;
+ struct ieee80211_tx_info *info;
+ struct _carl9170_tx_superframe *txc = (void *) skb->data;
+ int i;
+ bool ampdu;
+ bool no_ack;
+
+ info = IEEE80211_SKB_CB(skb);
+ ampdu = !!(info->flags & IEEE80211_TX_CTL_AMPDU);
+ no_ack = !!(info->flags & IEEE80211_TX_CTL_NO_ACK);
+
+ /* Set the rate control probe flag for all (sub-) frames.
+  * This is because the TX_STATS_AMPDU flag is only set on
+  * the last frame, so it has to be inherited.
+  */
+ info->flags |= (sinfo->flags & IEEE80211_TX_CTL_RATE_CTRL_PROBE);
+
+ /* NOTE: For the first rate, the ERP & AMPDU flags are directly
+  * taken from mac_control. For all fallback rate, the firmware
+  * updates the mac_control flags from the rate info field.
+  */
+ for (i = 0; i < CARL9170_TX_MAX_RATES; i++) {
+  __le32 phy_set;
+
+  txrate = &sinfo->control.rates[i];
+  if (txrate->idx < 0)
+   break;
+
+  phy_set = carl9170_tx_physet(ar, info, txrate);
+  if (i == 0) {
+   __le16 mac_tmp = cpu_to_le16(0);
+
+   /* first rate - part of the hw's frame header */
+   txc->f.phy_control = phy_set;
+
+   if (ampdu && txrate->flags & IEEE80211_TX_RC_MCS)
+    mac_tmp |= cpu_to_le16(AR9170_TX_MAC_AGGR);
+
+   if (carl9170_tx_rts_check(ar, txrate, ampdu, no_ack))
+    mac_tmp |= cpu_to_le16(AR9170_TX_MAC_PROT_RTS);
+   else if (carl9170_tx_cts_check(ar, txrate))
+    mac_tmp |= cpu_to_le16(AR9170_TX_MAC_PROT_CTS);
+
+   txc->f.mac_control |= mac_tmp;
+  } else {
+   /* fallback rates are stored in the firmware's
+    * retry rate set array.
+    */
+   txc->s.rr[i - 1] = phy_set;
+  }
+
+  SET_VAL(CARL9170_TX_SUPER_RI_TRIES, txc->s.ri[i],
+   txrate->count);
+
+  if (carl9170_tx_rts_check(ar, txrate, ampdu, no_ack))
+   txc->s.ri[i] |= (AR9170_TX_MAC_PROT_RTS <<
+    CARL9170_TX_SUPER_RI_ERP_PROT_S);
+  else if (carl9170_tx_cts_check(ar, txrate))
+   txc->s.ri[i] |= (AR9170_TX_MAC_PROT_CTS <<
+    CARL9170_TX_SUPER_RI_ERP_PROT_S);
+
+  if (ampdu && (txrate->flags & IEEE80211_TX_RC_MCS))
+   txc->s.ri[i] |= CARL9170_TX_SUPER_RI_AMPDU;
+ }
+}
+
 static int carl9170_tx_prepare(struct ar9170 *ar,
           struct ieee80211_sta *sta,
           struct sk_buff *skb)
@@ -874,13 +960,10 @@ static int carl9170_tx_prepare(struct ar9170 *ar,
  struct _carl9170_tx_superframe *txc;
  struct carl9170_vif_info *cvif;
  struct ieee80211_tx_info *info;
- struct ieee80211_tx_rate *txrate;
  struct carl9170_tx_info *arinfo;
  unsigned int hw_queue;
- int i;
  __le16 mac_tmp;
  u16 len;
- bool ampdu, no_ack;
 
  BUILD_BUG_ON(sizeof(*arinfo) > sizeof(info->rate_driver_data));
  BUILD_BUG_ON(sizeof(struct _carl9170_tx_superdesc) !=
@@ -889,8 +972,6 @@ static int carl9170_tx_prepare(struct ar9170 *ar,
  BUILD_BUG_ON(sizeof(struct _ar9170_tx_hwdesc) !=
        AR9170_TX_HWDESC_LEN);
 
- BUILD_BUG_ON(IEEE80211_TX_MAX_RATES < CARL9170_TX_MAX_RATES);
-
  BUILD_BUG_ON(AR9170_MAX_VIRTUAL_MAC >
   ((CARL9170_TX_SUPER_MISC_VIF_ID >>
    CARL9170_TX_SUPER_MISC_VIF_ID_S) + 1));
@@ -932,8 +1013,7 @@ static int carl9170_tx_prepare(struct ar9170 *ar,
  mac_tmp |= cpu_to_le16((hw_queue << AR9170_TX_MAC_QOS_S) &
           AR9170_TX_MAC_QOS);
 
- no_ack = !!(info->flags & IEEE80211_TX_CTL_NO_ACK);
- if (unlikely(no_ack))
+ if (unlikely(info->flags & IEEE80211_TX_CTL_NO_ACK))
   mac_tmp |= cpu_to_le16(AR9170_TX_MAC_NO_ACK);
 
  if (info->control.hw_key) {
@@ -954,8 +1034,7 @@ static int carl9170_tx_prepare(struct ar9170 *ar,
   }
  }
 
- ampdu = !!(info->flags & IEEE80211_TX_CTL_AMPDU);
- if (ampdu) {
+ if (info->flags & IEEE80211_TX_CTL_AMPDU) {
   unsigned int density, factor;
 
   if (unlikely(!sta || !cvif))
@@ -982,50 +1061,6 @@ static int carl9170_tx_prepare(struct ar9170 *ar,
    txc->s.ampdu_settings, factor);
  }
 
- /*
-  * NOTE: For the first rate, the ERP & AMPDU flags are directly
-  * taken from mac_control. For all fallback rate, the firmware
-  * updates the mac_control flags from the rate info field.
-  */
- for (i = 0; i < CARL9170_TX_MAX_RATES; i++) {
-  __le32 phy_set;
-  txrate = &info->control.rates[i];
-  if (txrate->idx < 0)
-   break;
-
-  phy_set = carl9170_tx_physet(ar, info, txrate);
-  if (i == 0) {
-   /* first rate - part of the hw's frame header */
-   txc->f.phy_control = phy_set;
-
-   if (ampdu && txrate->flags & IEEE80211_TX_RC_MCS)
-    mac_tmp |= cpu_to_le16(AR9170_TX_MAC_AGGR);
-   if (carl9170_tx_rts_check(ar, txrate, ampdu, no_ack))
-    mac_tmp |= cpu_to_le16(AR9170_TX_MAC_PROT_RTS);
-   else if (carl9170_tx_cts_check(ar, txrate))
-    mac_tmp |= cpu_to_le16(AR9170_TX_MAC_PROT_CTS);
-
-  } else {
-   /* fallback rates are stored in the firmware's
-    * retry rate set array.
-    */
-   txc->s.rr[i - 1] = phy_set;
-  }
-
-  SET_VAL(CARL9170_TX_SUPER_RI_TRIES, txc->s.ri[i],
-   txrate->count);
-
-  if (carl9170_tx_rts_check(ar, txrate, ampdu, no_ack))
-   txc->s.ri[i] |= (AR9170_TX_MAC_PROT_RTS <<
-    CARL9170_TX_SUPER_RI_ERP_PROT_S);
-  else if (carl9170_tx_cts_check(ar, txrate))
-   txc->s.ri[i] |= (AR9170_TX_MAC_PROT_CTS <<
-    CARL9170_TX_SUPER_RI_ERP_PROT_S);
-
-  if (ampdu && (txrate->flags & IEEE80211_TX_RC_MCS))
-   txc->s.ri[i] |= CARL9170_TX_SUPER_RI_AMPDU;
- }
-
  txc->s.len = cpu_to_le16(skb->len);
  txc->f.length = cpu_to_le16(len + FCS_LEN);
  txc->f.mac_control = mac_tmp;
@@ -1086,31 +1121,12 @@ static void carl9170_set_ampdu_params(struct ar9170 *ar, struct sk_buff *skb)
  }
 }
 
-static bool carl9170_tx_rate_check(struct ar9170 *ar, struct sk_buff *_dest,
-       struct sk_buff *_src)
-{
- struct _carl9170_tx_superframe *dest, *src;
-
- dest = (void *) _dest->data;
- src = (void *) _src->data;
-
- /*
-  * The mac80211 rate control algorithm expects that all MPDUs in
-  * an AMPDU share the same tx vectors.
-  * This is not really obvious right now, because the hardware
-  * does the AMPDU setup according to its own rulebook.
-  * Our nicely assembled, strictly monotonic increasing mpdu
-  * chains will be broken up, mashed back together...
-  */
-
- return (dest->f.phy_control == src->f.phy_control);
-}
-
 static void carl9170_tx_ampdu(struct ar9170 *ar)
 {
  struct sk_buff_head agg;
  struct carl9170_sta_tid *tid_info;
  struct sk_buff *skb, *first;
+ struct ieee80211_tx_info *tx_info_first;
  unsigned int i = 0, done_ampdus = 0;
  u16 seq, queue, tmpssn;
 
@@ -1156,6 +1172,7 @@ retry:
    goto processed;
   }
 
+  tx_info_first = NULL;
   while ((skb = skb_peek(&tid_info->queue))) {
    /* strict 0, 1, ..., n - 1, n frame sequence order */
    if (unlikely(carl9170_get_seq(skb) != seq))
@@ -1166,8 +1183,13 @@ retry:
        (tid_info->max - 1)))
     break;
 
-   if (!carl9170_tx_rate_check(ar, skb, first))
-    break;
+   if (!tx_info_first) {
+    carl9170_tx_get_rates(ar, tid_info->vif,
+            tid_info->sta, first);
+    tx_info_first = IEEE80211_SKB_CB(first);
+   }
+
+   carl9170_tx_apply_rateset(ar, tx_info_first, skb);
 
    atomic_inc(&ar->tx_ampdu_upload);
    tid_info->snx = seq = SEQ_NEXT(seq);
@@ -1182,8 +1204,7 @@ retry:
   if (skb_queue_empty(&tid_info->queue) ||
       carl9170_get_seq(skb_peek(&tid_info->queue)) !=
       tid_info->snx) {
-   /*
-    * stop TID, if A-MPDU frames are still missing,
+   /* stop TID, if A-MPDU frames are still missing,
     * or whenever the queue is empty.
     */
 
@@ -1450,12 +1471,14 @@ void carl9170_op_tx(struct ieee80211_hw *hw,
  struct ar9170 *ar = hw->priv;
  struct ieee80211_tx_info *info;
  struct ieee80211_sta *sta = control->sta;
+ struct ieee80211_vif *vif;
  bool run;
 
  if (unlikely(!IS_STARTED(ar)))
   goto err_free;
 
  info = IEEE80211_SKB_CB(skb);
+ vif = info->control.vif;
 
  if (unlikely(carl9170_tx_prepare(ar, sta, skb)))
   goto err_free;
@@ -1486,6 +1509,8 @@ void carl9170_op_tx(struct ieee80211_hw *hw,
  } else {
   unsigned int queue = skb_get_queue_mapping(skb);
 
+  carl9170_tx_get_rates(ar, vif, sta, skb);
+  carl9170_tx_apply_rateset(ar, info, skb);
   skb_queue_tail(&ar->tx_pending[queue], skb);
  }
 
diff --git a/drivers/net/wireless/ath/carl9170/usb.c b/drivers/net/wireless/ath/carl9170/usb.c
index 307bc0d..f35c7f3 100644
--- a/drivers/net/wireless/ath/carl9170/usb.c
+++ b/drivers/net/wireless/ath/carl9170/usb.c
@@ -773,7 +773,7 @@ void carl9170_usb_stop(struct ar9170 *ar)
  complete_all(&ar->cmd_wait);
 
  /* This is required to prevent an early completion on _start */
- INIT_COMPLETION(ar->cmd_wait);
+ reinit_completion(&ar->cmd_wait);
 
  /*
   * Note:
@@ -1076,8 +1076,14 @@ static int carl9170_usb_probe(struct usb_interface *intf,
 
  carl9170_set_state(ar, CARL9170_STOPPED);
 
- return request_firmware_nowait(THIS_MODULE, 1, CARL9170FW_NAME,
+ err = request_firmware_nowait(THIS_MODULE, 1, CARL9170FW_NAME,
   &ar->udev->dev, GFP_KERNEL, ar, carl9170_usb_firmware_step2);
+ if (err) {
+  usb_put_dev(udev);
+  usb_put_dev(udev);
+  carl9170_free(ar);
+ }
+ return err;
 }
 
 static void carl9170_usb_disconnect(struct usb_interface *intf)
diff --git a/drivers/net/wireless/ath/dfs_pattern_detector.c b/drivers/net/wireless/ath/dfs_pattern_detector.c
new file mode 100644
index 0000000..650be79
--- /dev/null
+++ b/drivers/net/wireless/ath/dfs_pattern_detector.c
@@ -0,0 +1,363 @@
+/*
+ * Copyright (c) 2012 Neratec Solutions AG
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <linux/slab.h>
+#include <linux/export.h>
+
+#include "dfs_pattern_detector.h"
+#include "dfs_pri_detector.h"
+#include "ath.h"
+
+/*
+ * tolerated deviation of radar time stamp in usecs on both sides
+ * TODO: this might need to be HW-dependent
+ */
+#define PRI_TOLERANCE 16
+
+/**
+ * struct radar_types - contains array of patterns defined for one DFS domain
+ * @domain: DFS regulatory domain
+ * @num_radar_types: number of radar types to follow
+ * @radar_types: radar types array
+ */
+struct radar_types {
+ enum nl80211_dfs_regions region;
+ u32 num_radar_types;
+ const struct radar_detector_specs *radar_types;
+};
+
+/* percentage on ppb threshold to trigger detection */
+#define MIN_PPB_THRESH 50
+#define PPB_THRESH(PPB) ((PPB * MIN_PPB_THRESH + 50) / 100)
+#define PRF2PRI(PRF) ((1000000 + PRF / 2) / PRF)
+/* percentage of pulse width tolerance */
+#define WIDTH_TOLERANCE 5
+#define WIDTH_LOWER(X) ((X*(100-WIDTH_TOLERANCE)+50)/100)
+#define WIDTH_UPPER(X) ((X*(100+WIDTH_TOLERANCE)+50)/100)
+
+#define ETSI_PATTERN(ID, WMIN, WMAX, PMIN, PMAX, PRF, PPB) \
+{        \
+ ID, WIDTH_LOWER(WMIN), WIDTH_UPPER(WMAX),  \
+ (PRF2PRI(PMAX) - PRI_TOLERANCE),   \
+ (PRF2PRI(PMIN) * PRF + PRI_TOLERANCE), PRF, PPB * PRF, \
+ PPB_THRESH(PPB), PRI_TOLERANCE,    \
+}
+
+/* radar types as defined by ETSI EN-301-893 v1.5.1 */
+static const struct radar_detector_specs etsi_radar_ref_types_v15[] = {
+ ETSI_PATTERN(0,  0,  1,  700,  700, 1, 18),
+ ETSI_PATTERN(1,  0,  5,  200, 1000, 1, 10),
+ ETSI_PATTERN(2,  0, 15,  200, 1600, 1, 15),
+ ETSI_PATTERN(3,  0, 15, 2300, 4000, 1, 25),
+ ETSI_PATTERN(4, 20, 30, 2000, 4000, 1, 20),
+ ETSI_PATTERN(5,  0,  2,  300,  400, 3, 10),
+ ETSI_PATTERN(6,  0,  2,  400, 1200, 3, 15),
+};
+
+static const struct radar_types etsi_radar_types_v15 = {
+ .region   = NL80211_DFS_ETSI,
+ .num_radar_types = ARRAY_SIZE(etsi_radar_ref_types_v15),
+ .radar_types  = etsi_radar_ref_types_v15,
+};
+
+#define FCC_PATTERN(ID, WMIN, WMAX, PMIN, PMAX, PRF, PPB) \
+{        \
+ ID, WIDTH_LOWER(WMIN), WIDTH_UPPER(WMAX),  \
+ PMIN - PRI_TOLERANCE,     \
+ PMAX * PRF + PRI_TOLERANCE, PRF, PPB * PRF,  \
+ PPB_THRESH(PPB), PRI_TOLERANCE,    \
+}
+
+static const struct radar_detector_specs fcc_radar_ref_types[] = {
+ FCC_PATTERN(0, 0, 1, 1428, 1428, 1, 18),
+ FCC_PATTERN(1, 0, 5, 150, 230, 1, 23),
+ FCC_PATTERN(2, 6, 10, 200, 500, 1, 16),
+ FCC_PATTERN(3, 11, 20, 200, 500, 1, 12),
+ FCC_PATTERN(4, 50, 100, 1000, 2000, 20, 1),
+ FCC_PATTERN(5, 0, 1, 333, 333, 1, 9),
+};
+
+static const struct radar_types fcc_radar_types = {
+ .region   = NL80211_DFS_FCC,
+ .num_radar_types = ARRAY_SIZE(fcc_radar_ref_types),
+ .radar_types  = fcc_radar_ref_types,
+};
+
+#define JP_PATTERN FCC_PATTERN
+static const struct radar_detector_specs jp_radar_ref_types[] = {
+ JP_PATTERN(0, 0, 1, 1428, 1428, 1, 18),
+ JP_PATTERN(1, 2, 3, 3846, 3846, 1, 18),
+ JP_PATTERN(2, 0, 1, 1388, 1388, 1, 18),
+ JP_PATTERN(3, 1, 2, 4000, 4000, 1, 18),
+ JP_PATTERN(4, 0, 5, 150, 230, 1, 23),
+ JP_PATTERN(5, 6, 10, 200, 500, 1, 16),
+ JP_PATTERN(6, 11, 20, 200, 500, 1, 12),
+ JP_PATTERN(7, 50, 100, 1000, 2000, 20, 1),
+ JP_PATTERN(5, 0, 1, 333, 333, 1, 9),
+};
+
+static const struct radar_types jp_radar_types = {
+ .region   = NL80211_DFS_JP,
+ .num_radar_types = ARRAY_SIZE(jp_radar_ref_types),
+ .radar_types  = jp_radar_ref_types,
+};
+
+static const struct radar_types *dfs_domains[] = {
+ &etsi_radar_types_v15,
+ &fcc_radar_types,
+ &jp_radar_types,
+};
+
+/**
+ * get_dfs_domain_radar_types() - get radar types for a given DFS domain
+ * @param domain DFS domain
+ * @return radar_types ptr on success, NULL if DFS domain is not supported
+ */
+static const struct radar_types *
+get_dfs_domain_radar_types(enum nl80211_dfs_regions region)
+{
+ u32 i;
+ for (i = 0; i < ARRAY_SIZE(dfs_domains); i++) {
+  if (dfs_domains[i]->region == region)
+   return dfs_domains[i];
+ }
+ return NULL;
+}
+
+/**
+ * struct channel_detector - detector elements for a DFS channel
+ * @head: list_head
+ * @freq: frequency for this channel detector in MHz
+ * @detectors: array of dynamically created detector elements for this freq
+ *
+ * Channel detectors are required to provide multi-channel DFS detection, e.g.
+ * to support off-channel scanning. A pattern detector has a list of channels
+ * radar pulses have been reported for in the past.
+ */
+struct channel_detector {
+ struct list_head head;
+ u16 freq;
+ struct pri_detector **detectors;
+};
+
+/* channel_detector_reset() - reset detector lines for a given channel */
+static void channel_detector_reset(struct dfs_pattern_detector *dpd,
+       struct channel_detector *cd)
+{
+ u32 i;
+ if (cd == NULL)
+  return;
+ for (i = 0; i < dpd->num_radar_types; i++)
+  cd->detectors[i]->reset(cd->detectors[i], dpd->last_pulse_ts);
+}
+
+/* channel_detector_exit() - destructor */
+static void channel_detector_exit(struct dfs_pattern_detector *dpd,
+      struct channel_detector *cd)
+{
+ u32 i;
+ if (cd == NULL)
+  return;
+ list_del(&cd->head);
+ for (i = 0; i < dpd->num_radar_types; i++) {
+  struct pri_detector *de = cd->detectors[i];
+  if (de != NULL)
+   de->exit(de);
+ }
+ kfree(cd->detectors);
+ kfree(cd);
+}
+
+static struct channel_detector *
+channel_detector_create(struct dfs_pattern_detector *dpd, u16 freq)
+{
+ u32 sz, i;
+ struct channel_detector *cd;
+
+ cd = kmalloc(sizeof(*cd), GFP_ATOMIC);
+ if (cd == NULL)
+  goto fail;
+
+ INIT_LIST_HEAD(&cd->head);
+ cd->freq = freq;
+ sz = sizeof(cd->detectors) * dpd->num_radar_types;
+ cd->detectors = kzalloc(sz, GFP_ATOMIC);
+ if (cd->detectors == NULL)
+  goto fail;
+
+ for (i = 0; i < dpd->num_radar_types; i++) {
+  const struct radar_detector_specs *rs = &dpd->radar_spec[i];
+  struct pri_detector *de = pri_detector_init(rs);
+  if (de == NULL)
+   goto fail;
+  cd->detectors[i] = de;
+ }
+ list_add(&cd->head, &dpd->channel_detectors);
+ return cd;
+
+fail:
+ ath_dbg(dpd->common, DFS,
+  "failed to allocate channel_detector for freq=%d\n", freq);
+ channel_detector_exit(dpd, cd);
+ return NULL;
+}
+
+/**
+ * channel_detector_get() - get channel detector for given frequency
+ * @param dpd instance pointer
+ * @param freq frequency in MHz
+ * @return pointer to channel detector on success, NULL otherwise
+ *
+ * Return existing channel detector for the given frequency or return a
+ * newly create one.
+ */
+static struct channel_detector *
+channel_detector_get(struct dfs_pattern_detector *dpd, u16 freq)
+{
+ struct channel_detector *cd;
+ list_for_each_entry(cd, &dpd->channel_detectors, head) {
+  if (cd->freq == freq)
+   return cd;
+ }
+ return channel_detector_create(dpd, freq);
+}
+
+/*
+ * DFS Pattern Detector
+ */
+
+/* dpd_reset(): reset all channel detectors */
+static void dpd_reset(struct dfs_pattern_detector *dpd)
+{
+ struct channel_detector *cd;
+ if (!list_empty(&dpd->channel_detectors))
+  list_for_each_entry(cd, &dpd->channel_detectors, head)
+   channel_detector_reset(dpd, cd);
+
+}
+static void dpd_exit(struct dfs_pattern_detector *dpd)
+{
+ struct channel_detector *cd, *cd0;
+ if (!list_empty(&dpd->channel_detectors))
+  list_for_each_entry_safe(cd, cd0, &dpd->channel_detectors, head)
+   channel_detector_exit(dpd, cd);
+ kfree(dpd);
+}
+
+static bool
+dpd_add_pulse(struct dfs_pattern_detector *dpd, struct pulse_event *event)
+{
+ u32 i;
+ struct channel_detector *cd;
+
+ /*
+  * pulses received for a non-supported or un-initialized
+  * domain are treated as detected radars for fail-safety
+  */
+ if (dpd->region == NL80211_DFS_UNSET)
+  return true;
+
+ cd = channel_detector_get(dpd, event->freq);
+ if (cd == NULL)
+  return false;
+
+ dpd->last_pulse_ts = event->ts;
+ /* reset detector on time stamp wraparound, caused by TSF reset */
+ if (event->ts < dpd->last_pulse_ts)
+  dpd_reset(dpd);
+
+ /* do type individual pattern matching */
+ for (i = 0; i < dpd->num_radar_types; i++) {
+  struct pri_detector *pd = cd->detectors[i];
+  struct pri_sequence *ps = pd->add_pulse(pd, event);
+  if (ps != NULL) {
+   ath_dbg(dpd->common, DFS,
+    "DFS: radar found on freq=%d: id=%d, pri=%d, "
+    "count=%d, count_false=%d\n",
+    event->freq, pd->rs->type_id,
+    ps->pri, ps->count, ps->count_falses);
+   channel_detector_reset(dpd, cd);
+   return true;
+  }
+ }
+ return false;
+}
+
+static struct ath_dfs_pool_stats
+dpd_get_stats(struct dfs_pattern_detector *dpd)
+{
+ return global_dfs_pool_stats;
+}
+
+static bool dpd_set_domain(struct dfs_pattern_detector *dpd,
+      enum nl80211_dfs_regions region)
+{
+ const struct radar_types *rt;
+ struct channel_detector *cd, *cd0;
+
+ if (dpd->region == region)
+  return true;
+
+ dpd->region = NL80211_DFS_UNSET;
+
+ rt = get_dfs_domain_radar_types(region);
+ if (rt == NULL)
+  return false;
+
+ /* delete all channel detectors for previous DFS domain */
+ if (!list_empty(&dpd->channel_detectors))
+  list_for_each_entry_safe(cd, cd0, &dpd->channel_detectors, head)
+   channel_detector_exit(dpd, cd);
+ dpd->radar_spec = rt->radar_types;
+ dpd->num_radar_types = rt->num_radar_types;
+
+ dpd->region = region;
+ return true;
+}
+
+static struct dfs_pattern_detector default_dpd = {
+ .exit  = dpd_exit,
+ .set_dfs_domain = dpd_set_domain,
+ .add_pulse = dpd_add_pulse,
+ .get_stats = dpd_get_stats,
+ .region  = NL80211_DFS_UNSET,
+};
+
+struct dfs_pattern_detector *
+dfs_pattern_detector_init(struct ath_common *common,
+     enum nl80211_dfs_regions region)
+{
+ struct dfs_pattern_detector *dpd;
+
+ if (!config_enabled(CONFIG_CFG80211_CERTIFICATION_ONUS))
+  return NULL;
+
+ dpd = kmalloc(sizeof(*dpd), GFP_KERNEL);
+ if (dpd == NULL)
+  return NULL;
+
+ *dpd = default_dpd;
+ INIT_LIST_HEAD(&dpd->channel_detectors);
+
+ dpd->common = common;
+ if (dpd->set_dfs_domain(dpd, region))
+  return dpd;
+
+ ath_dbg(common, DFS,"Could not set DFS domain to %d", region);
+ kfree(dpd);
+ return NULL;
+}
+EXPORT_SYMBOL(dfs_pattern_detector_init);
diff --git a/drivers/net/wireless/ath/dfs_pattern_detector.h b/drivers/net/wireless/ath/dfs_pattern_detector.h
new file mode 100644
index 0000000..dde2652
--- /dev/null
+++ b/drivers/net/wireless/ath/dfs_pattern_detector.h
@@ -0,0 +1,112 @@
+/*
+ * Copyright (c) 2012 Neratec Solutions AG
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef DFS_PATTERN_DETECTOR_H
+#define DFS_PATTERN_DETECTOR_H
+
+#include <linux/types.h>
+#include <linux/list.h>
+#include <linux/nl80211.h>
+
+/**
+ * struct ath_dfs_pool_stats - DFS Statistics for global pools
+ */
+struct ath_dfs_pool_stats {
+ u32 pool_reference;
+ u32 pulse_allocated;
+ u32 pulse_alloc_error;
+ u32 pulse_used;
+ u32 pseq_allocated;
+ u32 pseq_alloc_error;
+ u32 pseq_used;
+};
+
+/**
+ * struct pulse_event - describing pulses reported by PHY
+ * @ts: pulse time stamp in us
+ * @freq: channel frequency in MHz
+ * @width: pulse duration in us
+ * @rssi: rssi of radar event
+ */
+struct pulse_event {
+ u64 ts;
+ u16 freq;
+ u8 width;
+ u8 rssi;
+};
+
+/**
+ * struct radar_detector_specs - detector specs for a radar pattern type
+ * @type_id: pattern type, as defined by regulatory
+ * @width_min: minimum radar pulse width in [us]
+ * @width_max: maximum radar pulse width in [us]
+ * @pri_min: minimum pulse repetition interval in [us] (including tolerance)
+ * @pri_max: minimum pri in [us] (including tolerance)
+ * @num_pri: maximum number of different pri for this type
+ * @ppb: pulses per bursts for this type
+ * @ppb_thresh: number of pulses required to trigger detection
+ * @max_pri_tolerance: pulse time stamp tolerance on both sides [us]
+ */
+struct radar_detector_specs {
+ u8 type_id;
+ u8 width_min;
+ u8 width_max;
+ u16 pri_min;
+ u16 pri_max;
+ u8 num_pri;
+ u8 ppb;
+ u8 ppb_thresh;
+ u8 max_pri_tolerance;
+};
+
+/**
+ * struct dfs_pattern_detector - DFS pattern detector
+ * @exit(): destructor
+ * @set_dfs_domain(): set DFS domain, resets detector lines upon domain changes
+ * @add_pulse(): add radar pulse to detector, returns true on detection
+ * @region: active DFS region, NL80211_DFS_UNSET until set
+ * @num_radar_types: number of different radar types
+ * @last_pulse_ts: time stamp of last valid pulse in usecs
+ * @radar_detector_specs: array of radar detection specs
+ * @channel_detectors: list connecting channel_detector elements
+ */
+struct dfs_pattern_detector {
+ void (*exit)(struct dfs_pattern_detector *dpd);
+ bool (*set_dfs_domain)(struct dfs_pattern_detector *dpd,
+      enum nl80211_dfs_regions region);
+ bool (*add_pulse)(struct dfs_pattern_detector *dpd,
+     struct pulse_event *pe);
+
+ struct ath_dfs_pool_stats (*get_stats)(struct dfs_pattern_detector *dpd);
+ enum nl80211_dfs_regions region;
+ u8 num_radar_types;
+ u64 last_pulse_ts;
+ /* needed for ath_dbg() */
+ struct ath_common *common;
+
+ const struct radar_detector_specs *radar_spec;
+ struct list_head channel_detectors;
+};
+
+/**
+ * dfs_pattern_detector_init() - constructor for pattern detector class
+ * @param region: DFS domain to be used, can be NL80211_DFS_UNSET at creation
+ * @return instance pointer on success, NULL otherwise
+ */
+extern struct dfs_pattern_detector *
+dfs_pattern_detector_init(struct ath_common *common,
+     enum nl80211_dfs_regions region);
+#endif /* DFS_PATTERN_DETECTOR_H */
diff --git a/drivers/net/wireless/ath/dfs_pri_detector.c b/drivers/net/wireless/ath/dfs_pri_detector.c
new file mode 100644
index 0000000..43b6081
--- /dev/null
+++ b/drivers/net/wireless/ath/dfs_pri_detector.c
@@ -0,0 +1,429 @@
+/*
+ * Copyright (c) 2012 Neratec Solutions AG
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+
+#include "ath.h"
+#include "dfs_pattern_detector.h"
+#include "dfs_pri_detector.h"
+
+struct ath_dfs_pool_stats global_dfs_pool_stats = {};
+
+#define DFS_POOL_STAT_INC(c) (global_dfs_pool_stats.c++)
+#define DFS_POOL_STAT_DEC(c) (global_dfs_pool_stats.c--)
+
+/**
+ * struct pulse_elem - elements in pulse queue
+ * @ts: time stamp in usecs
+ */
+struct pulse_elem {
+ struct list_head head;
+ u64 ts;
+};
+
+/**
+ * pde_get_multiple() - get number of multiples considering a given tolerance
+ * @return factor if abs(val - factor*fraction) <= tolerance, 0 otherwise
+ */
+static u32 pde_get_multiple(u32 val, u32 fraction, u32 tolerance)
+{
+ u32 remainder;
+ u32 factor;
+ u32 delta;
+
+ if (fraction == 0)
+  return 0;
+
+ delta = (val < fraction) ? (fraction - val) : (val - fraction);
+
+ if (delta <= tolerance)
+  /* val and fraction are within tolerance */
+  return 1;
+
+ factor = val / fraction;
+ remainder = val % fraction;
+ if (remainder > tolerance) {
+  /* no exact match */
+  if ((fraction - remainder) <= tolerance)
+   /* remainder is within tolerance */
+   factor++;
+  else
+   factor = 0;
+ }
+ return factor;
+}
+
+/**
+ * DOC: Singleton Pulse and Sequence Pools
+ *
+ * Instances of pri_sequence and pulse_elem are kept in singleton pools to
+ * reduce the number of dynamic allocations. They are shared between all
+ * instances and grow up to the peak number of simultaneously used objects.
+ *
+ * Memory is freed after all references to the pools are released.
+ */
+static u32 singleton_pool_references;
+static LIST_HEAD(pulse_pool);
+static LIST_HEAD(pseq_pool);
+static DEFINE_SPINLOCK(pool_lock);
+
+static void pool_register_ref(void)
+{
+ spin_lock_bh(&pool_lock);
+ singleton_pool_references++;
+ DFS_POOL_STAT_INC(pool_reference);
+ spin_unlock_bh(&pool_lock);
+}
+
+static void pool_deregister_ref(void)
+{
+ spin_lock_bh(&pool_lock);
+ singleton_pool_references--;
+ DFS_POOL_STAT_DEC(pool_reference);
+ if (singleton_pool_references == 0) {
+  /* free singleton pools with no references left */
+  struct pri_sequence *ps, *ps0;
+  struct pulse_elem *p, *p0;
+
+  list_for_each_entry_safe(p, p0, &pulse_pool, head) {
+   list_del(&p->head);
+   DFS_POOL_STAT_DEC(pulse_allocated);
+   kfree(p);
+  }
+  list_for_each_entry_safe(ps, ps0, &pseq_pool, head) {
+   list_del(&ps->head);
+   DFS_POOL_STAT_DEC(pseq_allocated);
+   kfree(ps);
+  }
+ }
+ spin_unlock_bh(&pool_lock);
+}
+
+static void pool_put_pulse_elem(struct pulse_elem *pe)
+{
+ spin_lock_bh(&pool_lock);
+ list_add(&pe->head, &pulse_pool);
+ DFS_POOL_STAT_DEC(pulse_used);
+ spin_unlock_bh(&pool_lock);
+}
+
+static void pool_put_pseq_elem(struct pri_sequence *pse)
+{
+ spin_lock_bh(&pool_lock);
+ list_add(&pse->head, &pseq_pool);
+ DFS_POOL_STAT_DEC(pseq_used);
+ spin_unlock_bh(&pool_lock);
+}
+
+static struct pri_sequence *pool_get_pseq_elem(void)
+{
+ struct pri_sequence *pse = NULL;
+ spin_lock_bh(&pool_lock);
+ if (!list_empty(&pseq_pool)) {
+  pse = list_first_entry(&pseq_pool, struct pri_sequence, head);
+  list_del(&pse->head);
+  DFS_POOL_STAT_INC(pseq_used);
+ }
+ spin_unlock_bh(&pool_lock);
+ return pse;
+}
+
+static struct pulse_elem *pool_get_pulse_elem(void)
+{
+ struct pulse_elem *pe = NULL;
+ spin_lock_bh(&pool_lock);
+ if (!list_empty(&pulse_pool)) {
+  pe = list_first_entry(&pulse_pool, struct pulse_elem, head);
+  list_del(&pe->head);
+  DFS_POOL_STAT_INC(pulse_used);
+ }
+ spin_unlock_bh(&pool_lock);
+ return pe;
+}
+
+static struct pulse_elem *pulse_queue_get_tail(struct pri_detector *pde)
+{
+ struct list_head *l = &pde->pulses;
+ if (list_empty(l))
+  return NULL;
+ return list_entry(l->prev, struct pulse_elem, head);
+}
+
+static bool pulse_queue_dequeue(struct pri_detector *pde)
+{
+ struct pulse_elem *p = pulse_queue_get_tail(pde);
+ if (p != NULL) {
+  list_del_init(&p->head);
+  pde->count--;
+  /* give it back to pool */
+  pool_put_pulse_elem(p);
+ }
+ return (pde->count > 0);
+}
+
+/* remove pulses older than window */
+static void pulse_queue_check_window(struct pri_detector *pde)
+{
+ u64 min_valid_ts;
+ struct pulse_elem *p;
+
+ /* there is no delta time with less than 2 pulses */
+ if (pde->count < 2)
+  return;
+
+ if (pde->last_ts <= pde->window_size)
+  return;
+
+ min_valid_ts = pde->last_ts - pde->window_size;
+ while ((p = pulse_queue_get_tail(pde)) != NULL) {
+  if (p->ts >= min_valid_ts)
+   return;
+  pulse_queue_dequeue(pde);
+ }
+}
+
+static bool pulse_queue_enqueue(struct pri_detector *pde, u64 ts)
+{
+ struct pulse_elem *p = pool_get_pulse_elem();
+ if (p == NULL) {
+  p = kmalloc(sizeof(*p), GFP_ATOMIC);
+  if (p == NULL) {
+   DFS_POOL_STAT_INC(pulse_alloc_error);
+   return false;
+  }
+  DFS_POOL_STAT_INC(pulse_allocated);
+  DFS_POOL_STAT_INC(pulse_used);
+ }
+ INIT_LIST_HEAD(&p->head);
+ p->ts = ts;
+ list_add(&p->head, &pde->pulses);
+ pde->count++;
+ pde->last_ts = ts;
+ pulse_queue_check_window(pde);
+ if (pde->count >= pde->max_count)
+  pulse_queue_dequeue(pde);
+ return true;
+}
+
+static bool pseq_handler_create_sequences(struct pri_detector *pde,
+       u64 ts, u32 min_count)
+{
+ struct pulse_elem *p;
+ list_for_each_entry(p, &pde->pulses, head) {
+  struct pri_sequence ps, *new_ps;
+  struct pulse_elem *p2;
+  u32 tmp_false_count;
+  u64 min_valid_ts;
+  u32 delta_ts = ts - p->ts;
+
+  if (delta_ts < pde->rs->pri_min)
+   /* ignore too small pri */
+   continue;
+
+  if (delta_ts > pde->rs->pri_max)
+   /* stop on too large pri (sorted list) */
+   break;
+
+  /* build a new sequence with new potential pri */
+  ps.count = 2;
+  ps.count_falses = 0;
+  ps.first_ts = p->ts;
+  ps.last_ts = ts;
+  ps.pri = ts - p->ts;
+  ps.dur = ps.pri * (pde->rs->ppb - 1)
+    + 2 * pde->rs->max_pri_tolerance;
+
+  p2 = p;
+  tmp_false_count = 0;
+  min_valid_ts = ts - ps.dur;
+  /* check which past pulses are candidates for new sequence */
+  list_for_each_entry_continue(p2, &pde->pulses, head) {
+   u32 factor;
+   if (p2->ts < min_valid_ts)
+    /* stop on crossing window border */
+    break;
+   /* check if pulse match (multi)PRI */
+   factor = pde_get_multiple(ps.last_ts - p2->ts, ps.pri,
+        pde->rs->max_pri_tolerance);
+   if (factor > 0) {
+    ps.count++;
+    ps.first_ts = p2->ts;
+    /*
+     * on match, add the intermediate falses
+     * and reset counter
+     */
+    ps.count_falses += tmp_false_count;
+    tmp_false_count = 0;
+   } else {
+    /* this is a potential false one */
+    tmp_false_count++;
+   }
+  }
+  if (ps.count < min_count)
+   /* did not reach minimum count, drop sequence */
+   continue;
+
+  /* this is a valid one, add it */
+  ps.deadline_ts = ps.first_ts + ps.dur;
+  new_ps = pool_get_pseq_elem();
+  if (new_ps == NULL) {
+   new_ps = kmalloc(sizeof(*new_ps), GFP_ATOMIC);
+   if (new_ps == NULL) {
+    DFS_POOL_STAT_INC(pseq_alloc_error);
+    return false;
+   }
+   DFS_POOL_STAT_INC(pseq_allocated);
+   DFS_POOL_STAT_INC(pseq_used);
+  }
+  memcpy(new_ps, &ps, sizeof(ps));
+  INIT_LIST_HEAD(&new_ps->head);
+  list_add(&new_ps->head, &pde->sequences);
+ }
+ return true;
+}
+
+/* check new ts and add to all matching existing sequences */
+static u32
+pseq_handler_add_to_existing_seqs(struct pri_detector *pde, u64 ts)
+{
+ u32 max_count = 0;
+ struct pri_sequence *ps, *ps2;
+ list_for_each_entry_safe(ps, ps2, &pde->sequences, head) {
+  u32 delta_ts;
+  u32 factor;
+
+  /* first ensure that sequence is within window */
+  if (ts > ps->deadline_ts) {
+   list_del_init(&ps->head);
+   pool_put_pseq_elem(ps);
+   continue;
+  }
+
+  delta_ts = ts - ps->last_ts;
+  factor = pde_get_multiple(delta_ts, ps->pri,
+       pde->rs->max_pri_tolerance);
+  if (factor > 0) {
+   ps->last_ts = ts;
+   ps->count++;
+
+   if (max_count < ps->count)
+    max_count = ps->count;
+  } else {
+   ps->count_falses++;
+  }
+ }
+ return max_count;
+}
+
+static struct pri_sequence *
+pseq_handler_check_detection(struct pri_detector *pde)
+{
+ struct pri_sequence *ps;
+
+ if (list_empty(&pde->sequences))
+  return NULL;
+
+ list_for_each_entry(ps, &pde->sequences, head) {
+  /*
+   * we assume to have enough matching confidence if we
+   * 1) have enough pulses
+   * 2) have more matching than false pulses
+   */
+  if ((ps->count >= pde->rs->ppb_thresh) &&
+      (ps->count * pde->rs->num_pri >= ps->count_falses))
+   return ps;
+ }
+ return NULL;
+}
+
+
+/* free pulse queue and sequences list and give objects back to pools */
+static void pri_detector_reset(struct pri_detector *pde, u64 ts)
+{
+ struct pri_sequence *ps, *ps0;
+ struct pulse_elem *p, *p0;
+ list_for_each_entry_safe(ps, ps0, &pde->sequences, head) {
+  list_del_init(&ps->head);
+  pool_put_pseq_elem(ps);
+ }
+ list_for_each_entry_safe(p, p0, &pde->pulses, head) {
+  list_del_init(&p->head);
+  pool_put_pulse_elem(p);
+ }
+ pde->count = 0;
+ pde->last_ts = ts;
+}
+
+static void pri_detector_exit(struct pri_detector *de)
+{
+ pri_detector_reset(de, 0);
+ pool_deregister_ref();
+ kfree(de);
+}
+
+static struct pri_sequence *pri_detector_add_pulse(struct pri_detector *de,
+         struct pulse_event *event)
+{
+ u32 max_updated_seq;
+ struct pri_sequence *ps;
+ u64 ts = event->ts;
+ const struct radar_detector_specs *rs = de->rs;
+
+ /* ignore pulses not within width range */
+ if ((rs->width_min > event->width) || (rs->width_max < event->width))
+  return NULL;
+
+ if ((ts - de->last_ts) < rs->max_pri_tolerance)
+  /* if delta to last pulse is too short, don't use this pulse */
+  return NULL;
+ de->last_ts = ts;
+
+ max_updated_seq = pseq_handler_add_to_existing_seqs(de, ts);
+
+ if (!pseq_handler_create_sequences(de, ts, max_updated_seq)) {
+  pri_detector_reset(de, ts);
+  return NULL;
+ }
+
+ ps = pseq_handler_check_detection(de);
+
+ if (ps == NULL)
+  pulse_queue_enqueue(de, ts);
+
+ return ps;
+}
+
+struct pri_detector *pri_detector_init(const struct radar_detector_specs *rs)
+{
+ struct pri_detector *de;
+
+ de = kzalloc(sizeof(*de), GFP_ATOMIC);
+ if (de == NULL)
+  return NULL;
+ de->exit = pri_detector_exit;
+ de->add_pulse = pri_detector_add_pulse;
+ de->reset = pri_detector_reset;
+
+ INIT_LIST_HEAD(&de->sequences);
+ INIT_LIST_HEAD(&de->pulses);
+ de->window_size = rs->pri_max * rs->ppb * rs->num_pri;
+ de->max_count = rs->ppb * 2;
+ de->rs = rs;
+
+ pool_register_ref();
+ return de;
+}
diff --git a/drivers/net/wireless/ath/dfs_pri_detector.h b/drivers/net/wireless/ath/dfs_pri_detector.h
new file mode 100644
index 0000000..79f0fff
--- /dev/null
+++ b/drivers/net/wireless/ath/dfs_pri_detector.h
@@ -0,0 +1,77 @@
+/*
+ * Copyright (c) 2012 Neratec Solutions AG
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef DFS_PRI_DETECTOR_H
+#define DFS_PRI_DETECTOR_H
+
+#include <linux/list.h>
+
+extern struct ath_dfs_pool_stats global_dfs_pool_stats;
+
+/**
+ * struct pri_sequence - sequence of pulses matching one PRI
+ * @head: list_head
+ * @pri: pulse repetition interval (PRI) in usecs
+ * @dur: duration of sequence in usecs
+ * @count: number of pulses in this sequence
+ * @count_falses: number of not matching pulses in this sequence
+ * @first_ts: time stamp of first pulse in usecs
+ * @last_ts: time stamp of last pulse in usecs
+ * @deadline_ts: deadline when this sequence becomes invalid (first_ts + dur)
+ */
+struct pri_sequence {
+ struct list_head head;
+ u32 pri;
+ u32 dur;
+ u32 count;
+ u32 count_falses;
+ u64 first_ts;
+ u64 last_ts;
+ u64 deadline_ts;
+};
+
+/**
+ * struct pri_detector - PRI detector element for a dedicated radar type
+ * @exit(): destructor
+ * @add_pulse(): add pulse event, returns pri_sequence if pattern was detected
+ * @reset(): clear states and reset to given time stamp
+ * @rs: detector specs for this detector element
+ * @last_ts: last pulse time stamp considered for this element in usecs
+ * @sequences: list_head holding potential pulse sequences
+ * @pulses: list connecting pulse_elem objects
+ * @count: number of pulses in queue
+ * @max_count: maximum number of pulses to be queued
+ * @window_size: window size back from newest pulse time stamp in usecs
+ */
+struct pri_detector {
+ void (*exit)     (struct pri_detector *de);
+ struct pri_sequence *
+      (*add_pulse)(struct pri_detector *de, struct pulse_event *e);
+ void (*reset)    (struct pri_detector *de, u64 ts);
+
+/* private: internal use only */
+ const struct radar_detector_specs *rs;
+ u64 last_ts;
+ struct list_head sequences;
+ struct list_head pulses;
+ u32 count;
+ u32 max_count;
+ u32 window_size;
+};
+
+struct pri_detector *pri_detector_init(const struct radar_detector_specs *rs);
+
+#endif /* DFS_PRI_DETECTOR_H */
diff --git a/drivers/net/wireless/ath/main.c b/drivers/net/wireless/ath/main.c
index 8e99540..8b0ac14 100644
--- a/drivers/net/wireless/ath/main.c
+++ b/drivers/net/wireless/ath/main.c
@@ -59,6 +59,14 @@ struct sk_buff *ath_rxbuf_alloc(struct ath_common *common,
 }
 EXPORT_SYMBOL(ath_rxbuf_alloc);
 
+bool ath_is_mybeacon(struct ath_common *common, struct ieee80211_hdr *hdr)
+{
+ return ieee80211_is_beacon(hdr->frame_control) &&
+  !is_zero_ether_addr(common->curbssid) &&
+  ether_addr_equal_64bits(hdr->addr3, common->curbssid);
+}
+EXPORT_SYMBOL(ath_is_mybeacon);
+
 void ath_printk(const char *level, const struct ath_common* common,
   const char *fmt, ...)
 {
diff --git a/drivers/net/wireless/ath/regd.c b/drivers/net/wireless/ath/regd.c
index ccc4c71..415393d 100644
--- a/drivers/net/wireless/ath/regd.c
+++ b/drivers/net/wireless/ath/regd.c
@@ -37,17 +37,18 @@ static int __ath_regd_init(struct ath_regulatory *reg);
 
 /* We enable active scan on these a case by case basis by regulatory domain */
 #define ATH9K_2GHZ_CH12_13 REG_RULE(2467-10, 2472+10, 40, 0, 20,\
-     NL80211_RRF_PASSIVE_SCAN)
+      NL80211_RRF_NO_IR)
 #define ATH9K_2GHZ_CH14  REG_RULE(2484-10, 2484+10, 40, 0, 20,\
-    NL80211_RRF_PASSIVE_SCAN | NL80211_RRF_NO_OFDM)
+      NL80211_RRF_NO_IR | \
+      NL80211_RRF_NO_OFDM)
 
 /* We allow IBSS on these on a case by case basis by regulatory domain */
-#define ATH9K_5GHZ_5150_5350 REG_RULE(5150-10, 5350+10, 40, 0, 30,\
-    NL80211_RRF_PASSIVE_SCAN | NL80211_RRF_NO_IBSS)
-#define ATH9K_5GHZ_5470_5850 REG_RULE(5470-10, 5850+10, 40, 0, 30,\
-    NL80211_RRF_PASSIVE_SCAN | NL80211_RRF_NO_IBSS)
-#define ATH9K_5GHZ_5725_5850 REG_RULE(5725-10, 5850+10, 40, 0, 30,\
-    NL80211_RRF_PASSIVE_SCAN | NL80211_RRF_NO_IBSS)
+#define ATH9K_5GHZ_5150_5350 REG_RULE(5150-10, 5350+10, 80, 0, 30,\
+      NL80211_RRF_NO_IR)
+#define ATH9K_5GHZ_5470_5850 REG_RULE(5470-10, 5850+10, 80, 0, 30,\
+      NL80211_RRF_NO_IR)
+#define ATH9K_5GHZ_5725_5850 REG_RULE(5725-10, 5850+10, 80, 0, 30,\
+      NL80211_RRF_NO_IR)
 
 #define ATH9K_2GHZ_ALL  ATH9K_2GHZ_CH01_11, \
     ATH9K_2GHZ_CH12_13, \
@@ -113,6 +114,87 @@ static const struct ieee80211_regdomain ath_world_regdom_67_68_6A_6C = {
  }
 };
 
+static bool dynamic_country_user_possible(struct ath_regulatory *reg)
+{
+ if (config_enabled(CONFIG_ATH_REG_DYNAMIC_USER_CERT_TESTING))
+  return true;
+
+ switch (reg->country_code) {
+ case CTRY_UNITED_STATES:
+ case CTRY_JAPAN1:
+ case CTRY_JAPAN2:
+ case CTRY_JAPAN3:
+ case CTRY_JAPAN4:
+ case CTRY_JAPAN5:
+ case CTRY_JAPAN6:
+ case CTRY_JAPAN7:
+ case CTRY_JAPAN8:
+ case CTRY_JAPAN9:
+ case CTRY_JAPAN10:
+ case CTRY_JAPAN11:
+ case CTRY_JAPAN12:
+ case CTRY_JAPAN13:
+ case CTRY_JAPAN14:
+ case CTRY_JAPAN15:
+ case CTRY_JAPAN16:
+ case CTRY_JAPAN17:
+ case CTRY_JAPAN18:
+ case CTRY_JAPAN19:
+ case CTRY_JAPAN20:
+ case CTRY_JAPAN21:
+ case CTRY_JAPAN22:
+ case CTRY_JAPAN23:
+ case CTRY_JAPAN24:
+ case CTRY_JAPAN25:
+ case CTRY_JAPAN26:
+ case CTRY_JAPAN27:
+ case CTRY_JAPAN28:
+ case CTRY_JAPAN29:
+ case CTRY_JAPAN30:
+ case CTRY_JAPAN31:
+ case CTRY_JAPAN32:
+ case CTRY_JAPAN33:
+ case CTRY_JAPAN34:
+ case CTRY_JAPAN35:
+ case CTRY_JAPAN36:
+ case CTRY_JAPAN37:
+ case CTRY_JAPAN38:
+ case CTRY_JAPAN39:
+ case CTRY_JAPAN40:
+ case CTRY_JAPAN41:
+ case CTRY_JAPAN42:
+ case CTRY_JAPAN43:
+ case CTRY_JAPAN44:
+ case CTRY_JAPAN45:
+ case CTRY_JAPAN46:
+ case CTRY_JAPAN47:
+ case CTRY_JAPAN48:
+ case CTRY_JAPAN49:
+ case CTRY_JAPAN50:
+ case CTRY_JAPAN51:
+ case CTRY_JAPAN52:
+ case CTRY_JAPAN53:
+ case CTRY_JAPAN54:
+ case CTRY_JAPAN55:
+ case CTRY_JAPAN56:
+ case CTRY_JAPAN57:
+ case CTRY_JAPAN58:
+ case CTRY_JAPAN59:
+  return false;
+ }
+
+ return true;
+}
+
+static bool ath_reg_dyn_country_user_allow(struct ath_regulatory *reg)
+{
+ if (!config_enabled(CONFIG_ATH_REG_DYNAMIC_USER_REG_HINTS))
+  return false;
+ if (!dynamic_country_user_possible(reg))
+  return false;
+ return true;
+}
+
 static inline bool is_wwr_sku(u16 regd)
 {
  return ((regd & COUNTRY_ERD_FLAG) != COUNTRY_ERD_FLAG) &&
@@ -140,7 +222,7 @@ static const struct ieee80211_regdomain *ath_default_world_regdomain(void)
 static const struct
 ieee80211_regdomain *ath_world_regdomain(struct ath_regulatory *reg)
 {
- switch (reg->regpair->regDmnEnum) {
+ switch (reg->regpair->reg_domain) {
  case 0x60:
  case 0x61:
  case 0x62:
@@ -177,118 +259,139 @@ static bool ath_is_radar_freq(u16 center_freq)
  return (center_freq >= 5260 && center_freq <= 5700);
 }
 
+static void ath_force_clear_no_ir_chan(struct wiphy *wiphy,
+           struct ieee80211_channel *ch)
+{
+ const struct ieee80211_reg_rule *reg_rule;
+
+ reg_rule = freq_reg_info(wiphy, MHZ_TO_KHZ(ch->center_freq));
+ if (IS_ERR(reg_rule))
+  return;
+
+ if (!(reg_rule->flags & NL80211_RRF_NO_IR))
+  if (ch->flags & IEEE80211_CHAN_NO_IR)
+   ch->flags &= ~IEEE80211_CHAN_NO_IR;
+}
+
+static void ath_force_clear_no_ir_freq(struct wiphy *wiphy, u16 center_freq)
+{
+ struct ieee80211_channel *ch;
+
+ ch = ieee80211_get_channel(wiphy, center_freq);
+ if (!ch)
+  return;
+
+ ath_force_clear_no_ir_chan(wiphy, ch);
+}
+
+static void ath_force_no_ir_chan(struct ieee80211_channel *ch)
+{
+ ch->flags |= IEEE80211_CHAN_NO_IR;
+}
+
+static void ath_force_no_ir_freq(struct wiphy *wiphy, u16 center_freq)
+{
+ struct ieee80211_channel *ch;
+
+ ch = ieee80211_get_channel(wiphy, center_freq);
+ if (!ch)
+  return;
+
+ ath_force_no_ir_chan(ch);
+}
+
+static void
+__ath_reg_apply_beaconing_flags(struct wiphy *wiphy,
+    struct ath_regulatory *reg,
+    enum nl80211_reg_initiator initiator,
+    struct ieee80211_channel *ch)
+{
+ if (ath_is_radar_freq(ch->center_freq) ||
+     (ch->flags & IEEE80211_CHAN_RADAR))
+  return;
+
+ switch (initiator) {
+ case NL80211_REGDOM_SET_BY_COUNTRY_IE:
+  ath_force_clear_no_ir_chan(wiphy, ch);
+  break;
+ case NL80211_REGDOM_SET_BY_USER:
+  if (ath_reg_dyn_country_user_allow(reg))
+   ath_force_clear_no_ir_chan(wiphy, ch);
+  break;
+ default:
+  if (ch->beacon_found)
+   ch->flags &= ~IEEE80211_CHAN_NO_IR;
+ }
+}
+
 /*
- * N.B: These exception rules do not apply radar freqs.
+ * These exception rules do not apply radar frequencies.
  *
- * - We enable adhoc (or beaconing) if allowed by 11d
- * - We enable active scan if the channel is allowed by 11d
+ * - We enable initiating radiation if the country IE says its fine:
  * - If no country IE has been processed and a we determine we have
- *   received a beacon on a channel we can enable active scan and
- *   adhoc (or beaconing).
+ *   received a beacon on a channel we can enable initiating radiation.
  */
 static void
 ath_reg_apply_beaconing_flags(struct wiphy *wiphy,
+         struct ath_regulatory *reg,
          enum nl80211_reg_initiator initiator)
 {
  enum ieee80211_band band;
  struct ieee80211_supported_band *sband;
- const struct ieee80211_reg_rule *reg_rule;
  struct ieee80211_channel *ch;
  unsigned int i;
 
  for (band = 0; band < IEEE80211_NUM_BANDS; band++) {
-
   if (!wiphy->bands[band])
    continue;
-
   sband = wiphy->bands[band];
-
   for (i = 0; i < sband->n_channels; i++) {
-
    ch = &sband->channels[i];
-
-   if (ath_is_radar_freq(ch->center_freq) ||
-       (ch->flags & IEEE80211_CHAN_RADAR))
-    continue;
-
-   if (initiator == NL80211_REGDOM_SET_BY_COUNTRY_IE) {
-    reg_rule = freq_reg_info(wiphy, ch->center_freq);
-    if (IS_ERR(reg_rule))
-     continue;
-    /*
-     * If 11d had a rule for this channel ensure
-     * we enable adhoc/beaconing if it allows us to
-     * use it. Note that we would have disabled it
-     * by applying our static world regdomain by
-     * default during init, prior to calling our
-     * regulatory_hint().
-     */
-    if (!(reg_rule->flags &
-        NL80211_RRF_NO_IBSS))
-     ch->flags &=
-       ~IEEE80211_CHAN_NO_IBSS;
-    if (!(reg_rule->flags &
-        NL80211_RRF_PASSIVE_SCAN))
-     ch->flags &=
-       ~IEEE80211_CHAN_PASSIVE_SCAN;
-   } else {
-    if (ch->beacon_found)
-     ch->flags &= ~(IEEE80211_CHAN_NO_IBSS |
-       IEEE80211_CHAN_PASSIVE_SCAN);
-   }
+   __ath_reg_apply_beaconing_flags(wiphy, reg,
+       initiator, ch);
   }
  }
-
 }
 
-/* Allows active scan scan on Ch 12 and 13 */
+/**
+ * ath_reg_apply_ir_flags()
+ * @wiphy: the wiphy to use
+ * @initiator: the regulatory hint initiator
+ *
+ * If no country IE has been received always enable passive scan
+ * and no-ibss on these channels. This is only done for specific
+ * regulatory SKUs.
+ *
+ * If a country IE has been received check its rule for this
+ * channel first before enabling active scan. The passive scan
+ * would have been enforced by the initial processing of our
+ * custom regulatory domain.
+ */
 static void
-ath_reg_apply_active_scan_flags(struct wiphy *wiphy,
-    enum nl80211_reg_initiator initiator)
+ath_reg_apply_ir_flags(struct wiphy *wiphy,
+         struct ath_regulatory *reg,
+         enum nl80211_reg_initiator initiator)
 {
  struct ieee80211_supported_band *sband;
- struct ieee80211_channel *ch;
- const struct ieee80211_reg_rule *reg_rule;
 
  sband = wiphy->bands[IEEE80211_BAND_2GHZ];
  if (!sband)
   return;
 
- /*
-  * If no country IE has been received always enable active scan
-  * on these channels. This is only done for specific regulatory SKUs
-  */
- if (initiator != NL80211_REGDOM_SET_BY_COUNTRY_IE) {
-  ch = &sband->channels[11]; /* CH 12 */
-  if (ch->flags & IEEE80211_CHAN_PASSIVE_SCAN)
-   ch->flags &= ~IEEE80211_CHAN_PASSIVE_SCAN;
-  ch = &sband->channels[12]; /* CH 13 */
-  if (ch->flags & IEEE80211_CHAN_PASSIVE_SCAN)
-   ch->flags &= ~IEEE80211_CHAN_PASSIVE_SCAN;
-  return;
- }
-
- /*
-  * If a country IE has been received check its rule for this
-  * channel first before enabling active scan. The passive scan
-  * would have been enforced by the initial processing of our
-  * custom regulatory domain.
-  */
-
- ch = &sband->channels[11]; /* CH 12 */
- reg_rule = freq_reg_info(wiphy, ch->center_freq);
- if (!IS_ERR(reg_rule)) {
-  if (!(reg_rule->flags & NL80211_RRF_PASSIVE_SCAN))
-   if (ch->flags & IEEE80211_CHAN_PASSIVE_SCAN)
-    ch->flags &= ~IEEE80211_CHAN_PASSIVE_SCAN;
- }
-
- ch = &sband->channels[12]; /* CH 13 */
- reg_rule = freq_reg_info(wiphy, ch->center_freq);
- if (!IS_ERR(reg_rule)) {
-  if (!(reg_rule->flags & NL80211_RRF_PASSIVE_SCAN))
-   if (ch->flags & IEEE80211_CHAN_PASSIVE_SCAN)
-    ch->flags &= ~IEEE80211_CHAN_PASSIVE_SCAN;
+ switch(initiator) {
+ case NL80211_REGDOM_SET_BY_COUNTRY_IE:
+  ath_force_clear_no_ir_freq(wiphy, 2467);
+  ath_force_clear_no_ir_freq(wiphy, 2472);
+  break;
+ case NL80211_REGDOM_SET_BY_USER:
+  if (!ath_reg_dyn_country_user_allow(reg))
+   break;
+  ath_force_clear_no_ir_freq(wiphy, 2467);
+  ath_force_clear_no_ir_freq(wiphy, 2472);
+  break;
+ default:
+  ath_force_no_ir_freq(wiphy, 2467);
+  ath_force_no_ir_freq(wiphy, 2472);
  }
 }
 
@@ -320,8 +423,7 @@ static void ath_reg_apply_radar_flags(struct wiphy *wiphy)
    */
   if (!(ch->flags & IEEE80211_CHAN_DISABLED))
    ch->flags |= IEEE80211_CHAN_RADAR |
-         IEEE80211_CHAN_NO_IBSS |
-         IEEE80211_CHAN_PASSIVE_SCAN;
+         IEEE80211_CHAN_NO_IR;
  }
 }
 
@@ -329,18 +431,21 @@ static void ath_reg_apply_world_flags(struct wiphy *wiphy,
           enum nl80211_reg_initiator initiator,
           struct ath_regulatory *reg)
 {
- switch (reg->regpair->regDmnEnum) {
+ switch (reg->regpair->reg_domain) {
  case 0x60:
  case 0x63:
  case 0x66:
  case 0x67:
  case 0x6C:
-  ath_reg_apply_beaconing_flags(wiphy, initiator);
+  ath_reg_apply_beaconing_flags(wiphy, reg, initiator);
   break;
  case 0x68:
-  ath_reg_apply_beaconing_flags(wiphy, initiator);
-  ath_reg_apply_active_scan_flags(wiphy, initiator);
+  ath_reg_apply_beaconing_flags(wiphy, reg, initiator);
+  ath_reg_apply_ir_flags(wiphy, reg, initiator);
   break;
+ default:
+  if (ath_reg_dyn_country_user_allow(reg))
+   ath_reg_apply_beaconing_flags(wiphy, reg, initiator);
  }
 }
 
@@ -356,14 +461,49 @@ static u16 ath_regd_find_country_by_name(char *alpha2)
  return -1;
 }
 
+static int __ath_reg_dyn_country(struct wiphy *wiphy,
+     struct ath_regulatory *reg,
+     struct regulatory_request *request)
+{
+ u16 country_code;
+
+ if (request->initiator == NL80211_REGDOM_SET_BY_COUNTRY_IE &&
+     !ath_is_world_regd(reg))
+  return -EINVAL;
+
+ country_code = ath_regd_find_country_by_name(request->alpha2);
+ if (country_code == (u16) -1)
+  return -EINVAL;
+
+ reg->current_rd = COUNTRY_ERD_FLAG;
+ reg->current_rd |= country_code;
+
+ __ath_regd_init(reg);
+
+ ath_reg_apply_world_flags(wiphy, request->initiator, reg);
+
+ return 0;
+}
+
+static void ath_reg_dyn_country(struct wiphy *wiphy,
+    struct ath_regulatory *reg,
+    struct regulatory_request *request)
+{
+ if (__ath_reg_dyn_country(wiphy, reg, request))
+  return;
+
+ printk(KERN_DEBUG "ath: regdomain 0x%0x "
+     "dynamically updated by %s\n",
+        reg->current_rd,
+        reg_initiator_name(request->initiator));
+}
+
 void ath_reg_notifier_apply(struct wiphy *wiphy,
        struct regulatory_request *request,
        struct ath_regulatory *reg)
 {
  struct ath_common *common = container_of(reg, struct ath_common,
        regulatory);
- u16 country_code;
-
  /* We always apply this */
  ath_reg_apply_radar_flags(wiphy);
 
@@ -388,25 +528,13 @@ void ath_reg_notifier_apply(struct wiphy *wiphy,
          sizeof(struct ath_regulatory));
   break;
  case NL80211_REGDOM_SET_BY_DRIVER:
+  break;
  case NL80211_REGDOM_SET_BY_USER:
+  if (ath_reg_dyn_country_user_allow(reg))
+   ath_reg_dyn_country(wiphy, reg, request);
   break;
  case NL80211_REGDOM_SET_BY_COUNTRY_IE:
-  if (!ath_is_world_regd(reg))
-   break;
-
-  country_code = ath_regd_find_country_by_name(request->alpha2);
-  if (country_code == (u16) -1)
-   break;
-
-  reg->current_rd = COUNTRY_ERD_FLAG;
-  reg->current_rd |= country_code;
-
-  printk(KERN_DEBUG "ath: regdomain 0x%0x updated by CountryIE\n",
-   reg->current_rd);
-  __ath_regd_init(reg);
-
-  ath_reg_apply_world_flags(wiphy, request->initiator, reg);
-
+  ath_reg_dyn_country(wiphy, reg, request);
   break;
  }
 }
@@ -432,7 +560,7 @@ static bool ath_regd_is_eeprom_valid(struct ath_regulatory *reg)
    printk(KERN_DEBUG "ath: EEPROM indicates we "
           "should expect a direct regpair map\n");
   for (i = 0; i < ARRAY_SIZE(regDomainPairs); i++)
-   if (regDomainPairs[i].regDmnEnum == rd)
+   if (regDomainPairs[i].reg_domain == rd)
     return true;
  }
  printk(KERN_DEBUG
@@ -489,7 +617,7 @@ ath_get_regpair(int regdmn)
  if (regdmn == NO_ENUMRD)
   return NULL;
  for (i = 0; i < ARRAY_SIZE(regDomainPairs); i++) {
-  if (regDomainPairs[i].regDmnEnum == regdmn)
+  if (regDomainPairs[i].reg_domain == regdmn)
    return &regDomainPairs[i];
  }
  return NULL;
@@ -504,7 +632,8 @@ ath_regd_init_wiphy(struct ath_regulatory *reg,
  const struct ieee80211_regdomain *regd;
 
  wiphy->reg_notifier = reg_notifier;
- wiphy->flags |= WIPHY_FLAG_STRICT_REGULATORY;
+ wiphy->regulatory_flags |= REGULATORY_STRICT_REG |
+       REGULATORY_CUSTOM_REG;
 
  if (ath_is_world_regd(reg)) {
   /*
@@ -512,7 +641,7 @@ ath_regd_init_wiphy(struct ath_regulatory *reg,
    * saved on the wiphy orig_* parameters
    */
   regd = ath_world_regdomain(reg);
-  wiphy->flags |= WIPHY_FLAG_CUSTOM_REGULATORY;
+  wiphy->regulatory_flags |= REGULATORY_COUNTRY_IE_FOLLOW_POWER;
  } else {
   /*
    * This gets applied in the case of the absence of CRDA,
@@ -521,6 +650,7 @@ ath_regd_init_wiphy(struct ath_regulatory *reg,
    */
   regd = ath_default_world_regdomain();
  }
+
  wiphy_apply_custom_regulatory(wiphy, regd);
  ath_reg_apply_radar_flags(wiphy);
  ath_reg_apply_world_flags(wiphy, NL80211_REGDOM_SET_BY_DRIVER, reg);
@@ -611,7 +741,7 @@ static int __ath_regd_init(struct ath_regulatory *reg)
  printk(KERN_DEBUG "ath: Country alpha2 being used: %c%c\n",
   reg->alpha2[0], reg->alpha2[1]);
  printk(KERN_DEBUG "ath: Regpair used: 0x%0x\n",
-  reg->regpair->regDmnEnum);
+  reg->regpair->reg_domain);
 
  return 0;
 }
diff --git a/drivers/net/wireless/ath/wil6210/Kconfig b/drivers/net/wireless/ath/wil6210/Kconfig
index bac3d98..ce8c038 100644
--- a/drivers/net/wireless/ath/wil6210/Kconfig
+++ b/drivers/net/wireless/ath/wil6210/Kconfig
@@ -27,3 +27,15 @@ config WIL6210_ISR_COR
    self-clear when accessed for debug purposes, it makes
    such monitoring impossible.
    Say y unless you debug interrupts
+
+config WIL6210_TRACING
+ bool "wil6210 tracing support"
+ depends on WIL6210
+ depends on EVENT_TRACING
+ default y
+ ---help---
+   Say Y here to enable tracepoints for the wil6210 driver
+   using the kernel tracing infrastructure.  Select this
+   option if you are interested in debugging the driver.
+
+   If unsure, say Y to make it easier to debug problems.
diff --git a/drivers/net/wireless/ath/wil6210/Makefile b/drivers/net/wireless/ath/wil6210/Makefile
index d288eea..c7a3465 100644
--- a/drivers/net/wireless/ath/wil6210/Makefile
+++ b/drivers/net/wireless/ath/wil6210/Makefile
@@ -1,15 +1,18 @@
 obj-$(CONFIG_WIL6210) += wil6210.o
 
-wil6210-objs := main.o
-wil6210-objs += netdev.o
-wil6210-objs += cfg80211.o
-wil6210-objs += pcie_bus.o
-wil6210-objs += debugfs.o
-wil6210-objs += wmi.o
-wil6210-objs += interrupt.o
-wil6210-objs += txrx.o
+wil6210-y := main.o
+wil6210-y += netdev.o
+wil6210-y += cfg80211.o
+wil6210-y += pcie_bus.o
+wil6210-y += debugfs.o
+wil6210-y += wmi.o
+wil6210-y += interrupt.o
+wil6210-y += txrx.o
+wil6210-y += debug.o
+wil6210-y += rx_reorder.o
+wil6210-$(CONFIG_WIL6210_TRACING) += trace.o
+
+# for tracing framework to find trace.h
+CFLAGS_trace.o := -I$(src)
 
-ifeq (, $(findstring -W,$(EXTRA_CFLAGS)))
- subdir-ccflags-y += -Werror
-endif
 subdir-ccflags-y += -D__CHECK_ENDIAN__
diff --git a/drivers/net/wireless/ath/wil6210/cfg80211.c b/drivers/net/wireless/ath/wil6210/cfg80211.c
index c5d4a87..820d4eb 100644
--- a/drivers/net/wireless/ath/wil6210/cfg80211.c
+++ b/drivers/net/wireless/ath/wil6210/cfg80211.c
@@ -104,41 +104,125 @@ int wil_iftype_nl2wmi(enum nl80211_iftype type)
  return -EOPNOTSUPP;
 }
 
-static int wil_cfg80211_get_station(struct wiphy *wiphy,
-        struct net_device *ndev,
-        u8 *mac, struct station_info *sinfo)
+static int wil_cid_fill_sinfo(struct wil6210_priv *wil, int cid,
+         struct station_info *sinfo)
 {
- struct wil6210_priv *wil = wiphy_to_wil(wiphy);
- int rc;
  struct wmi_notify_req_cmd cmd = {
-  .cid = 0,
+  .cid = cid,
   .interval_usec = 0,
  };
+ struct {
+  struct wil6210_mbox_hdr_wmi wmi;
+  struct wmi_notify_req_done_event evt;
+ } __packed reply;
+ struct wil_net_stats *stats = &wil->sta[cid].stats;
+ int rc;
 
- if (memcmp(mac, wil->dst_addr[0], ETH_ALEN))
-  return -ENOENT;
-
- /* WMI_NOTIFY_REQ_DONE_EVENTID handler fills wil->stats.bf_mcs */
  rc = wmi_call(wil, WMI_NOTIFY_REQ_CMDID, &cmd, sizeof(cmd),
-        WMI_NOTIFY_REQ_DONE_EVENTID, NULL, 0, 20);
+        WMI_NOTIFY_REQ_DONE_EVENTID, &reply, sizeof(reply), 20);
  if (rc)
   return rc;
 
+ wil_dbg_wmi(wil, "Link status for CID %d: {\n"
+      "  MCS %d TSF 0x%016llx\n"
+      "  BF status 0x%08x SNR 0x%08x SQI %d%%\n"
+      "  Tx Tpt %d goodput %d Rx goodput %d\n"
+      "  Sectors(rx:tx) my %d:%d peer %d:%d\n""}\n",
+      cid, le16_to_cpu(reply.evt.bf_mcs),
+      le64_to_cpu(reply.evt.tsf), reply.evt.status,
+      le32_to_cpu(reply.evt.snr_val),
+      reply.evt.sqi,
+      le32_to_cpu(reply.evt.tx_tpt),
+      le32_to_cpu(reply.evt.tx_goodput),
+      le32_to_cpu(reply.evt.rx_goodput),
+      le16_to_cpu(reply.evt.my_rx_sector),
+      le16_to_cpu(reply.evt.my_tx_sector),
+      le16_to_cpu(reply.evt.other_rx_sector),
+      le16_to_cpu(reply.evt.other_tx_sector));
+
  sinfo->generation = wil->sinfo_gen;
 
- sinfo->filled |= STATION_INFO_TX_BITRATE;
+ sinfo->filled = STATION_INFO_RX_BYTES |
+   STATION_INFO_TX_BYTES |
+   STATION_INFO_RX_PACKETS |
+   STATION_INFO_TX_PACKETS |
+   STATION_INFO_RX_BITRATE |
+   STATION_INFO_TX_BITRATE |
+   STATION_INFO_RX_DROP_MISC |
+   STATION_INFO_TX_FAILED;
+
  sinfo->txrate.flags = RATE_INFO_FLAGS_MCS | RATE_INFO_FLAGS_60G;
- sinfo->txrate.mcs = wil->stats.bf_mcs;
- sinfo->filled |= STATION_INFO_RX_BITRATE;
+ sinfo->txrate.mcs = le16_to_cpu(reply.evt.bf_mcs);
  sinfo->rxrate.flags = RATE_INFO_FLAGS_MCS | RATE_INFO_FLAGS_60G;
- sinfo->rxrate.mcs = wil->stats.last_mcs_rx;
+ sinfo->rxrate.mcs = stats->last_mcs_rx;
+ sinfo->rx_bytes = stats->rx_bytes;
+ sinfo->rx_packets = stats->rx_packets;
+ sinfo->rx_dropped_misc = stats->rx_dropped;
+ sinfo->tx_bytes = stats->tx_bytes;
+ sinfo->tx_packets = stats->tx_packets;
+ sinfo->tx_failed = stats->tx_errors;
 
  if (test_bit(wil_status_fwconnected, &wil->status)) {
   sinfo->filled |= STATION_INFO_SIGNAL;
-  sinfo->signal = 12; /* TODO: provide real value */
+  sinfo->signal = reply.evt.sqi;
  }
 
- return 0;
+ return rc;
+}
+
+static int wil_cfg80211_get_station(struct wiphy *wiphy,
+        struct net_device *ndev,
+        const u8 *mac, struct station_info *sinfo)
+{
+ struct wil6210_priv *wil = wiphy_to_wil(wiphy);
+ int rc;
+
+ int cid = wil_find_cid(wil, mac);
+
+ wil_dbg_misc(wil, "%s(%pM) CID %d\n", __func__, mac, cid);
+ if (cid < 0)
+  return cid;
+
+ rc = wil_cid_fill_sinfo(wil, cid, sinfo);
+
+ return rc;
+}
+
+/*
+ * Find @idx-th active STA for station dump.
+ */
+static int wil_find_cid_by_idx(struct wil6210_priv *wil, int idx)
+{
+ int i;
+
+ for (i = 0; i < ARRAY_SIZE(wil->sta); i++) {
+  if (wil->sta[i].status == wil_sta_unused)
+   continue;
+  if (idx == 0)
+   return i;
+  idx--;
+ }
+
+ return -ENOENT;
+}
+
+static int wil_cfg80211_dump_station(struct wiphy *wiphy,
+         struct net_device *dev, int idx,
+         u8 *mac, struct station_info *sinfo)
+{
+ struct wil6210_priv *wil = wiphy_to_wil(wiphy);
+ int rc;
+ int cid = wil_find_cid_by_idx(wil, idx);
+
+ if (cid < 0)
+  return -ENOENT;
+
+ memcpy(mac, wil->sta[cid].addr, ETH_ALEN);
+ wil_dbg_misc(wil, "%s(%pM) CID %d\n", __func__, mac, cid);
+
+ rc = wil_cid_fill_sinfo(wil, cid, sinfo);
+
+ return rc;
 }
 
 static int wil_cfg80211_change_iface(struct wiphy *wiphy,
@@ -181,6 +265,7 @@ static int wil_cfg80211_scan(struct wiphy *wiphy,
   u16 chnl[4];
  } __packed cmd;
  uint i, n;
+ int rc;
 
  if (wil->scan_request) {
   wil_err(wil, "Already scanning\n");
@@ -198,11 +283,12 @@ static int wil_cfg80211_scan(struct wiphy *wiphy,
 
  /* FW don't support scan after connection attempt */
  if (test_bit(wil_status_dontscan, &wil->status)) {
-  wil_err(wil, "Scan after connect attempt not supported\n");
+  wil_err(wil, "Can't scan now\n");
   return -EBUSY;
  }
 
  wil->scan_request = request;
+ mod_timer(&wil->scan_timer, jiffies + WIL6210_SCAN_TO);
 
  memset(&cmd, 0, sizeof(cmd));
  cmd.cmd.num_channels = 0;
@@ -221,8 +307,13 @@ static int wil_cfg80211_scan(struct wiphy *wiphy,
         request->channels[i]->center_freq);
  }
 
- return wmi_send(wil, WMI_START_SCAN_CMDID, &cmd, sizeof(cmd.cmd) +
+ rc = wmi_send(wil, WMI_START_SCAN_CMDID, &cmd, sizeof(cmd.cmd) +
    cmd.cmd.num_channels * sizeof(cmd.cmd.channel_list[0]));
+
+ if (rc)
+  wil->scan_request = NULL;
+
+ return rc;
 }
 
 static int wil_cfg80211_connect(struct wiphy *wiphy,
@@ -237,6 +328,10 @@ static int wil_cfg80211_connect(struct wiphy *wiphy,
  int ch;
  int rc = 0;
 
+ if (test_bit(wil_status_fwconnecting, &wil->status) ||
+     test_bit(wil_status_fwconnected, &wil->status))
+  return -EALREADY;
+
  bss = cfg80211_get_bss(wiphy, sme->channel, sme->bssid,
           sme->ssid, sme->ssid_len,
           WLAN_CAPABILITY_ESS, WLAN_CAPABILITY_ESS);
@@ -316,18 +411,18 @@ static int wil_cfg80211_connect(struct wiphy *wiphy,
  }
  conn.channel = ch - 1;
 
- memcpy(conn.bssid, bss->bssid, 6);
- memcpy(conn.dst_mac, bss->bssid, 6);
- /*
-  * FW don't support scan after connection attempt
-  */
- set_bit(wil_status_dontscan, &wil->status);
+ memcpy(conn.bssid, bss->bssid, ETH_ALEN);
+ memcpy(conn.dst_mac, bss->bssid, ETH_ALEN);
+
+ set_bit(wil_status_fwconnecting, &wil->status);
 
  rc = wmi_send(wil, WMI_CONNECT_CMDID, &conn, sizeof(conn));
  if (rc == 0) {
   /* Connect can take lots of time */
   mod_timer(&wil->connect_timer,
      jiffies + msecs_to_jiffies(2000));
+ } else {
+  clear_bit(wil_status_fwconnecting, &wil->status);
  }
 
  out:
@@ -348,6 +443,40 @@ static int wil_cfg80211_disconnect(struct wiphy *wiphy,
  return rc;
 }
 
+static int wil_cfg80211_mgmt_tx(struct wiphy *wiphy,
+    struct wireless_dev *wdev,
+    struct cfg80211_mgmt_tx_params *params,
+    u64 *cookie)
+{
+ const u8 *buf = params->buf;
+ size_t len = params->len;
+ struct wil6210_priv *wil = wiphy_to_wil(wiphy);
+ int rc;
+ struct ieee80211_mgmt *mgmt_frame = (void *)buf;
+ struct wmi_sw_tx_req_cmd *cmd;
+ struct {
+  struct wil6210_mbox_hdr_wmi wmi;
+  struct wmi_sw_tx_complete_event evt;
+ } __packed evt;
+
+ cmd = kmalloc(sizeof(*cmd) + len, GFP_KERNEL);
+ if (!cmd)
+  return -ENOMEM;
+
+ memcpy(cmd->dst_mac, mgmt_frame->da, WMI_MAC_LEN);
+ cmd->len = cpu_to_le16(len);
+ memcpy(cmd->payload, buf, len);
+
+ rc = wmi_call(wil, WMI_SW_TX_REQ_CMDID, cmd, sizeof(*cmd) + len,
+        WMI_SW_TX_COMPLETE_EVENTID, &evt, sizeof(evt), 2000);
+ if (rc == 0)
+  rc = evt.evt.status;
+
+ kfree(cmd);
+
+ return rc;
+}
+
 static int wil_cfg80211_set_channel(struct wiphy *wiphy,
         struct cfg80211_chan_def *chandef)
 {
@@ -398,6 +527,65 @@ static int wil_cfg80211_set_default_key(struct wiphy *wiphy,
  return 0;
 }
 
+static int wil_remain_on_channel(struct wiphy *wiphy,
+     struct wireless_dev *wdev,
+     struct ieee80211_channel *chan,
+     unsigned int duration,
+     u64 *cookie)
+{
+ struct wil6210_priv *wil = wiphy_to_wil(wiphy);
+ int rc;
+
+ /* TODO: handle duration */
+ wil_info(wil, "%s(%d, %d ms)\n", __func__, chan->center_freq, duration);
+
+ rc = wmi_set_channel(wil, chan->hw_value);
+ if (rc)
+  return rc;
+
+ rc = wmi_rxon(wil, true);
+
+ return rc;
+}
+
+static int wil_cancel_remain_on_channel(struct wiphy *wiphy,
+     struct wireless_dev *wdev,
+     u64 cookie)
+{
+ struct wil6210_priv *wil = wiphy_to_wil(wiphy);
+ int rc;
+
+ wil_info(wil, "%s()\n", __func__);
+
+ rc = wmi_rxon(wil, false);
+
+ return rc;
+}
+
+static int wil_fix_bcon(struct wil6210_priv *wil,
+   struct cfg80211_beacon_data *bcon)
+{
+ struct ieee80211_mgmt *f = (struct ieee80211_mgmt *)bcon->probe_resp;
+ size_t hlen = offsetof(struct ieee80211_mgmt, u.probe_resp.variable);
+ int rc = 0;
+
+ if (bcon->probe_resp_len <= hlen)
+  return 0;
+
+ if (!bcon->proberesp_ies) {
+  bcon->proberesp_ies = f->u.probe_resp.variable;
+  bcon->proberesp_ies_len = bcon->probe_resp_len - hlen;
+  rc = 1;
+ }
+ if (!bcon->assocresp_ies) {
+  bcon->assocresp_ies = f->u.probe_resp.variable;
+  bcon->assocresp_ies_len = bcon->probe_resp_len - hlen;
+  rc = 1;
+ }
+
+ return rc;
+}
+
 static int wil_cfg80211_start_ap(struct wiphy *wiphy,
      struct net_device *ndev,
      struct cfg80211_ap_settings *info)
@@ -419,13 +607,23 @@ static int wil_cfg80211_start_ap(struct wiphy *wiphy,
  print_hex_dump_bytes("SSID ", DUMP_PREFIX_OFFSET,
         info->ssid, info->ssid_len);
 
+ if (wil_fix_bcon(wil, bcon))
+  wil_dbg_misc(wil, "Fixed bcon\n");
+
+ mutex_lock(&wil->mutex);
+
  rc = wil_reset(wil);
  if (rc)
-  return rc;
+  goto out;
+
+ /* Rx VRING. */
+ rc = wil_rx_init(wil);
+ if (rc)
+  goto out;
 
  rc = wmi_set_ssid(wil, info->ssid_len, info->ssid);
  if (rc)
-  return rc;
+  goto out;
 
  /* MAC address - pre-requisite for other commands */
  wmi_set_mac_address(wil, ndev->dev_addr);
@@ -449,13 +647,13 @@ static int wil_cfg80211_start_ap(struct wiphy *wiphy,
  rc = wmi_pcp_start(wil, info->beacon_interval, wmi_nettype,
       channel->hw_value);
  if (rc)
-  return rc;
+  goto out;
 
- /* Rx VRING. After MAC and beacon */
- rc = wil_rx_init(wil);
 
  netif_carrier_on(ndev);
 
+out:
+ mutex_unlock(&wil->mutex);
  return rc;
 }
 
@@ -465,17 +663,36 @@ static int wil_cfg80211_stop_ap(struct wiphy *wiphy,
  int rc = 0;
  struct wil6210_priv *wil = wiphy_to_wil(wiphy);
 
+ mutex_lock(&wil->mutex);
+
  rc = wmi_pcp_stop(wil);
 
+ mutex_unlock(&wil->mutex);
  return rc;
 }
 
+static int wil_cfg80211_del_station(struct wiphy *wiphy,
+        struct net_device *dev, const u8 *mac)
+{
+ struct wil6210_priv *wil = wiphy_to_wil(wiphy);
+
+ mutex_lock(&wil->mutex);
+ wil6210_disconnect(wil, mac);
+ mutex_unlock(&wil->mutex);
+
+ return 0;
+}
+
 static struct cfg80211_ops wil_cfg80211_ops = {
  .scan = wil_cfg80211_scan,
  .connect = wil_cfg80211_connect,
  .disconnect = wil_cfg80211_disconnect,
  .change_virtual_intf = wil_cfg80211_change_iface,
  .get_station = wil_cfg80211_get_station,
+ .dump_station = wil_cfg80211_dump_station,
+ .remain_on_channel = wil_remain_on_channel,
+ .cancel_remain_on_channel = wil_cancel_remain_on_channel,
+ .mgmt_tx = wil_cfg80211_mgmt_tx,
  .set_monitor_channel = wil_cfg80211_set_channel,
  .add_key = wil_cfg80211_add_key,
  .del_key = wil_cfg80211_del_key,
@@ -483,6 +700,7 @@ static struct cfg80211_ops wil_cfg80211_ops = {
  /* AP mode */
  .start_ap = wil_cfg80211_start_ap,
  .stop_ap = wil_cfg80211_stop_ap,
+ .del_station = wil_cfg80211_del_station,
 };
 
 static void wil_wiphy_init(struct wiphy *wiphy)
@@ -508,7 +726,7 @@ static void wil_wiphy_init(struct wiphy *wiphy)
  wiphy->bands[IEEE80211_BAND_60GHZ] = &wil_band_60ghz;
 
  /* TODO: figure this out */
- wiphy->signal_type = CFG80211_SIGNAL_TYPE_MBM;
+ wiphy->signal_type = CFG80211_SIGNAL_TYPE_UNSPEC;
 
  wiphy->cipher_suites = wil_cipher_suites;
  wiphy->n_cipher_suites = ARRAY_SIZE(wil_cipher_suites);
diff --git a/drivers/net/wireless/ath/wil6210/debug.c b/drivers/net/wireless/ath/wil6210/debug.c
new file mode 100644
index 0000000..9eeabf4
--- /dev/null
+++ b/drivers/net/wireless/ath/wil6210/debug.c
@@ -0,0 +1,69 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include "wil6210.h"
+#include "trace.h"
+
+int wil_err(struct wil6210_priv *wil, const char *fmt, ...)
+{
+ struct net_device *ndev = wil_to_ndev(wil);
+ struct va_format vaf = {
+  .fmt = fmt,
+ };
+ va_list args;
+ int ret;
+
+ va_start(args, fmt);
+ vaf.va = &args;
+ ret = netdev_err(ndev, "%pV", &vaf);
+ trace_wil6210_log_err(&vaf);
+ va_end(args);
+
+ return ret;
+}
+
+int wil_info(struct wil6210_priv *wil, const char *fmt, ...)
+{
+ struct net_device *ndev = wil_to_ndev(wil);
+ struct va_format vaf = {
+  .fmt = fmt,
+ };
+ va_list args;
+ int ret;
+
+ va_start(args, fmt);
+ vaf.va = &args;
+ ret = netdev_info(ndev, "%pV", &vaf);
+ trace_wil6210_log_info(&vaf);
+ va_end(args);
+
+ return ret;
+}
+
+int wil_dbg_trace(struct wil6210_priv *wil, const char *fmt, ...)
+{
+ struct va_format vaf = {
+  .fmt = fmt,
+ };
+ va_list args;
+
+ va_start(args, fmt);
+ vaf.va = &args;
+ trace_wil6210_log_dbg(&vaf);
+ va_end(args);
+
+ return 0;
+}
diff --git a/drivers/net/wireless/ath/wil6210/debugfs.c b/drivers/net/wireless/ath/wil6210/debugfs.c
index d57e5be..8d4bc4b 100644
--- a/drivers/net/wireless/ath/wil6210/debugfs.c
+++ b/drivers/net/wireless/ath/wil6210/debugfs.c
@@ -26,14 +26,16 @@
 /* Nasty hack. Better have per device instances */
 static u32 mem_addr;
 static u32 dbg_txdesc_index;
+static u32 dbg_vring_index; /* 24+ for Rx, 0..23 for Tx */
 
 static void wil_print_vring(struct seq_file *s, struct wil6210_priv *wil,
-       const char *name, struct vring *vring)
+       const char *name, struct vring *vring,
+       char _s, char _h)
 {
  void __iomem *x = wmi_addr(wil, vring->hwtail);
 
  seq_printf(s, "VRING %s = {\n", name);
- seq_printf(s, "  pa     = 0x%016llx\n", (unsigned long long)vring->pa);
+ seq_printf(s, "  pa     = %pad\n", &vring->pa);
  seq_printf(s, "  va     = 0x%p\n", vring->va);
  seq_printf(s, "  size   = %d\n", vring->size);
  seq_printf(s, "  swtail = %d\n", vring->swtail);
@@ -50,8 +52,8 @@ static void wil_print_vring(struct seq_file *s, struct wil6210_priv *wil,
    volatile struct vring_tx_desc *d = &vring->va[i].tx;
    if ((i % 64) == 0 && (i != 0))
     seq_printf(s, "\n");
-   seq_printf(s, "%s", (d->dma.status & BIT(0)) ?
-     "S" : (vring->ctx[i] ? "H" : "h"));
+   seq_printf(s, "%c", (d->dma.status & BIT(0)) ?
+     _s : (vring->ctx[i].skb ? _h : 'h'));
   }
   seq_printf(s, "\n");
  }
@@ -63,14 +65,19 @@ static int wil_vring_debugfs_show(struct seq_file *s, void *data)
  uint i;
  struct wil6210_priv *wil = s->private;
 
- wil_print_vring(s, wil, "rx", &wil->vring_rx);
+ wil_print_vring(s, wil, "rx", &wil->vring_rx, 'S', '_');
 
  for (i = 0; i < ARRAY_SIZE(wil->vring_tx); i++) {
   struct vring *vring = &(wil->vring_tx[i]);
   if (vring->va) {
+   int cid = wil->vring2cid_tid[i][0];
+   int tid = wil->vring2cid_tid[i][1];
    char name[10];
    snprintf(name, sizeof(name), "tx_%2d", i);
-   wil_print_vring(s, wil, name, vring);
+
+   seq_printf(s, "\n%pM CID %d TID %d\n",
+       wil->sta[cid].addr, cid, tid);
+   wil_print_vring(s, wil, name, vring, '_', 'H');
   }
  }
 
@@ -390,51 +397,98 @@ static const struct file_operations fops_reset = {
  .write = wil_write_file_reset,
  .open  = simple_open,
 };
-/*---------Tx descriptor------------*/
 
+static void wil_seq_hexdump(struct seq_file *s, void *p, int len,
+       const char *prefix)
+{
+ char printbuf[16 * 3 + 2];
+ int i = 0;
+ while (i < len) {
+  int l = min(len - i, 16);
+  hex_dump_to_buffer(p + i, l, 16, 1, printbuf,
+       sizeof(printbuf), false);
+  seq_printf(s, "%s%s\n", prefix, printbuf);
+  i += l;
+ }
+}
+
+static void wil_seq_print_skb(struct seq_file *s, struct sk_buff *skb)
+{
+ int i = 0;
+ int len = skb_headlen(skb);
+ void *p = skb->data;
+ int nr_frags = skb_shinfo(skb)->nr_frags;
+
+ seq_printf(s, "    len = %d\n", len);
+ wil_seq_hexdump(s, p, len, "      : ");
+
+ if (nr_frags) {
+  seq_printf(s, "    nr_frags = %d\n", nr_frags);
+  for (i = 0; i < nr_frags; i++) {
+   const struct skb_frag_struct *frag =
+     &skb_shinfo(skb)->frags[i];
+
+   len = skb_frag_size(frag);
+   p = skb_frag_address_safe(frag);
+   seq_printf(s, "    [%2d] : len = %d\n", i, len);
+   wil_seq_hexdump(s, p, len, "      : ");
+  }
+ }
+}
+
+/*---------Tx/Rx descriptor------------*/
 static int wil_txdesc_debugfs_show(struct seq_file *s, void *data)
 {
  struct wil6210_priv *wil = s->private;
- struct vring *vring = &(wil->vring_tx[0]);
+ struct vring *vring;
+ bool tx = (dbg_vring_index < WIL6210_MAX_TX_RINGS);
+ if (tx)
+  vring = &(wil->vring_tx[dbg_vring_index]);
+ else
+  vring = &wil->vring_rx;
 
  if (!vring->va) {
-  seq_printf(s, "No Tx VRING\n");
+  if (tx)
+   seq_printf(s, "No Tx[%2d] VRING\n", dbg_vring_index);
+  else
+   seq_puts(s, "No Rx VRING\n");
   return 0;
  }
 
  if (dbg_txdesc_index < vring->size) {
+  /* use struct vring_tx_desc for Rx as well,
+   * only field used, .dma.length, is the same
+   */
   volatile struct vring_tx_desc *d =
     &(vring->va[dbg_txdesc_index].tx);
   volatile u32 *u = (volatile u32 *)d;
-  struct sk_buff *skb = vring->ctx[dbg_txdesc_index];
+  struct sk_buff *skb = vring->ctx[dbg_txdesc_index].skb;
 
-  seq_printf(s, "Tx[%3d] = {\n", dbg_txdesc_index);
+  if (tx)
+   seq_printf(s, "Tx[%2d][%3d] = {\n", dbg_vring_index,
+       dbg_txdesc_index);
+  else
+   seq_printf(s, "Rx[%3d] = {\n", dbg_txdesc_index);
   seq_printf(s, "  MAC = 0x%08x 0x%08x 0x%08x 0x%08x\n",
       u[0], u[1], u[2], u[3]);
   seq_printf(s, "  DMA = 0x%08x 0x%08x 0x%08x 0x%08x\n",
       u[4], u[5], u[6], u[7]);
-  seq_printf(s, "  SKB = %p\n", skb);
+  seq_printf(s, "  SKB = 0x%p\n", skb);
 
   if (skb) {
-   char printbuf[16 * 3 + 2];
-   int i = 0;
-   int len = skb_headlen(skb);
-   void *p = skb->data;
-
-   seq_printf(s, "    len = %d\n", len);
-
-   while (i < len) {
-    int l = min(len - i, 16);
-    hex_dump_to_buffer(p + i, l, 16, 1, printbuf,
-         sizeof(printbuf), false);
-    seq_printf(s, "      : %s\n", printbuf);
-    i += l;
-   }
+   skb_get(skb);
+   wil_seq_print_skb(s, skb);
+   kfree_skb(skb);
   }
   seq_printf(s, "}\n");
  } else {
-  seq_printf(s, "TxDesc index (%d) >= size (%d)\n",
-      dbg_txdesc_index, vring->size);
+  if (tx)
+   seq_printf(s, "[%2d] TxDesc index (%d) >= size (%d)\n",
+       dbg_vring_index, dbg_txdesc_index,
+       vring->size);
+  else
+   seq_printf(s, "RxDesc index (%d) >= size (%d)\n",
+       dbg_txdesc_index, vring->size);
  }
 
  return 0;
@@ -564,6 +618,69 @@ static const struct file_operations fops_temp = {
  .llseek  = seq_lseek,
 };
 
+/*---------Station matrix------------*/
+static void wil_print_rxtid(struct seq_file *s, struct wil_tid_ampdu_rx *r)
+{
+ int i;
+ u16 index = ((r->head_seq_num - r->ssn) & 0xfff) % r->buf_size;
+ seq_printf(s, "0x%03x [", r->head_seq_num);
+ for (i = 0; i < r->buf_size; i++) {
+  if (i == index)
+   seq_printf(s, "%c", r->reorder_buf[i] ? 'O' : '|');
+  else
+   seq_printf(s, "%c", r->reorder_buf[i] ? '*' : '_');
+ }
+ seq_puts(s, "]\n");
+}
+
+static int wil_sta_debugfs_show(struct seq_file *s, void *data)
+{
+ struct wil6210_priv *wil = s->private;
+ int i, tid;
+
+ for (i = 0; i < ARRAY_SIZE(wil->sta); i++) {
+  struct wil_sta_info *p = &wil->sta[i];
+  char *status = "unknown";
+  switch (p->status) {
+  case wil_sta_unused:
+   status = "unused   ";
+   break;
+  case wil_sta_conn_pending:
+   status = "pending  ";
+   break;
+  case wil_sta_connected:
+   status = "connected";
+   break;
+  }
+  seq_printf(s, "[%d] %pM %s%s\n", i, p->addr, status,
+      (p->data_port_open ? " data_port_open" : ""));
+
+  if (p->status == wil_sta_connected) {
+   for (tid = 0; tid < WIL_STA_TID_NUM; tid++) {
+    struct wil_tid_ampdu_rx *r = p->tid_rx[tid];
+    if (r) {
+     seq_printf(s, "[%2d] ", tid);
+     wil_print_rxtid(s, r);
+    }
+   }
+  }
+ }
+
+ return 0;
+}
+
+static int wil_sta_seq_open(struct inode *inode, struct file *file)
+{
+ return single_open(file, wil_sta_debugfs_show, inode->i_private);
+}
+
+static const struct file_operations fops_sta = {
+ .open  = wil_sta_seq_open,
+ .release = single_release,
+ .read  = seq_read,
+ .llseek  = seq_lseek,
+};
+
 /*----------------*/
 int wil6210_debugfs_init(struct wil6210_priv *wil)
 {
@@ -575,9 +692,13 @@ int wil6210_debugfs_init(struct wil6210_priv *wil)
 
  debugfs_create_file("mbox", S_IRUGO, dbg, wil, &fops_mbox);
  debugfs_create_file("vrings", S_IRUGO, dbg, wil, &fops_vring);
- debugfs_create_file("txdesc", S_IRUGO, dbg, wil, &fops_txdesc);
- debugfs_create_u32("txdesc_index", S_IRUGO | S_IWUSR, dbg,
+ debugfs_create_file("stations", S_IRUGO, dbg, wil, &fops_sta);
+ debugfs_create_file("desc", S_IRUGO, dbg, wil, &fops_txdesc);
+ debugfs_create_u32("desc_index", S_IRUGO | S_IWUSR, dbg,
       &dbg_txdesc_index);
+ debugfs_create_u32("vring_index", S_IRUGO | S_IWUSR, dbg,
+      &dbg_vring_index);
+
  debugfs_create_file("bf", S_IRUGO, dbg, wil, &fops_bf);
  debugfs_create_file("ssid", S_IRUGO | S_IWUSR, dbg, wil, &fops_ssid);
  debugfs_create_u32("secure_pcp", S_IRUGO | S_IWUSR, dbg,
diff --git a/drivers/net/wireless/ath/wil6210/interrupt.c b/drivers/net/wireless/ath/wil6210/interrupt.c
index e3c1e76..73593aa 100644
--- a/drivers/net/wireless/ath/wil6210/interrupt.c
+++ b/drivers/net/wireless/ath/wil6210/interrupt.c
@@ -17,6 +17,7 @@
 #include <linux/interrupt.h>
 
 #include "wil6210.h"
+#include "trace.h"
 
 /**
  * Theory of operation:
@@ -103,14 +104,14 @@ static void wil6210_mask_irq_pseudo(struct wil6210_priv *wil)
  clear_bit(wil_status_irqen, &wil->status);
 }
 
-static void wil6210_unmask_irq_tx(struct wil6210_priv *wil)
+void wil6210_unmask_irq_tx(struct wil6210_priv *wil)
 {
  iowrite32(WIL6210_IMC_TX, wil->csr +
     HOSTADDR(RGF_DMA_EP_TX_ICR) +
     offsetof(struct RGF_ICR, IMC));
 }
 
-static void wil6210_unmask_irq_rx(struct wil6210_priv *wil)
+void wil6210_unmask_irq_rx(struct wil6210_priv *wil)
 {
  iowrite32(WIL6210_IMC_RX, wil->csr +
     HOSTADDR(RGF_DMA_EP_RX_ICR) +
@@ -155,6 +156,19 @@ void wil6210_enable_irq(struct wil6210_priv *wil)
  iowrite32(WIL_ICR_ICC_VALUE, wil->csr + HOSTADDR(RGF_DMA_EP_MISC_ICR) +
     offsetof(struct RGF_ICR, ICC));
 
+ /* interrupt moderation parameters */
+ if (wil->wdev->iftype == NL80211_IFTYPE_MONITOR) {
+  /* disable interrupt moderation for monitor
+   * to get better timestamp precision
+   */
+  iowrite32(0, wil->csr + HOSTADDR(RGF_DMA_ITR_CNT_CRL));
+ } else {
+  iowrite32(WIL6210_ITR_TRSH,
+     wil->csr + HOSTADDR(RGF_DMA_ITR_CNT_TRSH));
+  iowrite32(BIT_DMA_ITR_CNT_CRL_EN,
+     wil->csr + HOSTADDR(RGF_DMA_ITR_CNT_CRL));
+ }
+
  wil6210_unmask_irq_pseudo(wil);
  wil6210_unmask_irq_tx(wil);
  wil6210_unmask_irq_rx(wil);
@@ -168,6 +182,7 @@ static irqreturn_t wil6210_irq_rx(int irq, void *cookie)
       HOSTADDR(RGF_DMA_EP_RX_ICR) +
       offsetof(struct RGF_ICR, ICR));
 
+ trace_wil6210_irq_rx(isr);
  wil_dbg_irq(wil, "ISR RX 0x%08x\n", isr);
 
  if (!isr) {
@@ -180,13 +195,18 @@ static irqreturn_t wil6210_irq_rx(int irq, void *cookie)
  if (isr & BIT_DMA_EP_RX_ICR_RX_DONE) {
   wil_dbg_irq(wil, "RX done\n");
   isr &= ~BIT_DMA_EP_RX_ICR_RX_DONE;
-  wil_rx_handle(wil);
+  if (test_bit(wil_status_reset_done, &wil->status)) {
+   wil_dbg_txrx(wil, "NAPI(Rx) schedule\n");
+   napi_schedule(&wil->napi_rx);
+  } else {
+   wil_err(wil, "Got Rx interrupt while in reset\n");
+  }
  }
 
  if (isr)
   wil_err(wil, "un-handled RX ISR bits 0x%08x\n", isr);
 
- wil6210_unmask_irq_rx(wil);
+ /* Rx IRQ will be enabled when NAPI processing finished */
 
  return IRQ_HANDLED;
 }
@@ -198,6 +218,7 @@ static irqreturn_t wil6210_irq_tx(int irq, void *cookie)
       HOSTADDR(RGF_DMA_EP_TX_ICR) +
       offsetof(struct RGF_ICR, ICR));
 
+ trace_wil6210_irq_tx(isr);
  wil_dbg_irq(wil, "ISR TX 0x%08x\n", isr);
 
  if (!isr) {
@@ -208,23 +229,22 @@ static irqreturn_t wil6210_irq_tx(int irq, void *cookie)
  wil6210_mask_irq_tx(wil);
 
  if (isr & BIT_DMA_EP_TX_ICR_TX_DONE) {
-  uint i;
   wil_dbg_irq(wil, "TX done\n");
   isr &= ~BIT_DMA_EP_TX_ICR_TX_DONE;
-  for (i = 0; i < 24; i++) {
-   u32 mask = BIT_DMA_EP_TX_ICR_TX_DONE_N(i);
-   if (isr & mask) {
-    isr &= ~mask;
-    wil_dbg_irq(wil, "TX done(%i)\n", i);
-    wil_tx_complete(wil, i);
-   }
+  /* clear also all VRING interrupts */
+  isr &= ~(BIT(25) - 1UL);
+  if (test_bit(wil_status_reset_done, &wil->status)) {
+   wil_dbg_txrx(wil, "NAPI(Tx) schedule\n");
+   napi_schedule(&wil->napi_tx);
+  } else {
+   wil_err(wil, "Got Tx interrupt while in reset\n");
   }
  }
 
  if (isr)
   wil_err(wil, "un-handled TX ISR bits 0x%08x\n", isr);
 
- wil6210_unmask_irq_tx(wil);
+ /* Tx IRQ will be enabled when NAPI processing finished */
 
  return IRQ_HANDLED;
 }
@@ -256,6 +276,7 @@ static irqreturn_t wil6210_irq_misc(int irq, void *cookie)
       HOSTADDR(RGF_DMA_EP_MISC_ICR) +
       offsetof(struct RGF_ICR, ICR));
 
+ trace_wil6210_irq_misc(isr);
  wil_dbg_irq(wil, "ISR MISC 0x%08x\n", isr);
 
  if (!isr) {
@@ -301,11 +322,13 @@ static irqreturn_t wil6210_irq_misc_thread(int irq, void *cookie)
  struct wil6210_priv *wil = cookie;
  u32 isr = wil->isr_misc;
 
+ trace_wil6210_irq_misc_thread(isr);
  wil_dbg_irq(wil, "Thread ISR MISC 0x%08x\n", isr);
 
  if (isr & ISR_MISC_FW_ERROR) {
   wil_notify_fw_error(wil);
   isr &= ~ISR_MISC_FW_ERROR;
+  wil_fw_error_recovery(wil);
  }
 
  if (isr & ISR_MISC_MBOX_EVT) {
@@ -315,7 +338,7 @@ static irqreturn_t wil6210_irq_misc_thread(int irq, void *cookie)
  }
 
  if (isr)
-  wil_err(wil, "un-handled MISC ISR bits 0x%08x\n", isr);
+  wil_dbg_irq(wil, "un-handled MISC ISR bits 0x%08x\n", isr);
 
  wil->isr_misc = 0;
 
@@ -408,6 +431,7 @@ static irqreturn_t wil6210_hardirq(int irq, void *cookie)
  if (wil6210_debug_irq_mask(wil, pseudo_cause))
   return IRQ_NONE;
 
+ trace_wil6210_irq_pseudo(pseudo_cause);
  wil_dbg_irq(wil, "Pseudo IRQ 0x%08x\n", pseudo_cause);
 
  wil6210_mask_irq_pseudo(wil);
@@ -479,6 +503,23 @@ free0:
 
  return rc;
 }
+/* can't use wil_ioread32_and_clear because ICC value is not ser yet */
+static inline void wil_clear32(void __iomem *addr)
+{
+ u32 x = ioread32(addr);
+
+ iowrite32(x, addr);
+}
+
+void wil6210_clear_irq(struct wil6210_priv *wil)
+{
+ wil_clear32(wil->csr + HOSTADDR(RGF_DMA_EP_RX_ICR) +
+      offsetof(struct RGF_ICR, ICR));
+ wil_clear32(wil->csr + HOSTADDR(RGF_DMA_EP_TX_ICR) +
+      offsetof(struct RGF_ICR, ICR));
+ wil_clear32(wil->csr + HOSTADDR(RGF_DMA_EP_MISC_ICR) +
+      offsetof(struct RGF_ICR, ICR));
+}
 
 int wil6210_init_irq(struct wil6210_priv *wil, int irq)
 {
diff --git a/drivers/net/wireless/ath/wil6210/main.c b/drivers/net/wireless/ath/wil6210/main.c
index a0478e2..11e6d9d 100644
--- a/drivers/net/wireless/ath/wil6210/main.c
+++ b/drivers/net/wireless/ath/wil6210/main.c
@@ -16,8 +16,14 @@
 
 #include <linux/moduleparam.h>
 #include <linux/if_arp.h>
+#include <linux/etherdevice.h>
 
 #include "wil6210.h"
+#include "txrx.h"
+
+static bool no_fw_recovery;
+module_param(no_fw_recovery, bool, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(no_fw_recovery, " disable FW error recovery");
 
 /*
  * Due to a hardware issue,
@@ -52,35 +58,74 @@ void wil_memcpy_toio_32(volatile void __iomem *dst, const void *src,
   __raw_writel(*s++, d++);
 }
 
-static void _wil6210_disconnect(struct wil6210_priv *wil, void *bssid)
+static void wil_disconnect_cid(struct wil6210_priv *wil, int cid)
 {
  uint i;
+ struct wil_sta_info *sta = &wil->sta[cid];
+
+ sta->data_port_open = false;
+ if (sta->status != wil_sta_unused) {
+  wmi_disconnect_sta(wil, sta->addr, WLAN_REASON_DEAUTH_LEAVING);
+  sta->status = wil_sta_unused;
+ }
+
+ for (i = 0; i < WIL_STA_TID_NUM; i++) {
+  struct wil_tid_ampdu_rx *r = sta->tid_rx[i];
+  sta->tid_rx[i] = NULL;
+  wil_tid_ampdu_rx_free(wil, r);
+ }
+ for (i = 0; i < ARRAY_SIZE(wil->vring_tx); i++) {
+  if (wil->vring2cid_tid[i][0] == cid)
+   wil_vring_fini_tx(wil, i);
+ }
+ memset(&sta->stats, 0, sizeof(sta->stats));
+}
+
+static void _wil6210_disconnect(struct wil6210_priv *wil, const u8 *bssid)
+{
+ int cid = -ENOENT;
  struct net_device *ndev = wil_to_ndev(wil);
  struct wireless_dev *wdev = wil->wdev;
 
- wil_dbg_misc(wil, "%s()\n", __func__);
+ might_sleep();
+ if (bssid) {
+  cid = wil_find_cid(wil, bssid);
+  wil_dbg_misc(wil, "%s(%pM, CID %d)\n", __func__, bssid, cid);
+ } else {
+  wil_dbg_misc(wil, "%s(all)\n", __func__);
+ }
 
- wil_link_off(wil);
- clear_bit(wil_status_fwconnected, &wil->status);
+ if (cid >= 0) /* disconnect 1 peer */
+  wil_disconnect_cid(wil, cid);
+ else /* disconnect all */
+  for (cid = 0; cid < WIL6210_MAX_CID; cid++)
+   wil_disconnect_cid(wil, cid);
 
- switch (wdev->sme_state) {
- case CFG80211_SME_CONNECTED:
-  cfg80211_disconnected(ndev, WLAN_STATUS_UNSPECIFIED_FAILURE,
-          NULL, 0, GFP_KERNEL);
-  break;
- case CFG80211_SME_CONNECTING:
-  cfg80211_connect_result(ndev, bssid, NULL, 0, NULL, 0,
-     WLAN_STATUS_UNSPECIFIED_FAILURE,
-     GFP_KERNEL);
+ /* link state */
+ switch (wdev->iftype) {
+ case NL80211_IFTYPE_STATION:
+ case NL80211_IFTYPE_P2P_CLIENT:
+  wil_link_off(wil);
+  if (test_bit(wil_status_fwconnected, &wil->status)) {
+   clear_bit(wil_status_fwconnected, &wil->status);
+   cfg80211_disconnected(ndev,
+           WLAN_STATUS_UNSPECIFIED_FAILURE,
+           NULL, 0, GFP_KERNEL);
+  } else if (test_bit(wil_status_fwconnecting, &wil->status)) {
+   cfg80211_connect_result(ndev, bssid, NULL, 0, NULL, 0,
+      WLAN_STATUS_UNSPECIFIED_FAILURE,
+      GFP_KERNEL);
+  }
+  clear_bit(wil_status_fwconnecting, &wil->status);
   break;
  default:
+  /* AP-like interface and monitor:
+   * never scan, always connected
+   */
+  if (bssid)
+   cfg80211_del_sta(ndev, bssid, GFP_KERNEL);
   break;
  }
-
- for (i = 0; i < ARRAY_SIZE(wil->vring_tx); i++)
-  wil_vring_fini_tx(wil, i);
-
- clear_bit(wil_status_dontscan, &wil->status);
 }
 
 static void wil_disconnect_worker(struct work_struct *work)
@@ -88,7 +133,9 @@ static void wil_disconnect_worker(struct work_struct *work)
  struct wil6210_priv *wil = container_of(work,
    struct wil6210_priv, disconnect_worker);
 
+ mutex_lock(&wil->mutex);
  _wil6210_disconnect(wil, NULL);
+ mutex_unlock(&wil->mutex);
 }
 
 static void wil_connect_timer_fn(ulong x)
@@ -103,12 +150,82 @@ static void wil_connect_timer_fn(ulong x)
  schedule_work(&wil->disconnect_worker);
 }
 
+static void wil_scan_timer_fn(ulong x)
+{
+ struct wil6210_priv *wil = (void *)x;
+
+ clear_bit(wil_status_fwready, &wil->status);
+ wil_err(wil, "Scan timeout detected, start fw error recovery\n");
+ schedule_work(&wil->fw_error_worker);
+}
+
+static void wil_fw_error_worker(struct work_struct *work)
+{
+ struct wil6210_priv *wil = container_of(work,
+   struct wil6210_priv, fw_error_worker);
+ struct wireless_dev *wdev = wil->wdev;
+
+ wil_dbg_misc(wil, "fw error worker\n");
+
+ if (no_fw_recovery)
+  return;
+
+ /* increment @recovery_count if less then WIL6210_FW_RECOVERY_TO
+  * passed since last recovery attempt
+  */
+ if (time_is_after_jiffies(wil->last_fw_recovery +
+      WIL6210_FW_RECOVERY_TO))
+  wil->recovery_count++;
+ else
+  wil->recovery_count = 1; /* fw was alive for a long time */
+
+ if (wil->recovery_count > WIL6210_FW_RECOVERY_RETRIES) {
+  wil_err(wil, "too many recovery attempts (%d), giving up\n",
+   wil->recovery_count);
+  return;
+ }
+
+ wil->last_fw_recovery = jiffies;
+
+ mutex_lock(&wil->mutex);
+ switch (wdev->iftype) {
+ case NL80211_IFTYPE_STATION:
+ case NL80211_IFTYPE_P2P_CLIENT:
+ case NL80211_IFTYPE_MONITOR:
+  wil_info(wil, "fw error recovery started (try %d)...\n",
+    wil->recovery_count);
+  wil_reset(wil);
+
+  /* need to re-allocate Rx ring after reset */
+  wil_rx_init(wil);
+  break;
+ case NL80211_IFTYPE_AP:
+ case NL80211_IFTYPE_P2P_GO:
+  /* recovery in these modes is done by upper layers */
+  break;
+ default:
+  break;
+ }
+ mutex_unlock(&wil->mutex);
+}
+
+static int wil_find_free_vring(struct wil6210_priv *wil)
+{
+ int i;
+ for (i = 0; i < WIL6210_MAX_TX_RINGS; i++) {
+  if (!wil->vring_tx[i].va)
+   return i;
+ }
+ return -EINVAL;
+}
+
 static void wil_connect_worker(struct work_struct *work)
 {
  int rc;
  struct wil6210_priv *wil = container_of(work, struct wil6210_priv,
       connect_worker);
  int cid = wil->pending_connect_cid;
+ int ringid = wil_find_free_vring(wil);
 
  if (cid < 0) {
   wil_err(wil, "No connection pending\n");
@@ -117,16 +234,22 @@ static void wil_connect_worker(struct work_struct *work)
 
  wil_dbg_wmi(wil, "Configure for connection CID %d\n", cid);
 
- rc = wil_vring_init_tx(wil, 0, WIL6210_TX_RING_SIZE, cid, 0);
+ rc = wil_vring_init_tx(wil, ringid, WIL6210_TX_RING_SIZE, cid, 0);
  wil->pending_connect_cid = -1;
- if (rc == 0)
+ if (rc == 0) {
+  wil->sta[cid].status = wil_sta_connected;
   wil_link_on(wil);
+ } else {
+  wil->sta[cid].status = wil_sta_unused;
+ }
 }
 
 int wil_priv_init(struct wil6210_priv *wil)
 {
  wil_dbg_misc(wil, "%s()\n", __func__);
 
+ memset(wil->sta, 0, sizeof(wil->sta));
+
  mutex_init(&wil->mutex);
  mutex_init(&wil->wmi_mutex);
 
@@ -134,10 +257,12 @@ int wil_priv_init(struct wil6210_priv *wil)
 
  wil->pending_connect_cid = -1;
  setup_timer(&wil->connect_timer, wil_connect_timer_fn, (ulong)wil);
+ setup_timer(&wil->scan_timer, wil_scan_timer_fn, (ulong)wil);
 
  INIT_WORK(&wil->connect_worker, wil_connect_worker);
  INIT_WORK(&wil->disconnect_worker, wil_disconnect_worker);
  INIT_WORK(&wil->wmi_event_worker, wmi_event_worker);
+ INIT_WORK(&wil->fw_error_worker, wil_fw_error_worker);
 
  INIT_LIST_HEAD(&wil->pending_wmi_ev);
  spin_lock_init(&wil->wmi_ev_lock);
@@ -152,10 +277,12 @@ int wil_priv_init(struct wil6210_priv *wil)
   return -EAGAIN;
  }
 
+ wil->last_fw_recovery = jiffies;
+
  return 0;
 }
 
-void wil6210_disconnect(struct wil6210_priv *wil, void *bssid)
+void wil6210_disconnect(struct wil6210_priv *wil, const u8 *bssid)
 {
  del_timer_sync(&wil->connect_timer);
  _wil6210_disconnect(wil, bssid);
@@ -163,8 +290,12 @@ void wil6210_disconnect(struct wil6210_priv *wil, void *bssid)
 
 void wil_priv_deinit(struct wil6210_priv *wil)
 {
+ del_timer_sync(&wil->scan_timer);
  cancel_work_sync(&wil->disconnect_worker);
+ cancel_work_sync(&wil->fw_error_worker);
+ mutex_lock(&wil->mutex);
  wil6210_disconnect(wil, NULL);
+ mutex_unlock(&wil->mutex);
  wmi_event_flush(wil);
  destroy_workqueue(wil->wmi_wq_conn);
  destroy_workqueue(wil->wmi_wq);
@@ -172,40 +303,78 @@ void wil_priv_deinit(struct wil6210_priv *wil)
 
 static void wil_target_reset(struct wil6210_priv *wil)
 {
+ int delay = 0;
+ u32 hw_state;
+ u32 rev_id;
+
  wil_dbg_misc(wil, "Resetting...\n");
 
+ /* register read */
+#define R(a) ioread32(wil->csr + HOSTADDR(a))
  /* register write */
 #define W(a, v) iowrite32(v, wil->csr + HOSTADDR(a))
  /* register set = read, OR, write */
-#define S(a, v) iowrite32(ioread32(wil->csr + HOSTADDR(a)) | v, \
-  wil->csr + HOSTADDR(a))
+#define S(a, v) W(a, R(a) | v)
+ /* register clear = read, AND with inverted, write */
+#define C(a, v) W(a, R(a) & ~v)
 
+ wil->hw_version = R(RGF_USER_FW_REV_ID);
+ rev_id = wil->hw_version & 0xff;
  /* hpal_perst_from_pad_src_n_mask */
  S(RGF_USER_CLKS_CTL_SW_RST_MASK_0, BIT(6));
  /* car_perst_rst_src_n_mask */
  S(RGF_USER_CLKS_CTL_SW_RST_MASK_0, BIT(7));
+ wmb(); /* order is important here */
 
  W(RGF_USER_MAC_CPU_0,  BIT(1)); /* mac_cpu_man_rst */
  W(RGF_USER_USER_CPU_0, BIT(1)); /* user_cpu_man_rst */
+ wmb(); /* order is important here */
 
  W(RGF_USER_CLKS_CTL_SW_RST_VEC_2, 0xFE000000);
  W(RGF_USER_CLKS_CTL_SW_RST_VEC_1, 0x0000003F);
  W(RGF_USER_CLKS_CTL_SW_RST_VEC_3, 0x00000170);
  W(RGF_USER_CLKS_CTL_SW_RST_VEC_0, 0xFFE7FC00);
+ wmb(); /* order is important here */
 
  W(RGF_USER_CLKS_CTL_SW_RST_VEC_3, 0);
  W(RGF_USER_CLKS_CTL_SW_RST_VEC_2, 0);
  W(RGF_USER_CLKS_CTL_SW_RST_VEC_1, 0);
  W(RGF_USER_CLKS_CTL_SW_RST_VEC_0, 0);
+ wmb(); /* order is important here */
 
  W(RGF_USER_CLKS_CTL_SW_RST_VEC_3, 0x00000001);
- W(RGF_USER_CLKS_CTL_SW_RST_VEC_2, 0x00000080);
+ if (rev_id == 1) {
+  W(RGF_USER_CLKS_CTL_SW_RST_VEC_2, 0x00000080);
+ } else {
+  W(RGF_PCIE_LOS_COUNTER_CTL, BIT(6) | BIT(8));
+  W(RGF_USER_CLKS_CTL_SW_RST_VEC_2, 0x00008000);
+ }
  W(RGF_USER_CLKS_CTL_SW_RST_VEC_0, 0);
+ wmb(); /* order is important here */
+
+ /* wait until device ready */
+ do {
+  msleep(1);
+  hw_state = R(RGF_USER_HW_MACHINE_STATE);
+  if (delay++ > 100) {
+   wil_err(wil, "Reset not completed, hw_state 0x%08x\n",
+    hw_state);
+   return;
+  }
+ } while (hw_state != HW_MACHINE_BOOT_DONE);
 
- wil_dbg_misc(wil, "Reset completed\n");
+ if (rev_id == 2)
+  W(RGF_PCIE_LOS_COUNTER_CTL, BIT(8));
 
+ C(RGF_USER_CLKS_CTL_0, BIT_USER_CLKS_RST_PWGD);
+ wmb(); /* order is important here */
+
+ wil_dbg_misc(wil, "Reset completed in %d ms\n", delay);
+
+#undef R
 #undef W
 #undef S
+#undef C
 }
 
 void wil_mbox_ring_le2cpus(struct wil6210_mbox_ring *r)
@@ -225,8 +394,8 @@ static int wil_wait_for_fw_ready(struct wil6210_priv *wil)
   wil_err(wil, "Firmware not ready\n");
   return -ETIME;
  } else {
-  wil_dbg_misc(wil, "FW ready after %d ms\n",
-        jiffies_to_msecs(to-left));
+  wil_info(wil, "FW ready after %d ms. HW version 0x%08x\n",
+    jiffies_to_msecs(to-left), wil->hw_version);
  }
  return 0;
 }
@@ -240,11 +409,25 @@ int wil_reset(struct wil6210_priv *wil)
 {
  int rc;
 
+ WARN_ON(!mutex_is_locked(&wil->mutex));
+
  cancel_work_sync(&wil->disconnect_worker);
  wil6210_disconnect(wil, NULL);
 
+ wil->status = 0; /* prevent NAPI from being scheduled */
+ if (test_bit(wil_status_napi_en, &wil->status)) {
+  napi_synchronize(&wil->napi_rx);
+ }
+
+ if (wil->scan_request) {
+  wil_dbg_misc(wil, "Abort scan_request 0x%p\n",
+        wil->scan_request);
+  del_timer_sync(&wil->scan_timer);
+  cfg80211_scan_done(wil->scan_request, true);
+  wil->scan_request = NULL;
+ }
+
  wil6210_disable_irq(wil);
- wil->status = 0;
 
  wmi_event_flush(wil);
 
@@ -254,9 +437,11 @@ int wil_reset(struct wil6210_priv *wil)
  /* TODO: put MAC in reset */
  wil_target_reset(wil);
 
+ wil_rx_fini(wil);
+
  /* init after reset */
  wil->pending_connect_cid = -1;
- INIT_COMPLETION(wil->wmi_ready);
+ reinit_completion(&wil->wmi_ready);
 
  /* TODO: release MAC reset */
  wil6210_enable_irq(wil);
@@ -267,6 +452,11 @@ int wil_reset(struct wil6210_priv *wil)
  return rc;
 }
 
+void wil_fw_error_recovery(struct wil6210_priv *wil)
+{
+ wil_dbg_misc(wil, "starting fw error recovery\n");
+ schedule_work(&wil->fw_error_worker);
+}
 
 void wil_link_on(struct wil6210_priv *wil)
 {
@@ -292,41 +482,38 @@ static int __wil_up(struct wil6210_priv *wil)
 {
  struct net_device *ndev = wil_to_ndev(wil);
  struct wireless_dev *wdev = wil->wdev;
- struct ieee80211_channel *channel = wdev->preset_chandef.chan;
  int rc;
- int bi;
- u16 wmi_nettype = wil_iftype_nl2wmi(wdev->iftype);
+
+ WARN_ON(!mutex_is_locked(&wil->mutex));
 
  rc = wil_reset(wil);
  if (rc)
   return rc;
 
- /* FIXME Firmware works now in PBSS mode(ToDS=0, FromDS=0) */
- wmi_nettype = wil_iftype_nl2wmi(NL80211_IFTYPE_ADHOC);
+ /* Rx VRING. After MAC and beacon */
+ rc = wil_rx_init(wil);
+ if (rc)
+  return rc;
+
  switch (wdev->iftype) {
  case NL80211_IFTYPE_STATION:
   wil_dbg_misc(wil, "type: STATION\n");
-  bi = 0;
   ndev->type = ARPHRD_ETHER;
   break;
  case NL80211_IFTYPE_AP:
   wil_dbg_misc(wil, "type: AP\n");
-  bi = 100;
   ndev->type = ARPHRD_ETHER;
   break;
  case NL80211_IFTYPE_P2P_CLIENT:
   wil_dbg_misc(wil, "type: P2P_CLIENT\n");
-  bi = 0;
   ndev->type = ARPHRD_ETHER;
   break;
  case NL80211_IFTYPE_P2P_GO:
   wil_dbg_misc(wil, "type: P2P_GO\n");
-  bi = 100;
   ndev->type = ARPHRD_ETHER;
   break;
  case NL80211_IFTYPE_MONITOR:
   wil_dbg_misc(wil, "type: Monitor\n");
-  bi = 0;
   ndev->type = ARPHRD_IEEE80211_RADIOTAP;
   /* ARPHRD_IEEE80211 or ARPHRD_IEEE80211_RADIOTAP ? */
   break;
@@ -334,36 +521,13 @@ static int __wil_up(struct wil6210_priv *wil)
   return -EOPNOTSUPP;
  }
 
- /* Apply profile in the following order: */
- /* SSID and channel for the AP */
- switch (wdev->iftype) {
- case NL80211_IFTYPE_AP:
- case NL80211_IFTYPE_P2P_GO:
-  if (wdev->ssid_len == 0) {
-   wil_err(wil, "SSID not set\n");
-   return -EINVAL;
-  }
-  rc = wmi_set_ssid(wil, wdev->ssid_len, wdev->ssid);
-  if (rc)
-   return rc;
-  break;
- default:
-  break;
- }
-
  /* MAC address - pre-requisite for other commands */
  wmi_set_mac_address(wil, ndev->dev_addr);
 
- /* Set up beaconing if required. */
- if (bi > 0) {
-  rc = wmi_pcp_start(wil, bi, wmi_nettype,
-       (channel ? channel->hw_value : 0));
-  if (rc)
-   return rc;
- }
 
- /* Rx VRING. After MAC and beacon */
- wil_rx_init(wil);
+ napi_enable(&wil->napi_rx);
+ napi_enable(&wil->napi_tx);
+ set_bit(wil_status_napi_en, &wil->status);
 
  return 0;
 }
@@ -381,7 +545,14 @@ int wil_up(struct wil6210_priv *wil)
 
 static int __wil_down(struct wil6210_priv *wil)
 {
+ WARN_ON(!mutex_is_locked(&wil->mutex));
+
+ clear_bit(wil_status_napi_en, &wil->status);
+ napi_disable(&wil->napi_rx);
+ napi_disable(&wil->napi_tx);
+
  if (wil->scan_request) {
+  del_timer_sync(&wil->scan_timer);
   cfg80211_scan_done(wil->scan_request, true);
   wil->scan_request = NULL;
  }
@@ -402,3 +573,19 @@ int wil_down(struct wil6210_priv *wil)
 
  return rc;
 }
+
+int wil_find_cid(struct wil6210_priv *wil, const u8 *mac)
+{
+ int i;
+ int rc = -ENOENT;
+
+ for (i = 0; i < ARRAY_SIZE(wil->sta); i++) {
+  if ((wil->sta[i].status != wil_sta_unused) &&
+      ether_addr_equal(wil->sta[i].addr, mac)) {
+   rc = i;
+   break;
+  }
+ }
+
+ return rc;
+}
diff --git a/drivers/net/wireless/ath/wil6210/netdev.c b/drivers/net/wireless/ath/wil6210/netdev.c
index 098a8ec..106b6dc 100644
--- a/drivers/net/wireless/ath/wil6210/netdev.c
+++ b/drivers/net/wireless/ath/wil6210/netdev.c
@@ -32,14 +32,77 @@ static int wil_stop(struct net_device *ndev)
  return wil_down(wil);
 }
 
+static int wil_change_mtu(struct net_device *ndev, int new_mtu)
+{
+ struct wil6210_priv *wil = ndev_to_wil(ndev);
+
+ if (new_mtu < 68 || new_mtu > IEEE80211_MAX_DATA_LEN_DMG)
+  return -EINVAL;
+
+ wil_dbg_misc(wil, "change MTU %d -> %d\n", ndev->mtu, new_mtu);
+ ndev->mtu = new_mtu;
+
+ return 0;
+}
+
 static const struct net_device_ops wil_netdev_ops = {
  .ndo_open  = wil_open,
  .ndo_stop  = wil_stop,
  .ndo_start_xmit  = wil_start_xmit,
  .ndo_set_mac_address = eth_mac_addr,
  .ndo_validate_addr = eth_validate_addr,
+ .ndo_change_mtu  = wil_change_mtu,
 };
 
+static int wil6210_netdev_poll_rx(struct napi_struct *napi, int budget)
+{
+ struct wil6210_priv *wil = container_of(napi, struct wil6210_priv,
+      napi_rx);
+ int quota = budget;
+ int done;
+
+ wil_rx_handle(wil, &quota);
+ done = budget - quota;
+
+ if (done <= 1) { /* burst ends - only one packet processed */
+  napi_complete(napi);
+  wil6210_unmask_irq_rx(wil);
+  wil_dbg_txrx(wil, "NAPI RX complete\n");
+ }
+
+ wil_dbg_txrx(wil, "NAPI RX poll(%d) done %d\n", budget, done);
+
+ return done;
+}
+
+static int wil6210_netdev_poll_tx(struct napi_struct *napi, int budget)
+{
+ struct wil6210_priv *wil = container_of(napi, struct wil6210_priv,
+      napi_tx);
+ int tx_done = 0;
+ uint i;
+
+ /* always process ALL Tx complete, regardless budget - it is fast */
+ for (i = 0; i < WIL6210_MAX_TX_RINGS; i++) {
+  struct vring *vring = &wil->vring_tx[i];
+
+  if (!vring->va)
+   continue;
+
+  tx_done += wil_tx_complete(wil, i);
+ }
+
+ if (tx_done <= 1) { /* burst ends - only one packet processed */
+  napi_complete(napi);
+  wil6210_unmask_irq_tx(wil);
+  wil_dbg_txrx(wil, "NAPI TX complete\n");
+ }
+
+ wil_dbg_txrx(wil, "NAPI TX poll(%d) done %d\n", budget, tx_done);
+
+ return min(tx_done, budget);
+}
+
 void *wil_if_alloc(struct device *dev, void __iomem *csr)
 {
  struct net_device *ndev;
@@ -78,9 +141,17 @@ void *wil_if_alloc(struct device *dev, void __iomem *csr)
 
  ndev->netdev_ops = &wil_netdev_ops;
  ndev->ieee80211_ptr = wdev;
+ ndev->hw_features = NETIF_F_HW_CSUM | NETIF_F_RXCSUM |
+       NETIF_F_SG | NETIF_F_GRO;
+ ndev->features |= ndev->hw_features;
  SET_NETDEV_DEV(ndev, wiphy_dev(wdev->wiphy));
  wdev->netdev = ndev;
 
+ netif_napi_add(ndev, &wil->napi_rx, wil6210_netdev_poll_rx,
+         WIL6210_NAPI_BUDGET);
+ netif_napi_add(ndev, &wil->napi_tx, wil6210_netdev_poll_tx,
+         WIL6210_NAPI_BUDGET);
+
  wil_link_off(wil);
 
  return wil;
diff --git a/drivers/net/wireless/ath/wil6210/pcie_bus.c b/drivers/net/wireless/ath/wil6210/pcie_bus.c
index eb1dc7a..1e2e07b 100644
--- a/drivers/net/wireless/ath/wil6210/pcie_bus.c
+++ b/drivers/net/wireless/ath/wil6210/pcie_bus.c
@@ -41,36 +41,36 @@ static int wil_if_pcie_enable(struct wil6210_priv *wil)
  switch (use_msi) {
  case 3:
  case 1:
+  wil_dbg_misc(wil, "Setup %d MSI interrupts\n", use_msi);
+  break;
  case 0:
+  wil_dbg_misc(wil, "MSI interrupts disabled, use INTx\n");
   break;
  default:
-  wil_err(wil, "Invalid use_msi=%d, default to 1\n",
-   use_msi);
+  wil_err(wil, "Invalid use_msi=%d, default to 1\n", use_msi);
   use_msi = 1;
  }
- wil->n_msi = use_msi;
- if (wil->n_msi) {
-  wil_dbg_misc(wil, "Setup %d MSI interrupts\n", use_msi);
-  rc = pci_enable_msi_block(pdev, wil->n_msi);
-  if (rc && (wil->n_msi == 3)) {
-   wil_err(wil, "3 MSI mode failed, try 1 MSI\n");
-   wil->n_msi = 1;
-   rc = pci_enable_msi_block(pdev, wil->n_msi);
-  }
-  if (rc) {
-   wil_err(wil, "pci_enable_msi failed, use INTx\n");
-   wil->n_msi = 0;
-  }
- } else {
-  wil_dbg_misc(wil, "MSI interrupts disabled, use INTx\n");
+
+ if (use_msi == 3 && pci_enable_msi_range(pdev, 3, 3) < 0) {
+  wil_err(wil, "3 MSI mode failed, try 1 MSI\n");
+  use_msi = 1;
+ }
+
+ if (use_msi == 1 && pci_enable_msi(pdev)) {
+  wil_err(wil, "pci_enable_msi failed, use INTx\n");
+  use_msi = 0;
  }
 
+ wil->n_msi = use_msi;
+
  rc = wil6210_init_irq(wil, pdev->irq);
  if (rc)
   goto stop_master;
 
  /* need reset here to obtain MAC */
+ mutex_lock(&wil->mutex);
  rc = wil_reset(wil);
+ mutex_unlock(&wil->mutex);
  if (rc)
   goto release_irq;
 
@@ -138,7 +138,7 @@ static int wil_pcie_probe(struct pci_dev *pdev, const struct pci_device_id *id)
   goto err_release_reg;
  }
  /* rollback to err_iounmap */
- dev_info(&pdev->dev, "CSR at %pR -> %p\n", &pdev->resource[0], csr);
+ dev_info(&pdev->dev, "CSR at %pR -> 0x%p\n", &pdev->resource[0], csr);
 
  wil = wil_if_alloc(dev, csr);
  if (IS_ERR(wil)) {
@@ -151,6 +151,7 @@ static int wil_pcie_probe(struct pci_dev *pdev, const struct pci_device_id *id)
  pci_set_drvdata(pdev, wil);
  wil->pdev = pdev;
 
+ wil6210_clear_irq(wil);
  /* FW should raise IRQ when ready */
  rc = wil_if_pcie_enable(wil);
  if (rc) {
@@ -197,7 +198,6 @@ static void wil_pcie_remove(struct pci_dev *pdev)
  pci_iounmap(pdev, wil->csr);
  pci_release_region(pdev, 0);
  pci_disable_device(pdev);
- pci_set_drvdata(pdev, NULL);
 }
 
 static DEFINE_PCI_DEVICE_TABLE(wil6210_pcie_ids) = {
diff --git a/drivers/net/wireless/ath/wil6210/rx_reorder.c b/drivers/net/wireless/ath/wil6210/rx_reorder.c
new file mode 100644
index 0000000..747ae12
--- /dev/null
+++ b/drivers/net/wireless/ath/wil6210/rx_reorder.c
@@ -0,0 +1,201 @@
+#include "wil6210.h"
+#include "txrx.h"
+
+#define SEQ_MODULO 0x1000
+#define SEQ_MASK   0xfff
+
+static inline int seq_less(u16 sq1, u16 sq2)
+{
+ return ((sq1 - sq2) & SEQ_MASK) > (SEQ_MODULO >> 1);
+}
+
+static inline u16 seq_inc(u16 sq)
+{
+ return (sq + 1) & SEQ_MASK;
+}
+
+static inline u16 seq_sub(u16 sq1, u16 sq2)
+{
+ return (sq1 - sq2) & SEQ_MASK;
+}
+
+static inline int reorder_index(struct wil_tid_ampdu_rx *r, u16 seq)
+{
+ return seq_sub(seq, r->ssn) % r->buf_size;
+}
+
+static void wil_release_reorder_frame(struct wil6210_priv *wil,
+          struct wil_tid_ampdu_rx *r,
+          int index)
+{
+ struct net_device *ndev = wil_to_ndev(wil);
+ struct sk_buff *skb = r->reorder_buf[index];
+
+ if (!skb)
+  goto no_frame;
+
+ /* release the frame from the reorder ring buffer */
+ r->stored_mpdu_num--;
+ r->reorder_buf[index] = NULL;
+ wil_netif_rx_any(skb, ndev);
+
+no_frame:
+ r->head_seq_num = seq_inc(r->head_seq_num);
+}
+
+static void wil_release_reorder_frames(struct wil6210_priv *wil,
+           struct wil_tid_ampdu_rx *r,
+           u16 hseq)
+{
+ int index;
+
+ /* note: this function is never called with
+  * hseq preceding r->head_seq_num, i.e it is always true
+  * !seq_less(hseq, r->head_seq_num)
+  * and thus on loop exit it should be
+  * r->head_seq_num == hseq
+  */
+ while (seq_less(r->head_seq_num, hseq) && r->stored_mpdu_num) {
+  index = reorder_index(r, r->head_seq_num);
+  wil_release_reorder_frame(wil, r, index);
+ }
+ r->head_seq_num = hseq;
+}
+
+static void wil_reorder_release(struct wil6210_priv *wil,
+    struct wil_tid_ampdu_rx *r)
+{
+ int index = reorder_index(r, r->head_seq_num);
+
+ while (r->reorder_buf[index]) {
+  wil_release_reorder_frame(wil, r, index);
+  index = reorder_index(r, r->head_seq_num);
+ }
+}
+
+void wil_rx_reorder(struct wil6210_priv *wil, struct sk_buff *skb)
+{
+ struct net_device *ndev = wil_to_ndev(wil);
+ struct vring_rx_desc *d = wil_skb_rxdesc(skb);
+ int tid = wil_rxdesc_tid(d);
+ int cid = wil_rxdesc_cid(d);
+ int mid = wil_rxdesc_mid(d);
+ u16 seq = wil_rxdesc_seq(d);
+ struct wil_sta_info *sta = &wil->sta[cid];
+ struct wil_tid_ampdu_rx *r = sta->tid_rx[tid];
+ u16 hseq;
+ int index;
+
+ wil_dbg_txrx(wil, "MID %d CID %d TID %d Seq 0x%03x\n",
+       mid, cid, tid, seq);
+
+ if (!r) {
+  wil_netif_rx_any(skb, ndev);
+  return;
+ }
+
+ hseq = r->head_seq_num;
+
+ spin_lock(&r->reorder_lock);
+
+ /** Due to the race between WMI events, where BACK establishment
+  * reported, and data Rx, few packets may be pass up before reorder
+  * buffer get allocated. Catch up by pretending SSN is what we
+  * see in the 1-st Rx packet
+  */
+ if (r->first_time) {
+  r->first_time = false;
+  if (seq != r->head_seq_num) {
+   wil_err(wil, "Error: 1-st frame with wrong sequence"
+    " %d, should be %d. Fixing...\n", seq,
+    r->head_seq_num);
+   r->head_seq_num = seq;
+   r->ssn = seq;
+  }
+ }
+
+ /* frame with out of date sequence number */
+ if (seq_less(seq, r->head_seq_num)) {
+  dev_kfree_skb(skb);
+  goto out;
+ }
+
+ /*
+  * If frame the sequence number exceeds our buffering window
+  * size release some previous frames to make room for this one.
+  */
+ if (!seq_less(seq, r->head_seq_num + r->buf_size)) {
+  hseq = seq_inc(seq_sub(seq, r->buf_size));
+  /* release stored frames up to new head to stack */
+  wil_release_reorder_frames(wil, r, hseq);
+ }
+
+ /* Now the new frame is always in the range of the reordering buffer */
+
+ index = reorder_index(r, seq);
+
+ /* check if we already stored this frame */
+ if (r->reorder_buf[index]) {
+  dev_kfree_skb(skb);
+  goto out;
+ }
+
+ /*
+  * If the current MPDU is in the right order and nothing else
+  * is stored we can process it directly, no need to buffer it.
+  * If it is first but there's something stored, we may be able
+  * to release frames after this one.
+  */
+ if (seq == r->head_seq_num && r->stored_mpdu_num == 0) {
+  r->head_seq_num = seq_inc(r->head_seq_num);
+  wil_netif_rx_any(skb, ndev);
+  goto out;
+ }
+
+ /* put the frame in the reordering buffer */
+ r->reorder_buf[index] = skb;
+ r->reorder_time[index] = jiffies;
+ r->stored_mpdu_num++;
+ wil_reorder_release(wil, r);
+
+out:
+ spin_unlock(&r->reorder_lock);
+}
+
+struct wil_tid_ampdu_rx *wil_tid_ampdu_rx_alloc(struct wil6210_priv *wil,
+      int size, u16 ssn)
+{
+ struct wil_tid_ampdu_rx *r = kzalloc(sizeof(*r), GFP_KERNEL);
+ if (!r)
+  return NULL;
+
+ r->reorder_buf =
+  kcalloc(size, sizeof(struct sk_buff *), GFP_KERNEL);
+ r->reorder_time =
+  kcalloc(size, sizeof(unsigned long), GFP_KERNEL);
+ if (!r->reorder_buf || !r->reorder_time) {
+  kfree(r->reorder_buf);
+  kfree(r->reorder_time);
+  kfree(r);
+  return NULL;
+ }
+
+ spin_lock_init(&r->reorder_lock);
+ r->ssn = ssn;
+ r->head_seq_num = ssn;
+ r->buf_size = size;
+ r->stored_mpdu_num = 0;
+ r->first_time = true;
+ return r;
+}
+
+void wil_tid_ampdu_rx_free(struct wil6210_priv *wil,
+      struct wil_tid_ampdu_rx *r)
+{
+ if (!r)
+  return;
+ wil_release_reorder_frames(wil, r, r->head_seq_num + r->buf_size);
+ kfree(r->reorder_buf);
+ kfree(r->reorder_time);
+ kfree(r);
+}
diff --git a/drivers/net/wireless/ath/wil6210/trace.c b/drivers/net/wireless/ath/wil6210/trace.c
new file mode 100644
index 0000000..cd2534b
--- /dev/null
+++ b/drivers/net/wireless/ath/wil6210/trace.c
@@ -0,0 +1,20 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <linux/module.h>
+
+#define CREATE_TRACE_POINTS
+#include "trace.h"
diff --git a/drivers/net/wireless/ath/wil6210/trace.h b/drivers/net/wireless/ath/wil6210/trace.h
new file mode 100644
index 0000000..e59239d
--- /dev/null
+++ b/drivers/net/wireless/ath/wil6210/trace.h
@@ -0,0 +1,239 @@
+/*
+ * Copyright (c) 2013 Qualcomm Atheros, Inc.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#undef TRACE_SYSTEM
+#define TRACE_SYSTEM wil6210
+#if !defined(WIL6210_TRACE_H) || defined(TRACE_HEADER_MULTI_READ)
+#define WIL6210_TRACE_H
+
+#include <linux/tracepoint.h>
+#include "wil6210.h"
+#include "txrx.h"
+
+/* create empty functions when tracing is disabled */
+#if !defined(CONFIG_WIL6210_TRACING) || defined(__CHECKER__)
+
+#undef TRACE_EVENT
+#define TRACE_EVENT(name, proto, ...) \
+static inline void trace_ ## name(proto) {}
+#undef DECLARE_EVENT_CLASS
+#define DECLARE_EVENT_CLASS(...)
+#undef DEFINE_EVENT
+#define DEFINE_EVENT(evt_class, name, proto, ...) \
+static inline void trace_ ## name(proto) {}
+#endif /* !CONFIG_WIL6210_TRACING || defined(__CHECKER__) */
+
+DECLARE_EVENT_CLASS(wil6210_wmi,
+ TP_PROTO(struct wil6210_mbox_hdr_wmi *wmi, void *buf, u16 buf_len),
+
+ TP_ARGS(wmi, buf, buf_len),
+
+ TP_STRUCT__entry(
+  __field(u8, mid)
+  __field(u16, id)
+  __field(u32, timestamp)
+  __field(u16, buf_len)
+  __dynamic_array(u8, buf, buf_len)
+ ),
+
+ TP_fast_assign(
+  __entry->mid = wmi->mid;
+  __entry->id = le16_to_cpu(wmi->id);
+  __entry->timestamp = le32_to_cpu(wmi->timestamp);
+  __entry->buf_len = buf_len;
+  memcpy(__get_dynamic_array(buf), buf, buf_len);
+ ),
+
+ TP_printk(
+  "MID %d id 0x%04x len %d timestamp %d",
+  __entry->mid, __entry->id, __entry->buf_len, __entry->timestamp
+ )
+);
+
+DEFINE_EVENT(wil6210_wmi, wil6210_wmi_cmd,
+ TP_PROTO(struct wil6210_mbox_hdr_wmi *wmi, void *buf, u16 buf_len),
+ TP_ARGS(wmi, buf, buf_len)
+);
+
+DEFINE_EVENT(wil6210_wmi, wil6210_wmi_event,
+ TP_PROTO(struct wil6210_mbox_hdr_wmi *wmi, void *buf, u16 buf_len),
+ TP_ARGS(wmi, buf, buf_len)
+);
+
+#define WIL6210_MSG_MAX (200)
+
+DECLARE_EVENT_CLASS(wil6210_log_event,
+ TP_PROTO(struct va_format *vaf),
+ TP_ARGS(vaf),
+ TP_STRUCT__entry(
+  __dynamic_array(char, msg, WIL6210_MSG_MAX)
+ ),
+ TP_fast_assign(
+  WARN_ON_ONCE(vsnprintf(__get_dynamic_array(msg),
+           WIL6210_MSG_MAX,
+           vaf->fmt,
+           *vaf->va) >= WIL6210_MSG_MAX);
+ ),
+ TP_printk("%s", __get_str(msg))
+);
+
+DEFINE_EVENT(wil6210_log_event, wil6210_log_err,
+ TP_PROTO(struct va_format *vaf),
+ TP_ARGS(vaf)
+);
+
+DEFINE_EVENT(wil6210_log_event, wil6210_log_info,
+ TP_PROTO(struct va_format *vaf),
+ TP_ARGS(vaf)
+);
+
+DEFINE_EVENT(wil6210_log_event, wil6210_log_dbg,
+ TP_PROTO(struct va_format *vaf),
+ TP_ARGS(vaf)
+);
+
+#define wil_pseudo_irq_cause(x) __print_flags(x, "|", \
+ {BIT_DMA_PSEUDO_CAUSE_RX, "Rx" },  \
+ {BIT_DMA_PSEUDO_CAUSE_TX, "Tx" },  \
+ {BIT_DMA_PSEUDO_CAUSE_MISC, "Misc" })
+
+TRACE_EVENT(wil6210_irq_pseudo,
+ TP_PROTO(u32 x),
+ TP_ARGS(x),
+ TP_STRUCT__entry(
+  __field(u32, x)
+ ),
+ TP_fast_assign(
+  __entry->x = x;
+ ),
+ TP_printk("cause 0x%08x : %s", __entry->x,
+    wil_pseudo_irq_cause(__entry->x))
+);
+
+DECLARE_EVENT_CLASS(wil6210_irq,
+ TP_PROTO(u32 x),
+ TP_ARGS(x),
+ TP_STRUCT__entry(
+  __field(u32, x)
+ ),
+ TP_fast_assign(
+  __entry->x = x;
+ ),
+ TP_printk("cause 0x%08x", __entry->x)
+);
+
+DEFINE_EVENT(wil6210_irq, wil6210_irq_rx,
+ TP_PROTO(u32 x),
+ TP_ARGS(x)
+);
+
+DEFINE_EVENT(wil6210_irq, wil6210_irq_tx,
+ TP_PROTO(u32 x),
+ TP_ARGS(x)
+);
+
+DEFINE_EVENT(wil6210_irq, wil6210_irq_misc,
+ TP_PROTO(u32 x),
+ TP_ARGS(x)
+);
+
+DEFINE_EVENT(wil6210_irq, wil6210_irq_misc_thread,
+ TP_PROTO(u32 x),
+ TP_ARGS(x)
+);
+
+TRACE_EVENT(wil6210_rx,
+ TP_PROTO(u16 index, struct vring_rx_desc *d),
+ TP_ARGS(index, d),
+ TP_STRUCT__entry(
+  __field(u16, index)
+  __field(unsigned int, len)
+  __field(u8, mid)
+  __field(u8, cid)
+  __field(u8, tid)
+  __field(u8, type)
+  __field(u8, subtype)
+  __field(u16, seq)
+  __field(u8, mcs)
+ ),
+ TP_fast_assign(
+  __entry->index = index;
+  __entry->len = d->dma.length;
+  __entry->mid = wil_rxdesc_mid(d);
+  __entry->cid = wil_rxdesc_cid(d);
+  __entry->tid = wil_rxdesc_tid(d);
+  __entry->type = wil_rxdesc_ftype(d);
+  __entry->subtype = wil_rxdesc_subtype(d);
+  __entry->seq = wil_rxdesc_seq(d);
+  __entry->mcs = wil_rxdesc_mcs(d);
+ ),
+ TP_printk("index %d len %d mid %d cid %d tid %d mcs %d seq 0x%03x"
+    " type 0x%1x subtype 0x%1x", __entry->index, __entry->len,
+    __entry->mid, __entry->cid, __entry->tid, __entry->mcs,
+    __entry->seq, __entry->type, __entry->subtype)
+);
+
+TRACE_EVENT(wil6210_tx,
+ TP_PROTO(u8 vring, u16 index, unsigned int len, u8 frags),
+ TP_ARGS(vring, index, len, frags),
+ TP_STRUCT__entry(
+  __field(u8, vring)
+  __field(u8, frags)
+  __field(u16, index)
+  __field(unsigned int, len)
+ ),
+ TP_fast_assign(
+  __entry->vring = vring;
+  __entry->frags = frags;
+  __entry->index = index;
+  __entry->len = len;
+ ),
+ TP_printk("vring %d index %d len %d frags %d",
+    __entry->vring, __entry->index, __entry->len, __entry->frags)
+);
+
+TRACE_EVENT(wil6210_tx_done,
+ TP_PROTO(u8 vring, u16 index, unsigned int len, u8 err),
+ TP_ARGS(vring, index, len, err),
+ TP_STRUCT__entry(
+  __field(u8, vring)
+  __field(u8, err)
+  __field(u16, index)
+  __field(unsigned int, len)
+ ),
+ TP_fast_assign(
+  __entry->vring = vring;
+  __entry->index = index;
+  __entry->len = len;
+  __entry->err = err;
+ ),
+ TP_printk("vring %d index %d len %d err 0x%02x",
+    __entry->vring, __entry->index, __entry->len,
+    __entry->err)
+);
+
+#endif /* WIL6210_TRACE_H || TRACE_HEADER_MULTI_READ*/
+
+#if defined(CONFIG_WIL6210_TRACING) && !defined(__CHECKER__)
+/* we don't want to use include/trace/events */
+#undef TRACE_INCLUDE_PATH
+#define TRACE_INCLUDE_PATH .
+#undef TRACE_INCLUDE_FILE
+#define TRACE_INCLUDE_FILE trace
+
+/* This part must be outside protection */
+#include <trace/define_trace.h>
+#endif /* defined(CONFIG_WIL6210_TRACING) && !defined(__CHECKER__) */
diff --git a/drivers/net/wireless/ath/wil6210/txrx.c b/drivers/net/wireless/ath/wil6210/txrx.c
index 7970245..0784ef3 100644
--- a/drivers/net/wireless/ath/wil6210/txrx.c
+++ b/drivers/net/wireless/ath/wil6210/txrx.c
@@ -18,10 +18,15 @@
 #include <net/ieee80211_radiotap.h>
 #include <linux/if_arp.h>
 #include <linux/moduleparam.h>
+#include <linux/ip.h>
+#include <linux/ipv6.h>
+#include <net/ipv6.h>
+#include <linux/prefetch.h>
 
 #include "wil6210.h"
 #include "wmi.h"
 #include "txrx.h"
+#include "trace.h"
 
 static bool rtap_include_phy_info;
 module_param(rtap_include_phy_info, bool, S_IRUGO);
@@ -59,6 +64,22 @@ static inline int wil_vring_avail_tx(struct vring *vring)
  return vring->size - used - 1;
 }
 
+/**
+ * wil_vring_wmark_low - low watermark for available descriptor space
+ */
+static inline int wil_vring_wmark_low(struct vring *vring)
+{
+ return vring->size/8;
+}
+
+/**
+ * wil_vring_wmark_high - high watermark for available descriptor space
+ */
+static inline int wil_vring_wmark_high(struct vring *vring)
+{
+ return vring->size/4;
+}
+
 static int wil_vring_alloc(struct wil6210_priv *wil, struct vring *vring)
 {
  struct device *dev = wil_to_dev(wil);
@@ -69,7 +90,7 @@ static int wil_vring_alloc(struct wil6210_priv *wil, struct vring *vring)
 
  vring->swhead = 0;
  vring->swtail = 0;
- vring->ctx = kzalloc(vring->size * sizeof(vring->ctx[0]), GFP_KERNEL);
+ vring->ctx = kcalloc(vring->size, sizeof(vring->ctx[0]), GFP_KERNEL);
  if (!vring->ctx) {
   vring->va = NULL;
   return -ENOMEM;
@@ -89,16 +110,33 @@ static int wil_vring_alloc(struct wil6210_priv *wil, struct vring *vring)
   * we can use any
   */
  for (i = 0; i < vring->size; i++) {
-  volatile struct vring_tx_desc *d = &(vring->va[i].tx);
-  d->dma.status = TX_DMA_STATUS_DU;
+  volatile struct vring_tx_desc *_d = &(vring->va[i].tx);
+  _d->dma.status = TX_DMA_STATUS_DU;
  }
 
- wil_dbg_misc(wil, "vring[%d] 0x%p:0x%016llx 0x%p\n", vring->size,
-       vring->va, (unsigned long long)vring->pa, vring->ctx);
+ wil_dbg_misc(wil, "vring[%d] 0x%p:%pad 0x%p\n", vring->size,
+       vring->va, &vring->pa, vring->ctx);
 
  return 0;
 }
 
+static void wil_txdesc_unmap(struct device *dev, struct vring_tx_desc *d,
+        struct wil_ctx *ctx)
+{
+ dma_addr_t pa = wil_desc_addr(&d->dma.addr);
+ u16 dmalen = le16_to_cpu(d->dma.length);
+ switch (ctx->mapped_as) {
+ case wil_mapped_as_single:
+  dma_unmap_single(dev, pa, dmalen, DMA_TO_DEVICE);
+  break;
+ case wil_mapped_as_page:
+  dma_unmap_page(dev, pa, dmalen, DMA_TO_DEVICE);
+  break;
+ default:
+  break;
+ }
+}
+
 static void wil_vring_free(struct wil6210_priv *wil, struct vring *vring,
       int tx)
 {
@@ -106,31 +144,32 @@ static void wil_vring_free(struct wil6210_priv *wil, struct vring *vring,
  size_t sz = vring->size * sizeof(vring->va[0]);
 
  while (!wil_vring_is_empty(vring)) {
+  dma_addr_t pa;
+  u16 dmalen;
+  struct wil_ctx *ctx;
+
   if (tx) {
-   volatile struct vring_tx_desc *d =
+   struct vring_tx_desc dd, *d = &dd;
+   volatile struct vring_tx_desc *_d =
      &vring->va[vring->swtail].tx;
-   dma_addr_t pa = d->dma.addr_low |
-     ((u64)d->dma.addr_high << 32);
-   struct sk_buff *skb = vring->ctx[vring->swtail];
-   if (skb) {
-    dma_unmap_single(dev, pa, d->dma.length,
-       DMA_TO_DEVICE);
-    dev_kfree_skb_any(skb);
-    vring->ctx[vring->swtail] = NULL;
-   } else {
-    dma_unmap_page(dev, pa, d->dma.length,
-            DMA_TO_DEVICE);
-   }
+
+   ctx = &vring->ctx[vring->swtail];
+   *d = *_d;
+   wil_txdesc_unmap(dev, d, ctx);
+   if (ctx->skb)
+    dev_kfree_skb_any(ctx->skb);
    vring->swtail = wil_vring_next_tail(vring);
   } else { /* rx */
-   volatile struct vring_rx_desc *d =
-     &vring->va[vring->swtail].rx;
-   dma_addr_t pa = d->dma.addr_low |
-     ((u64)d->dma.addr_high << 32);
-   struct sk_buff *skb = vring->ctx[vring->swhead];
-   dma_unmap_single(dev, pa, d->dma.length,
-      DMA_FROM_DEVICE);
-   kfree_skb(skb);
+   struct vring_rx_desc dd, *d = &dd;
+   volatile struct vring_rx_desc *_d =
+     &vring->va[vring->swhead].rx;
+
+   ctx = &vring->ctx[vring->swhead];
+   *d = *_d;
+   pa = wil_desc_addr(&d->dma.addr);
+   dmalen = le16_to_cpu(d->dma.length);
+   dma_unmap_single(dev, pa, dmalen, DMA_FROM_DEVICE);
+   kfree_skb(ctx->skb);
    wil_vring_advance_head(vring, 1);
   }
  }
@@ -151,7 +190,8 @@ static int wil_vring_alloc_skb(struct wil6210_priv *wil, struct vring *vring,
 {
  struct device *dev = wil_to_dev(wil);
  unsigned int sz = RX_BUF_LEN;
- volatile struct vring_rx_desc *d = &(vring->va[i].rx);
+ struct vring_rx_desc dd, *d = &dd;
+ volatile struct vring_rx_desc *_d = &(vring->va[i].rx);
  dma_addr_t pa;
 
  /* TODO align */
@@ -169,14 +209,14 @@ static int wil_vring_alloc_skb(struct wil6210_priv *wil, struct vring *vring,
  }
 
  d->dma.d0 = BIT(9) | RX_DMA_D0_CMD_DMA_IT;
- d->dma.addr_low = lower_32_bits(pa);
- d->dma.addr_high = (u16)upper_32_bits(pa);
+ wil_desc_addr_set(&d->dma.addr, pa);
  /* ip_length don't care */
  /* b11 don't care */
  /* error don't care */
  d->dma.status = 0; /* BIT(0) should be 0 for HW_OWNED */
- d->dma.length = sz;
- vring->ctx[i] = skb;
+ d->dma.length = cpu_to_le16(sz);
+ *_d = *d;
+ vring->ctx[i].skb = skb;
 
  return 0;
 }
@@ -321,45 +361,65 @@ static struct sk_buff *wil_vring_reap_rx(struct wil6210_priv *wil,
 {
  struct device *dev = wil_to_dev(wil);
  struct net_device *ndev = wil_to_ndev(wil);
- volatile struct vring_rx_desc *d;
- struct vring_rx_desc *d1;
+ volatile struct vring_rx_desc *_d;
+ struct vring_rx_desc *d;
  struct sk_buff *skb;
  dma_addr_t pa;
  unsigned int sz = RX_BUF_LEN;
+ u16 dmalen;
  u8 ftype;
  u8 ds_bits;
+ int cid;
+ struct wil_net_stats *stats;
+
 
  BUILD_BUG_ON(sizeof(struct vring_rx_desc) > sizeof(skb->cb));
 
  if (wil_vring_is_empty(vring))
   return NULL;
 
- d = &(vring->va[vring->swhead].rx);
- if (!(d->dma.status & RX_DMA_STATUS_DU)) {
+ _d = &(vring->va[vring->swhead].rx);
+ if (!(_d->dma.status & RX_DMA_STATUS_DU)) {
   /* it is not error, we just reached end of Rx done area */
   return NULL;
  }
 
- pa = d->dma.addr_low | ((u64)d->dma.addr_high << 32);
- skb = vring->ctx[vring->swhead];
+ skb = vring->ctx[vring->swhead].skb;
+ d = wil_skb_rxdesc(skb);
+ *d = *_d;
+ pa = wil_desc_addr(&d->dma.addr);
+ vring->ctx[vring->swhead].skb = NULL;
+ wil_vring_advance_head(vring, 1);
+
  dma_unmap_single(dev, pa, sz, DMA_FROM_DEVICE);
- skb_trim(skb, d->dma.length);
+ dmalen = le16_to_cpu(d->dma.length);
 
- d1 = wil_skb_rxdesc(skb);
- *d1 = *d;
+ trace_wil6210_rx(vring->swhead, d);
+ wil_dbg_txrx(wil, "Rx[%3d] : %d bytes\n", vring->swhead, dmalen);
+ wil_hex_dump_txrx("Rx ", DUMP_PREFIX_NONE, 32, 4,
+     (const void *)d, sizeof(*d), false);
 
- wil->stats.last_mcs_rx = wil_rxdesc_mcs(d1);
+ if (dmalen > sz) {
+  wil_err(wil, "Rx size too large: %d bytes!\n", dmalen);
+  kfree_skb(skb);
+  return NULL;
+ }
+ skb_trim(skb, dmalen);
+
+ prefetch(skb->data);
+
+ wil_hex_dump_txrx("Rx ", DUMP_PREFIX_OFFSET, 16, 1,
+     skb->data, skb_headlen(skb), false);
+
+ cid = wil_rxdesc_cid(d);
+ stats = &wil->sta[cid].stats;
+ stats->last_mcs_rx = wil_rxdesc_mcs(d);
+ wil->stats.last_mcs_rx = stats->last_mcs_rx;
 
  /* use radiotap header only if required */
  if (ndev->type == ARPHRD_IEEE80211_RADIOTAP)
   wil_rx_add_radiotap_header(wil, skb);
 
- wil_dbg_txrx(wil, "Rx[%3d] : %d bytes\n", vring->swhead, d->dma.length);
- wil_hex_dump_txrx("Rx ", DUMP_PREFIX_NONE, 32, 4,
-     (const void *)d, sizeof(*d), false);
-
- wil_vring_advance_head(vring, 1);
-
  /* no extra checks if in sniffer mode */
  if (ndev->type != ARPHRD_ETHER)
   return skb;
@@ -368,7 +428,7 @@ static struct sk_buff *wil_vring_reap_rx(struct wil6210_priv *wil,
   * Driver should recognize it by frame type, that is found
   * in Rx descriptor. If type is not data, it is 802.11 frame as is
   */
- ftype = wil_rxdesc_ftype(d1) << 2;
+ ftype = wil_rxdesc_ftype(d) << 2;
  if (ftype != IEEE80211_FTYPE_DATA) {
   wil_dbg_txrx(wil, "Non-data frame ftype 0x%08x\n", ftype);
   /* TODO: process it */
@@ -383,7 +443,22 @@ static struct sk_buff *wil_vring_reap_rx(struct wil6210_priv *wil,
   return NULL;
  }
 
- ds_bits = wil_rxdesc_ds_bits(d1);
+ /* L4 IDENT is on when HW calculated checksum, check status
+  * and in case of error drop the packet
+  * higher stack layers will handle retransmission (if required)
+  */
+ if (d->dma.status & RX_DMA_STATUS_L4_IDENT) {
+  /* L4 protocol identified, csum calculated */
+  if ((d->dma.error & RX_DMA_ERROR_L4_ERR) == 0)
+   skb->ip_summed = CHECKSUM_UNNECESSARY;
+  /* If HW reports bad checksum, let IP stack re-check it
+   * For example, HW don't understand Microsoft IP stack that
+   * mis-calculates TCP checksum - if it should be 0x0,
+   * it writes 0xffff in violation of RFC 1624
+   */
+ }
+
+ ds_bits = wil_rxdesc_ds_bits(d);
  if (ds_bits == 1) {
   /*
    * HW bug - in ToDS mode, i.e. Rx on AP side,
@@ -425,34 +500,39 @@ static int wil_rx_refill(struct wil6210_priv *wil, int count)
 
 /*
  * Pass Rx packet to the netif. Update statistics.
+ * Called in softirq context (NAPI poll).
  */
-static void wil_netif_rx_any(struct sk_buff *skb, struct net_device *ndev)
+void wil_netif_rx_any(struct sk_buff *skb, struct net_device *ndev)
 {
- int rc;
+ gro_result_t rc;
+ struct wil6210_priv *wil = ndev_to_wil(ndev);
  unsigned int len = skb->len;
+ struct vring_rx_desc *d = wil_skb_rxdesc(skb);
+ int cid = wil_rxdesc_cid(d);
+ struct wil_net_stats *stats = &wil->sta[cid].stats;
 
  skb_orphan(skb);
 
- if (in_interrupt())
-  rc = netif_rx(skb);
- else
-  rc = netif_rx_ni(skb);
+ rc = napi_gro_receive(&wil->napi_rx, skb);
 
- if (likely(rc == NET_RX_SUCCESS)) {
+ if (unlikely(rc == GRO_DROP)) {
+  ndev->stats.rx_dropped++;
+  stats->rx_dropped++;
+  wil_dbg_txrx(wil, "Rx drop %d bytes\n", len);
+ } else {
   ndev->stats.rx_packets++;
+  stats->rx_packets++;
   ndev->stats.rx_bytes += len;
-
- } else {
-  ndev->stats.rx_dropped++;
+  stats->rx_bytes += len;
  }
 }
 
 /**
  * Proceed all completed skb's from Rx VRING
  *
- * Safe to call from IRQ
+ * Safe to call from NAPI poll, i.e. softirq with interrupts enabled
  */
-void wil_rx_handle(struct wil6210_priv *wil)
+void wil_rx_handle(struct wil6210_priv *wil, int *quota)
 {
  struct net_device *ndev = wil_to_ndev(wil);
  struct vring *v = &wil->vring_rx;
@@ -463,9 +543,8 @@ void wil_rx_handle(struct wil6210_priv *wil)
   return;
  }
  wil_dbg_txrx(wil, "%s()\n", __func__);
- while (NULL != (skb = wil_vring_reap_rx(wil, v))) {
-  wil_hex_dump_txrx("Rx ", DUMP_PREFIX_OFFSET, 16, 1,
-      skb->data, skb_headlen(skb), false);
+ while ((*quota > 0) && (NULL != (skb = wil_vring_reap_rx(wil, v)))) {
+  (*quota)--;
 
   if (wil->wdev->iftype == NL80211_IFTYPE_MONITOR) {
    skb->dev = ndev;
@@ -473,12 +552,18 @@ void wil_rx_handle(struct wil6210_priv *wil)
    skb->ip_summed = CHECKSUM_UNNECESSARY;
    skb->pkt_type = PACKET_OTHERHOST;
    skb->protocol = htons(ETH_P_802_2);
-
+   wil_netif_rx_any(skb, ndev);
   } else {
+   struct ethhdr *eth = (void *)skb->data;
+
    skb->protocol = eth_type_trans(skb, ndev);
+
+   if (is_unicast_ether_addr(eth->h_dest))
+    wil_rx_reorder(wil, skb);
+   else
+    wil_netif_rx_any(skb, ndev);
   }
 
-  wil_netif_rx_any(skb, ndev);
  }
  wil_rx_refill(wil, v->size);
 }
@@ -488,6 +573,11 @@ int wil_rx_init(struct wil6210_priv *wil)
  struct vring *vring = &wil->vring_rx;
  int rc;
 
+ if (vring->va) {
+  wil_err(wil, "Rx ring already allocated\n");
+  return -EINVAL;
+ }
+
  vring->size = WIL6210_RX_RING_SIZE;
  rc = wil_vring_alloc(wil, vring);
  if (rc)
@@ -528,7 +618,7 @@ int wil_vring_init_tx(struct wil6210_priv *wil, int id, int size,
     .ring_size = cpu_to_le16(size),
    },
    .ringid = id,
-   .cidxtid = (cid & 0xf) | ((tid & 0xf) << 4),
+   .cidxtid = mk_cidxtid(cid, tid),
    .encap_trans_type = WMI_VRING_ENC_TYPE_802_3,
    .mac_ctrl = 0,
    .to_resolution = 0,
@@ -544,6 +634,7 @@ int wil_vring_init_tx(struct wil6210_priv *wil, int id, int size,
   struct wmi_vring_cfg_done_event cmd;
  } __packed reply;
  struct vring *vring = &wil->vring_tx[id];
+ struct vring_tx_data *txdata = &wil->vring_tx_data[id];
 
  if (vring->va) {
   wil_err(wil, "Tx ring [%d] already allocated\n", id);
@@ -551,11 +642,15 @@ int wil_vring_init_tx(struct wil6210_priv *wil, int id, int size,
   goto out;
  }
 
+ memset(txdata, 0, sizeof(*txdata));
  vring->size = size;
  rc = wil_vring_alloc(wil, vring);
  if (rc)
   goto out;
 
+ wil->vring2cid_tid[id][0] = cid;
+ wil->vring2cid_tid[id][1] = tid;
+
  cmd.vring_cfg.tx_sw_ring.ring_mem_base = cpu_to_le64(vring->pa);
 
  rc = wmi_call(wil, WMI_VRING_CFG_CMDID, &cmd, sizeof(cmd),
@@ -571,6 +666,8 @@ int wil_vring_init_tx(struct wil6210_priv *wil, int id, int size,
  }
  vring->hwtail = le32_to_cpu(reply.cmd.tx_vring_tail_ptr);
 
+ txdata->enabled = 1;
+
  return 0;
  out_free:
  wil_vring_free(wil, vring, 1);
@@ -583,35 +680,127 @@ void wil_vring_fini_tx(struct wil6210_priv *wil, int id)
 {
  struct vring *vring = &wil->vring_tx[id];
 
+ WARN_ON(!mutex_is_locked(&wil->mutex));
+
  if (!vring->va)
   return;
 
+ /* make sure NAPI won't touch this vring */
+ wil->vring_tx_data[id].enabled = 0;
+ if (test_bit(wil_status_napi_en, &wil->status))
+  napi_synchronize(&wil->napi_tx);
+
  wil_vring_free(wil, vring, 1);
 }
 
 static struct vring *wil_find_tx_vring(struct wil6210_priv *wil,
            struct sk_buff *skb)
 {
- struct vring *v = &wil->vring_tx[0];
+ int i;
+ struct ethhdr *eth = (void *)skb->data;
+ int cid = wil_find_cid(wil, eth->h_dest);
+
+ if (cid < 0)
+  return NULL;
+
+ if (!wil->sta[cid].data_port_open &&
+     (skb->protocol != cpu_to_be16(ETH_P_PAE)))
+  return NULL;
 
- if (v->va)
-  return v;
+ /* TODO: fix for multiple TID */
+ for (i = 0; i < ARRAY_SIZE(wil->vring2cid_tid); i++) {
+  if (wil->vring2cid_tid[i][0] == cid) {
+   struct vring *v = &wil->vring_tx[i];
+   wil_dbg_txrx(wil, "%s(%pM) -> [%d]\n",
+         __func__, eth->h_dest, i);
+   if (v->va) {
+    return v;
+   } else {
+    wil_dbg_txrx(wil, "vring[%d] not valid\n", i);
+    return NULL;
+   }
+  }
+ }
 
  return NULL;
 }
 
-static int wil_tx_desc_map(volatile struct vring_tx_desc *d,
-      dma_addr_t pa, u32 len)
+static void wil_set_da_for_vring(struct wil6210_priv *wil,
+     struct sk_buff *skb, int vring_index)
+{
+ struct ethhdr *eth = (void *)skb->data;
+ int cid = wil->vring2cid_tid[vring_index][0];
+ memcpy(eth->h_dest, wil->sta[cid].addr, ETH_ALEN);
+}
+
+static int wil_tx_vring(struct wil6210_priv *wil, struct vring *vring,
+   struct sk_buff *skb);
+/*
+ * Find 1-st vring and return it; set dest address for this vring in skb
+ * duplicate skb and send it to other active vrings
+ */
+static struct vring *wil_tx_bcast(struct wil6210_priv *wil,
+           struct sk_buff *skb)
 {
- d->dma.addr_low = lower_32_bits(pa);
- d->dma.addr_high = (u16)upper_32_bits(pa);
+ struct vring *v, *v2;
+ struct sk_buff *skb2;
+ int i;
+ u8 cid;
+
+ /* find 1-st vring eligible for data */
+ for (i = 0; i < WIL6210_MAX_TX_RINGS; i++) {
+  v = &wil->vring_tx[i];
+  if (!v->va)
+   continue;
+
+  cid = wil->vring2cid_tid[i][0];
+  if (!wil->sta[cid].data_port_open)
+   continue;
+
+  goto found;
+ }
+
+ wil_err(wil, "Tx while no vrings active?\n");
+
+ return NULL;
+
+found:
+ wil_dbg_txrx(wil, "BCAST -> ring %d\n", i);
+ wil_set_da_for_vring(wil, skb, i);
+
+ /* find other active vrings and duplicate skb for each */
+ for (i++; i < WIL6210_MAX_TX_RINGS; i++) {
+  v2 = &wil->vring_tx[i];
+  if (!v2->va)
+   continue;
+  cid = wil->vring2cid_tid[i][0];
+  if (!wil->sta[cid].data_port_open)
+   continue;
+
+  skb2 = skb_copy(skb, GFP_ATOMIC);
+  if (skb2) {
+   wil_dbg_txrx(wil, "BCAST DUP -> ring %d\n", i);
+   wil_set_da_for_vring(wil, skb2, i);
+   wil_tx_vring(wil, v2, skb2);
+  } else {
+   wil_err(wil, "skb_copy failed\n");
+  }
+ }
+
+ return v;
+}
+
+static int wil_tx_desc_map(struct vring_tx_desc *d, dma_addr_t pa, u32 len,
+      int vring_index)
+{
+ wil_desc_addr_set(&d->dma.addr, pa);
  d->dma.ip_length = 0;
  /* 0..6: mac_length; 7:ip_version 0-IP6 1-IP4*/
  d->dma.b11 = 0/*14 | BIT(7)*/;
  d->dma.error = 0;
  d->dma.status = 0; /* BIT(0) should be 0 for HW_OWNED */
- d->dma.length = len;
- d->dma.d0 = 0;
+ d->dma.length = cpu_to_le16((u16)len);
+ d->dma.d0 = (vring_index << DMA_CFG_DESC_TX_0_QID_POS);
  d->mac.d[0] = 0;
  d->mac.d[1] = 0;
  d->mac.d[2] = 0;
@@ -626,66 +815,140 @@ static int wil_tx_desc_map(volatile struct vring_tx_desc *d,
  return 0;
 }
 
+static inline
+void wil_tx_desc_set_nr_frags(struct vring_tx_desc *d, int nr_frags)
+{
+ d->mac.d[2] |= ((nr_frags + 1) <<
+         MAC_CFG_DESC_TX_2_NUM_OF_DESCRIPTORS_POS);
+}
+
+static int wil_tx_desc_offload_cksum_set(struct wil6210_priv *wil,
+    struct vring_tx_desc *d,
+    struct sk_buff *skb)
+{
+ int protocol;
+
+ if (skb->ip_summed != CHECKSUM_PARTIAL)
+  return 0;
+
+ d->dma.b11 = ETH_HLEN; /* MAC header length */
+
+ switch (skb->protocol) {
+ case cpu_to_be16(ETH_P_IP):
+  protocol = ip_hdr(skb)->protocol;
+  d->dma.b11 |= BIT(DMA_CFG_DESC_TX_OFFLOAD_CFG_L3T_IPV4_POS);
+  break;
+ case cpu_to_be16(ETH_P_IPV6):
+  protocol = ipv6_hdr(skb)->nexthdr;
+  break;
+ default:
+  return -EINVAL;
+ }
+
+ switch (protocol) {
+ case IPPROTO_TCP:
+  d->dma.d0 |= (2 << DMA_CFG_DESC_TX_0_L4_TYPE_POS);
+  /* L4 header len: TCP header length */
+  d->dma.d0 |=
+  (tcp_hdrlen(skb) & DMA_CFG_DESC_TX_0_L4_LENGTH_MSK);
+  break;
+ case IPPROTO_UDP:
+  /* L4 header len: UDP header length */
+  d->dma.d0 |=
+  (sizeof(struct udphdr) & DMA_CFG_DESC_TX_0_L4_LENGTH_MSK);
+  break;
+ default:
+  return -EINVAL;
+ }
+
+ d->dma.ip_length = skb_network_header_len(skb);
+ /* Enable TCP/UDP checksum */
+ d->dma.d0 |= BIT(DMA_CFG_DESC_TX_0_TCP_UDP_CHECKSUM_EN_POS);
+ /* Calculate pseudo-header */
+ d->dma.d0 |= BIT(DMA_CFG_DESC_TX_0_PSEUDO_HEADER_CALC_EN_POS);
+
+ return 0;
+}
+
 static int wil_tx_vring(struct wil6210_priv *wil, struct vring *vring,
    struct sk_buff *skb)
 {
  struct device *dev = wil_to_dev(wil);
- volatile struct vring_tx_desc *d;
+ struct vring_tx_desc dd, *d = &dd;
+ volatile struct vring_tx_desc *_d;
  u32 swhead = vring->swhead;
  int avail = wil_vring_avail_tx(vring);
  int nr_frags = skb_shinfo(skb)->nr_frags;
- uint f;
+ uint f = 0;
  int vring_index = vring - wil->vring_tx;
  uint i = swhead;
  dma_addr_t pa;
 
  wil_dbg_txrx(wil, "%s()\n", __func__);
 
- if (avail < vring->size/8)
-  netif_tx_stop_all_queues(wil_to_ndev(wil));
  if (avail < 1 + nr_frags) {
   wil_err(wil, "Tx ring full. No space for %d fragments\n",
    1 + nr_frags);
   return -ENOMEM;
  }
- d = &(vring->va[i].tx);
-
- /* FIXME FW can accept only unicast frames for the peer */
- memcpy(skb->data, wil->dst_addr[vring_index], ETH_ALEN);
+ _d = &(vring->va[i].tx);
 
  pa = dma_map_single(dev, skb->data,
    skb_headlen(skb), DMA_TO_DEVICE);
 
- wil_dbg_txrx(wil, "Tx skb %d bytes %p -> %#08llx\n", skb_headlen(skb),
-       skb->data, (unsigned long long)pa);
+ wil_dbg_txrx(wil, "Tx skb %d bytes 0x%p -> %pad\n", skb_headlen(skb),
+       skb->data, &pa);
  wil_hex_dump_txrx("Tx ", DUMP_PREFIX_OFFSET, 16, 1,
      skb->data, skb_headlen(skb), false);
 
  if (unlikely(dma_mapping_error(dev, pa)))
   return -EINVAL;
+ vring->ctx[i].mapped_as = wil_mapped_as_single;
  /* 1-st segment */
- wil_tx_desc_map(d, pa, skb_headlen(skb));
- d->mac.d[2] |= ((nr_frags + 1) <<
-         MAC_CFG_DESC_TX_2_NUM_OF_DESCRIPTORS_POS);
+ wil_tx_desc_map(d, pa, skb_headlen(skb), vring_index);
+ /* Process TCP/UDP checksum offloading */
+ if (wil_tx_desc_offload_cksum_set(wil, d, skb)) {
+  wil_err(wil, "VRING #%d Failed to set cksum, drop packet\n",
+   vring_index);
+  goto dma_error;
+ }
+
+ vring->ctx[i].nr_frags = nr_frags;
+ wil_tx_desc_set_nr_frags(d, nr_frags);
+ if (nr_frags)
+  *_d = *d;
+
  /* middle segments */
- for (f = 0; f < nr_frags; f++) {
+ for (; f < nr_frags; f++) {
   const struct skb_frag_struct *frag =
     &skb_shinfo(skb)->frags[f];
   int len = skb_frag_size(frag);
   i = (swhead + f + 1) % vring->size;
-  d = &(vring->va[i].tx);
+  _d = &(vring->va[i].tx);
   pa = skb_frag_dma_map(dev, frag, 0, skb_frag_size(frag),
     DMA_TO_DEVICE);
   if (unlikely(dma_mapping_error(dev, pa)))
    goto dma_error;
-  wil_tx_desc_map(d, pa, len);
-  vring->ctx[i] = NULL;
+  vring->ctx[i].mapped_as = wil_mapped_as_page;
+  wil_tx_desc_map(d, pa, len, vring_index);
+  /* no need to check return code -
+   * if it succeeded for 1-st descriptor,
+   * it will succeed here too
+   */
+  wil_tx_desc_offload_cksum_set(wil, d, skb);
+  *_d = *d;
  }
  /* for the last seg only */
  d->dma.d0 |= BIT(DMA_CFG_DESC_TX_0_CMD_EOP_POS);
- d->dma.d0 |= BIT(9); /* BUG: undocumented bit */
+ d->dma.d0 |= BIT(DMA_CFG_DESC_TX_0_CMD_MARK_WB_POS);
  d->dma.d0 |= BIT(DMA_CFG_DESC_TX_0_CMD_DMA_IT_POS);
- d->dma.d0 |= (vring_index << DMA_CFG_DESC_TX_0_QID_POS);
+ *_d = *d;
+
+ /* hold reference to skb
+  * to prevent skb release before accounting
+  * in case of immediate "tx done"
+  */
+ vring->ctx[i].skb = skb_get(skb);
 
  wil_hex_dump_txrx("Tx ", DUMP_PREFIX_NONE, 32, 4,
      (const void *)d, sizeof(*d), false);
@@ -693,26 +956,27 @@ static int wil_tx_vring(struct wil6210_priv *wil, struct vring *vring,
  /* advance swhead */
  wil_vring_advance_head(vring, nr_frags + 1);
  wil_dbg_txrx(wil, "Tx swhead %d -> %d\n", swhead, vring->swhead);
+ trace_wil6210_tx(vring_index, swhead, skb->len, nr_frags);
  iowrite32(vring->swhead, wil->csr + HOSTADDR(vring->hwtail));
- /* hold reference to skb
-  * to prevent skb release before accounting
-  * in case of immediate "tx done"
-  */
- vring->ctx[i] = skb_get(skb);
 
  return 0;
  dma_error:
  /* unmap what we have mapped */
- /* Note: increment @f to operate with positive index */
- for (f++; f > 0; f--) {
+ nr_frags = f + 1; /* frags mapped + one for skb head */
+ for (f = 0; f < nr_frags; f++) {
+  struct wil_ctx *ctx;
+
   i = (swhead + f) % vring->size;
-  d = &(vring->va[i].tx);
-  d->dma.status = TX_DMA_STATUS_DU;
-  pa = d->dma.addr_low | ((u64)d->dma.addr_high << 32);
-  if (vring->ctx[i])
-   dma_unmap_single(dev, pa, d->dma.length, DMA_TO_DEVICE);
-  else
-   dma_unmap_page(dev, pa, d->dma.length, DMA_TO_DEVICE);
+  ctx = &vring->ctx[i];
+  _d = &(vring->va[i].tx);
+  *d = *_d;
+  _d->dma.status = TX_DMA_STATUS_DU;
+  wil_txdesc_unmap(dev, d, ctx);
+
+  if (ctx->skb)
+   dev_kfree_skb_any(ctx->skb);
+
+  memset(ctx, 0, sizeof(*ctx));
  }
 
  return -EINVAL;
@@ -722,12 +986,17 @@ static int wil_tx_vring(struct wil6210_priv *wil, struct vring *vring,
 netdev_tx_t wil_start_xmit(struct sk_buff *skb, struct net_device *ndev)
 {
  struct wil6210_priv *wil = ndev_to_wil(ndev);
+ struct ethhdr *eth = (void *)skb->data;
  struct vring *vring;
+ static bool pr_once_fw;
  int rc;
 
  wil_dbg_txrx(wil, "%s()\n", __func__);
  if (!test_bit(wil_status_fwready, &wil->status)) {
-  wil_err(wil, "FW not ready\n");
+  if (!pr_once_fw) {
+   wil_err(wil, "FW not ready\n");
+   pr_once_fw = true;
+  }
   goto drop;
  }
  if (!test_bit(wil_status_fwconnected, &wil->status)) {
@@ -738,18 +1007,25 @@ netdev_tx_t wil_start_xmit(struct sk_buff *skb, struct net_device *ndev)
   wil_err(wil, "Xmit in monitor mode not supported\n");
   goto drop;
  }
- if (skb->protocol == cpu_to_be16(ETH_P_PAE)) {
-  rc = wmi_tx_eapol(wil, skb);
- } else {
-  /* find vring */
+ pr_once_fw = false;
+
+ /* find vring */
+ if (is_unicast_ether_addr(eth->h_dest)) {
   vring = wil_find_tx_vring(wil, skb);
-  if (!vring) {
-   wil_err(wil, "No Tx VRING available\n");
-   goto drop;
-  }
-  /* set up vring entry */
-  rc = wil_tx_vring(wil, vring, skb);
+ } else {
+  vring = wil_tx_bcast(wil, skb);
+ }
+ if (!vring) {
+  wil_err(wil, "No Tx VRING found for %pM\n", eth->h_dest);
+  goto drop;
  }
+ /* set up vring entry */
+ rc = wil_tx_vring(wil, vring, skb);
+
+ /* do we still have enough room in the vring? */
+ if (wil_vring_avail_tx(vring) < wil_vring_wmark_low(vring))
+  netif_tx_stop_all_queues(wil_to_ndev(wil));
+
  switch (rc) {
  case 0:
   /* statistics will be updated on the tx_complete */
@@ -761,7 +1037,6 @@ netdev_tx_t wil_start_xmit(struct sk_buff *skb, struct net_device *ndev)
   break; /* goto drop; */
  }
  drop:
- netif_tx_stop_all_queues(ndev);
  ndev->stats.tx_dropped++;
  dev_kfree_skb_any(skb);
 
@@ -771,62 +1046,94 @@ netdev_tx_t wil_start_xmit(struct sk_buff *skb, struct net_device *ndev)
 /**
  * Clean up transmitted skb's from the Tx VRING
  *
+ * Return number of descriptors cleared
+ *
  * Safe to call from IRQ
  */
-void wil_tx_complete(struct wil6210_priv *wil, int ringid)
+int wil_tx_complete(struct wil6210_priv *wil, int ringid)
 {
  struct net_device *ndev = wil_to_ndev(wil);
  struct device *dev = wil_to_dev(wil);
  struct vring *vring = &wil->vring_tx[ringid];
+ struct vring_tx_data *txdata = &wil->vring_tx_data[ringid];
+ int done = 0;
+ int cid = wil->vring2cid_tid[ringid][0];
+ struct wil_net_stats *stats = &wil->sta[cid].stats;
+ volatile struct vring_tx_desc *_d;
 
  if (!vring->va) {
   wil_err(wil, "Tx irq[%d]: vring not initialized\n", ringid);
-  return;
+  return 0;
+ }
+
+ if (!txdata->enabled) {
+  wil_info(wil, "Tx irq[%d]: vring disabled\n", ringid);
+  return 0;
  }
 
  wil_dbg_txrx(wil, "%s(%d)\n", __func__, ringid);
 
  while (!wil_vring_is_empty(vring)) {
-  volatile struct vring_tx_desc *d1 =
-           &vring->va[vring->swtail].tx;
-  struct vring_tx_desc dd, *d = &dd;
-  dma_addr_t pa;
-  struct sk_buff *skb;
-
-  dd = *d1;
+  int new_swtail;
+  struct wil_ctx *ctx = &vring->ctx[vring->swtail];
+  /**
+   * For the fragmented skb, HW will set DU bit only for the
+   * last fragment. look for it
+   */
+  int lf = (vring->swtail + ctx->nr_frags) % vring->size;
+  /* TODO: check we are not past head */
 
-  if (!(d->dma.status & TX_DMA_STATUS_DU))
+  _d = &vring->va[lf].tx;
+  if (!(_d->dma.status & TX_DMA_STATUS_DU))
    break;
 
-  wil_dbg_txrx(wil,
-        "Tx[%3d] : %d bytes, status 0x%02x err 0x%02x\n",
-        vring->swtail, d->dma.length, d->dma.status,
-        d->dma.error);
-  wil_hex_dump_txrx("TxC ", DUMP_PREFIX_NONE, 32, 4,
-      (const void *)d, sizeof(*d), false);
-
-  pa = d->dma.addr_low | ((u64)d->dma.addr_high << 32);
-  skb = vring->ctx[vring->swtail];
-  if (skb) {
-   if (d->dma.error == 0) {
-    ndev->stats.tx_packets++;
-    ndev->stats.tx_bytes += skb->len;
-   } else {
-    ndev->stats.tx_errors++;
-   }
+  new_swtail = (lf + 1) % vring->size;
+  while (vring->swtail != new_swtail) {
+   struct vring_tx_desc dd, *d = &dd;
+   u16 dmalen;
+   struct wil_ctx *ctx = &vring->ctx[vring->swtail];
+   struct sk_buff *skb = ctx->skb;
+   _d = &vring->va[vring->swtail].tx;
 
-   dma_unmap_single(dev, pa, d->dma.length, DMA_TO_DEVICE);
-   dev_kfree_skb_any(skb);
-   vring->ctx[vring->swtail] = NULL;
-  } else {
-   dma_unmap_page(dev, pa, d->dma.length, DMA_TO_DEVICE);
+   *d = *_d;
+
+   dmalen = le16_to_cpu(d->dma.length);
+   trace_wil6210_tx_done(ringid, vring->swtail, dmalen,
+           d->dma.error);
+   wil_dbg_txrx(wil,
+         "Tx[%3d] : %d bytes, status 0x%02x err 0x%02x\n",
+         vring->swtail, dmalen, d->dma.status,
+         d->dma.error);
+   wil_hex_dump_txrx("TxC ", DUMP_PREFIX_NONE, 32, 4,
+       (const void *)d, sizeof(*d), false);
+
+   wil_txdesc_unmap(dev, d, ctx);
+
+   if (skb) {
+    if (d->dma.error == 0) {
+     ndev->stats.tx_packets++;
+     stats->tx_packets++;
+     ndev->stats.tx_bytes += skb->len;
+     stats->tx_bytes += skb->len;
+    } else {
+     ndev->stats.tx_errors++;
+     stats->tx_errors++;
+    }
+
+    dev_kfree_skb_any(skb);
+   }
+   memset(ctx, 0, sizeof(*ctx));
+   /* There is no need to touch HW descriptor:
+    * - ststus bit TX_DMA_STATUS_DU is set by design,
+    *   so hardware will not try to process this desc.,
+    * - rest of descriptor will be initialized on Tx.
+    */
+   vring->swtail = wil_vring_next_tail(vring);
+   done++;
   }
-  d->dma.addr_low = 0;
-  d->dma.addr_high = 0;
-  d->dma.length = 0;
-  d->dma.status = TX_DMA_STATUS_DU;
-  vring->swtail = wil_vring_next_tail(vring);
  }
- if (wil_vring_avail_tx(vring) > vring->size/4)
+ if (wil_vring_avail_tx(vring) > wil_vring_wmark_high(vring))
   netif_tx_wake_all_queues(wil_to_ndev(wil));
+
+ return done;
 }
diff --git a/drivers/net/wireless/ath/wil6210/txrx.h b/drivers/net/wireless/ath/wil6210/txrx.h
index adef12f..bc5706a 100644
--- a/drivers/net/wireless/ath/wil6210/txrx.h
+++ b/drivers/net/wireless/ath/wil6210/txrx.h
@@ -27,6 +27,28 @@
 #define WIL6210_RTAP_SIZE (128)
 
 /* Tx/Rx path */
+
+/*
+ * Common representation of physical address in Vring
+ */
+struct vring_dma_addr {
+ __le32 addr_low;
+ __le16 addr_high;
+} __packed;
+
+static inline dma_addr_t wil_desc_addr(struct vring_dma_addr *addr)
+{
+ return le32_to_cpu(addr->addr_low) |
+      ((u64)le16_to_cpu(addr->addr_high) << 32);
+}
+
+static inline void wil_desc_addr_set(struct vring_dma_addr *addr,
+         dma_addr_t pa)
+{
+ addr->addr_low = cpu_to_le32(lower_32_bits(pa));
+ addr->addr_high = cpu_to_le16((u16)upper_32_bits(pa));
+}
+
 /*
  * Tx descriptor - MAC part
  * [dword 0]
@@ -179,6 +201,10 @@ struct vring_tx_mac {
 #define DMA_CFG_DESC_TX_0_CMD_EOP_LEN 1
 #define DMA_CFG_DESC_TX_0_CMD_EOP_MSK 0x100
 
+#define DMA_CFG_DESC_TX_0_CMD_MARK_WB_POS 9
+#define DMA_CFG_DESC_TX_0_CMD_MARK_WB_LEN 1
+#define DMA_CFG_DESC_TX_0_CMD_MARK_WB_MSK 0x200
+
 #define DMA_CFG_DESC_TX_0_CMD_DMA_IT_POS 10
 #define DMA_CFG_DESC_TX_0_CMD_DMA_IT_LEN 1
 #define DMA_CFG_DESC_TX_0_CMD_DMA_IT_MSK 0x400
@@ -209,20 +235,28 @@ struct vring_tx_mac {
 
 #define DMA_CFG_DESC_TX_0_L4_TYPE_POS 30
 #define DMA_CFG_DESC_TX_0_L4_TYPE_LEN 2
-#define DMA_CFG_DESC_TX_0_L4_TYPE_MSK 0xC0000000
+#define DMA_CFG_DESC_TX_0_L4_TYPE_MSK 0xC0000000 /* L4 type: 0-UDP, 2-TCP */
+
+
+#define DMA_CFG_DESC_TX_OFFLOAD_CFG_MAC_LEN_POS 0
+#define DMA_CFG_DESC_TX_OFFLOAD_CFG_MAC_LEN_LEN 7
+#define DMA_CFG_DESC_TX_OFFLOAD_CFG_MAC_LEN_MSK 0x7F /* MAC hdr len */
+
+#define DMA_CFG_DESC_TX_OFFLOAD_CFG_L3T_IPV4_POS 7
+#define DMA_CFG_DESC_TX_OFFLOAD_CFG_L3T_IPV4_LEN 1
+#define DMA_CFG_DESC_TX_OFFLOAD_CFG_L3T_IPV4_MSK 0x80 /* 1-IPv4, 0-IPv6 */
 
 
 #define TX_DMA_STATUS_DU         BIT(0)
 
 struct vring_tx_dma {
  u32 d0;
- u32 addr_low;
- u16 addr_high;
+ struct vring_dma_addr addr;
  u8  ip_length;
  u8  b11;       /* 0..6: mac_length; 7:ip_version */
  u8  error;     /* 0..2: err; 3..7: reserved; */
  u8  status;    /* 0: used; 1..7; reserved */
- u16 length;
+ __le16 length;
 } __packed;
 
 /*
@@ -309,19 +343,27 @@ struct vring_rx_mac {
 
 #define RX_DMA_D0_CMD_DMA_IT     BIT(10)
 
+/* Error field, offload bits */
+#define RX_DMA_ERROR_L3_ERR   BIT(4)
+#define RX_DMA_ERROR_L4_ERR   BIT(5)
+
+
+/* Status field */
 #define RX_DMA_STATUS_DU         BIT(0)
 #define RX_DMA_STATUS_ERROR      BIT(2)
+
+#define RX_DMA_STATUS_L3_IDENT   BIT(4)
+#define RX_DMA_STATUS_L4_IDENT   BIT(5)
 #define RX_DMA_STATUS_PHY_INFO   BIT(6)
 
 struct vring_rx_dma {
  u32 d0;
- u32 addr_low;
- u16 addr_high;
+ struct vring_dma_addr addr;
  u8  ip_length;
  u8  b11;
  u8  error;
  u8  status;
- u16 length;
+ __le16 length;
 } __packed;
 
 struct vring_tx_desc {
@@ -394,4 +436,11 @@ static inline struct vring_rx_desc *wil_skb_rxdesc(struct sk_buff *skb)
  return (void *)skb->cb;
 }
 
+void wil_netif_rx_any(struct sk_buff *skb, struct net_device *ndev);
+void wil_rx_reorder(struct wil6210_priv *wil, struct sk_buff *skb);
+struct wil_tid_ampdu_rx *wil_tid_ampdu_rx_alloc(struct wil6210_priv *wil,
+      int size, u16 ssn);
+void wil_tid_ampdu_rx_free(struct wil6210_priv *wil,
+      struct wil_tid_ampdu_rx *r);
+
 #endif /* WIL6210_TXRX_H */
diff --git a/drivers/net/wireless/ath/wil6210/wil6210.h b/drivers/net/wireless/ath/wil6210/wil6210.h
index 8f76ecd..e25edc5 100644
--- a/drivers/net/wireless/ath/wil6210/wil6210.h
+++ b/drivers/net/wireless/ath/wil6210/wil6210.h
@@ -34,9 +34,15 @@ static inline u32 WIL_GET_BITS(u32 x, int b0, int b1)
 
 #define WIL6210_MEM_SIZE (2*1024*1024UL)
 
-#define WIL6210_RX_RING_SIZE (128)
-#define WIL6210_TX_RING_SIZE (128)
-#define WIL6210_MAX_TX_RINGS (24)
+#define WIL6210_RX_RING_SIZE (128)
+#define WIL6210_TX_RING_SIZE (512)
+#define WIL6210_MAX_TX_RINGS (24) /* HW limit */
+#define WIL6210_MAX_CID  (8) /* HW limit */
+#define WIL6210_NAPI_BUDGET (16) /* arbitrary */
+#define WIL6210_ITR_TRSH (10000) /* arbitrary - about 15 IRQs/msec */
+#define WIL6210_FW_RECOVERY_RETRIES (5) /* try to recover this many times */
+#define WIL6210_FW_RECOVERY_TO msecs_to_jiffies(5000)
+#define WIL6210_SCAN_TO  msecs_to_jiffies(10000)
 
 /* Hardware definitions begin */
 
@@ -71,23 +77,21 @@ struct RGF_ICR {
 } __packed;
 
 /* registers - FW addresses */
-#define RGF_USER_USER_SCRATCH_PAD (0x8802bc)
-#define RGF_USER_USER_ICR  (0x880b4c) /* struct RGF_ICR */
- #define BIT_USER_USER_ICR_SW_INT_2 BIT(18)
-#define RGF_USER_CLKS_CTL_SW_RST_MASK_0 (0x880b14)
-#define RGF_USER_MAC_CPU_0  (0x8801fc)
+#define RGF_USER_HW_MACHINE_STATE (0x8801dc)
+ #define HW_MACHINE_BOOT_DONE (0x3fffffd)
 #define RGF_USER_USER_CPU_0  (0x8801e0)
+#define RGF_USER_MAC_CPU_0  (0x8801fc)
+#define RGF_USER_USER_SCRATCH_PAD (0x8802bc)
+#define RGF_USER_FW_REV_ID  (0x880a8c) /* chip revision */
+#define RGF_USER_CLKS_CTL_0  (0x880abc)
+ #define BIT_USER_CLKS_RST_PWGD BIT(11) /* reset on "power good" */
 #define RGF_USER_CLKS_CTL_SW_RST_VEC_0 (0x880b04)
 #define RGF_USER_CLKS_CTL_SW_RST_VEC_1 (0x880b08)
 #define RGF_USER_CLKS_CTL_SW_RST_VEC_2 (0x880b0c)
 #define RGF_USER_CLKS_CTL_SW_RST_VEC_3 (0x880b10)
-
-#define RGF_DMA_PSEUDO_CAUSE  (0x881c68)
-#define RGF_DMA_PSEUDO_CAUSE_MASK_SW (0x881c6c)
-#define RGF_DMA_PSEUDO_CAUSE_MASK_FW (0x881c70)
- #define BIT_DMA_PSEUDO_CAUSE_RX  BIT(0)
- #define BIT_DMA_PSEUDO_CAUSE_TX  BIT(1)
- #define BIT_DMA_PSEUDO_CAUSE_MISC BIT(2)
+#define RGF_USER_CLKS_CTL_SW_RST_MASK_0 (0x880b14)
+#define RGF_USER_USER_ICR  (0x880b4c) /* struct RGF_ICR */
+ #define BIT_USER_USER_ICR_SW_INT_2 BIT(18)
 
 #define RGF_DMA_EP_TX_ICR  (0x881bb4) /* struct RGF_ICR */
  #define BIT_DMA_EP_TX_ICR_TX_DONE BIT(0)
@@ -102,13 +106,22 @@ struct RGF_ICR {
 /* Interrupt moderation control */
 #define RGF_DMA_ITR_CNT_TRSH  (0x881c5c)
 #define RGF_DMA_ITR_CNT_DATA  (0x881c60)
-#define RGF_DMA_ITR_CNT_CRL  (0x881C64)
+#define RGF_DMA_ITR_CNT_CRL  (0x881c64)
  #define BIT_DMA_ITR_CNT_CRL_EN  BIT(0)
  #define BIT_DMA_ITR_CNT_CRL_EXT_TICK BIT(1)
  #define BIT_DMA_ITR_CNT_CRL_FOREVER BIT(2)
  #define BIT_DMA_ITR_CNT_CRL_CLR  BIT(3)
  #define BIT_DMA_ITR_CNT_CRL_REACH_TRSH BIT(4)
 
+#define RGF_DMA_PSEUDO_CAUSE  (0x881c68)
+#define RGF_DMA_PSEUDO_CAUSE_MASK_SW (0x881c6c)
+#define RGF_DMA_PSEUDO_CAUSE_MASK_FW (0x881c70)
+ #define BIT_DMA_PSEUDO_CAUSE_RX  BIT(0)
+ #define BIT_DMA_PSEUDO_CAUSE_TX  BIT(1)
+ #define BIT_DMA_PSEUDO_CAUSE_MISC BIT(2)
+
+#define RGF_PCIE_LOS_COUNTER_CTL (0x882dc4)
+
 /* popular locations */
 #define HOST_MBOX   HOSTADDR(RGF_USER_USER_SCRATCH_PAD)
 #define HOST_SW_INT (HOSTADDR(RGF_USER_USER_ICR) + \
@@ -122,6 +135,31 @@ struct RGF_ICR {
 
 /* Hardware definitions end */
 
+/**
+ * mk_cidxtid - construct @cidxtid field
+ * @cid: CID value
+ * @tid: TID value
+ *
+ * @cidxtid field encoded as bits 0..3 - CID; 4..7 - TID
+ */
+static inline u8 mk_cidxtid(u8 cid, u8 tid)
+{
+ return ((tid & 0xf) << 4) | (cid & 0xf);
+}
+
+/**
+ * parse_cidxtid - parse @cidxtid field
+ * @cid: store CID value here
+ * @tid: store TID value here
+ *
+ * @cidxtid field encoded as bits 0..3 - CID; 4..7 - TID
+ */
+static inline void parse_cidxtid(u8 cidxtid, u8 *cid, u8 *tid)
+{
+ *cid = cidxtid & 0xf;
+ *tid = (cidxtid >> 4) & 0xf;
+}
+
 struct wil6210_mbox_ring {
  u32 base;
  u16 entry_size; /* max. size of mbox entry, incl. all headers */
@@ -154,11 +192,22 @@ struct wil6210_mbox_hdr {
 /* max. value for wil6210_mbox_hdr.len */
 #define MAX_MBOXITEM_SIZE   (240)
 
+/**
+ * struct wil6210_mbox_hdr_wmi - WMI header
+ *
+ * @mid: MAC ID
+ * 00 - default, created by FW
+ * 01..0f - WiFi ports, driver to create
+ * 10..fe - debug
+ * ff - broadcast
+ * @id: command/event ID
+ * @timestamp: FW fills for events, free-running msec timer
+ */
 struct wil6210_mbox_hdr_wmi {
- u8 reserved0[2];
+ u8 mid;
+ u8 reserved;
  __le16 id;
- __le16 info1; /* bits [0..3] - device_id, rest - unused */
- u8 reserved1[2];
+ __le32 timestamp;
 } __packed;
 
 struct pending_wmi_event {
@@ -170,6 +219,21 @@ struct pending_wmi_event {
  } __packed event;
 };
 
+enum { /* for wil_ctx.mapped_as */
+ wil_mapped_as_none = 0,
+ wil_mapped_as_single = 1,
+ wil_mapped_as_page = 2,
+};
+
+/**
+ * struct wil_ctx - software context for Vring descriptor
+ */
+struct wil_ctx {
+ struct sk_buff *skb;
+ u8 nr_frags;
+ u8 mapped_as;
+};
+
 union vring_desc;
 
 struct vring {
@@ -179,19 +243,70 @@ struct vring {
  u32 swtail;
  u32 swhead;
  u32 hwtail; /* write here to inform hw */
- void **ctx; /* void *ctx[size] - software context */
+ struct wil_ctx *ctx; /* ctx[size] - software context */
+};
+
+/**
+ * Additional data for Tx Vring
+ */
+struct vring_tx_data {
+ int enabled;
+
 };
 
 enum { /* for wil6210_priv.status */
  wil_status_fwready = 0,
+ wil_status_fwconnecting,
  wil_status_fwconnected,
  wil_status_dontscan,
  wil_status_reset_done,
  wil_status_irqen, /* FIXME: interrupts enabled - for debug */
+ wil_status_napi_en, /* NAPI enabled protected by wil->mutex */
 };
 
 struct pci_dev;
 
+/**
+ * struct tid_ampdu_rx - TID aggregation information (Rx).
+ *
+ * @reorder_buf: buffer to reorder incoming aggregated MPDUs
+ * @reorder_time: jiffies when skb was added
+ * @session_timer: check if peer keeps Tx-ing on the TID (by timeout value)
+ * @reorder_timer: releases expired frames from the reorder buffer.
+ * @last_rx: jiffies of last rx activity
+ * @head_seq_num: head sequence number in reordering buffer.
+ * @stored_mpdu_num: number of MPDUs in reordering buffer
+ * @ssn: Starting Sequence Number expected to be aggregated.
+ * @buf_size: buffer size for incoming A-MPDUs
+ * @timeout: reset timer value (in TUs).
+ * @dialog_token: dialog token for aggregation session
+ * @rcu_head: RCU head used for freeing this struct
+ * @reorder_lock: serializes access to reorder buffer, see below.
+ *
+ * This structure's lifetime is managed by RCU, assignments to
+ * the array holding it must hold the aggregation mutex.
+ *
+ * The @reorder_lock is used to protect the members of this
+ * struct, except for @timeout, @buf_size and @dialog_token,
+ * which are constant across the lifetime of the struct (the
+ * dialog token being used only for debugging).
+ */
+struct wil_tid_ampdu_rx {
+ spinlock_t reorder_lock; /* see above */
+ struct sk_buff **reorder_buf;
+ unsigned long *reorder_time;
+ struct timer_list session_timer;
+ struct timer_list reorder_timer;
+ unsigned long last_rx;
+ u16 head_seq_num;
+ u16 stored_mpdu_num;
+ u16 ssn;
+ u16 buf_size;
+ u16 timeout;
+ u8 dialog_token;
+ bool first_time; /* is it 1-st time this buffer used? */
+};
+
 struct wil6210_stats {
  u64 tsf;
  u32 snr;
@@ -203,6 +318,43 @@ struct wil6210_stats {
  u16 peer_tx_sector;
 };
 
+enum wil_sta_status {
+ wil_sta_unused = 0,
+ wil_sta_conn_pending = 1,
+ wil_sta_connected = 2,
+};
+
+#define WIL_STA_TID_NUM (16)
+
+struct wil_net_stats {
+ unsigned long rx_packets;
+ unsigned long tx_packets;
+ unsigned long rx_bytes;
+ unsigned long tx_bytes;
+ unsigned long tx_errors;
+ unsigned long rx_dropped;
+ u16 last_mcs_rx;
+};
+
+/**
+ * struct wil_sta_info - data for peer
+ *
+ * Peer identified by its CID (connection ID)
+ * NIC performs beam forming for each peer;
+ * if no beam forming done, frame exchange is not
+ * possible.
+ */
+struct wil_sta_info {
+ u8 addr[ETH_ALEN];
+ enum wil_sta_status status;
+ struct wil_net_stats stats;
+ bool data_port_open; /* can send any data, not only EAPOL */
+ /* Rx BACK */
+ struct wil_tid_ampdu_rx *tid_rx[WIL_STA_TID_NUM];
+ unsigned long tid_rx_timer_expired[BITS_TO_LONGS(WIL_STA_TID_NUM)];
+ unsigned long tid_rx_stop_requested[BITS_TO_LONGS(WIL_STA_TID_NUM)];
+};
+
 struct wil6210_priv {
  struct pci_dev *pdev;
  int n_msi;
@@ -210,7 +362,10 @@ struct wil6210_priv {
  void __iomem *csr;
  ulong status;
  u32 fw_version;
+ u32 hw_version;
  u8 n_mids; /* number of additional MIDs as reported by FW */
+ int recovery_count; /* num of FW recovery attempts in a short time */
+ unsigned long last_fw_recovery; /* jiffies of last fw recovery */
  /* profile */
  u32 monitor_flags;
  u32 secure_pcp; /* create secure PCP? */
@@ -230,7 +385,9 @@ struct wil6210_priv {
  struct workqueue_struct *wmi_wq_conn; /* for connect worker */
  struct work_struct connect_worker;
  struct work_struct disconnect_worker;
+ struct work_struct fw_error_worker; /* for FW error recovery */
  struct timer_list connect_timer;
+ struct timer_list scan_timer; /* detect scan timeout */
  int pending_connect_cid;
  struct list_head pending_wmi_ev;
  /*
@@ -239,10 +396,14 @@ struct wil6210_priv {
   * - consumed in thread by wmi_event_worker
   */
  spinlock_t wmi_ev_lock;
+ struct napi_struct napi_rx;
+ struct napi_struct napi_tx;
  /* DMA related */
  struct vring vring_rx;
  struct vring vring_tx[WIL6210_MAX_TX_RINGS];
- u8 dst_addr[WIL6210_MAX_TX_RINGS][ETH_ALEN];
+ struct vring_tx_data vring_tx_data[WIL6210_MAX_TX_RINGS];
+ u8 vring2cid_tid[WIL6210_MAX_TX_RINGS][2]; /* [0] - CID, [1] - TID */
+ struct wil_sta_info sta[WIL6210_MAX_CID];
  /* scan */
  struct cfg80211_scan_request *scan_request;
 
@@ -267,9 +428,13 @@ struct wil6210_priv {
 #define wil_to_ndev(i) (wil_to_wdev(i)->netdev)
 #define ndev_to_wil(n) (wdev_to_wil(n->ieee80211_ptr))
 
-#define wil_dbg(wil, fmt, arg...) netdev_dbg(wil_to_ndev(wil), fmt, ##arg)
-#define wil_info(wil, fmt, arg...) netdev_info(wil_to_ndev(wil), fmt, ##arg)
-#define wil_err(wil, fmt, arg...) netdev_err(wil_to_ndev(wil), fmt, ##arg)
+int wil_dbg_trace(struct wil6210_priv *wil, const char *fmt, ...);
+int wil_err(struct wil6210_priv *wil, const char *fmt, ...);
+int wil_info(struct wil6210_priv *wil, const char *fmt, ...);
+#define wil_dbg(wil, fmt, arg...) do { \
+ netdev_dbg(wil_to_ndev(wil), fmt, ##arg); \
+ wil_dbg_trace(wil, fmt, ##arg); \
+} while (0)
 
 #define wil_dbg_irq(wil, fmt, arg...) wil_dbg(wil, "DBG[ IRQ]" fmt, ##arg)
 #define wil_dbg_txrx(wil, fmt, arg...) wil_dbg(wil, "DBG[TXRX]" fmt, ##arg)
@@ -300,11 +465,13 @@ void wil_if_remove(struct wil6210_priv *wil);
 int wil_priv_init(struct wil6210_priv *wil);
 void wil_priv_deinit(struct wil6210_priv *wil);
 int wil_reset(struct wil6210_priv *wil);
+void wil_fw_error_recovery(struct wil6210_priv *wil);
 void wil_link_on(struct wil6210_priv *wil);
 void wil_link_off(struct wil6210_priv *wil);
 int wil_up(struct wil6210_priv *wil);
 int wil_down(struct wil6210_priv *wil);
 void wil_mbox_ring_le2cpus(struct wil6210_mbox_ring *r);
+int wil_find_cid(struct wil6210_priv *wil, const u8 *mac);
 
 void __iomem *wmi_buffer(struct wil6210_priv *wil, __le32 ptr);
 void __iomem *wmi_addr(struct wil6210_priv *wil, u32 ptr);
@@ -320,7 +487,6 @@ int wmi_set_ssid(struct wil6210_priv *wil, u8 ssid_len, const void *ssid);
 int wmi_get_ssid(struct wil6210_priv *wil, u8 *ssid_len, void *ssid);
 int wmi_set_channel(struct wil6210_priv *wil, int channel);
 int wmi_get_channel(struct wil6210_priv *wil, int *channel);
-int wmi_tx_eapol(struct wil6210_priv *wil, struct sk_buff *skb);
 int wmi_del_cipher_key(struct wil6210_priv *wil, u8 key_index,
          const void *mac_addr);
 int wmi_add_cipher_key(struct wil6210_priv *wil, u8 key_index,
@@ -329,8 +495,11 @@ int wmi_echo(struct wil6210_priv *wil);
 int wmi_set_ie(struct wil6210_priv *wil, u8 type, u16 ie_len, const void *ie);
 int wmi_rx_chain_add(struct wil6210_priv *wil, struct vring *vring);
 int wmi_p2p_cfg(struct wil6210_priv *wil, int channel);
+int wmi_rxon(struct wil6210_priv *wil, bool on);
 int wmi_get_temperature(struct wil6210_priv *wil, u32 *t_m, u32 *t_r);
+int wmi_disconnect_sta(struct wil6210_priv *wil, const u8 *mac, u16 reason);
 
+void wil6210_clear_irq(struct wil6210_priv *wil);
 int wil6210_init_irq(struct wil6210_priv *wil, int irq);
 void wil6210_fini_irq(struct wil6210_priv *wil, int irq);
 void wil6210_disable_irq(struct wil6210_priv *wil);
@@ -345,7 +514,7 @@ void wil_wdev_free(struct wil6210_priv *wil);
 int wmi_set_mac_address(struct wil6210_priv *wil, void *addr);
 int wmi_pcp_start(struct wil6210_priv *wil, int bi, u8 wmi_nettype, u8 chan);
 int wmi_pcp_stop(struct wil6210_priv *wil);
-void wil6210_disconnect(struct wil6210_priv *wil, void *bssid);
+void wil6210_disconnect(struct wil6210_priv *wil, const u8 *bssid);
 
 int wil_rx_init(struct wil6210_priv *wil);
 void wil_rx_fini(struct wil6210_priv *wil);
@@ -356,10 +525,12 @@ int wil_vring_init_tx(struct wil6210_priv *wil, int id, int size,
 void wil_vring_fini_tx(struct wil6210_priv *wil, int id);
 
 netdev_tx_t wil_start_xmit(struct sk_buff *skb, struct net_device *ndev);
-void wil_tx_complete(struct wil6210_priv *wil, int ringid);
+int wil_tx_complete(struct wil6210_priv *wil, int ringid);
+void wil6210_unmask_irq_tx(struct wil6210_priv *wil);
 
 /* RX API */
-void wil_rx_handle(struct wil6210_priv *wil);
+void wil_rx_handle(struct wil6210_priv *wil, int *quota);
+void wil6210_unmask_irq_rx(struct wil6210_priv *wil);
 
 int wil_iftype_nl2wmi(enum nl80211_iftype type);
 
diff --git a/drivers/net/wireless/ath/wil6210/wmi.c b/drivers/net/wireless/ath/wil6210/wmi.c
index 45b04e3..6cc0e18 100644
--- a/drivers/net/wireless/ath/wil6210/wmi.c
+++ b/drivers/net/wireless/ath/wil6210/wmi.c
@@ -20,6 +20,7 @@
 #include "wil6210.h"
 #include "txrx.h"
 #include "wmi.h"
+#include "trace.h"
 
 /**
  * WMI event receiving - theory of operations
@@ -74,10 +75,11 @@ static const struct {
  {0x800000, 0x808000, 0x900000}, /* FW data RAM 32k */
  {0x840000, 0x860000, 0x908000}, /* peripheral data RAM 128k/96k used */
  {0x880000, 0x88a000, 0x880000}, /* various RGF */
- {0x8c0000, 0x932000, 0x8c0000}, /* trivial mapping for upper area */
+ {0x8c0000, 0x949000, 0x8c0000}, /* trivial mapping for upper area */
  /*
   * 920000..930000 ucode code RAM
   * 930000..932000 ucode data RAM
+  * 932000..949000 back-door debug data
   */
 };
 
@@ -170,8 +172,8 @@ static int __wmi_send(struct wil6210_priv *wil, u16 cmdid, void *buf, u16 len)
    .len = cpu_to_le16(sizeof(cmd.wmi) + len),
   },
   .wmi = {
+   .mid = 0,
    .id = cpu_to_le16(cmdid),
-   .info1 = 0,
   },
  };
  struct wil6210_mbox_ring *r = &wil->mbox_ctl.tx;
@@ -190,7 +192,7 @@ static int __wmi_send(struct wil6210_priv *wil, u16 cmdid, void *buf, u16 len)
  might_sleep();
 
  if (!test_bit(wil_status_fwready, &wil->status)) {
-  wil_err(wil, "FW not ready\n");
+  wil_err(wil, "WMI: cannot send command while FW not ready\n");
   return -EAGAIN;
  }
 
@@ -246,6 +248,8 @@ static int __wmi_send(struct wil6210_priv *wil, u16 cmdid, void *buf, u16 len)
  iowrite32(r->head = next_head, wil->csr + HOST_MBOX +
     offsetof(struct wil6210_mbox_ctl, tx.head));
 
+ trace_wil6210_wmi_cmd(&cmd.wmi, buf, len);
+
  /* interrupt to FW */
  iowrite32(SW_INT_MBOX, wil->csr + HOST_SW_INT);
 
@@ -272,8 +276,8 @@ static void wmi_evt_ready(struct wil6210_priv *wil, int id, void *d, int len)
  wil->fw_version = le32_to_cpu(evt->sw_version);
  wil->n_mids = evt->numof_additional_mids;
 
- wil_dbg_wmi(wil, "FW ver. %d; MAC %pM; %d MID's\n", wil->fw_version,
-      evt->mac, wil->n_mids);
+ wil_info(wil, "FW ver. %d; MAC %pM; %d MID's\n", wil->fw_version,
+   evt->mac, wil->n_mids);
 
  if (!is_valid_ether_addr(ndev->dev_addr)) {
   memcpy(ndev->dev_addr, evt->mac, ETH_ALEN);
@@ -286,7 +290,7 @@ static void wmi_evt_ready(struct wil6210_priv *wil, int id, void *d, int len)
 static void wmi_evt_fw_ready(struct wil6210_priv *wil, int id, void *d,
         int len)
 {
- wil_dbg_wmi(wil, "WMI: FW ready\n");
+ wil_dbg_wmi(wil, "WMI: got FW ready event\n");
 
  set_bit(wil_status_fwready, &wil->status);
  /* reuse wmi_ready for the firmware ready indication */
@@ -303,16 +307,16 @@ static void wmi_evt_rx_mgmt(struct wil6210_priv *wil, int id, void *d, int len)
  u32 freq = ieee80211_channel_to_frequency(ch_no,
    IEEE80211_BAND_60GHZ);
  struct ieee80211_channel *channel = ieee80211_get_channel(wiphy, freq);
- /* TODO convert LE to CPU */
- s32 signal = 0; /* TODO */
+ s32 signal = data->info.sqi;
  __le16 fc = rx_mgmt_frame->frame_control;
  u32 d_len = le32_to_cpu(data->info.len);
  u16 d_status = le16_to_cpu(data->info.status);
 
- wil_dbg_wmi(wil, "MGMT: channel %d MCS %d SNR %d\n",
-      data->info.channel, data->info.mcs, data->info.snr);
- wil_dbg_wmi(wil, "status 0x%04x len %d stype %04x\n", d_status, d_len,
-      le16_to_cpu(data->info.stype));
+ wil_dbg_wmi(wil, "MGMT: channel %d MCS %d SNR %d SQI %d%%\n",
+      data->info.channel, data->info.mcs, data->info.snr,
+      data->info.sqi);
+ wil_dbg_wmi(wil, "status 0x%04x len %d fc 0x%04x\n", d_status, d_len,
+      le16_to_cpu(fc));
  wil_dbg_wmi(wil, "qid %d mid %d cid %d\n",
       data->info.qid, data->info.mid, data->info.cid);
 
@@ -335,7 +339,7 @@ static void wmi_evt_rx_mgmt(struct wil6210_priv *wil, int id, void *d, int len)
   }
  } else {
   cfg80211_rx_mgmt(wil->wdev, freq, signal,
-     (void *)rx_mgmt_frame, d_len, GFP_KERNEL);
+     (void *)rx_mgmt_frame, d_len, 0, GFP_KERNEL);
  }
 }
 
@@ -344,9 +348,10 @@ static void wmi_evt_scan_complete(struct wil6210_priv *wil, int id,
 {
  if (wil->scan_request) {
   struct wmi_scan_complete_event *data = d;
-  bool aborted = (data->status != 0);
+  bool aborted = (data->status != WMI_SCAN_SUCCESS);
 
   wil_dbg_wmi(wil, "SCAN_COMPLETE(0x%08x)\n", data->status);
+  del_timer_sync(&wil->scan_timer);
   cfg80211_scan_done(wil->scan_request, aborted);
   wil->scan_request = NULL;
  } else {
@@ -380,6 +385,11 @@ static void wmi_evt_connect(struct wil6210_priv *wil, int id, void *d, int len)
    evt->assoc_req_len, evt->assoc_resp_len);
   return;
  }
+ if (evt->cid >= WIL6210_MAX_CID) {
+  wil_err(wil, "Connect CID invalid : %d\n", evt->cid);
+  return;
+ }
+
  ch = evt->channel + 1;
  wil_dbg_wmi(wil, "Connect %pM channel [%d] cid %d\n",
       evt->bssid, ch, evt->cid);
@@ -406,7 +416,7 @@ static void wmi_evt_connect(struct wil6210_priv *wil, int id, void *d, int len)
 
  if ((wdev->iftype == NL80211_IFTYPE_STATION) ||
      (wdev->iftype == NL80211_IFTYPE_P2P_CLIENT)) {
-  if (wdev->sme_state != CFG80211_SME_CONNECTING) {
+  if (!test_bit(wil_status_fwconnecting, &wil->status)) {
    wil_err(wil, "Not in connecting state\n");
    return;
   }
@@ -430,11 +440,13 @@ static void wmi_evt_connect(struct wil6210_priv *wil, int id, void *d, int len)
 
   cfg80211_new_sta(ndev, evt->bssid, &sinfo, GFP_KERNEL);
  }
+ clear_bit(wil_status_fwconnecting, &wil->status);
  set_bit(wil_status_fwconnected, &wil->status);
 
  /* FIXME FW can transmit only ucast frames to peer */
  /* FIXME real ring_id instead of hard coded 0 */
- memcpy(wil->dst_addr[0], evt->bssid, ETH_ALEN);
+ memcpy(wil->sta[evt->cid].addr, evt->bssid, ETH_ALEN);
+ wil->sta[evt->cid].status = wil_sta_conn_pending;
 
  wil->pending_connect_cid = evt->cid;
  queue_work(wil->wmi_wq_conn, &wil->connect_worker);
@@ -451,7 +463,9 @@ static void wmi_evt_disconnect(struct wil6210_priv *wil, int id,
 
  wil->sinfo_gen++;
 
+ mutex_lock(&wil->mutex);
  wil6210_disconnect(wil, evt->bssid);
+ mutex_unlock(&wil->mutex);
 }
 
 static void wmi_evt_notify(struct wil6210_priv *wil, int id, void *d, int len)
@@ -471,11 +485,11 @@ static void wmi_evt_notify(struct wil6210_priv *wil, int id, void *d, int len)
  wil->stats.peer_rx_sector = le16_to_cpu(evt->other_rx_sector);
  wil->stats.peer_tx_sector = le16_to_cpu(evt->other_tx_sector);
  wil_dbg_wmi(wil, "Link status, MCS %d TSF 0x%016llx\n"
-      "BF status 0x%08x SNR 0x%08x\n"
+      "BF status 0x%08x SNR 0x%08x SQI %d%%\n"
       "Tx Tpt %d goodput %d Rx goodput %d\n"
       "Sectors(rx:tx) my %d:%d peer %d:%d\n",
       wil->stats.bf_mcs, wil->stats.tsf, evt->status,
-      wil->stats.snr, le32_to_cpu(evt->tx_tpt),
+      wil->stats.snr, evt->sqi, le32_to_cpu(evt->tx_tpt),
       le32_to_cpu(evt->tx_goodput), le32_to_cpu(evt->rx_goodput),
       wil->stats.my_rx_sector, wil->stats.my_tx_sector,
       wil->stats.peer_rx_sector, wil->stats.peer_tx_sector);
@@ -494,10 +508,16 @@ static void wmi_evt_eapol_rx(struct wil6210_priv *wil, int id,
  int sz = eapol_len + ETH_HLEN;
  struct sk_buff *skb;
  struct ethhdr *eth;
+ int cid;
+ struct wil_net_stats *stats = NULL;
 
  wil_dbg_wmi(wil, "EAPOL len %d from %pM\n", eapol_len,
       evt->src_mac);
 
+ cid = wil_find_cid(wil, evt->src_mac);
+ if (cid >= 0)
+  stats = &wil->sta[cid].stats;
+
  if (eapol_len > 196) { /* TODO: revisit size limit */
   wil_err(wil, "EAPOL too large\n");
   return;
@@ -508,6 +528,7 @@ static void wmi_evt_eapol_rx(struct wil6210_priv *wil, int id,
   wil_err(wil, "Failed to allocate skb\n");
   return;
  }
+
  eth = (struct ethhdr *)skb_put(skb, ETH_HLEN);
  memcpy(eth->h_dest, ndev->dev_addr, ETH_ALEN);
  memcpy(eth->h_source, evt->src_mac, ETH_ALEN);
@@ -516,9 +537,15 @@ static void wmi_evt_eapol_rx(struct wil6210_priv *wil, int id,
  skb->protocol = eth_type_trans(skb, ndev);
  if (likely(netif_rx_ni(skb) == NET_RX_SUCCESS)) {
   ndev->stats.rx_packets++;
-  ndev->stats.rx_bytes += skb->len;
+  ndev->stats.rx_bytes += sz;
+  if (stats) {
+   stats->rx_packets++;
+   stats->rx_bytes += sz;
+  }
  } else {
   ndev->stats.rx_dropped++;
+  if (stats)
+   stats->rx_dropped++;
  }
 }
 
@@ -526,9 +553,16 @@ static void wmi_evt_linkup(struct wil6210_priv *wil, int id, void *d, int len)
 {
  struct net_device *ndev = wil_to_ndev(wil);
  struct wmi_data_port_open_event *evt = d;
+ u8 cid = evt->cid;
+
+ wil_dbg_wmi(wil, "Link UP for CID %d\n", cid);
 
- wil_dbg_wmi(wil, "Link UP for CID %d\n", evt->cid);
+ if (cid >= ARRAY_SIZE(wil->sta)) {
+  wil_err(wil, "Link UP for invalid CID %d\n", cid);
+  return;
+ }
 
+ wil->sta[cid].data_port_open = true;
  netif_carrier_on(ndev);
 }
 
@@ -536,10 +570,17 @@ static void wmi_evt_linkdown(struct wil6210_priv *wil, int id, void *d, int len)
 {
  struct net_device *ndev = wil_to_ndev(wil);
  struct wmi_wbe_link_down_event *evt = d;
+ u8 cid = evt->cid;
 
  wil_dbg_wmi(wil, "Link DOWN for CID %d, reason %d\n",
-      evt->cid, le32_to_cpu(evt->reason));
+      cid, le32_to_cpu(evt->reason));
 
+ if (cid >= ARRAY_SIZE(wil->sta)) {
+  wil_err(wil, "Link DOWN for invalid CID %d\n", cid);
+  return;
+ }
+
+ wil->sta[cid].data_port_open = false;
  netif_carrier_off(ndev);
 }
 
@@ -547,10 +588,42 @@ static void wmi_evt_ba_status(struct wil6210_priv *wil, int id, void *d,
          int len)
 {
  struct wmi_vring_ba_status_event *evt = d;
+ struct wil_sta_info *sta;
+ uint i, cid;
+
+ /* TODO: use Rx BA status, not Tx one */
 
  wil_dbg_wmi(wil, "BACK[%d] %s {%d} timeout %d\n",
-      evt->ringid, evt->status ? "N/A" : "OK", evt->agg_wsize,
-      __le16_to_cpu(evt->ba_timeout));
+      evt->ringid,
+      evt->status == WMI_BA_AGREED ? "OK" : "N/A",
+      evt->agg_wsize, __le16_to_cpu(evt->ba_timeout));
+
+ if (evt->ringid >= WIL6210_MAX_TX_RINGS) {
+  wil_err(wil, "invalid ring id %d\n", evt->ringid);
+  return;
+ }
+
+ cid = wil->vring2cid_tid[evt->ringid][0];
+ if (cid >= WIL6210_MAX_CID) {
+  wil_err(wil, "invalid CID %d for vring %d\n", cid, evt->ringid);
+  return;
+ }
+
+ sta = &wil->sta[cid];
+ if (sta->status == wil_sta_unused) {
+  wil_err(wil, "CID %d unused\n", cid);
+  return;
+ }
+
+ wil_dbg_wmi(wil, "BACK for CID %d %pM\n", cid, sta->addr);
+ for (i = 0; i < WIL_STA_TID_NUM; i++) {
+  struct wil_tid_ampdu_rx *r = sta->tid_rx[i];
+  sta->tid_rx[i] = NULL;
+  wil_tid_ampdu_rx_free(wil, r);
+  if ((evt->status == WMI_BA_AGREED) && evt->agg_wsize)
+   sta->tid_rx[i] = wil_tid_ampdu_rx_alloc(wil,
+      evt->agg_wsize, 0);
+ }
 }
 
 static const struct {
@@ -586,21 +659,27 @@ void wmi_recv_cmd(struct wil6210_priv *wil)
  u8 *cmd;
  void __iomem *src;
  ulong flags;
+ unsigned n;
 
  if (!test_bit(wil_status_reset_done, &wil->status)) {
   wil_err(wil, "Reset not completed\n");
   return;
  }
 
- for (;;) {
+ for (n = 0;; n++) {
   u16 len;
 
   r->head = ioread32(wil->csr + HOST_MBOX +
        offsetof(struct wil6210_mbox_ctl, rx.head));
-  if (r->tail == r->head)
+  if (r->tail == r->head) {
+   if (n == 0)
+    wil_dbg_wmi(wil, "No events?\n");
    return;
+  }
 
-  /* read cmd from tail */
+  wil_dbg_wmi(wil, "Mbox head %08x tail %08x\n",
+       r->head, r->tail);
+  /* read cmd descriptor from tail */
   wil_memcpy_fromio_32(&d_tail, wil->csr + HOSTADDR(r->tail),
          sizeof(struct wil6210_mbox_ring_desc));
   if (d_tail.sync == 0) {
@@ -608,13 +687,18 @@ void wmi_recv_cmd(struct wil6210_priv *wil)
    return;
   }
 
+  /* read cmd header from descriptor */
   if (0 != wmi_read_hdr(wil, d_tail.addr, &hdr)) {
    wil_err(wil, "Mbox evt at 0x%08x?\n",
     le32_to_cpu(d_tail.addr));
    return;
   }
-
   len = le16_to_cpu(hdr.len);
+  wil_dbg_wmi(wil, "Mbox evt %04x %04x %04x %02x\n",
+       le16_to_cpu(hdr.seq), len, le16_to_cpu(hdr.type),
+       hdr.flags);
+
+  /* read cmd buffer from descriptor */
   src = wmi_buffer(wil, d_tail.addr) +
         sizeof(struct wil6210_mbox_hdr);
   evt = kmalloc(ALIGN(offsetof(struct pending_wmi_event,
@@ -630,13 +714,15 @@ void wmi_recv_cmd(struct wil6210_priv *wil)
   iowrite32(0, wil->csr + HOSTADDR(r->tail) +
      offsetof(struct wil6210_mbox_ring_desc, sync));
   /* indicate */
-  wil_dbg_wmi(wil, "Mbox evt %04x %04x %04x %02x\n",
-       le16_to_cpu(hdr.seq), len, le16_to_cpu(hdr.type),
-       hdr.flags);
   if ((hdr.type == WIL_MBOX_HDR_TYPE_WMI) &&
       (len >= sizeof(struct wil6210_mbox_hdr_wmi))) {
-   wil_dbg_wmi(wil, "WMI event 0x%04x\n",
-        evt->event.wmi.id);
+   struct wil6210_mbox_hdr_wmi *wmi = &evt->event.wmi;
+   u16 id = le16_to_cpu(wmi->id);
+   u32 tstamp = le32_to_cpu(wmi->timestamp);
+   wil_dbg_wmi(wil, "WMI event 0x%04x MID %d @%d msec\n",
+        id, wmi->mid, tstamp);
+   trace_wil6210_wmi_event(wmi, &wmi[1],
+      len - sizeof(*wmi));
   }
   wil_hex_dump_wmi("evt ", DUMP_PREFIX_OFFSET, 16, 1,
      &evt->event.hdr, sizeof(hdr) + len, true);
@@ -657,6 +743,8 @@ void wmi_recv_cmd(struct wil6210_priv *wil)
    wil_dbg_wmi(wil, "queue_work -> %d\n", q);
   }
  }
+ if (n > 1)
+  wil_dbg_wmi(wil, "%s -> %d events processed\n", __func__, n);
 }
 
 int wmi_call(struct wil6210_priv *wil, u16 cmdid, void *buf, u16 len,
@@ -724,7 +812,8 @@ int wmi_pcp_start(struct wil6210_priv *wil, int bi, u8 wmi_nettype, u8 chan)
   .bcon_interval = cpu_to_le16(bi),
   .network_type = wmi_nettype,
   .disable_sec_offload = 1,
-  .channel = chan,
+  .channel = chan - 1,
+  .pcp_max_assoc_sta = WIL6210_MAX_CID,
  };
  struct {
   struct wil6210_mbox_hdr_wmi wmi;
@@ -734,8 +823,12 @@ int wmi_pcp_start(struct wil6210_priv *wil, int bi, u8 wmi_nettype, u8 chan)
  if (!wil->secure_pcp)
   cmd.disable_sec = 1;
 
+ /*
+  * Processing time may be huge, in case of secure AP it takes about
+  * 3500ms for FW to start AP
+  */
  rc = wmi_call(wil, WMI_PCP_START_CMDID, &cmd, sizeof(cmd),
-        WMI_PCP_STARTED_EVENTID, &reply, sizeof(reply), 100);
+        WMI_PCP_STARTED_EVENTID, &reply, sizeof(reply), 5000);
  if (rc)
   return rc;
 
@@ -829,40 +922,6 @@ int wmi_p2p_cfg(struct wil6210_priv *wil, int channel)
  return wmi_send(wil, WMI_P2P_CFG_CMDID, &cmd, sizeof(cmd));
 }
 
-int wmi_tx_eapol(struct wil6210_priv *wil, struct sk_buff *skb)
-{
- struct wmi_eapol_tx_cmd *cmd;
- struct ethhdr *eth;
- u16 eapol_len = skb->len - ETH_HLEN;
- void *eapol = skb->data + ETH_HLEN;
- uint i;
- int rc;
-
- skb_set_mac_header(skb, 0);
- eth = eth_hdr(skb);
- wil_dbg_wmi(wil, "EAPOL %d bytes to %pM\n", eapol_len, eth->h_dest);
- for (i = 0; i < ARRAY_SIZE(wil->vring_tx); i++) {
-  if (memcmp(wil->dst_addr[i], eth->h_dest, ETH_ALEN) == 0)
-   goto found_dest;
- }
-
- return -EINVAL;
-
- found_dest:
- /* find out eapol data & len */
- cmd = kzalloc(sizeof(*cmd) + eapol_len, GFP_KERNEL);
- if (!cmd)
-  return -EINVAL;
-
- memcpy(cmd->dst_mac, eth->h_dest, ETH_ALEN);
- cmd->eapol_len = cpu_to_le16(eapol_len);
- memcpy(cmd->eapol, eapol, eapol_len);
- rc = wmi_send(wil, WMI_EAPOL_TX_CMDID, cmd, sizeof(*cmd) + eapol_len);
- kfree(cmd);
-
- return rc;
-}
-
 int wmi_del_cipher_key(struct wil6210_priv *wil, u8 key_index,
          const void *mac_addr)
 {
@@ -913,6 +972,38 @@ int wmi_set_ie(struct wil6210_priv *wil, u8 type, u16 ie_len, const void *ie)
  return rc;
 }
 
+/**
+ * wmi_rxon - turn radio on/off
+ * @on:  turn on if true, off otherwise
+ *
+ * Only switch radio. Channel should be set separately.
+ * No timeout for rxon - radio turned on forever unless some other call
+ * turns it off
+ */
+int wmi_rxon(struct wil6210_priv *wil, bool on)
+{
+ int rc;
+ struct {
+  struct wil6210_mbox_hdr_wmi wmi;
+  struct wmi_listen_started_event evt;
+ } __packed reply;
+
+ wil_info(wil, "%s(%s)\n", __func__, on ? "on" : "off");
+
+ if (on) {
+  rc = wmi_call(wil, WMI_START_LISTEN_CMDID, NULL, 0,
+         WMI_LISTEN_STARTED_EVENTID,
+         &reply, sizeof(reply), 100);
+  if ((rc == 0) && (reply.evt.status != WMI_FW_STATUS_SUCCESS))
+   rc = -EINVAL;
+ } else {
+  rc = wmi_call(wil, WMI_DISCOVERY_STOP_CMDID, NULL, 0,
+         WMI_DISCOVERY_STOPPED_EVENTID, NULL, 0, 20);
+ }
+
+ return rc;
+}
+
 int wmi_rx_chain_add(struct wil6210_priv *wil, struct vring *vring)
 {
  struct wireless_dev *wdev = wil->wdev;
@@ -926,6 +1017,7 @@ int wmi_rx_chain_add(struct wil6210_priv *wil, struct vring *vring)
   },
   .mid = 0, /* TODO - what is it? */
   .decap_trans_type = WMI_DECAP_TYPE_802_3,
+  .reorder_type = WMI_RX_SW_REORDER,
  };
  struct {
   struct wil6210_mbox_hdr_wmi wmi;
@@ -944,6 +1036,12 @@ int wmi_rx_chain_add(struct wil6210_priv *wil, struct vring *vring)
   cmd.sniffer_cfg.phy_support =
    cpu_to_le32((wil->monitor_flags & MONITOR_FLAG_CONTROL)
         ? WMI_SNIFFER_CP : WMI_SNIFFER_DP);
+ } else {
+  /* Initialize offload (in non-sniffer mode).
+   * Linux IP stack always calculates IP checksum
+   * HW always calculate TCP/UDP checksum
+   */
+  cmd.l3_l4_ctrl |= (1 << L3_L4_CTRL_TCPIP_CHECKSUM_EN_POS);
  }
  /* typical time for secure PCP is 840ms */
  rc = wmi_call(wil, WMI_CFG_RX_CHAIN_CMDID, &cmd, sizeof(cmd),
@@ -987,6 +1085,18 @@ int wmi_get_temperature(struct wil6210_priv *wil, u32 *t_m, u32 *t_r)
  return 0;
 }
 
+int wmi_disconnect_sta(struct wil6210_priv *wil, const u8 *mac, u16 reason)
+{
+ struct wmi_disconnect_sta_cmd cmd = {
+  .disconnect_reason = cpu_to_le16(reason),
+ };
+ memcpy(cmd.dst_mac, mac, ETH_ALEN);
+
+ wil_dbg_wmi(wil, "%s(%pM, reason %d)\n", __func__, mac, reason);
+
+ return wmi_send(wil, WMI_DISCONNECT_STA_CMDID, &cmd, sizeof(cmd));
+}
+
 void wmi_event_flush(struct wil6210_priv *wil)
 {
  struct pending_wmi_event *evt, *t;
diff --git a/drivers/net/wireless/ath/wil6210/wmi.h b/drivers/net/wireless/ath/wil6210/wmi.h
index 50b8528..17334c8 100644
--- a/drivers/net/wireless/ath/wil6210/wmi.h
+++ b/drivers/net/wireless/ath/wil6210/wmi.h
@@ -28,7 +28,7 @@
 #define __WILOCITY_WMI_H__
 
 /* General */
-
+#define WILOCITY_MAX_ASSOC_STA (8)
 #define WMI_MAC_LEN  (6)
 #define WMI_PROX_RANGE_NUM (3)
 
@@ -219,15 +219,6 @@ struct wmi_disconnect_sta_cmd {
  __le16 disconnect_reason;
 } __packed;
 
-/*
- * WMI_RECONNECT_CMDID
- */
-struct wmi_reconnect_cmd {
- u8 channel;   /* hint */
- u8 reserved;
- u8 bssid[WMI_MAC_LEN];  /* mandatory if set */
-} __packed;
-
 
 /*
  * WMI_SET_PMK_CMDID
@@ -296,11 +287,13 @@ enum wmi_scan_type {
  WMI_LONG_SCAN  = 0,
  WMI_SHORT_SCAN  = 1,
  WMI_PBC_SCAN  = 2,
+ WMI_ACTIVE_SCAN  = 3,
+ WMI_DIRECT_SCAN  = 4,
 };
 
 struct wmi_start_scan_cmd {
- u8 reserved[8];
-
+ u8 direct_scan_mac_addr[6];
+ u8 reserved[2];
  __le32 home_dwell_time; /* Max duration in the home channel(ms) */
  __le32 force_scan_interval; /* Time interval between scans (ms)*/
  u8 scan_type;  /* wmi_scan_type */
@@ -332,6 +325,7 @@ struct wmi_probed_ssid_cmd {
  u8 ssid[WMI_MAX_SSID_LEN];
 } __packed;
 
+
 /*
  * WMI_SET_APPIE_CMDID
  * Add Application specified IE to a management frame
@@ -427,7 +421,7 @@ struct wmi_bcon_ctrl_cmd {
  __le16 frag_num;
  __le64 ss_mask;
  u8 network_type;
- u8 reserved;
+ u8 pcp_max_assoc_sta;
  u8 disable_sec_offload;
  u8 disable_sec;
 } __packed;
@@ -450,7 +444,7 @@ enum wmi_port_role {
 struct wmi_port_allocate_cmd {
  u8 mac[WMI_MAC_LEN];
  u8 port_role;
- u8 midid;
+ u8 mid;
 } __packed;
 
 /*
@@ -467,6 +461,7 @@ struct wmi_delete_port_cmd {
 enum wmi_discovery_mode {
  WMI_DISCOVERY_MODE_NON_OFFLOAD = 0,
  WMI_DISCOVERY_MODE_OFFLOAD = 1,
+ WMI_DISCOVERY_MODE_PEER2PEER = 2,
 };
 
 struct wmi_p2p_cfg_cmd {
@@ -493,7 +488,8 @@ struct wmi_power_mgmt_cfg_cmd {
  */
 struct wmi_pcp_start_cmd {
  __le16 bcon_interval;
- u8 reserved0[10];
+ u8 pcp_max_assoc_sta;
+ u8 reserved0[9];
  u8 network_type;
  u8 channel;
  u8 disable_sec_offload;
@@ -857,6 +853,7 @@ enum wmi_event_id {
  WMI_RF_MGMT_STATUS_EVENTID  = 0x1853,
  WMI_BF_SM_MGMT_DONE_EVENTID  = 0x1838,
  WMI_RX_MGMT_PACKET_EVENTID  = 0x1840,
+ WMI_TX_MGMT_PACKET_EVENTID  = 0x1841,
 
  /* Performance monitoring events */
  WMI_DATA_PORT_OPEN_EVENTID  = 0x1860,
@@ -1040,16 +1037,23 @@ enum wmi_disconnect_reason {
 struct wmi_disconnect_event {
  __le16 protocol_reason_status; /* reason code, see 802.11 spec. */
  u8 bssid[WMI_MAC_LEN];  /* set if known */
- u8 disconnect_reason;  /* see wmi_disconnect_reason_e */
- u8 assoc_resp_len;
- u8 assoc_info[0];
+ u8 disconnect_reason;  /* see wmi_disconnect_reason */
+ u8 assoc_resp_len;  /* not in use */
+ u8 assoc_info[0];  /* not in use */
 } __packed;
 
 /*
  * WMI_SCAN_COMPLETE_EVENTID
  */
+enum scan_status {
+ WMI_SCAN_SUCCESS = 0,
+ WMI_SCAN_FAILED  = 1,
+ WMI_SCAN_ABORTED = 2,
+ WMI_SCAN_REJECTED = 3,
+};
+
 struct wmi_scan_complete_event {
- __le32 status;
+ __le32 status; /* scan_status */
 } __packed;
 
 /*
@@ -1256,6 +1260,14 @@ struct wmi_rx_mgmt_info {
  u8 channel; /* From Radio MNGR */
 } __packed;
 
+
+/*
+ * WMI_TX_MGMT_PACKET_EVENTID
+ */
+struct wmi_tx_mgmt_packet_event {
+ u8 payload[0];
+} __packed;
+
 struct wmi_rx_mgmt_packet_event {
  struct wmi_rx_mgmt_info info;
  u8 payload[0];
diff --git a/include/linux/ath9k_platform.h b/include/linux/ath9k_platform.h
index fcdd81b..a495a95 100644
--- a/include/linux/ath9k_platform.h
+++ b/include/linux/ath9k_platform.h
@@ -32,8 +32,12 @@ struct ath9k_platform_data {
  u32 gpio_val;
 
  bool is_clk_25mhz;
+ bool tx_gain_buffalo;
+
  int (*get_mac_revision)(void);
  int (*external_reset)(void);
+
+ bool use_eeprom;
 };
 
 #endif /* _LINUX_ATH9K_PLATFORM_H */
-- 
1.7.1